ca65 V2.18 - Ubuntu 2.19-1
Main file   : 6x0xbios.asm
Current file: 6x0xbios.asm

000000r 1               
000000r 1               ;__6x0xbios__________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	BIOS for the 6502 6x0x Retrobrew Computers SBC
000000r 1               ;
000000r 1               ;	ORIGINALLY WRITTEN BY: DAN WERNER -- 1/1/2014
000000r 1               ; 	Code cleanup: Dan Werner -- 1/22/2023
000000r 1               ;
000000r 1               ; ** NOTE THAT THIS BIOS NEEDS PAGED MEMORY TO OPERATE
000000r 1               ; ** K17 MUST BE OPEN FOR PAGED MEMORY TO OPERATE ON THE 6502 CPU
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; CONFIGURATION
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               M6X0X_IOSPACE   = $E000
000000r 1               M6X0X_SHADOW_ROM = $F000
000000r 1               
000000r 1               ; PAGER
000000r 1               M6X0X_ACT_TASK  = M6X0X_IOSPACE+$A00
000000r 1               M6X0X_MAP_SETUP = M6X0X_IOSPACE+$A10
000000r 1               M6X0X_MAP_SPACE = M6X0X_IOSPACE+$A20
000000r 1               M6X0X_MMU_ENA   = M6X0X_IOSPACE+$A30
000000r 1               
000000r 1               ;
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;ZERO PAGE	ADDRESS			; FUNCTION
000000r 1               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 1               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 1               CONSOLE         = $3A           ; CURRENT CONSOLE
000000r 1               WORKPTR         = $3B           ; WORK POINTER FOR COMMAND PROCESSOR
000000r 1               JUMPPTR         = $3D           ; JUMP VECTOR FOR LOOKUP TABLE
000000r 1               TEMPWORD        = $3F           ;
000000r 1               TEMPWORD1       = $41           ;
000000r 1               TEMPWORD2       = $43           ;
000000r 1               TEMPBYTE        = $45           ;
000000r 1               ACC             = $46           ; ACC STORAGE
000000r 1               XREG            = $47           ; X REG STORAGE
000000r 1               YREG            = $48           ; Y REG STORAGE
000000r 1               PREG            = $49           ; CURRENT STACK POINTER
000000r 1               PC              = $4A           ; PROGRAM COUNTER
000000r 1               SPTR            = $4C           ; CPU STATUS REGISTER
000000r 1               CKSM            = $4D           ; CHECKSUM
000000r 1               BYTECT          = $4E           ; BYTE COUNT
000000r 1               STRPTR          = $4F           ;
000000r 1               
000000r 1               ; working memory for assembler -- only used during assembler operation
000000r 1               savx            = $1c
000000r 1               tmpc            = $1d
000000r 1               length          = $1f
000000r 1               wrap            = $26
000000r 1               aflg            = $28
000000r 1               acmd            = $2a
000000r 1               nemo            = $44
000000r 1               tmp0            = $c1
000000r 1               tmp2            = $c3
000000r 1               stage           = $0210         ; assembler stage area (SHARED WITH HOST BUFFER	)
000000r 1               hstbuf          = $0200         ; 0200-03ff host buffer
000000r 1               ;
000000r 1               ; DRIVER WORKING STORAGE
000000r 1               ;
000000r 1               INBUFFER        = $0400         ;
000000r 1               
000000r 1               DSKY_BUF        = $0500         ; Eight Bytes DSKY display buffer
000000r 1               DSKY_BUFLEN     = 8             ;
000000r 1               DSKY_HEXBUF     = $0508         ; Four Bytes DSKY hex buffer
000000r 1               DSKY_HEXBUFLEN  = 4             ;
000000r 1               sektrk          = $050C         ; seek track number
000000r 1               seksec          = $050E         ; seek sector number
000000r 1               debcyll         = $0510         ; DEBLOCKED CYLINDER LSB
000000r 1               debcylm         = $0511         ; DEBLOCKED CYLINDER MSB
000000r 1               debsehd         = $0512         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 1               Cdebcyll        = $0513         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 1               Cdebcylm        = $0514         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 1               Cdebsehd        = $0515         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 1               sekdsk          = $0516         ; seek disk number
000000r 1               dskcfg          = $0517         ; 16 bytes disk configuration table
000000r 1               DSKUNIT         = $0528         ; seek disk number
000000r 1               ST0             = $0529         ;
000000r 1               FLERR           = $052A         ;
000000r 1               FCMD            = $052B         ;
000000r 1               FLRETRY         = $052C         ;
000000r 1               FLRETRY1        = $052D         ;
000000r 1               FLATCH_STORE    = $052E         ;
000000r 1               PPIDETIMEOUT    = $052F         ; (word)
000000r 1               slicetmp        = $0531         ; (word)
000000r 1               PPIDEINDEX      = $0533
000000r 1               CURRENT_IDE_DRIVE = $0534
000000r 1               
000000r 1               
000000r 1                       .PC02
000000r 1                       .ORG    $C000
00C000  1                       .SEGMENT "DRIVERS"
00C000  1                       .INCLUDE "macro.asm"
00C000  2               ;__MACRO___________________________________________________________________________________________________________________
00C000  2               ;
00C000  2               ; 	Macros for the betterment of Mankind
00C000  2               ;________________________________________________________________________________________________________________________________
00C000  2               ;
00C000  2               
00C000  2               .macro          PRTS      message
00C000  2               .LOCAL p1
00C000  2               .LOCAL p2
00C000  2               .LOCAL p3
00C000  2               .LOCAL p4
00C000  2               .LOCAL p5
00C000  2                 .if     .paramcount <> 1
00C000  2                       .error  "Too few parameters for macro PRTS"
00C000  2                       .endif
00C000  2                       PHA
00C000  2                       PHX
00C000  2                       PHY
00C000  2                       LDX #$00
00C000  2               p1:
00C000  2                       LDA p4,x
00C000  2                       INX
00C000  2                       CMP #'$'
00C000  2                       BEQ p2
00C000  2                       JSR IOF_OUTCH
00C000  2                       JMP p1
00C000  2               p2:
00C000  2                       PLY
00C000  2                       plx
00C000  2                       pla
00C000  2                       JMP p5
00C000  2               p4:
00C000  2                       .BYTE message
00C000  2               p5:
00C000  2               .endmacro
00C000  2               
00C000  2               
00C000  2               
00C000  2               NEWLINE:
00C000  2  48                   PHA
00C001  2  DA                   PHX
00C002  2  5A                   PHY
00C003  2  A9 0D                LDA     #$0D
00C005  2  20 42 FA             JSR     IOF_OUTCH
00C008  2  A9 0A                LDA     #$0A
00C00A  2  20 42 FA             JSR     IOF_OUTCH
00C00D  2  7A                   PLY
00C00E  2  FA                   PLX
00C00F  2  68                   PLA
00C010  2  60                   RTS
00C011  2               
00C011  2               PRTDEC:
00C011  2  5A                   PHY
00C012  2  DA                   PHX
00C013  2  48                   PHA
00C014  2  A0 00                LDY     #00
00C016  2  A2 FF                LDX     #$FF
00C018  2  38                   SEC
00C019  2               PrDec100:
00C019  2  E8                   INX
00C01A  2  E9 64                SBC     #100
00C01C  2  B0 FB                BCS     PrDec100        ;Count how many 100s
00C01E  2  69 64                ADC     #100
00C020  2  20 3A C0             JSR     PrDecDigit      ;Print the 100s
00C023  2  A2 FF                LDX     #$FF
00C025  2  38                   SEC                     ;Prepare for subtraction
00C026  2               PrDec10:
00C026  2  E8                   INX
00C027  2  E9 0A                SBC     #10
00C029  2  B0 FB                BCS     PrDec10         ;Count how many 10s
00C02B  2  69 0A                ADC     #10
00C02D  2  20 3A C0             JSR     PrDecDigit      ;Print the 10s
00C030  2  AA                   TAX                     ;Pass 1s into X
00C031  2  A0 01                LDY     #1
00C033  2  20 3A C0             JSR     PrDecDigit      ;Print the 1s
00C036  2  68                   PLA
00C037  2  FA                   PLX
00C038  2  7A                   PLY
00C039  2  60                   RTS
00C03A  2               PrDecDigit:
00C03A  2  48                   PHA
00C03B  2  C0 00                CPY     #$00
00C03D  2  D0 09                BNE     PrDecDigit1
00C03F  2  8A                   TXA
00C040  2  A8                   TAY
00C041  2  C0 00                CPY     #$00
00C043  2  D0 03                BNE     PrDecDigit1
00C045  2  4C 4E C0             JMP     PrDecDigit2
00C048  2               PrDecDigit1:
00C048  2  8A                   TXA                     ;Save A, pass digit to A
00C049  2  09 30                ORA     #'0'
00C04B  2  20 42 FA             JSR     IOF_OUTCH       ;Convert to character and print it
00C04E  2               PrDecDigit2:
00C04E  2  68                   PLA
00C04F  2  60                   RTS                     ;Restore A and return
00C050  2               
00C050  1                       .INCLUDE "bios_options.asm"
00C050  2               ;__BIOS OPTIONS__________________________________________________________________________________________________________________
00C050  2               ;
00C050  2               ; 	Optional components are defined in this file
00C050  2               ;
00C050  2               ;________________________________________________________________________________________________________________________________
00C050  2               ;
00C050  2               
00C050  2               ; DSKY Type, choose one of the options listed
00C050  2               DSKY_OPTION     = 2             ; DSKY Type  1=ORIGINAL, 2=NG, 0=NONE
00C050  2               DSKYOSC         = 1000000       ; Set DSKY NG Osc frequency
00C050  2               
00C050  1                       .INCLUDE "bios_ppp_hd.asm"
00C050  2               ;__PARALLEL PORT PROP MASS STORAGE DRIVERS_______________________________________________________________________________________
00C050  2               ;
00C050  2               ; 	DOS/65 PARALLEL PORT PROP MASS STORAGE DRIVERS
00C050  2               ;
00C050  2               ;	Entry points:
00C050  2               ;		PPP_SOFT_RESET   - called during OS init
00C050  2               ;		PPP_READ_SECTOR  - read a sector from drive
00C050  2               ;		PPP_WRITE_SECTOR - write a sector to drive
00C050  2               ;               PPP_INITIALIZE   - INITIALIZE HARDWARE
00C050  2               ;________________________________________________________________________________________________________________________________
00C050  2               ;
00C050  2               
00C050  2               
00C050  2               ;*__PPP_READ_SECTOR___________________________________________________________________________________
00C050  2               ;*
00C050  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00C050  2               ;*
00C050  2               ;*____________________________________________________________________________________________________
00C050  2               PPP_READ_SECTOR:
00C050  2               
00C050  2               
00C050  2  AD 12 05             LDA     debsehd         ;
00C053  2  CD 15 05             CMP     Cdebsehd        ;
00C056  2  D0 13                BNE     PPP_READ_SECTOR_DIRTY
00C058  2  AD 10 05             LDA     debcyll         ;
00C05B  2  CD 13 05             CMP     Cdebcyll        ;
00C05E  2  D0 0B                BNE     PPP_READ_SECTOR_DIRTY
00C060  2  AD 11 05             LDA     debcylm         ;
00C063  2  CD 14 05             CMP     Cdebcylm        ;
00C066  2  D0 03                BNE     PPP_READ_SECTOR_DIRTY
00C068  2               
00C068  2  A9 00                LDA     #$00
00C06A  2  60                   RTS
00C06B  2               
00C06B  2               PPP_READ_SECTOR_DIRTY:
00C06B  2  AD 10 05             LDA     debcyll         ; STORE CURRENT PARMS
00C06E  2  8D 13 05             STA     Cdebcyll        ;
00C071  2  AD 11 05             LDA     debcylm         ;
00C074  2  8D 14 05             STA     Cdebcylm        ;
00C077  2  AD 12 05             LDA     debsehd         ;
00C07A  2  8D 15 05             STA     Cdebsehd        ;
00C07D  2               
00C07D  2               
00C07D  2  A9 14                LDA     #$14
00C07F  2  20 96 F4             JSR     SENDCMD
00C082  2               
00C082  2  AD 12 05             LDA     debsehd
00C085  2  20 AC F4             JSR     PUTBYTE
00C088  2  AD 10 05             LDA     debcyll
00C08B  2  20 AC F4             JSR     PUTBYTE
00C08E  2  AD 11 05             LDA     debcylm
00C091  2  20 AC F4             JSR     PUTBYTE
00C094  2  A9 00                LDA     #$00
00C096  2  20 AC F4             JSR     PUTBYTE
00C099  2               
00C099  2               
00C099  2  20 E7 F4             JSR     GETBYTE         ; GET RESULT
00C09C  2  C9 00                CMP     #$00
00C09E  2  D0 0B                BNE     PPP_READ_SECTOR_ERR
00C0A0  2               
00C0A0  2  A9 13                LDA     #$13
00C0A2  2  20 96 F4             JSR     SENDCMD
00C0A5  2  20 B9 C0             JSR     GETBUF
00C0A8  2  A9 00                LDA     #$00
00C0AA  2  60                   RTS
00C0AB  2               PPP_READ_SECTOR_ERR:
00C0AB  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C0AD  2  8D 15 05             STA     Cdebsehd        ;
00C0B0  2  8D 13 05             STA     Cdebcyll        ;
00C0B3  2  8D 14 05             STA     Cdebcylm        ;
00C0B6  2               
00C0B6  2  A9 02                LDA     #$02
00C0B8  2  60                   RTS
00C0B9  2               GETBUF:
00C0B9  2  A2 00                LDX     #$00
00C0BB  2               GETBUF1:
00C0BB  2  20 E7 F4             JSR     GETBYTE
00C0BE  2  9D 00 02             STA     hstbuf,X
00C0C1  2  E8                   INX
00C0C2  2  E0 00                CPX     #$00
00C0C4  2  D0 F5                BNE     GETBUF1
00C0C6  2               GETBUF2:
00C0C6  2  20 E7 F4             JSR     GETBYTE
00C0C9  2  9D 00 03             STA     hstbuf+256,X
00C0CC  2  E8                   INX
00C0CD  2  E0 00                CPX     #$00
00C0CF  2  D0 F5                BNE     GETBUF2
00C0D1  2  60                   RTS
00C0D2  2               
00C0D2  2               
00C0D2  2               ;*__PPP_WRITE_SECTOR__________________________________________________________________________________
00C0D2  2               ;*
00C0D2  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00C0D2  2               ;*
00C0D2  2               ;*____________________________________________________________________________________________________
00C0D2  2               PPP_WRITE_SECTOR:
00C0D2  2               ; WRITE A SECTOR
00C0D2  2  A9 12                LDA     #$12
00C0D4  2  20 96 F4             JSR     SENDCMD
00C0D7  2  20 19 C1             JSR     PUTBUF
00C0DA  2               
00C0DA  2  A9 15                LDA     #$15
00C0DC  2  20 96 F4             JSR     SENDCMD
00C0DF  2               
00C0DF  2  AD 12 05             LDA     debsehd
00C0E2  2  20 AC F4             JSR     PUTBYTE
00C0E5  2  AD 10 05             LDA     debcyll
00C0E8  2  20 AC F4             JSR     PUTBYTE
00C0EB  2  AD 11 05             LDA     debcylm
00C0EE  2  20 AC F4             JSR     PUTBYTE
00C0F1  2  A9 00                LDA     #$00
00C0F3  2  20 AC F4             JSR     PUTBYTE
00C0F6  2               
00C0F6  2  20 E7 F4             JSR     GETBYTE         ; GET RESULT
00C0F9  2  C9 00                CMP     #$00
00C0FB  2  D0 0E                BNE     PPP_WRITE_SECTOR_ERROR
00C0FD  2               
00C0FD  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C0FF  2  8D 13 05             STA     Cdebcyll        ;
00C102  2  8D 14 05             STA     Cdebcylm        ;
00C105  2  8D 15 05             STA     Cdebsehd        ;
00C108  2  A9 00                LDA     #$00
00C10A  2  60                   RTS
00C10B  2               PPP_WRITE_SECTOR_ERROR:
00C10B  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C10D  2  8D 15 05             STA     Cdebsehd        ;
00C110  2  8D 13 05             STA     Cdebcyll        ;
00C113  2  8D 14 05             STA     Cdebcylm        ;
00C116  2  A9 02                LDA     #$02
00C118  2  60                   RTS
00C119  2               PUTBUF:
00C119  2  A2 00                LDX     #$00
00C11B  2               PUTBUF1:
00C11B  2  BD 00 02             LDA     hstbuf,X
00C11E  2  20 AC F4             JSR     PUTBYTE
00C121  2  E8                   INX
00C122  2  E0 00                CPX     #$00
00C124  2  D0 F5                BNE     PUTBUF1
00C126  2               PUTBUF2:
00C126  2  BD 00 03             LDA     hstbuf+256,X
00C129  2  20 AC F4             JSR     PUTBYTE
00C12C  2  E8                   INX
00C12D  2  E0 00                CPX     #$00
00C12F  2  D0 F5                BNE     PUTBUF2
00C131  2  60                   RTS
00C132  2               
00C132  2               
00C132  2               ;*__PPP_SOFT_RESET____________________________________________________________________________________
00C132  2               ;*
00C132  2               ;*  SOFT RESET PPP CHANNEL
00C132  2               ;*
00C132  2               ;*____________________________________________________________________________________________________
00C132  2               PPP_SOFT_RESET:
00C132  2  A9 10                LDA     #$10
00C134  2  20 96 F4             JSR     SENDCMD
00C137  2  60                   RTS                     ;
00C138  2               
00C138  2               ;*__PPP_INITIALIZE____________________________________________________________________________________
00C138  2               ;*
00C138  2               ;*  INITIALIZE THE PPP SD DRIVERS
00C138  2               ;*
00C138  2               ;*____________________________________________________________________________________________________
00C138  2               PPP_INITIALIZE:
00C138  2  48 DA 5A A2          PRTS    "SD CARD: INITIALIZED$"; NOT PRESENT
00C13C  2  00 BD 51 C1  
00C140  2  E8 C9 24 F0  
00C166  2  20 00 C0             JSR     NEWLINE
00C169  2  4C 32 C1             JMP     PPP_SOFT_RESET
00C16C  2               
00C16C  1                       .INCLUDE "bios_diov3_flp.asm"
00C16C  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
00C16C  2               ;
00C16C  2               ; 	DOS/65 floppy drivers for direct attached disk-io V3 card
00C16C  2               ;
00C16C  2               ;	Entry points:
00C16C  2               ;		SETUPDRIVE  - called during OS init
00C16C  2               ;		FORMFL	    - format floppy disk ('U' POINTS TO DCB)
00C16C  2               ;		READFL	    - read a sector from drive ('U' POINTS TO DCB, X TO MEMORY)
00C16C  2               ;		WRITEFL	    - write a sector to drive   ('U' POINTS TO DCB, X TO MEMORY)
00C16C  2               ;
00C16C  2               ;________________________________________________________________________________________________________________________________
00C16C  2               ;
00C16C  2               
00C16C  2               
00C16C  2               
00C16C  2               ;*
00C16C  2               ;* HARDWARE I/O ADDRESSES
00C16C  2               ;*
00C16C  2               
00C16C  2               FMSR            = M6X0X_IOSPACE+$30; ADDRESS OF MAIN STATUS REGISTER
00C16C  2               FDATA           = M6X0X_IOSPACE+$31; FLOPPY DATA REGISTER
00C16C  2               FLATCH          = M6X0X_IOSPACE+$38; FLOPPY CONFIGURATION LATCH
00C16C  2               
00C16C  2               ;
00C16C  2               ; FDC CONFIGURATION LATCH OUTPUT BIT PATTERNS
00C16C  2               MOTOR           = %00000010     ; BIT PATTERN IN LATCH FOR MOTOR CONTROL (ON)
00C16C  2               TERMCN          = %00000001     ; BIT PATTERN IN LATCH TO WRITE A TC STROBE
00C16C  2               RESETL          = %00000000     ; BIT PATTERN IN LATCH TO RESET ALL BITS
00C16C  2               MINI            = %00000100     ; BIT PATTERN IN LATCH TO SET MINI MODE FDC9229 LOW DENS=1, HIGH DENS=0
00C16C  2               PRECOMP         = %00100000     ; BIT PATTERN IN LATCH TO SET WRITE PRECOMP 125 NS:
00C16C  2               FDDENSITY       = %01000000     ; BIT PATTERN IN LATCH TO FLOPPY LOW DENSITY (HIGH IS 1)
00C16C  2               FDREADY         = %10000000     ; BIT PATTERN IN LATCH TO FLOPPY READY (P-34):
00C16C  2               
00C16C  2               
00C16C  2               
00C16C  2               
00C16C  2               ;__SETUPDRIVE__________________________________________________________________________________________________________________________
00C16C  2               ;
00C16C  2               ;	SETUP FLOPPY DRIVE SETTINGS
00C16C  2               ;________________________________________________________________________________________________________________________________
00C16C  2               ;
00C16C  2               ;
00C16C  2               ;
00C16C  2               SETUPDRIVE:
00C16C  2  A9 00                LDA     #$00
00C16E  2  8D 38 E0             STA     FLATCH
00C171  2  A9 00                LDA     #RESETL         ; RESET SETTINGS
00C173  2  09 04                ORA     #MINI           ; SELECT MINI FLOPPY (low dens=1, high dens=0)
00C175  2  09 20                ORA     #PRECOMP        ; SELECT PRECOMP
00C177  2  09 40                ORA     #FDDENSITY      ; SELECT HIGH DENSITY
00C179  2  09 80                ORA     #FDREADY        ;
00C17B  2  8D 2E 05             STA     FLATCH_STORE    ; SAVE SETTINGS
00C17E  2  8D 38 E0             STA     FLATCH
00C181  2  20 25 C4             JSR     CHECKINT        ;
00C184  2  A9 03                LDA     #$03            ; SPECIFY COMMAND
00C186  2  20 E3 C3             JSR     PFDATA          ; OUTPUT TO FDC
00C189  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
00C18B  2  20 E3 C3             JSR     PFDATA          ; OUTPUT TO FDC
00C18E  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
00C190  2  20 E3 C3             JSR     PFDATA          ; OUTPUT TO FDC
00C193  2  20 25 C4             JSR     CHECKINT        ;
00C196  2  20 25 C4             JSR     CHECKINT        ;
00C199  2  20 25 C4             JSR     CHECKINT        ;
00C19C  2  20 25 C4             JSR     CHECKINT        ;
00C19F  2  20 25 C4             JSR     CHECKINT        ;
00C1A2  2  20 25 C4             JSR     CHECKINT        ;
00C1A5  2  20 B5 C3             JSR     RECAL           ;
00C1A8  2  A9 27                LDA     #39             ;
00C1AA  2  8D 10 05             STA     debcyll         ;
00C1AD  2  20 85 C3             JSR     SETTRACK
00C1B0  2  4C B5 C3             JMP     RECAL           ;
00C1B3  2               
00C1B3  2               ;__OUTFLATCH__________________________________________________________________________________________________________________________
00C1B3  2               ;
00C1B3  2               ;	SEND SETTINGS TO FLOPPY CONTROLLER
00C1B3  2               ;________________________________________________________________________________________________________________________________
00C1B3  2               ;
00C1B3  2               OUTFLATCH:
00C1B3  2  AD 2E 05             LDA     FLATCH_STORE    ; SET A TO SETTINGS
00C1B6  2  8D 38 E0             STA     FLATCH          ; OUTPUT TO CONTROLLER
00C1B9  2  60                   RTS
00C1BA  2               
00C1BA  2               
00C1BA  2               ;__READFL________________________________________________________________________________________________________________________
00C1BA  2               ;
00C1BA  2               ; 	READ A FLOPPY SECTOR
00C1BA  2               ;________________________________________________________________________________________________________________________________
00C1BA  2               ;
00C1BA  2               READFL:
00C1BA  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C1BD  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C1BF  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C1C2  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C1C5  2               
00C1C5  2  AD 10 05             LDA     debcyll         ;
00C1C8  2  CD 13 05             CMP     Cdebcyll        ;
00C1CB  2  D0 0B                BNE     READFL_DIRTY
00C1CD  2  AD 12 05             LDA     debsehd         ;
00C1D0  2  CD 15 05             CMP     Cdebsehd        ;
00C1D3  2  D0 03                BNE     READFL_DIRTY
00C1D5  2               
00C1D5  2  A9 00                LDA     #$00
00C1D7  2  60                   RTS
00C1D8  2               
00C1D8  2               
00C1D8  2               READFL_DIRTY:
00C1D8  2               
00C1D8  2  AD 10 05             LDA     debcyll         ;  STORE CURRENT PARMS
00C1DB  2  8D 13 05             STA     Cdebcyll        ;
00C1DE  2  AD 12 05             LDA     debsehd         ;
00C1E1  2  8D 15 05             STA     Cdebsehd        ;
00C1E4  2               
00C1E4  2               
00C1E4  2  A9 00                LDA     #$00
00C1E6  2  8D 2C 05             STA     FLRETRY
00C1E9  2  8D 2D 05             STA     FLRETRY1
00C1EC  2               READFL1:
00C1EC  2  A9 46                LDA     #$46            ; BIT 6 SETS MFM, 06H IS READ COMMAND
00C1EE  2  8D 2B 05             STA     FCMD
00C1F1  2  20 75 C2             JSR     DSKOP
00C1F4  2  C9 00                CMP     #$00
00C1F6  2  F0 28                BEQ     READFLDONE
00C1F8  2  EE 2C 05             INC     FLRETRY
00C1FB  2  AD 2C 05             LDA     FLRETRY
00C1FE  2  C9 06                CMP     #$06
00C200  2  D0 EA                BNE     READFL1
00C202  2  20 B5 C3             JSR     RECAL
00C205  2  20 85 C3             JSR     SETTRACK
00C208  2  A9 00                LDA     #$00
00C20A  2  8D 2C 05             STA     FLRETRY
00C20D  2  EE 2D 05             INC     FLRETRY1
00C210  2  AD 2D 05             LDA     FLRETRY1
00C213  2  C9 02                CMP     #$02
00C215  2  D0 D5                BNE     READFL1
00C217  2               
00C217  2  A9 FF                LDA     #$FF
00C219  2  8D 13 05             STA     Cdebcyll        ;
00C21C  2  8D 15 05             STA     Cdebsehd        ;
00C21F  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00C220  2               READFLDONE:
00C220  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00C222  2  60                   RTS
00C223  2               
00C223  2               ;__WRITEFL________________________________________________________________________________________________________________________
00C223  2               ;
00C223  2               ; 	WRITE A FLOPPY SECTOR
00C223  2               ;________________________________________________________________________________________________________________________________
00C223  2               ;
00C223  2               WRITEFL:
00C223  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C226  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C228  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C22B  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C22E  2               
00C22E  2  A9 FF                LDA     #$FF
00C230  2  8D 13 05             STA     Cdebcyll        ;
00C233  2  8D 15 05             STA     Cdebsehd        ;
00C236  2  A9 00                LDA     #$00
00C238  2  8D 2C 05             STA     FLRETRY
00C23B  2  8D 2D 05             STA     FLRETRY1
00C23E  2               WRITEFL1:
00C23E  2  A9 45                LDA     #$45            ; BIT 6 SETS MFM, 05H IS WRITE COMMAND
00C240  2  8D 2B 05             STA     FCMD
00C243  2  20 75 C2             JSR     DSKOP
00C246  2  C9 00                CMP     #$00
00C248  2  F0 D6                BEQ     READFLDONE
00C24A  2  EE 2C 05             INC     FLRETRY
00C24D  2  AD 2C 05             LDA     FLRETRY
00C250  2  C9 06                CMP     #$06
00C252  2  D0 EA                BNE     WRITEFL1
00C254  2  20 B5 C3             JSR     RECAL
00C257  2  20 85 C3             JSR     SETTRACK
00C25A  2  A9 00                LDA     #$00
00C25C  2  8D 2C 05             STA     FLRETRY
00C25F  2  EE 2D 05             INC     FLRETRY1
00C262  2  AD 2D 05             LDA     FLRETRY1
00C265  2  C9 02                CMP     #$02
00C267  2  D0 D5                BNE     WRITEFL1
00C269  2  A9 FF                LDA     #$FF            ;
00C26B  2  8D 13 05             STA     Cdebcyll        ;
00C26E  2  8D 15 05             STA     Cdebsehd        ;
00C271  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00C272  2               WRITEFLDONE:
00C272  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00C274  2  60                   RTS
00C275  2               
00C275  2               
00C275  2               ;__DSKOP__________________________________________________________________________________________________________________________
00C275  2               ;
00C275  2               ; 	PERFORM A DISK OPERATION
00C275  2               ;________________________________________________________________________________________________________________________________
00C275  2               ;
00C275  2               
00C275  2               DSKOP:
00C275  2  78                   SEI
00C276  2  20 25 C4             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
00C279  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
00C27B  2  F0 1B                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
00C27D  2               ;
00C27D  2               ;
00C27D  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C280  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C282  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C285  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C288  2               ;
00C288  2  20 85 C3             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
00C28B  2               ;
00C28B  2  AD 2B 05             LDA     FCMD            ; WHAT COMMAND IS PENDING?
00C28E  2  C9 46                CMP     #$46            ; IS IT A READ COMMAND?
00C290  2  D0 03                BNE     GWRR_POLL       ;
00C292  2  4C F8 C2             JMP     RDD_POLL        ;
00C295  2               GWRR_POLL:
00C295  2  4C 5B C3             JMP     WRR_POLL        ;
00C298  2               DSKEXIT:
00C298  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C29B  2  29 FD                AND     #%11111101      ; SET MOTOR OFF
00C29D  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C2A0  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C2A3  2  A9 FF                LDA     #$FF            ; SET -1 IF ERROR
00C2A5  2  58                   CLI
00C2A6  2  60                   RTS
00C2A7  2               
00C2A7  2               SNDFDWR:
00C2A7  2               
00C2A7  2  A0 00                LDY     #$00            ; BYTES/SECTOR COUNT
00C2A9  2  18                   CLC
00C2AA  2  AD 16 05             LDA     sekdsk          ; GET DISK UNIT NUMBER
00C2AD  2  29 03                AND     #$03            ; MASK FOR FOUR DRIVES.
00C2AF  2  8D 28 05             STA     DSKUNIT         ; PARK IT IN TEMP
00C2B2  2  AD 12 05             LDA     debsehd         ; GET HEAD SELECTION
00C2B5  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00C2B7  2  0A                   ASL     A               ;
00C2B8  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
00C2B9  2  0D 28 05             ORA     DSKUNIT         ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
00C2BC  2  8D 28 05             STA     DSKUNIT         ; STORE IN UNIT
00C2BF  2  AD 2B 05             LDA     FCMD            ;
00C2C2  2  20 E3 C3             JSR     PFDATA          ; PUSH COMMAND TO I8272
00C2C5  2  AD 28 05             LDA     DSKUNIT         ;
00C2C8  2  20 E3 C3             JSR     PFDATA          ;
00C2CB  2  AD 10 05             LDA     debcyll         ;
00C2CE  2  20 E3 C3             JSR     PFDATA          ;
00C2D1  2  AD 12 05             LDA     debsehd         ; GET HEAD SELECTION
00C2D4  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00C2D6  2  20 E3 C3             JSR     PFDATA          ;
00C2D9  2  18                   CLC                     ;
00C2DA  2  AD 12 05             LDA     debsehd         ;
00C2DD  2  4A                   LSR     A
00C2DE  2  69 01                ADC     #$01            ;
00C2E0  2  20 E3 C3             JSR     PFDATA          ;
00C2E3  2  A9 02                LDA     #$02            ;
00C2E5  2  20 E3 C3             JSR     PFDATA          ; WHAT DENSITY
00C2E8  2  A9 09                LDA     #$09            ;
00C2EA  2  20 E3 C3             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
00C2ED  2  A9 1B                LDA     #$1B            ;
00C2EF  2  20 E3 C3             JSR     PFDATA          ; WHAT GAP IS NEEDED
00C2F2  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
00C2F4  2  20 0C C4             JSR     PFDATAS
00C2F7  2  60                   RTS
00C2F8  2               ; PERFORM READ
00C2F8  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN.
00C2F8  2               ;
00C2F8  2               RDD_POLL:
00C2F8  2  20 A7 C2             JSR     SNDFDWR         ;
00C2FB  2               RDS1:
00C2FB  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C2FE  2  10 FB                BPL     RDS1
00C300  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C302  2  F0 1B                BEQ     DSKOPEND        ; NO, ERROR
00C304  2  AD 31 E0             LDA     FDATA           ; GET DATA
00C307  2  99 00 02             STA     hstbuf,Y        ; WRITE IT
00C30A  2  C8                   INY
00C30B  2  D0 EE                BNE     RDS1            ; KEEP GOING
00C30D  2               RDS2:
00C30D  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C310  2  10 FB                BPL     RDS2
00C312  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C314  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
00C316  2  AD 31 E0             LDA     FDATA           ; GET DATA
00C319  2  99 00 03             STA     hstbuf+256,Y    ; WRITE IT
00C31C  2  C8                   INY
00C31D  2  D0 EE                BNE     RDS2            ; KEEP GOING
00C31F  2               
00C31F  2               DSKOPEND:
00C31F  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C322  2  09 01                ORA     #%00000001      ;
00C324  2  8D 2E 05             STA     FLATCH_STORE    ; SET TC
00C327  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C32A  2  EA                   NOP                     ;
00C32B  2  EA                   NOP                     ; 2 MICROSECOND DELAY
00C32C  2  EA                   NOP                     ;
00C32D  2  EA                   NOP                     ;
00C32E  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C331  2  29 FE                AND     #%11111110      ;
00C333  2  8D 2E 05             STA     FLATCH_STORE    ; CLEAR TC
00C336  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C339  2  48                   PHA                     ;
00C33A  2  68                   PLA                     ;
00C33B  2  48                   PHA                     ;
00C33C  2  68                   PLA                     ; 2 MICROSECOND DELAY
00C33D  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C340  2  29 FD                AND     #%11111101      ; SET MOTOR OFF
00C342  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C345  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER					;
00C348  2               ;
00C348  2  20 5B C4             JSR     GFDATA          ;GET ERROR TYPE
00C34B  2  8D 2A 05             STA     FLERR
00C34E  2               
00C34E  2               ;* CLEAR OUT ANY REMAINING DATA
00C34E  2               RESUL3:
00C34E  2  20 5B C4             JSR     GFDATA          ;READ BYTE FROM FDC
00C351  2  C9 00                CMP     #$00
00C353  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
00C355  2  AD 2A 05             LDA     FLERR           ;
00C358  2  29 C0                AND     #%11000000      ;
00C35A  2  60                   RTS
00C35B  2               
00C35B  2               WRR_POLL:
00C35B  2  20 A7 C2             JSR     SNDFDWR         ;
00C35E  2               WRS1:   ;
00C35E  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C361  2  10 FB                BPL     WRS1            ; NOT READY
00C363  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C365  2  F0 1B                BEQ     WRS3            ; NO, ERROR
00C367  2  B9 00 02             LDA     hstbuf,Y        ; WRITE IT
00C36A  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C36D  2  C8                   INY
00C36E  2  D0 EE                BNE     WRS1            ; DO NEXT
00C370  2               WRS2:   ;
00C370  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C373  2  10 FB                BPL     WRS2            ; NOT READY
00C375  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C377  2  F0 09                BEQ     WRS3            ; NO, ERROR
00C379  2  B9 00 03             LDA     hstbuf+256,Y    ; WRITE IT
00C37C  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C37F  2  C8                   INY
00C380  2  D0 EE                BNE     WRS2            ; DO NEXT
00C382  2               WRS3:
00C382  2  4C 1F C3             JMP     DSKOPEND        ;
00C385  2               
00C385  2               
00C385  2               ;__SETTRACK__________________________________________________________________________________________________________________________
00C385  2               ;
00C385  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
00C385  2               ; 	A: TRACK #
00C385  2               ;________________________________________________________________________________________________________________________________
00C385  2               ;
00C385  2               SETTRACK:
00C385  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C388  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C38A  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C38D  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C390  2               
00C390  2               ; ANY INTERUPT PENDING
00C390  2               ; IF YES FIND OUT WHY/CLEAR
00C390  2  20 25 C4             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
00C393  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
00C395  2  D0 03                BNE     SETTRK1
00C397  2  4C E2 C3             JMP     SETTRKEXIT      ;
00C39A  2               
00C39A  2               ;
00C39A  2               SETTRK1:
00C39A  2  AD 10 05             LDA     debcyll         ; GET TRACK
00C39D  2  C9 00                CMP     #$00            ;
00C39F  2  F0 14                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
00C3A1  2  A9 0F                LDA     #$0F            ; SEEK COMMAND
00C3A3  2  20 E3 C3             JSR     PFDATA          ; PUSH COMMAND
00C3A6  2  AD 16 05             LDA     sekdsk          ; SAY WHICH UNIT
00C3A9  2  20 E3 C3             JSR     PFDATA          ; SEND THAT
00C3AC  2  AD 10 05             LDA     debcyll         ; TO WHAT TRACK
00C3AF  2  20 E3 C3             JSR     PFDATA          ; SEND THAT TOO
00C3B2  2  4C CB C3             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
00C3B5  2               RECAL:
00C3B5  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C3B8  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C3BA  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C3BD  2  20 B3 C1             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C3C0  2               
00C3C0  2  A9 07                LDA     #$07            ; RECAL TO TRACK 0
00C3C2  2  20 E3 C3             JSR     PFDATA          ; SEND IT
00C3C5  2  AD 16 05             LDA     sekdsk          ; WHICH UNIT
00C3C8  2  20 E3 C3             JSR     PFDATA          ; SEND THAT TOO
00C3CB  2               ;
00C3CB  2               WAINT:
00C3CB  2  48                   PHA
00C3CC  2  8A                   TXA
00C3CD  2  48                   PHA
00C3CE  2  A2 00                LDX     #$00
00C3D0  2               WAINT1:
00C3D0  2  E8                   INX
00C3D1  2  E0 FF                CPX     #$FF
00C3D3  2  D0 FB                BNE     WAINT1
00C3D5  2  68                   PLA
00C3D6  2  AA                   TAX
00C3D7  2  68                   PLA
00C3D8  2               ;
00C3D8  2               SETTRK2:
00C3D8  2  20 25 C4             JSR     CHECKINT
00C3DB  2  AD 30 E0             LDA     FMSR            ; READ SEEK STATUS
00C3DE  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
00C3E0  2  D0 F6                BNE     SETTRK2         ; YES, WAIT FOR THEM
00C3E2  2               ;
00C3E2  2               SETTRKEXIT:
00C3E2  2  60                   RTS
00C3E3  2               
00C3E3  2               ;__PFDATA__________________________________________________________________________________________________________________________
00C3E3  2               ;
00C3E3  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
00C3E3  2               ;
00C3E3  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
00C3E3  2               ;	RQM  DIO
00C3E3  2               ;	0	0	BUSY
00C3E3  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C3E3  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C3E3  2               ;	0	1	BUSY
00C3E3  2               ;
00C3E3  2               ;________________________________________________________________________________________________________________________________
00C3E3  2               ;
00C3E3  2               PFDATA:
00C3E3  2  48                   PHA                     ; SAVE DATA BYTE
00C3E4  2               WRF1:
00C3E4  2  AD 30 E0             LDA     FMSR            ; READ FDC STATUS
00C3E7  2  AA                   TAX
00C3E8  2  29 80                AND     #$80            ;
00C3EA  2  F0 F8                BEQ     WRF1            ; FDC IS NOT READY, WAIT FOR IT
00C3EC  2  8A                   TXA
00C3ED  2  29 40                AND     #$40            ; TEST DIO BIT
00C3EF  2  D0 15                BNE     WRF2            ; FDC IS OUT OF SYNC
00C3F1  2  68                   PLA                     ; RESTORE DATA
00C3F2  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C3F5  2               
00C3F5  2  48                   PHA
00C3F6  2  68                   PLA
00C3F7  2  48                   PHA
00C3F8  2  68                   PLA
00C3F9  2  48                   PHA
00C3FA  2  68                   PLA
00C3FB  2  48                   PHA
00C3FC  2  68                   PLA
00C3FD  2  48                   PHA
00C3FE  2  68                   PLA
00C3FF  2  48                   PHA
00C400  2  68                   PLA
00C401  2  48                   PHA
00C402  2  68                   PLA
00C403  2  48                   PHA
00C404  2  68                   PLA
00C405  2               
00C405  2  60                   RTS
00C406  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00C406  2               WRF2:
00C406  2  AD 31 E0             LDA     FDATA           ; READ DATA REGISTER
00C409  2  4C E4 C3             JMP     WRF1            ; AND CONTINUE
00C40C  2               
00C40C  2               ;__PFDATAS_________________________________________________________________________________________________________________________
00C40C  2               ;
00C40C  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
00C40C  2               ;
00C40C  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
00C40C  2               ;	RQM  DIO
00C40C  2               ;	0	0	BUSY
00C40C  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C40C  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C40C  2               ;	0	1	BUSY
00C40C  2               ;
00C40C  2               ;________________________________________________________________________________________________________________________________
00C40C  2               ;
00C40C  2               PFDATAS:
00C40C  2  48                   PHA                     ; SAVE DATA BYTE
00C40D  2               WRF1S:
00C40D  2  AD 30 E0             LDA     FMSR            ; READ FDC STATUS
00C410  2  AA                   TAX
00C411  2  29 80                AND     #$80            ;
00C413  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
00C415  2  8A                   TXA
00C416  2  29 40                AND     #$40            ; TEST DIO BIT
00C418  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
00C41A  2  68                   PLA                     ; RESTORE DATA
00C41B  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C41E  2  60                   RTS
00C41F  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00C41F  2               WRF2S:
00C41F  2  AD 31 E0             LDA     FDATA           ; READ DATA REGISTER
00C422  2  4C 0D C4             JMP     WRF1S           ; AND CONTINUE
00C425  2               
00C425  2               
00C425  2               
00C425  2               ;__CHECKINT__________________________________________________________________________________________________________________________
00C425  2               ;
00C425  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
00C425  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
00C425  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
00C425  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
00C425  2               ;________________________________________________________________________________________________________________________________
00C425  2               ;
00C425  2               CHECKINT:
00C425  2  AD 30 E0             LDA     FMSR            ; READING OR WRITING IS KEYS TO D7 RQM
00C428  2  29 80                AND     #$80
00C42A  2  F0 F9                BEQ     CHECKINT        ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
00C42C  2  AD 30 E0             LDA     FMSR            ; READING OR WRITING IS KEYS TO D7 RQM
00C42F  2  29 40                AND     #$40            ; WAITING FOR INPUT?
00C431  2  F0 0E                BEQ     SENDINT
00C433  2  60                   RTS
00C434  2               
00C434  2               ERRCLR:
00C434  2  AD 31 E0             LDA     FDATA           ; CLEAR THE JUNK OUT OF DATA REGISTER
00C437  2  AD 30 E0             LDA     FMSR            ; CHECK WITH RQM
00C43A  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
00C43C  2  F0 F6                BEQ     ERRCLR          ;
00C43E  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
00C440  2               ;
00C440  2  60                   RTS
00C441  2               
00C441  2               ;__SENDINT__________________________________________________________________________________________________________________________
00C441  2               ;
00C441  2               ; SENSE INTERRUPT COMMAND
00C441  2               ;________________________________________________________________________________________________________________________________
00C441  2               ;
00C441  2               SENDINT:
00C441  2  A9 08                LDA     #$08            ; SENSE INTERRUPT COMMAND
00C443  2  20 E3 C3             JSR     PFDATA          ; SEND IT
00C446  2  20 5B C4             JSR     GFDATA          ; GET RESULTS
00C449  2  8D 29 05             STA     ST0             ; STORE THAT
00C44C  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
00C44E  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
00C450  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
00C452  2  20 5B C4             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
00C455  2  AD 29 05             LDA     ST0             ; GET FIRST ONE
00C458  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
00C45A  2               ENDSENDINT:
00C45A  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
00C45B  2               
00C45B  2               
00C45B  2               ;__GFDATA__________________________________________________________________________________________________________________________
00C45B  2               ;
00C45B  2               ; GET DATA FROM FLOPPY CONTROLLER
00C45B  2               ;
00C45B  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
00C45B  2               ;	RQM  DIO
00C45B  2               ;	0	0	BUSY
00C45B  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C45B  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C45B  2               ;	0	1	BUSY
00C45B  2               ;
00C45B  2               ;________________________________________________________________________________________________________________________________
00C45B  2               ;
00C45B  2               GFDATA:
00C45B  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C45E  2  AA                   TAX                     ;
00C45F  2  29 80                AND     #%10000000      ; NOT READY, WAIT
00C461  2  F0 F8                BEQ     GFDATA          ;
00C463  2  8A                   TXA
00C464  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
00C466  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
00C468  2  AD 31 E0             LDA     FDATA           ; GET FDC DATA
00C46B  2               GFDATA1:
00C46B  2  60                   RTS
00C46C  2               
00C46C  1                       .INCLUDE "bios_diov3_ide.asm"
00C46C  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00C46C  2               ;
00C46C  2               ; 	DOS/65 DISK DRIVERS FOR DIRECT ATTACHED DISK-IO V3 CARD
00C46C  2               ;
00C46C  2               ;	ENTRY POINTS:
00C46C  2               ;		IDE_SOFT_RESET   - CALLED DURING OS INIT
00C46C  2               ;		IDE_READ_SECTOR  - READ A SECTOR FROM DRIVE  ('U' POINTS TO DCB, X TO MEMORY)
00C46C  2               ;		IDE_WRITE_SECTOR - WRITE A SECTOR TO DRIVE   ('U' POINTS TO DCB, X TO MEMORY)
00C46C  2               ;               IDE_INITIALIZE   - DETECT AND INITIALIZE HARDWARE
00C46C  2               ;________________________________________________________________________________________________________________________________
00C46C  2               ;
00C46C  2               PPIDELO         = M6X0X_IOSPACE+$20; DATA PORT (LOW BYTE)
00C46C  2               PPIDEHI         = M6X0X_IOSPACE+$21; DATA PORT (HIGH BYTE)
00C46C  2               PPIDECNTRL      = M6X0X_IOSPACE+$22; IDE CONTROL
00C46C  2               PPIDEPPIC       = M6X0X_IOSPACE+$23; PPI CONTROL
00C46C  2               
00C46C  2               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
00C46C  2               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
00C46C  2               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
00C46C  2               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C46C  2               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C46C  2               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C46C  2               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C46C  2               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C46C  2               
00C46C  2               PPIDE_DATA      = PPIDE_CS0_LINE
00C46C  2               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
00C46C  2               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
00C46C  2               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C46C  2               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
00C46C  2               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
00C46C  2               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00C46C  2               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C46C  2               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C46C  2               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00C46C  2               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C46C  2               
00C46C  2               
00C46C  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00C46C  2               PPIDE_CMD_RECAL = $10
00C46C  2               PPIDE_CMD_READ  = $20
00C46C  2               PPIDE_CMD_WRITE = $30
00C46C  2               PPIDE_CMD_INIT  = $91
00C46C  2               PPIDE_CMD_ID    = $EC
00C46C  2               PPIDE_CMD_SPINDOWN = $E0
00C46C  2               PPIDE_CMD_SPINUP = $E1
00C46C  2               
00C46C  2               
00C46C  2               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00C46C  2               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
00C46C  2               
00C46C  2               
00C46C  2               
00C46C  2               
00C46C  2               ;__PPIDE_INIT_________________________________________________________________________________________
00C46C  2               ;
00C46C  2               ;  INIT AND DISPLAY IDE INFO
00C46C  2               ;____________________________________________________________________________________________________
00C46C  2               ;
00C46C  2               PPIDE_INIT:
00C46C  2  48 DA 5A A2          PRTS    "PPIDE :$"
00C470  2  00 BD 85 C4  
00C474  2  E8 C9 24 F0  
00C48D  2  20 00 C0             JSR     NEWLINE
00C490  2  20 23 C6             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
00C493  2  D0 35                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
00C495  2               ;
00C495  2  48 DA 5A A2          PRTS    " IO=0x$"
00C499  2  00 BD AE C4  
00C49D  2  E8 C9 24 F0  
00C4B5  2  A9 E0                LDA     #>PPIDELO       ; GET BASE PORT
00C4B7  2  20 47 F9             JSR     PRINT_BYTE      ; PRINT BASE PORT
00C4BA  2  A9 20                LDA     #<PPIDELO       ; GET BASE PORT
00C4BC  2  20 47 F9             JSR     PRINT_BYTE      ; PRINT BASE PORT
00C4BF  2               ;
00C4BF  2  20 A8 C6             JSR     PPIDE_RESET     ; RESET THE BUS
00C4C2  2  20 58 C5             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
00C4C5  2  B0 03                BCS     IDE_ABORT
00C4C7  2  4C F3 C4             JMP     IDE_PRINT_INFO
00C4CA  2               IDE_ABORT:
00C4CA  2  48 DA 5A A2          PRTS    " NOT PRESENT$" ; NOT PRESENT
00C4CE  2  00 BD E3 C4  
00C4D2  2  E8 C9 24 F0  
00C4F0  2  4C 54 C5             JMP     IDE_INITA
00C4F3  2               IDE_PRINT_INFO:
00C4F3  2  20 00 C0             JSR     NEWLINE
00C4F6  2  48 DA 5A A2          PRTS    " PPIDE0: Blocks=$"
00C4FA  2  00 BD 0F C5  
00C4FE  2  E8 C9 24 F0  
00C520  2  A9 00                LDA     #$00
00C522  2  20 98 C5             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00C525  2  48 DA 5A A2          PRTS    " PPIDE1: Blocks=$"
00C529  2  00 BD 3E C5  
00C52D  2  E8 C9 24 F0  
00C54F  2  A9 01                LDA     #$01
00C551  2  20 98 C5             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00C554  2               IDE_INITA:
00C554  2  20 00 C0             JSR     NEWLINE
00C557  2  60                   RTS                     ; DONE
00C558  2               ;
00C558  2               ;__PPIDE_PROBE_______________________________________________________________________________________
00C558  2               ;
00C558  2               ;  PROBE FOR IDE HARDWARE
00C558  2               ;____________________________________________________________________________________________________
00C558  2               ;
00C558  2               PPIDE_PROBE:
00C558  2               ;
00C558  2               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
00C558  2               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
00C558  2               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
00C558  2               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
00C558  2               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
00C558  2               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
00C558  2               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
00C558  2               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
00C558  2               
00C558  2  A9 00                LDA     #$00
00C55A  2  8D 20 E0             STA     PPIDELO         ; PPI PORT A, DATALO
00C55D  2               
00C55D  2  20 D0 C6             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
00C560  2  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
00C562  2  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
00C564  2  20 C7 C7             JSR     IDE_READ
00C567  2  8A                   TXA
00C568  2  29 40                AND     #%01000000
00C56A  2  C9 00                CMP     #$00
00C56C  2  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
00C56E  2               
00C56E  2               ; CHECK SIGNATURE
00C56E  2  A9 0A                LDA     #PPIDE_SEC_CNT
00C570  2  20 C7 C7             JSR     IDE_READ
00C573  2  E0 01                CPX     #$01
00C575  2  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
00C577  2  A9 0B                LDA     #PPIDE_LBALOW
00C579  2  20 C7 C7             JSR     IDE_READ
00C57C  2  E0 01                CPX     #$01
00C57E  2  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
00C580  2  A9 0C                LDA     #PPIDE_LBAMID
00C582  2  20 C7 C7             JSR     IDE_READ
00C585  2  E0 00                CPX     #$00
00C587  2  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
00C589  2  A9 0D                LDA     #PPIDE_LBAHI
00C58B  2  20 C7 C7             JSR     IDE_READ
00C58E  2  E0 00                CPX     #$00
00C590  2  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
00C592  2  18                   CLC
00C593  2  4C 97 C5             JMP     PPIDE_PROBE_SUCCESS
00C596  2               PPIDE_PROBE_FAIL:
00C596  2  38                   SEC
00C597  2               PPIDE_PROBE_SUCCESS:
00C597  2  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
00C598  2               
00C598  2               
00C598  2               
00C598  2               ;*__IDE_READ_INFO___________________________________________________________________________________
00C598  2               ;*
00C598  2               ;*  READ IDE INFORMATION
00C598  2               ;*	CARRY SET ON ERROR
00C598  2               ;* 	A=MST/SLV
00C598  2               ;*____________________________________________________________________________________________________
00C598  2               IDE_READ_INFO:
00C598  2  48                   PHA
00C599  2               ; SET DRIVE BIT
00C599  2  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
00C59B  2  0A                   ASL     a               ; SHIFT 4
00C59C  2  0A                   ASL     a               ;
00C59D  2  0A                   ASL     a               ;
00C59E  2  0A                   ASL     a               ;
00C59F  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
00C5A1  2  AA                   TAX
00C5A2  2  A0 00                LDY     #$00
00C5A4  2  A9 0E                LDA     #PPIDE_DEVICE
00C5A6  2  20 E3 C7             JSR     IDE_WRITE
00C5A9  2               
00C5A9  2               
00C5A9  2  20 D0 C6             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C5AC  2  B0 49                BCS     IDE_READ_INFO_ABORT
00C5AE  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
00C5B0  2  A2 EC                LDX     #PPIDE_CMD_ID
00C5B2  2  20 E3 C7             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
00C5B5  2  20 F8 C6             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
00C5B8  2  B0 3D                BCS     IDE_READ_INFO_ABORT
00C5BA  2  20 28 C7             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
00C5BD  2  48 DA 5A A2          PRTS    "0x$"
00C5C1  2  00 BD D6 C5  
00C5C5  2  E8 C9 24 F0  
00C5D9  2  AD 7B 02             LDA     hstbuf+123
00C5DC  2  20 47 F9             JSR     PRINT_BYTE
00C5DF  2  AD 7A 02             LDA     hstbuf+122
00C5E2  2  20 47 F9             JSR     PRINT_BYTE
00C5E5  2  AD 79 02             LDA     hstbuf+121
00C5E8  2  20 47 F9             JSR     PRINT_BYTE
00C5EB  2  AD 78 02             LDA     hstbuf+120
00C5EE  2  20 47 F9             JSR     PRINT_BYTE
00C5F1  2  20 00 C0             JSR     NEWLINE
00C5F4  2  68                   PLA
00C5F5  2  18                   CLC
00C5F6  2  60                   RTS
00C5F7  2               
00C5F7  2               IDE_READ_INFO_ABORT:
00C5F7  2  48 DA 5A A2          PRTS    " NOT PRESENT$" ; NOT PRESENT
00C5FB  2  00 BD 10 C6  
00C5FF  2  E8 C9 24 F0  
00C61D  2  20 00 C0             JSR     NEWLINE
00C620  2  68                   PLA
00C621  2  38                   SEC
00C622  2  60                   RTS
00C623  2               
00C623  2               ;__IDE_PPIDETECT____________________________________________________________________________________
00C623  2               ;
00C623  2               ;  PROBE FOR PPI HARDWARE
00C623  2               ;____________________________________________________________________________________________________
00C623  2               ;
00C623  2               IDE_PPIDETECT:
00C623  2               ;
00C623  2               ; TEST FOR PPI EXISTENCE
00C623  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00C623  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00C623  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00C623  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00C623  2               ; INTERFERE WITH THE VALUE BEING READ.
00C623  2  20 07 C8             JSR     SET_PPI_WR
00C626  2               ;
00C626  2  A9 00                LDA     #$00            ; VALUE ZERO
00C628  2  8D 20 E0             STA     PPIDELO         ; PUSH VALUE TO PORT
00C62B  2  AD 20 E0             LDA     PPIDELO         ; GET PORT VALUE
00C62E  2  C9 00                CMP     #$00
00C630  2  60                   RTS                     ; AND RETURN
00C631  2               ;
00C631  2               
00C631  2               
00C631  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
00C631  2               ;*
00C631  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00C631  2               ;*
00C631  2               ;*____________________________________________________________________________________________________
00C631  2               IDE_READ_SECTOR:
00C631  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
00C634  2  CD 15 05             CMP     Cdebsehd        ;
00C637  2  D0 13                BNE     IDE_READ_SECTOR_DIRTY
00C639  2  AD 11 05             LDA     debcylm         ;
00C63C  2  CD 14 05             CMP     Cdebcylm        ;
00C63F  2  D0 0B                BNE     IDE_READ_SECTOR_DIRTY
00C641  2  AD 10 05             LDA     debcyll         ;
00C644  2  CD 13 05             CMP     Cdebcyll        ;
00C647  2  D0 03                BNE     IDE_READ_SECTOR_DIRTY
00C649  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
00C64B  2  60                   RTS
00C64C  2               
00C64C  2               IDE_READ_SECTOR_DIRTY:
00C64C  2  20 D0 C6             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C64F  2  B0 27                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C651  2               IDE_READ_SECTOR_DIRTY1:
00C651  2  20 94 C7             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
00C654  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
00C656  2  A2 20                LDX     #PPIDE_CMD_READ
00C658  2  20 E3 C7             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
00C65B  2  20 F8 C6             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
00C65E  2  B0 18                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C660  2  20 28 C7             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
00C663  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
00C666  2  8D 15 05             STA     Cdebsehd        ;
00C669  2  AD 10 05             LDA     debcyll         ;
00C66C  2  8D 13 05             STA     Cdebcyll        ;
00C66F  2  AD 11 05             LDA     debcylm         ;
00C672  2  8D 14 05             STA     Cdebcylm        ;
00C675  2               
00C675  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
00C677  2  60                   RTS
00C678  2               IDE_READ_SECTOR_DIRTY_ERROR:
00C678  2  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
00C67A  2  60                   RTS
00C67B  2               
00C67B  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
00C67B  2               ;*
00C67B  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00C67B  2               ;*
00C67B  2               ;*____________________________________________________________________________________________________
00C67B  2               IDE_WRITE_SECTOR:
00C67B  2  20 D0 C6             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C67E  2  B0 25                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C680  2               IDE_WRITE_SECTOR_RAW:
00C680  2  20 94 C7             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
00C683  2  A9 0F                LDA     #PPIDE_COMMAND
00C685  2  A2 30                LDX     #PPIDE_CMD_WRITE
00C687  2  20 E3 C7             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
00C68A  2  20 F8 C6             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
00C68D  2  B0 16                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C68F  2  20 5D C7             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
00C692  2  20 D0 C6             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
00C695  2  B0 0E                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C697  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C699  2  8D 15 05             STA     Cdebsehd        ;
00C69C  2  8D 13 05             STA     Cdebcyll        ;
00C69F  2  8D 14 05             STA     Cdebcylm        ;
00C6A2  2               
00C6A2  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
00C6A4  2  60                   RTS
00C6A5  2               IDE_WRITE_SECTOR_ERROR:
00C6A5  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
00C6A7  2  60                   RTS
00C6A8  2               
00C6A8  2               ;*__PPIDE_RESET____________________________________________________________________________________
00C6A8  2               ;*
00C6A8  2               ;*  SOFT RESET IDE CHANNEL
00C6A8  2               ;*
00C6A8  2               ;*____________________________________________________________________________________________________
00C6A8  2               PPIDE_RESET:
00C6A8  2  A9 00                LDA     #$00
00C6AA  2  8D 12 05             STA     debsehd
00C6AD  2  8D 10 05             STA     debcyll
00C6B0  2  8D 11 05             STA     debcylm
00C6B3  2  A9 FF                LDA     #$FF            ;
00C6B5  2  8D 15 05             STA     Cdebsehd        ;
00C6B8  2  8D 13 05             STA     Cdebcyll        ;
00C6BB  2  8D 14 05             STA     Cdebcylm        ;
00C6BE  2               
00C6BE  2  A9 80                LDA     #PPIDE_RST_LINE
00C6C0  2  8D 22 E0             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
00C6C3  2  A2 00                LDX     #$00
00C6C5  2               RST_DLY:
00C6C5  2  CA                   DEX
00C6C6  2  E0 00                CPX     #$00
00C6C8  2  D0 FB                BNE     RST_DLY
00C6CA  2  A9 00                LDA     #$00
00C6CC  2  8D 22 E0             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
00C6CF  2  60                   RTS
00C6D0  2               
00C6D0  2               
00C6D0  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
00C6D0  2               ;*
00C6D0  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
00C6D0  2               ;*
00C6D0  2               ;*____________________________________________________________________________________________________
00C6D0  2               IDE_WAIT_NOT_BUSY:
00C6D0  2  DA                   PHX
00C6D1  2  5A                   PHY
00C6D2  2  48                   PHA
00C6D3  2  A9 00                LDA     #$00
00C6D5  2  8D 2F 05             STA     PPIDETIMEOUT
00C6D8  2  8D 30 05             STA     PPIDETIMEOUT+1
00C6DB  2               IDE_WAIT_NOT_BUSY1:
00C6DB  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
00C6DD  2  20 C7 C7             JSR     IDE_READ
00C6E0  2  8A                   TXA
00C6E1  2  29 80                AND     #$80
00C6E3  2  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
00C6E5  2  EE 2F 05             INC     PPIDETIMEOUT
00C6E8  2  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
00C6EA  2  EE 30 05             INC     PPIDETIMEOUT+1
00C6ED  2  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
00C6EF  2  38                   SEC
00C6F0  2  4C F4 C6             JMP     IDE_WAIT_NOT_BUSY3
00C6F3  2               IDE_WAIT_NOT_BUSY2:
00C6F3  2  18                   CLC
00C6F4  2               IDE_WAIT_NOT_BUSY3:
00C6F4  2  68                   PLA
00C6F5  2  7A                   PLY
00C6F6  2  FA                   PLX
00C6F7  2  60                   RTS
00C6F8  2               
00C6F8  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
00C6F8  2               ;*
00C6F8  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
00C6F8  2               ;*
00C6F8  2               ;*____________________________________________________________________________________________________
00C6F8  2               IDE_WAIT_DRQ:
00C6F8  2  DA                   PHX
00C6F9  2  5A                   PHY
00C6FA  2  48                   PHA
00C6FB  2  A9 00                LDA     #$00
00C6FD  2  8D 2F 05             STA     PPIDETIMEOUT
00C700  2  8D 30 05             STA     PPIDETIMEOUT+1
00C703  2               IDE_WAIT_DRQ1:
00C703  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
00C705  2  20 C7 C7             JSR     IDE_READ
00C708  2  8A                   TXA
00C709  2  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
00C70B  2  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
00C70D  2  F0 14                BEQ     IDE_WAIT_DRQ2
00C70F  2  29 01                AND     #%00000001      ; IS ERROR?
00C711  2  C9 01                CMP     #%00000001      ;
00C713  2  F0 0A                BEQ     IDE_WAIT_DRQE
00C715  2  EE 2F 05             INC     PPIDETIMEOUT
00C718  2  D0 E9                BNE     IDE_WAIT_DRQ1
00C71A  2  EE 30 05             INC     PPIDETIMEOUT+1
00C71D  2  D0 E4                BNE     IDE_WAIT_DRQ1
00C71F  2               IDE_WAIT_DRQE:
00C71F  2  38                   SEC
00C720  2  4C 24 C7             JMP     IDE_WAIT_DRQ3
00C723  2               IDE_WAIT_DRQ2:
00C723  2  18                   CLC
00C724  2               IDE_WAIT_DRQ3:
00C724  2  68                   PLA
00C725  2  7A                   PLY
00C726  2  FA                   PLX
00C727  2  60                   RTS
00C728  2               
00C728  2               
00C728  2               
00C728  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
00C728  2               ;*
00C728  2               ;*  READ IDE BUFFER LITTLE ENDIAN
00C728  2               ;*
00C728  2               ;*____________________________________________________________________________________________________
00C728  2               IDE_READ_BUFFER:
00C728  2  A2 00                LDX     #$00            ; INDEX
00C72A  2               IDEBUFRD:
00C72A  2  8E 33 05             STX     PPIDEINDEX
00C72D  2  A9 08                LDA     #PPIDE_DATA
00C72F  2  20 C7 C7             JSR     IDE_READ
00C732  2  8A                   TXA
00C733  2  AE 33 05             LDX     PPIDEINDEX
00C736  2  9D 00 02             STA     hstbuf,X        ;
00C739  2  E8                   INX                     ;
00C73A  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
00C73B  2  9D 00 02             STA     hstbuf,X        ;
00C73E  2  E8                   INX
00C73F  2  E0 00                CPX     #$00            ;
00C741  2  D0 E7                BNE     IDEBUFRD        ;
00C743  2               IDEBUFRD1:
00C743  2  8E 33 05             STX     PPIDEINDEX
00C746  2  A9 08                LDA     #PPIDE_DATA
00C748  2  20 C7 C7             JSR     IDE_READ
00C74B  2  8A                   TXA
00C74C  2  AE 33 05             LDX     PPIDEINDEX
00C74F  2  9D 00 03             STA     hstbuf+256,X    ;
00C752  2  E8                   INX                     ;
00C753  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
00C754  2  9D 00 03             STA     hstbuf+256,X    ;
00C757  2  E8                   INX                     ;
00C758  2  E0 00                CPX     #$00            ;
00C75A  2  D0 E7                BNE     IDEBUFRD1       ;
00C75C  2  60                   RTS                     ;
00C75D  2               
00C75D  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
00C75D  2               ;*
00C75D  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
00C75D  2               ;*
00C75D  2               ;*____________________________________________________________________________________________________
00C75D  2               IDE_WRITE_BUFFER:
00C75D  2  A2 00                LDX     #$00            ; INDEX
00C75F  2               IDEBUFWT:
00C75F  2  8E 33 05             STX     PPIDEINDEX
00C762  2  BD 01 02             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
00C765  2  A8                   TAY                     ;
00C766  2  BD 00 02             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
00C769  2  AA                   TAX
00C76A  2  A9 08                LDA     #PPIDE_DATA
00C76C  2  20 E3 C7             JSR     IDE_WRITE
00C76F  2  AE 33 05             LDX     PPIDEINDEX
00C772  2  E8                   INX                     ;
00C773  2  E8                   INX                     ;
00C774  2  E0 00                CPX     #$00            ;
00C776  2  D0 E7                BNE     IDEBUFWT        ;
00C778  2  A2 00                LDX     #$00            ; INDEX
00C77A  2               IDEBUFWT1:
00C77A  2  8E 33 05             STX     PPIDEINDEX
00C77D  2  BD 01 03             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
00C780  2  A8                   TAY
00C781  2  BD 00 03             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
00C784  2  AA                   TAX
00C785  2  A9 08                LDA     #PPIDE_DATA
00C787  2  20 E3 C7             JSR     IDE_WRITE
00C78A  2  AE 33 05             LDX     PPIDEINDEX
00C78D  2  E8                   INX                     ;
00C78E  2  E8                   INX                     ;
00C78F  2  E0 00                CPX     #$00            ;
00C791  2  D0 E7                BNE     IDEBUFWT1       ;
00C793  2  60                   RTS                     ;
00C794  2               
00C794  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
00C794  2               ;*
00C794  2               ;*  SETUP LBA DATA
00C794  2               ;*  A= DRIVE DEVICE
00C794  2               ;*____________________________________________________________________________________________________
00C794  2               IDE_SETUP_LBA:
00C794  2  AD 34 05             LDA     CURRENT_IDE_DRIVE
00C797  2  29 01                AND     #$01            ; only want drive cfg
00C799  2  0A                   ASL     a               ; SHIFT 4
00C79A  2  0A                   ASL     a               ;
00C79B  2  0A                   ASL     a               ;
00C79C  2  0A                   ASL     a               ;
00C79D  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
00C79F  2  AA                   TAX
00C7A0  2  A0 00                LDY     #$00
00C7A2  2  A9 0E                LDA     #PPIDE_DEVICE
00C7A4  2  20 E3 C7             JSR     IDE_WRITE
00C7A7  2               
00C7A7  2  AE 11 05             LDX     debcylm
00C7AA  2  A9 0D                LDA     #PPIDE_LBAHI
00C7AC  2  20 E3 C7             JSR     IDE_WRITE
00C7AF  2               
00C7AF  2  AE 10 05             LDX     debcyll         ;
00C7B2  2  A9 0C                LDA     #PPIDE_LBAMID
00C7B4  2  20 E3 C7             JSR     IDE_WRITE
00C7B7  2               
00C7B7  2  AE 12 05             LDX     debsehd         ;
00C7BA  2  A9 0B                LDA     #PPIDE_LBALOW
00C7BC  2  20 E3 C7             JSR     IDE_WRITE
00C7BF  2               
00C7BF  2  A2 01                LDX     #$01
00C7C1  2  A9 0A                LDA     #PPIDE_SEC_CNT
00C7C3  2  20 E3 C7             JSR     IDE_WRITE
00C7C6  2               
00C7C6  2  60                   RTS
00C7C7  2               
00C7C7  2               
00C7C7  2               ;-------------------------------------------------------------------------------
00C7C7  2               
00C7C7  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
00C7C7  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
00C7C7  2               ; PROGRAM WOULD NOT CALL TO THESE.
00C7C7  2               
00C7C7  2               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
00C7C7  2               ;INPUT A = IDE REGSITER ADDRESS
00C7C7  2               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
00C7C7  2               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
00C7C7  2               
00C7C7  2               IDE_READ:
00C7C7  2  20 FF C7             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
00C7CA  2  8D 22 E0             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
00C7CD  2  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
00C7CF  2  8D 22 E0             STA     PPIDECNTRL
00C7D2  2  AE 20 E0             LDX     PPIDELO         ; READ LOWER BYTE
00C7D5  2  AC 21 E0             LDY     PPIDEHI         ; READ UPPER BYTE
00C7D8  2  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
00C7DA  2  8D 22 E0             STA     PPIDECNTRL
00C7DD  2  A9 00                LDA     #$00
00C7DF  2  8D 22 E0             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
00C7E2  2  60                   RTS
00C7E3  2               
00C7E3  2               
00C7E3  2               
00C7E3  2               
00C7E3  2               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
00C7E3  2               ;INPUT A = IDE REGISTER ADDRESS
00C7E3  2               ;INPUT REGISTER X = LSB TO WRITE
00C7E3  2               ;INPUT REGISTER Y = MSB TO WRITE
00C7E3  2               ;
00C7E3  2               
00C7E3  2               
00C7E3  2               IDE_WRITE:
00C7E3  2  20 07 C8             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
00C7E6  2               
00C7E6  2  8E 20 E0             STX     PPIDELO         ; WRITE LOWER BYTE
00C7E9  2  8C 21 E0             STY     PPIDEHI         ; WRITE UPPER BYTE
00C7EC  2               
00C7EC  2  8D 22 E0             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
00C7EF  2               
00C7EF  2  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
00C7F1  2  8D 22 E0             STA     PPIDECNTRL
00C7F4  2               
00C7F4  2  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
00C7F6  2  8D 22 E0             STA     PPIDECNTRL
00C7F9  2               
00C7F9  2  A9 00                LDA     #$00
00C7FB  2  8D 22 E0             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
00C7FE  2  60                   RTS
00C7FF  2               
00C7FF  2               
00C7FF  2               ;-----------------------------------------------------------------------------------
00C7FF  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
00C7FF  2               ;
00C7FF  2               ;------------------------------------------------------------------------------------
00C7FF  2               
00C7FF  2               SET_PPI_RD:
00C7FF  2  48                   PHA
00C800  2  A9 92                LDA     #PPRD_IDE_8255
00C802  2  8D 23 E0             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
00C805  2  68                   PLA
00C806  2  60                   RTS
00C807  2               
00C807  2               SET_PPI_WR:
00C807  2  48                   PHA
00C808  2  A9 80                LDA     #PPWR_IDE_8255
00C80A  2  8D 23 E0             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
00C80D  2  68                   PLA
00C80E  2  60                   RTS
00C80F  2               
00C80F  1                       .INCLUDE "bios_clrdir.asm"
00C80F  2               ;__CLRDIR_______________________________________________________
00C80F  2               ;
00C80F  2               ; Clear Device Tracks
00C80F  2               ; USAGE:
00C80F  2               ;
00C80F  2               ; CLRDIR  D TTTTTT NN
00C80F  2               ; D     = Device (I)DE Primary (J)IDE Secondary or (S)D
00C80F  2               ; TTTTTT= Starting Track
00C80F  2               ; NN    = Number of Tracks
00C80F  2               ;______________________________________________________________
00C80F  2               CLRDIR:
00C80F  2               
00C80F  2  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00C811  2  85 3B                STA     WORKPTR         ;
00C813  2  A9 04                LDA     #>INBUFFER      ;
00C815  2  85 3C                STA     WORKPTR +1      ;
00C817  2               
00C817  2  A9 06                LDA     #6
00C819  2  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "CLRDIR"
00C81C  2               
00C81C  2  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00C81F  2  A2 00                LDX     #$00            ;
00C821  2               
00C821  2  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT BYTE FROM BUFFER
00C823  2  C9 49                CMP     #'I'            ; IDE Selected
00C825  2  D0 0B                BNE     :+
00C827  2  A9 00                LDA     #$00
00C829  2  8D 16 05             STA     sekdsk
00C82C  2  8D 34 05             STA     CURRENT_IDE_DRIVE
00C82F  2  4C 52 C8             JMP     clrdir_gettrk
00C832  2               :
00C832  2  C9 4A                CMP     #'J'            ; IDE SECONDARY Selected
00C834  2  D0 0D                BNE     :+
00C836  2  A9 00                LDA     #$00
00C838  2  8D 16 05             STA     sekdsk
00C83B  2  A9 01                LDA     #$01
00C83D  2  8D 34 05             STA     CURRENT_IDE_DRIVE
00C840  2  4C 52 C8             JMP     clrdir_gettrk
00C843  2               :
00C843  2  C9 53                CMP     #'S'            ; SD  Selected
00C845  2  D0 08                BNE     :+
00C847  2  A9 01                LDA     #$01
00C849  2  8D 16 05             STA     sekdsk
00C84C  2  4C 52 C8             JMP     clrdir_gettrk
00C84F  2               :
00C84F  2  4C 93 C8             JMP     clrdir_err1
00C852  2               clrdir_gettrk:
00C852  2  20 B1 F8             JSR     INCWORKPTR      ;
00C855  2  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00C858  2  20 25 F9             JSR     HEXIN
00C85B  2  B0 41                BCS     clrdir_err
00C85D  2  2A                   ROL     A
00C85E  2  2A                   ROL     A
00C85F  2  2A                   ROL     A
00C860  2  2A                   ROL     A
00C861  2  8D 11 05             STA     debcylm
00C864  2  20 B1 F8             JSR     INCWORKPTR      ;
00C867  2  20 25 F9             JSR     HEXIN
00C86A  2  B0 32                BCS     clrdir_err
00C86C  2  0D 11 05             ORA     debcylm
00C86F  2  8D 11 05             STA     debcylm
00C872  2  20 B1 F8             JSR     INCWORKPTR      ;
00C875  2  20 E4 F8             JSR     GETNUMBER
00C878  2  B0 24                BCS     clrdir_err
00C87A  2  A5 40                LDA     TEMPWORD+1
00C87C  2  8D 10 05             STA     debcyll
00C87F  2  A5 3F                LDA     TEMPWORD
00C881  2  8D 12 05             STA     debsehd
00C884  2  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00C887  2               ;       get number of tracks to process
00C887  2  20 E4 F8             JSR     GETNUMBER
00C88A  2  B0 12                BCS     clrdir_err
00C88C  2  A5 3F                LDA     TEMPWORD
00C88E  2  85 4E                STA     BYTECT
00C890  2  4C A1 C8             JMP     clrdir_CLRBUF
00C893  2               clrdir_err1:
00C893  2  A9 E1                LDA     #<ERROR         ; LOAD LOW BYTE OF ERROR STRING
00C895  2  85 4F                STA     STRPTR          ; STORE IN POINTER LOW BYTE
00C897  2  A9 FB                LDA     #>ERROR         ; LOAD HOGH BYTE OF ERROR STRING
00C899  2  85 50                STA     STRPTR +1       ; STORE IN POINTER HIGH BYTE
00C89B  2  4C 62 F9             JMP     OUTSTR          ; OUTPUT THE STRING
00C89E  2               clrdir_err:
00C89E  2  4C D9 F8             JMP     INVALID_NUMBER_ERROR
00C8A1  2               clrdir_CLRBUF:
00C8A1  2               ;       clear buffer
00C8A1  2  A9 E5                LDA     #$e5
00C8A3  2  A2 00                LDX     #$00
00C8A5  2               :
00C8A5  2  9D 00 02             STA     $200,X
00C8A8  2  9D 00 03             STA     $300,X
00C8AB  2  E8                   INX
00C8AC  2  E0 00                CPX     #00
00C8AE  2  D0 F5                BNE     :-
00C8B0  2               
00C8B0  2               clrdir_Loopl:
00C8B0  2  AD 10 05             LDA     debcyll
00C8B3  2  20 47 F9             JSR     PRINT_BYTE
00C8B6  2  A9 2E                LDA     #'.'
00C8B8  2  20 42 FA             JSR     IOF_OUTCH
00C8BB  2               
00C8BB  2               clrdir_Loop:
00C8BB  2  AD 16 05             LDA     sekdsk
00C8BE  2  C9 00                CMP     #$00
00C8C0  2  F0 06                BEQ     :+
00C8C2  2  20 D2 C0             JSR     PPP_WRITE_SECTOR
00C8C5  2  4C CB C8             JMP     :++
00C8C8  2               :
00C8C8  2  20 7B C6             JSR     IDE_WRITE_SECTOR
00C8CB  2               :
00C8CB  2  EE 12 05             INC     debsehd
00C8CE  2  AD 12 05             LDA     debsehd
00C8D1  2  C9 00                CMP     #$00
00C8D3  2  D0 E6                BNE     clrdir_Loop
00C8D5  2  EE 10 05             INC     debcyll
00C8D8  2  C6 4E                DEC     BYTECT
00C8DA  2  A5 4E                LDA     BYTECT
00C8DC  2  C9 00                CMP     #$00
00C8DE  2  F0 03                BEQ     clrdir_EXIT
00C8E0  2  4C B0 C8             JMP     clrdir_Loopl
00C8E3  2               clrdir_EXIT:
00C8E3  2  A9 0D                LDA     #$0d
00C8E5  2  20 42 FA             JSR     IOF_OUTCH
00C8E8  2  A9 0A                LDA     #$0a
00C8EA  2  20 42 FA             JSR     IOF_OUTCH
00C8ED  2  60                   RTS
00C8EE  2               
00C8EE  1                       .INCLUDE "bios_rtc.asm"
00C8EE  2               
00C8EE  2               
00C8EE  2               ;__RTC DRIVERS___________________________________________________________________________________________________________________
00C8EE  2               ;
00C8EE  2               ; 	DOS REAL TIME CLOCK drivers
00C8EE  2               ;
00C8EE  2               ;	Entry points:
00C8EE  2               ;		DOSREADRTC   - called to RETURN RTC
00C8EE  2               ;________________________________________________________________________________________________________________________________
00C8EE  2               ;
00C8EE  2               ;*
00C8EE  2               ;* HARDWARE I/O ADDRESSES
00C8EE  2               ;*
00C8EE  2               RTCDDRD         = M6X0X_IOSPACE+$D02
00C8EE  2               RTCPORTD        = M6X0X_IOSPACE+$D00
00C8EE  2               
00C8EE  2               mask_data       = $20           ; RTC data line
00C8EE  2               mask_clk        = $40           ; RTC Serial Clock line
00C8EE  2               mask_ce         = $10           ; De-activate RTC reset line
00C8EE  2               
00C8EE  2               ;__RTC_WRITE____________________________________________________
00C8EE  2               ; write a value to the DS1302
00C8EE  2               ; address in X
00C8EE  2               ; value in Y
00C8EE  2               ;_______________________________________________________________
00C8EE  2               RTC_WRITE:
00C8EE  2  48                   PHA
00C8EF  2  78                   SEI                     ; disable interrupts during critical section
00C8F0  2  20 D0 C9             JSR     RTC_RESET_OFF   ; turn off RTC reset
00C8F3  2  8A                   TXA                     ; bring into A the address from D
00C8F4  2  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
00C8F6  2  18                   CLC
00C8F7  2  0A                   ASL     A
00C8F8  2  18                   CLC
00C8F9  2  69 80                ADC     #%10000000      ; set MSB to one for DS1302 COMMAND BYTE (WRITE)
00C8FB  2  20 40 C9             JSR     RTC_WR          ; write address to DS1302
00C8FE  2  98                   TYA                     ; start processing value
00C8FF  2  20 40 C9             JSR     RTC_WR          ; write address to DS1302
00C902  2  20 BF C9             JSR     RTC_RESET_ON    ; turn on RTC reset
00C905  2  58                   CLI
00C906  2  68                   PLA
00C907  2  60                   RTS
00C908  2               
00C908  2               ;__RTC_READ______________________________________________________
00C908  2               ; read a value from the DS1302
00C908  2               ; address in X
00C908  2               ; value in Y
00C908  2               ;_______________________________________________________________
00C908  2               RTC_READ:
00C908  2  48                   PHA
00C909  2  78                   SEI                     ; disable interrupts during critical section
00C90A  2  20 D0 C9             JSR     RTC_RESET_OFF   ; turn off RTC reset
00C90D  2  8A                   TXA                     ; bring into A the address from D
00C90E  2  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
00C910  2  18                   CLC
00C911  2  0A                   ASL     A               ; rotate address bits to the left
00C912  2  18                   CLC
00C913  2  69 81                ADC     #%10000001      ; set MSB to one for DS1302 COMMAND BYTE (READ)
00C915  2  20 40 C9             JSR     RTC_WR          ; write address to DS1302
00C918  2  20 79 C9             JSR     RTC_RD          ; read value from DS1302 (value is in reg A)
00C91B  2  A8                   TAY
00C91C  2  20 BF C9             JSR     RTC_RESET_ON    ; turn on RTC reset
00C91F  2  58                   CLI
00C920  2  68                   PLA
00C921  2  60                   RTS
00C922  2               
00C922  2               ;_______________________________________________________________
00C922  2               ; function RTC_RESET
00C922  2               ;   Output a RTC reset signal
00C922  2               ;_______________________________________________________________
00C922  2               RTC_RESET:
00C922  2  48                   PHA
00C923  2  A9 70                LDA     #$70
00C925  2  8D 02 ED             STA     RTCDDRD
00C928  2  A9 20                LDA     #mask_data
00C92A  2  8D 00 ED             STA     RTCPORTD
00C92D  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C930  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C933  2  A9 30                LDA     #mask_data + mask_ce
00C935  2  8D 00 ED             STA     RTCPORTD
00C938  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C93B  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C93E  2  68                   PLA
00C93F  2  60                   RTS
00C940  2               
00C940  2               ;_______________________________________________________________
00C940  2               ;
00C940  2               ; RTC Internal Functions
00C940  2               ;_______________________________________________________________
00C940  2               RTC_WR:
00C940  2  85 41                STA     TEMPWORD1       ; save accumulator as it is the DATA
00C942  2  A9 70                LDA     #$70
00C944  2  8D 02 ED             STA     RTCDDRD
00C947  2  A2 00                LDX     #$00            ; set X index counter of FOR loop
00C949  2               RTC_WR1:
00C949  2  A5 41                LDA     TEMPWORD1
00C94B  2               
00C94B  2  29 01                AND     #$01
00C94D  2               
00C94D  2  C9 00                CMP     #$00            ; is LSB a 0 or 1?
00C94F  2  F0 10                BEQ     RTC_WR2         ; if it�s a 0, handle it at RTC_WR2.
00C951  2               ; LSB is a 1, handle it below
00C951  2               ; setup RTC latch with RST and DATA high, SCLK low
00C951  2  A9 30                LDA     #mask_ce + mask_data
00C953  2  8D 00 ED             STA     RTCPORTD
00C956  2  20 B2 C9             JSR     RTC_BIT_DELAY   ; let it settle a while
00C959  2               ; setup RTC with RST, DATA, and SCLK high
00C959  2  A9 70                LDA     #mask_ce + mask_clk + mask_data
00C95B  2  8D 00 ED             STA     RTCPORTD
00C95E  2  4C 6E C9             JMP     RTC_WR3         ; exit FOR loop
00C961  2               
00C961  2               RTC_WR2:
00C961  2               ; LSB is a 0, handle it below
00C961  2  A9 10                LDA     #mask_ce        ; setup RTC latch with RST high, SCLK and DATA low
00C963  2  8D 00 ED             STA     RTCPORTD        ; output to RTC latch
00C966  2  20 B2 C9             JSR     RTC_BIT_DELAY   ; let it settle a while
00C969  2               ; setup RTC with RST and SCLK high, DATA low
00C969  2  A9 50                LDA     #mask_ce + mask_clk
00C96B  2  8D 00 ED             STA     RTCPORTD
00C96E  2               
00C96E  2               RTC_WR3:
00C96E  2  20 B2 C9             JSR     RTC_BIT_DELAY   ; let it settle a while
00C971  2  46 41                LSR     TEMPWORD1       ; move next bit into LSB position for processing to RTC
00C973  2  E8                   INX                     ; increment A in FOR loop (A=A+1)
00C974  2  E0 08                CPX     #$08            ; is A < $08 ?
00C976  2  D0 D1                BNE     RTC_WR1         ; No, do FOR loop again
00C978  2  60                   RTS                     ; Yes, end function and return
00C979  2               
00C979  2               
00C979  2               ; function RTC_RD
00C979  2               ; output value in A
00C979  2               ; uses X
00C979  2               RTC_RD:
00C979  2  A9 50                LDA     #$50
00C97B  2  8D 02 ED             STA     RTCDDRD
00C97E  2  A2 00                LDX     #$00            ; set X index counter of FOR loop
00C980  2               
00C980  2  A9 00                LDA     #$00            ; set A=0 output of RTC_RD is passed in A
00C982  2  85 41                STA     TEMPWORD1
00C984  2  A9 01                LDA     #$01            ; mask value
00C986  2  85 43                STA     TEMPWORD2
00C988  2               RTC_RD1:
00C988  2               ; setup RTC with RST and RD high, SCLK low
00C988  2  A9 10                LDA     #mask_ce
00C98A  2  8D 00 ED             STA     RTCPORTD
00C98D  2  20 B2 C9             JSR     RTC_BIT_DELAY   ; let it settle a while
00C990  2  AD 00 ED             LDA     RTCPORTD        ; input from RTC latch
00C993  2  29 20                AND     #$20            ; is  0 or 1?
00C995  2  C9 00                CMP     #$00
00C997  2  F0 07                BEQ     RTC_RD2         ; if is a 0, handle it below
00C999  2  A5 43                LDA     TEMPWORD2
00C99B  2  18                   CLC
00C99C  2  65 41                ADC     TEMPWORD1
00C99E  2  85 41                STA     TEMPWORD1
00C9A0  2               ; if LSB is a 0, skip it (C=C+0)
00C9A0  2               RTC_RD2:
00C9A0  2  06 43                ASL     TEMPWORD2       ; SHIFT MASK
00C9A2  2  A9 50                LDA     #mask_ce + mask_clk
00C9A4  2  8D 00 ED             STA     RTCPORTD
00C9A7  2  20 B2 C9             JSR     RTC_BIT_DELAY   ; let it settle
00C9AA  2  E8                   INX                     ; increment FOR loop (A=A+1)
00C9AB  2  E0 08                CPX     #$08            ; is A < $08 ?
00C9AD  2  D0 D9                BNE     RTC_RD1         ; No, do FOR loop again
00C9AF  2  A5 41                LDA     TEMPWORD1
00C9B1  2  60                   RTS                     ; Yes, end function and return.  Read RTC value is in C
00C9B2  2               
00C9B2  2               RTC_BIT_DELAY:                  ; purpose is to delay ~36 uS
00C9B2  2               ; (6) JSR INTO
00C9B2  2  48                   PHA                     ; 3
00C9B3  2  A9 02                LDA     #$02            ; 2  (1 REP AT 1 MHZ 6 REPS AT 2MHZ)
00C9B5  2  85 3F                STA     TEMPWORD        ; 3
00C9B7  2               RTC_BIT_DELAY1:
00C9B7  2  C6 3F                DEC     TEMPWORD        ;5
00C9B9  2  D0 FC                BNE     RTC_BIT_DELAY1  ;3
00C9BB  2               
00C9BB  2  EA                   NOP                     ; 2
00C9BC  2  EA                   NOP                     ; 2
00C9BD  2  68                   PLA                     ; 4
00C9BE  2  60                   RTS                     ; 6
00C9BF  2               
00C9BF  2               
00C9BF  2               
00C9BF  2               
00C9BF  2               ; function RTC_RESET_ON
00C9BF  2               ;  { Assert RTC reset signal }
00C9BF  2               RTC_RESET_ON:
00C9BF  2  A9 70                LDA     #$70
00C9C1  2  8D 02 ED             STA     RTCDDRD
00C9C4  2  A9 20                LDA     #mask_data
00C9C6  2  8D 00 ED             STA     RTCPORTD
00C9C9  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C9CC  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C9CF  2  60                   RTS
00C9D0  2               
00C9D0  2               ; function RTC_RESET_OFF
00C9D0  2               ;  { De-assert RTC reset signal }
00C9D0  2               RTC_RESET_OFF:
00C9D0  2  A9 70                LDA     #$70
00C9D2  2  8D 02 ED             STA     RTCDDRD
00C9D5  2  A9 30                LDA     #mask_data +  mask_ce
00C9D7  2  8D 00 ED             STA     RTCPORTD
00C9DA  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C9DD  2  20 B2 C9             JSR     RTC_BIT_DELAY
00C9E0  2  60                   RTS
00C9E1  2               
00C9E1  1                       .IF     DSKY_OPTION=1
00C9E1  1                           .INCLUDE "bios_dsky.asm"
00C9E1  1                       .ENDIF
00C9E1  1               
00C9E1  1                       .IF     DSKY_OPTION=2
00C9E1  1                           .INCLUDE "bios_dskyng.asm"
00C9E1  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
00C9E1  2               ;
00C9E1  2               ; 	Nhyodyne DSKY/NG drivers
00C9E1  2               ;
00C9E1  2               ;	Entry points:
00C9E1  2               ;               DSKY_INIT
00C9E1  2               ;               DSKY_RESET
00C9E1  2               ;               DSKY_SHOW
00C9E1  2               ;               DSKY_BIN2SEG
00C9E1  2               ;               DSKY_STAT
00C9E1  2               ;               DSKY_GETKEY
00C9E1  2               ;               DSKY_BEEP
00C9E1  2               ;               DSKY_PUTLED
00C9E1  2               ;               DSKY_BLANK
00C9E1  2               ;               DSKY_DSPL
00C9E1  2               ;________________________________________________________________________________________________________________________________
00C9E1  2               ;
00C9E1  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
00C9E1  2               ;
00C9E1  2               ; LED SEGMENTS (BIT VALUES)
00C9E1  2               ;
00C9E1  2               ;	+--01--+
00C9E1  2               ;	20    02
00C9E1  2               ;	+--40--+
00C9E1  2               ;	10    04
00C9E1  2               ;	+--08--+  80
00C9E1  2               ;
00C9E1  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
00C9E1  2               ;                          ||||||||
00C9E1  2               ;                          |||||+++-- ROW
00C9E1  2               ;                          ||+++----- COL
00C9E1  2               ;                          |+-------- SHIFT
00C9E1  2               ;                          +--------- CONTROL
00C9E1  2               ;
00C9E1  2               ;	00	08	10	18	23
00C9E1  2               ;	01	09	11	19	22
00C9E1  2               ;	02	0A	12	1A	21
00C9E1  2               ;	03	0B	13	1B	20
00C9E1  2               ;	04	0C	14	1C	SHIFT
00C9E1  2               ;	05	0D	15	1D	CTRL
00C9E1  2               ;
00C9E1  2               ; LED BIT MAP (BIT VALUES)
00C9E1  2               ;
00C9E1  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
00C9E1  2               ;	---	---	---	---	---	---	---	---
00C9E1  2               ;	01	01	01	01	01
00C9E1  2               ;	02	02	02	02	02
00C9E1  2               ;	04      04      04      04	04
00C9E1  2               ;	08      08      08      08	08
00C9E1  2               ;	10      10      10      10	10
00C9E1  2               ;	20      20      20      20	20	L1	L2 	BUZZ
00C9E1  2               ;
00C9E1  2               DSKY_VIAA       = $ED00         ; PORT C
00C9E1  2               DSKY_VIAB       = $EC00         ; PORT A & B
00C9E1  2               DSKY_PPIA       = DSKY_VIAA + 1 ; PORT A
00C9E1  2               DSKY_PPIC       = DSKY_VIAB + 1 ; PORT C
00C9E1  2               DSKY_PPIA_C     = DSKY_VIAA + 3 ; PORT A DDR
00C9E1  2               DSKY_PPIC_C     = DSKY_VIAB + 3 ; PORT C DDR
00C9E1  2               
00C9E1  2               ;
00C9E1  2               ; PIO CHANNEL C:
00C9E1  2               ;
00C9E1  2               ;	7	6	5	4	3	2	1	0
00C9E1  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
00C9E1  2               ;
00C9E1  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
00C9E1  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
00C9E1  2               ;
00C9E1  2               DSKY_PPI_IDLE   = %00000110
00C9E1  2               ;
00C9E1  2               DSKY_CMD_CLR    = %11011111     ; CLEAR (ALL OFF)
00C9E1  2               DSKY_CMD_CLRX   = %11010011     ; CLEAR (ALL ON)
00C9E1  2               DSKY_CMD_WDSP   = %10010000     ; WRITE DISPLAY RAM
00C9E1  2               DSKY_CMD_RDSP   = %01110000     ; READ DISPLAY RAM
00C9E1  2               DSKY_CMD_CLK    = %00100000     ; SET CLK PRESCALE
00C9E1  2               DSKY_CMD_FIFO   = %01000000     ; READ FIFO
00C9E1  2               ;
00C9E1  2               DSKY_PRESCL     = DSKYOSC/100000; PRESCALER
00C9E1  2               ;
00C9E1  2               ;__DSKY_INIT_________________________________________________________________________________________
00C9E1  2               ;
00C9E1  2               ;  DISPLAY DSKY INFO
00C9E1  2               ;____________________________________________________________________________________________________
00C9E1  2               ;
00C9E1  2               DSKY_INIT:
00C9E1  2  20 C3 CA             JSR     DSKY_PREINIT
00C9E4  2  48 DA 5A A2          PRTS    "DSKY:$"
00C9E8  2  00 BD FD C9  
00C9EC  2  E8 C9 24 F0  
00CA03  2  20 00 C0             JSR     NEWLINE
00CA06  2               
00CA06  2               ;
00CA06  2  48 DA 5A A2          PRTS    " IO=0x$"
00CA0A  2  00 BD 1F CA  
00CA0E  2  E8 C9 24 F0  
00CA26  2  A9 ED                LDA     #>DSKY_VIAA     ; GET BASE PORT
00CA28  2  20 47 F9             JSR     PRINT_BYTE
00CA2B  2  A9 00                LDA     #<DSKY_VIAA     ; GET BASE PORT
00CA2D  2  20 47 F9             JSR     PRINT_BYTE
00CA30  2  48 DA 5A A2          PRTS    " & "
00CA34  2  00 BD 49 CA  
00CA38  2  E8 C9 24 F0  
00CA4C  2  A9 EC                LDA     #>DSKY_VIAB     ; GET BASE PORT
00CA4E  2  20 47 F9             JSR     PRINT_BYTE
00CA51  2  A9 00                LDA     #<DSKY_VIAB     ; GET BASE PORT
00CA53  2  20 47 F9             JSR     PRINT_BYTE
00CA56  2               
00CA56  2  48 DA 5A A2          PRTS    " MODE=$"
00CA5A  2  00 BD 6F CA  
00CA5E  2  E8 C9 24 F0  
00CA76  2  48 DA 5A A2          PRTS    "NG$"           ; PRINT DSKY TYPE
00CA7A  2  00 BD 8F CA  
00CA7E  2  E8 C9 24 F0  
00CA92  2               ;
00CA92  2  AD F2 CC             LDA     DSKY_PRESENT    ; PRESENT?
00CA95  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CA97  2  F0 26                BEQ     DSKY_INITA
00CA99  2  48 DA 5A A2          PRTS    " NOT PRESENT$" ; NOT PRESENT
00CA9D  2  00 BD B2 CA  
00CAA1  2  E8 C9 24 F0  
00CABF  2               DSKY_INITA:
00CABF  2  20 00 C0             JSR     NEWLINE
00CAC2  2  60                   RTS                     ; DONE
00CAC3  2               ;
00CAC3  2               ;__DSKY_PREINIT______________________________________________________________________________________
00CAC3  2               ;
00CAC3  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00CAC3  2               ;____________________________________________________________________________________________________
00CAC3  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00CAC3  2               DSKY_PREINIT:
00CAC3  2               ; CHECK FOR PPI
00CAC3  2  20 08 CB             JSR     DSKY_PPIDETECT  ; TEST FOR PPI HARDWARE
00CAC6  2  D0 2A                BNE     DSKY_ABORT      ; BAIL OUT IF NOT THERE
00CAC8  2               
00CAC8  2               ; SETUP PPI TO DEFAULT MODE
00CAC8  2  20 D0 CC             JSR     DSKY_PPIRD
00CACB  2               ; INIT 8279 VALUES TO IDLE STATE
00CACB  2  A9 06                LDA     #DSKY_PPI_IDLE
00CACD  2  8D 01 EC             STA     DSKY_PPIC
00CAD0  2               ; PULSE RESET SIGNAL ON 8279
00CAD0  2  09 80                ORA     #%10000000
00CAD2  2  8D 01 EC             STA     DSKY_PPIC
00CAD5  2  29 7F                AND     #%01111111
00CAD7  2  8D 01 EC             STA     DSKY_PPIC
00CADA  2               ; INITIALIZE 8279
00CADA  2  20 F3 CA             JSR     DSKY_REINIT
00CADD  2               ; NOW SEE IF A DSKYNG IS REALLY THERE...
00CADD  2  A9 A5                LDA     #$A5
00CADF  2  A0 00                LDY     #$00
00CAE1  2  20 44 CC             JSR     DSKY_PUTBYTE
00CAE4  2  A0 00                LDY     #$00
00CAE6  2  20 58 CC             JSR     DSKY_GETBYTE
00CAE9  2  C9 A5                CMP     #$A5
00CAEB  2  D0 05                BNE     DSKY_ABORT      ; BAIL OUT IF MISCOMPARE
00CAED  2  A9 FF                LDA     #$FF
00CAEF  2  8D F2 CC             STA     DSKY_PRESENT
00CAF2  2               DSKY_ABORT:
00CAF2  2  60                   RTS
00CAF3  2               ;
00CAF3  2               DSKY_REINIT:
00CAF3  2  20 DD CC             JSR     DSKY_PPIIDLE
00CAF6  2               ; SET CLOCK SCALER TO 20
00CAF6  2  A9 2A                LDA     #DSKY_CMD_CLK | DSKY_PRESCL
00CAF8  2  20 C4 CB             JSR     DSKY_CMD
00CAFB  2               ; FALL THRU
00CAFB  2               ;
00CAFB  2               DSKY_RESET:
00CAFB  2               ; RESET DSKY -- CLEAR RAM AND FIFO
00CAFB  2  A9 DF                LDA     #DSKY_CMD_CLR
00CAFD  2  20 C4 CB             JSR     DSKY_CMD
00CB00  2               ;
00CB00  2               ; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
00CB00  2               ; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
00CB00  2               ; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
00CB00  2               ; IS USED TO IMPLEMENT A TIMEOUT.
00CB00  2  A2 00                LDX     #0              ; TIMEOUT LOOP COUNTER
00CB02  2               DSKY_RESET1:
00CB02  2  DA                   PHX                     ; SAVE COUNTER
00CB03  2  FA                   PLX                     ; RECOVER COUNTER
00CB04  2  CA                   DEX
00CB05  2  D0 FB                BNE     DSKY_RESET1     ; LOOP TILL TIMEOUT
00CB07  2               ;
00CB07  2               DSKY_RESET2:
00CB07  2  60                   RTS
00CB08  2               ;
00CB08  2               ;
00CB08  2               ;
00CB08  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
00CB08  2               ;
00CB08  2               ;  PROBE FOR PPI HARDWARE
00CB08  2               ;____________________________________________________________________________________________________
00CB08  2               ;
00CB08  2               DSKY_PPIDETECT:
00CB08  2               ;
00CB08  2               ; TEST FOR PPI EXISTENCE
00CB08  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00CB08  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00CB08  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00CB08  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00CB08  2               ; INTERFERE WITH THE VALUE BEING READ.
00CB08  2  20 C3 CC             JSR     DSKY_PPIWR
00CB0B  2               ;
00CB0B  2  A9 00                LDA     #$00            ; VALUE ZERO
00CB0D  2  8D 01 ED             STA     DSKY_PPIA       ; PUSH VALUE TO PORT
00CB10  2  AD 01 ED             LDA     DSKY_PPIA       ; GET PORT VALUE
00CB13  2  C9 00                CMP     #$00
00CB15  2  60                   RTS                     ; AND RETURN
00CB16  2               ;
00CB16  2               ;
00CB16  2               KY_0            = $00
00CB16  2               KY_1            = $01
00CB16  2               KY_2            = $02
00CB16  2               KY_3            = $03
00CB16  2               KY_4            = $04
00CB16  2               KY_5            = $05
00CB16  2               KY_6            = $06
00CB16  2               KY_7            = $07
00CB16  2               KY_8            = $08
00CB16  2               KY_9            = $09
00CB16  2               KY_A            = $0A
00CB16  2               KY_B            = $0B
00CB16  2               KY_C            = $0C
00CB16  2               KY_D            = $0D
00CB16  2               KY_E            = $0E
00CB16  2               KY_F            = $0F
00CB16  2               KY_FW           = $10           ; FORWARD
00CB16  2               KY_BK           = $11           ; BACKWARD
00CB16  2               KY_CL           = $12           ; CLEAR
00CB16  2               KY_EN           = $13           ; ENTER
00CB16  2               KY_DE           = $14           ; DEPOSIT
00CB16  2               KY_EX           = $15           ; EXAMINE
00CB16  2               KY_GO           = $16           ; GO
00CB16  2               KY_BO           = $17           ; BOOT
00CB16  2               KY_F4           = $18           ; F4
00CB16  2               KY_F3           = $19           ; F3
00CB16  2               KY_F2           = $20           ; F2
00CB16  2               KY_F1           = $21           ; F1
00CB16  2               ;
00CB16  2               ;__DSKY_STAT_________________________________________________________________________________________
00CB16  2               ;
00CB16  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
00CB16  2               ;____________________________________________________________________________________________________
00CB16  2               ;
00CB16  2               DSKY_STAT:
00CB16  2  AD F2 CC             LDA     DSKY_PRESENT    ; DOES IT EXIST?
00CB19  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CB1B  2  D0 05                BNE     DSKY_STATA      ; ABORT WITH A=0 IF NOT THERE
00CB1D  2  20 FD CB             JSR     DSKY_ST
00CB20  2  29 0F                AND     #$0F            ; ISOLATE THE CUR FIFO LEN
00CB22  2               DSKY_STATA:
00CB22  2  60                   RTS
00CB23  2               ;
00CB23  2               ;__DSKY_GETKEY_____________________________________________________________________________________
00CB23  2               ;
00CB23  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
00CB23  2               ;____________________________________________________________________________________________________
00CB23  2               ;
00CB23  2               DSKY_GETKEY:
00CB23  2  AD F2 CC             LDA     DSKY_PRESENT    ; DOES IT EXIST?
00CB26  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CB28  2  D0 24                BNE     DSKY_GETKEY1A   ; ABORT WITH A=0 IF NOT THERE
00CB2A  2  20 16 CB             JSR     DSKY_STAT
00CB2D  2  F0 F4                BEQ     DSKY_GETKEY     ; LOOP IF NOTHING THERE
00CB2F  2  A9 40                LDA     #DSKY_CMD_FIFO
00CB31  2  20 C4 CB             JSR     DSKY_CMD
00CB34  2  20 02 CC             JSR     DSKY_DIN
00CB37  2  49 C0                EOR     #%11000000      ; FLIP POLARITY OF SHIFT/CTL BITS
00CB39  2  48                   PHA
00CB3A  2  29 3F                AND     #$3F            ; STRIP SHIFT/CTL BITS FOR LOOKUP
00CB3C  2  8D F0 CC             STA     DSKY_TEMP_VAL
00CB3F  2  A2 00                LDX     #0              ; INDEX
00CB41  2               DSKY_GETKEY1:
00CB41  2  BD 5D CB             LDA     DSKY_KEYMAP,X
00CB44  2  CD F0 CC             CMP     DSKY_TEMP_VAL   ; MATCH?
00CB47  2  F0 09                BEQ     DSKY_GETKEY2    ; FOUND, DONE
00CB49  2  E8                   INX
00CB4A  2  E0 1C                CPX     #28
00CB4C  2  D0 F3                BNE     DSKY_GETKEY1    ; LOOP UNTIL EOT
00CB4E  2               DSKY_GETKEY1A:
00CB4E  2  68                   PLA
00CB4F  2  A9 FF                LDA     #$FF            ; NOT FOUND ERR, RETURN $FF
00CB51  2  60                   RTS
00CB52  2               DSKY_GETKEY2:
00CB52  2               ; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
00CB52  2               ; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
00CB52  2  68                   PLA                     ; RESTORE RAW VALUE
00CB53  2  25 C0                AND     %11000000       ; ISOLATE SHIFT/CTRL BITS
00CB55  2  8D F0 CC             STA     DSKY_TEMP_VAL
00CB58  2  8A                   TXA
00CB59  2  0D F0 CC             ORA     DSKY_TEMP_VAL   ; COMBINE WITH INDEX VALUE
00CB5C  2  60                   RTS
00CB5D  2               ;
00CB5D  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
00CB5D  2               ;
00CB5D  2               DSKY_KEYMAP:
00CB5D  2               ; POS	$00  $01  $02  $03  $04  $05  $06  $07
00CB5D  2               ; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
00CB5D  2  0D 04 0C 14          .BYTE   $0D, $04, $0C, $14, $03, $0B, $13, $02
00CB61  2  03 0B 13 02  
00CB65  2               ;
00CB65  2               ; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
00CB65  2               ; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
00CB65  2  0A 12 01 09          .BYTE   $0A, $12, $01, $09, $11, $00, $08, $10
00CB69  2  11 00 08 10  
00CB6D  2               ;
00CB6D  2               ; POS	$10  $11  $12  $13  $14  $15  $16  $17
00CB6D  2               ; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
00CB6D  2  05 15 1D 1C          .BYTE   $05, $15, $1D, $1C, $1B, $1A, $19, $18
00CB71  2  1B 1A 19 18  
00CB75  2               
00CB75  2               ; POS	$18  $19  $20  $21
00CB75  2               ; KEY   [F4] [F3] [F2] [F1]
00CB75  2  23 22 21 20          .BYTE   $23, $22, $21, $20
00CB79  2               
00CB79  2               ;
00CB79  2               ;
00CB79  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
00CB79  2               ;
00CB79  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
00CB79  2               ;
00CB79  2               ; DSKY_BUF: 32 BIT BINARY
00CB79  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
00CB79  2               ;____________________________________________________________________________________________________
00CB79  2               ;
00CB79  2               DSKY_BIN2SEG:
00CB79  2  A2 00                LDX     #$00
00CB7B  2               DSKY_BIN2SEG1:
00CB7B  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; FIRST NIBBLE
00CB7E  2  4A                   LSR     A
00CB7F  2  4A                   LSR     A
00CB80  2  4A                   LSR     A
00CB81  2  4A                   LSR     A
00CB82  2  DA                   PHX                     ; STORE READ INDEX
00CB83  2  AA                   TAX                     ; MOVE DIGIT TO LOOKUP INDEX
00CB84  2  BD E0 CC             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
00CB87  2  FA                   PLX                     ; GET READ INDEX
00CB88  2  DA                   PHX
00CB89  2  48                   PHA
00CB8A  2  8A                   TXA
00CB8B  2  0A                   ASL     a
00CB8C  2  AA                   TAX
00CB8D  2  68                   PLA
00CB8E  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00CB91  2  FA                   PLX
00CB92  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; SECOND NIBBLE
00CB95  2               
00CB95  2  29 0F                AND     #$0F
00CB97  2  DA                   PHX
00CB98  2  AA                   TAX
00CB99  2  BD E0 CC             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
00CB9C  2  FA                   PLX
00CB9D  2  DA                   PHX
00CB9E  2  48                   PHA
00CB9F  2  8A                   TXA                     ; GET READ INDEX
00CBA0  2  0A                   ASL     a
00CBA1  2  AA                   TAX
00CBA2  2  E8                   INX
00CBA3  2  68                   PLA
00CBA4  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00CBA7  2  FA                   PLX
00CBA8  2  E8                   INX
00CBA9  2  E0 04                CPX     #4
00CBAB  2  D0 CE                BNE     DSKY_BIN2SEG1
00CBAD  2  60                   RTS
00CBAE  2               ;
00CBAE  2               ;__DSKY_SHOW___________________________________________________________________________________________
00CBAE  2               ; DSKY SHOW BUFFER
00CBAE  2               ;______________________________________________________________________________________________________
00CBAE  2               ;
00CBAE  2               DSKY_SHOW:
00CBAE  2  48                   PHA
00CBAF  2  DA                   PHX
00CBB0  2  5A                   PHY
00CBB1  2  A2 00                LDX     #0
00CBB3  2               DSKY_SHOW1:
00CBB3  2  BD 00 05             LDA     DSKY_BUF,X
00CBB6  2  DA                   PHX
00CBB7  2  7A                   PLY
00CBB8  2  20 44 CC             JSR     DSKY_PUTBYTE
00CBBB  2  E8                   INX
00CBBC  2  E0 08                CPX     #8
00CBBE  2  D0 F3                BNE     DSKY_SHOW1
00CBC0  2  7A                   PLY
00CBC1  2  FA                   PLX
00CBC2  2  68                   PLA
00CBC3  2  60                   RTS
00CBC4  2               
00CBC4  2               ;______________________________________________________________________________________________________
00CBC4  2               ; DSKYNG OUTPUT ROUTINES
00CBC4  2               ;______________________________________________________________________________________________________
00CBC4  2               
00CBC4  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
00CBC4  2               DSKY_CMD:
00CBC4  2  48                   PHA
00CBC5  2  A9 01                LDA     #$01
00CBC7  2  4C CD CB             JMP     DSKY_DOUT2
00CBCA  2               ;
00CBCA  2               ; SEND DSKY DATA BYTE IN REGISTER A
00CBCA  2               ; TRASHES BC
00CBCA  2               ;
00CBCA  2               DSKY_DOUT:
00CBCA  2  48                   PHA
00CBCB  2  A9 00                LDA     #$00
00CBCD  2               ;
00CBCD  2               DSKY_DOUT2:
00CBCD  2               ; SET PPI LINE CONFIG TO WRITE MODE
00CBCD  2  20 C3 CC             JSR     DSKY_PPIWR
00CBD0  2               ;
00CBD0  2               ; SET ADDRESS FIRST
00CBD0  2  09 06                ORA     #DSKY_PPI_IDLE
00CBD2  2  8D 01 EC             STA     DSKY_PPIC
00CBD5  2               ;
00CBD5  2               ; ASSERT 8279 /CS
00CBD5  2  09 18                ORA     #%00011000
00CBD7  2  8D 01 EC             STA     DSKY_PPIC
00CBDA  2               ;
00CBDA  2               ; PPIC WORKING VALUE TO DSKY_TEMP_VAL
00CBDA  2  8D F0 CC             STA     DSKY_TEMP_VAL
00CBDD  2               ;
00CBDD  2               ; ASSERT DATA BYTE VALUE
00CBDD  2  68                   PLA
00CBDE  2  8D 01 ED             STA     DSKY_PPIA
00CBE1  2               ;
00CBE1  2               ; PULSE /WR
00CBE1  2  AD F0 CC             LDA     DSKY_TEMP_VAL
00CBE4  2  29 FD                AND     #%11111101
00CBE6  2  8D 01 EC             STA     DSKY_PPIC
00CBE9  2  EA                   NOP                     ; MAY NOT BE NEEDED
00CBEA  2  09 02                ORA     #%00000010
00CBEC  2  8D 01 EC             STA     DSKY_PPIC
00CBEF  2               ;
00CBEF  2               ; DEASSERT /CS
00CBEF  2  29 E7                AND     #%11100111
00CBF1  2  8D 01 EC             STA     DSKY_PPIC
00CBF4  2               ;
00CBF4  2               ; CLEAR ADDRESS BIT
00CBF4  2  29 E6                AND     #%11100110
00CBF6  2  8D 01 EC             STA     DSKY_PPIC
00CBF9  2               ;
00CBF9  2               ; DONE
00CBF9  2  20 DD CC             JSR     DSKY_PPIIDLE
00CBFC  2  60                   RTS
00CBFD  2               ;
00CBFD  2               ;==================================================================================================
00CBFD  2               ; DSKYNG OUTPUT ROUTINES
00CBFD  2               ;==================================================================================================
00CBFD  2               ;
00CBFD  2               ; RETURN DSKY STATUS VALUE IN A
00CBFD  2               ;
00CBFD  2               DSKY_ST:
00CBFD  2  A9 01                LDA     #$01
00CBFF  2  4C 04 CC             JMP     DSKY_DIN2
00CC02  2               ;
00CC02  2               ; RETURN NEXT DATA VALUE IN A
00CC02  2               ;
00CC02  2               DSKY_DIN:
00CC02  2  A9 00                LDA     #$00
00CC04  2               ;
00CC04  2               DSKY_DIN2:
00CC04  2               ; SET PPI LINE CONFIG TO READ MODE
00CC04  2  20 D0 CC             JSR     DSKY_PPIRD
00CC07  2               ;
00CC07  2               ; SET ADDRESS FIRST
00CC07  2  09 06                ORA     #DSKY_PPI_IDLE
00CC09  2  8D 01 EC             STA     DSKY_PPIC
00CC0C  2               ;
00CC0C  2               ; ASSERT 8279 /CS
00CC0C  2  09 18                ORA     #%00011000
00CC0E  2  8D 01 EC             STA     DSKY_PPIC
00CC11  2               ;
00CC11  2               ; ASSERT /RD
00CC11  2  29 7B                AND     #%01111011
00CC13  2  8D 01 EC             STA     DSKY_PPIC
00CC16  2               ;
00CC16  2  8D F0 CC             STA     DSKY_TEMP_VAL
00CC19  2               ; GET VALUE
00CC19  2  AD 01 ED             LDA     DSKY_PPIA
00CC1C  2  48                   PHA
00CC1D  2               
00CC1D  2  AD F0 CC             LDA     DSKY_TEMP_VAL
00CC20  2               ; DEASSERT /RD
00CC20  2  09 04                ORA     #%00000100
00CC22  2  8D 01 EC             STA     DSKY_PPIC
00CC25  2               ;
00CC25  2               ; DEASSERT /CS
00CC25  2  29 E7                AND     #%11100111
00CC27  2  8D 01 EC             STA     DSKY_PPIC
00CC2A  2               ;
00CC2A  2               ; CLEAR ADDRESS BIT
00CC2A  2  29 E6                AND     #%11100110
00CC2C  2  8D 01 EC             STA     DSKY_PPIC
00CC2F  2               ;
00CC2F  2               ; DONE
00CC2F  2  20 DD CC             JSR     DSKY_PPIIDLE
00CC32  2  68                   PLA
00CC33  2  60                   RTS
00CC34  2               
00CC34  2               ;__DSKY_BLANK_____________________________________________________________________________________
00CC34  2               ;
00CC34  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
00CC34  2               ;
00CC34  2               ;_________________________________________________________________________________________________
00CC34  2               ;
00CC34  2               DSKY_BLANK:
00CC34  2  A9 90                LDA     #DSKY_CMD_WDSP
00CC36  2  20 C4 CB             JSR     DSKY_CMD
00CC39  2  A2 10                LDX     #16
00CC3B  2               DSKY_BLANK1:
00CC3B  2  A9 FF                LDA     #$FF
00CC3D  2  20 CA CB             JSR     DSKY_DOUT
00CC40  2  CA                   DEX
00CC41  2  D0 F8                BNE     DSKY_BLANK1
00CC43  2  60                   RTS
00CC44  2               ;
00CC44  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
00CC44  2               ;
00CC44  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
00CC44  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
00CC44  2               ;
00CC44  2               ;__________________________________________________________________________________________________
00CC44  2               ;
00CC44  2               DSKY_PUTBYTE:
00CC44  2  5A                   PHY
00CC45  2  48                   PHA
00CC46  2  48                   PHA
00CC47  2  18                   CLC
00CC48  2  98                   TYA
00CC49  2  69 90                ADC     #DSKY_CMD_WDSP
00CC4B  2  A8                   TAY
00CC4C  2  20 C4 CB             JSR     DSKY_CMD
00CC4F  2  68                   PLA
00CC50  2  49 FF                EOR     #$FF
00CC52  2  20 CA CB             JSR     DSKY_DOUT
00CC55  2  68                   PLA
00CC56  2  7A                   PLY
00CC57  2  60                   RTS
00CC58  2               ;
00CC58  2               ;__DSKY_GETBYTE___________________________________________________________________________________
00CC58  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
00CC58  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
00CC58  2               ;
00CC58  2               ;_________________________________________________________________________________________________
00CC58  2               ;
00CC58  2               DSKY_GETBYTE:
00CC58  2  18                   CLC
00CC59  2  98                   TYA
00CC5A  2  69 70                ADC     #DSKY_CMD_RDSP
00CC5C  2  A8                   TAY
00CC5D  2  20 C4 CB             JSR     DSKY_CMD
00CC60  2  20 02 CC             JSR     DSKY_DIN
00CC63  2  49 FF                EOR     #$FF
00CC65  2  60                   RTS
00CC66  2               
00CC66  2               ;
00CC66  2               ;__DSKY_PUTLED____________________________________________________________________________________
00CC66  2               ;
00CC66  2               ;	This function is intended to update the LEDs.
00CC66  2               ;	VALUES SHOULD BE IN DSKY_BUF
00CC66  2               ;_________________________________________________________________________________________________
00CC66  2               ;
00CC66  2               DSKY_PUTLED:
00CC66  2  DA                   PHX
00CC67  2  5A                   PHY
00CC68  2  48                   PHA
00CC69  2  A0 00                LDY     #$00
00CC6B  2  A2 00                LDX     #$00
00CC6D  2               DSKY_PUTLED_1:
00CC6D  2  BD 00 05             LDA     DSKY_BUF,X      ; GET BYTE
00CC70  2  20 44 CC             JSR     DSKY_PUTBYTE    ; SEND IT TO DSKY
00CC73  2  C8                   INY                     ; LOOP TIL DONE
00CC74  2  E8                   INX
00CC75  2  C0 08                CPY     #8
00CC77  2  D0 F4                BNE     DSKY_PUTLED_1
00CC79  2  68                   PLA                     ; RESTORE REGISTERS
00CC7A  2  7A                   PLY
00CC7B  2  FA                   PLX
00CC7C  2  60                   RTS
00CC7D  2               ;
00CC7D  2               ;__DSKY_BEEP______________________________________________________________________________________
00CC7D  2               ;	This function is intended to beep the speaker on the DSKY
00CC7D  2               ;_________________________________________________________________________________________________
00CC7D  2               ;
00CC7D  2               DSKY_BEEP:
00CC7D  2  5A                   PHY
00CC7E  2  DA                   PHX
00CC7F  2  48                   PHA
00CC80  2  A0 0F                LDY     #$0F
00CC82  2  20 58 CC             JSR     DSKY_GETBYTE
00CC85  2  09 20                ORA     #$20
00CC87  2  A9 20                LDA     #$20
00CC89  2  A0 0F                LDY     #$0F
00CC8B  2  20 44 CC             JSR     DSKY_PUTBYTE
00CC8E  2               
00CC8E  2               ;;; 	timer . . .
00CC8E  2  A2 8F                LDX     #$8F
00CC90  2  A0 FF                LDY     #$FF
00CC92  2               DSKY_BEEP1:
00CC92  2  88                   DEY
00CC93  2  D0 FD                BNE     DSKY_BEEP1
00CC95  2  CA                   DEX
00CC96  2  D0 FA                BNE     DSKY_BEEP1
00CC98  2               
00CC98  2  A0 0F                LDY     #$0F
00CC9A  2  20 58 CC             JSR     DSKY_GETBYTE
00CC9D  2  29 DF                AND     #$DF
00CC9F  2  A9 DF                LDA     #$DF
00CCA1  2  A0 0F                LDY     #$0F
00CCA3  2  20 44 CC             JSR     DSKY_PUTBYTE
00CCA6  2               
00CCA6  2  68                   PLA
00CCA7  2  FA                   PLX
00CCA8  2  7A                   PLY
00CCA9  2  60                   RTS
00CCAA  2               ;
00CCAA  2               ;__ODSKY_DSPL______________________________________________________________________________________
00CCAA  2               ;
00CCAA  2               ;	This function is intended to turn on or off the DSKY L1 & L2 leds
00CCAA  2               ;
00CCAA  2               ;   A= LED# (0 or 1)
00CCAA  2               ;   X= On(1) or Off(0)
00CCAA  2               ;_________________________________________________________________________________________________
00CCAA  2               ;
00CCAA  2               DSKY_DSPL:
00CCAA  2  5A                   PHY
00CCAB  2  18                   CLC
00CCAC  2  29 01                AND     #$01
00CCAE  2  69 0D                ADC     #$0D
00CCB0  2  A8                   TAY
00CCB1  2  20 58 CC             JSR     DSKY_GETBYTE
00CCB4  2  E0 00                CPX     #$00
00CCB6  2  F0 04                BEQ     :+
00CCB8  2  09 20                ORA     #$20
00CCBA  2  80 02                BRA     DSKY_DSPL_1
00CCBC  2               :
00CCBC  2  29 DF                AND     #$DF
00CCBE  2               DSKY_DSPL_1:
00CCBE  2  20 44 CC             JSR     DSKY_PUTBYTE
00CCC1  2  7A                   PLY
00CCC2  2  60                   RTS
00CCC3  2               
00CCC3  2               ;
00CCC3  2               ;_________________________________________________________________________________________________
00CCC3  2               ; DSKYNG LINE CONTROL ROUTINES
00CCC3  2               ;
00CCC3  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
00CCC3  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
00CCC3  2               ;
00CCC3  2               ;_________________________________________________________________________________________________
00CCC3  2               ;
00CCC3  2               DSKY_PPIWR:
00CCC3  2  48                   PHA
00CCC4  2               ;
00CCC4  2               ; PLACE PORT A BITS 0-7 IN OUT MODE
00CCC4  2  A9 FF                LDA     #$FF
00CCC6  2  8D 03 ED             STA     DSKY_PPIA_C
00CCC9  2               ;
00CCC9  2               ; PLACE PORT C BITS 0-4 & 7 IN OUT MODE
00CCC9  2  A9 9F                LDA     #$9F
00CCCB  2  8D 03 ED             STA     DSKY_PPIA_C
00CCCE  2               ;
00CCCE  2  68                   PLA
00CCCF  2  60                   RTS
00CCD0  2               ;
00CCD0  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
00CCD0  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
00CCD0  2               ;
00CCD0  2               DSKY_PPIRD:
00CCD0  2  48                   PHA
00CCD1  2               ;
00CCD1  2               ; PLACE PORT A BITS 0-7 IN INPUT MODE
00CCD1  2  A9 00                LDA     #$00
00CCD3  2  8D 03 ED             STA     DSKY_PPIA_C
00CCD6  2               ;
00CCD6  2               ; PLACE PORT C BITS 0-4 & 7 IN OUT MODE
00CCD6  2  A9 9F                LDA     #$9F
00CCD8  2  8D 03 ED             STA     DSKY_PPIA_C
00CCDB  2               ;
00CCDB  2  68                   PLA
00CCDC  2  60                   RTS
00CCDD  2               ;
00CCDD  2               ; RELEASE USE OF PPI
00CCDD  2               ;
00CCDD  2               DSKY_PPIIDLE:
00CCDD  2  4C D0 CC             JMP     DSKY_PPIRD      ; SAME AS READ MODE
00CCE0  2               ;
00CCE0  2               ;__STORAGE_________________________________________________________________________________________
00CCE0  2               ; CODES FOR NUMERICS
00CCE0  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
00CCE0  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
00CCE0  2               ;_________________________________________________________________________________________________
00CCE0  2               ;
00CCE0  2               DSKY_HEXMAP:
00CCE0  2  3F                   .BYTE   $3F             ; 0
00CCE1  2  06                   .BYTE   $06             ; 1
00CCE2  2  5B                   .BYTE   $5B             ; 2
00CCE3  2  4F                   .BYTE   $4F             ; 3
00CCE4  2  66                   .BYTE   $66             ; 4
00CCE5  2  6D                   .BYTE   $6D             ; 5
00CCE6  2  7D                   .BYTE   $7D             ; 6
00CCE7  2  07                   .BYTE   $07             ; 7
00CCE8  2  7F                   .BYTE   $7F             ; 8
00CCE9  2  67                   .BYTE   $67             ; 9
00CCEA  2  77                   .BYTE   $77             ; A
00CCEB  2  7C                   .BYTE   $7C             ; B
00CCEC  2  39                   .BYTE   $39             ; C
00CCED  2  5E                   .BYTE   $5E             ; D
00CCEE  2  79                   .BYTE   $79             ; E
00CCEF  2  71                   .BYTE   $71             ; F
00CCF0  2               ;
00CCF0  2               DSKY_TEMP_VAL:
00CCF0  2  00                   .BYTE   0
00CCF1  2               DSKY_PPIX_VAL:
00CCF1  2  00                   .BYTE   0
00CCF2  2               DSKY_PRESENT:
00CCF2  2  00                   .BYTE   0
00CCF3  2               
00CCF3  1                       .ENDIF
00CCF3  1               
00CCF3  1                       .IF     DSKY_OPTION=0
00CCF3  1               DSKY_INIT:
00CCF3  1               DSKY_RESET:
00CCF3  1               DSKY_SHOW:
00CCF3  1               DSKY_BIN2SEG:
00CCF3  1               DSKY_STAT:
00CCF3  1               DSKY_GETKEY:
00CCF3  1               DSKY_BEEP:
00CCF3  1               DSKY_PUTLED:
00CCF3  1               DSKY_BLANK:
00CCF3  1               DSKY_DSPL:
00CCF3  1                           RTS
00CCF3  1                       .ENDIF
00CCF3  1               
00CCF3  1               
00CCF3  1               STARTUP:
00CCF3  1  0D 0A                .BYTE   $0D,$0A
00CCF5  1               
00CCF5  1  20 20 52 65          .BYTE   "  RetroBrew Computers 6x0x",$0D,$0A,$0D,$0A
00CCF9  1  74 72 6F 42  
00CCFD  1  72 65 77 20  
00CD13  1  20 2E 64 38          .BYTE   " .d8888b.            .d8888b. ",$0D,$0A
00CD17  1  38 38 38 62  
00CD1B  1  2E 20 20 20  
00CD33  1  64 38 38 50          .BYTE   "d88P  Y88b          d88P  Y88b ",$0D,$0A
00CD37  1  20 20 59 38  
00CD3B  1  38 62 20 20  
00CD54  1  38 38 38 20          .BYTE   "888                 888    888 ",$0D,$0A
00CD58  1  20 20 20 20  
00CD5C  1  20 20 20 20  
00CD75  1  38 38 38 64          .BYTE   "888d888b.  888  888 888    888 888  888 ",$0D,$0A
00CD79  1  38 38 38 62  
00CD7D  1  2E 20 20 38  
00CD9F  1  38 38 38 50          .BYTE   "888P  Y88b `Y8bd8P' 888    888 `Y8bd8P' ",$0D,$0A
00CDA3  1  20 20 59 38  
00CDA7  1  38 62 20 60  
00CDC9  1  38 38 38 20          .BYTE   "888    888   X88K   888    888   X88K ",$0D,$0A
00CDCD  1  20 20 20 38  
00CDD1  1  38 38 20 20  
00CDF1  1  59 38 38 62          .BYTE   "Y88b  d88P .d8  8b. Y88b  d88P .d8  8b. ",$0D,$0A
00CDF5  1  20 20 64 38  
00CDF9  1  38 50 20 2E  
00CE1B  1  20 20 59 38          .BYTE   "  Y8888P   888  888   Y8888P   888  888 ",$0D,$0A,$0D,$0A
00CE1F  1  38 38 38 50  
00CE23  1  20 20 20 38  
00CE47  1               
00CE47  1                       .SEGMENT "TROM"
00CE47  1                       .ORG    $F000
00F000  1                       .INCLUDE "miniassembler.asm"
00F000  2               ;*
00F000  2               ;* ASSEMBLER/DISSASSEMBLER
00F000  2               ;*
00F000  2               ;* Based on original source code by Jim Butterfield
00F000  2               ;*
00F000  2               ;* Mr. Butterfield inspired many of us with his work on the commodore series of computers.
00F000  2               ;* May he rest in peace. (1936-2007)
00F000  2               ;*
00F000  2               
00F000  2               ;__DISASSEMBLE_________________________________________________
00F000  2               ;
00F000  2               ; Disassemble assembly lines to screen
00F000  2               ; USAGE:
00F000  2               ;
00F000  2               ; DISSASSEMBLE XXXX
00F000  2               ;______________________________________________________________
00F000  2               DISASSEMBLE:
00F000  2               
00F000  2  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F002  2  85 3B                STA     WORKPTR         ;
00F004  2  A9 04                LDA     #>INBUFFER      ;
00F006  2  85 3C                STA     WORKPTR +1      ;
00F008  2               
00F008  2  A9 0B                LDA     #11
00F00A  2  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "DISASSEMBLE"
00F00D  2               
00F00D  2  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00F010  2  20 E4 F8             JSR     GETNUMBER       ; GET THE STARTING ADDRESS
00F013  2  B0 45                BCS     DISASSEMBLE_ERROR; IF NOT A NUMBER, REPORT ERROR
00F015  2  A5 3F                LDA     TEMPWORD
00F017  2  85 C1                STA     tmp0
00F019  2  A5 40                LDA     TEMPWORD+1
00F01B  2  85 C2                STA     tmp0+1
00F01D  2               diss:
00F01D  2  A9 0F                LDA     #$0f
00F01F  2  85 45                STA     TEMPBYTE
00F021  2               dislp:
00F021  2  20 7F F0             JSR     diss1
00F024  2  20 E2 F0             JSR     pcadj
00F027  2  85 C1                STA     tmp0
00F029  2  84 C2                STY     tmp0+1
00F02B  2  C6 45                DEC     TEMPBYTE
00F02D  2  D0 F2                BNE     dislp
00F02F  2               
00F02F  2               
00F02F  2  A9 45                LDA     #<DISSASSEMBLE_TEXT; LOAD LOW BYTE OF PROMPT STRING
00F031  2  85 4F                STA     STRPTR          ; STORE IN POINTER LOW BYTE
00F033  2  A9 F0                LDA     #>DISSASSEMBLE_TEXT; LOAD HOGH BYTE OF PROMPR STRING
00F035  2  85 50                STA     STRPTR +1       ; STORE IN POINTER HIGH BYTE
00F037  2  20 62 F9             JSR     OUTSTR          ; OUTPUT THE STRING
00F03A  2               
00F03A  2  20 35 FA             JSR     IOF_CONINW
00F03D  2  C9 59                CMP     #'Y'
00F03F  2  D0 03                BNE     dissexit
00F041  2  4C 1D F0             JMP     diss
00F044  2               dissexit:
00F044  2  60                   RTS
00F045  2               DISSASSEMBLE_TEXT:
00F045  2  0D 0A                .BYTE   $0d,$0a
00F047  2  43 4F 4E 54          .BYTE   "CONTINUE? (Y/N) "
00F04B  2  49 4E 55 45  
00F04F  2  3F 20 28 59  
00F057  2  0D 0A 00             .BYTE   $0d,$0a,$00
00F05A  2               
00F05A  2               DISASSEMBLE_ERROR:
00F05A  2  4C D9 F8             JMP     INVALID_NUMBER_ERROR
00F05D  2               ENTER_BYTE:
00F05D  2  AA                   TAX                     ; SAVE A REGISTER
00F05E  2  4A                   LSR     A               ; SHIFT HIGH NIBBLE TO LOW NIBBLE
00F05F  2  4A                   LSR     A               ;
00F060  2  4A                   LSR     A               ;
00F061  2  4A                   LSR     A               ;
00F062  2  18                   CLC                     ; CLEAR CARRY
00F063  2  20 6A F0             JSR     ENTER_DIGIT     ; PRINT LOW NIBBLE
00F066  2  8A                   TXA                     ; RESTORE ACCUMULATOR
00F067  2  4C 6A F0             JMP     ENTER_DIGIT     ; PRINT LOW NIBBLE
00F06A  2               ENTER_DIGIT:
00F06A  2  29 0F                AND     #$0F            ; STRIP OFF HIGH NIBBLE
00F06C  2  09 30                ORA     #$30            ; ADD $30 TO PRODUCE ASCII
00F06E  2  C9 3A                CMP     #$3A            ; IS GREATER THAN 9
00F070  2  30 03                BMI     ENTER_DIGIT_OUT ; NO, SKIP ADD
00F072  2  18                   CLC                     ; CLEAR CARRY
00F073  2  69 07                ADC     #$07            ; ADD ON FOR LETTER VALUES
00F075  2               ENTER_DIGIT_OUT:                ;
00F075  2  48                   PHA
00F076  2  20 42 FA             JSR     IOF_OUTCH       ; PRINT OUT CHAR
00F079  2  68                   PLA
00F07A  2  85 3B                STA     WORKPTR
00F07C  2  4C B1 F8             JMP     INCWORKPTR
00F07F  2               
00F07F  2               
00F07F  2               
00F07F  2               
00F07F  2               ;__diss1_______________________________________________________
00F07F  2               ;
00F07F  2               ; Disassemble 1 assembly line to screen
00F07F  2               ; Parms:
00F07F  2               ; tmp0 (WORD) Word Pointer to begin disassembly
00F07F  2               ;______________________________________________________________
00F07F  2               diss1:
00F07F  2  20 70 F1             JSR     crlf
00F082  2  A9 2E                LDA     #'.'
00F084  2  20 42 FA             JSR     IOF_OUTCH
00F087  2  20 6C F1             JSR     space
00F08A  2               diss1a:
00F08A  2  20 E9 F2             JSR     PRINT_WORD
00F08D  2  20 6C F1             JSR     space
00F090  2  A2 00                LDX     #0
00F092  2  A1 C1                LDA     (tmp0,x)
00F094  2  20 F1 F0             JSR     instxx
00F097  2  48                   PHA
00F098  2  20 37 F1             JSR     disvv
00F09B  2  68                   PLA
00F09C  2  20 4D F1             JSR     propxx
00F09F  2  A2 06                LDX     #$06
00F0A1  2               pradr1:
00F0A1  2  E0 03                CPX     #$03
00F0A3  2  D0 12                BNE     pradr3
00F0A5  2  A4 1F                LDY     length
00F0A7  2  F0 0E                BEQ     pradr3
00F0A9  2               pradr2:
00F0A9  2  A5 2A                LDA     acmd
00F0AB  2  C9 E8                CMP     #$e8
00F0AD  2  B1 C1                LDA     (tmp0),y
00F0AF  2  B0 1C                BCS     reladr
00F0B1  2  20 DA F0             JSR     prbyte
00F0B4  2  88                   DEY
00F0B5  2  D0 F2                BNE     pradr2
00F0B7  2               pradr3:
00F0B7  2  06 2A                ASL     acmd
00F0B9  2  90 0E                BCC     pradr4
00F0BB  2  BD B5 F3             LDA     char1-1,x
00F0BE  2  20 26 F3             JSR     chrout
00F0C1  2  BD BB F3             LDA     char2-1,x
00F0C4  2  F0 03                BEQ     pradr4
00F0C6  2  20 26 F3             JSR     chrout
00F0C9  2               pradr4:
00F0C9  2  CA                   DEX
00F0CA  2  D0 D5                BNE     pradr1
00F0CC  2  60                   RTS
00F0CD  2               ; ** print rel address **
00F0CD  2               reladr:
00F0CD  2  20 E5 F0             JSR     pcadj3
00F0D0  2  AA                   TAX
00F0D1  2  E8                   INX
00F0D2  2  D0 01                BNE     prntyx
00F0D4  2  C8                   INY
00F0D5  2               ; ** print word address **
00F0D5  2               prntyx:
00F0D5  2  98                   TYA
00F0D6  2  20 DA F0             JSR     prbyte
00F0D9  2  8A                   TXA
00F0DA  2               ; ** print Byte **
00F0DA  2               prbyte:
00F0DA  2  86 1C                STX     savx
00F0DC  2  20 47 F9             JSR     PRINT_BYTE
00F0DF  2  A6 1C                LDX     savx
00F0E1  2  60                   RTS
00F0E2  2               ; ** advance the program counter **
00F0E2  2               pcadj:
00F0E2  2  A5 1F                LDA     length
00F0E4  2  38                   SEC
00F0E5  2               pcadj3:
00F0E5  2  A4 C2                LDY     tmp0+1
00F0E7  2  AA                   TAX
00F0E8  2  10 01                BPL     pcadj4
00F0EA  2  88                   DEY
00F0EB  2               pcadj4:
00F0EB  2  65 C1                ADC     tmp0
00F0ED  2  90 01                BCC     rts1
00F0EF  2  C8                   INY
00F0F0  2               rts1:
00F0F0  2  60                   RTS
00F0F1  2               ; ** check inst valid, len **
00F0F1  2               instxx:
00F0F1  2  A8                   TAY
00F0F2  2  4A                   LSR     a
00F0F3  2  90 0B                BCC     ieven
00F0F5  2  4A                   LSR     a
00F0F6  2  B0 17                BCS     err
00F0F8  2  C9 22                CMP     #$22
00F0FA  2  F0 13                BEQ     err
00F0FC  2  29 07                AND     #$07
00F0FE  2  09 80                ORA     #$80
00F100  2               ieven:
00F100  2  4A                   LSR     a
00F101  2  AA                   TAX
00F102  2  BD 64 F3             LDA     mode,x
00F105  2  B0 04                BCS     rtmode
00F107  2  4A                   LSR     a
00F108  2  4A                   LSR     a
00F109  2  4A                   LSR     a
00F10A  2  4A                   LSR     a
00F10B  2               rtmode:
00F10B  2  29 0F                AND     #$0f
00F10D  2  D0 04                BNE     getfmt
00F10F  2               err:
00F10F  2  A0 80                LDY     #$80
00F111  2  A9 00                LDA     #0
00F113  2               ; ** get addr mode, length **
00F113  2               getfmt:
00F113  2  AA                   TAX
00F114  2  BD A8 F3             LDA     mode2,x
00F117  2  85 2A                STA     acmd
00F119  2  29 03                AND     #$03
00F11B  2  85 1F                STA     length
00F11D  2               ; ** extract intructn **
00F11D  2  98                   TYA
00F11E  2  29 8F                AND     #$8f
00F120  2  AA                   TAX
00F121  2  98                   TYA
00F122  2  A0 03                LDY     #$03
00F124  2  E0 8A                CPX     #$8a
00F126  2  F0 0B                BEQ     mnndx3
00F128  2               mnndx1:
00F128  2  4A                   LSR     a
00F129  2  90 08                BCC     mnndx3
00F12B  2  4A                   LSR     a
00F12C  2               mnndx2:
00F12C  2  4A                   LSR     a
00F12D  2  09 20                ORA     #$20
00F12F  2  88                   DEY
00F130  2  D0 FA                BNE     mnndx2
00F132  2  C8                   INY
00F133  2               mnndx3:
00F133  2  88                   DEY
00F134  2  D0 F2                BNE     mnndx1
00F136  2  60                   RTS
00F137  2               ; print bytes
00F137  2               disvv:
00F137  2  B1 C1                LDA     (tmp0),y
00F139  2  20 DA F0             JSR     prbyte
00F13C  2  A2 01                LDX     #1
00F13E  2               disvl:
00F13E  2  20 1F F3             JSR     spacd
00F141  2  C4 1F                CPY     length
00F143  2  C8                   INY
00F144  2  90 F1                BCC     disvv
00F146  2  A2 03                LDX     #$03
00F148  2  C0 04                CPY     #4
00F14A  2  90 F2                BCC     disvl
00F14C  2  60                   RTS
00F14D  2               ; ** print mnemonic **
00F14D  2               propxx:
00F14D  2  A8                   TAY
00F14E  2  B9 C2 F3             LDA     mneml,y
00F151  2  85 28                STA     aflg
00F153  2  B9 02 F4             LDA     mnemr,y
00F156  2  85 29                STA     aflg+1
00F158  2               prmn1:
00F158  2  A9 00                LDA     #0
00F15A  2  A0 05                LDY     #$05
00F15C  2               prmn2:
00F15C  2  06 29                ASL     aflg+1
00F15E  2  26 28                ROL     aflg
00F160  2  2A                   ROL     a
00F161  2  88                   DEY
00F162  2  D0 F8                BNE     prmn2
00F164  2  69 3F                ADC     #$3f
00F166  2  20 42 FA             JSR     IOF_OUTCH
00F169  2  CA                   DEX
00F16A  2  D0 EC                BNE     prmn1
00F16C  2               ; ** print space **
00F16C  2               space:
00F16C  2  A9 20                LDA     #$20
00F16E  2  D0 07                BNE     flip
00F170  2               ; ** print cr, maybe lf **
00F170  2               crlf:
00F170  2  A9 0D                LDA     #$0d
00F172  2  20 42 FA             JSR     IOF_OUTCH
00F175  2  A9 0A                LDA     #$0a
00F177  2               flip:
00F177  2  4C 42 FA             JMP     IOF_OUTCH
00F17A  2               
00F17A  2               
00F17A  2               ;__ASSEMBLE____________________________________________________
00F17A  2               ;
00F17A  2               ; Assemble line from keyboard to memory
00F17A  2               ;______________________________________________________________
00F17A  2               ASSEMBLE:
00F17A  2  A9 00                LDA     #(INBUFFER & $FF); SETUP WORK BUFFER
00F17C  2  85 3B                STA     WORKPTR         ;
00F17E  2  A9 04                LDA     #(INBUFFER >> 8);
00F180  2  85 3C                STA     WORKPTR +1      ;
00F182  2               
00F182  2  A9 08                LDA     #8
00F184  2  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "ASSEMBLE"
00F187  2               
00F187  2  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER ANY WHITESPACE
00F18A  2  20 E4 F8             JSR     GETNUMBER       ; GET NUMBER
00F18D  2  B0 03                BCS     ASSEMBLE_ERROR  ; IF NOT A NUMBER REPORT ERROR
00F18F  2  4C 95 F1             JMP     asvald
00F192  2               ASSEMBLE_ERROR:
00F192  2  4C 19 F3             JMP     error
00F195  2               asvald:
00F195  2  A5 3F                LDA     TEMPWORD
00F197  2  85 C1                STA     tmp0
00F199  2  A5 40                LDA     TEMPWORD+1
00F19B  2  85 C2                STA     tmp0+1
00F19D  2               asv1:
00F19D  2  20 70 F1             JSR     crlf
00F1A0  2  A9 2E                LDA     #'.'
00F1A2  2  20 42 FA             JSR     IOF_OUTCH
00F1A5  2  20 6C F1             JSR     space
00F1A8  2  20 E9 F2             JSR     PRINT_WORD
00F1AB  2  20 6C F1             JSR     space
00F1AE  2  20 D9 F2             JSR     t2t2
00F1B1  2  8E 11 02             STX     stage+1
00F1B4  2  A9 00                LDA     #(INBUFFER & $FF); SETUP INPUT COMMAND BUFFER
00F1B6  2  85 4F                STA     STRPTR          ;
00F1B8  2  85 3B                STA     WORKPTR         ;
00F1BA  2  A9 04                LDA     #(INBUFFER >> 8);
00F1BC  2  85 50                STA     STRPTR +1       ;
00F1BE  2  85 3C                STA     WORKPTR+1       ;
00F1C0  2  20 77 F9             JSR     INSTR           ; GET A STRING FROM THE CONSOLE
00F1C3  2  20 38 F9             JSR     EATWHITESPACE
00F1C6  2  A2 03                LDX     #$03            ; push opcode to stack
00F1C8  2  A0 00                LDY     #$00
00F1CA  2               apush:
00F1CA  2  B1 3B                LDA     (WORKPTR),Y     ; GET NEXT CHAR FROM BUFFER
00F1CC  2  48                   PHA
00F1CD  2  20 B1 F8             JSR     INCWORKPTR
00F1D0  2  CA                   DEX
00F1D1  2  D0 F7                BNE     apush
00F1D3  2               
00F1D3  2  A2 03                LDX     #$03
00F1D5  2               apull:
00F1D5  2  68                   PLA
00F1D6  2  38                   SEC
00F1D7  2  E9 3F                SBC     #$3f
00F1D9  2  A0 05                LDY     #$05
00F1DB  2               acrun:
00F1DB  2  4A                   LSR     a
00F1DC  2  6E 11 02             ROR     stage+1
00F1DF  2  6E 10 02             ROR     stage
00F1E2  2  88                   DEY
00F1E3  2  D0 F6                BNE     acrun
00F1E5  2  CA                   DEX
00F1E6  2  D0 ED                BNE     apull
00F1E8  2  A2 02                LDX     #$02
00F1EA  2               ainp:
00F1EA  2  A0 00                LDY     #$00
00F1EC  2  B1 3B                LDA     (WORKPTR),Y     ; GET NEXT CHAR FROM BUFFER
00F1EE  2  20 B1 F8             JSR     INCWORKPTR
00F1F1  2  C9 00                CMP     #$00
00F1F3  2  F0 1E                BEQ     aret
00F1F5  2  C9 20                CMP     #$20
00F1F7  2  F0 F1                BEQ     ainp
00F1F9  2  20 D0 F2             JSR     ahex
00F1FC  2  B0 0F                BCS     stone
00F1FE  2               
00F1FE  2  20 46 F3             JSR     rdob2
00F201  2  A4 C1                LDY     tmp0
00F203  2  84 C2                STY     tmp0+1
00F205  2  85 C1                STA     tmp0
00F207  2               
00F207  2  A9 30                LDA     #$30
00F209  2  9D 10 02             STA     stage,x
00F20C  2  E8                   INX
00F20D  2               stone:
00F20D  2  9D 10 02             STA     stage,x
00F210  2  E8                   INX
00F211  2  D0 D7                BNE     ainp
00F213  2               aret:
00F213  2  86 28                STX     aflg
00F215  2  A2 00                LDX     #0
00F217  2  86 26                STX     wrap
00F219  2  F0 04                BEQ     atry
00F21B  2               abump:
00F21B  2  E6 26                INC     wrap
00F21D  2  F0 75                BEQ     aerr
00F21F  2               atry:
00F21F  2  A2 00                LDX     #0
00F221  2  86 1D                STX     tmpc
00F223  2  A5 26                LDA     wrap
00F225  2  20 F1 F0             JSR     instxx
00F228  2  A6 2A                LDX     acmd
00F22A  2  86 29                STX     aflg+1
00F22C  2  AA                   TAX
00F22D  2  BC C2 F3             LDY     mneml,x
00F230  2  BD 02 F4             LDA     mnemr,x
00F233  2  20 B9 F2             JSR     achek2
00F236  2  D0 E3                BNE     abump
00F238  2  A2 06                LDX     #$06
00F23A  2               aoprnd:
00F23A  2  E0 03                CPX     #$03
00F23C  2  D0 19                BNE     ashf
00F23E  2  A4 1F                LDY     length
00F240  2  F0 15                BEQ     ashf
00F242  2               arsc:
00F242  2  A5 2A                LDA     acmd
00F244  2  C9 E8                CMP     #$e8
00F246  2  A9 30                LDA     #$30
00F248  2  B0 21                BCS     arel1
00F24A  2  20 BF F2             JSR     acheck
00F24D  2  D0 CC                BNE     abump
00F24F  2  20 C1 F2             JSR     achick
00F252  2  D0 C7                BNE     abump
00F254  2  88                   DEY
00F255  2  D0 EB                BNE     arsc
00F257  2               ashf:
00F257  2  06 2A                ASL     acmd
00F259  2  90 0B                BCC     adex
00F25B  2  BC BB F3             LDY     char2-1,x
00F25E  2  BD B5 F3             LDA     char1-1,x
00F261  2  20 B9 F2             JSR     achek2
00F264  2  D0 B5                BNE     abump
00F266  2               adex:
00F266  2  CA                   DEX
00F267  2  D0 D1                BNE     aoprnd
00F269  2  F0 0A                BEQ     ald
00F26B  2               arel1:
00F26B  2  20 B8 F2             JSR     acdb1
00F26E  2  D0 AB                BNE     abump
00F270  2  20 B8 F2             JSR     acdb1
00F273  2  D0 A6                BNE     abump
00F275  2               ald:
00F275  2  A5 28                LDA     aflg
00F277  2  C5 1D                CMP     tmpc
00F279  2  D0 A0                BNE     abump
00F27B  2  20 D9 F2             JSR     t2t2
00F27E  2  A4 1F                LDY     length
00F280  2  F0 28                BEQ     aopset
00F282  2  A5 29                LDA     aflg+1
00F284  2  C9 9D                CMP     #$9d
00F286  2  D0 1A                BNE     aopnd
00F288  2  20 F6 F2             JSR     diffb
00F28B  2  90 0A                BCC     abdown
00F28D  2  98                   TYA
00F28E  2  D0 04                BNE     aerr
00F290  2  A5 44                LDA     nemo
00F292  2  10 0A                BPL     abran
00F294  2               aerr:
00F294  2  4C 19 F3             JMP     error
00F297  2               abdown:
00F297  2  C8                   INY
00F298  2  D0 FA                BNE     aerr
00F29A  2  A5 44                LDA     nemo
00F29C  2  10 F6                BPL     aerr
00F29E  2               abran:
00F29E  2  A4 1F                LDY     length
00F2A0  2  D0 03                BNE     abrel
00F2A2  2               aopnd:
00F2A2  2  B9 C2 00             LDA     tmp2-1,y
00F2A5  2               abrel:
00F2A5  2  91 C1                STA     (tmp0),y
00F2A7  2  88                   DEY
00F2A8  2  D0 F8                BNE     aopnd
00F2AA  2               aopset:
00F2AA  2  A5 26                LDA     wrap
00F2AC  2  91 C1                STA     (tmp0),y
00F2AE  2  20 E2 F0             JSR     pcadj
00F2B1  2  85 C1                STA     tmp0
00F2B3  2  84 C2                STY     tmp0+1
00F2B5  2  4C 9D F1             JMP     asv1
00F2B8  2               acdb1:
00F2B8  2  A8                   TAY
00F2B9  2               achek2:
00F2B9  2  20 BF F2             JSR     acheck
00F2BC  2  D0 11                BNE     acex
00F2BE  2  98                   TYA
00F2BF  2               acheck:
00F2BF  2  F0 0E                BEQ     acex
00F2C1  2               achick:
00F2C1  2  86 1C                STX     savx
00F2C3  2  A6 1D                LDX     tmpc
00F2C5  2  DD 10 02             CMP     stage,x
00F2C8  2  08                   PHP
00F2C9  2  E8                   INX
00F2CA  2  86 1D                STX     tmpc
00F2CC  2  A6 1C                LDX     savx
00F2CE  2  28                   PLP
00F2CF  2               acex:
00F2CF  2  60                   RTS
00F2D0  2               ahex:
00F2D0  2  C9 30                CMP     #$30
00F2D2  2  90 03                BCC     asx
00F2D4  2  C9 47                CMP     #$47
00F2D6  2  60                   RTS
00F2D7  2               asx:
00F2D7  2  38                   SEC
00F2D8  2  60                   RTS
00F2D9  2               
00F2D9  2               
00F2D9  2               
00F2D9  2               ; ** swap tmp0, tmp2 **
00F2D9  2               t2t2:
00F2D9  2  A2 02                LDX     #$02
00F2DB  2               t2t21:
00F2DB  2  B5 C0                LDA     tmp0-1,x
00F2DD  2  48                   PHA
00F2DE  2  B5 C2                LDA     tmp2-1,x
00F2E0  2  95 C0                STA     tmp0-1,x
00F2E2  2  68                   PLA
00F2E3  2  95 C2                STA     tmp2-1,x
00F2E5  2  CA                   DEX
00F2E6  2  D0 F3                BNE     t2t21
00F2E8  2  60                   RTS
00F2E9  2               
00F2E9  2               PRINT_WORD:
00F2E9  2  48                   PHA
00F2EA  2  A5 C2                LDA     tmp0+1
00F2EC  2  20 DA F0             JSR     prbyte
00F2EF  2  A5 C1                LDA     tmp0
00F2F1  2  20 DA F0             JSR     prbyte
00F2F4  2  68                   PLA
00F2F5  2  60                   RTS
00F2F6  2               ; ** calc tmp2-tmp0-2 **
00F2F6  2               diffb:
00F2F6  2  A5 C3                LDA     tmp2
00F2F8  2  A4 C4                LDY     tmp2+1
00F2FA  2  38                   SEC
00F2FB  2  E9 02                SBC     #2
00F2FD  2  B0 0E                BCS     deck
00F2FF  2  88                   DEY
00F300  2  90 0B                BCC     deck
00F302  2               ; ** calc aflg-tmp0 **
00F302  2               diffa:
00F302  2  A5 28                LDA     aflg
00F304  2  A4 29                LDY     aflg+1
00F306  2  4C 0D F3             JMP     deck
00F309  2               ; ** calc tmp2-tmp0 **
00F309  2               diffp:
00F309  2  A5 C3                LDA     tmp2
00F30B  2  A4 C4                LDY     tmp2+1
00F30D  2               deck:
00F30D  2  38                   SEC
00F30E  2  E5 C1                SBC     tmp0
00F310  2  85 44                STA     nemo
00F312  2  98                   TYA
00F313  2  E5 C2                SBC     tmp0+1
00F315  2  A8                   TAY
00F316  2  05 44                ORA     nemo
00F318  2  60                   RTS
00F319  2               
00F319  2               error:
00F319  2  A9 3F                LDA     #$3f
00F31B  2  20 42 FA             JSR     IOF_OUTCH
00F31E  2  60                   RTS
00F31F  2               ; ** print spaces **
00F31F  2               spacd:
00F31F  2  20 6C F1             JSR     space
00F322  2  CA                   DEX
00F323  2  D0 FA                BNE     spacd
00F325  2  60                   RTS
00F326  2               chrout:
00F326  2  C5 28                CMP     aflg
00F328  2  F0 03                BEQ     caltrit
00F32A  2  20 42 FA             JSR     IOF_OUTCH
00F32D  2               caltrit:
00F32D  2  60                   RTS
00F32E  2               
00F32E  2               altrit:
00F32E  2  98                   TYA
00F32F  2  48                   PHA
00F330  2  20 70 F1             JSR     crlf
00F333  2  68                   PLA
00F334  2  20 42 FA             JSR     IOF_OUTCH
00F337  2  A9 2E                LDA     #$2e
00F339  2  4C 42 FA             JMP     IOF_OUTCH
00F33C  2               
00F33C  2               ; ** print hex byte **
00F33C  2               wroa:
00F33C  2  A5 C2                LDA     tmp0+1
00F33E  2  20 47 F9             JSR     PRINT_BYTE
00F341  2  A5 C1                LDA     tmp0
00F343  2  4C 47 F9             JMP     PRINT_BYTE
00F346  2               
00F346  2               ; ** read hex byte **
00F346  2               rdob2:
00F346  2  20 5B F3             JSR     hexit
00F349  2  0A                   ASL     a
00F34A  2  0A                   ASL     a
00F34B  2  0A                   ASL     a
00F34C  2  0A                   ASL     a
00F34D  2  85 2A                STA     acmd
00F34F  2  B1 3B                LDA     (WORKPTR),Y     ; GET NEXT CHAR FROM BUFFER
00F351  2  20 B1 F8             JSR     INCWORKPTR
00F354  2               rdob3:
00F354  2  20 5B F3             JSR     hexit
00F357  2  05 2A                ORA     acmd
00F359  2  38                   SEC
00F35A  2  60                   RTS
00F35B  2               ; ** convert from hex **
00F35B  2               hexit:
00F35B  2  C9 3A                CMP     #$3a
00F35D  2  90 02                BCC     hex08
00F35F  2  69 08                ADC     #$08
00F361  2               hex08:
00F361  2  29 0F                AND     #$0f
00F363  2  60                   RTS
00F364  2               
00F364  2               
00F364  2               ; mode table... nybble organized
00F364  2               ; 0= err  4= implied  8= zer,x   c= zer,y
00F364  2               ; 1= imm  5= acc      9= abs,x   d= rel
00F364  2               ; 2= zer  6= (ind,x)  a= abs,y
00F364  2               ; 3= abs  7= (ind),y  b= (ind)
00F364  2               mode:
00F364  2  40 02 45 03          .BYTE   $40,$02,$45,$03
00F368  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F36C  2  30 22 45 33          .BYTE   $30,$22,$45,$33
00F370  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F374  2  40 02 45 33          .BYTE   $40,$02,$45,$33
00F378  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F37C  2  40 02 45 B3          .BYTE   $40,$02,$45,$b3
00F380  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F384  2  00 22 44 33          .BYTE   $00,$22,$44,$33
00F388  2  D0 8C 44 00          .BYTE   $d0,$8c,$44,$00
00F38C  2  11 22 44 33          .BYTE   $11,$22,$44,$33
00F390  2  D0 8C 44 9A          .BYTE   $d0,$8c,$44,$9a
00F394  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F398  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F39C  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F3A0  2  D0 08 40 09          .BYTE   $d0,$08,$40,$09
00F3A4  2  62 13 78 A9          .BYTE   $62,$13,$78,$a9
00F3A8  2               ;master modes
00F3A8  2               ;six hi-order bits  mode options
00F3A8  2               ;two lo-order bits  operand length ready.
00F3A8  2               mode2:
00F3A8  2  00 21 81 82          .BYTE   $00,$21,$81,$82
00F3AC  2  00 00 59 4D          .BYTE   $00,$00,$59,$4d
00F3B0  2  91 92 86 4A          .BYTE   $91,$92,$86,$4a,$85,$9d
00F3B4  2  85 9D        
00F3B6  2               char1:
00F3B6  2  2C 29 2C 23          .BYTE   $2c,$29,$2c,$23,$28,$24
00F3BA  2  28 24        
00F3BC  2               char2:
00F3BC  2  59 00 58 24          .BYTE   $59,$00,$58,$24,$24,$00
00F3C0  2  24 00        
00F3C2  2               ; packed mnemonics
00F3C2  2               mneml:
00F3C2  2  1C 8A 1C 23          .BYTE   $1c,$8a,$1c,$23
00F3C6  2  5D 8B 1B A1          .BYTE   $5d,$8b,$1b,$a1
00F3CA  2  9D 8A 1D 23          .BYTE   $9d,$8a,$1d,$23
00F3CE  2  9D 8B 1D A1          .BYTE   $9d,$8b,$1d,$a1
00F3D2  2  00 29 19 AE          .BYTE   $00,$29,$19,$ae
00F3D6  2  69 A8 19 23          .BYTE   $69,$a8,$19,$23
00F3DA  2  24 53 1B 23          .BYTE   $24,$53,$1b,$23
00F3DE  2  24 53 19 A1          .BYTE   $24,$53,$19,$a1
00F3E2  2  00 1A 5B 5B          .BYTE   $00,$1a,$5b,$5b
00F3E6  2  A5 69 24 24          .BYTE   $a5,$69,$24,$24
00F3EA  2  AE AE A8 AD          .BYTE   $ae,$ae,$a8,$ad
00F3EE  2  29 00 7C 00          .BYTE   $29,$00,$7c,$00
00F3F2  2  15 9C 6D 9C          .BYTE   $15,$9c,$6d,$9c
00F3F6  2  A5 69 29 53          .BYTE   $a5,$69,$29,$53
00F3FA  2  84 13 34 11          .BYTE   $84,$13,$34,$11
00F3FE  2  A5 69 23 A0          .BYTE   $a5,$69,$23,$a0
00F402  2               
00F402  2               mnemr:
00F402  2  D8 62 5A 48          .BYTE   $d8,$62,$5a,$48
00F406  2  26 62 94 88          .BYTE   $26,$62,$94,$88
00F40A  2  54 44 C8 54          .BYTE   $54,$44,$c8,$54
00F40E  2  68 44 E8 94          .BYTE   $68,$44,$e8,$94
00F412  2  00 B4 08 84          .BYTE   $00,$b4,$08,$84
00F416  2  74 B4 28 6E          .BYTE   $74,$b4,$28,$6e
00F41A  2  74 F4 CC 4A          .BYTE   $74,$f4,$cc,$4a
00F41E  2  72 F2 A4 8A          .BYTE   $72,$f2,$a4,$8a
00F422  2  00 AA A2 A2          .BYTE   $00,$aa,$a2,$a2
00F426  2  74 74 74 72          .BYTE   $74,$74,$74,$72
00F42A  2  44 68 B2 32          .BYTE   $44,$68,$b2,$32
00F42E  2  B2 00 22 00          .BYTE   $b2,$00,$22,$00
00F432  2  1A 1A 26 26          .BYTE   $1a,$1a,$26,$26
00F436  2  72 72 88 C8          .BYTE   $72,$72,$88,$c8
00F43A  2  C4 CA 26 48          .BYTE   $c4,$ca,$26,$48
00F43E  2  44 44 A2 C8          .BYTE   $44,$44,$a2,$c8
00F442  2               
00F442  1                       .INCLUDE "bios_ppp_common.asm"
00F442  2               ;__Parallel Port Prop Common Code_________________________________________________________________________________________________
00F442  2               ;
00F442  2               ; 	This is the code that is common to all PPP drivers
00F442  2               ;
00F442  2               ;	Entry points:
00F442  2               ;		INIT_PPP - INIT THE PPP HARDWARE
00F442  2               ;		SENDCMD - SEND A COMMAND TO THE PPP HARDWARE
00F442  2               ;		PUTBYTE -  SEND A BYTE TO THE PPP HARDWARE
00F442  2               ;		GETBYTE -  GET BYTE FROM THE PPP HARDWARE
00F442  2               ;________________________________________________________________________________________________________________________________
00F442  2               ;
00F442  2               
00F442  2               
00F442  2               
00F442  2               ;*
00F442  2               ;* HARDWARE I/O ADDRESSES
00F442  2               ;*
00F442  2               PPPPIOA         = M6X0X_IOSPACE+$EFC
00F442  2               PPPCNTA         = M6X0X_IOSPACE+$EFD
00F442  2               PPPPIOB         = M6X0X_IOSPACE+$EFE
00F442  2               PPPCNTB         = M6X0X_IOSPACE+$EFF
00F442  2               
00F442  2               ;*__INIT_PPP___________________________________________________________________________________
00F442  2               ;*
00F442  2               ;*  INIT THE PPP HARDWARE
00F442  2               ;*
00F442  2               ;*____________________________________________________________________________________________________
00F442  2               INIT_PPP:
00F442  2               
00F442  2  A9 00                LDA     #$00            ; SELECT DDR
00F444  2  8D FD EE             STA     PPPCNTA
00F447  2  A9 00                LDA     #$00            ; SET ALL PINS INPUT
00F449  2  8D FC EE             STA     PPPPIOA         ;
00F44C  2  A9 00                LDA     #$00            ; SELECT DDR
00F44E  2  8D FF EE             STA     PPPCNTB
00F451  2               
00F451  2  A9 6F                LDA     #%01101111      ; SET CONTROL PINS
00F453  2               ; PB0=>CMD/DATA	[O]
00F453  2               ; PB1=> X  		[O]
00F453  2               ; PB2=> RESET 	[O]
00F453  2               ; PB3=> X   	[O]
00F453  2               ; PB4=> STB 	[I]
00F453  2               ; PB5=> IBF 	[0]
00F453  2               ; PB6=> ACK 	[O]
00F453  2               ; PB7=> OBF 	[I]
00F453  2               ;
00F453  2  8D FE EE             STA     PPPPIOB         ;
00F456  2               
00F456  2  A9 04                LDA     #$04            ; SELECT PIO
00F458  2  8D FD EE             STA     PPPCNTA
00F45B  2  8D FF EE             STA     PPPCNTB
00F45E  2               
00F45E  2  A9 04                LDA     #%00000100      ; ASSERT RESET
00F460  2  8D FE EE             STA     PPPPIOB
00F463  2  A9 01                LDA     #%00000001      ; DEASSERT RESET,  DATA
00F465  2  8D FE EE             STA     PPPPIOB
00F468  2               
00F468  2               INIT_PPP0:
00F468  2               
00F468  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F46B  2  09 40                ORA     #%01000000
00F46D  2  8D FE EE             STA     PPPPIOB
00F470  2               
00F470  2               INIT_PPP1:
00F470  2               ; WAIT FOR STB LOW (OUTPUT BUFFER READY)
00F470  2  AD FE EE             LDA     PPPPIOB         ;
00F473  2  29 10                AND     #%00010000      ;
00F475  2  D0 F9                BNE     INIT_PPP1       ;
00F477  2  AD FC EE             LDA     PPPPIOA         ;IS $AA?
00F47A  2  C9 AA                CMP     #$AA
00F47C  2  D0 F2                BNE     INIT_PPP1       ; NO, STILL INIT IN PROCESS
00F47E  2               
00F47E  2  AD FE EE             LDA     PPPPIOB         ; YES, BRING ACK LOW
00F481  2  29 BF                AND     #%10111111
00F483  2  8D FE EE             STA     PPPPIOB
00F486  2               INIT_PPP3:                      ; WAIT FOR STB HIGH
00F486  2  AD FE EE             LDA     PPPPIOB
00F489  2  29 10                AND     #%00010000
00F48B  2  F0 F9                BEQ     INIT_PPP3
00F48D  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F490  2  09 40                ORA     #%01000000
00F492  2  8D FE EE             STA     PPPPIOB
00F495  2  60                   RTS
00F496  2               
00F496  2               
00F496  2               
00F496  2               ;*__SENDCMD___________________________________________________________________________________________
00F496  2               ;*
00F496  2               ;*  SEND A COMMAND TO THE PPP HARDWARE
00F496  2               ;*
00F496  2               ;*____________________________________________________________________________________________________
00F496  2               SENDCMD:
00F496  2  48                   PHA
00F497  2               SENDCMD1:
00F497  2  AD FE EE             LDA     PPPPIOB         ;
00F49A  2  29 FE                AND     #%11111110      ; SET CMD FLAG
00F49C  2  8D FE EE             STA     PPPPIOB         ; SEND IT
00F49F  2  68                   PLA
00F4A0  2  20 AC F4             JSR     PUTBYTE         ; SEND THE COMMAND BYTE
00F4A3  2               ; TURN OFF CMD
00F4A3  2  AD FE EE             LDA     PPPPIOB         ;
00F4A6  2  09 01                ORA     #%00000001      ; CLEAR CMD FLAG
00F4A8  2  8D FE EE             STA     PPPPIOB         ; SEND IT
00F4AB  2  60                   RTS
00F4AC  2               
00F4AC  2               ;*__PUTBYTE___________________________________________________________________________________________
00F4AC  2               ;*
00F4AC  2               ;*  SEND A BYTE TO THE PPP HARDWARE
00F4AC  2               ;*
00F4AC  2               ;*____________________________________________________________________________________________________
00F4AC  2               
00F4AC  2               PUTBYTE:
00F4AC  2  48                   PHA
00F4AD  2  A9 00                LDA     #$00
00F4AF  2  8D FD EE             STA     PPPCNTA
00F4B2  2  A9 FF                LDA     #$FF            ; SET ALL PINS OUTPUT
00F4B4  2  8D FC EE             STA     PPPPIOA         ;
00F4B7  2  A9 04                LDA     #$04
00F4B9  2  8D FD EE             STA     PPPCNTA
00F4BC  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F4BF  2  09 40                ORA     #%01000000
00F4C1  2  8D FE EE             STA     PPPPIOB
00F4C4  2               PUTWAIT1:
00F4C4  2               ; WAIT FOR OBF HIGH
00F4C4  2  AD FE EE             LDA     PPPPIOB         ;
00F4C7  2  29 80                AND     #%10000000      ;
00F4C9  2  F0 F9                BEQ     PUTWAIT1        ;
00F4CB  2  68                   PLA
00F4CC  2  8D FC EE             STA     PPPPIOA
00F4CF  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK LOW
00F4D2  2  29 BF                AND     #%10111111
00F4D4  2  8D FE EE             STA     PPPPIOB
00F4D7  2               PUTWAIT2:
00F4D7  2               ; WAIT FOR OBF LOW
00F4D7  2  AD FE EE             LDA     PPPPIOB         ;
00F4DA  2  29 80                AND     #%10000000      ;
00F4DC  2  D0 F9                BNE     PUTWAIT2        ;
00F4DE  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F4E1  2  09 40                ORA     #%01000000
00F4E3  2  8D FE EE             STA     PPPPIOB
00F4E6  2  60                   RTS
00F4E7  2               
00F4E7  2               ;*__GETBYTE___________________________________________________________________________________________
00F4E7  2               ;*
00F4E7  2               ;*  GET BYTE FROM THE PPP HARDWARE
00F4E7  2               ;*
00F4E7  2               ;*____________________________________________________________________________________________________
00F4E7  2               
00F4E7  2               GETBYTE:
00F4E7  2  A9 00                LDA     #$00
00F4E9  2  8D FD EE             STA     PPPCNTA
00F4EC  2  A9 00                LDA     #$00            ; SET ALL PINS INPUT
00F4EE  2  8D FC EE             STA     PPPPIOA         ;
00F4F1  2  A9 04                LDA     #$04
00F4F3  2  8D FD EE             STA     PPPCNTA
00F4F6  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F4F9  2  09 40                ORA     #%01000000
00F4FB  2  8D FE EE             STA     PPPPIOB
00F4FE  2               GETWAIT1:
00F4FE  2               ; WAIT FOR STB LOW
00F4FE  2  AD FE EE             LDA     PPPPIOB         ;
00F501  2  29 10                AND     #%00010000      ;
00F503  2  D0 F9                BNE     GETWAIT1        ;
00F505  2  AD FC EE             LDA     PPPPIOA
00F508  2  48                   PHA
00F509  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK LOW
00F50C  2  29 BF                AND     #%10111111
00F50E  2  8D FE EE             STA     PPPPIOB
00F511  2               GETWAIT2:
00F511  2               ; WAIT FOR STB HIGH
00F511  2  AD FE EE             LDA     PPPPIOB         ;
00F514  2  29 10                AND     #%00010000      ;
00F516  2  F0 F9                BEQ     GETWAIT2        ;
00F518  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00F51B  2  09 40                ORA     #%01000000
00F51D  2  8D FE EE             STA     PPPPIOB
00F520  2  68                   PLA
00F521  2  60                   RTS
00F522  2               
00F522  1                       .INCLUDE "bios_serial.asm"
00F522  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00F522  2               ;
00F522  2               ; 	serial drivers
00F522  2               ;
00F522  2               ;	Entry points:
00F522  2               ;		SERIALINIT  - called during OS init
00F522  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00F522  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00F522  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00F522  2               ;		SERIALSTATUS- GET UART STATUS
00F522  2               ;________________________________________________________________________________________________________________________________
00F522  2               ;
00F522  2               
00F522  2               
00F522  2               ;*
00F522  2               ;* HARDWARE I/O ADDRESSES
00F522  2               ;*
00F522  2               
00F522  2               UART1DATA       = M6X0X_IOSPACE+$FF4; SERIAL PORT 1 (I/O Card)
00F522  2               UART1STATUS     = M6X0X_IOSPACE+$FF5; SERIAL PORT 1 (I/O Card)
00F522  2               UART1COMMAND    = M6X0X_IOSPACE+$FF6; SERIAL PORT 1 (I/O Card)
00F522  2               UART1CONTROL    = M6X0X_IOSPACE+$FF7; SERIAL PORT 1 (I/O Card)
00F522  2               
00F522  2               
00F522  2               ;Command Register
00F522  2               ;No bit is affected by a software reset, however, all bits are set to zero on a hardware reset.
00F522  2               ;Bit 7 6 5  configuration
00F522  2               ;    x x 0  no parity bit
00F522  2               ;    0 0 1  send and receive with odd parity
00F522  2               ;    0 1 1  send and receive with even parity
00F522  2               ;    1 0 1  send: parity=1; receive: parity not evaluated
00F522  2               ;    1 1 1  send: parity=0; receive: parity not evaluated
00F522  2               ;
00F522  2               ;Bit 4  0: no echo
00F522  2               ;       1: echo (received characters are being sent again,
00F522  2               ;                bits 2 and 3 must be 0 for that)
00F522  2               ;
00F522  2               ;Bit 3 2  sender interr.   RTS level   sender
00F522  2               ;    0 0  no               high        off
00F522  2               ;    0 1  yes              low         on
00F522  2               ;    1 0  no               low         on
00F522  2               ;    1 1  no               low         send BRK
00F522  2               ;
00F522  2               ;Bit 1  0: interrupt gets triggered by bit 3 in status register
00F522  2               ;       1: no interrupt
00F522  2               ;
00F522  2               ;Bit 0  0: disable transceiver and interrupts, /DTR high
00F522  2               ;       1: enable transceiver and interrupts, /DTR low
00F522  2               ;
00F522  2               ;Control Register
00F522  2               ;Bits 0 to 3 are set to zero on a software reset, and all bits are set to zero on a hardware reset.
00F522  2               ;Bit 7  0: 1 stop bit
00F522  2               ;       1: a) with 8 data bits and 1 parity bit: 1 stop bit
00F522  2               ;          b) with 5 data bits and no parity bit: 1.5 stop bits
00F522  2               ;          c) otherwise 2 stop bits
00F522  2               ;
00F522  2               ;Bit 6 5  data bits
00F522  2               ;    0 0  8
00F522  2               ;    0 1  7
00F522  2               ;    1 0  6
00F522  2               ;    1 1  5
00F522  2               ;
00F522  2               ;Bit 4  0: external receive clock
00F522  2               ;       1: builtin clock as receive clock
00F522  2               ;
00F522  2               ;Bit 3 2 1 0  baud rate
00F522  2               ;    0 0 0 0  1/16 times external clock
00F522  2               ;    0 0 0 1  50 bps
00F522  2               ;    0 0 1 0  75 bps
00F522  2               ;    0 0 1 1  109.92 bps
00F522  2               ;    0 1 0 0  134.58 bps
00F522  2               ;    0 1 0 1  150 bps
00F522  2               ;    0 1 1 0  300 bps
00F522  2               ;    0 1 1 1  600 bps
00F522  2               ;    1 0 0 0  1200 bps
00F522  2               ;    1 0 0 1  1800 bps
00F522  2               ;    1 0 1 0  2400 bps
00F522  2               ;    1 0 1 1  3600 bps
00F522  2               ;    1 1 0 0  4800 bps
00F522  2               ;    1 1 0 1  7200 bps
00F522  2               ;    1 1 1 0  9600 bps
00F522  2               ;    1 1 1 1  19200 bps
00F522  2               
00F522  2               
00F522  2               
00F522  2               ;__SERIALINIT____________________________________________________________________________________________________________________
00F522  2               ;
00F522  2               ;	INITIALIZE SERIAL PORTS
00F522  2               ;________________________________________________________________________________________________________________________________
00F522  2               ;
00F522  2               SERIALINIT:
00F522  2  A9 00                LDA     #$00            ; RESET UART
00F524  2  8D F5 EF             STA     UART1STATUS     ;
00F527  2  A9 0B                LDA     #$0B            ;
00F529  2  8D F6 EF             STA     UART1COMMAND    ;
00F52C  2  A9 1E                LDA     #$1E            ; 9600, 8 BITS, NO PARITY, 1 STOP BIT
00F52E  2  8D F7 EF             STA     UART1CONTROL    ;
00F531  2  60                   RTS
00F532  2               
00F532  2               
00F532  2               
00F532  2               ;__WRSER1________________________________________________________________________________________________________________________
00F532  2               ;
00F532  2               ;	WRITE CHARACTER(A) TO UART
00F532  2               ;________________________________________________________________________________________________________________________________
00F532  2               ;
00F532  2               WRSER1:
00F532  2  48                   PHA
00F533  2               WRSER1a:
00F533  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS
00F536  2  29 10                AND     #%00010000      ; IS TX READY
00F538  2  F0 F9                BEQ     WRSER1a         ; NO, WAIT FOR IT
00F53A  2  68                   PLA
00F53B  2  8D F4 EF             STA     UART1DATA       ; WRITE DATA
00F53E  2  60                   RTS
00F53F  2               
00F53F  2               ;__RDSER1________________________________________________________________________________________________________________________
00F53F  2               ;
00F53F  2               ;	READ CHARACTER FROM UART TO (A)
00F53F  2               ;________________________________________________________________________________________________________________________________
00F53F  2               ;
00F53F  2               RDSER1:
00F53F  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS REGISTER
00F542  2  29 08                AND     #%00001000      ; IS RX READY
00F544  2  F0 04                BEQ     RDSER1N         ; NO, INDICATE NO CHAR
00F546  2  AD F4 EF             LDA     UART1DATA       ; GET DATA CHAR
00F549  2  60                   RTS
00F54A  2               RDSER1N:
00F54A  2  A9 00                LDA     #$00            ;
00F54C  2  60                   RTS                     ;
00F54D  2               
00F54D  2               ;__RDSER1W_______________________________________________________________________________________________________________________
00F54D  2               ;
00F54D  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
00F54D  2               ;________________________________________________________________________________________________________________________________
00F54D  2               ;
00F54D  2               
00F54D  2               RDSER1W:
00F54D  2  20 3F F5             JSR     RDSER1
00F550  2  C9 00                CMP     #$00
00F552  2  F0 F9                BEQ     RDSER1W
00F554  2  29 7F                AND     #$7F
00F556  2  60                   RTS
00F557  2               
00F557  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00F557  2               ;
00F557  2               ;	READ UARD STATUS
00F557  2               ;________________________________________________________________________________________________________________________________
00F557  2               ;
00F557  2               SERIALSTATUS:
00F557  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS REGISTER
00F55A  2  29 08                AND     #%00001000      ; IS RX READY
00F55C  2  D0 03                BNE     RDSTAT1         ; NO, INDICATE NO CHAR
00F55E  2  A9 00                LDA     #$00            ; GET DATA CHAR
00F560  2  60                   RTS
00F561  2               RDSTAT1:
00F561  2  A9 FF                LDA     #$FF            ; GET DATA CHAR
00F563  2  60                   RTS
00F564  2               
00F564  1                       .INCLUDE "bios_ppp_console.asm"
00F564  2               ;__PARALLEL PORT PROP CONSOLE DRIVERS____________________________________________________________________________________________
00F564  2               ;
00F564  2               ; 	DOS CONSOLE DRIVERS FOR THE PARALLEL PORT PROP
00F564  2               ;
00F564  2               ;	Entry points:
00F564  2               ;		PPPCONIN   	- read a byte from CONSOLE ('A' POINTS TO BYTE)
00F564  2               ;		PPPCONINW  	- read a byte from CONSOLE ('A' POINTS TO BYTE, WAIT FOR BYTE)
00F564  2               ;		PPPOUTCH   	- write a byte from CONSOLE  ('A' POINTS TO BYTE)
00F564  2               ;		PPPCONSTATUS	-RETURN CONSOLE STATUS
00F564  2               ;________________________________________________________________________________________________________________________________
00F564  2               ;
00F564  2               
00F564  2               
00F564  2               
00F564  2               
00F564  2               
00F564  2               ;__PPPOUTCH______________________________________________________________________________________________________________________
00F564  2               ;
00F564  2               ;	WRITE CHARACTER(A) TO PPP
00F564  2               ;________________________________________________________________________________________________________________________________
00F564  2               ;
00F564  2               PPPOUTCH:
00F564  2  48                   PHA
00F565  2  A9 20                LDA     #$20
00F567  2  20 96 F4             JSR     SENDCMD
00F56A  2  68                   PLA
00F56B  2               
00F56B  2  20 AC F4             JSR     PUTBYTE
00F56E  2  60                   RTS
00F56F  2               
00F56F  2               ;__PPPCONIN______________________________________________________________________________________________________________________
00F56F  2               ;
00F56F  2               ;	READ CHARACTER FROM PPP
00F56F  2               ;________________________________________________________________________________________________________________________________
00F56F  2               ;
00F56F  2               PPPCONIN:
00F56F  2  A9 31                LDA     #$31
00F571  2  20 96 F4             JSR     SENDCMD
00F574  2  20 E7 F4             JSR     GETBYTE
00F577  2  60                   RTS                     ;
00F578  2               
00F578  2               ;__CONINW________________________________________________________________________________________________________________________
00F578  2               ;
00F578  2               ;	READ CHARACTER FROM PPP (WAIT FOR CHAR)
00F578  2               ;________________________________________________________________________________________________________________________________
00F578  2               ;
00F578  2               PPPCONINW:
00F578  2  A9 31                LDA     #$31
00F57A  2  20 96 F4             JSR     SENDCMD
00F57D  2  20 E7 F4             JSR     GETBYTE
00F580  2  C9 00                CMP     #$00
00F582  2  F0 F4                BEQ     PPPCONINW
00F584  2  29 7F                AND     #$7F
00F586  2  60                   RTS
00F587  2               
00F587  2               ;__IOF_CONSTATUS_________________________________________________________________________________________________________________
00F587  2               ;
00F587  2               ;	READ STATUS FROM PPP
00F587  2               ;________________________________________________________________________________________________________________________________
00F587  2               ;
00F587  2               PPPCONSTATUS:
00F587  2  A9 30                LDA     #$30
00F589  2  20 96 F4             JSR     SENDCMD
00F58C  2  20 E7 F4             JSR     GETBYTE
00F58F  2  60                   RTS
00F590  2               
00F590  1               
00F590  1               
00F590  1               ;__COLD_START___________________________________________________
00F590  1               ;
00F590  1               ; PERFORM SYSTEM COLD INIT
00F590  1               ;
00F590  1               ;_______________________________________________________________
00F590  1               COLD_START:
00F590  1  78                   SEI                     ; DISABLE INTERRUPTS
00F591  1  D8                   CLD                     ;  VERIFY DECIMAL MODE IS OFF
00F592  1  A2 FF                LDX     #$FF            ;
00F594  1  9A                   TXS                     ; CLEAR STACK
00F595  1  8A                   TXA
00F596  1               
00F596  1  A9 00                LDA     #$00            ; SET CONSOLE (00=PPP, 01= SERIAL)
00F598  1               ;;; TODO  ADD AUTODETECT/OPTION AT SOME POINT
00F598  1  85 3A                STA     CONSOLE
00F59A  1               
00F59A  1  A9 FF                LDA     #<IRQROUTINE
00F59C  1  85 35                STA     IRQVECTOR
00F59E  1  85 37                STA     NMIVECTOR
00F5A0  1  A9 F5                LDA     #>IRQROUTINE
00F5A2  1  85 36                STA     IRQVECTOR+1
00F5A4  1  85 38                STA     NMIVECTOR+1
00F5A6  1               
00F5A6  1               ;	INIT HARDWARE
00F5A6  1  20 42 F4             JSR     INIT_PPP        ;
00F5A9  1  20 22 F5             JSR     SERIALINIT      ;
00F5AC  1  20 5F FA             JSR     INITPAGES       ;
00F5AF  1               
00F5AF  1  20 7E FB             JSR     PAGE_ENTER
00F5B2  1  A9 F3                LDA     #<STARTUP       ; OUTPUT STARTUP STRING
00F5B4  1  85 4F                STA     STRPTR          ;
00F5B6  1  A9 CC                LDA     #>STARTUP       ;
00F5B8  1  85 50                STA     STRPTR+1        ;
00F5BA  1  20 62 F9             JSR     OUTSTR          ;
00F5BD  1  20 76 FB             JSR     PAGE_EXIT
00F5C0  1               
00F5C0  1  A9 00                LDA     #$00            ;
00F5C2  1  8D 00 04             STA     INBUFFER        ; MAKE SURE INPUT BUFFER IS EMPTY
00F5C5  1               ;
00F5C5  1  20 E6 FA             JSR     P_PPP_INITIALIZE
00F5C8  1  20 EF FA             JSR     P_IDE_INITIALIZE
00F5CB  1  20 13 FB             JSR     P_RTC_RESET
00F5CE  1               
00F5CE  1  20 E1 C9             JSR     DSKY_INIT
00F5D1  1  A2 00                LDX     #$00            ; SHOW A STARTUP MESSAGE ON DSKY
00F5D3  1               :
00F5D3  1  BD 26 FC             LDA     DSKYMSG,x
00F5D6  1  9D 00 05             STA     DSKY_BUF,x
00F5D9  1  E8                   INX
00F5DA  1  E0 08                CPX     #8
00F5DC  1  D0 F5                BNE     :-
00F5DE  1  20 AE CB             JSR     DSKY_SHOW
00F5E1  1               
00F5E1  1  00                   BRK                     ; PERFORM BRK (START MONITOR)
00F5E2  1               
00F5E2  1               
00F5E2  1               ;__BRKROUTINE___________________________________________________
00F5E2  1               ;
00F5E2  1               ; HANDLE CPU BRK INTERRUPT PROCESING AND START MONITOR
00F5E2  1               ;
00F5E2  1               ;_______________________________________________________________
00F5E2  1               BRKROUTINE:
00F5E2  1               ; MONITOR'S BREAK HANDLER
00F5E2  1  18                   CLC
00F5E3  1  68                   PLA                     ;
00F5E4  1  AA                   TAX                     ; LOW BYTE OF PC
00F5E5  1  68                   PLA                     ;
00F5E6  1  A8                   TAY                     ; HIGH BYTE OF PC
00F5E7  1  38                   SEC                     ;
00F5E8  1  8A                   TXA                     ;
00F5E9  1  E9 02                SBC     #$02            ; REMOVE BREAK INSTRUCTION
00F5EB  1  85 4A                STA     PC              ;
00F5ED  1  B0 01                BCS     BRK2            ;
00F5EF  1  88                   DEY
00F5F0  1               BRK2:
00F5F0  1  84 4B                STY     PC+1            ; SAVE PC
00F5F2  1  BA                   TSX                     ; GET STACK POINTER
00F5F3  1  86 4C                STX     SPTR            ; SAVE STACK POINTER
00F5F5  1  20 18 F6             JSR     PRINT_REG       ; DUMP REGISTER CONTENTS
00F5F8  1  A2 FF                LDX     #$FF            ;
00F5FA  1  9A                   TXS                     ; CLEAR STACK
00F5FB  1  58                   CLI                     ; ENABLE INTERRUPTS AGAIN
00F5FC  1  4C 78 F6             JMP     COMMAND_PROCESSOR; START THE MONITOR
00F5FF  1               
00F5FF  1               
00F5FF  1               ;__IRQROUTINE___________________________________________________
00F5FF  1               ;
00F5FF  1               ; HANDLE INTERRUPT PROCESING
00F5FF  1               ;
00F5FF  1               ;_______________________________________________________________
00F5FF  1               IRQROUTINE:
00F5FF  1  58                   CLI                     ; ENABLE INTERRUPTS AGAIN
00F600  1  40                   RTI
00F601  1               
00F601  1               ;__INTERRUPT____________________________________________________
00F601  1               ;
00F601  1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
00F601  1               ;
00F601  1               ;_______________________________________________________________
00F601  1               INTERRUPT:
00F601  1  78                   SEI                     ; DISABLE INTERRUPTS
00F602  1  84 48                STY     YREG            ; SAVE Y
00F604  1  86 47                STX     XREG            ; SAVE X
00F606  1  85 46                STA     ACC             ; SAVE A
00F608  1  68                   PLA                     ; GET STATUS REGISTER
00F609  1  85 49                STA     PREG            ; SAVE STATUS REGISTER
00F60B  1  29 10                AND     #$10            ; MASK BRK
00F60D  1  D0 03                BNE     BRKCMD          ; BRK CMD
00F60F  1  6C 35 00             JMP     (IRQVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
00F612  1               BRKCMD:
00F612  1  4C E2 F5             JMP     BRKROUTINE      ; MONITOR BRK ROUTINE
00F615  1               
00F615  1               NINTERRUPT:
00F615  1  6C 37 00             JMP     (NMIVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED NMI)
00F618  1               
00F618  1               
00F618  1               
00F618  1               ;__PRINT_REG____________________________________________________
00F618  1               ;
00F618  1               ; PRINT OUT REGISTERS ON THE DISPLAY
00F618  1               ;
00F618  1               ;_______________________________________________________________
00F618  1               PRINT_REG:
00F618  1  A9 06                LDA     #<REGDATA       ; OUTPUT HEADER STRING
00F61A  1  85 4F                STA     STRPTR          ;
00F61C  1  A9 FC                LDA     #>REGDATA       ;
00F61E  1  85 50                STA     STRPTR+1        ;
00F620  1  20 62 F9             JSR     OUTSTR          ;
00F623  1  A5 4B                LDA     PC+1            ; OUTPUT PROGRAM COUNTER HIGH BYTE
00F625  1  20 47 F9             JSR     PRINT_BYTE      ;
00F628  1  A5 4A                LDA     PC              ; OUTPUT PROGRAM COUNTER LOW BYTE
00F62A  1  20 47 F9             JSR     PRINT_BYTE      ;
00F62D  1  A9 20                LDA     #$20            ; OUTPUT SPACE
00F62F  1  20 42 FA             JSR     IOF_OUTCH       ;
00F632  1  A5 46                LDA     ACC             ; OUTPUT ACCUMULATOR
00F634  1  20 47 F9             JSR     PRINT_BYTE      ;
00F637  1  A9 20                LDA     #$20            ; OUTPUT 2 SPACES
00F639  1  20 42 FA             JSR     IOF_OUTCH       ;
00F63C  1  A9 20                LDA     #$20            ;
00F63E  1  20 42 FA             JSR     IOF_OUTCH       ;
00F641  1  A5 47                LDA     XREG            ; OUTPUT X REGISTER
00F643  1  20 47 F9             JSR     PRINT_BYTE      ;
00F646  1  A9 20                LDA     #$20            ; OUTPUT 2 SPACES
00F648  1  20 42 FA             JSR     IOF_OUTCH       ;
00F64B  1  A9 20                LDA     #$20            ;
00F64D  1  20 42 FA             JSR     IOF_OUTCH       ;
00F650  1  A5 48                LDA     YREG            ; OUTPUT Y REGISTER
00F652  1  20 47 F9             JSR     PRINT_BYTE      ;
00F655  1  A9 20                LDA     #$20            ; OUTPUT 2 SPACES
00F657  1  20 42 FA             JSR     IOF_OUTCH       ;
00F65A  1  A9 20                LDA     #$20            ;
00F65C  1  20 42 FA             JSR     IOF_OUTCH       ;
00F65F  1  A5 4C                LDA     SPTR            ; OUTPUT STACK POINTER
00F661  1  20 47 F9             JSR     PRINT_BYTE      ;
00F664  1  A9 20                LDA     #$20            ; OUTPUT 2 SPACES
00F666  1  20 42 FA             JSR     IOF_OUTCH       ;
00F669  1  A9 20                LDA     #$20            ;
00F66B  1  20 42 FA             JSR     IOF_OUTCH       ;
00F66E  1  A5 49                LDA     PREG            ; OUTPUT STATUS REGISTER
00F670  1  20 47 F9             JSR     PRINT_BYTE      ; OUTPUT IN HEX
00F673  1  A9 0D                LDA     #$0D            ; PRINT NEW LINE
00F675  1  4C 42 FA             JMP     IOF_OUTCH       ;
00F678  1               
00F678  1               
00F678  1               
00F678  1               
00F678  1               ;__COMMAND_PROCESSOR____________________________________________
00F678  1               ;
00F678  1               ; PROMPT FOR, INPUT, AND PROCESS INCOMMING USER COMMANDS
00F678  1               ;
00F678  1               ;_______________________________________________________________
00F678  1               COMMAND_PROCESSOR:
00F678  1               
00F678  1  20 A6 F8             JSR     DISPLAY_PROMPT  ; PRINT PROMPT STRING
00F67B  1               
00F67B  1  A9 00                LDA     #<INBUFFER      ; SETUP INPUT COMMAND BUFFER
00F67D  1  85 4F                STA     STRPTR          ;
00F67F  1  A9 04                LDA     #>INBUFFER      ;
00F681  1  85 50                STA     STRPTR +1       ;
00F683  1               
00F683  1  20 77 F9             JSR     INSTR           ; GET A STRING FROM THE CONSOLE
00F686  1               
00F686  1  A9 0D                LDA     #$0D            ;
00F688  1  20 42 FA             JSR     IOF_OUTCH       ;
00F68B  1  A9 0A                LDA     #$0A            ;
00F68D  1  20 42 FA             JSR     IOF_OUTCH       ;
00F690  1               
00F690  1  A0 00                LDY     #$00            ; SET INDEX = 0
00F692  1               
00F692  1  A9 8C                LDA     #<COMMAND_LOOKUP_TABLE; SETUP INPUT COMMAND POINTER
00F694  1  85 3B                STA     WORKPTR         ;
00F696  1  A9 FB                LDA     #>COMMAND_LOOKUP_TABLE;
00F698  1  85 3C                STA     WORKPTR +1      ;
00F69A  1  B9 00 04             LDA     INBUFFER,Y      ; MOVE FIRST BYTE OF COMMAND BUFFER TO ACC
00F69D  1  C9 00                CMP     #$00            ; IS NULL?
00F69F  1  F0 D7                BEQ     COMMAND_PROCESSOR; YES, GET NEXT COMMAND
00F6A1  1               
00F6A1  1               COMMAND_PROCESSOR_CMP:
00F6A1  1  A2 00                LDX     #$00            ; X=0
00F6A3  1  B9 00 04             LDA     INBUFFER,Y      ; ACC= NEXT BYTE OF INPUT BUFFER
00F6A6  1  C1 3B                CMP     (WORKPTR,X)     ; DOES NEXT BYTE OF INPUT BUFFER MATCH NEXT BYTE OF LOOKUP TABLE
00F6A8  1  D0 1A                BNE     CMD_PROCESOR_NEXT_CMD; NO, GO TO NEXT COMMAND IN LOOKUP TABLE
00F6AA  1  C8                   INY                     ; YES, Y=Y+1
00F6AB  1  B9 00 04             LDA     INBUFFER,Y      ; LOAD NEXT BYTE OF INPUT BUFFER
00F6AE  1  C9 20                CMP     #$20            ; IS IT A SPACE (SINGALING END OF COMMAND)
00F6B0  1  F0 2F                BEQ     CMD_PROCESSOR_MATCH_FOUND; YES, POSSIBLE MATCH FOUND
00F6B2  1  C9 00                CMP     #$00            ; IS IT A NULL (SINGALING END OF COMMAND)
00F6B4  1  F0 2B                BEQ     CMD_PROCESSOR_MATCH_FOUND; YES, POSSIBLE MATCH FOUND
00F6B6  1  20 B1 F8             JSR     INCWORKPTR      ; NO, INCREMENT POINTER TO LOOKUP TABLE
00F6B9  1  A2 00                LDX     #$00            ;
00F6BB  1  A1 3B                LDA     (WORKPTR,X)     ; A= NEXT BYTE OF LOOKUP TABLE
00F6BD  1  C9 00                CMP     #$00            ; IS IT A NULL? (SIGNALING END OF TABLE ENTRY)
00F6BF  1  F0 0E                BEQ     CMD_PROCESOR_NEXT_CMD1; YES, ADVANCE TO NEXT COMMAND IN TABLE
00F6C1  1  4C A1 F6             JMP     COMMAND_PROCESSOR_CMP; LOOP TO CHECK NEXT CHAR
00F6C4  1               
00F6C4  1               CMD_PROCESOR_NEXT_CMD:
00F6C4  1  20 B1 F8             JSR     INCWORKPTR      ; INCREMENT POINTER TO LOOKUP TABLE
00F6C7  1  A2 00                LDX     #$00            ;
00F6C9  1  A1 3B                LDA     (WORKPTR,X)     ; A = NEXT BYTE OF LOOKUP TABLE
00F6CB  1  C9 00                CMP     #$00            ; IS IT A NULL?
00F6CD  1  D0 F5                BNE     CMD_PROCESOR_NEXT_CMD; NO, LOOP
00F6CF  1               
00F6CF  1               CMD_PROCESOR_NEXT_CMD1:
00F6CF  1  A9 03                LDA     #3
00F6D1  1  20 B8 F8             JSR     INCWORKPTRX     ; INCREMENT POINTER TO LOOKUP TABLE
00F6D4  1  A2 00                LDX     #$00            ;
00F6D6  1  A1 3B                LDA     (WORKPTR,X)     ; A = NEXT BYTE OF LOOKUP TABLE
00F6D8  1  C9 01                CMP     #$01            ; IS IT $01 (SINGALING END OF LOOKUP TABLE)
00F6DA  1  F0 28                BEQ     CMD_PROCESOR_NOT_FOUND; YES, DISPLAY NOT FOUND MESSAGE
00F6DC  1  A0 00                LDY     #$00            ; NO RESET INPUT BUFFER COUNTER
00F6DE  1  4C A1 F6             JMP     COMMAND_PROCESSOR_CMP; LOOP
00F6E1  1               
00F6E1  1               CMD_PROCESSOR_MATCH_FOUND:
00F6E1  1  20 B1 F8             JSR     INCWORKPTR      ; INCREMENT POINTER TO LOOKUP TABLE
00F6E4  1  A2 00                LDX     #$00            ;
00F6E6  1  A1 3B                LDA     (WORKPTR,X)     ; A = NEXT BYTE OF LOOKUP TABLE
00F6E8  1  C9 00                CMP     #$00            ; IS IT A NULL?
00F6EA  1  D0 D8                BNE     CMD_PROCESOR_NEXT_CMD; NO, TRY NEXT COMMAND
00F6EC  1  20 B1 F8             JSR     INCWORKPTR      ; YES, INCREMENT POINTER TO LOOKUP TABLE
00F6EF  1  A2 00                LDX     #$00            ;
00F6F1  1  A1 3B                LDA     (WORKPTR,X)     ; A = NEXT BYTE OF LOOKUP TABLE
00F6F3  1  85 3D                STA     JUMPPTR         ; STORE A INTO LOW BYTE OF JUMP VECTOR
00F6F5  1  20 B1 F8             JSR     INCWORKPTR      ; INCREMENT POINTER TO LOOKUP TABLE
00F6F8  1  A2 00                LDX     #$00            ;
00F6FA  1  A1 3B                LDA     (WORKPTR,X)     ; A = NEXT BYTE OF LOOKUP TABLE
00F6FC  1  85 3E                STA     JUMPPTR+1       ; INCREMENT POINTER TO LOOKUP TABLE
00F6FE  1  20 12 F7             JSR     CMD_PROCESOR_RUN; RUN COMMAND
00F701  1  4C 78 F6             JMP     COMMAND_PROCESSOR; GET NEXT COMMAND
00F704  1               
00F704  1               CMD_PROCESOR_NOT_FOUND:
00F704  1  A9 E1                LDA     #<ERROR         ; LOAD LOW BYTE OF ERROR STRING
00F706  1  85 4F                STA     STRPTR          ; STORE IN POINTER LOW BYTE
00F708  1  A9 FB                LDA     #>ERROR         ; LOAD HOGH BYTE OF ERROR STRING
00F70A  1  85 50                STA     STRPTR +1       ; STORE IN POINTER HIGH BYTE
00F70C  1               
00F70C  1  20 62 F9             JSR     OUTSTR          ; OUTPUT THE STRING
00F70F  1  4C 78 F6             JMP     COMMAND_PROCESSOR;
00F712  1               CMD_PROCESOR_RUN:
00F712  1  6C 3D 00             JMP     (JUMPPTR)       ; JUMP TO COMMAND VECTOR
00F715  1               
00F715  1               EXIT_MONITOR:
00F715  1  6C FC FF             JMP     ($FFFC)         ;
00F718  1               
00F718  1               
00F718  1               ;__BOOT_________________________________________________________
00F718  1               ;
00F718  1               ; BOOT OS
00F718  1               ;
00F718  1               ; BOOT X
00F718  1               ;_______________________________________________________________
00F718  1               IOF_BOOT:
00F718  1               ;
00F718  1  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F71A  1  85 3B                STA     WORKPTR         ;
00F71C  1  A9 04                LDA     #>INBUFFER      ;
00F71E  1  85 3C                STA     WORKPTR +1      ;
00F720  1               
00F720  1  A9 04                LDA     #4
00F722  1  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "BOOT"
00F725  1               
00F725  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00F728  1  20 25 F9             JSR     HEXIN           ;
00F72B  1  B0 52                BCS     BOOT_ERROR
00F72D  1               
00F72D  1  C9 01                CMP     #$01            ;
00F72F  1  F0 32                BEQ     BOOTFDD
00F731  1               ;
00F731  1  C9 04                CMP     #$04            ;
00F733  1  F0 17                BEQ     BOOTHDD
00F735  1               
00F735  1  20 B0 FA             JSR     P_PPP_SOFT_RESET;
00F738  1  A9 00                LDA     #$00
00F73A  1  8D 28 05             STA     DSKUNIT
00F73D  1  8D 10 05             STA     debcyll         ;
00F740  1  8D 11 05             STA     debcylm         ;
00F743  1  8D 12 05             STA     debsehd         ;
00F746  1  20 B9 FA             JSR     P_PPP_READ_SECTOR;
00F749  1  4C 00 02             JMP     hstbuf          ;
00F74C  1               ;
00F74C  1               BOOTHDD:
00F74C  1               ;
00F74C  1  20 E6 FA             JSR     P_PPP_INITIALIZE;
00F74F  1  A9 00                LDA     #$00
00F751  1  8D 28 05             STA     DSKUNIT
00F754  1  8D 10 05             STA     debcyll         ;
00F757  1  8D 11 05             STA     debcylm         ;
00F75A  1  8D 12 05             STA     debsehd         ;
00F75D  1  20 D4 FA             JSR     P_IDE_READ_SECTOR;
00F760  1  4C 00 02             JMP     hstbuf          ;
00F763  1               BOOTFDD:
00F763  1               ;
00F763  1  A9 01                LDA     #$01            ;
00F765  1  8D 16 05             STA     sekdsk          ;
00F768  1  20 95 FA             JSR     P_SETUPDRIVE    ;
00F76B  1  A9 00                LDA     #$00
00F76D  1  8D 28 05             STA     DSKUNIT
00F770  1  8D 10 05             STA     debcyll         ;
00F773  1  8D 11 05             STA     debcylm         ;
00F776  1  8D 12 05             STA     debsehd         ;
00F779  1  20 9E FA             JSR     P_READFL        ;
00F77C  1  4C 00 02             JMP     hstbuf          ;
00F77F  1               
00F77F  1               BOOT_ERROR:
00F77F  1  4C D9 F8             JMP     INVALID_NUMBER_ERROR
00F782  1               ;__GO______________________________________________________
00F782  1               ;
00F782  1               ; GO COMMAND
00F782  1               ;
00F782  1               ; GO XXXX
00F782  1               ;_______________________________________________________________
00F782  1               GO:
00F782  1               
00F782  1  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F784  1  85 3B                STA     WORKPTR         ;
00F786  1  A9 04                LDA     #>INBUFFER      ;
00F788  1  85 3C                STA     WORKPTR +1      ;
00F78A  1               
00F78A  1  A9 02                LDA     #2
00F78C  1  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "GO"
00F78F  1               
00F78F  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00F792  1  20 E4 F8             JSR     GETNUMBER       ; GET THE STARTING ADDRESS
00F795  1  B0 4C                BCS     DUMP_ERROR      ; IF NOT A NUMBER, REPORT ERROR
00F797  1               
00F797  1  6C 3F 00             JMP     (TEMPWORD)      ;
00F79A  1               
00F79A  1               
00F79A  1               
00F79A  1               
00F79A  1               ;__DUMPMEM______________________________________________________
00F79A  1               ;
00F79A  1               ; DUMP MEMORY COMMAND
00F79A  1               ;
00F79A  1               ; DUMP XXXX (XXXX)
00F79A  1               ;_______________________________________________________________
00F79A  1               DUMP:
00F79A  1               
00F79A  1  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F79C  1  85 3B                STA     WORKPTR         ;
00F79E  1  A9 04                LDA     #>INBUFFER      ;
00F7A0  1  85 3C                STA     WORKPTR +1      ;
00F7A2  1               
00F7A2  1  A9 04                LDA     #4
00F7A4  1  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "DUMP"
00F7A7  1               
00F7A7  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER THE WHITESPACE
00F7AA  1  20 E4 F8             JSR     GETNUMBER       ; GET THE STARTING ADDRESS
00F7AD  1  B0 34                BCS     DUMP_ERROR      ; IF NOT A NUMBER, REPORT ERROR
00F7AF  1               
00F7AF  1  A5 3F                LDA     TEMPWORD        ; STORE STARTING ADDRESS IN WORD POINTER (TEMPWORD1)
00F7B1  1  85 41                STA     TEMPWORD1       ;
00F7B3  1  A5 40                LDA     TEMPWORD+1      ;
00F7B5  1  85 42                STA     TEMPWORD1+1     ;
00F7B7  1               
00F7B7  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER ANY WHITESPACE
00F7BA  1  20 E4 F8             JSR     GETNUMBER       ; GET THE ENDING ADDRESS
00F7BD  1  B0 24                BCS     DUMP_ERROR      ; IF NOT A NUMBER, REPORT ERROR
00F7BF  1               
00F7BF  1  A5 41                LDA     TEMPWORD1       ; STORE ENDING ADDRESS IN WORD POINTER (WORKPTR)
00F7C1  1  85 3B                STA     WORKPTR         ;
00F7C3  1  A5 42                LDA     TEMPWORD1+1     ;
00F7C5  1  85 3C                STA     WORKPTR+1       ;
00F7C7  1               DUMP_LOOP:
00F7C7  1  20 65 F8             JSR     PRINT_MEM_LINE  ;
00F7CA  1  A9 0D                LDA     #$0D            ;
00F7CC  1  20 42 FA             JSR     IOF_OUTCH       ;
00F7CF  1  A9 0A                LDA     #$0A            ;
00F7D1  1  20 42 FA             JSR     IOF_OUTCH       ;
00F7D4  1  A5 3C                LDA     WORKPTR+1       ; COMPARE HIGH BYTES
00F7D6  1  C5 40                CMP     TEMPWORD+1
00F7D8  1  90 ED                BCC     DUMP_LOOP       ; IF NUM1H < NUM2H THEN NUM1 < NUM2
00F7DA  1  D0 06                BNE     DUMP_DONE       ; IF NUM1H <> NUM2H THEN NUM1 > NUM2 (SO NUM1 >= NUM2)
00F7DC  1  A5 3B                LDA     WORKPTR         ; COMPARE LOW BYTES
00F7DE  1  C5 3F                CMP     TEMPWORD
00F7E0  1  90 E5                BCC     DUMP_LOOP       ; IF NUM1L < NUM2L THEN NUM1 < NUM2
00F7E2  1               DUMP_DONE:
00F7E2  1  60                   RTS
00F7E3  1               DUMP_ERROR:
00F7E3  1  4C D9 F8             JMP     INVALID_NUMBER_ERROR
00F7E6  1               
00F7E6  1               
00F7E6  1               
00F7E6  1               ;__ENTERMEM_____________________________________________________
00F7E6  1               ;
00F7E6  1               ; ENTER MEMORY COMMAND
00F7E6  1               ;
00F7E6  1               ; ENTER XXXX (XX XX XX XX XX XX XX XX XX XX XX XX XX XX )
00F7E6  1               ;_______________________________________________________________
00F7E6  1               ENTERMEM:
00F7E6  1               
00F7E6  1  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F7E8  1  85 3B                STA     WORKPTR         ;
00F7EA  1  A9 04                LDA     #>INBUFFER      ;
00F7EC  1  85 3C                STA     WORKPTR +1      ;
00F7EE  1               
00F7EE  1  A9 05                LDA     #5
00F7F0  1  20 B8 F8             JSR     INCWORKPTRX     ; JUMP OVER "ENTER"
00F7F3  1               
00F7F3  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER ANY WHITESPACE
00F7F6  1  20 E4 F8             JSR     GETNUMBER       ; GET NUMBER
00F7F9  1  B0 67                BCS     ENTER_ERROR     ; IF NOT A NUMBER REPORT ERROR
00F7FB  1               
00F7FB  1  A5 3F                LDA     TEMPWORD        ; STORE ADDRESS INTO WORD POINTER (TEMPWORD1)
00F7FD  1  85 41                STA     TEMPWORD1       ;
00F7FF  1  A5 40                LDA     TEMPWORD+1      ;
00F801  1  85 42                STA     TEMPWORD1+1     ;
00F803  1  A0 00                LDY     #$00            ; RESET COUNTER TO 0
00F805  1               ENTERLOOP:
00F805  1  A2 00                LDX     #$00            ;
00F807  1  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT BYTE FROM BUFFER
00F809  1  C9 00                CMP     #$00            ; IS NULL?
00F80B  1  F0 10                BEQ     ENTER_DONE      ; YES, WE'RE DONE
00F80D  1  20 38 F9             JSR     EATWHITESPACE   ; SKIP OVER ANY WHITESPACE
00F810  1  20 E4 F8             JSR     GETNUMBER       ; GET NEXT NUMBER
00F813  1  B0 4D                BCS     ENTER_ERROR     ; IF NOT A NUMBER REPORT ERROR
00F815  1  A5 3F                LDA     TEMPWORD        ; STORE BYTE IN ADDRESS (INDEXED BY Y)
00F817  1  91 41                STA     (TEMPWORD1),Y   ;
00F819  1  C8                   INY                     ; GO TO NEXT BYTE
00F81A  1  4C 05 F8             JMP     ENTERLOOP       ; LOOP
00F81D  1               ENTER_DONE:
00F81D  1  C0 00                CPY     #$00            ; WAS LINE BLANK?
00F81F  1  D0 01                BNE     ENTER_CONTINUE  ; NO, PREPARE FOR NEXT LINE
00F821  1  60                   RTS                     ; YES, END DATA ENTRY
00F822  1               ENTER_CONTINUE:
00F822  1  A9 0D                LDA     #$0D            ;
00F824  1  20 42 FA             JSR     IOF_OUTCH       ;
00F827  1  A9 0A                LDA     #$0A            ;
00F829  1  20 42 FA             JSR     IOF_OUTCH
00F82C  1  A9 3A                LDA     #$3A            ; OUTPUT ":" TO SCREEN
00F82E  1  20 42 FA             JSR     IOF_OUTCH       ;
00F831  1  18                   CLC                     ; CLEAR CARRY
00F832  1  98                   TYA                     ; A=Y (LAST COUNTER)
00F833  1  65 41                ADC     TEMPWORD1       ; ADD LAST COUNT TO BEGINNING POINTER
00F835  1  85 41                STA     TEMPWORD1       ; STORE RESULT IN BEGINNING POINTER
00F837  1  D0 02                BNE     ENTER_INCREMENT ; NOT ZERO?, DONE
00F839  1  E6 42                INC     TEMPWORD1+1     ; ZERO, INC HIGH BYTE
00F83B  1               ENTER_INCREMENT:
00F83B  1  A5 42                LDA     TEMPWORD1+1     ; PRINTOUT STARTING ADDRESS TO SCREEN
00F83D  1  20 47 F9             JSR     PRINT_BYTE      ; (HIGH)
00F840  1  A5 41                LDA     TEMPWORD1       ;
00F842  1  20 47 F9             JSR     PRINT_BYTE      ; (LOW)
00F845  1  A9 20                LDA     #$20            ; OUTPUT SPACE TO SCREEN
00F847  1  20 42 FA             JSR     IOF_OUTCH       ;
00F84A  1  A9 00                LDA     #<INBUFFER      ; SETUP INPUT COMMAND BUFFER
00F84C  1  85 4F                STA     STRPTR          ;
00F84E  1  A9 04                LDA     #>INBUFFER      ;
00F850  1  85 50                STA     STRPTR +1       ;
00F852  1  20 77 F9             JSR     INSTR           ; GET A STRING FROM THE CONSOLE
00F855  1  A9 00                LDA     #<INBUFFER      ; SETUP WORK BUFFER
00F857  1  85 3B                STA     WORKPTR         ;
00F859  1  A9 04                LDA     #>INBUFFER      ;
00F85B  1  85 3C                STA     WORKPTR +1      ;
00F85D  1  A0 00                LDY     #$00            ;
00F85F  1  4C 05 F8             JMP     ENTERLOOP       ; LOOP
00F862  1               
00F862  1               
00F862  1               ENTER_ERROR:
00F862  1  4C D9 F8             JMP     INVALID_NUMBER_ERROR
00F865  1               
00F865  1               ;__PRINT_MEM_LINE_______________________________________________
00F865  1               ;
00F865  1               ; PRINT MEMORY DUMP LINE
00F865  1               ;
00F865  1               ; PRINT 16 HEX LOCATIONS STARTING WITH ADDRESS WORKPTR
00F865  1               ;_______________________________________________________________
00F865  1               PRINT_MEM_LINE:
00F865  1  A9 3A                LDA     #$3A            ; LOAD ':' INTO ACC
00F867  1  20 42 FA             JSR     IOF_OUTCH       ; PRINT ':'
00F86A  1  A5 3C                LDA     WORKPTR+1       ; PRINT ADDRESS
00F86C  1  20 47 F9             JSR     PRINT_BYTE      ;
00F86F  1  A5 3B                LDA     WORKPTR         ;
00F871  1  20 47 F9             JSR     PRINT_BYTE      ;
00F874  1  A9 2D                LDA     #$2D            ; LOAD '-'
00F876  1  20 42 FA             JSR     IOF_OUTCH       ; PRINT '-'
00F879  1  A0 00                LDY     #$00            ;
00F87B  1               PRINT_MEM_LINE_LOOP:
00F87B  1  B1 3B                LDA     (WORKPTR),Y     ; LOAD NEXT BYTE
00F87D  1  20 47 F9             JSR     PRINT_BYTE      ; PRINT BYTE
00F880  1  A9 20                LDA     #$20            ; LOAD ' '
00F882  1  20 42 FA             JSR     IOF_OUTCH       ; PRINT ' '
00F885  1  C8                   INY                     ; INCREMENT COUNTER
00F886  1  C0 10                CPY     #$10            ; HAVE WE PRINTED 16 ADDRESSES
00F888  1  D0 F1                BNE     PRINT_MEM_LINE_LOOP; NO, LOOP
00F88A  1  A9 3A                LDA     #$3A            ; LOAD ':' INTO ACC
00F88C  1  20 42 FA             JSR     IOF_OUTCH       ; PRINT ':'
00F88F  1  A2 00                LDX     #$00            ;
00F891  1  A0 00                LDY     #$00            ;
00F893  1               PRINT_MEM_LINE_LOOP_ASCII:
00F893  1  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT BYTE
00F895  1  20 C9 F8             JSR     OUTASCII        ; PRINT ASCII VALUE OF BYTE
00F898  1  C8                   INY                     ; INCREMENT COUNTER
00F899  1  20 B1 F8             JSR     INCWORKPTR      ; INCREMENT BUFFER POINTER
00F89C  1  C0 10                CPY     #$10            ; HAVE WE PRINTED 16 ADDRESSES
00F89E  1  D0 F3                BNE     PRINT_MEM_LINE_LOOP_ASCII; NO, LOOP
00F8A0  1  A9 0D                LDA     #$0D            ; YES, PRINT CR
00F8A2  1  20 42 FA             JSR     IOF_OUTCH       ;
00F8A5  1  60                   RTS                     ; RETURN
00F8A6  1               
00F8A6  1               
00F8A6  1               
00F8A6  1               ;__DISPLAY_PROMPT______________________________________________
00F8A6  1               ;
00F8A6  1               ; DISPLAY THE INPUT PROMPT ON THE SCREEN
00F8A6  1               ;
00F8A6  1               ;______________________________________________________________
00F8A6  1               DISPLAY_PROMPT:
00F8A6  1  A9 DD                LDA     #<PROMPT        ; LOAD LOW BYTE OF PROMPT STRING
00F8A8  1  85 4F                STA     STRPTR          ; STORE IN POINTER LOW BYTE
00F8AA  1  A9 FB                LDA     #>PROMPT        ; LOAD HOGH BYTE OF PROMPR STRING
00F8AC  1  85 50                STA     STRPTR +1       ; STORE IN POINTER HIGH BYTE
00F8AE  1               
00F8AE  1  4C 62 F9             JMP     OUTSTR          ; OUTPUT THE STRING
00F8B1  1               
00F8B1  1               
00F8B1  1               ;__INCWORKPTR___________________________________________________
00F8B1  1               ; INCREMENT THE 16BIT WORK POINTER
00F8B1  1               ;
00F8B1  1               ;_______________________________________________________________
00F8B1  1               INCWORKPTR:
00F8B1  1  E6 3B                INC     WORKPTR         ; INCREMENT LOWBYTE
00F8B3  1  D0 02                BNE     :+              ; NOT ZERO?, DONE
00F8B5  1  E6 3C                INC     WORKPTR+1       ; ZERO, INC HIGH BYTE
00F8B7  1               :
00F8B7  1  60                   RTS                     ; RETURN
00F8B8  1               
00F8B8  1               ;__INCWORKPTRX__________________________________________________
00F8B8  1               ; INCREMENT THE 16BIT WORK POINTER X TIMES
00F8B8  1               ;   A= NUMBER OF TIMES TO INCREMENT
00F8B8  1               ;_______________________________________________________________
00F8B8  1               INCWORKPTRX:
00F8B8  1  18                   CLC
00F8B9  1  65 3B                ADC     WORKPTR         ; INCREMENT LOWBYTE
00F8BB  1  90 02                BCC     :+              ; NO CARRY?
00F8BD  1  E6 3C                INC     WORKPTR+1       ; CARRY, INC HIGH BYTE
00F8BF  1               :
00F8BF  1  85 3B                STA     WORKPTR         ; STORE
00F8C1  1  60                   RTS                     ; RETURN
00F8C2  1               
00F8C2  1               
00F8C2  1               
00F8C2  1               ;__INCTEMPWORD2__________________________________________________
00F8C2  1               ;
00F8C2  1               ; INCREMENT THE 16BIT WORK POINTER
00F8C2  1               ;
00F8C2  1               ;
00F8C2  1               ;_______________________________________________________________
00F8C2  1               INCTEMPWORD2:
00F8C2  1  E6 43                INC     TEMPWORD2       ; INCREMENT LOWBYTE
00F8C4  1  D0 02                BNE     :+              ; NOT ZERO?, DONE
00F8C6  1  E6 44                INC     TEMPWORD2+1     ; ZERO, INC HIGH BYTE
00F8C8  1               :
00F8C8  1  60                   RTS                     ; RETURN
00F8C9  1               
00F8C9  1               
00F8C9  1               
00F8C9  1               ;__OUTASCII_____________________________________________________
00F8C9  1               ;
00F8C9  1               ; PRINT CHAR IF VALID, ELSE PRINT '.'
00F8C9  1               ;
00F8C9  1               ;_______________________________________________________________
00F8C9  1               OUTASCII:
00F8C9  1  C9 20                CMP     #$20            ; IS < 20
00F8CB  1  90 07                BCC     :+              ; YES, SKIP
00F8CD  1  C9 80                CMP     #$80
00F8CF  1  B0 03                BCS     :+
00F8D1  1  4C 42 FA             JMP     IOF_OUTCH       ; NO, PRINT CHAR AND RETURN
00F8D4  1               :
00F8D4  1  A9 2E                LDA     #$2E            ; A= '.'
00F8D6  1  4C 42 FA             JMP     IOF_OUTCH       ; PRINT '.' AND RETURN
00F8D9  1               
00F8D9  1               
00F8D9  1               
00F8D9  1               ;__INVALID_NUMBER_ERROR__________________________________________
00F8D9  1               ;
00F8D9  1               ; PRINT "INVALID HEX NUMBER MESSAGE"
00F8D9  1               ;
00F8D9  1               ;_______________________________________________________________
00F8D9  1               INVALID_NUMBER_ERROR:
00F8D9  1  A9 F2                LDA     #<INERROR       ; LOAD LOW BYTE OF ERROR STRING
00F8DB  1  85 4F                STA     STRPTR          ; STORE IN POINTER LOW BYTE
00F8DD  1  A9 FB                LDA     #>INERROR       ; LOAD HOGH BYTE OF ERROR STRING
00F8DF  1  85 50                STA     STRPTR +1       ; STORE IN POINTER HIGH BYTE
00F8E1  1  4C 62 F9             JMP     OUTSTR          ; OUTPUT THE STRING
00F8E4  1               
00F8E4  1               
00F8E4  1               ;__GETNUMBER______________________________________________________
00F8E4  1               ;
00F8E4  1               ; GET ASCII NUMBER FROM BUFFER AND PARSE INTO TEMPWORD
00F8E4  1               ;
00F8E4  1               ;_______________________________________________________________
00F8E4  1               GETNUMBER:
00F8E4  1  A9 00                LDA     #$00            ;
00F8E6  1  85 3F                STA     TEMPWORD        ; CLEAR OUT TEMPWORD (OUTPUT OF GETNUMBER)
00F8E8  1  85 40                STA     TEMPWORD+1      ;
00F8EA  1  A2 00                LDX     #$00            ;
00F8EC  1               GETNUMBER_LOOP:
00F8EC  1  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT BYTE FROM BUFFER
00F8EE  1  C9 20                CMP     #$20            ; IS SPACE?
00F8F0  1  F0 31                BEQ     GETNUMBER_DONE  ; YES, WE'RE DONE
00F8F2  1  C9 00                CMP     #$00            ; IS NULL?
00F8F4  1  F0 2D                BEQ     GETNUMBER_DONE  ; YES, WE'RE DONE
00F8F6  1  C9 2C                CMP     #$2C            ; IS ","?
00F8F8  1  F0 29                BEQ     GETNUMBER_DONE  ; YES, WE'RE DONE
00F8FA  1  C9 29                CMP     #$29            ; IS ")"?
00F8FC  1  F0 25                BEQ     GETNUMBER_DONE  ; YES, WE'RE DONE
00F8FE  1  20 25 F9             JSR     HEXIN           ; GET HEX DIGIT
00F901  1  B0 1E                BCS     GETNUMBER_ERROR ; IS INVALID DIGIT?, YES PRINT ERROR AND ABORT
00F903  1  18                   CLC                     ; CLEAR CARRY
00F904  1  26 3F                ROL     TEMPWORD        ; MOVE WORD OVER 4 BITS TO LEFT
00F906  1  26 40                ROL     TEMPWORD+1      ;
00F908  1  18                   CLC                     ;
00F909  1  26 3F                ROL     TEMPWORD        ;
00F90B  1  26 40                ROL     TEMPWORD+1      ;
00F90D  1  18                   CLC                     ;
00F90E  1  26 3F                ROL     TEMPWORD        ;
00F910  1  26 40                ROL     TEMPWORD+1      ;
00F912  1  18                   CLC                     ;
00F913  1  26 3F                ROL     TEMPWORD        ;
00F915  1  26 40                ROL     TEMPWORD+1      ;
00F917  1  05 3F                ORA     TEMPWORD        ; ADD IN NEW DIGIT
00F919  1  85 3F                STA     TEMPWORD        ; STORE BACK TO TEMPWORD
00F91B  1  20 B1 F8             JSR     INCWORKPTR      ; INCREMENT BUFFER POINTER
00F91E  1  4C EC F8             JMP     GETNUMBER_LOOP  ; LOOP
00F921  1               GETNUMBER_ERROR:
00F921  1  38                   SEC                     ; SET ERROR FLAG (CARRY)
00F922  1  60                   RTS                     ; RETURN
00F923  1               GETNUMBER_DONE:
00F923  1  18                   CLC                     ; CLEAR ERROR FLAG (CARRY)
00F924  1  60                   RTS                     ; RETURN
00F925  1               
00F925  1               ;__HEXIN________________________________________________________
00F925  1               ;
00F925  1               ; GET NEXT CHAR FROM INPUT BUFFER AND CHANGE TO HEX DIGIT
00F925  1               ;
00F925  1               ; IF INVALID, SET CARRY FLAG
00F925  1               ;_______________________________________________________________
00F925  1               HEXIN:
00F925  1  A2 00                LDX     #$00            ;
00F927  1  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT CHAR FROM BUFFER
00F929  1  C9 3A                CMP     #$3A            ; LESS THAN 9?
00F92B  1  B0 02                BCS     HEXIN_BIG       ; NO, SKIP NEXT
00F92D  1  E9 2F                SBC     #$2F            ; CONVERT 0-9
00F92F  1               HEXIN_BIG:
00F92F  1  C9 41                CMP     #$41            ; A OR MORE?
00F931  1  90 02                BCC     HEXIN_SMALL     ; NO, SKIP NEXT
00F933  1  E9 37                SBC     #$37            ; CONVERT A-F
00F935  1               HEXIN_SMALL:
00F935  1  C9 10                CMP     #$10            ; RESULT TOO BIG?
00F937  1  60                   RTS
00F938  1               
00F938  1               
00F938  1               ;__EATWHITESPACE___________________________________________________
00F938  1               ;
00F938  1               ; FORWARD THE BUFFER POINTER PAST ANY WHITE SPACE IN THE INPUT BUFFER
00F938  1               ;
00F938  1               ;_______________________________________________________________
00F938  1               EATWHITESPACE:
00F938  1  A2 00                LDX     #$00            ;
00F93A  1  A1 3B                LDA     (WORKPTR,X)     ; GET NEXT CHAR FROM BUFFER
00F93C  1  C9 20                CMP     #$20            ; IS SPACE
00F93E  1  D0 06                BNE     EATWHITESPACE_OUT; NO, DONE
00F940  1  20 B1 F8             JSR     INCWORKPTR      ; YES, INCREMENT BUFFER POINTER
00F943  1  4C 38 F9             JMP     EATWHITESPACE   ; LOOP
00F946  1               EATWHITESPACE_OUT:
00F946  1  60                   RTS                     ; RETURN
00F947  1               
00F947  1               
00F947  1               ;__PRINT_BYTE__________________________________________________
00F947  1               ;
00F947  1               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
00F947  1               ;
00F947  1               ;______________________________________________________________
00F947  1               PRINT_BYTE:
00F947  1  AA                   TAX                     ; SAVE A REGISTER
00F948  1  4A                   LSR     A               ; SHIFT HIGH NIBBLE TO LOW NIBBLE
00F949  1  4A                   LSR     A               ;
00F94A  1  4A                   LSR     A               ;
00F94B  1  4A                   LSR     A               ;
00F94C  1  18                   CLC                     ; CLEAR CARRY
00F94D  1  20 54 F9             JSR     PRINT_DIGIT     ; PRINT LOW NIBBLE
00F950  1  8A                   TXA                     ; RESTORE ACCUMULATOR
00F951  1  4C 54 F9             JMP     PRINT_DIGIT     ; PRINT LOW NIBBLE
00F954  1               
00F954  1               ;__PRINT_DIGIT_________________________________________________
00F954  1               ;
00F954  1               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00F954  1               ;
00F954  1               ;______________________________________________________________
00F954  1               PRINT_DIGIT:
00F954  1  29 0F                AND     #$0F            ; STRIP OFF HIGH NIBBLE
00F956  1  09 30                ORA     #$30            ; ADD $30 TO PRODUCE ASCII
00F958  1  C9 3A                CMP     #$3A            ; IS GREATER THAN 9
00F95A  1  30 03                BMI     PRINT_DIGIT_OUT ; NO, SKIP ADD
00F95C  1  18                   CLC                     ; CLEAR CARRY
00F95D  1  69 07                ADC     #$07            ; ADD ON FOR LETTER VALUES
00F95F  1               PRINT_DIGIT_OUT:                ;
00F95F  1  4C 42 FA             JMP     IOF_OUTCH       ; PRINT OUT CHAR
00F962  1               
00F962  1               
00F962  1               
00F962  1               ;__OUTSTR______________________________________________________
00F962  1               ;
00F962  1               ; OUTPUT THE STRING POINTED TO BY OUTSTR TO THE SCREEN
00F962  1               ;
00F962  1               ;______________________________________________________________
00F962  1               OUTSTR:
00F962  1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
00F964  1               OUTSTRLP:
00F964  1  B1 4F                LDA     (STRPTR),Y      ; LOAD NEXT CHAR FROM STRING INTO ACC
00F966  1  C9 00                CMP     #$00            ; IS NULL?
00F968  1  F0 0C                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00F96A  1  20 42 FA             JSR     IOF_OUTCH       ; PRINT CHAR IN ACC
00F96D  1  E6 4F                INC     STRPTR
00F96F  1  D0 F3                BNE     OUTSTRLP
00F971  1  E6 50                INC     STRPTR+1
00F973  1  4C 64 F9             JMP     OUTSTRLP        ; DO NEXT CHAR
00F976  1               ENDOUTSTR:
00F976  1  60                   RTS                     ; RETURN
00F977  1               
00F977  1               ;__INSTR_______________________________________________________
00F977  1               ;
00F977  1               ; INPUT STRING FROM KEYBOARD INTO KEYBOARD BUFFER
00F977  1               ;
00F977  1               ;______________________________________________________________
00F977  1               INSTR:
00F977  1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
00F979  1               INSTRLP:
00F979  1  20 35 FA             JSR     IOF_CONINW
00F97C  1  C9 60                CMP     #$60            ; IS LOWER CASE
00F97E  1  90 02                BCC     INSTRUC         ; NO, SKIP
00F980  1  29 DF                AND     #$DF            ; TO UPPER CASE
00F982  1               INSTRUC:
00F982  1  C9 0D                CMP     #$0D            ; IS CR?
00F984  1  F0 1E                BEQ     ENDINSTR        ; YES, DONE WITH INPUT
00F986  1  C9 08                CMP     #$08            ; IS BACKSPACE?
00F988  1  D0 10                BNE     INSTR_NOTBS     ; NO, SKUP BACKSPACE RTN
00F98A  1  C0 00                CPY     #$00            ; IS INDEX =0 ?
00F98C  1  F0 1B                BEQ     INSTR_EMPTY_BS  ; YES, SKIP BACKSPACE
00F98E  1  20 42 FA             JSR     IOF_OUTCH       ; OUTPUT CHAR TO SCREEN
00F991  1  88                   DEY                     ; Y=Y-1
00F992  1  A9 00                LDA     #$00            ;
00F994  1  91 4F                STA     (STRPTR),Y      ; NULL TERMINATE INPUT BUFFER
00F996  1  88                   DEY                     ; Y=Y-1
00F997  1  4C 9F F9             JMP     INSTR_SKIP_STORE; SKIP STORE OF CHAR TO INPUT BUFFER
00F99A  1               INSTR_NOTBS:
00F99A  1  91 4F                STA     (STRPTR),Y      ; STORE CHAR IN KEYBAORD BUFFER
00F99C  1  20 42 FA             JSR     IOF_OUTCH       ; OUTPUT CHAR TO SCREEN
00F99F  1               INSTR_SKIP_STORE:
00F99F  1  C8                   INY                     ; Y=Y+1
00F9A0  1  C0 FF                CPY     #$FF            ; DOES Y=$FF
00F9A2  1  D0 D5                BNE     INSTRLP         ; NO, LOOP FOR NEXT CHAR
00F9A4  1               ENDINSTR:
00F9A4  1  A9 00                LDA     #$00            ; A=0
00F9A6  1  91 4F                STA     (STRPTR),Y      ; NULL TERMINATE INPUT BUFFER
00F9A8  1  60                   RTS
00F9A9  1               INSTR_EMPTY_BS:
00F9A9  1  A9 00                LDA     #$00            ; BLANK OUT KEYBOARD CHAR, TO SIGNAL READY FOR NEXT CHAR
00F9AB  1  4C 79 F9             JMP     INSTRLP         ; JUMP TO INPUT LOOP
00F9AE  1               
00F9AE  1               
00F9AE  1               ;__LOAD_________________________________________________________
00F9AE  1               
00F9AE  1               ; LOAD A MOTOROLA FORMATTED HEX FILE
00F9AE  1               ;
00F9AE  1               ;_______________________________________________________________
00F9AE  1               LOAD:
00F9AE  1  20 4D F5             JSR     RDSER1W         ;
00F9B1  1  C9 53                CMP     #'S'            ;
00F9B3  1  D0 F9                BNE     LOAD            ; FIRST CHAR NOT (S)
00F9B5  1  20 4D F5             JSR     RDSER1W         ; READ CHAR
00F9B8  1  C9 39                CMP     #'9'            ;
00F9BA  1  F0 2C                BEQ     LOAD21          ;
00F9BC  1  C9 31                CMP     #'1'            ;
00F9BE  1  D0 EE                BNE     LOAD            ; SECOND CHAR NOT (1)
00F9C0  1  A9 00                LDA     #$00            ;
00F9C2  1  85 4D                STA     CKSM            ; ZERO CHECKSUM
00F9C4  1  20 E9 F9             JSR     LGETBYTE        ; READ BYTE
00F9C7  1  E9 01                SBC     #$01            ;
00F9C9  1  85 4E                STA     BYTECT          ; BYTE COUNT
00F9CB  1  20 16 FA             JSR     BADDR           ; BUILD ADDRESS
00F9CE  1  A0 00                LDY     #$00            ;
00F9D0  1               LOAD11:
00F9D0  1  20 E9 F9             JSR     LGETBYTE        ;
00F9D3  1  C6 4E                DEC     BYTECT          ;
00F9D5  1  F0 08                BEQ     LOAD15          ; ZERO BYTE COUNT
00F9D7  1  91 41                STA     (TEMPWORD1),Y   ; STORE DATA
00F9D9  1  20 21 FA             JSR     INCTEMPWORD1    ;
00F9DC  1  4C D0 F9             JMP     LOAD11          ;
00F9DF  1               
00F9DF  1               LOAD15:
00F9DF  1  E6 4D                INC     CKSM            ;
00F9E1  1  F0 CB                BEQ     LOAD            ;
00F9E3  1               LOAD19:
00F9E3  1  A9 3F                LDA     #'?'            ;
00F9E5  1  20 32 F5             JSR     WRSER1          ;
00F9E8  1               LOAD21:
00F9E8  1  60                   RTS
00F9E9  1               LGETBYTE:
00F9E9  1  20 01 FA             JSR     INHEX           ; GET HEX CHAR
00F9EC  1  0A                   ASL     A               ;
00F9ED  1  0A                   ASL     A               ;
00F9EE  1  0A                   ASL     A               ;
00F9EF  1  0A                   ASL     A               ;
00F9F0  1  85 45                STA     TEMPBYTE        ;
00F9F2  1  20 01 FA             JSR     INHEX           ;
00F9F5  1  29 0F                AND     #$0F            ; MASK TO 4 BITS
00F9F7  1  05 45                ORA     TEMPBYTE        ;
00F9F9  1  48                   PHA                     ;
00F9FA  1  18                   CLC                     ;
00F9FB  1  65 4D                ADC     CKSM            ;
00F9FD  1  85 4D                STA     CKSM            ;
00F9FF  1  68                   PLA                     ;
00FA00  1  60                   RTS                     ;
00FA01  1               ; INPUT HEX CHAR
00FA01  1               INHEX:
00FA01  1  20 4D F5             JSR     RDSER1W         ;
00FA04  1  48                   PHA                     ;
00FA05  1  20 32 F5             JSR     WRSER1          ;
00FA08  1  68                   PLA                     ;
00FA09  1  C9 3A                CMP     #$3A            ; LESS THAN 9?
00FA0B  1  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00FA0D  1  E9 2F                SBC     #$2F            ; CONVERT 0-9
00FA0F  1               INHEX_BIG:
00FA0F  1  C9 41                CMP     #$41            ; A OR MORE?
00FA11  1  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
00FA13  1  E9 37                SBC     #$37            ; CONVERT A-F
00FA15  1               INHEX_SMALL:
00FA15  1  60                   RTS                     ;
00FA16  1               
00FA16  1               ; BUILD ADDRESS
00FA16  1               BADDR:
00FA16  1  20 E9 F9             JSR     LGETBYTE        ; READ 2 FRAMES
00FA19  1  85 42                STA     TEMPWORD1+1     ;
00FA1B  1  20 E9 F9             JSR     LGETBYTE        ;
00FA1E  1  85 41                STA     TEMPWORD1       ;
00FA20  1  60                   RTS
00FA21  1               
00FA21  1               
00FA21  1               INCTEMPWORD1:
00FA21  1  E6 41                INC     TEMPWORD1       ; INCREMENT LOWBYTE
00FA23  1  D0 02                BNE     INCTEMPWORD1_OUT; NOT ZERO?, DONE
00FA25  1  E6 42                INC     TEMPWORD1+1     ; ZERO, INC HIGH BYTE
00FA27  1               INCTEMPWORD1_OUT:
00FA27  1  60                   RTS                     ; RETURN
00FA28  1               
00FA28  1               
00FA28  1               ;__IOF_CONIN____________________________________________________
00FA28  1               ;
00FA28  1               ; read a byte from CONSOLE ('A' POINTS TO BYTE)
00FA28  1               ;_______________________________________________________________
00FA28  1               IOF_CONIN:
00FA28  1  A5 3A                LDA     CONSOLE
00FA2A  1  C9 01                CMP     #$01
00FA2C  1  F0 03                BEQ     CONINSERIAL
00FA2E  1  4C 6F F5             JMP     PPPCONIN
00FA31  1               CONINSERIAL:
00FA31  1  4C 3F F5             JMP     RDSER1
00FA34  1  60                   RTS
00FA35  1               
00FA35  1               ;__IOF_CONINW____________________________________________________
00FA35  1               ;
00FA35  1               ; read a byte from CONSOLE ('A' POINTS TO BYTE, WAIT FOR BYTE)
00FA35  1               ;_______________________________________________________________
00FA35  1               IOF_CONINW:
00FA35  1  A5 3A                LDA     CONSOLE
00FA37  1  C9 01                CMP     #$01
00FA39  1  F0 03                BEQ     CONINSERIALW
00FA3B  1  4C 78 F5             JMP     PPPCONINW
00FA3E  1               CONINSERIALW:
00FA3E  1  4C 4D F5             JMP     RDSER1W
00FA41  1  60                   RTS
00FA42  1               
00FA42  1               ;__IOF_OUTCH____________________________________________________
00FA42  1               ;
00FA42  1               ; write a byte from CONSOLE  ('A' POINTS TO BYTE)
00FA42  1               ;_______________________________________________________________
00FA42  1               IOF_OUTCH:
00FA42  1  48                   PHA
00FA43  1  A5 3A                LDA     CONSOLE
00FA45  1  C9 01                CMP     #$01
00FA47  1  F0 04                BEQ     CONOUTSERIAL
00FA49  1  68                   PLA
00FA4A  1  4C 64 F5             JMP     PPPOUTCH
00FA4D  1               CONOUTSERIAL:
00FA4D  1  68                   PLA
00FA4E  1  4C 32 F5             JMP     WRSER1
00FA51  1  60                   RTS
00FA52  1               
00FA52  1               ;__IOF_CONSTATUS________________________________________________
00FA52  1               ;
00FA52  1               ; RETURN CONSOLE STATUS
00FA52  1               ;______________________________________________________________
00FA52  1               IOF_CONSTATUS:
00FA52  1  A5 3A                LDA     CONSOLE
00FA54  1  C9 01                CMP     #$01
00FA56  1  F0 03                BEQ     CONSTATUSSERIAL
00FA58  1  4C 87 F5             JMP     PPPCONSTATUS
00FA5B  1               CONSTATUSSERIAL:
00FA5B  1  4C 57 F5             JMP     SERIALSTATUS
00FA5E  1  60                   RTS
00FA5F  1               
00FA5F  1               
00FA5F  1               ;__INITPAGES____________________________________________________
00FA5F  1               ;
00FA5F  1               ; SETUP MMU FOR BIOS PAGED MEMORY OPERATION
00FA5F  1               ;
00FA5F  1               ; SETUP:
00FA5F  1               ; 	TASK 0, NORMAL OPERATION
00FA5F  1               ;   TASK 1, ADDITIONAL ROM DRIVERS PAGED INTO C000-D000
00FA5F  1               ;	TASKS 2-15 -- OPEN FOR OS/USER USE
00FA5F  1               ;_______________________________________________________________
00FA5F  1               INITPAGES:
00FA5F  1  A9 00                LDA     #$00            ; ENSURE MMU IS DISABLED (SHOULD BE ALREADY, BUT . . . )
00FA61  1  8D 30 EA             STA     M6X0X_MMU_ENA
00FA64  1  A9 01                LDA     #$01
00FA66  1  8D 10 EA             STA     M6X0X_MAP_SETUP ; Fill TASK 1
00FA69  1  20 89 FA             JSR     INITPAGE        ; FILL TASK 1 WITH A 1:1 MAP
00FA6C  1  A9 8C                LDA     #$8C            ; BUT, MAP Cxxx AND Dxxx TO ROM Cxxx AND Dxxx RATHER THAN RAM
00FA6E  1  8D 2C EA             STA     M6X0X_MAP_SPACE+$0C
00FA71  1  A9 8D                LDA     #$8D
00FA73  1  8D 2D EA             STA     M6X0X_MAP_SPACE+$0D
00FA76  1  A9 00                LDA     #$00
00FA78  1  8D 10 EA             STA     M6X0X_MAP_SETUP ; Then do task 0
00FA7B  1  20 89 FA             JSR     INITPAGE        ; FILL TASK 0 WITH A 1:1 MAP
00FA7E  1                                               ;  Why task 1 before task 0??   On some boards every write to the register also writes to task 0
00FA7E  1                                               ;  so it is important to write task 0 last (or not use it)
00FA7E  1  A9 00                LDA     #$00
00FA80  1  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FA83  1  A9 01                LDA     #$01
00FA85  1  8D 30 EA             STA     M6X0X_MMU_ENA   ; ENABLE MMU --- FEEEEEL THE POOOOWERRRR
00FA88  1  60                   RTS
00FA89  1               
00FA89  1               
00FA89  1               INITPAGE:
00FA89  1  A2 00                LDX     #$00
00FA8B  1               :
00FA8B  1  8A                   TXA
00FA8C  1  9D 20 EA             STA     M6X0X_MAP_SPACE,X; CREATE A 1:1 MAP OF BANK
00FA8F  1  E8                   INX
00FA90  1  E0 10                CPX     #$10
00FA92  1  D0 F7                BNE     :-
00FA94  1  60                   RTS
00FA95  1               
00FA95  1               P_SETUPDRIVE:                   ; init floppy drive
00FA95  1  20 7E FB             JSR     PAGE_ENTER
00FA98  1  20 6C C1             JSR     SETUPDRIVE
00FA9B  1  4C 76 FB             JMP     PAGE_EXIT
00FA9E  1               P_READFL:                       ; read sector from floppy
00FA9E  1  20 7E FB             JSR     PAGE_ENTER
00FAA1  1  20 BA C1             JSR     READFL
00FAA4  1  4C 76 FB             JMP     PAGE_EXIT
00FAA7  1               P_WRITEFL:                      ; write sector to floppy
00FAA7  1  20 7E FB             JSR     PAGE_ENTER
00FAAA  1  20 23 C2             JSR     WRITEFL
00FAAD  1  4C 76 FB             JMP     PAGE_EXIT
00FAB0  1               P_PPP_SOFT_RESET:               ; reset ppp sd drive
00FAB0  1  20 7E FB             JSR     PAGE_ENTER
00FAB3  1  20 32 C1             JSR     PPP_SOFT_RESET
00FAB6  1  4C 76 FB             JMP     PAGE_EXIT
00FAB9  1               P_PPP_READ_SECTOR:              ; read ppp sd drive sector
00FAB9  1  20 7E FB             JSR     PAGE_ENTER
00FABC  1  20 50 C0             JSR     PPP_READ_SECTOR
00FABF  1  4C 76 FB             JMP     PAGE_EXIT
00FAC2  1               P_PPP_WRITE_SECTOR:             ; write ppp sd drive sector
00FAC2  1  20 7E FB             JSR     PAGE_ENTER
00FAC5  1  20 D2 C0             JSR     PPP_WRITE_SECTOR
00FAC8  1  4C 76 FB             JMP     PAGE_EXIT
00FACB  1               P_IDE_SOFT_RESET:               ; reset ide drive
00FACB  1  20 7E FB             JSR     PAGE_ENTER
00FACE  1  20 A8 C6             JSR     PPIDE_RESET
00FAD1  1  4C 76 FB             JMP     PAGE_EXIT
00FAD4  1               P_IDE_READ_SECTOR:              ; ide read sector
00FAD4  1  20 7E FB             JSR     PAGE_ENTER
00FAD7  1  20 31 C6             JSR     IDE_READ_SECTOR
00FADA  1  4C 76 FB             JMP     PAGE_EXIT
00FADD  1               P_IDE_WRITE_SECTOR:             ; ide write sector
00FADD  1  20 7E FB             JSR     PAGE_ENTER
00FAE0  1  20 7B C6             JSR     IDE_WRITE_SECTOR
00FAE3  1  4C 76 FB             JMP     PAGE_EXIT
00FAE6  1               P_PPP_INITIALIZE:
00FAE6  1  20 7E FB             JSR     PAGE_ENTER
00FAE9  1  20 38 C1             JSR     PPP_INITIALIZE
00FAEC  1  4C 76 FB             JMP     PAGE_EXIT
00FAEF  1               P_IDE_INITIALIZE:
00FAEF  1  20 7E FB             JSR     PAGE_ENTER
00FAF2  1  20 6C C4             JSR     PPIDE_INIT
00FAF5  1  4C 76 FB             JMP     PAGE_EXIT
00FAF8  1               P_CLRDIR:
00FAF8  1  20 7E FB             JSR     PAGE_ENTER
00FAFB  1  20 0F C8             JSR     CLRDIR
00FAFE  1  4C 76 FB             JMP     PAGE_EXIT
00FB01  1               P_RTC_WRITE:
00FB01  1  20 7E FB             JSR     PAGE_ENTER
00FB04  1  20 EE C8             JSR     RTC_WRITE
00FB07  1  4C 76 FB             JMP     PAGE_EXIT
00FB0A  1               P_RTC_READ:
00FB0A  1  20 7E FB             JSR     PAGE_ENTER
00FB0D  1  20 08 C9             JSR     RTC_READ
00FB10  1  4C 76 FB             JMP     PAGE_EXIT
00FB13  1               P_RTC_RESET:
00FB13  1  20 7E FB             JSR     PAGE_ENTER
00FB16  1  20 22 C9             JSR     RTC_RESET
00FB19  1  4C 76 FB             JMP     PAGE_EXIT
00FB1C  1               P_DSKY_INIT:
00FB1C  1  20 7E FB             JSR     PAGE_ENTER
00FB1F  1  20 E1 C9             JSR     DSKY_INIT
00FB22  1  4C 76 FB             JMP     PAGE_EXIT
00FB25  1               P_DSKY_RESET:
00FB25  1  20 7E FB             JSR     PAGE_ENTER
00FB28  1  20 FB CA             JSR     DSKY_RESET
00FB2B  1  4C 76 FB             JMP     PAGE_EXIT
00FB2E  1               P_DSKY_SHOW:
00FB2E  1  20 7E FB             JSR     PAGE_ENTER
00FB31  1  20 AE CB             JSR     DSKY_SHOW
00FB34  1  4C 76 FB             JMP     PAGE_EXIT
00FB37  1               P_DSKY_BIN2SEG:
00FB37  1  20 7E FB             JSR     PAGE_ENTER
00FB3A  1  20 79 CB             JSR     DSKY_BIN2SEG
00FB3D  1  4C 76 FB             JMP     PAGE_EXIT
00FB40  1               P_DSKY_STAT:
00FB40  1  20 7E FB             JSR     PAGE_ENTER
00FB43  1  20 16 CB             JSR     DSKY_STAT
00FB46  1  4C 76 FB             JMP     PAGE_EXIT
00FB49  1               P_DSKY_GETKEY:
00FB49  1  20 7E FB             JSR     PAGE_ENTER
00FB4C  1  20 23 CB             JSR     DSKY_GETKEY
00FB4F  1  4C 76 FB             JMP     PAGE_EXIT
00FB52  1               P_DSKY_BEEP:
00FB52  1  20 7E FB             JSR     PAGE_ENTER
00FB55  1  20 7D CC             JSR     DSKY_BEEP
00FB58  1  4C 76 FB             JMP     PAGE_EXIT
00FB5B  1               P_DSKY_PUTLED:
00FB5B  1  20 7E FB             JSR     PAGE_ENTER
00FB5E  1  20 66 CC             JSR     DSKY_PUTLED
00FB61  1  4C 76 FB             JMP     PAGE_EXIT
00FB64  1               P_DSKY_BLANK:
00FB64  1  20 7E FB             JSR     PAGE_ENTER
00FB67  1  20 34 CC             JSR     DSKY_BLANK
00FB6A  1  4C 76 FB             JMP     PAGE_EXIT
00FB6D  1               P_DSKY_DSPL:
00FB6D  1  20 7E FB             JSR     PAGE_ENTER
00FB70  1  20 AA CC             JSR     DSKY_DSPL
00FB73  1  4C 76 FB             JMP     PAGE_EXIT
00FB76  1               
00FB76  1               PAGE_EXIT:
00FB76  1  48                   PHA
00FB77  1  A9 00                LDA     #$00
00FB79  1  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FB7C  1  68                   PLA
00FB7D  1  60                   RTS
00FB7E  1               PAGE_ENTER:
00FB7E  1  48                   PHA
00FB7F  1  78                   SEI
00FB80  1  A9 01                LDA     #$01
00FB82  1  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FB85  1  A9 01                LDA     #$01
00FB87  1  8D 30 EA             STA     M6X0X_MMU_ENA   ; ENSURE MMU IS ENABLED --- FEEEEEL THE POOOOWERRRR
00FB8A  1  68                   PLA
00FB8B  1  60                   RTS
00FB8C  1               
00FB8C  1               ; COMMAND PROCESSOR JUMP TABLE
00FB8C  1               COMMAND_LOOKUP_TABLE:
00FB8C  1  52 45 47 49          .BYTE   "REGISTER",0,<PRINT_REG,>PRINT_REG
00FB90  1  53 54 45 52  
00FB94  1  00 18 F6     
00FB97  1  44 55 4D 50          .BYTE   "DUMP",0,<DUMP,>DUMP
00FB9B  1  00 9A F7     
00FB9E  1  45 4E 54 45          .BYTE   "ENTER",0,<ENTERMEM,>ENTERMEM
00FBA2  1  52 00 E6 F7  
00FBA6  1  47 4F 00 82          .BYTE   "GO",0,<GO,>GO
00FBAA  1  F7           
00FBAB  1  4C 4F 41 44          .BYTE   "LOAD",0,<LOAD,>LOAD
00FBAF  1  00 AE F9     
00FBB2  1  42 4F 4F 54          .BYTE   "BOOT",0,<IOF_BOOT,>IOF_BOOT
00FBB6  1  00 18 F7     
00FBB9  1  44 49 53 41          .BYTE   "DISASSEMBLE",0,<DISASSEMBLE,>DISASSEMBLE
00FBBD  1  53 53 45 4D  
00FBC1  1  42 4C 45 00  
00FBC7  1  41 53 53 45          .BYTE   "ASSEMBLE",0,<ASSEMBLE,>ASSEMBLE
00FBCB  1  4D 42 4C 45  
00FBCF  1  00 7A F1     
00FBD2  1  43 4C 52 44          .BYTE   "CLRDIR",0,<P_CLRDIR,>P_CLRDIR
00FBD6  1  49 52 00 F8  
00FBDA  1  FA           
00FBDB  1  01 00                .BYTE   01,0
00FBDD  1               ; COMMAND PROMPT STRING
00FBDD  1               PROMPT:
00FBDD  1  0D 0A 2E 00          .BYTE   $0D,$0A,".",0
00FBE1  1               ; ERROR STRING
00FBE1  1               ERROR:
00FBE1  1  0D 0A 3F 20          .BYTE   $0D,$0A,"? BAD COMMAND",$0D,0
00FBE5  1  42 41 44 20  
00FBE9  1  43 4F 4D 4D  
00FBF2  1               INERROR:
00FBF2  1  0D 0A 3F 20          .BYTE   $0D,$0A,"? BAD HEX NUMBER",$0D,0
00FBF6  1  42 41 44 20  
00FBFA  1  48 45 58 20  
00FC06  1               ; STRINGS FOR REGISTER DISPLY
00FC06  1               REGDATA:
00FC06  1  0D 0A                .BYTE   $0D,$0A
00FC08  1  20 20 20 50          .BYTE   "   PC  AC  XR  YR  SP  SR"
00FC0C  1  43 20 20 41  
00FC10  1  43 20 20 58  
00FC21  1  0D 0A 21 20          .BYTE   $0D,$0A,"! ",0
00FC25  1  00           
00FC26  1               
00FC26  1               ; DSKY STARTUP MESSAGE
00FC26  1               DSKYMSG:
00FC26  1  7D 6D 3F 5B          .BYTE   $7D,$6D,$3F,$5B,$00,$39,$73,$3E; 6502 CPU
00FC2A  1  00 39 73 3E  
00FC2E  1               
00FC2E  1               
00FC2E  1               ;BIOS JUMP TABLE
00FC2E  1                       .SEGMENT "JUMPTABLE"
00FC2E  1                       .ORG    $FD00           ; JUMP TABLE LOCATION
00FD00  1  4C 28 FA             JMP     IOF_CONIN       ; read a byte from CONSOLE ('A' POINTS TO BYTE)
00FD03  1  4C 35 FA             JMP     IOF_CONINW      ; read a byte from CONSOLE ('A' POINTS TO BYTE, WAIT FOR BYTE)
00FD06  1  4C 42 FA             JMP     IOF_OUTCH       ; write a byte from CONSOLE  ('A' POINTS TO BYTE)
00FD09  1  4C 52 FA             JMP     IOF_CONSTATUS   ; RETURN CONSOLE STATUS
00FD0C  1  4C 22 F5             JMP     SERIALINIT      ; called during OS init
00FD0F  1  4C 3F F5             JMP     RDSER1          ; read a byte from serial port ('A' POINTS TO BYTE)
00FD12  1  4C 32 F5             JMP     WRSER1          ; write a byte from serial port  ('A' POINTS TO BYTE)
00FD15  1  4C 4D F5             JMP     RDSER1W         ; read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00FD18  1  4C 57 F5             JMP     SERIALSTATUS    ; GET UART STATUS
00FD1B  1  4C 95 FA             JMP     P_SETUPDRIVE    ; init floppy drive
00FD1E  1  4C 9E FA             JMP     P_READFL        ; read sector from floppy
00FD21  1  4C A7 FA             JMP     P_WRITEFL       ; write sector to floppy
00FD24  1  4C B0 FA             JMP     P_PPP_SOFT_RESET; reset ppp sd drive
00FD27  1  4C B9 FA             JMP     P_PPP_READ_SECTOR; read ppp sd drive sector
00FD2A  1  4C C2 FA             JMP     P_PPP_WRITE_SECTOR; write ppp sd drive sector
00FD2D  1  4C CB FA             JMP     P_IDE_SOFT_RESET; reset ide drive
00FD30  1  4C D4 FA             JMP     P_IDE_READ_SECTOR; ide read sector
00FD33  1  4C DD FA             JMP     P_IDE_WRITE_SECTOR; ide write sector
00FD36  1  4C AE F9             JMP     LOAD            ; load s19 file into memory
00FD39  1  4C E6 FA             JMP     P_PPP_INITIALIZE; INITIALIZE PPP SD HARDWARE
00FD3C  1  4C EF FA             JMP     P_IDE_INITIALIZE; INITIALIZE/DETECT IDE V3 HARDWARE
00FD3F  1  4C 01 FB             JMP     P_RTC_WRITE     ; WRITE RTC REGISTER
00FD42  1  4C 0A FB             JMP     P_RTC_READ      ; READ RTC REGISTER
00FD45  1  4C 13 FB             JMP     P_RTC_RESET     ; RESET RTC
00FD48  1  4C 1C FB             JMP     P_DSKY_INIT     ; INIT DSKY HARDWARE
00FD4B  1  4C 25 FB             JMP     P_DSKY_RESET    ; RESET DSKY CONTROLLER
00FD4E  1  4C 2E FB             JMP     P_DSKY_SHOW     ; SHOW DSKY SEGMENTS
00FD51  1  4C 37 FB             JMP     P_DSKY_BIN2SEG  ; CONVERT NUMBER TO DSKY SEGMENTS
00FD54  1  4C 40 FB             JMP     P_DSKY_STAT     ; CHECK DSKY KEYBOARD
00FD57  1  4C 49 FB             JMP     P_DSKY_GETKEY   ; GET DSKY KEYPRESS
00FD5A  1  4C 52 FB             JMP     P_DSKY_BEEP     ; BEEP DSKY
00FD5D  1  4C 5B FB             JMP     P_DSKY_PUTLED   ; SET KEYBOARD LED MATRIX
00FD60  1  4C 64 FB             JMP     P_DSKY_BLANK    ; BLANK DSKY DISPLAY
00FD63  1  4C 6D FB             JMP     P_DSKY_DSPL     ; UPDATE INDIVIDUAL DISPLAY LEDS
00FD66  1               
00FD66  1               
00FD66  1               
00FD66  1               
00FD66  1                       .SEGMENT "VECTORS"
00FD66  1                       .ORG    $FFFA
00FFFA  1               NNTVECTOR:
00FFFA  1  15 F6                .WORD   NINTERRUPT      ;
00FFFC  1               RSTVECTOR:
00FFFC  1  90 F5                .WORD   COLD_START      ;
00FFFE  1               INTVECTOR:
00FFFE  1  01 F6                .WORD   INTERRUPT       ; ROM VECTOR FOR IRQ
010000  1               
010000  1                       .END
