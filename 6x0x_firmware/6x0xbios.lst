ca65 V2.18 - Ubuntu 2.19-1
Main file   : 6x0xbios.asm
Current file: 6x0xbios.asm

000000r 1               
000000r 1               ;__6x0xbios__________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	BIOS for the 6502 6x0x Retrobrew Computers SBC
000000r 1               ;
000000r 1               ;	ORIGINALLY WRITTEN BY: DAN WERNER -- 1/1/2014
000000r 1               ; 	Code cleanup: Dan Werner -- 1/22/2023
000000r 1               ;
000000r 1               ; ** NOTE THAT THIS BIOS NEEDS PAGED MEMORY TO OPERATE
000000r 1               ; ** K17 MUST BE OPEN FOR PAGED MEMORY TO OPERATE ON THE 6502 CPU
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; CONFIGURATION
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               M6X0X_IOSPACE   = $E000
000000r 1               M6X0X_SHADOW_ROM = $F000
000000r 1               
000000r 1               ; PAGER
000000r 1               M6X0X_ACT_TASK  = M6X0X_IOSPACE+$A00
000000r 1               M6X0X_MAP_SETUP = M6X0X_IOSPACE+$A10
000000r 1               M6X0X_MAP_SPACE = M6X0X_IOSPACE+$A20
000000r 1               M6X0X_MMU_ENA   = M6X0X_IOSPACE+$A30
000000r 1               
000000r 1               ;
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;ZERO PAGE	ADDRESS			; FUNCTION
000000r 1               farfunct        = $32           ; function to call in driver area
000000r 1               farpointer      = $33           ;
000000r 1               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 1               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 1               CONSOLE         = $3A           ; CURRENT CONSOLE
000000r 1               TEMPWORD        = $3B           ;
000000r 1               TEMPWORD1       = $3D           ;
000000r 1               TEMPWORD2       = $3F           ;
000000r 1               STRPTR          = $41
000000r 1               hstbuf          = $0200         ; 0200-03ff host buffer
000000r 1               
000000r 1               ;
000000r 1               ; DRIVER WORKING STORAGE
000000r 1               ;
000000r 1               INBUFFER        = $0400         ;
000000r 1               
000000r 1               DSKY_BUF        = $0500         ; Eight Bytes DSKY display buffer
000000r 1               DSKY_BUFLEN     = 8             ;
000000r 1               DSKY_HEXBUF     = $0508         ; Four Bytes DSKY hex buffer
000000r 1               DSKY_HEXBUFLEN  = 4             ;
000000r 1               sektrk          = $050C         ; seek track number
000000r 1               seksec          = $050E         ; seek sector number
000000r 1               debcyll         = $0510         ; DEBLOCKED CYLINDER LSB
000000r 1               debcylm         = $0511         ; DEBLOCKED CYLINDER MSB
000000r 1               debsehd         = $0512         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 1               Cdebcyll        = $0513         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 1               Cdebcylm        = $0514         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 1               Cdebsehd        = $0515         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 1               sekdsk          = $0516         ; seek disk number
000000r 1               dskcfg          = $0517         ; 16 bytes disk configuration table
000000r 1               DSKUNIT         = $0528         ; seek disk number
000000r 1               ST0             = $0529         ;
000000r 1               FLERR           = $052A         ;
000000r 1               FCMD            = $052B         ;
000000r 1               FLRETRY         = $052C         ;
000000r 1               FLRETRY1        = $052D         ;
000000r 1               FLATCH_STORE    = $052E         ;
000000r 1               PPIDETIMEOUT    = $052F         ; (word)
000000r 1               slicetmp        = $0531         ; (word)
000000r 1               PPIDEINDEX      = $0533
000000r 1               CURRENT_IDE_DRIVE = $0534
000000r 1               DSKY_X_STORAGE  = $0535
000000r 1               DSKY_Y_STORAGE  = $0536
000000r 1               DSKY_TEMP_VAL   = $0537
000000r 1               DSKY_PPIX_VAL   = $0538
000000r 1               DSKY_PRESENT    = $0539
000000r 1               
000000r 1               STARTOS         = $B800
000000r 1               
000000r 1               
000000r 1                       .ORG    $C000
00C000  1                       .SEGMENT "DRIVERS"
00C000  1                       .INCLUDE "macro.asm"
00C000  2               ;__MACRO___________________________________________________________________________________________________________________
00C000  2               ;
00C000  2               ; 	Macros for the betterment of Mankind
00C000  2               ;________________________________________________________________________________________________________________________________
00C000  2               ;
00C000  2               
00C000  2               .macro          PRTS      message
00C000  2               .LOCAL p1
00C000  2               .LOCAL p2
00C000  2               .LOCAL p3
00C000  2               .LOCAL p4
00C000  2               .LOCAL p5
00C000  2                 .if     .paramcount <> 1
00C000  2                       .error  "Too few parameters for macro PRTS"
00C000  2                       .endif
00C000  2                       PHA
00C000  2                       TXA
00C000  2                       pha
00C000  2                       TYA
00C000  2                       PHA
00C000  2                       LDX #$00
00C000  2               p1:
00C000  2                       LDA p4,x
00C000  2                       INX
00C000  2                       CMP #'$'
00C000  2                       BEQ p2
00C000  2                       JSR MACRO_OUTCH
00C000  2                       JMP p1
00C000  2               p2:
00C000  2                       PLA
00C000  2                       TAY
00C000  2                       plA
00C000  2                       TAX
00C000  2                       pla
00C000  2                       JMP p5
00C000  2               p4:
00C000  2                       .BYTE message
00C000  2               p5:
00C000  2               .endmacro
00C000  2               
00C000  2               
00C000  2               
00C000  2               NEWLINE:
00C000  2  48                   PHA
00C001  2  8A                   TXA
00C002  2  48                   PHA
00C003  2  98                   TYA
00C004  2  48                   PHA
00C005  2  A9 0D                LDA     #$0D
00C007  2  20 58 C0             JSR     MACRO_OUTCH
00C00A  2  A9 0A                LDA     #$0A
00C00C  2  20 58 C0             JSR     MACRO_OUTCH
00C00F  2  68                   PLA
00C010  2  A8                   TAY
00C011  2  68                   plA
00C012  2  AA                   TAX
00C013  2  68                   PLA
00C014  2  60                   RTS
00C015  2               
00C015  2               PRTDEC:
00C015  2  48                   PHA
00C016  2  8A                   TXA
00C017  2  48                   PHA
00C018  2  98                   TYA
00C019  2  48                   PHA
00C01A  2  A0 00                LDY     #00
00C01C  2  A2 FF                LDX     #$FF
00C01E  2  38                   SEC
00C01F  2               PrDec100:
00C01F  2  E8                   INX
00C020  2  E9 64                SBC     #100
00C022  2  B0 FB                BCS     PrDec100        ;Count how many 100s
00C024  2  69 64                ADC     #100
00C026  2  20 42 C0             JSR     PrDecDigit      ;Print the 100s
00C029  2  A2 FF                LDX     #$FF
00C02B  2  38                   SEC                     ;Prepare for subtraction
00C02C  2               PrDec10:
00C02C  2  E8                   INX
00C02D  2  E9 0A                SBC     #10
00C02F  2  B0 FB                BCS     PrDec10         ;Count how many 10s
00C031  2  69 0A                ADC     #10
00C033  2  20 42 C0             JSR     PrDecDigit      ;Print the 10s
00C036  2  AA                   TAX                     ;Pass 1s into X
00C037  2  A0 01                LDY     #1
00C039  2  20 42 C0             JSR     PrDecDigit      ;Print the 1s
00C03C  2  68                   PLA
00C03D  2  A8                   TAY
00C03E  2  68                   plA
00C03F  2  AA                   TAX
00C040  2  68                   PLA
00C041  2  60                   RTS
00C042  2               PrDecDigit:
00C042  2  48                   PHA
00C043  2  C0 00                CPY     #$00
00C045  2  D0 09                BNE     PrDecDigit1
00C047  2  8A                   TXA
00C048  2  A8                   TAY
00C049  2  C0 00                CPY     #$00
00C04B  2  D0 03                BNE     PrDecDigit1
00C04D  2  4C 56 C0             JMP     PrDecDigit2
00C050  2               PrDecDigit1:
00C050  2  8A                   TXA                     ;Save A, pass digit to A
00C051  2  09 30                ORA     #'0'
00C053  2  20 58 C0             JSR     MACRO_OUTCH       ;Convert to character and print it
00C056  2               PrDecDigit2:
00C056  2  68                   PLA
00C057  2  60                   RTS                     ;Restore A and return
00C058  2               
00C058  2               
00C058  2               MACRO_OUTCH:
00C058  2  48                   PHA
00C059  2  A5 3A                LDA     CONSOLE
00C05B  2  85 32                STA     farfunct
00C05D  2  68                   PLA
00C05E  2  4C 71 C0             JMP     FUNCTION_DISPATCHER
00C061  2               
00C061  2               PRINT_BYTE:
00C061  2  8E CA 00             STX     SAVX            ; save X
00C064  2  20 BF F6             JSR     ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
00C067  2  20 58 C0             JSR     MACRO_OUTCH     ; output upper nybble
00C06A  2  8A                   TXA                     ; transfer lower to A
00C06B  2  AE CA 00             LDX     SAVX            ; restore X
00C06E  2  4C 58 C0             JMP     MACRO_OUTCH     ; output lower nybble
00C071  2               
00C071  1                       .INCLUDE "bios_options.asm"
00C071  2               ;__BIOS OPTIONS__________________________________________________________________________________________________________________
00C071  2               ;
00C071  2               ; 	Optional components are defined in this file
00C071  2               ;
00C071  2               ;________________________________________________________________________________________________________________________________
00C071  2               ;
00C071  2               
00C071  2               ; DSKY Type, choose one of the options listed
00C071  2               DSKY_OPTION     = 2             ; DSKY Type  1=ORIGINAL, 2=NG, 0=NONE
00C071  2               DSKYOSC         = 1000000       ; Set DSKY NG Osc frequency
00C071  2               
00C071  1                       .INCLUDE "bios_dispatch.asm"
00C071  2               ; Character devices:
00C071  2               ;----------------------------
00C071  2               ;  Console (Redirected)
00C071  2               ;  Serial ports (1-x)
00C071  2               ;  ParPortProp
00C071  2               ;  VDU
00C071  2               ;  CVDU
00C071  2               ;  Printer Port
00C071  2               
00C071  2               ; Block Devices
00C071  2               ;----------------------------
00C071  2               ; ParPortProp SD Card
00C071  2               ; PPP IDE
00C071  2               ; Floppy
00C071  2               ; MD
00C071  2               
00C071  2               ; DSKY?
00C071  2               ; RTC?
00C071  2               ; IO PORTS?
00C071  2               ; SOUND CARDS?
00C071  2               ;
00C071  2               
00C071  2               ;__DISPATCHER________________________________________________________________________________________
00C071  2               ;
00C071  2               ;  Function dispatcher
00C071  2               ;  function to call is located in "farfunct"
00C071  2               ;____________________________________________________________________________________________________
00C071  2               ;
00C071  2               FUNCTION_DISPATCHER:
00C071  2  48                   PHA
00C072  2  8A                   TXA
00C073  2  48                   PHA
00C074  2  A5 32                LDA     farfunct
00C076  2  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
00C077  2  AA                   TAX
00C078  2  BD 88 C0             LDA     DISPATCHTABLE,X
00C07B  2  85 33                STA     farpointer
00C07D  2  BD 89 C0             LDA     DISPATCHTABLE+1,X
00C080  2  85 34                STA     farpointer+1
00C082  2               
00C082  2  68                   PLA
00C083  2  AA                   TAX
00C084  2  68                   PLA
00C085  2  6C 33 00             JMP     (farpointer)
00C088  2               
00C088  2               
00C088  2               DISPATCHTABLE:
00C088  2  41 CA                .WORD   DFT_CONSOLE     ; FUNCTION 00 - WRITE CONSOLE
00C08A  2  41 CA                .WORD   DFT_CONSOLE     ; FUNCTION 01 - READ CONSOLE
00C08C  2  41 CA                .WORD   DFT_CONSOLE     ; FUNCTION 02 - READ CONSOLE (BLOCKING)
00C08E  2  41 CA                .WORD   DFT_CONSOLE     ; FUNCTION 03 - GET CONSOLE STATUS
00C090  2               
00C090  2  FC C1                .WORD   WRSER1          ; FUNCTION 04 - WRITE SERIAL PORT
00C092  2  09 C2                .WORD   RDSER1          ; FUNCTION 05 - READ SERIAL PORT
00C094  2  17 C2                .WORD   RDSER1W         ; FUNCTION 06 - READ SERIAL PORT (BLOCKING)
00C096  2  21 C2                .WORD   SERIALSTATUS    ; FUNCTION 07 - GET SERIAL STATUS
00C098  2  EC C1                .WORD   SERIALINIT      ; FUNCTION 08 - SERIAL PORT INIT
00C09A  2               
00C09A  2  2E C2                .WORD   PPPOUTCH        ; FUNCTION 09 - WRITE PROP VIDEO
00C09C  2  39 C2                .WORD   PPPCONIN        ; FUNCTION 10 - READ PROP KEYBOARD
00C09E  2  42 C2                .WORD   PPPCONINW       ; FUNCTION 11 - READ  PROP KEYBOARD (BLOCKING)
00C0A0  2  51 C2                .WORD   PPPCONSTATUS    ; FUNCTION 12 - GET  PROP KEYBOARD STATUS
00C0A2  2  0C C1                .WORD   INIT_PPP        ; FUNCTION 13 - INIT PROP INTERFACE
00C0A4  2               
00C0A4  2  00 00                .WORD   0000            ; FUNCTION 14
00C0A6  2  00 00                .WORD   0000            ; FUNCTION 15
00C0A8  2  00 00                .WORD   0000            ; FUNCTION 16
00C0AA  2  00 00                .WORD   0000            ; FUNCTION 17
00C0AC  2  00 00                .WORD   0000            ; FUNCTION 18
00C0AE  2  00 00                .WORD   0000            ; FUNCTION 19
00C0B0  2  00 00                .WORD   0000            ; FUNCTION 20
00C0B2  2  00 00                .WORD   0000            ; FUNCTION 21
00C0B4  2  00 00                .WORD   0000            ; FUNCTION 22
00C0B6  2  00 00                .WORD   0000            ; FUNCTION 23
00C0B8  2  00 00                .WORD   0000            ; FUNCTION 24
00C0BA  2  00 00                .WORD   0000            ; FUNCTION 25
00C0BC  2  00 00                .WORD   0000            ; FUNCTION 26
00C0BE  2  00 00                .WORD   0000            ; FUNCTION 27
00C0C0  2  00 00                .WORD   0000            ; FUNCTION 28
00C0C2  2  00 00                .WORD   0000            ; FUNCTION 29
00C0C4  2  00 00                .WORD   0000            ; FUNCTION 30
00C0C6  2  00 00                .WORD   0000            ; FUNCTION 31
00C0C8  2  00 00                .WORD   0000            ; FUNCTION 32
00C0CA  2  00 00                .WORD   0000            ; FUNCTION 33
00C0CC  2  00 00                .WORD   0000            ; FUNCTION 34
00C0CE  2  00 00                .WORD   0000            ; FUNCTION 35
00C0D0  2  00 00                .WORD   0000            ; FUNCTION 36
00C0D2  2  00 00                .WORD   0000            ; FUNCTION 37
00C0D4  2  00 00                .WORD   0000            ; FUNCTION 38
00C0D6  2  00 00                .WORD   0000            ; FUNCTION 39
00C0D8  2               ;
00C0D8  2  40 CB                .WORD   DSKY_INIT       ; FUNCTION 40 -
00C0DA  2  1D CD                .WORD   DSKY_SHOW       ; FUNCTION 41 -
00C0DC  2  DE CC                .WORD   DSKY_BIN2SEG    ; FUNCTION 42 -
00C0DE  2  6E CC                .WORD   DSKY_RESET      ; FUNCTION 43 -
00C0E0  2  7B CC                .WORD   DSKY_STAT       ; FUNCTION 44 -
00C0E2  2  88 CC                .WORD   DSKY_GETKEY     ; FUNCTION 45 -
00C0E4  2  FA CD                .WORD   DSKY_BEEP       ; FUNCTION 46 -
00C0E6  2  2B CE                .WORD   DSKY_DSPL       ; FUNCTION 47 -
00C0E8  2  DF CD                .WORD   DSKY_PUTLED     ; FUNCTION 48 -
00C0EA  2  A9 CD                .WORD   DSKY_BLANK      ; FUNCTION 49 -
00C0EC  2               ;
00C0EC  2  4D CA                .WORD   RTC_WRITE       ; FUNCTION 50 -
00C0EE  2  67 CA                .WORD   RTC_READ        ; FUNCTION 51 -
00C0F0  2  81 CA                .WORD   RTC_RESET       ; FUNCTION 52 -
00C0F2  2               
00C0F2  2  00 00                .WORD   0000            ; FUNCTION 53
00C0F4  2  00 00                .WORD   0000            ; FUNCTION 54
00C0F6  2  00 00                .WORD   0000            ; FUNCTION 55
00C0F8  2  00 00                .WORD   0000            ; FUNCTION 56
00C0FA  2  00 00                .WORD   0000            ; FUNCTION 57
00C0FC  2  00 00                .WORD   0000            ; FUNCTION 58
00C0FE  2  00 00                .WORD   0000            ; FUNCTION 59
00C100  2               
00C100  2  7A C6                .WORD   PPIDE_INIT      ; FUNCTION 60 - called during OS init
00C102  2  5B C8                .WORD   IDE_READ_SECTOR ; FUNCTION 61 - read a sector from drive
00C104  2  A5 C8                .WORD   IDE_WRITE_SECTOR; FUNCTION 62 - write a sector to drive
00C106  2               ;
00C106  2  42 C3                .WORD   PPP_INITIALIZE  ; FUNCTION 63 - init the ppp sd device
00C108  2  5A C2                .WORD   PPP_READ_SECTOR ; FUNCTION 64 - read a sector from the ppp sd device
00C10A  2  DC C2                .WORD   PPP_WRITE_SECTOR; FUNCTION 65 - write a sector to the ppp sd device
00C10C  2               ;
00C10C  2               ;        .WORD   FL_SETUP        ; FUNCTION 66 - init floppy device
00C10C  2               ;        .WORD   FL_READ_SECTOR  ; FUNCTION 67 - read a sector from floppy device
00C10C  2               ;        .WORD   FL_WRITE_SECTOR ; FUNCTION 68 - write a sector to floppy device
00C10C  2               ;
00C10C  2               ;        .WORD   MD_SHOW         ; FUNCTION 69 - md show information
00C10C  2               ;        .WORD   MD_READ_SECTOR  ; FUNCTION 70 - read a sector from memory device
00C10C  2               ;        .WORD   MD_WRITE_SECTOR ; FUNCTION 71 - write a sector to memory device
00C10C  2               
00C10C  1                       .INCLUDE "bios_ppp_common.asm"
00C10C  2               ;__Parallel Port Prop Common Code_________________________________________________________________________________________________
00C10C  2               ;
00C10C  2               ; 	This is the code that is common to all PPP drivers
00C10C  2               ;
00C10C  2               ;	Entry points:
00C10C  2               ;		INIT_PPP - INIT THE PPP HARDWARE
00C10C  2               ;		SENDCMD - SEND A COMMAND TO THE PPP HARDWARE
00C10C  2               ;		PUTBYTE -  SEND A BYTE TO THE PPP HARDWARE
00C10C  2               ;		GETBYTE -  GET BYTE FROM THE PPP HARDWARE
00C10C  2               ;________________________________________________________________________________________________________________________________
00C10C  2               ;
00C10C  2               
00C10C  2               
00C10C  2               
00C10C  2               ;*
00C10C  2               ;* HARDWARE I/O ADDRESSES
00C10C  2               ;*
00C10C  2               PPPPIOA         = M6X0X_IOSPACE+$EFC
00C10C  2               PPPCNTA         = M6X0X_IOSPACE+$EFD
00C10C  2               PPPPIOB         = M6X0X_IOSPACE+$EFE
00C10C  2               PPPCNTB         = M6X0X_IOSPACE+$EFF
00C10C  2               
00C10C  2               ;*__INIT_PPP___________________________________________________________________________________
00C10C  2               ;*
00C10C  2               ;*  INIT THE PPP HARDWARE
00C10C  2               ;*
00C10C  2               ;*____________________________________________________________________________________________________
00C10C  2               INIT_PPP:
00C10C  2               
00C10C  2  A9 00                LDA     #$00            ; SELECT DDR
00C10E  2  8D FD EE             STA     PPPCNTA
00C111  2  A9 00                LDA     #$00            ; SET ALL PINS INPUT
00C113  2  8D FC EE             STA     PPPPIOA         ;
00C116  2  A9 00                LDA     #$00            ; SELECT DDR
00C118  2  8D FF EE             STA     PPPCNTB
00C11B  2               
00C11B  2  A9 6F                LDA     #%01101111      ; SET CONTROL PINS
00C11D  2               ; PB0=>CMD/DATA	[O]
00C11D  2               ; PB1=> X  		[O]
00C11D  2               ; PB2=> RESET 	[O]
00C11D  2               ; PB3=> X   	[O]
00C11D  2               ; PB4=> STB 	[I]
00C11D  2               ; PB5=> IBF 	[0]
00C11D  2               ; PB6=> ACK 	[O]
00C11D  2               ; PB7=> OBF 	[I]
00C11D  2               ;
00C11D  2  8D FE EE             STA     PPPPIOB         ;
00C120  2               
00C120  2  A9 04                LDA     #$04            ; SELECT PIO
00C122  2  8D FD EE             STA     PPPCNTA
00C125  2  8D FF EE             STA     PPPCNTB
00C128  2               
00C128  2  A9 04                LDA     #%00000100      ; ASSERT RESET
00C12A  2  8D FE EE             STA     PPPPIOB
00C12D  2  A9 01                LDA     #%00000001      ; DEASSERT RESET,  DATA
00C12F  2  8D FE EE             STA     PPPPIOB
00C132  2               
00C132  2               INIT_PPP0:
00C132  2               
00C132  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C135  2  09 40                ORA     #%01000000
00C137  2  8D FE EE             STA     PPPPIOB
00C13A  2               
00C13A  2               INIT_PPP1:
00C13A  2               ; WAIT FOR STB LOW (OUTPUT BUFFER READY)
00C13A  2  AD FE EE             LDA     PPPPIOB         ;
00C13D  2  29 10                AND     #%00010000      ;
00C13F  2  D0 F9                BNE     INIT_PPP1       ;
00C141  2  AD FC EE             LDA     PPPPIOA         ;IS $AA?
00C144  2  C9 AA                CMP     #$AA
00C146  2  D0 F2                BNE     INIT_PPP1       ; NO, STILL INIT IN PROCESS
00C148  2               
00C148  2  AD FE EE             LDA     PPPPIOB         ; YES, BRING ACK LOW
00C14B  2  29 BF                AND     #%10111111
00C14D  2  8D FE EE             STA     PPPPIOB
00C150  2               INIT_PPP3:                      ; WAIT FOR STB HIGH
00C150  2  AD FE EE             LDA     PPPPIOB
00C153  2  29 10                AND     #%00010000
00C155  2  F0 F9                BEQ     INIT_PPP3
00C157  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C15A  2  09 40                ORA     #%01000000
00C15C  2  8D FE EE             STA     PPPPIOB
00C15F  2  60                   RTS
00C160  2               
00C160  2               
00C160  2               
00C160  2               ;*__SENDCMD___________________________________________________________________________________________
00C160  2               ;*
00C160  2               ;*  SEND A COMMAND TO THE PPP HARDWARE
00C160  2               ;*
00C160  2               ;*____________________________________________________________________________________________________
00C160  2               SENDCMD:
00C160  2  48                   PHA
00C161  2               SENDCMD1:
00C161  2  AD FE EE             LDA     PPPPIOB         ;
00C164  2  29 FE                AND     #%11111110      ; SET CMD FLAG
00C166  2  8D FE EE             STA     PPPPIOB         ; SEND IT
00C169  2  68                   PLA
00C16A  2  20 76 C1             JSR     PUTBYTE         ; SEND THE COMMAND BYTE
00C16D  2               ; TURN OFF CMD
00C16D  2  AD FE EE             LDA     PPPPIOB         ;
00C170  2  09 01                ORA     #%00000001      ; CLEAR CMD FLAG
00C172  2  8D FE EE             STA     PPPPIOB         ; SEND IT
00C175  2  60                   RTS
00C176  2               
00C176  2               ;*__PUTBYTE___________________________________________________________________________________________
00C176  2               ;*
00C176  2               ;*  SEND A BYTE TO THE PPP HARDWARE
00C176  2               ;*
00C176  2               ;*____________________________________________________________________________________________________
00C176  2               
00C176  2               PUTBYTE:
00C176  2  48                   PHA
00C177  2  A9 00                LDA     #$00
00C179  2  8D FD EE             STA     PPPCNTA
00C17C  2  A9 FF                LDA     #$FF            ; SET ALL PINS OUTPUT
00C17E  2  8D FC EE             STA     PPPPIOA         ;
00C181  2  A9 04                LDA     #$04
00C183  2  8D FD EE             STA     PPPCNTA
00C186  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C189  2  09 40                ORA     #%01000000
00C18B  2  8D FE EE             STA     PPPPIOB
00C18E  2               PUTWAIT1:
00C18E  2               ; WAIT FOR OBF HIGH
00C18E  2  AD FE EE             LDA     PPPPIOB         ;
00C191  2  29 80                AND     #%10000000      ;
00C193  2  F0 F9                BEQ     PUTWAIT1        ;
00C195  2  68                   PLA
00C196  2  8D FC EE             STA     PPPPIOA
00C199  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK LOW
00C19C  2  29 BF                AND     #%10111111
00C19E  2  8D FE EE             STA     PPPPIOB
00C1A1  2               PUTWAIT2:
00C1A1  2               ; WAIT FOR OBF LOW
00C1A1  2  AD FE EE             LDA     PPPPIOB         ;
00C1A4  2  29 80                AND     #%10000000      ;
00C1A6  2  D0 F9                BNE     PUTWAIT2        ;
00C1A8  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C1AB  2  09 40                ORA     #%01000000
00C1AD  2  8D FE EE             STA     PPPPIOB
00C1B0  2  60                   RTS
00C1B1  2               
00C1B1  2               ;*__GETBYTE___________________________________________________________________________________________
00C1B1  2               ;*
00C1B1  2               ;*  GET BYTE FROM THE PPP HARDWARE
00C1B1  2               ;*
00C1B1  2               ;*____________________________________________________________________________________________________
00C1B1  2               
00C1B1  2               GETBYTE:
00C1B1  2  A9 00                LDA     #$00
00C1B3  2  8D FD EE             STA     PPPCNTA
00C1B6  2  A9 00                LDA     #$00            ; SET ALL PINS INPUT
00C1B8  2  8D FC EE             STA     PPPPIOA         ;
00C1BB  2  A9 04                LDA     #$04
00C1BD  2  8D FD EE             STA     PPPCNTA
00C1C0  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C1C3  2  09 40                ORA     #%01000000
00C1C5  2  8D FE EE             STA     PPPPIOB
00C1C8  2               GETWAIT1:
00C1C8  2               ; WAIT FOR STB LOW
00C1C8  2  AD FE EE             LDA     PPPPIOB         ;
00C1CB  2  29 10                AND     #%00010000      ;
00C1CD  2  D0 F9                BNE     GETWAIT1        ;
00C1CF  2  AD FC EE             LDA     PPPPIOA
00C1D2  2  48                   PHA
00C1D3  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK LOW
00C1D6  2  29 BF                AND     #%10111111
00C1D8  2  8D FE EE             STA     PPPPIOB
00C1DB  2               GETWAIT2:
00C1DB  2               ; WAIT FOR STB HIGH
00C1DB  2  AD FE EE             LDA     PPPPIOB         ;
00C1DE  2  29 10                AND     #%00010000      ;
00C1E0  2  F0 F9                BEQ     GETWAIT2        ;
00C1E2  2  AD FE EE             LDA     PPPPIOB         ; BRING ACK HIGH
00C1E5  2  09 40                ORA     #%01000000
00C1E7  2  8D FE EE             STA     PPPPIOB
00C1EA  2  68                   PLA
00C1EB  2  60                   RTS
00C1EC  2               
00C1EC  1                       .INCLUDE "bios_serial.asm"
00C1EC  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00C1EC  2               ;
00C1EC  2               ; 	serial drivers
00C1EC  2               ;
00C1EC  2               ;	Entry points:
00C1EC  2               ;		SERIALINIT  - called during OS init
00C1EC  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00C1EC  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00C1EC  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00C1EC  2               ;		SERIALSTATUS- GET UART STATUS
00C1EC  2               ;________________________________________________________________________________________________________________________________
00C1EC  2               ;
00C1EC  2               
00C1EC  2               
00C1EC  2               ;*
00C1EC  2               ;* HARDWARE I/O ADDRESSES
00C1EC  2               ;*
00C1EC  2               
00C1EC  2               UART1DATA       = M6X0X_IOSPACE+$FF4; SERIAL PORT 1 (I/O Card)
00C1EC  2               UART1STATUS     = M6X0X_IOSPACE+$FF5; SERIAL PORT 1 (I/O Card)
00C1EC  2               UART1COMMAND    = M6X0X_IOSPACE+$FF6; SERIAL PORT 1 (I/O Card)
00C1EC  2               UART1CONTROL    = M6X0X_IOSPACE+$FF7; SERIAL PORT 1 (I/O Card)
00C1EC  2               
00C1EC  2               
00C1EC  2               ;Command Register
00C1EC  2               ;No bit is affected by a software reset, however, all bits are set to zero on a hardware reset.
00C1EC  2               ;Bit 7 6 5  configuration
00C1EC  2               ;    x x 0  no parity bit
00C1EC  2               ;    0 0 1  send and receive with odd parity
00C1EC  2               ;    0 1 1  send and receive with even parity
00C1EC  2               ;    1 0 1  send: parity=1; receive: parity not evaluated
00C1EC  2               ;    1 1 1  send: parity=0; receive: parity not evaluated
00C1EC  2               ;
00C1EC  2               ;Bit 4  0: no echo
00C1EC  2               ;       1: echo (received characters are being sent again,
00C1EC  2               ;                bits 2 and 3 must be 0 for that)
00C1EC  2               ;
00C1EC  2               ;Bit 3 2  sender interr.   RTS level   sender
00C1EC  2               ;    0 0  no               high        off
00C1EC  2               ;    0 1  yes              low         on
00C1EC  2               ;    1 0  no               low         on
00C1EC  2               ;    1 1  no               low         send BRK
00C1EC  2               ;
00C1EC  2               ;Bit 1  0: interrupt gets triggered by bit 3 in status register
00C1EC  2               ;       1: no interrupt
00C1EC  2               ;
00C1EC  2               ;Bit 0  0: disable transceiver and interrupts, /DTR high
00C1EC  2               ;       1: enable transceiver and interrupts, /DTR low
00C1EC  2               ;
00C1EC  2               ;Control Register
00C1EC  2               ;Bits 0 to 3 are set to zero on a software reset, and all bits are set to zero on a hardware reset.
00C1EC  2               ;Bit 7  0: 1 stop bit
00C1EC  2               ;       1: a) with 8 data bits and 1 parity bit: 1 stop bit
00C1EC  2               ;          b) with 5 data bits and no parity bit: 1.5 stop bits
00C1EC  2               ;          c) otherwise 2 stop bits
00C1EC  2               ;
00C1EC  2               ;Bit 6 5  data bits
00C1EC  2               ;    0 0  8
00C1EC  2               ;    0 1  7
00C1EC  2               ;    1 0  6
00C1EC  2               ;    1 1  5
00C1EC  2               ;
00C1EC  2               ;Bit 4  0: external receive clock
00C1EC  2               ;       1: builtin clock as receive clock
00C1EC  2               ;
00C1EC  2               ;Bit 3 2 1 0  baud rate
00C1EC  2               ;    0 0 0 0  1/16 times external clock
00C1EC  2               ;    0 0 0 1  50 bps
00C1EC  2               ;    0 0 1 0  75 bps
00C1EC  2               ;    0 0 1 1  109.92 bps
00C1EC  2               ;    0 1 0 0  134.58 bps
00C1EC  2               ;    0 1 0 1  150 bps
00C1EC  2               ;    0 1 1 0  300 bps
00C1EC  2               ;    0 1 1 1  600 bps
00C1EC  2               ;    1 0 0 0  1200 bps
00C1EC  2               ;    1 0 0 1  1800 bps
00C1EC  2               ;    1 0 1 0  2400 bps
00C1EC  2               ;    1 0 1 1  3600 bps
00C1EC  2               ;    1 1 0 0  4800 bps
00C1EC  2               ;    1 1 0 1  7200 bps
00C1EC  2               ;    1 1 1 0  9600 bps
00C1EC  2               ;    1 1 1 1  19200 bps
00C1EC  2               
00C1EC  2               
00C1EC  2               
00C1EC  2               ;__SERIALINIT____________________________________________________________________________________________________________________
00C1EC  2               ;
00C1EC  2               ;	INITIALIZE SERIAL PORTS
00C1EC  2               ;________________________________________________________________________________________________________________________________
00C1EC  2               ;
00C1EC  2               SERIALINIT:
00C1EC  2  A9 00                LDA     #$00            ; RESET UART
00C1EE  2  8D F5 EF             STA     UART1STATUS     ;
00C1F1  2  A9 0B                LDA     #$0B            ;
00C1F3  2  8D F6 EF             STA     UART1COMMAND    ;
00C1F6  2  A9 1E                LDA     #$1E            ; 9600, 8 BITS, NO PARITY, 1 STOP BIT
00C1F8  2  8D F7 EF             STA     UART1CONTROL    ;
00C1FB  2  60                   RTS
00C1FC  2               
00C1FC  2               
00C1FC  2               
00C1FC  2               ;__WRSER1________________________________________________________________________________________________________________________
00C1FC  2               ;
00C1FC  2               ;	WRITE CHARACTER(A) TO UART
00C1FC  2               ;________________________________________________________________________________________________________________________________
00C1FC  2               ;
00C1FC  2               WRSER1:
00C1FC  2  48                   PHA
00C1FD  2               WRSER1a:
00C1FD  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS
00C200  2  29 10                AND     #%00010000      ; IS TX READY
00C202  2  F0 F9                BEQ     WRSER1a         ; NO, WAIT FOR IT
00C204  2  68                   PLA
00C205  2  8D F4 EF             STA     UART1DATA       ; WRITE DATA
00C208  2  60                   RTS
00C209  2               
00C209  2               ;__RDSER1________________________________________________________________________________________________________________________
00C209  2               ;
00C209  2               ;	READ CHARACTER FROM UART TO (A)
00C209  2               ;________________________________________________________________________________________________________________________________
00C209  2               ;
00C209  2               RDSER1:
00C209  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS REGISTER
00C20C  2  29 08                AND     #%00001000      ; IS RX READY
00C20E  2  F0 04                BEQ     RDSER1N         ; NO, INDICATE NO CHAR
00C210  2  AD F4 EF             LDA     UART1DATA       ; GET DATA CHAR
00C213  2  60                   RTS
00C214  2               RDSER1N:
00C214  2  A9 00                LDA     #$00            ;
00C216  2  60                   RTS                     ;
00C217  2               
00C217  2               ;__RDSER1W_______________________________________________________________________________________________________________________
00C217  2               ;
00C217  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
00C217  2               ;________________________________________________________________________________________________________________________________
00C217  2               ;
00C217  2               
00C217  2               RDSER1W:
00C217  2  20 09 C2             JSR     RDSER1
00C21A  2  C9 00                CMP     #$00
00C21C  2  F0 F9                BEQ     RDSER1W
00C21E  2  29 7F                AND     #$7F
00C220  2  60                   RTS
00C221  2               
00C221  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00C221  2               ;
00C221  2               ;	READ UARD STATUS
00C221  2               ;________________________________________________________________________________________________________________________________
00C221  2               ;
00C221  2               SERIALSTATUS:
00C221  2  AD F5 EF             LDA     UART1STATUS     ; GET STATUS REGISTER
00C224  2  29 08                AND     #%00001000      ; IS RX READY
00C226  2  D0 03                BNE     RDSTAT1         ; NO, INDICATE NO CHAR
00C228  2  A9 00                LDA     #$00            ; GET DATA CHAR
00C22A  2  60                   RTS
00C22B  2               RDSTAT1:
00C22B  2  A9 FF                LDA     #$FF            ; GET DATA CHAR
00C22D  2  60                   RTS
00C22E  2               
00C22E  1                       .INCLUDE "bios_ppp_console.asm"
00C22E  2               ;__PARALLEL PORT PROP CONSOLE DRIVERS____________________________________________________________________________________________
00C22E  2               ;
00C22E  2               ; 	DOS CONSOLE DRIVERS FOR THE PARALLEL PORT PROP
00C22E  2               ;
00C22E  2               ;	Entry points:
00C22E  2               ;		PPPCONIN   	- read a byte from CONSOLE ('A' POINTS TO BYTE)
00C22E  2               ;		PPPCONINW  	- read a byte from CONSOLE ('A' POINTS TO BYTE, WAIT FOR BYTE)
00C22E  2               ;		PPPOUTCH   	- write a byte from CONSOLE  ('A' POINTS TO BYTE)
00C22E  2               ;		PPPCONSTATUS	-RETURN CONSOLE STATUS
00C22E  2               ;________________________________________________________________________________________________________________________________
00C22E  2               ;
00C22E  2               
00C22E  2               
00C22E  2               
00C22E  2               
00C22E  2               
00C22E  2               ;__PPPOUTCH______________________________________________________________________________________________________________________
00C22E  2               ;
00C22E  2               ;	WRITE CHARACTER(A) TO PPP
00C22E  2               ;________________________________________________________________________________________________________________________________
00C22E  2               ;
00C22E  2               PPPOUTCH:
00C22E  2  48                   PHA
00C22F  2  A9 20                LDA     #$20
00C231  2  20 60 C1             JSR     SENDCMD
00C234  2  68                   PLA
00C235  2               
00C235  2  20 76 C1             JSR     PUTBYTE
00C238  2  60                   RTS
00C239  2               
00C239  2               ;__PPPCONIN______________________________________________________________________________________________________________________
00C239  2               ;
00C239  2               ;	READ CHARACTER FROM PPP
00C239  2               ;________________________________________________________________________________________________________________________________
00C239  2               ;
00C239  2               PPPCONIN:
00C239  2  A9 31                LDA     #$31
00C23B  2  20 60 C1             JSR     SENDCMD
00C23E  2  20 B1 C1             JSR     GETBYTE
00C241  2  60                   RTS                     ;
00C242  2               
00C242  2               ;__CONINW________________________________________________________________________________________________________________________
00C242  2               ;
00C242  2               ;	READ CHARACTER FROM PPP (WAIT FOR CHAR)
00C242  2               ;________________________________________________________________________________________________________________________________
00C242  2               ;
00C242  2               PPPCONINW:
00C242  2  A9 31                LDA     #$31
00C244  2  20 60 C1             JSR     SENDCMD
00C247  2  20 B1 C1             JSR     GETBYTE
00C24A  2  C9 00                CMP     #$00
00C24C  2  F0 F4                BEQ     PPPCONINW
00C24E  2  29 7F                AND     #$7F
00C250  2  60                   RTS
00C251  2               
00C251  2               ;__IOF_CONSTATUS_________________________________________________________________________________________________________________
00C251  2               ;
00C251  2               ;	READ STATUS FROM PPP
00C251  2               ;________________________________________________________________________________________________________________________________
00C251  2               ;
00C251  2               PPPCONSTATUS:
00C251  2  A9 30                LDA     #$30
00C253  2  20 60 C1             JSR     SENDCMD
00C256  2  20 B1 C1             JSR     GETBYTE
00C259  2  60                   RTS
00C25A  2               
00C25A  1                       .INCLUDE "bios_ppp_hd.asm"
00C25A  2               ;__PARALLEL PORT PROP MASS STORAGE DRIVERS_______________________________________________________________________________________
00C25A  2               ;
00C25A  2               ; 	DOS/65 PARALLEL PORT PROP MASS STORAGE DRIVERS
00C25A  2               ;
00C25A  2               ;	Entry points:
00C25A  2               ;		PPP_SOFT_RESET   - called during OS init
00C25A  2               ;		PPP_READ_SECTOR  - read a sector from drive
00C25A  2               ;		PPP_WRITE_SECTOR - write a sector to drive
00C25A  2               ;               PPP_INITIALIZE   - INITIALIZE HARDWARE
00C25A  2               ;________________________________________________________________________________________________________________________________
00C25A  2               ;
00C25A  2               
00C25A  2               
00C25A  2               ;*__PPP_READ_SECTOR___________________________________________________________________________________
00C25A  2               ;*
00C25A  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00C25A  2               ;*
00C25A  2               ;*____________________________________________________________________________________________________
00C25A  2               PPP_READ_SECTOR:
00C25A  2               
00C25A  2               
00C25A  2  AD 12 05             LDA     debsehd         ;
00C25D  2  CD 15 05             CMP     Cdebsehd        ;
00C260  2  D0 13                BNE     PPP_READ_SECTOR_DIRTY
00C262  2  AD 10 05             LDA     debcyll         ;
00C265  2  CD 13 05             CMP     Cdebcyll        ;
00C268  2  D0 0B                BNE     PPP_READ_SECTOR_DIRTY
00C26A  2  AD 11 05             LDA     debcylm         ;
00C26D  2  CD 14 05             CMP     Cdebcylm        ;
00C270  2  D0 03                BNE     PPP_READ_SECTOR_DIRTY
00C272  2               
00C272  2  A9 00                LDA     #$00
00C274  2  60                   RTS
00C275  2               
00C275  2               PPP_READ_SECTOR_DIRTY:
00C275  2  AD 10 05             LDA     debcyll         ; STORE CURRENT PARMS
00C278  2  8D 13 05             STA     Cdebcyll        ;
00C27B  2  AD 11 05             LDA     debcylm         ;
00C27E  2  8D 14 05             STA     Cdebcylm        ;
00C281  2  AD 12 05             LDA     debsehd         ;
00C284  2  8D 15 05             STA     Cdebsehd        ;
00C287  2               
00C287  2               
00C287  2  A9 14                LDA     #$14
00C289  2  20 60 C1             JSR     SENDCMD
00C28C  2               
00C28C  2  AD 12 05             LDA     debsehd
00C28F  2  20 76 C1             JSR     PUTBYTE
00C292  2  AD 10 05             LDA     debcyll
00C295  2  20 76 C1             JSR     PUTBYTE
00C298  2  AD 11 05             LDA     debcylm
00C29B  2  20 76 C1             JSR     PUTBYTE
00C29E  2  A9 00                LDA     #$00
00C2A0  2  20 76 C1             JSR     PUTBYTE
00C2A3  2               
00C2A3  2               
00C2A3  2  20 B1 C1             JSR     GETBYTE         ; GET RESULT
00C2A6  2  C9 00                CMP     #$00
00C2A8  2  D0 0B                BNE     PPP_READ_SECTOR_ERR
00C2AA  2               
00C2AA  2  A9 13                LDA     #$13
00C2AC  2  20 60 C1             JSR     SENDCMD
00C2AF  2  20 C3 C2             JSR     GETBUF
00C2B2  2  A9 00                LDA     #$00
00C2B4  2  60                   RTS
00C2B5  2               PPP_READ_SECTOR_ERR:
00C2B5  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C2B7  2  8D 15 05             STA     Cdebsehd        ;
00C2BA  2  8D 13 05             STA     Cdebcyll        ;
00C2BD  2  8D 14 05             STA     Cdebcylm        ;
00C2C0  2               
00C2C0  2  A9 02                LDA     #$02
00C2C2  2  60                   RTS
00C2C3  2               GETBUF:
00C2C3  2  A2 00                LDX     #$00
00C2C5  2               GETBUF1:
00C2C5  2  20 B1 C1             JSR     GETBYTE
00C2C8  2  9D 00 02             STA     hstbuf,X
00C2CB  2  E8                   INX
00C2CC  2  E0 00                CPX     #$00
00C2CE  2  D0 F5                BNE     GETBUF1
00C2D0  2               GETBUF2:
00C2D0  2  20 B1 C1             JSR     GETBYTE
00C2D3  2  9D 00 03             STA     hstbuf+256,X
00C2D6  2  E8                   INX
00C2D7  2  E0 00                CPX     #$00
00C2D9  2  D0 F5                BNE     GETBUF2
00C2DB  2  60                   RTS
00C2DC  2               
00C2DC  2               
00C2DC  2               ;*__PPP_WRITE_SECTOR__________________________________________________________________________________
00C2DC  2               ;*
00C2DC  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00C2DC  2               ;*
00C2DC  2               ;*____________________________________________________________________________________________________
00C2DC  2               PPP_WRITE_SECTOR:
00C2DC  2               ; WRITE A SECTOR
00C2DC  2  A9 12                LDA     #$12
00C2DE  2  20 60 C1             JSR     SENDCMD
00C2E1  2  20 23 C3             JSR     PUTBUF
00C2E4  2               
00C2E4  2  A9 15                LDA     #$15
00C2E6  2  20 60 C1             JSR     SENDCMD
00C2E9  2               
00C2E9  2  AD 12 05             LDA     debsehd
00C2EC  2  20 76 C1             JSR     PUTBYTE
00C2EF  2  AD 10 05             LDA     debcyll
00C2F2  2  20 76 C1             JSR     PUTBYTE
00C2F5  2  AD 11 05             LDA     debcylm
00C2F8  2  20 76 C1             JSR     PUTBYTE
00C2FB  2  A9 00                LDA     #$00
00C2FD  2  20 76 C1             JSR     PUTBYTE
00C300  2               
00C300  2  20 B1 C1             JSR     GETBYTE         ; GET RESULT
00C303  2  C9 00                CMP     #$00
00C305  2  D0 0E                BNE     PPP_WRITE_SECTOR_ERROR
00C307  2               
00C307  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C309  2  8D 13 05             STA     Cdebcyll        ;
00C30C  2  8D 14 05             STA     Cdebcylm        ;
00C30F  2  8D 15 05             STA     Cdebsehd        ;
00C312  2  A9 00                LDA     #$00
00C314  2  60                   RTS
00C315  2               PPP_WRITE_SECTOR_ERROR:
00C315  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C317  2  8D 15 05             STA     Cdebsehd        ;
00C31A  2  8D 13 05             STA     Cdebcyll        ;
00C31D  2  8D 14 05             STA     Cdebcylm        ;
00C320  2  A9 02                LDA     #$02
00C322  2  60                   RTS
00C323  2               PUTBUF:
00C323  2  A2 00                LDX     #$00
00C325  2               PUTBUF1:
00C325  2  BD 00 02             LDA     hstbuf,X
00C328  2  20 76 C1             JSR     PUTBYTE
00C32B  2  E8                   INX
00C32C  2  E0 00                CPX     #$00
00C32E  2  D0 F5                BNE     PUTBUF1
00C330  2               PUTBUF2:
00C330  2  BD 00 03             LDA     hstbuf+256,X
00C333  2  20 76 C1             JSR     PUTBYTE
00C336  2  E8                   INX
00C337  2  E0 00                CPX     #$00
00C339  2  D0 F5                BNE     PUTBUF2
00C33B  2  60                   RTS
00C33C  2               
00C33C  2               
00C33C  2               ;*__PPP_SOFT_RESET____________________________________________________________________________________
00C33C  2               ;*
00C33C  2               ;*  SOFT RESET PPP CHANNEL
00C33C  2               ;*
00C33C  2               ;*____________________________________________________________________________________________________
00C33C  2               PPP_SOFT_RESET:
00C33C  2  A9 10                LDA     #$10
00C33E  2  20 60 C1             JSR     SENDCMD
00C341  2  60                   RTS                     ;
00C342  2               
00C342  2               ;*__PPP_INITIALIZE____________________________________________________________________________________
00C342  2               ;*
00C342  2               ;*  INITIALIZE THE PPP SD DRIVERS
00C342  2               ;*
00C342  2               ;*____________________________________________________________________________________________________
00C342  2               PPP_INITIALIZE:
00C342  2  48 8A 48 98          PRTS    "SD CARD: INITIALIZED$"; NOT PRESENT
00C346  2  48 A2 00 BD  
00C34A  2  5F C3 E8 C9  
00C374  2  20 00 C0             JSR     NEWLINE
00C377  2  4C 3C C3             JMP     PPP_SOFT_RESET
00C37A  2               
00C37A  1                       .INCLUDE "bios_diov3_flp.asm"
00C37A  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
00C37A  2               ;
00C37A  2               ; 	DOS/65 floppy drivers for direct attached disk-io V3 card
00C37A  2               ;
00C37A  2               ;	Entry points:
00C37A  2               ;		SETUPDRIVE  - called during OS init
00C37A  2               ;		FORMFL	    - format floppy disk
00C37A  2               ;		READFL	    - read a sector from drive
00C37A  2               ;		WRITEFL	    - write a sector to drive
00C37A  2               ;
00C37A  2               ;________________________________________________________________________________________________________________________________
00C37A  2               ;
00C37A  2               
00C37A  2               
00C37A  2               
00C37A  2               ;*
00C37A  2               ;* HARDWARE I/O ADDRESSES
00C37A  2               ;*
00C37A  2               
00C37A  2               FMSR            = M6X0X_IOSPACE+$30; ADDRESS OF MAIN STATUS REGISTER
00C37A  2               FDATA           = M6X0X_IOSPACE+$31; FLOPPY DATA REGISTER
00C37A  2               FLATCH          = M6X0X_IOSPACE+$38; FLOPPY CONFIGURATION LATCH
00C37A  2               
00C37A  2               ;
00C37A  2               ; FDC CONFIGURATION LATCH OUTPUT BIT PATTERNS
00C37A  2               MOTOR           = %00000010     ; BIT PATTERN IN LATCH FOR MOTOR CONTROL (ON)
00C37A  2               TERMCN          = %00000001     ; BIT PATTERN IN LATCH TO WRITE A TC STROBE
00C37A  2               RESETL          = %00000000     ; BIT PATTERN IN LATCH TO RESET ALL BITS
00C37A  2               MINI            = %00000100     ; BIT PATTERN IN LATCH TO SET MINI MODE FDC9229 LOW DENS=1, HIGH DENS=0
00C37A  2               PRECOMP         = %00100000     ; BIT PATTERN IN LATCH TO SET WRITE PRECOMP 125 NS:
00C37A  2               FDDENSITY       = %01000000     ; BIT PATTERN IN LATCH TO FLOPPY LOW DENSITY (HIGH IS 1)
00C37A  2               FDREADY         = %10000000     ; BIT PATTERN IN LATCH TO FLOPPY READY (P-34):
00C37A  2               
00C37A  2               
00C37A  2               
00C37A  2               
00C37A  2               ;__SETUPDRIVE__________________________________________________________________________________________________________________________
00C37A  2               ;
00C37A  2               ;	SETUP FLOPPY DRIVE SETTINGS
00C37A  2               ;________________________________________________________________________________________________________________________________
00C37A  2               ;
00C37A  2               ;
00C37A  2               ;
00C37A  2               SETUPDRIVE:
00C37A  2  A9 00                LDA     #$00
00C37C  2  8D 38 E0             STA     FLATCH
00C37F  2  A9 00                LDA     #RESETL         ; RESET SETTINGS
00C381  2  09 04                ORA     #MINI           ; SELECT MINI FLOPPY (low dens=1, high dens=0)
00C383  2  09 20                ORA     #PRECOMP        ; SELECT PRECOMP
00C385  2  09 40                ORA     #FDDENSITY      ; SELECT HIGH DENSITY
00C387  2  09 80                ORA     #FDREADY        ;
00C389  2  8D 2E 05             STA     FLATCH_STORE    ; SAVE SETTINGS
00C38C  2  8D 38 E0             STA     FLATCH
00C38F  2  20 33 C6             JSR     CHECKINT        ;
00C392  2  A9 03                LDA     #$03            ; SPECIFY COMMAND
00C394  2  20 F1 C5             JSR     PFDATA          ; OUTPUT TO FDC
00C397  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
00C399  2  20 F1 C5             JSR     PFDATA          ; OUTPUT TO FDC
00C39C  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
00C39E  2  20 F1 C5             JSR     PFDATA          ; OUTPUT TO FDC
00C3A1  2  20 33 C6             JSR     CHECKINT        ;
00C3A4  2  20 33 C6             JSR     CHECKINT        ;
00C3A7  2  20 33 C6             JSR     CHECKINT        ;
00C3AA  2  20 33 C6             JSR     CHECKINT        ;
00C3AD  2  20 33 C6             JSR     CHECKINT        ;
00C3B0  2  20 33 C6             JSR     CHECKINT        ;
00C3B3  2  20 C3 C5             JSR     RECAL           ;
00C3B6  2  A9 27                LDA     #39             ;
00C3B8  2  8D 10 05             STA     debcyll         ;
00C3BB  2  20 93 C5             JSR     SETTRACK
00C3BE  2  4C C3 C5             JMP     RECAL           ;
00C3C1  2               
00C3C1  2               ;__OUTFLATCH__________________________________________________________________________________________________________________________
00C3C1  2               ;
00C3C1  2               ;	SEND SETTINGS TO FLOPPY CONTROLLER
00C3C1  2               ;________________________________________________________________________________________________________________________________
00C3C1  2               ;
00C3C1  2               OUTFLATCH:
00C3C1  2  AD 2E 05             LDA     FLATCH_STORE    ; SET A TO SETTINGS
00C3C4  2  8D 38 E0             STA     FLATCH          ; OUTPUT TO CONTROLLER
00C3C7  2  60                   RTS
00C3C8  2               
00C3C8  2               
00C3C8  2               ;__READFL________________________________________________________________________________________________________________________
00C3C8  2               ;
00C3C8  2               ; 	READ A FLOPPY SECTOR
00C3C8  2               ;________________________________________________________________________________________________________________________________
00C3C8  2               ;
00C3C8  2               READFL:
00C3C8  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C3CB  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C3CD  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C3D0  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C3D3  2               
00C3D3  2  AD 10 05             LDA     debcyll         ;
00C3D6  2  CD 13 05             CMP     Cdebcyll        ;
00C3D9  2  D0 0B                BNE     READFL_DIRTY
00C3DB  2  AD 12 05             LDA     debsehd         ;
00C3DE  2  CD 15 05             CMP     Cdebsehd        ;
00C3E1  2  D0 03                BNE     READFL_DIRTY
00C3E3  2               
00C3E3  2  A9 00                LDA     #$00
00C3E5  2  60                   RTS
00C3E6  2               
00C3E6  2               
00C3E6  2               READFL_DIRTY:
00C3E6  2               
00C3E6  2  AD 10 05             LDA     debcyll         ;  STORE CURRENT PARMS
00C3E9  2  8D 13 05             STA     Cdebcyll        ;
00C3EC  2  AD 12 05             LDA     debsehd         ;
00C3EF  2  8D 15 05             STA     Cdebsehd        ;
00C3F2  2               
00C3F2  2               
00C3F2  2  A9 00                LDA     #$00
00C3F4  2  8D 2C 05             STA     FLRETRY
00C3F7  2  8D 2D 05             STA     FLRETRY1
00C3FA  2               READFL1:
00C3FA  2  A9 46                LDA     #$46            ; BIT 6 SETS MFM, 06H IS READ COMMAND
00C3FC  2  8D 2B 05             STA     FCMD
00C3FF  2  20 83 C4             JSR     DSKOP
00C402  2  C9 00                CMP     #$00
00C404  2  F0 28                BEQ     READFLDONE
00C406  2  EE 2C 05             INC     FLRETRY
00C409  2  AD 2C 05             LDA     FLRETRY
00C40C  2  C9 06                CMP     #$06
00C40E  2  D0 EA                BNE     READFL1
00C410  2  20 C3 C5             JSR     RECAL
00C413  2  20 93 C5             JSR     SETTRACK
00C416  2  A9 00                LDA     #$00
00C418  2  8D 2C 05             STA     FLRETRY
00C41B  2  EE 2D 05             INC     FLRETRY1
00C41E  2  AD 2D 05             LDA     FLRETRY1
00C421  2  C9 02                CMP     #$02
00C423  2  D0 D5                BNE     READFL1
00C425  2               
00C425  2  A9 FF                LDA     #$FF
00C427  2  8D 13 05             STA     Cdebcyll        ;
00C42A  2  8D 15 05             STA     Cdebsehd        ;
00C42D  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00C42E  2               READFLDONE:
00C42E  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00C430  2  60                   RTS
00C431  2               
00C431  2               ;__WRITEFL________________________________________________________________________________________________________________________
00C431  2               ;
00C431  2               ; 	WRITE A FLOPPY SECTOR
00C431  2               ;________________________________________________________________________________________________________________________________
00C431  2               ;
00C431  2               WRITEFL:
00C431  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C434  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C436  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C439  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C43C  2               
00C43C  2  A9 FF                LDA     #$FF
00C43E  2  8D 13 05             STA     Cdebcyll        ;
00C441  2  8D 15 05             STA     Cdebsehd        ;
00C444  2  A9 00                LDA     #$00
00C446  2  8D 2C 05             STA     FLRETRY
00C449  2  8D 2D 05             STA     FLRETRY1
00C44C  2               WRITEFL1:
00C44C  2  A9 45                LDA     #$45            ; BIT 6 SETS MFM, 05H IS WRITE COMMAND
00C44E  2  8D 2B 05             STA     FCMD
00C451  2  20 83 C4             JSR     DSKOP
00C454  2  C9 00                CMP     #$00
00C456  2  F0 D6                BEQ     READFLDONE
00C458  2  EE 2C 05             INC     FLRETRY
00C45B  2  AD 2C 05             LDA     FLRETRY
00C45E  2  C9 06                CMP     #$06
00C460  2  D0 EA                BNE     WRITEFL1
00C462  2  20 C3 C5             JSR     RECAL
00C465  2  20 93 C5             JSR     SETTRACK
00C468  2  A9 00                LDA     #$00
00C46A  2  8D 2C 05             STA     FLRETRY
00C46D  2  EE 2D 05             INC     FLRETRY1
00C470  2  AD 2D 05             LDA     FLRETRY1
00C473  2  C9 02                CMP     #$02
00C475  2  D0 D5                BNE     WRITEFL1
00C477  2  A9 FF                LDA     #$FF            ;
00C479  2  8D 13 05             STA     Cdebcyll        ;
00C47C  2  8D 15 05             STA     Cdebsehd        ;
00C47F  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00C480  2               WRITEFLDONE:
00C480  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00C482  2  60                   RTS
00C483  2               
00C483  2               
00C483  2               ;__DSKOP__________________________________________________________________________________________________________________________
00C483  2               ;
00C483  2               ; 	PERFORM A DISK OPERATION
00C483  2               ;________________________________________________________________________________________________________________________________
00C483  2               ;
00C483  2               
00C483  2               DSKOP:
00C483  2  78                   SEI
00C484  2  20 33 C6             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
00C487  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
00C489  2  F0 1B                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
00C48B  2               ;
00C48B  2               ;
00C48B  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C48E  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C490  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C493  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C496  2               ;
00C496  2  20 93 C5             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
00C499  2               ;
00C499  2  AD 2B 05             LDA     FCMD            ; WHAT COMMAND IS PENDING?
00C49C  2  C9 46                CMP     #$46            ; IS IT A READ COMMAND?
00C49E  2  D0 03                BNE     GWRR_POLL       ;
00C4A0  2  4C 06 C5             JMP     RDD_POLL        ;
00C4A3  2               GWRR_POLL:
00C4A3  2  4C 69 C5             JMP     WRR_POLL        ;
00C4A6  2               DSKEXIT:
00C4A6  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C4A9  2  29 FD                AND     #%11111101      ; SET MOTOR OFF
00C4AB  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C4AE  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C4B1  2  A9 FF                LDA     #$FF            ; SET -1 IF ERROR
00C4B3  2  58                   CLI
00C4B4  2  60                   RTS
00C4B5  2               
00C4B5  2               SNDFDWR:
00C4B5  2               
00C4B5  2  A0 00                LDY     #$00            ; BYTES/SECTOR COUNT
00C4B7  2  18                   CLC
00C4B8  2  AD 16 05             LDA     sekdsk          ; GET DISK UNIT NUMBER
00C4BB  2  29 03                AND     #$03            ; MASK FOR FOUR DRIVES.
00C4BD  2  8D 28 05             STA     DSKUNIT         ; PARK IT IN TEMP
00C4C0  2  AD 12 05             LDA     debsehd         ; GET HEAD SELECTION
00C4C3  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00C4C5  2  0A                   ASL     A               ;
00C4C6  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
00C4C7  2  0D 28 05             ORA     DSKUNIT         ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
00C4CA  2  8D 28 05             STA     DSKUNIT         ; STORE IN UNIT
00C4CD  2  AD 2B 05             LDA     FCMD            ;
00C4D0  2  20 F1 C5             JSR     PFDATA          ; PUSH COMMAND TO I8272
00C4D3  2  AD 28 05             LDA     DSKUNIT         ;
00C4D6  2  20 F1 C5             JSR     PFDATA          ;
00C4D9  2  AD 10 05             LDA     debcyll         ;
00C4DC  2  20 F1 C5             JSR     PFDATA          ;
00C4DF  2  AD 12 05             LDA     debsehd         ; GET HEAD SELECTION
00C4E2  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00C4E4  2  20 F1 C5             JSR     PFDATA          ;
00C4E7  2  18                   CLC                     ;
00C4E8  2  AD 12 05             LDA     debsehd         ;
00C4EB  2  4A                   LSR     A
00C4EC  2  69 01                ADC     #$01            ;
00C4EE  2  20 F1 C5             JSR     PFDATA          ;
00C4F1  2  A9 02                LDA     #$02            ;
00C4F3  2  20 F1 C5             JSR     PFDATA          ; WHAT DENSITY
00C4F6  2  A9 09                LDA     #$09            ;
00C4F8  2  20 F1 C5             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
00C4FB  2  A9 1B                LDA     #$1B            ;
00C4FD  2  20 F1 C5             JSR     PFDATA          ; WHAT GAP IS NEEDED
00C500  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
00C502  2  20 1A C6             JSR     PFDATAS
00C505  2  60                   RTS
00C506  2               ; PERFORM READ
00C506  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN.
00C506  2               ;
00C506  2               RDD_POLL:
00C506  2  20 B5 C4             JSR     SNDFDWR         ;
00C509  2               RDS1:
00C509  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C50C  2  10 FB                BPL     RDS1
00C50E  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C510  2  F0 1B                BEQ     DSKOPEND        ; NO, ERROR
00C512  2  AD 31 E0             LDA     FDATA           ; GET DATA
00C515  2  99 00 02             STA     hstbuf,Y        ; WRITE IT
00C518  2  C8                   INY
00C519  2  D0 EE                BNE     RDS1            ; KEEP GOING
00C51B  2               RDS2:
00C51B  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C51E  2  10 FB                BPL     RDS2
00C520  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C522  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
00C524  2  AD 31 E0             LDA     FDATA           ; GET DATA
00C527  2  99 00 03             STA     hstbuf+256,Y    ; WRITE IT
00C52A  2  C8                   INY
00C52B  2  D0 EE                BNE     RDS2            ; KEEP GOING
00C52D  2               
00C52D  2               DSKOPEND:
00C52D  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C530  2  09 01                ORA     #%00000001      ;
00C532  2  8D 2E 05             STA     FLATCH_STORE    ; SET TC
00C535  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C538  2  EA                   NOP                     ;
00C539  2  EA                   NOP                     ; 2 MICROSECOND DELAY
00C53A  2  EA                   NOP                     ;
00C53B  2  EA                   NOP                     ;
00C53C  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C53F  2  29 FE                AND     #%11111110      ;
00C541  2  8D 2E 05             STA     FLATCH_STORE    ; CLEAR TC
00C544  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C547  2  48                   PHA                     ;
00C548  2  68                   PLA                     ;
00C549  2  48                   PHA                     ;
00C54A  2  68                   PLA                     ; 2 MICROSECOND DELAY
00C54B  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C54E  2  29 FD                AND     #%11111101      ; SET MOTOR OFF
00C550  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C553  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER					;
00C556  2               ;
00C556  2  20 69 C6             JSR     GFDATA          ;GET ERROR TYPE
00C559  2  8D 2A 05             STA     FLERR
00C55C  2               
00C55C  2               ;* CLEAR OUT ANY REMAINING DATA
00C55C  2               RESUL3:
00C55C  2  20 69 C6             JSR     GFDATA          ;READ BYTE FROM FDC
00C55F  2  C9 00                CMP     #$00
00C561  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
00C563  2  AD 2A 05             LDA     FLERR           ;
00C566  2  29 C0                AND     #%11000000      ;
00C568  2  60                   RTS
00C569  2               
00C569  2               WRR_POLL:
00C569  2  20 B5 C4             JSR     SNDFDWR         ;
00C56C  2               WRS1:   ;
00C56C  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C56F  2  10 FB                BPL     WRS1            ; NOT READY
00C571  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C573  2  F0 1B                BEQ     WRS3            ; NO, ERROR
00C575  2  B9 00 02             LDA     hstbuf,Y        ; WRITE IT
00C578  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C57B  2  C8                   INY
00C57C  2  D0 EE                BNE     WRS1            ; DO NEXT
00C57E  2               WRS2:   ;
00C57E  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C581  2  10 FB                BPL     WRS2            ; NOT READY
00C583  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00C585  2  F0 09                BEQ     WRS3            ; NO, ERROR
00C587  2  B9 00 03             LDA     hstbuf+256,Y    ; WRITE IT
00C58A  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C58D  2  C8                   INY
00C58E  2  D0 EE                BNE     WRS2            ; DO NEXT
00C590  2               WRS3:
00C590  2  4C 2D C5             JMP     DSKOPEND        ;
00C593  2               
00C593  2               
00C593  2               ;__SETTRACK__________________________________________________________________________________________________________________________
00C593  2               ;
00C593  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
00C593  2               ; 	A: TRACK #
00C593  2               ;________________________________________________________________________________________________________________________________
00C593  2               ;
00C593  2               SETTRACK:
00C593  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C596  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C598  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C59B  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C59E  2               
00C59E  2               ; ANY INTERUPT PENDING
00C59E  2               ; IF YES FIND OUT WHY/CLEAR
00C59E  2  20 33 C6             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
00C5A1  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
00C5A3  2  D0 03                BNE     SETTRK1
00C5A5  2  4C F0 C5             JMP     SETTRKEXIT      ;
00C5A8  2               
00C5A8  2               ;
00C5A8  2               SETTRK1:
00C5A8  2  AD 10 05             LDA     debcyll         ; GET TRACK
00C5AB  2  C9 00                CMP     #$00            ;
00C5AD  2  F0 14                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
00C5AF  2  A9 0F                LDA     #$0F            ; SEEK COMMAND
00C5B1  2  20 F1 C5             JSR     PFDATA          ; PUSH COMMAND
00C5B4  2  AD 16 05             LDA     sekdsk          ; SAY WHICH UNIT
00C5B7  2  20 F1 C5             JSR     PFDATA          ; SEND THAT
00C5BA  2  AD 10 05             LDA     debcyll         ; TO WHAT TRACK
00C5BD  2  20 F1 C5             JSR     PFDATA          ; SEND THAT TOO
00C5C0  2  4C D9 C5             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
00C5C3  2               RECAL:
00C5C3  2  AD 2E 05             LDA     FLATCH_STORE    ; POINT TO FLATCH
00C5C6  2  09 02                ORA     #%00000010      ; SET MOTOR ON
00C5C8  2  8D 2E 05             STA     FLATCH_STORE    ; POINT TO FLATCH
00C5CB  2  20 C1 C3             JSR     OUTFLATCH       ; OUTPUT TO CONTROLLER
00C5CE  2               
00C5CE  2  A9 07                LDA     #$07            ; RECAL TO TRACK 0
00C5D0  2  20 F1 C5             JSR     PFDATA          ; SEND IT
00C5D3  2  AD 16 05             LDA     sekdsk          ; WHICH UNIT
00C5D6  2  20 F1 C5             JSR     PFDATA          ; SEND THAT TOO
00C5D9  2               ;
00C5D9  2               WAINT:
00C5D9  2  48                   PHA
00C5DA  2  8A                   TXA
00C5DB  2  48                   PHA
00C5DC  2  A2 00                LDX     #$00
00C5DE  2               WAINT1:
00C5DE  2  E8                   INX
00C5DF  2  E0 FF                CPX     #$FF
00C5E1  2  D0 FB                BNE     WAINT1
00C5E3  2  68                   PLA
00C5E4  2  AA                   TAX
00C5E5  2  68                   PLA
00C5E6  2               ;
00C5E6  2               SETTRK2:
00C5E6  2  20 33 C6             JSR     CHECKINT
00C5E9  2  AD 30 E0             LDA     FMSR            ; READ SEEK STATUS
00C5EC  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
00C5EE  2  D0 F6                BNE     SETTRK2         ; YES, WAIT FOR THEM
00C5F0  2               ;
00C5F0  2               SETTRKEXIT:
00C5F0  2  60                   RTS
00C5F1  2               
00C5F1  2               ;__PFDATA__________________________________________________________________________________________________________________________
00C5F1  2               ;
00C5F1  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
00C5F1  2               ;
00C5F1  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
00C5F1  2               ;	RQM  DIO
00C5F1  2               ;	0	0	BUSY
00C5F1  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C5F1  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C5F1  2               ;	0	1	BUSY
00C5F1  2               ;
00C5F1  2               ;________________________________________________________________________________________________________________________________
00C5F1  2               ;
00C5F1  2               PFDATA:
00C5F1  2  48                   PHA                     ; SAVE DATA BYTE
00C5F2  2               WRF1:
00C5F2  2  AD 30 E0             LDA     FMSR            ; READ FDC STATUS
00C5F5  2  AA                   TAX
00C5F6  2  29 80                AND     #$80            ;
00C5F8  2  F0 F8                BEQ     WRF1            ; FDC IS NOT READY, WAIT FOR IT
00C5FA  2  8A                   TXA
00C5FB  2  29 40                AND     #$40            ; TEST DIO BIT
00C5FD  2  D0 15                BNE     WRF2            ; FDC IS OUT OF SYNC
00C5FF  2  68                   PLA                     ; RESTORE DATA
00C600  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C603  2               
00C603  2  48                   PHA
00C604  2  68                   PLA
00C605  2  48                   PHA
00C606  2  68                   PLA
00C607  2  48                   PHA
00C608  2  68                   PLA
00C609  2  48                   PHA
00C60A  2  68                   PLA
00C60B  2  48                   PHA
00C60C  2  68                   PLA
00C60D  2  48                   PHA
00C60E  2  68                   PLA
00C60F  2  48                   PHA
00C610  2  68                   PLA
00C611  2  48                   PHA
00C612  2  68                   PLA
00C613  2               
00C613  2  60                   RTS
00C614  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00C614  2               WRF2:
00C614  2  AD 31 E0             LDA     FDATA           ; READ DATA REGISTER
00C617  2  4C F2 C5             JMP     WRF1            ; AND CONTINUE
00C61A  2               
00C61A  2               ;__PFDATAS_________________________________________________________________________________________________________________________
00C61A  2               ;
00C61A  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
00C61A  2               ;
00C61A  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
00C61A  2               ;	RQM  DIO
00C61A  2               ;	0	0	BUSY
00C61A  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C61A  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C61A  2               ;	0	1	BUSY
00C61A  2               ;
00C61A  2               ;________________________________________________________________________________________________________________________________
00C61A  2               ;
00C61A  2               PFDATAS:
00C61A  2  48                   PHA                     ; SAVE DATA BYTE
00C61B  2               WRF1S:
00C61B  2  AD 30 E0             LDA     FMSR            ; READ FDC STATUS
00C61E  2  AA                   TAX
00C61F  2  29 80                AND     #$80            ;
00C621  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
00C623  2  8A                   TXA
00C624  2  29 40                AND     #$40            ; TEST DIO BIT
00C626  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
00C628  2  68                   PLA                     ; RESTORE DATA
00C629  2  8D 31 E0             STA     FDATA           ; WRITE TO FDC
00C62C  2  60                   RTS
00C62D  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00C62D  2               WRF2S:
00C62D  2  AD 31 E0             LDA     FDATA           ; READ DATA REGISTER
00C630  2  4C 1B C6             JMP     WRF1S           ; AND CONTINUE
00C633  2               
00C633  2               
00C633  2               
00C633  2               ;__CHECKINT__________________________________________________________________________________________________________________________
00C633  2               ;
00C633  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
00C633  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
00C633  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
00C633  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
00C633  2               ;________________________________________________________________________________________________________________________________
00C633  2               ;
00C633  2               CHECKINT:
00C633  2  AD 30 E0             LDA     FMSR            ; READING OR WRITING IS KEYS TO D7 RQM
00C636  2  29 80                AND     #$80
00C638  2  F0 F9                BEQ     CHECKINT        ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
00C63A  2  AD 30 E0             LDA     FMSR            ; READING OR WRITING IS KEYS TO D7 RQM
00C63D  2  29 40                AND     #$40            ; WAITING FOR INPUT?
00C63F  2  F0 0E                BEQ     SENDINT
00C641  2  60                   RTS
00C642  2               
00C642  2               ERRCLR:
00C642  2  AD 31 E0             LDA     FDATA           ; CLEAR THE JUNK OUT OF DATA REGISTER
00C645  2  AD 30 E0             LDA     FMSR            ; CHECK WITH RQM
00C648  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
00C64A  2  F0 F6                BEQ     ERRCLR          ;
00C64C  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
00C64E  2               ;
00C64E  2  60                   RTS
00C64F  2               
00C64F  2               ;__SENDINT__________________________________________________________________________________________________________________________
00C64F  2               ;
00C64F  2               ; SENSE INTERRUPT COMMAND
00C64F  2               ;________________________________________________________________________________________________________________________________
00C64F  2               ;
00C64F  2               SENDINT:
00C64F  2  A9 08                LDA     #$08            ; SENSE INTERRUPT COMMAND
00C651  2  20 F1 C5             JSR     PFDATA          ; SEND IT
00C654  2  20 69 C6             JSR     GFDATA          ; GET RESULTS
00C657  2  8D 29 05             STA     ST0             ; STORE THAT
00C65A  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
00C65C  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
00C65E  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
00C660  2  20 69 C6             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
00C663  2  AD 29 05             LDA     ST0             ; GET FIRST ONE
00C666  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
00C668  2               ENDSENDINT:
00C668  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
00C669  2               
00C669  2               
00C669  2               ;__GFDATA__________________________________________________________________________________________________________________________
00C669  2               ;
00C669  2               ; GET DATA FROM FLOPPY CONTROLLER
00C669  2               ;
00C669  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
00C669  2               ;	RQM  DIO
00C669  2               ;	0	0	BUSY
00C669  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00C669  2               ;	1	1	BYTE FOR READ BY HOST PENDING
00C669  2               ;	0	1	BUSY
00C669  2               ;
00C669  2               ;________________________________________________________________________________________________________________________________
00C669  2               ;
00C669  2               GFDATA:
00C669  2  AD 30 E0             LDA     FMSR            ; GET STATUS
00C66C  2  AA                   TAX                     ;
00C66D  2  29 80                AND     #%10000000      ; NOT READY, WAIT
00C66F  2  F0 F8                BEQ     GFDATA          ;
00C671  2  8A                   TXA
00C672  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
00C674  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
00C676  2  AD 31 E0             LDA     FDATA           ; GET FDC DATA
00C679  2               GFDATA1:
00C679  2  60                   RTS
00C67A  2               
00C67A  1                       .INCLUDE "bios_diov3_ide.asm"
00C67A  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00C67A  2               ;
00C67A  2               ; 	DOS/65 DISK DRIVERS FOR DIRECT ATTACHED DISK-IO V3 CARD
00C67A  2               ;
00C67A  2               ;	ENTRY POINTS:
00C67A  2               ;		IDE_SOFT_RESET   - CALLED DURING OS INIT
00C67A  2               ;		IDE_READ_SECTOR  - READ A SECTOR FROM DRIVE
00C67A  2               ;		IDE_WRITE_SECTOR - WRITE A SECTOR TO DRIVE
00C67A  2               ;               IDE_INITIALIZE   - DETECT AND INITIALIZE HARDWARE
00C67A  2               ;________________________________________________________________________________________________________________________________
00C67A  2               ;
00C67A  2               PPIDELO         = M6X0X_IOSPACE+$20; DATA PORT (LOW BYTE)
00C67A  2               PPIDEHI         = M6X0X_IOSPACE+$21; DATA PORT (HIGH BYTE)
00C67A  2               PPIDECNTRL      = M6X0X_IOSPACE+$22; IDE CONTROL
00C67A  2               PPIDEPPIC       = M6X0X_IOSPACE+$23; PPI CONTROL
00C67A  2               
00C67A  2               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
00C67A  2               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
00C67A  2               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
00C67A  2               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C67A  2               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C67A  2               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C67A  2               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C67A  2               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00C67A  2               
00C67A  2               PPIDE_DATA      = PPIDE_CS0_LINE
00C67A  2               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
00C67A  2               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
00C67A  2               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C67A  2               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
00C67A  2               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
00C67A  2               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00C67A  2               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C67A  2               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C67A  2               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00C67A  2               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00C67A  2               
00C67A  2               
00C67A  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00C67A  2               PPIDE_CMD_RECAL = $10
00C67A  2               PPIDE_CMD_READ  = $20
00C67A  2               PPIDE_CMD_WRITE = $30
00C67A  2               PPIDE_CMD_INIT  = $91
00C67A  2               PPIDE_CMD_ID    = $EC
00C67A  2               PPIDE_CMD_SPINDOWN = $E0
00C67A  2               PPIDE_CMD_SPINUP = $E1
00C67A  2               
00C67A  2               
00C67A  2               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00C67A  2               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
00C67A  2               
00C67A  2               
00C67A  2               
00C67A  2               
00C67A  2               ;__PPIDE_INIT_________________________________________________________________________________________
00C67A  2               ;
00C67A  2               ;  INIT AND DISPLAY IDE INFO
00C67A  2               ;____________________________________________________________________________________________________
00C67A  2               ;
00C67A  2               PPIDE_INIT:
00C67A  2  48 8A 48 98          PRTS    "PPIDE :$"
00C67E  2  48 A2 00 BD  
00C682  2  97 C6 E8 C9  
00C69F  2  20 00 C0             JSR     NEWLINE
00C6A2  2  20 4D C8             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
00C6A5  2  D0 39                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
00C6A7  2               ;
00C6A7  2  48 8A 48 98          PRTS    " IO=0x$"
00C6AB  2  48 A2 00 BD  
00C6AF  2  C4 C6 E8 C9  
00C6CB  2  A9 E0                LDA     #>PPIDELO       ; GET BASE PORT
00C6CD  2  20 61 C0             JSR     PRINT_BYTE      ; PRINT BASE PORT
00C6D0  2  A9 20                LDA     #<PPIDELO       ; GET BASE PORT
00C6D2  2  20 61 C0             JSR     PRINT_BYTE      ; PRINT BASE PORT
00C6D5  2               ;
00C6D5  2  20 D2 C8             JSR     PPIDE_RESET     ; RESET THE BUS
00C6D8  2  20 7A C7             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
00C6DB  2  B0 03                BCS     IDE_ABORT
00C6DD  2  4C 0D C7             JMP     IDE_PRINT_INFO
00C6E0  2               IDE_ABORT:
00C6E0  2  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT PRESENT
00C6E4  2  48 A2 00 BD  
00C6E8  2  FD C6 E8 C9  
00C70A  2  4C 76 C7             JMP     IDE_INITA
00C70D  2               IDE_PRINT_INFO:
00C70D  2  20 00 C0             JSR     NEWLINE
00C710  2  48 8A 48 98          PRTS    " PPIDE0: Blocks=$"
00C714  2  48 A2 00 BD  
00C718  2  2D C7 E8 C9  
00C73E  2  A9 00                LDA     #$00
00C740  2  20 BA C7             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00C743  2  48 8A 48 98          PRTS    " PPIDE1: Blocks=$"
00C747  2  48 A2 00 BD  
00C74B  2  60 C7 E8 C9  
00C771  2  A9 01                LDA     #$01
00C773  2  20 BA C7             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00C776  2               IDE_INITA:
00C776  2  20 00 C0             JSR     NEWLINE
00C779  2  60                   RTS                     ; DONE
00C77A  2               ;
00C77A  2               ;__PPIDE_PROBE_______________________________________________________________________________________
00C77A  2               ;
00C77A  2               ;  PROBE FOR IDE HARDWARE
00C77A  2               ;____________________________________________________________________________________________________
00C77A  2               ;
00C77A  2               PPIDE_PROBE:
00C77A  2               ;
00C77A  2               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
00C77A  2               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
00C77A  2               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
00C77A  2               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
00C77A  2               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
00C77A  2               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
00C77A  2               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
00C77A  2               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
00C77A  2               
00C77A  2  A9 00                LDA     #$00
00C77C  2  8D 20 E0             STA     PPIDELO         ; PPI PORT A, DATALO
00C77F  2               
00C77F  2  20 FA C8             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
00C782  2  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
00C784  2  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
00C786  2  20 F9 C9             JSR     IDE_READ
00C789  2  8A                   TXA
00C78A  2  29 40                AND     #%01000000
00C78C  2  C9 00                CMP     #$00
00C78E  2  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
00C790  2               
00C790  2               ; CHECK SIGNATURE
00C790  2  A9 0A                LDA     #PPIDE_SEC_CNT
00C792  2  20 F9 C9             JSR     IDE_READ
00C795  2  E0 01                CPX     #$01
00C797  2  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
00C799  2  A9 0B                LDA     #PPIDE_LBALOW
00C79B  2  20 F9 C9             JSR     IDE_READ
00C79E  2  E0 01                CPX     #$01
00C7A0  2  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
00C7A2  2  A9 0C                LDA     #PPIDE_LBAMID
00C7A4  2  20 F9 C9             JSR     IDE_READ
00C7A7  2  E0 00                CPX     #$00
00C7A9  2  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
00C7AB  2  A9 0D                LDA     #PPIDE_LBAHI
00C7AD  2  20 F9 C9             JSR     IDE_READ
00C7B0  2  E0 00                CPX     #$00
00C7B2  2  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
00C7B4  2  18                   CLC
00C7B5  2  4C B9 C7             JMP     PPIDE_PROBE_SUCCESS
00C7B8  2               PPIDE_PROBE_FAIL:
00C7B8  2  38                   SEC
00C7B9  2               PPIDE_PROBE_SUCCESS:
00C7B9  2  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
00C7BA  2               
00C7BA  2               
00C7BA  2               
00C7BA  2               ;*__IDE_READ_INFO___________________________________________________________________________________
00C7BA  2               ;*
00C7BA  2               ;*  READ IDE INFORMATION
00C7BA  2               ;*	CARRY SET ON ERROR
00C7BA  2               ;* 	A=MST/SLV
00C7BA  2               ;*____________________________________________________________________________________________________
00C7BA  2               IDE_READ_INFO:
00C7BA  2  48                   PHA
00C7BB  2               ; SET DRIVE BIT
00C7BB  2  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
00C7BD  2  0A                   ASL     a               ; SHIFT 4
00C7BE  2  0A                   ASL     a               ;
00C7BF  2  0A                   ASL     a               ;
00C7C0  2  0A                   ASL     a               ;
00C7C1  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
00C7C3  2  AA                   TAX
00C7C4  2  A0 00                LDY     #$00
00C7C6  2  A9 0E                LDA     #PPIDE_DEVICE
00C7C8  2  20 15 CA             JSR     IDE_WRITE
00C7CB  2               
00C7CB  2               
00C7CB  2  20 FA C8             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C7CE  2  B0 4D                BCS     IDE_READ_INFO_ABORT
00C7D0  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
00C7D2  2  A2 EC                LDX     #PPIDE_CMD_ID
00C7D4  2  20 15 CA             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
00C7D7  2  20 26 C9             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
00C7DA  2  B0 41                BCS     IDE_READ_INFO_ABORT
00C7DC  2  20 5A C9             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
00C7DF  2  48 8A 48 98          PRTS    "0x$"
00C7E3  2  48 A2 00 BD  
00C7E7  2  FC C7 E8 C9  
00C7FF  2  AD 7B 02             LDA     hstbuf+123
00C802  2  20 61 C0             JSR     PRINT_BYTE
00C805  2  AD 7A 02             LDA     hstbuf+122
00C808  2  20 61 C0             JSR     PRINT_BYTE
00C80B  2  AD 79 02             LDA     hstbuf+121
00C80E  2  20 61 C0             JSR     PRINT_BYTE
00C811  2  AD 78 02             LDA     hstbuf+120
00C814  2  20 61 C0             JSR     PRINT_BYTE
00C817  2  20 00 C0             JSR     NEWLINE
00C81A  2  68                   PLA
00C81B  2  18                   CLC
00C81C  2  60                   RTS
00C81D  2               
00C81D  2               IDE_READ_INFO_ABORT:
00C81D  2  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT PRESENT
00C821  2  48 A2 00 BD  
00C825  2  3A C8 E8 C9  
00C847  2  20 00 C0             JSR     NEWLINE
00C84A  2  68                   PLA
00C84B  2  38                   SEC
00C84C  2  60                   RTS
00C84D  2               
00C84D  2               ;__IDE_PPIDETECT____________________________________________________________________________________
00C84D  2               ;
00C84D  2               ;  PROBE FOR PPI HARDWARE
00C84D  2               ;____________________________________________________________________________________________________
00C84D  2               ;
00C84D  2               IDE_PPIDETECT:
00C84D  2               ;
00C84D  2               ; TEST FOR PPI EXISTENCE
00C84D  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00C84D  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00C84D  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00C84D  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00C84D  2               ; INTERFERE WITH THE VALUE BEING READ.
00C84D  2  20 39 CA             JSR     SET_PPI_WR
00C850  2               ;
00C850  2  A9 00                LDA     #$00            ; VALUE ZERO
00C852  2  8D 20 E0             STA     PPIDELO         ; PUSH VALUE TO PORT
00C855  2  AD 20 E0             LDA     PPIDELO         ; GET PORT VALUE
00C858  2  C9 00                CMP     #$00
00C85A  2  60                   RTS                     ; AND RETURN
00C85B  2               ;
00C85B  2               
00C85B  2               
00C85B  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
00C85B  2               ;*
00C85B  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00C85B  2               ;*
00C85B  2               ;*____________________________________________________________________________________________________
00C85B  2               IDE_READ_SECTOR:
00C85B  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
00C85E  2  CD 15 05             CMP     Cdebsehd        ;
00C861  2  D0 13                BNE     IDE_READ_SECTOR_DIRTY
00C863  2  AD 11 05             LDA     debcylm         ;
00C866  2  CD 14 05             CMP     Cdebcylm        ;
00C869  2  D0 0B                BNE     IDE_READ_SECTOR_DIRTY
00C86B  2  AD 10 05             LDA     debcyll         ;
00C86E  2  CD 13 05             CMP     Cdebcyll        ;
00C871  2  D0 03                BNE     IDE_READ_SECTOR_DIRTY
00C873  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
00C875  2  60                   RTS
00C876  2               
00C876  2               IDE_READ_SECTOR_DIRTY:
00C876  2  20 FA C8             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C879  2  B0 27                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C87B  2               IDE_READ_SECTOR_DIRTY1:
00C87B  2  20 C6 C9             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
00C87E  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
00C880  2  A2 20                LDX     #PPIDE_CMD_READ
00C882  2  20 15 CA             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
00C885  2  20 26 C9             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
00C888  2  B0 18                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C88A  2  20 5A C9             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
00C88D  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
00C890  2  8D 15 05             STA     Cdebsehd        ;
00C893  2  AD 10 05             LDA     debcyll         ;
00C896  2  8D 13 05             STA     Cdebcyll        ;
00C899  2  AD 11 05             LDA     debcylm         ;
00C89C  2  8D 14 05             STA     Cdebcylm        ;
00C89F  2               
00C89F  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
00C8A1  2  60                   RTS
00C8A2  2               IDE_READ_SECTOR_DIRTY_ERROR:
00C8A2  2  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
00C8A4  2  60                   RTS
00C8A5  2               
00C8A5  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
00C8A5  2               ;*
00C8A5  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00C8A5  2               ;*
00C8A5  2               ;*____________________________________________________________________________________________________
00C8A5  2               IDE_WRITE_SECTOR:
00C8A5  2  20 FA C8             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
00C8A8  2  B0 25                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C8AA  2               IDE_WRITE_SECTOR_RAW:
00C8AA  2  20 C6 C9             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
00C8AD  2  A9 0F                LDA     #PPIDE_COMMAND
00C8AF  2  A2 30                LDX     #PPIDE_CMD_WRITE
00C8B1  2  20 15 CA             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
00C8B4  2  20 26 C9             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
00C8B7  2  B0 16                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C8B9  2  20 8F C9             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
00C8BC  2  20 FA C8             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
00C8BF  2  B0 0E                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
00C8C1  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
00C8C3  2  8D 15 05             STA     Cdebsehd        ;
00C8C6  2  8D 13 05             STA     Cdebcyll        ;
00C8C9  2  8D 14 05             STA     Cdebcylm        ;
00C8CC  2               
00C8CC  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
00C8CE  2  60                   RTS
00C8CF  2               IDE_WRITE_SECTOR_ERROR:
00C8CF  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
00C8D1  2  60                   RTS
00C8D2  2               
00C8D2  2               ;*__PPIDE_RESET____________________________________________________________________________________
00C8D2  2               ;*
00C8D2  2               ;*  SOFT RESET IDE CHANNEL
00C8D2  2               ;*
00C8D2  2               ;*____________________________________________________________________________________________________
00C8D2  2               PPIDE_RESET:
00C8D2  2  A9 00                LDA     #$00
00C8D4  2  8D 12 05             STA     debsehd
00C8D7  2  8D 10 05             STA     debcyll
00C8DA  2  8D 11 05             STA     debcylm
00C8DD  2  A9 FF                LDA     #$FF            ;
00C8DF  2  8D 15 05             STA     Cdebsehd        ;
00C8E2  2  8D 13 05             STA     Cdebcyll        ;
00C8E5  2  8D 14 05             STA     Cdebcylm        ;
00C8E8  2               
00C8E8  2  A9 80                LDA     #PPIDE_RST_LINE
00C8EA  2  8D 22 E0             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
00C8ED  2  A2 00                LDX     #$00
00C8EF  2               RST_DLY:
00C8EF  2  CA                   DEX
00C8F0  2  E0 00                CPX     #$00
00C8F2  2  D0 FB                BNE     RST_DLY
00C8F4  2  A9 00                LDA     #$00
00C8F6  2  8D 22 E0             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
00C8F9  2  60                   RTS
00C8FA  2               
00C8FA  2               
00C8FA  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
00C8FA  2               ;*
00C8FA  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
00C8FA  2               ;*
00C8FA  2               ;*____________________________________________________________________________________________________
00C8FA  2               IDE_WAIT_NOT_BUSY:
00C8FA  2  48                   PHA
00C8FB  2  8A                   TXA
00C8FC  2  48                   PHA
00C8FD  2  98                   TYA
00C8FE  2  48                   PHA
00C8FF  2  A9 00                LDA     #$00
00C901  2  8D 2F 05             STA     PPIDETIMEOUT
00C904  2  8D 30 05             STA     PPIDETIMEOUT+1
00C907  2               IDE_WAIT_NOT_BUSY1:
00C907  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
00C909  2  20 F9 C9             JSR     IDE_READ
00C90C  2  8A                   TXA
00C90D  2  29 80                AND     #$80
00C90F  2  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
00C911  2  EE 2F 05             INC     PPIDETIMEOUT
00C914  2  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
00C916  2  EE 30 05             INC     PPIDETIMEOUT+1
00C919  2  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
00C91B  2  38                   SEC
00C91C  2  4C 20 C9             JMP     IDE_WAIT_NOT_BUSY3
00C91F  2               IDE_WAIT_NOT_BUSY2:
00C91F  2  18                   CLC
00C920  2               IDE_WAIT_NOT_BUSY3:
00C920  2  68                   PLA
00C921  2  A8                   TAY
00C922  2  68                   PLA
00C923  2  AA                   TAX
00C924  2  68                   PLA
00C925  2  60                   RTS
00C926  2               
00C926  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
00C926  2               ;*
00C926  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
00C926  2               ;*
00C926  2               ;*____________________________________________________________________________________________________
00C926  2               IDE_WAIT_DRQ:
00C926  2  48                   PHA
00C927  2  8A                   TXA
00C928  2  48                   PHA
00C929  2  98                   TYA
00C92A  2  48                   PHA
00C92B  2  A9 00                LDA     #$00
00C92D  2  8D 2F 05             STA     PPIDETIMEOUT
00C930  2  8D 30 05             STA     PPIDETIMEOUT+1
00C933  2               IDE_WAIT_DRQ1:
00C933  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
00C935  2  20 F9 C9             JSR     IDE_READ
00C938  2  8A                   TXA
00C939  2  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
00C93B  2  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
00C93D  2  F0 14                BEQ     IDE_WAIT_DRQ2
00C93F  2  29 01                AND     #%00000001      ; IS ERROR?
00C941  2  C9 01                CMP     #%00000001      ;
00C943  2  F0 0A                BEQ     IDE_WAIT_DRQE
00C945  2  EE 2F 05             INC     PPIDETIMEOUT
00C948  2  D0 E9                BNE     IDE_WAIT_DRQ1
00C94A  2  EE 30 05             INC     PPIDETIMEOUT+1
00C94D  2  D0 E4                BNE     IDE_WAIT_DRQ1
00C94F  2               IDE_WAIT_DRQE:
00C94F  2  38                   SEC
00C950  2  4C 54 C9             JMP     IDE_WAIT_DRQ3
00C953  2               IDE_WAIT_DRQ2:
00C953  2  18                   CLC
00C954  2               IDE_WAIT_DRQ3:
00C954  2  68                   PLA
00C955  2  A8                   TAY
00C956  2  68                   PLA
00C957  2  AA                   TAX
00C958  2  68                   PLA
00C959  2  60                   RTS
00C95A  2               
00C95A  2               
00C95A  2               
00C95A  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
00C95A  2               ;*
00C95A  2               ;*  READ IDE BUFFER LITTLE ENDIAN
00C95A  2               ;*
00C95A  2               ;*____________________________________________________________________________________________________
00C95A  2               IDE_READ_BUFFER:
00C95A  2  A2 00                LDX     #$00            ; INDEX
00C95C  2               IDEBUFRD:
00C95C  2  8E 33 05             STX     PPIDEINDEX
00C95F  2  A9 08                LDA     #PPIDE_DATA
00C961  2  20 F9 C9             JSR     IDE_READ
00C964  2  8A                   TXA
00C965  2  AE 33 05             LDX     PPIDEINDEX
00C968  2  9D 00 02             STA     hstbuf,X        ;
00C96B  2  E8                   INX                     ;
00C96C  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
00C96D  2  9D 00 02             STA     hstbuf,X        ;
00C970  2  E8                   INX
00C971  2  E0 00                CPX     #$00            ;
00C973  2  D0 E7                BNE     IDEBUFRD        ;
00C975  2               IDEBUFRD1:
00C975  2  8E 33 05             STX     PPIDEINDEX
00C978  2  A9 08                LDA     #PPIDE_DATA
00C97A  2  20 F9 C9             JSR     IDE_READ
00C97D  2  8A                   TXA
00C97E  2  AE 33 05             LDX     PPIDEINDEX
00C981  2  9D 00 03             STA     hstbuf+256,X    ;
00C984  2  E8                   INX                     ;
00C985  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
00C986  2  9D 00 03             STA     hstbuf+256,X    ;
00C989  2  E8                   INX                     ;
00C98A  2  E0 00                CPX     #$00            ;
00C98C  2  D0 E7                BNE     IDEBUFRD1       ;
00C98E  2  60                   RTS                     ;
00C98F  2               
00C98F  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
00C98F  2               ;*
00C98F  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
00C98F  2               ;*
00C98F  2               ;*____________________________________________________________________________________________________
00C98F  2               IDE_WRITE_BUFFER:
00C98F  2  A2 00                LDX     #$00            ; INDEX
00C991  2               IDEBUFWT:
00C991  2  8E 33 05             STX     PPIDEINDEX
00C994  2  BD 01 02             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
00C997  2  A8                   TAY                     ;
00C998  2  BD 00 02             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
00C99B  2  AA                   TAX
00C99C  2  A9 08                LDA     #PPIDE_DATA
00C99E  2  20 15 CA             JSR     IDE_WRITE
00C9A1  2  AE 33 05             LDX     PPIDEINDEX
00C9A4  2  E8                   INX                     ;
00C9A5  2  E8                   INX                     ;
00C9A6  2  E0 00                CPX     #$00            ;
00C9A8  2  D0 E7                BNE     IDEBUFWT        ;
00C9AA  2  A2 00                LDX     #$00            ; INDEX
00C9AC  2               IDEBUFWT1:
00C9AC  2  8E 33 05             STX     PPIDEINDEX
00C9AF  2  BD 01 03             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
00C9B2  2  A8                   TAY
00C9B3  2  BD 00 03             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
00C9B6  2  AA                   TAX
00C9B7  2  A9 08                LDA     #PPIDE_DATA
00C9B9  2  20 15 CA             JSR     IDE_WRITE
00C9BC  2  AE 33 05             LDX     PPIDEINDEX
00C9BF  2  E8                   INX                     ;
00C9C0  2  E8                   INX                     ;
00C9C1  2  E0 00                CPX     #$00            ;
00C9C3  2  D0 E7                BNE     IDEBUFWT1       ;
00C9C5  2  60                   RTS                     ;
00C9C6  2               
00C9C6  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
00C9C6  2               ;*
00C9C6  2               ;*  SETUP LBA DATA
00C9C6  2               ;*  A= DRIVE DEVICE
00C9C6  2               ;*____________________________________________________________________________________________________
00C9C6  2               IDE_SETUP_LBA:
00C9C6  2  AD 34 05             LDA     CURRENT_IDE_DRIVE
00C9C9  2  29 01                AND     #$01            ; only want drive cfg
00C9CB  2  0A                   ASL     a               ; SHIFT 4
00C9CC  2  0A                   ASL     a               ;
00C9CD  2  0A                   ASL     a               ;
00C9CE  2  0A                   ASL     a               ;
00C9CF  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
00C9D1  2  AA                   TAX
00C9D2  2  A0 00                LDY     #$00
00C9D4  2  A9 0E                LDA     #PPIDE_DEVICE
00C9D6  2  20 15 CA             JSR     IDE_WRITE
00C9D9  2               
00C9D9  2  AE 11 05             LDX     debcylm
00C9DC  2  A9 0D                LDA     #PPIDE_LBAHI
00C9DE  2  20 15 CA             JSR     IDE_WRITE
00C9E1  2               
00C9E1  2  AE 10 05             LDX     debcyll         ;
00C9E4  2  A9 0C                LDA     #PPIDE_LBAMID
00C9E6  2  20 15 CA             JSR     IDE_WRITE
00C9E9  2               
00C9E9  2  AE 12 05             LDX     debsehd         ;
00C9EC  2  A9 0B                LDA     #PPIDE_LBALOW
00C9EE  2  20 15 CA             JSR     IDE_WRITE
00C9F1  2               
00C9F1  2  A2 01                LDX     #$01
00C9F3  2  A9 0A                LDA     #PPIDE_SEC_CNT
00C9F5  2  20 15 CA             JSR     IDE_WRITE
00C9F8  2               
00C9F8  2  60                   RTS
00C9F9  2               
00C9F9  2               
00C9F9  2               ;-------------------------------------------------------------------------------
00C9F9  2               
00C9F9  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
00C9F9  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
00C9F9  2               ; PROGRAM WOULD NOT CALL TO THESE.
00C9F9  2               
00C9F9  2               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
00C9F9  2               ;INPUT A = IDE REGSITER ADDRESS
00C9F9  2               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
00C9F9  2               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
00C9F9  2               
00C9F9  2               IDE_READ:
00C9F9  2  20 31 CA             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
00C9FC  2  8D 22 E0             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
00C9FF  2  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
00CA01  2  8D 22 E0             STA     PPIDECNTRL
00CA04  2  AE 20 E0             LDX     PPIDELO         ; READ LOWER BYTE
00CA07  2  AC 21 E0             LDY     PPIDEHI         ; READ UPPER BYTE
00CA0A  2  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
00CA0C  2  8D 22 E0             STA     PPIDECNTRL
00CA0F  2  A9 00                LDA     #$00
00CA11  2  8D 22 E0             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
00CA14  2  60                   RTS
00CA15  2               
00CA15  2               
00CA15  2               
00CA15  2               
00CA15  2               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
00CA15  2               ;INPUT A = IDE REGISTER ADDRESS
00CA15  2               ;INPUT REGISTER X = LSB TO WRITE
00CA15  2               ;INPUT REGISTER Y = MSB TO WRITE
00CA15  2               ;
00CA15  2               
00CA15  2               
00CA15  2               IDE_WRITE:
00CA15  2  20 39 CA             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
00CA18  2               
00CA18  2  8E 20 E0             STX     PPIDELO         ; WRITE LOWER BYTE
00CA1B  2  8C 21 E0             STY     PPIDEHI         ; WRITE UPPER BYTE
00CA1E  2               
00CA1E  2  8D 22 E0             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
00CA21  2               
00CA21  2  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
00CA23  2  8D 22 E0             STA     PPIDECNTRL
00CA26  2               
00CA26  2  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
00CA28  2  8D 22 E0             STA     PPIDECNTRL
00CA2B  2               
00CA2B  2  A9 00                LDA     #$00
00CA2D  2  8D 22 E0             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
00CA30  2  60                   RTS
00CA31  2               
00CA31  2               
00CA31  2               ;-----------------------------------------------------------------------------------
00CA31  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
00CA31  2               ;
00CA31  2               ;------------------------------------------------------------------------------------
00CA31  2               
00CA31  2               SET_PPI_RD:
00CA31  2  48                   PHA
00CA32  2  A9 92                LDA     #PPRD_IDE_8255
00CA34  2  8D 23 E0             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
00CA37  2  68                   PLA
00CA38  2  60                   RTS
00CA39  2               
00CA39  2               SET_PPI_WR:
00CA39  2  48                   PHA
00CA3A  2  A9 80                LDA     #PPWR_IDE_8255
00CA3C  2  8D 23 E0             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
00CA3F  2  68                   PLA
00CA40  2  60                   RTS
00CA41  2               
00CA41  1                       .INCLUDE "bios_console.asm"
00CA41  2               ;__CONSOLE_______________________________________________________________________________________________________________________
00CA41  2               ;
00CA41  2               ; 	CONSOLE DISPATCHER
00CA41  2               ;
00CA41  2               ;________________________________________________________________________________________________________________________________
00CA41  2               ;
00CA41  2               
00CA41  2               ;__DFT_CONSOLE___________________________________________________________________________________________________________________
00CA41  2               ;
00CA41  2               ;	      TRANSFER CONSOLE COMMAND TO DESIGNATED CONSOLE
00CA41  2               ;________________________________________________________________________________________________________________________________
00CA41  2               DFT_CONSOLE:
00CA41  2  48                   PHA
00CA42  2  A5 3A                LDA     CONSOLE
00CA44  2  18                   CLC
00CA45  2  65 32                ADC     farfunct
00CA47  2  85 32                STA     farfunct
00CA49  2  68                   PLA
00CA4A  2  4C 71 C0             JMP     FUNCTION_DISPATCHER
00CA4D  2               
00CA4D  1                       .INCLUDE "bios_rtc.asm"
00CA4D  2               
00CA4D  2               
00CA4D  2               ;__RTC DRIVERS___________________________________________________________________________________________________________________
00CA4D  2               ;
00CA4D  2               ; 	DOS REAL TIME CLOCK drivers
00CA4D  2               ;
00CA4D  2               ;	Entry points:
00CA4D  2               ;		DOSREADRTC   - called to RETURN RTC
00CA4D  2               ;________________________________________________________________________________________________________________________________
00CA4D  2               ;
00CA4D  2               ;*
00CA4D  2               ;* HARDWARE I/O ADDRESSES
00CA4D  2               ;*
00CA4D  2               RTCDDRD         = M6X0X_IOSPACE+$D02
00CA4D  2               RTCPORTD        = M6X0X_IOSPACE+$D00
00CA4D  2               
00CA4D  2               mask_data       = $20           ; RTC data line
00CA4D  2               mask_clk        = $40           ; RTC Serial Clock line
00CA4D  2               mask_ce         = $10           ; De-activate RTC reset line
00CA4D  2               
00CA4D  2               ;__RTC_WRITE____________________________________________________
00CA4D  2               ; write a value to the DS1302
00CA4D  2               ; address in X
00CA4D  2               ; value in Y
00CA4D  2               ;_______________________________________________________________
00CA4D  2               RTC_WRITE:
00CA4D  2  48                   PHA
00CA4E  2  78                   SEI                     ; disable interrupts during critical section
00CA4F  2  20 2F CB             JSR     RTC_RESET_OFF   ; turn off RTC reset
00CA52  2  8A                   TXA                     ; bring into A the address from D
00CA53  2  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
00CA55  2  18                   CLC
00CA56  2  0A                   ASL     A
00CA57  2  18                   CLC
00CA58  2  69 80                ADC     #%10000000      ; set MSB to one for DS1302 COMMAND BYTE (WRITE)
00CA5A  2  20 9F CA             JSR     RTC_WR          ; write address to DS1302
00CA5D  2  98                   TYA                     ; start processing value
00CA5E  2  20 9F CA             JSR     RTC_WR          ; write address to DS1302
00CA61  2  20 1E CB             JSR     RTC_RESET_ON    ; turn on RTC reset
00CA64  2  58                   CLI
00CA65  2  68                   PLA
00CA66  2  60                   RTS
00CA67  2               
00CA67  2               ;__RTC_READ______________________________________________________
00CA67  2               ; read a value from the DS1302
00CA67  2               ; address in X
00CA67  2               ; value in Y
00CA67  2               ;_______________________________________________________________
00CA67  2               RTC_READ:
00CA67  2  48                   PHA
00CA68  2  78                   SEI                     ; disable interrupts during critical section
00CA69  2  20 2F CB             JSR     RTC_RESET_OFF   ; turn off RTC reset
00CA6C  2  8A                   TXA                     ; bring into A the address from D
00CA6D  2  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
00CA6F  2  18                   CLC
00CA70  2  0A                   ASL     A               ; rotate address bits to the left
00CA71  2  18                   CLC
00CA72  2  69 81                ADC     #%10000001      ; set MSB to one for DS1302 COMMAND BYTE (READ)
00CA74  2  20 9F CA             JSR     RTC_WR          ; write address to DS1302
00CA77  2  20 D8 CA             JSR     RTC_RD          ; read value from DS1302 (value is in reg A)
00CA7A  2  A8                   TAY
00CA7B  2  20 1E CB             JSR     RTC_RESET_ON    ; turn on RTC reset
00CA7E  2  58                   CLI
00CA7F  2  68                   PLA
00CA80  2  60                   RTS
00CA81  2               
00CA81  2               ;_______________________________________________________________
00CA81  2               ; function RTC_RESET
00CA81  2               ;   Output a RTC reset signal
00CA81  2               ;_______________________________________________________________
00CA81  2               RTC_RESET:
00CA81  2  48                   PHA
00CA82  2  A9 70                LDA     #$70
00CA84  2  8D 02 ED             STA     RTCDDRD
00CA87  2  A9 20                LDA     #mask_data
00CA89  2  8D 00 ED             STA     RTCPORTD
00CA8C  2  20 11 CB             JSR     RTC_BIT_DELAY
00CA8F  2  20 11 CB             JSR     RTC_BIT_DELAY
00CA92  2  A9 30                LDA     #mask_data + mask_ce
00CA94  2  8D 00 ED             STA     RTCPORTD
00CA97  2  20 11 CB             JSR     RTC_BIT_DELAY
00CA9A  2  20 11 CB             JSR     RTC_BIT_DELAY
00CA9D  2  68                   PLA
00CA9E  2  60                   RTS
00CA9F  2               
00CA9F  2               ;_______________________________________________________________
00CA9F  2               ;
00CA9F  2               ; RTC Internal Functions
00CA9F  2               ;_______________________________________________________________
00CA9F  2               RTC_WR:
00CA9F  2  85 3D                STA     TEMPWORD1       ; save accumulator as it is the DATA
00CAA1  2  A9 70                LDA     #$70
00CAA3  2  8D 02 ED             STA     RTCDDRD
00CAA6  2  A2 00                LDX     #$00            ; set X index counter of FOR loop
00CAA8  2               RTC_WR1:
00CAA8  2  A5 3D                LDA     TEMPWORD1
00CAAA  2               
00CAAA  2  29 01                AND     #$01
00CAAC  2               
00CAAC  2  C9 00                CMP     #$00            ; is LSB a 0 or 1?
00CAAE  2  F0 10                BEQ     RTC_WR2         ; if its a 0, handle it at RTC_WR2.
00CAB0  2               ; LSB is a 1, handle it below
00CAB0  2               ; setup RTC latch with RST and DATA high, SCLK low
00CAB0  2  A9 30                LDA     #mask_ce + mask_data
00CAB2  2  8D 00 ED             STA     RTCPORTD
00CAB5  2  20 11 CB             JSR     RTC_BIT_DELAY   ; let it settle a while
00CAB8  2               ; setup RTC with RST, DATA, and SCLK high
00CAB8  2  A9 70                LDA     #mask_ce + mask_clk + mask_data
00CABA  2  8D 00 ED             STA     RTCPORTD
00CABD  2  4C CD CA             JMP     RTC_WR3         ; exit FOR loop
00CAC0  2               
00CAC0  2               RTC_WR2:
00CAC0  2               ; LSB is a 0, handle it below
00CAC0  2  A9 10                LDA     #mask_ce        ; setup RTC latch with RST high, SCLK and DATA low
00CAC2  2  8D 00 ED             STA     RTCPORTD        ; output to RTC latch
00CAC5  2  20 11 CB             JSR     RTC_BIT_DELAY   ; let it settle a while
00CAC8  2               ; setup RTC with RST and SCLK high, DATA low
00CAC8  2  A9 50                LDA     #mask_ce + mask_clk
00CACA  2  8D 00 ED             STA     RTCPORTD
00CACD  2               
00CACD  2               RTC_WR3:
00CACD  2  20 11 CB             JSR     RTC_BIT_DELAY   ; let it settle a while
00CAD0  2  46 3D                LSR     TEMPWORD1       ; move next bit into LSB position for processing to RTC
00CAD2  2  E8                   INX                     ; increment A in FOR loop (A=A+1)
00CAD3  2  E0 08                CPX     #$08            ; is A < $08 ?
00CAD5  2  D0 D1                BNE     RTC_WR1         ; No, do FOR loop again
00CAD7  2  60                   RTS                     ; Yes, end function and return
00CAD8  2               
00CAD8  2               
00CAD8  2               ; function RTC_RD
00CAD8  2               ; output value in A
00CAD8  2               ; uses X
00CAD8  2               RTC_RD:
00CAD8  2  A9 50                LDA     #$50
00CADA  2  8D 02 ED             STA     RTCDDRD
00CADD  2  A2 00                LDX     #$00            ; set X index counter of FOR loop
00CADF  2               
00CADF  2  A9 00                LDA     #$00            ; set A=0 output of RTC_RD is passed in A
00CAE1  2  85 3D                STA     TEMPWORD1
00CAE3  2  A9 01                LDA     #$01            ; mask value
00CAE5  2  85 3F                STA     TEMPWORD2
00CAE7  2               RTC_RD1:
00CAE7  2               ; setup RTC with RST and RD high, SCLK low
00CAE7  2  A9 10                LDA     #mask_ce
00CAE9  2  8D 00 ED             STA     RTCPORTD
00CAEC  2  20 11 CB             JSR     RTC_BIT_DELAY   ; let it settle a while
00CAEF  2  AD 00 ED             LDA     RTCPORTD        ; input from RTC latch
00CAF2  2  29 20                AND     #$20            ; is  0 or 1?
00CAF4  2  C9 00                CMP     #$00
00CAF6  2  F0 07                BEQ     RTC_RD2         ; if is a 0, handle it below
00CAF8  2  A5 3F                LDA     TEMPWORD2
00CAFA  2  18                   CLC
00CAFB  2  65 3D                ADC     TEMPWORD1
00CAFD  2  85 3D                STA     TEMPWORD1
00CAFF  2               ; if LSB is a 0, skip it (C=C+0)
00CAFF  2               RTC_RD2:
00CAFF  2  06 3F                ASL     TEMPWORD2       ; SHIFT MASK
00CB01  2  A9 50                LDA     #mask_ce + mask_clk
00CB03  2  8D 00 ED             STA     RTCPORTD
00CB06  2  20 11 CB             JSR     RTC_BIT_DELAY   ; let it settle
00CB09  2  E8                   INX                     ; increment FOR loop (A=A+1)
00CB0A  2  E0 08                CPX     #$08            ; is A < $08 ?
00CB0C  2  D0 D9                BNE     RTC_RD1         ; No, do FOR loop again
00CB0E  2  A5 3D                LDA     TEMPWORD1
00CB10  2  60                   RTS                     ; Yes, end function and return.  Read RTC value is in C
00CB11  2               
00CB11  2               RTC_BIT_DELAY:                  ; purpose is to delay ~36 uS
00CB11  2               ; (6) JSR INTO
00CB11  2  48                   PHA                     ; 3
00CB12  2  A9 02                LDA     #$02            ; 2  (1 REP AT 1 MHZ 6 REPS AT 2MHZ)
00CB14  2  85 3B                STA     TEMPWORD        ; 3
00CB16  2               RTC_BIT_DELAY1:
00CB16  2  C6 3B                DEC     TEMPWORD        ;5
00CB18  2  D0 FC                BNE     RTC_BIT_DELAY1  ;3
00CB1A  2               
00CB1A  2  EA                   NOP                     ; 2
00CB1B  2  EA                   NOP                     ; 2
00CB1C  2  68                   PLA                     ; 4
00CB1D  2  60                   RTS                     ; 6
00CB1E  2               
00CB1E  2               
00CB1E  2               
00CB1E  2               
00CB1E  2               ; function RTC_RESET_ON
00CB1E  2               ;  { Assert RTC reset signal }
00CB1E  2               RTC_RESET_ON:
00CB1E  2  A9 70                LDA     #$70
00CB20  2  8D 02 ED             STA     RTCDDRD
00CB23  2  A9 20                LDA     #mask_data
00CB25  2  8D 00 ED             STA     RTCPORTD
00CB28  2  20 11 CB             JSR     RTC_BIT_DELAY
00CB2B  2  20 11 CB             JSR     RTC_BIT_DELAY
00CB2E  2  60                   RTS
00CB2F  2               
00CB2F  2               ; function RTC_RESET_OFF
00CB2F  2               ;  { De-assert RTC reset signal }
00CB2F  2               RTC_RESET_OFF:
00CB2F  2  A9 70                LDA     #$70
00CB31  2  8D 02 ED             STA     RTCDDRD
00CB34  2  A9 30                LDA     #mask_data +  mask_ce
00CB36  2  8D 00 ED             STA     RTCPORTD
00CB39  2  20 11 CB             JSR     RTC_BIT_DELAY
00CB3C  2  20 11 CB             JSR     RTC_BIT_DELAY
00CB3F  2  60                   RTS
00CB40  2               
00CB40  1                       .IF     DSKY_OPTION=1
00CB40  1                           .INCLUDE "bios_dsky.asm"
00CB40  1                       .ENDIF
00CB40  1               
00CB40  1                       .IF     DSKY_OPTION=2
00CB40  1                           .INCLUDE "bios_dskyng.asm"
00CB40  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
00CB40  2               ;
00CB40  2               ; 	Nhyodyne DSKY/NG drivers
00CB40  2               ;
00CB40  2               ;	Entry points:
00CB40  2               ;               DSKY_INIT
00CB40  2               ;               DSKY_RESET
00CB40  2               ;               DSKY_SHOW
00CB40  2               ;               DSKY_BIN2SEG
00CB40  2               ;               DSKY_STAT
00CB40  2               ;               DSKY_GETKEY
00CB40  2               ;               DSKY_BEEP
00CB40  2               ;               DSKY_PUTLED
00CB40  2               ;               DSKY_BLANK
00CB40  2               ;               DSKY_DSPL
00CB40  2               ;________________________________________________________________________________________________________________________________
00CB40  2               ;
00CB40  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
00CB40  2               ;
00CB40  2               ; LED SEGMENTS (BIT VALUES)
00CB40  2               ;
00CB40  2               ;	+--01--+
00CB40  2               ;	20    02
00CB40  2               ;	+--40--+
00CB40  2               ;	10    04
00CB40  2               ;	+--08--+  80
00CB40  2               ;
00CB40  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
00CB40  2               ;                          ||||||||
00CB40  2               ;                          |||||+++-- ROW
00CB40  2               ;                          ||+++----- COL
00CB40  2               ;                          |+-------- SHIFT
00CB40  2               ;                          +--------- CONTROL
00CB40  2               ;
00CB40  2               ;	00	08	10	18	23
00CB40  2               ;	01	09	11	19	22
00CB40  2               ;	02	0A	12	1A	21
00CB40  2               ;	03	0B	13	1B	20
00CB40  2               ;	04	0C	14	1C	SHIFT
00CB40  2               ;	05	0D	15	1D	CTRL
00CB40  2               ;
00CB40  2               ; LED BIT MAP (BIT VALUES)
00CB40  2               ;
00CB40  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
00CB40  2               ;	---	---	---	---	---	---	---	---
00CB40  2               ;	01	01	01	01	01
00CB40  2               ;	02	02	02	02	02
00CB40  2               ;	04      04      04      04	04
00CB40  2               ;	08      08      08      08	08
00CB40  2               ;	10      10      10      10	10
00CB40  2               ;	20      20      20      20	20	L1	L2 	BUZZ
00CB40  2               ;
00CB40  2               DSKY_VIAA       = $ED00         ; PORT C
00CB40  2               DSKY_VIAB       = $EC00         ; PORT A & B
00CB40  2               DSKY_PPIA       = DSKY_VIAB + 1 ; PORT A
00CB40  2               DSKY_PPIC       = DSKY_VIAA + 1 ; PORT C
00CB40  2               DSKY_PPIA_C     = DSKY_VIAB + 3 ; PORT A DDR
00CB40  2               DSKY_PPIC_C     = DSKY_VIAA + 3 ; PORT C DDR
00CB40  2               
00CB40  2               ;
00CB40  2               ; PIO CHANNEL C:
00CB40  2               ;
00CB40  2               ;	7	6	5	4	3	2	1	0
00CB40  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
00CB40  2               ;
00CB40  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
00CB40  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
00CB40  2               ;
00CB40  2               DSKY_PPI_IDLE   = %00000110
00CB40  2               ;
00CB40  2               DSKY_CMD_CLR    = %11011111     ; CLEAR (ALL OFF)
00CB40  2               DSKY_CMD_CLRX   = %11010011     ; CLEAR (ALL ON)
00CB40  2               DSKY_CMD_WDSP   = %10010000     ; WRITE DISPLAY RAM
00CB40  2               DSKY_CMD_RDSP   = %01110000     ; READ DISPLAY RAM
00CB40  2               DSKY_CMD_CLK    = %00100000     ; SET CLK PRESCALE
00CB40  2               DSKY_CMD_FIFO   = %01000000     ; READ FIFO
00CB40  2               ;
00CB40  2               DSKY_PRESCL     = DSKYOSC/100000; PRESCALER
00CB40  2               ;
00CB40  2               ;__DSKY_INIT_________________________________________________________________________________________
00CB40  2               ;
00CB40  2               ;  DISPLAY DSKY INFO
00CB40  2               ;____________________________________________________________________________________________________
00CB40  2               ;
00CB40  2               DSKY_INIT:
00CB40  2  20 3B CC             JSR     DSKY_PREINIT
00CB43  2  48 8A 48 98          PRTS    "DSKY:$"
00CB47  2  48 A2 00 BD  
00CB4B  2  60 CB E8 C9  
00CB66  2  20 00 C0             JSR     NEWLINE
00CB69  2               
00CB69  2               ;
00CB69  2  48 8A 48 98          PRTS    " IO=0x$"
00CB6D  2  48 A2 00 BD  
00CB71  2  86 CB E8 C9  
00CB8D  2  A9 ED                LDA     #>DSKY_VIAA     ; GET BASE PORT
00CB8F  2  20 61 C0             JSR     PRINT_BYTE
00CB92  2  A9 00                LDA     #<DSKY_VIAA     ; GET BASE PORT
00CB94  2  20 61 C0             JSR     PRINT_BYTE
00CB97  2  48 8A 48 98          PRTS    " & $"
00CB9B  2  48 A2 00 BD  
00CB9F  2  B4 CB E8 C9  
00CBB8  2  A9 EC                LDA     #>DSKY_VIAB     ; GET BASE PORT
00CBBA  2  20 61 C0             JSR     PRINT_BYTE
00CBBD  2  A9 00                LDA     #<DSKY_VIAB     ; GET BASE PORT
00CBBF  2  20 61 C0             JSR     PRINT_BYTE
00CBC2  2               
00CBC2  2  48 8A 48 98          PRTS    " MODE=$"
00CBC6  2  48 A2 00 BD  
00CBCA  2  DF CB E8 C9  
00CBE6  2  48 8A 48 98          PRTS    "NG$"           ; PRINT DSKY TYPE
00CBEA  2  48 A2 00 BD  
00CBEE  2  03 CC E8 C9  
00CC06  2               ;
00CC06  2  AD 39 05             LDA     DSKY_PRESENT    ; PRESENT?
00CC09  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CC0B  2  F0 2A                BEQ     DSKY_INITA
00CC0D  2  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT PRESENT
00CC11  2  48 A2 00 BD  
00CC15  2  2A CC E8 C9  
00CC37  2               DSKY_INITA:
00CC37  2  20 00 C0             JSR     NEWLINE
00CC3A  2  60                   RTS                     ; DONE
00CC3B  2               ;
00CC3B  2               ;__DSKY_PREINIT______________________________________________________________________________________
00CC3B  2               ;
00CC3B  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00CC3B  2               ;____________________________________________________________________________________________________
00CC3B  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00CC3B  2               DSKY_PREINIT:
00CC3B  2               ; SETUP PPI TO DEFAULT MODE
00CC3B  2  20 56 CE             JSR     DSKY_PPIRD
00CC3E  2               
00CC3E  2               ; INIT 8279 VALUES TO IDLE STATE
00CC3E  2  A9 06                LDA     #DSKY_PPI_IDLE
00CC40  2  8D 01 ED             STA     DSKY_PPIC
00CC43  2               ; PULSE RESET SIGNAL ON 8279
00CC43  2  09 80                ORA     #%10000000
00CC45  2  8D 01 ED             STA     DSKY_PPIC
00CC48  2  29 7F                AND     #%01111111
00CC4A  2  8D 01 ED             STA     DSKY_PPIC
00CC4D  2               ; INITIALIZE 8279
00CC4D  2  20 66 CC             JSR     DSKY_REINIT
00CC50  2               ; NOW SEE IF A DSKYNG IS REALLY THERE...
00CC50  2  A9 A5                LDA     #$A5
00CC52  2  A0 00                LDY     #$00
00CC54  2  20 B9 CD             JSR     DSKY_PUTBYTE
00CC57  2  A0 00                LDY     #$00
00CC59  2  20 D1 CD             JSR     DSKY_GETBYTE
00CC5C  2  C9 A5                CMP     #$A5
00CC5E  2  D0 05                BNE     DSKY_ABORT      ; BAIL OUT IF MISCOMPARE
00CC60  2  A9 FF                LDA     #$FF
00CC62  2  8D 39 05             STA     DSKY_PRESENT
00CC65  2               DSKY_ABORT:
00CC65  2  60                   RTS
00CC66  2               ;
00CC66  2               DSKY_REINIT:
00CC66  2  20 56 CE             JSR     DSKY_PPIIDLE
00CC69  2               ; SET CLOCK SCALER TO 20
00CC69  2  A9 2A                LDA     #DSKY_CMD_CLK | DSKY_PRESCL
00CC6B  2  20 39 CD             JSR     DSKY_CMD
00CC6E  2               ; FALL THRU
00CC6E  2               ;
00CC6E  2               DSKY_RESET:
00CC6E  2               ; RESET DSKY -- CLEAR RAM AND FIFO
00CC6E  2  A9 DF                LDA     #DSKY_CMD_CLR
00CC70  2  20 39 CD             JSR     DSKY_CMD
00CC73  2               ;
00CC73  2               ; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
00CC73  2               ; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
00CC73  2               ; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
00CC73  2               ; IS USED TO IMPLEMENT A TIMEOUT.
00CC73  2  A2 00                LDX     #0              ; TIMEOUT LOOP COUNTER
00CC75  2               DSKY_RESET1:
00CC75  2  48                   PHA                     ; SAVE COUNTER
00CC76  2  68                   PLA                     ; RECOVER COUNTER
00CC77  2  CA                   DEX
00CC78  2  D0 FB                BNE     DSKY_RESET1     ; LOOP TILL TIMEOUT
00CC7A  2               ;
00CC7A  2               DSKY_RESET2:
00CC7A  2  60                   RTS
00CC7B  2               ;
00CC7B  2               ;
00CC7B  2               ;
00CC7B  2               
00CC7B  2               ;
00CC7B  2               ;
00CC7B  2               KY_0            = $00
00CC7B  2               KY_1            = $01
00CC7B  2               KY_2            = $02
00CC7B  2               KY_3            = $03
00CC7B  2               KY_4            = $04
00CC7B  2               KY_5            = $05
00CC7B  2               KY_6            = $06
00CC7B  2               KY_7            = $07
00CC7B  2               KY_8            = $08
00CC7B  2               KY_9            = $09
00CC7B  2               KY_A            = $0A
00CC7B  2               KY_B            = $0B
00CC7B  2               KY_C            = $0C
00CC7B  2               KY_D            = $0D
00CC7B  2               KY_E            = $0E
00CC7B  2               KY_F            = $0F
00CC7B  2               KY_FW           = $10           ; FORWARD
00CC7B  2               KY_BK           = $11           ; BACKWARD
00CC7B  2               KY_CL           = $12           ; CLEAR
00CC7B  2               KY_EN           = $13           ; ENTER
00CC7B  2               KY_DE           = $14           ; DEPOSIT
00CC7B  2               KY_EX           = $15           ; EXAMINE
00CC7B  2               KY_GO           = $16           ; GO
00CC7B  2               KY_BO           = $17           ; BOOT
00CC7B  2               KY_F4           = $18           ; F4
00CC7B  2               KY_F3           = $19           ; F3
00CC7B  2               KY_F2           = $20           ; F2
00CC7B  2               KY_F1           = $21           ; F1
00CC7B  2               ;
00CC7B  2               ;__DSKY_STAT_________________________________________________________________________________________
00CC7B  2               ;
00CC7B  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
00CC7B  2               ;____________________________________________________________________________________________________
00CC7B  2               ;
00CC7B  2               DSKY_STAT:
00CC7B  2  AD 39 05             LDA     DSKY_PRESENT    ; DOES IT EXIST?
00CC7E  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CC80  2  D0 05                BNE     DSKY_STATA      ; ABORT WITH A=0 IF NOT THERE
00CC82  2  20 72 CD             JSR     DSKY_ST
00CC85  2  29 0F                AND     #$0F            ; ISOLATE THE CUR FIFO LEN
00CC87  2               DSKY_STATA:
00CC87  2  60                   RTS
00CC88  2               ;
00CC88  2               ;__DSKY_GETKEY_____________________________________________________________________________________
00CC88  2               ;
00CC88  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
00CC88  2               ;____________________________________________________________________________________________________
00CC88  2               ;
00CC88  2               DSKY_GETKEY:
00CC88  2  AD 39 05             LDA     DSKY_PRESENT    ; DOES IT EXIST?
00CC8B  2  C9 FF                CMP     #$FF            ; SET FLAGS
00CC8D  2  D0 24                BNE     DSKY_GETKEY1A   ; ABORT WITH A=0 IF NOT THERE
00CC8F  2  20 7B CC             JSR     DSKY_STAT
00CC92  2  F0 F4                BEQ     DSKY_GETKEY     ; LOOP IF NOTHING THERE
00CC94  2  A9 40                LDA     #DSKY_CMD_FIFO
00CC96  2  20 39 CD             JSR     DSKY_CMD
00CC99  2  20 77 CD             JSR     DSKY_DIN
00CC9C  2  49 C0                EOR     #%11000000      ; FLIP POLARITY OF SHIFT/CTL BITS
00CC9E  2  48                   PHA
00CC9F  2  29 3F                AND     #$3F            ; STRIP SHIFT/CTL BITS FOR LOOKUP
00CCA1  2  8D 37 05             STA     DSKY_TEMP_VAL
00CCA4  2  A2 00                LDX     #0              ; INDEX
00CCA6  2               DSKY_GETKEY1:
00CCA6  2  BD C2 CC             LDA     DSKY_KEYMAP,X
00CCA9  2  CD 37 05             CMP     DSKY_TEMP_VAL   ; MATCH?
00CCAC  2  F0 09                BEQ     DSKY_GETKEY2    ; FOUND, DONE
00CCAE  2  E8                   INX
00CCAF  2  E0 1C                CPX     #28
00CCB1  2  D0 F3                BNE     DSKY_GETKEY1    ; LOOP UNTIL EOT
00CCB3  2               DSKY_GETKEY1A:
00CCB3  2  68                   PLA
00CCB4  2  A9 FF                LDA     #$FF            ; NOT FOUND ERR, RETURN $FF
00CCB6  2  60                   RTS
00CCB7  2               DSKY_GETKEY2:
00CCB7  2               ; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
00CCB7  2               ; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
00CCB7  2  68                   PLA                     ; RESTORE RAW VALUE
00CCB8  2  25 C0                AND     %11000000       ; ISOLATE SHIFT/CTRL BITS
00CCBA  2  8D 37 05             STA     DSKY_TEMP_VAL
00CCBD  2  8A                   TXA
00CCBE  2  0D 37 05             ORA     DSKY_TEMP_VAL   ; COMBINE WITH INDEX VALUE
00CCC1  2  60                   RTS
00CCC2  2               ;
00CCC2  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
00CCC2  2               ;
00CCC2  2               DSKY_KEYMAP:
00CCC2  2               ; POS	$00  $01  $02  $03  $04  $05  $06  $07
00CCC2  2               ; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
00CCC2  2  0D 04 0C 14          .BYTE   $0D, $04, $0C, $14, $03, $0B, $13, $02
00CCC6  2  03 0B 13 02  
00CCCA  2               ;
00CCCA  2               ; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
00CCCA  2               ; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
00CCCA  2  0A 12 01 09          .BYTE   $0A, $12, $01, $09, $11, $00, $08, $10
00CCCE  2  11 00 08 10  
00CCD2  2               ;
00CCD2  2               ; POS	$10  $11  $12  $13  $14  $15  $16  $17
00CCD2  2               ; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
00CCD2  2  05 15 1D 1C          .BYTE   $05, $15, $1D, $1C, $1B, $1A, $19, $18
00CCD6  2  1B 1A 19 18  
00CCDA  2               
00CCDA  2               ; POS	$18  $19  $20  $21
00CCDA  2               ; KEY   [F4] [F3] [F2] [F1]
00CCDA  2  23 22 21 20          .BYTE   $23, $22, $21, $20
00CCDE  2               
00CCDE  2               ;
00CCDE  2               ;
00CCDE  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
00CCDE  2               ;
00CCDE  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
00CCDE  2               ;
00CCDE  2               ; DSKY_BUF: 32 BIT BINARY
00CCDE  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
00CCDE  2               ;____________________________________________________________________________________________________
00CCDE  2               ;
00CCDE  2               DSKY_BIN2SEG:
00CCDE  2  A2 00                LDX     #$00
00CCE0  2               DSKY_BIN2SEG1:
00CCE0  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; FIRST NIBBLE
00CCE3  2  4A                   LSR     A
00CCE4  2  4A                   LSR     A
00CCE5  2  4A                   LSR     A
00CCE6  2  4A                   LSR     A
00CCE7  2  8E 35 05             STX     DSKY_X_STORAGE  ; STORE READ INDEX
00CCEA  2  AA                   TAX                     ; MOVE DIGIT TO LOOKUP INDEX
00CCEB  2  BD 63 CE             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
00CCEE  2  AE 35 05             LDX     DSKY_X_STORAGE  ; GET READ INDEX
00CCF1  2  48                   PHA
00CCF2  2  8A                   TXA
00CCF3  2  0A                   ASL     a
00CCF4  2  AA                   TAX
00CCF5  2  68                   PLA
00CCF6  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00CCF9  2  AE 35 05             LDX     DSKY_X_STORAGE
00CCFC  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; SECOND NIBBLE
00CCFF  2               
00CCFF  2  29 0F                AND     #$0F
00CD01  2  8E 35 05             STX     DSKY_X_STORAGE  ; STORE READ INDEX
00CD04  2  AA                   TAX
00CD05  2  BD 63 CE             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
00CD08  2  AE 35 05             LDX     DSKY_X_STORAGE  ; GET READ INDEX
00CD0B  2  48                   PHA
00CD0C  2  8A                   TXA                     ; GET READ INDEX
00CD0D  2  0A                   ASL     a
00CD0E  2  AA                   TAX
00CD0F  2  E8                   INX
00CD10  2  68                   PLA
00CD11  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00CD14  2  AE 35 05             LDX     DSKY_X_STORAGE  ; GET READ INDEX
00CD17  2  E8                   INX
00CD18  2  E0 04                CPX     #4
00CD1A  2  D0 C4                BNE     DSKY_BIN2SEG1
00CD1C  2  60                   RTS
00CD1D  2               ;
00CD1D  2               ;__DSKY_SHOW___________________________________________________________________________________________
00CD1D  2               ; DSKY SHOW BUFFER
00CD1D  2               ;______________________________________________________________________________________________________
00CD1D  2               ;
00CD1D  2               DSKY_SHOW:
00CD1D  2  48                   PHA
00CD1E  2  8A                   TXA
00CD1F  2  48                   PHA
00CD20  2  98                   TYA
00CD21  2  48                   PHA
00CD22  2  A2 00                LDX     #0
00CD24  2               DSKY_SHOW1:
00CD24  2  BD 00 05             LDA     DSKY_BUF,X
00CD27  2  48                   PHA
00CD28  2  8A                   TXA
00CD29  2  A8                   TAY
00CD2A  2  68                   PLA
00CD2B  2  20 B9 CD             JSR     DSKY_PUTBYTE
00CD2E  2  E8                   INX
00CD2F  2  E0 08                CPX     #8
00CD31  2  D0 F1                BNE     DSKY_SHOW1
00CD33  2  68                   PLA
00CD34  2  A8                   TAY
00CD35  2  68                   PLA
00CD36  2  AA                   TAX
00CD37  2  68                   PLA
00CD38  2  60                   RTS
00CD39  2               
00CD39  2               ;______________________________________________________________________________________________________
00CD39  2               ; DSKYNG OUTPUT ROUTINES
00CD39  2               ;______________________________________________________________________________________________________
00CD39  2               
00CD39  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
00CD39  2               DSKY_CMD:
00CD39  2  48                   PHA
00CD3A  2  A9 01                LDA     #$01
00CD3C  2  4C 42 CD             JMP     DSKY_DOUT2
00CD3F  2               ;
00CD3F  2               ; SEND DSKY DATA BYTE IN REGISTER A
00CD3F  2               ; TRASHES BC
00CD3F  2               ;
00CD3F  2               DSKY_DOUT:
00CD3F  2  48                   PHA
00CD40  2  A9 00                LDA     #$00
00CD42  2               ;
00CD42  2               DSKY_DOUT2:
00CD42  2               ; SET PPI LINE CONFIG TO WRITE MODE
00CD42  2  20 49 CE             JSR     DSKY_PPIWR
00CD45  2               ;
00CD45  2               ; SET ADDRESS FIRST
00CD45  2  09 06                ORA     #DSKY_PPI_IDLE
00CD47  2  8D 01 ED             STA     DSKY_PPIC
00CD4A  2               ;
00CD4A  2               ; ASSERT 8279 /CS
00CD4A  2  09 18                ORA     #%00011000
00CD4C  2  8D 01 ED             STA     DSKY_PPIC
00CD4F  2               ;
00CD4F  2               ; PPIC WORKING VALUE TO DSKY_TEMP_VAL
00CD4F  2  8D 37 05             STA     DSKY_TEMP_VAL
00CD52  2               ;
00CD52  2               ; ASSERT DATA BYTE VALUE
00CD52  2  68                   PLA
00CD53  2  8D 01 EC             STA     DSKY_PPIA
00CD56  2               ;
00CD56  2               ; PULSE /WR
00CD56  2  AD 37 05             LDA     DSKY_TEMP_VAL
00CD59  2  29 FD                AND     #%11111101
00CD5B  2  8D 01 ED             STA     DSKY_PPIC
00CD5E  2  EA                   NOP                     ; MAY NOT BE NEEDED
00CD5F  2  09 02                ORA     #%00000010
00CD61  2  8D 01 ED             STA     DSKY_PPIC
00CD64  2               ;
00CD64  2               ; DEASSERT /CS
00CD64  2  29 E7                AND     #%11100111
00CD66  2  8D 01 ED             STA     DSKY_PPIC
00CD69  2               ;
00CD69  2               ; CLEAR ADDRESS BIT
00CD69  2  29 E6                AND     #%11100110
00CD6B  2  8D 01 ED             STA     DSKY_PPIC
00CD6E  2               ;
00CD6E  2               ; DONE
00CD6E  2  20 56 CE             JSR     DSKY_PPIIDLE
00CD71  2  60                   RTS
00CD72  2               ;
00CD72  2               ;==================================================================================================
00CD72  2               ; DSKYNG OUTPUT ROUTINES
00CD72  2               ;==================================================================================================
00CD72  2               ;
00CD72  2               ; RETURN DSKY STATUS VALUE IN A
00CD72  2               ;
00CD72  2               DSKY_ST:
00CD72  2  A9 01                LDA     #$01
00CD74  2  4C 79 CD             JMP     DSKY_DIN2
00CD77  2               ;
00CD77  2               ; RETURN NEXT DATA VALUE IN A
00CD77  2               ;
00CD77  2               DSKY_DIN:
00CD77  2  A9 00                LDA     #$00
00CD79  2               ;
00CD79  2               DSKY_DIN2:
00CD79  2               ; SET PPI LINE CONFIG TO READ MODE
00CD79  2  20 56 CE             JSR     DSKY_PPIRD
00CD7C  2               ;
00CD7C  2               ; SET ADDRESS FIRST
00CD7C  2  09 06                ORA     #DSKY_PPI_IDLE
00CD7E  2  8D 01 ED             STA     DSKY_PPIC
00CD81  2               ;
00CD81  2               ; ASSERT 8279 /CS
00CD81  2  09 18                ORA     #%00011000
00CD83  2  8D 01 ED             STA     DSKY_PPIC
00CD86  2               ;
00CD86  2               ; ASSERT /RD
00CD86  2  29 7B                AND     #%01111011
00CD88  2  8D 01 ED             STA     DSKY_PPIC
00CD8B  2               ;
00CD8B  2  8D 37 05             STA     DSKY_TEMP_VAL
00CD8E  2               ; GET VALUE
00CD8E  2  AD 01 EC             LDA     DSKY_PPIA
00CD91  2  48                   PHA
00CD92  2               
00CD92  2  AD 37 05             LDA     DSKY_TEMP_VAL
00CD95  2               ; DEASSERT /RD
00CD95  2  09 04                ORA     #%00000100
00CD97  2  8D 01 ED             STA     DSKY_PPIC
00CD9A  2               ;
00CD9A  2               ; DEASSERT /CS
00CD9A  2  29 E7                AND     #%11100111
00CD9C  2  8D 01 ED             STA     DSKY_PPIC
00CD9F  2               ;
00CD9F  2               ; CLEAR ADDRESS BIT
00CD9F  2  29 E6                AND     #%11100110
00CDA1  2  8D 01 ED             STA     DSKY_PPIC
00CDA4  2               ;
00CDA4  2               ; DONE
00CDA4  2  20 56 CE             JSR     DSKY_PPIIDLE
00CDA7  2  68                   PLA
00CDA8  2  60                   RTS
00CDA9  2               
00CDA9  2               ;__DSKY_BLANK_____________________________________________________________________________________
00CDA9  2               ;
00CDA9  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
00CDA9  2               ;
00CDA9  2               ;_________________________________________________________________________________________________
00CDA9  2               ;
00CDA9  2               DSKY_BLANK:
00CDA9  2  A9 90                LDA     #DSKY_CMD_WDSP
00CDAB  2  20 39 CD             JSR     DSKY_CMD
00CDAE  2  A2 10                LDX     #16
00CDB0  2               DSKY_BLANK1:
00CDB0  2  A9 FF                LDA     #$FF
00CDB2  2  20 3F CD             JSR     DSKY_DOUT
00CDB5  2  CA                   DEX
00CDB6  2  D0 F8                BNE     DSKY_BLANK1
00CDB8  2  60                   RTS
00CDB9  2               ;
00CDB9  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
00CDB9  2               ;
00CDB9  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
00CDB9  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
00CDB9  2               ;
00CDB9  2               ;__________________________________________________________________________________________________
00CDB9  2               ;
00CDB9  2               DSKY_PUTBYTE:
00CDB9  2  8C 36 05             STY     DSKY_Y_STORAGE
00CDBC  2  48                   PHA
00CDBD  2  48                   PHA
00CDBE  2  18                   CLC
00CDBF  2  98                   TYA
00CDC0  2  69 90                ADC     #DSKY_CMD_WDSP
00CDC2  2  A8                   TAY
00CDC3  2  20 39 CD             JSR     DSKY_CMD
00CDC6  2  68                   PLA
00CDC7  2  49 FF                EOR     #$FF
00CDC9  2  20 3F CD             JSR     DSKY_DOUT
00CDCC  2  68                   PLA
00CDCD  2  AC 36 05             LDY     DSKY_Y_STORAGE
00CDD0  2  60                   RTS
00CDD1  2               ;
00CDD1  2               ;__DSKY_GETBYTE___________________________________________________________________________________
00CDD1  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
00CDD1  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
00CDD1  2               ;
00CDD1  2               ;_________________________________________________________________________________________________
00CDD1  2               ;
00CDD1  2               DSKY_GETBYTE:
00CDD1  2  18                   CLC
00CDD2  2  98                   TYA
00CDD3  2  69 70                ADC     #DSKY_CMD_RDSP
00CDD5  2  A8                   TAY
00CDD6  2  20 39 CD             JSR     DSKY_CMD
00CDD9  2  20 77 CD             JSR     DSKY_DIN
00CDDC  2  49 FF                EOR     #$FF
00CDDE  2  60                   RTS
00CDDF  2               
00CDDF  2               ;
00CDDF  2               ;__DSKY_PUTLED____________________________________________________________________________________
00CDDF  2               ;
00CDDF  2               ;	This function is intended to update the LEDs.
00CDDF  2               ;	VALUES SHOULD BE IN DSKY_BUF
00CDDF  2               ;_________________________________________________________________________________________________
00CDDF  2               ;
00CDDF  2               DSKY_PUTLED:
00CDDF  2  48                   PHA
00CDE0  2  8A                   TXA
00CDE1  2  48                   PHA
00CDE2  2  98                   TYA
00CDE3  2  48                   PHA
00CDE4  2  A0 00                LDY     #$00
00CDE6  2  A2 00                LDX     #$00
00CDE8  2               DSKY_PUTLED_1:
00CDE8  2  BD 00 05             LDA     DSKY_BUF,X      ; GET BYTE
00CDEB  2  20 B9 CD             JSR     DSKY_PUTBYTE    ; SEND IT TO DSKY
00CDEE  2  C8                   INY                     ; LOOP TIL DONE
00CDEF  2  E8                   INX
00CDF0  2  C0 08                CPY     #8
00CDF2  2  D0 F4                BNE     DSKY_PUTLED_1
00CDF4  2  68                   PLA                     ; RESTORE REGISTERS
00CDF5  2  A8                   TAY
00CDF6  2  68                   PLA
00CDF7  2  AA                   TAX
00CDF8  2  68                   PLA
00CDF9  2  60                   RTS
00CDFA  2               ;
00CDFA  2               ;__DSKY_BEEP______________________________________________________________________________________
00CDFA  2               ;	This function is intended to beep the speaker on the DSKY
00CDFA  2               ;_________________________________________________________________________________________________
00CDFA  2               ;
00CDFA  2               DSKY_BEEP:
00CDFA  2  48                   PHA
00CDFB  2  8A                   TXA
00CDFC  2  48                   PHA
00CDFD  2  98                   TYA
00CDFE  2  48                   PHA
00CDFF  2  A0 0F                LDY     #$0F
00CE01  2  20 D1 CD             JSR     DSKY_GETBYTE
00CE04  2  09 20                ORA     #$20
00CE06  2  A9 20                LDA     #$20
00CE08  2  A0 0F                LDY     #$0F
00CE0A  2  20 B9 CD             JSR     DSKY_PUTBYTE
00CE0D  2               
00CE0D  2               ;;; 	timer . . .
00CE0D  2  A2 8F                LDX     #$8F
00CE0F  2  A0 FF                LDY     #$FF
00CE11  2               DSKY_BEEP1:
00CE11  2  88                   DEY
00CE12  2  D0 FD                BNE     DSKY_BEEP1
00CE14  2  CA                   DEX
00CE15  2  D0 FA                BNE     DSKY_BEEP1
00CE17  2               
00CE17  2  A0 0F                LDY     #$0F
00CE19  2  20 D1 CD             JSR     DSKY_GETBYTE
00CE1C  2  29 DF                AND     #$DF
00CE1E  2  A9 DF                LDA     #$DF
00CE20  2  A0 0F                LDY     #$0F
00CE22  2  20 B9 CD             JSR     DSKY_PUTBYTE
00CE25  2               
00CE25  2  68                   PLA                     ; RESTORE REGISTERS
00CE26  2  A8                   TAY
00CE27  2  68                   PLA
00CE28  2  AA                   TAX
00CE29  2  68                   PLA
00CE2A  2  60                   RTS
00CE2B  2               ;
00CE2B  2               ;__ODSKY_DSPL______________________________________________________________________________________
00CE2B  2               ;
00CE2B  2               ;	This function is intended to turn on or off the DSKY L1 & L2 leds
00CE2B  2               ;
00CE2B  2               ;   A= LED# (0 or 1)
00CE2B  2               ;   X= On(1) or Off(0)
00CE2B  2               ;_________________________________________________________________________________________________
00CE2B  2               ;
00CE2B  2               DSKY_DSPL:
00CE2B  2  8C 36 05             STY     DSKY_Y_STORAGE
00CE2E  2  18                   CLC
00CE2F  2  29 01                AND     #$01
00CE31  2  69 0D                ADC     #$0D
00CE33  2  A8                   TAY
00CE34  2  20 D1 CD             JSR     DSKY_GETBYTE
00CE37  2  E0 00                CPX     #$00
00CE39  2  F0 05                BEQ     :+
00CE3B  2  09 20                ORA     #$20
00CE3D  2  4C 42 CE             JMP     DSKY_DSPL_1
00CE40  2               :
00CE40  2  29 DF                AND     #$DF
00CE42  2               DSKY_DSPL_1:
00CE42  2  20 B9 CD             JSR     DSKY_PUTBYTE
00CE45  2  AC 36 05             LDY     DSKY_Y_STORAGE
00CE48  2  60                   RTS
00CE49  2               
00CE49  2               ;
00CE49  2               ;_________________________________________________________________________________________________
00CE49  2               ; DSKYNG LINE CONTROL ROUTINES
00CE49  2               ;
00CE49  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
00CE49  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
00CE49  2               ;
00CE49  2               ;_________________________________________________________________________________________________
00CE49  2               ;
00CE49  2               DSKY_PPIWR:
00CE49  2  48                   PHA
00CE4A  2               ;
00CE4A  2               ; PLACE PORT A BITS 0-7 IN OUT MODE
00CE4A  2  A9 FF                LDA     #$FF
00CE4C  2  8D 03 EC             STA     DSKY_PPIA_C
00CE4F  2               ;
00CE4F  2               ; PLACE PORT C BITS 0-4 & 7 IN OUT MODE
00CE4F  2  A9 9F                LDA     #$9F
00CE51  2  8D 03 ED             STA     DSKY_PPIC_C
00CE54  2               ;
00CE54  2  68                   PLA
00CE55  2  60                   RTS
00CE56  2               ;
00CE56  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
00CE56  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
00CE56  2               ;
00CE56  2               DSKY_PPIIDLE:
00CE56  2               DSKY_PPIRD:
00CE56  2  48                   PHA
00CE57  2               ;
00CE57  2               ; PLACE PORT C BITS 0-4 & 7 IN OUT MODE
00CE57  2  A9 9F                LDA     #$9F
00CE59  2  8D 03 ED             STA     DSKY_PPIC_C
00CE5C  2               ; PLACE PORT A BITS 0-7 IN INPUT MODE
00CE5C  2  A9 00                LDA     #$00
00CE5E  2  8D 03 EC             STA     DSKY_PPIA_C
00CE61  2               ;
00CE61  2               
00CE61  2               ;
00CE61  2  68                   PLA
00CE62  2  60                   RTS
00CE63  2               ;
00CE63  2               ;__STORAGE_________________________________________________________________________________________
00CE63  2               ; CODES FOR NUMERICS
00CE63  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
00CE63  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
00CE63  2               ;_________________________________________________________________________________________________
00CE63  2               ;
00CE63  2               DSKY_HEXMAP:
00CE63  2  3F                   .BYTE   $3F             ; 0
00CE64  2  06                   .BYTE   $06             ; 1
00CE65  2  5B                   .BYTE   $5B             ; 2
00CE66  2  4F                   .BYTE   $4F             ; 3
00CE67  2  66                   .BYTE   $66             ; 4
00CE68  2  6D                   .BYTE   $6D             ; 5
00CE69  2  7D                   .BYTE   $7D             ; 6
00CE6A  2  07                   .BYTE   $07             ; 7
00CE6B  2  7F                   .BYTE   $7F             ; 8
00CE6C  2  67                   .BYTE   $67             ; 9
00CE6D  2  77                   .BYTE   $77             ; A
00CE6E  2  7C                   .BYTE   $7C             ; B
00CE6F  2  39                   .BYTE   $39             ; C
00CE70  2  5E                   .BYTE   $5E             ; D
00CE71  2  79                   .BYTE   $79             ; E
00CE72  2  71                   .BYTE   $71             ; F
00CE73  2               ;
00CE73  2               
00CE73  1                       .ENDIF
00CE73  1               
00CE73  1                       .IF     DSKY_OPTION=0
00CE73  1               DSKY_INIT:
00CE73  1               DSKY_RESET:
00CE73  1               DSKY_SHOW:
00CE73  1               DSKY_BIN2SEG:
00CE73  1               DSKY_STAT:
00CE73  1               DSKY_GETKEY:
00CE73  1               DSKY_BEEP:
00CE73  1               DSKY_PUTLED:
00CE73  1               DSKY_BLANK:
00CE73  1               DSKY_DSPL:
00CE73  1                           RTS
00CE73  1                       .ENDIF
00CE73  1               
00CE73  1               
00CE73  1                       .SEGMENT "TROM"
00CE73  1                       .ORG    $F000
00F000  1               
00F000  1               
00F000  1               ;__COLD_START___________________________________________________
00F000  1               ;
00F000  1               ; PERFORM SYSTEM COLD INIT
00F000  1               ;
00F000  1               ;_______________________________________________________________
00F000  1               COLD_START:
00F000  1  78                   SEI                     ; DISABLE INTERRUPTS
00F001  1  D8                   CLD                     ;  VERIFY DECIMAL MODE IS OFF
00F002  1  A2 FF                LDX     #$FF            ;
00F004  1  9A                   TXS                     ; CLEAR STACK
00F005  1  8A                   TXA
00F006  1               
00F006  1               ;;; TODO  ADD AUTODETECT/OPTION AT SOME POINT
00F006  1  A9 09                LDA     #09             ; SET CONSOLE (09=PPP, 04= SERIAL)
00F008  1  85 3A                STA     CONSOLE
00F00A  1               ;;;
00F00A  1               
00F00A  1  A9 6E                LDA     #<IRQROUTINE
00F00C  1  85 35                STA     IRQVECTOR
00F00E  1  85 37                STA     NMIVECTOR
00F010  1  A9 F0                LDA     #>IRQROUTINE
00F012  1  85 36                STA     IRQVECTOR+1
00F014  1  85 38                STA     NMIVECTOR+1
00F016  1               ;
00F016  1               ;       INIT PAGING
00F016  1  20 13 FA             JSR     INITPAGES       ;
00F019  1               
00F019  1               ;	INIT HARDWARE
00F019  1  A9 08                LDA     #08             ; SERIAL INITIALIZE
00F01B  1  85 32                STA     farfunct
00F01D  1  20 5F FA             JSR     DO_FARCALL
00F020  1               ;
00F020  1  A9 0D                LDA     #13             ; PROP VIDEO INITIALIZE
00F022  1  85 32                STA     farfunct
00F024  1  20 5F FA             JSR     DO_FARCALL
00F027  1               
00F027  1               
00F027  1  20 51 FA             JSR     PAGE_ENTER
00F02A  1  A9 9F                LDA     #<STARTUP       ; OUTPUT STARTUP STRING
00F02C  1  85 41                STA     STRPTR          ;
00F02E  1  A9 FA                LDA     #>STARTUP       ;
00F030  1  85 42                STA     STRPTR+1        ;
00F032  1  20 82 FA             JSR     OUTSTR          ;
00F035  1  20 49 FA             JSR     PAGE_EXIT
00F038  1               
00F038  1  A9 00                LDA     #$00            ;
00F03A  1  8D 00 04             STA     INBUFFER        ; MAKE SURE INPUT BUFFER IS EMPTY
00F03D  1               ;
00F03D  1  A9 28                LDA     #40             ; DSKY INITIALIZE
00F03F  1  85 32                STA     farfunct
00F041  1  20 5F FA             JSR     DO_FARCALL
00F044  1               
00F044  1  A9 34                LDA     #52             ; RTC_RESET
00F046  1  85 32                STA     farfunct
00F048  1  20 5F FA             JSR     DO_FARCALL
00F04B  1               
00F04B  1  A9 3C                LDA     #60             ; IDE INITIALIZE
00F04D  1  85 32                STA     farfunct
00F04F  1  20 5F FA             JSR     DO_FARCALL
00F052  1               
00F052  1  A9 3F                LDA     #63             ; SD INITIALIZE
00F054  1  85 32                STA     farfunct
00F056  1  20 5F FA             JSR     DO_FARCALL
00F059  1               
00F059  1               ;        LDA     #66             ; FLOPPY INITIALIZE
00F059  1               ;        STA     farfunct
00F059  1               ;        JSR     DO_FARCALL
00F059  1               
00F059  1               
00F059  1  A2 00                LDX     #$00            ; SHOW A STARTUP MESSAGE ON DSKY
00F05B  1               :
00F05B  1  BD 97 FA             LDA     DSKYMSG,x
00F05E  1  9D 00 05             STA     DSKY_BUF,x
00F061  1  E8                   INX
00F062  1  E0 08                CPX     #8
00F064  1  D0 F5                BNE     :-
00F066  1  A9 29                LDA     #41             ; DSKY_SHOW
00F068  1  85 32                STA     farfunct
00F06A  1  20 5F FA             JSR     DO_FARCALL
00F06D  1               
00F06D  1  00                   BRK                     ; PERFORM BRK (START MONITOR)
00F06E  1               
00F06E  1               ;__IRQROUTINE___________________________________________________
00F06E  1               ;
00F06E  1               ; HANDLE INTERRUPT PROCESING
00F06E  1               ;
00F06E  1               ;_______________________________________________________________
00F06E  1               IRQROUTINE:
00F06E  1  58                   CLI                     ; ENABLE INTERRUPTS AGAIN
00F06F  1  40                   RTI
00F070  1               
00F070  1               ;__INTERRUPT____________________________________________________
00F070  1               ;
00F070  1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
00F070  1               ;
00F070  1               ;_______________________________________________________________
00F070  1               INTERRUPT:
00F070  1  78                   SEI                     ; DISABLE INTERRUPTS
00F071  1  85 3B                STA     TEMPWORD
00F073  1  68                   PLA                     ; GET STATUS REGISTER
00F074  1  48                   PHA                     ; SAVE STATUS REGISTER
00F075  1  29 10                AND     #$10            ; MASK BRK
00F077  1  D0 03                BNE     BRKCMD          ; BRK CMD
00F079  1  6C 35 00             JMP     (IRQVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
00F07C  1               BRKCMD:
00F07C  1  A5 3B                LDA     TEMPWORD
00F07E  1  48                   PHA
00F07F  1  8A                   TXA
00F080  1  48                   PHA
00F081  1  98                   TYA
00F082  1  48                   PHA
00F083  1  4C 89 F0             JMP     BRKROUTINE      ; MONITOR BRK ROUTINE
00F086  1               
00F086  1               NINTERRUPT:
00F086  1  6C 37 00             JMP     (NMIVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED NMI)
00F089  1               
00F089  1                       .INCLUDE "supermon.asm"
00F089  2               ; ********************************
00F089  2               ; * SUPERMON+ 64 JIM BUTTERFIELD *
00F089  2               ; * V1.2   AUGUST 20 1985        *
00F089  2               ; ********************************
00F089  2               
00F089  2               ; Reformatted and annotated in late 2016/early 2017 by J.B. Langston.
00F089  2               ; Modified for Nhyodyne/Retrobrew 3/12/2023 D. Werner
00F089  2               ;
00F089  2               ; Mr. Butterfield . . you inspired many of us, thank you.
00F089  2               ;
00F089  2               ; -----------------------------------------------------------------------------
00F089  2               ; temporary pointers
00F089  2               TMP0            = $C1           ; used to return input, often holds end address
00F089  2               TMP2            = $C3           ; usually holds start address
00F089  2               
00F089  2               ; these 7 locations are used to store the registers when
00F089  2               ; entering the monitor and restore them when exiting.
00F089  2               
00F089  2               PCH             = $B0           ; program counter high byte
00F089  2               PCL             = $B1           ; program counter low byte
00F089  2               SR              = $B2           ; status register
00F089  2               ACC             = $B3           ; accumulator
00F089  2               XR              = $B4           ; X register
00F089  2               YR              = $B5           ; Y register
00F089  2               SP              = $B6           ; stack pointer
00F089  2               STORE           = $B7           ; 2-byte temp storage
00F089  2               CHRPNT          = $B9           ; current position in input buffer
00F089  2               SAVY            = $BA           ; temp storage, often to save Y register
00F089  2               U9F             = $BB           ; index into assembler work buffer
00F089  2               CKSM            = $BC           ; S19 loader checksum store
00F089  2               LOADADR         = $BD           ; S19 load address
00F089  2               LOADWRK         = $BF           ; S19 load work
00F089  2               
00F089  2               ;-----------------------------------------------------------------------------
00F089  2               ; variables
00F089  2               ACMD            = $C5           ; addressing command
00F089  2               LENGTH          = $C6           ; length of operand
00F089  2               MNEMW           = $C7           ; 3 letter mnemonic buffer
00F089  2               SAVX            = $CA           ; 1 byte temp storage, often to save X register
00F089  2               OPCODE          = $CB           ; current opcode for assembler/disassembler
00F089  2               UPFLG           = $CC           ; flag: count up (bit 7 clear) or down (bit 7 set)
00F089  2               DIGCNT          = $CB           ; digit count
00F089  2               INDIG           = $CC           ; numeric value of single digit
00F089  2               NUMBIT          = $CD           ; numeric base of input
00F089  2               STASH           = $CE           ; 2-byte temp storage
00F089  2               U0AA0           = $D0           ; 10 byte work buffer
00F089  2               U0AAE           = $D0+10        ; end of 10 byte work buffer
00F089  2               STAGE           = $DA           ; 30 byte staging buffer for filename, search, etc.
00F089  2               ESTAGE          = $DA+30        ; end of 30 byte staging buffer for filename, search, etc.
00F089  2               INBUFF          = $0200
00F089  2               CHROUT          = IOF_OUTCH
00F089  2               
00F089  2               
00F089  2               ; -----------------------------------------------------------------------------
00F089  2               ; BRK handler
00F089  2               BRKROUTINE:
00F089  2               BREAK:
00F089  2  A2 05                LDX     #$05            ; pull registers off the stack
00F08B  2               BSTACK:
00F08B  2  68                   PLA                     ; order: Y,X,A,SR,PCL,PCH
00F08C  2  95 B0                STA     PCH,X           ; store in memory
00F08E  2  CA                   DEX
00F08F  2  10 FA                BPL     BSTACK
00F091  2  D8                   CLD                     ; disable bcd mode
00F092  2  BA                   TSX                     ; store stack pointer in memory
00F093  2  86 B6                STX     SP
00F095  2  58                   CLI                     ; enable interupts
00F096  2               
00F096  2               ; -----------------------------------------------------------------------------
00F096  2               ; display registers [R]
00F096  2               DSPLYR:
00F096  2  A0 00                LDY     #MSG2-MSGBAS    ; display headers
00F098  2  20 17 F8             JSR     SNDCLR
00F09B  2  A9 3B                LDA     #$3B            ; prefix registers with "; " to allow editing
00F09D  2  20 76 FA             JSR     CHROUT
00F0A0  2  A9 20                LDA     #$20
00F0A2  2  20 76 FA             JSR     CHROUT
00F0A5  2  A5 B0                LDA     PCH             ; print 2-byte program counter
00F0A7  2  20 B1 F6             JSR     WRTWO
00F0AA  2  A0 01                LDY     #1              ; start 1 byte after PC high byte
00F0AC  2               DISJ:
00F0AC  2  B9 B0 00             LDA     PCH,Y           ; loop through rest of the registers
00F0AF  2  20 8D F6             JSR     WRBYTE          ; print 1-byte register value
00F0B2  2  C8                   INY
00F0B3  2  C0 07                CPY     #7              ; there are a total of 5 registers to print
00F0B5  2  90 F5                BCC     DISJ
00F0B7  2               
00F0B7  2               ; -----------------------------------------------------------------------------
00F0B7  2               ; main loop
00F0B7  2               STRT:
00F0B7  2  20 98 F6             JSR     CRLF            ; new line
00F0BA  2  A2 00                LDX     #0              ; point at start of input buffer
00F0BC  2  86 B9                STX     CHRPNT
00F0BE  2               SMOVE:
00F0BE  2  20 68 FA             JSR     IOF_CONINW      ; CHRIN kernal call to input a character
00F0C1  2               
00F0C1  2  C9 08                CMP     #$08            ; IS BACKSPACE?
00F0C3  2  D0 1A                BNE     :+              ; NO, SKUP BACKSPACE RTN
00F0C5  2  E0 00                CPX     #$00            ; IS INDEX =0 ?
00F0C7  2  F0 F5                BEQ     SMOVE           ; YES, SKIP BACKSPACE
00F0C9  2  20 76 FA             JSR     IOF_OUTCH       ; BACK UP CURSOR
00F0CC  2  A9 20                LDA     #$20
00F0CE  2  20 76 FA             JSR     IOF_OUTCH       ; SPACE ON SCREEN
00F0D1  2  A9 08                LDA     #$08
00F0D3  2  20 76 FA             JSR     IOF_OUTCH       ; BACK UP CURSOR
00F0D6  2               
00F0D6  2  A9 00                LDA     #0
00F0D8  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
00F0DB  2  CA                   DEX
00F0DC  2  4C BE F0             JMP     SMOVE
00F0DF  2               :
00F0DF  2  20 76 FA             JSR     IOF_OUTCH       ; OUTPUT CHAR TO SCREEN
00F0E2  2               
00F0E2  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
00F0E5  2  E8                   INX
00F0E6  2  E0 00                CPX     #00             ; error if buffer is full
00F0E8  2  F0 1C                BEQ     ERROR
00F0EA  2  C9 0D                CMP     #$0D            ; keep reading until CR
00F0EC  2  D0 D0                BNE     SMOVE
00F0EE  2  A9 00                LDA     #0              ; null-terminate input buffer
00F0F0  2  9D FF 01             STA     INBUFF-1,X      ; (replacing the CR)
00F0F3  2               ST1:
00F0F3  2  20 D6 F6             JSR     GETCHR          ; get a character from the buffer
00F0F6  2  F0 BF                BEQ     STRT            ; start over if buffer is empty
00F0F8  2  C9 20                CMP     #$20            ; skip leading spaces
00F0FA  2  F0 F7                BEQ     ST1
00F0FC  2               S0:
00F0FC  2  A2 13                LDX     #KEYTOP-KEYW    ; loop through valid command characters
00F0FE  2               S1:
00F0FE  2  DD DA F9             CMP     KEYW,X          ; see if input character matches
00F101  2  F0 0B                BEQ     S2              ; command matched, dispatch it
00F103  2  CA                   DEX                     ; no match, check next command
00F104  2  10 F8                BPL     S1              ; keep trying until we've checked them all
00F106  2                                               ; then fall through to error handler
00F106  2               
00F106  2               ; -----------------------------------------------------------------------------
00F106  2               ; handle error
00F106  2               ERROR:
00F106  2  A0 1E                LDY     #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
00F108  2  20 2A F8             JSR     SNDMSG
00F10B  2  4C B7 F0             JMP     STRT            ; back to main loop
00F10E  2               
00F10E  2               ; -----------------------------------------------------------------------------
00F10E  2               ; dispatch command
00F10E  2               S2:
00F10E  2  E0 0E                CPX     #$0E            ; next 4 commands are base conversions
00F110  2  B0 0E                BCS     CNVLNK          ;   which are handled by the same subroutine
00F112  2  8A                   TXA                     ; remaining commands dispatch through vector table
00F113  2  0A                   ASL     A               ; multiply index of command by 2
00F114  2  AA                   TAX                     ;   since table contains 2-byte addresses
00F115  2  BD EE F9             LDA     KADDR+1,X       ; push address from vector table onto stack
00F118  2  48                   PHA                     ;   so that the RTS from GETPAR will jump there
00F119  2  BD ED F9             LDA     KADDR,X
00F11C  2  48                   PHA
00F11D  2  4C CC F5             JMP     GETPAR          ; get the first parameter for the command
00F120  2               CNVLNK:
00F120  2  4C 6B F7             JMP     CONVRT          ; handle base conversion
00F123  2               
00F123  2               
00F123  2               ; -----------------------------------------------------------------------------
00F123  2               ; display memory [M]
00F123  2               DSPLYM:
00F123  2  B0 08                BCS     DSPM11          ; start from previous end addr if no address given
00F125  2  20 EC F6             JSR     COPY12          ; save start address in TMP2
00F128  2  20 CC F5             JSR     GETPAR          ; get end address in TMP0
00F12B  2  90 06                BCC     DSMNEW          ; did user specify one?
00F12D  2               DSPM11:
00F12D  2  A9 0B                LDA     #$0B            ; if not, show 12 lines by default
00F12F  2  85 C1                STA     TMP0
00F131  2  D0 0E                BNE     DSPBYT          ; always true, but BNE uses 1 byte less than JMP
00F133  2               DSMNEW:
00F133  2  20 F5 F6             JSR     SUB12           ; end addr given, calc bytes between start and end
00F136  2  90 1E                BCC     MERROR          ; error if start is after end
00F138  2  A2 03                LDX     #3              ; divide by 8 (shift right 3 times)
00F13A  2               DSPM01:
00F13A  2  46 C2                LSR     TMP0+1
00F13C  2  66 C1                ROR     TMP0
00F13E  2  CA                   DEX
00F13F  2  D0 F9                BNE     DSPM01
00F141  2               DSPBYT:
00F141  2  20 38 F8             JSR     STOP            ; check for stop key
00F144  2  F0 0D                BEQ     DSPMX           ; exit early if pressed
00F146  2  20 BA F1             JSR     DISPMEM         ; display 1 line containing 8 bytes
00F149  2  A9 08                LDA     #8              ; increase start address by 8 bytes
00F14B  2  20 25 F7             JSR     BUMPAD2
00F14E  2  20 03 F7             JSR     SUBA1           ; decrement line counter
00F151  2  B0 EE                BCS     DSPBYT          ; show another line until it's < 0
00F153  2               DSPMX:
00F153  2  4C B7 F0             JMP     STRT            ; back to main loop
00F156  2               MERROR:
00F156  2  4C 06 F1             JMP     ERROR           ; handle error
00F159  2               
00F159  2               ; -----------------------------------------------------------------------------
00F159  2               ; alter registers [;]
00F159  2               ALTR:
00F159  2  20 3D F7             JSR     COPY1P          ; store first parameter in PC
00F15C  2  A0 00                LDY     #0              ; init counter
00F15E  2               ALTR1:
00F15E  2  20 CC F5             JSR     GETPAR          ; get value for next register
00F161  2  B0 0A                BCS     ALTRX           ; exit early if no more values given
00F163  2  A5 C1                LDA     TMP0            ; store in memory, offset from SR
00F165  2  99 B2 00             STA     SR,Y            ; these locations will be transferred to the
00F168  2  C8                   INY                     ;   actual registers before exiting the monitor
00F169  2  C0 05                CPY     #$05            ; have we updated all 5 yet?
00F16B  2  90 F1                BCC     ALTR1           ; if not, get next
00F16D  2               ALTRX:
00F16D  2  4C B7 F0             JMP     STRT            ; back to main loop
00F170  2               
00F170  2               ; -----------------------------------------------------------------------------
00F170  2               ; alter memory [>]
00F170  2               ALTM:
00F170  2  B0 13                BCS     ALTMX           ; exit if no parameter provided
00F172  2  20 EC F6             JSR     COPY12          ; copy parameter to start address
00F175  2  A0 00                LDY     #0
00F177  2               ALTM1:
00F177  2  20 CC F5             JSR     GETPAR          ; get value for next byte of memory
00F17A  2  B0 09                BCS     ALTMX           ; if none given, exit early
00F17C  2  A5 C1                LDA     TMP0            ; poke value into memory at start address + Y
00F17E  2  91 C3                STA     (TMP2),Y
00F180  2  C8                   INY                     ; next byte
00F181  2  C0 08                CPY     #8              ; have we read 8 bytes yet?
00F183  2  90 F2                BCC     ALTM1           ; if not, read the next one
00F185  2               ALTMX:
00F185  2  A9 91                LDA     #$91            ; move cursor up
00F187  2  20 76 FA             JSR     CHROUT
00F18A  2  20 BA F1             JSR     DISPMEM         ; re-display line to make ascii match hex
00F18D  2  4C B7 F0             JMP     STRT            ; back to main loop
00F190  2               
00F190  2               ; -----------------------------------------------------------------------------
00F190  2               ; goto (run) [G]
00F190  2               GOTO:
00F190  2  A6 B6                LDX     SP              ; load stack pointer from memory
00F192  2  9A                   TXS                     ; save in SP register
00F193  2               GOTO2:
00F193  2  20 3D F7             JSR     COPY1P          ; copy provided address to PC
00F196  2  78                   SEI                     ; disable interrupts
00F197  2  A5 B0                LDA     PCH             ; push PC high byte on stack
00F199  2  48                   PHA
00F19A  2  A5 B1                LDA     PCL             ; push PC low byte on stack
00F19C  2  48                   PHA
00F19D  2  A5 B2                LDA     SR              ; push status byte on stack
00F19F  2  48                   PHA
00F1A0  2  A5 B3                LDA     ACC             ; load accumulator from memory
00F1A2  2  A6 B4                LDX     XR              ; load X from memory
00F1A4  2  A4 B5                LDY     YR              ; load Y from memory
00F1A6  2  40                   RTI                     ; return from interrupt (pops PC and SR)
00F1A7  2               
00F1A7  2               ; jump to subroutine [J]
00F1A7  2               JSUB:
00F1A7  2  A6 B6                LDX     SP              ; load stack pointer from memory
00F1A9  2  9A                   TXS                     ; save value in SP register
00F1AA  2  20 93 F1             JSR     GOTO2           ; same as goto command
00F1AD  2  84 B5                STY     YR              ; save Y to memory
00F1AF  2  86 B4                STX     XR              ; save X to memory
00F1B1  2  85 B3                STA     ACC             ; save accumulator to memory
00F1B3  2  08                   PHP                     ; push processor status on stack
00F1B4  2  68                   PLA                     ; pull processor status into A
00F1B5  2  85 B2                STA     SR              ; save processor status to memory
00F1B7  2  4C 96 F0             JMP     DSPLYR          ; display registers
00F1BA  2               
00F1BA  2               ; -----------------------------------------------------------------------------
00F1BA  2               ; display 8 bytes of memory
00F1BA  2               DISPMEM:
00F1BA  2  20 98 F6             JSR     CRLF            ; new line
00F1BD  2  A9 3E                LDA     #'>'            ; prefix > so memory can be edited in place
00F1BF  2  20 76 FA             JSR     CHROUT
00F1C2  2  20 83 F6             JSR     SHOWAD          ; show address of first byte on line
00F1C5  2  A0 00                LDY     #0
00F1C7  2  F0 03                BEQ     DMEMGO          ; SHOWAD already printed a space after the address
00F1C9  2               DMEMLP:
00F1C9  2  20 90 F6             JSR     SPACE           ; print space between bytes
00F1CC  2               DMEMGO:
00F1CC  2  B1 C3                LDA     (TMP2),Y        ; load byte from start address + Y
00F1CE  2  20 B1 F6             JSR     WRTWO           ; output hex digits for byte
00F1D1  2  C8                   INY                     ; next byte
00F1D2  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
00F1D4  2  90 F3                BCC     DMEMLP          ; if not, output next byte
00F1D6  2  A0 26                LDY     #MSG5-MSGBAS    ; if so, output : and turn on reverse video
00F1D8  2  20 2A F8             JSR     SNDMSG          ;   before displaying ascii representation
00F1DB  2  A0 00                LDY     #0              ; back to first byte in line
00F1DD  2               DCHAR:
00F1DD  2  B1 C3                LDA     (TMP2),Y        ; load byte at start address + Y
00F1DF  2  C9 20                CMP     #$20            ; is it a printable character (>= $20)?
00F1E1  2  90 04                BCC     DDOT            ; if NOT printable, output '.'
00F1E3  2  C9 80                CMP     #$80
00F1E5  2  90 02                BCC     DCHROK          ; if printable, output character
00F1E7  2               DDOT:
00F1E7  2  A9 2E                LDA     #$2E            ; if not, output '.' instaed
00F1E9  2               DCHROK:
00F1E9  2  20 76 FA             JSR     CHROUT
00F1EC  2  C8                   INY                     ; next byte
00F1ED  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
00F1EF  2  90 EC                BCC     DCHAR           ; if not, output next byte
00F1F1  2  60                   RTS
00F1F2  2               
00F1F2  2               ; -----------------------------------------------------------------------------
00F1F2  2               ; compare memory [C]
00F1F2  2               COMPAR:
00F1F2  2  A9 00                LDA     #0              ; bit 7 clear signals compare
00F1F4  2  2C                   .BYTE   $2C             ; absolute BIT opcode consumes next word (LDA #$80)
00F1F5  2               
00F1F5  2               ; transfer memory [T]
00F1F5  2               TRANS:
00F1F5  2  A9 80                LDA     #$80            ; bit 7 set signals transfer
00F1F7  2  85 BA                STA     SAVY            ; save compare/transfer flag in SAVY
00F1F9  2  A9 00                LDA     #0              ; assume we're counting up (bit 7 clear)
00F1FB  2  85 CC                STA     UPFLG           ; save direction flag
00F1FD  2  20 48 F7             JSR     GETDIF          ; get two addresses and calculate difference
00F200  2                                               ;   TMP2 = source start
00F200  2                                               ;   STASH = source end
00F200  2                                               ;   STORE = length
00F200  2  B0 05                BCS     TERROR          ; carry set indicates error
00F202  2  20 CC F5             JSR     GETPAR          ; get destination address in TMP0
00F205  2  90 03                BCC     TOKAY           ; carry set indicates error
00F207  2               TERROR:
00F207  2  4C 06 F1             JMP     ERROR           ; handle error
00F20A  2               TOKAY:
00F20A  2  24 BA                BIT     SAVY            ; transfer or compare?
00F20C  2  10 23                BPL     COMPAR1         ; high bit clear indicates compare
00F20E  2  A5 C3                LDA     TMP2            ; if it's a transfer, we must take steps
00F210  2  C5 C1                CMP     TMP0            ;   to avoid overwriting the source bytes before
00F212  2  A5 C4                LDA     TMP2+1          ;   they have been transferred
00F214  2  E5 C2                SBC     TMP0+1          ; compare source (TMP2) to destination (TMP0)
00F216  2  B0 19                BCS     COMPAR1         ; and count up if source is before than desitnation
00F218  2  A5 B7                LDA     STORE           ; otherwise, start at end and count down...
00F21A  2  65 C1                ADC     TMP0            ; add length (STORE) to desintation (TMP0)
00F21C  2  85 C1                STA     TMP0            ; to calculate end of destination
00F21E  2  A5 B8                LDA     STORE+1
00F220  2  65 C2                ADC     TMP0+1
00F222  2  85 C2                STA     TMP0+1
00F224  2  A2 01                LDX     #1              ; change source pointer from beginning to end
00F226  2               TDOWN:
00F226  2  B5 CE                LDA     STASH,X         ; TMP2 = source end (STASH)
00F228  2  95 C3                STA     TMP2,X
00F22A  2  CA                   DEX
00F22B  2  10 F9                BPL     TDOWN
00F22D  2  A9 80                LDA     #$80            ; high bit set in UPFLG means count down
00F22F  2  85 CC                STA     UPFLG
00F231  2               COMPAR1:
00F231  2  20 98 F6             JSR     CRLF            ; new line
00F234  2  A0 00                LDY     #0              ; no offset from pointer
00F236  2               TCLOOP:
00F236  2  20 38 F8             JSR     STOP            ; check for stop key
00F239  2  F0 2F                BEQ     TEXIT           ; exit if pressed
00F23B  2  B1 C3                LDA     (TMP2),Y        ; load byte from source
00F23D  2  24 BA                BIT     SAVY            ; transfer or compare?
00F23F  2  10 02                BPL     COMPAR2         ; skip store if comparing
00F241  2  91 C1                STA     (TMP0),Y        ; otherwise, store in destination
00F243  2               COMPAR2:
00F243  2  D1 C1                CMP     (TMP0),Y        ; compare to destination
00F245  2  F0 03                BEQ     TMVAD           ; don't show address if equal
00F247  2  20 83 F6             JSR     SHOWAD          ; show address
00F24A  2               TMVAD:
00F24A  2  24 CC                BIT     UPFLG           ; counting up or down?
00F24C  2  30 0B                BMI     TDECAD          ; high bit set means we're counting down
00F24E  2  E6 C1                INC     TMP0            ; increment destination low byte
00F250  2  D0 10                BNE     TINCOK
00F252  2  E6 C2                INC     TMP0+1          ; carry to high byte if necessary
00F254  2  D0 0C                BNE     TINCOK
00F256  2  4C 06 F1             JMP     ERROR           ; error if high byte overflowed
00F259  2               TDECAD:
00F259  2  20 03 F7             JSR     SUBA1           ; decrement destination (TMP0)
00F25C  2  20 2F F7             JSR     SUB21           ; decrement source (TMP2)
00F25F  2  4C 65 F2             JMP     TMOR
00F262  2               TINCOK:
00F262  2  20 23 F7             JSR     ADDA2           ; increment source (TMP2)
00F265  2               TMOR:
00F265  2  20 15 F7             JSR     SUB13           ; decrement length
00F268  2  B0 CC                BCS     TCLOOP          ; loop until length is 0
00F26A  2               TEXIT:
00F26A  2  4C B7 F0             JMP     STRT            ; back to main loop
00F26D  2               
00F26D  2               ; -----------------------------------------------------------------------------
00F26D  2               ; hunt memory [H]
00F26D  2               HUNT:
00F26D  2  20 48 F7             JSR     GETDIF          ; get start (TMP2) and end (TMP0) of haystack
00F270  2  B0 57                BCS     HERROR          ; carry indicates error
00F272  2  A0 00                LDY     #0
00F274  2  20 D6 F6             JSR     GETCHR          ; get a single character
00F277  2  C9 27                CMP     #39             ; is it a single quote?
00F279  2  D0 16                BNE     NOSTRH          ; if not, input needle as hex bytes
00F27B  2  20 D6 F6             JSR     GETCHR          ; if so, input needle as string
00F27E  2  C9 00                CMP     #0
00F280  2  F0 47                BEQ     HERROR          ; error if needle isn't at least one byte
00F282  2               HPAR:
00F282  2  99 DA 00             STA     STAGE,Y         ; save char in staging area
00F285  2  C8                   INY
00F286  2  20 D6 F6             JSR     GETCHR          ; get another char
00F289  2  F0 18                BEQ     HTGO            ; if it's null start searching
00F28B  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
00F28D  2  D0 F3                BNE     HPAR            ; if not, get another character
00F28F  2  F0 12                BEQ     HTGO            ; if so, start searching
00F291  2               NOSTRH:
00F291  2  20 CA F5             JSR     RDPAR           ; read hex bytes if string not indicated
00F294  2               HLP:
00F294  2  A5 C1                LDA     TMP0            ; save last read byte in staging area
00F296  2  99 DA 00             STA     STAGE,Y
00F299  2  C8                   INY                     ; get another hex byte
00F29A  2  20 CC F5             JSR     GETPAR
00F29D  2  B0 04                BCS     HTGO            ; if there is none, start searching
00F29F  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
00F2A1  2  D0 F1                BNE     HLP             ; if not, get another byte
00F2A3  2               HTGO:
00F2A3  2  84 BA                STY     SAVY            ; save length of needle
00F2A5  2  20 98 F6             JSR     CRLF            ; new line
00F2A8  2               HSCAN:
00F2A8  2  A0 00                LDY     #0
00F2AA  2               HLP3:
00F2AA  2  B1 C3                LDA     (TMP2),Y        ; get first byte in haystack
00F2AC  2  D9 DA 00             CMP     STAGE,Y         ; compare it to first byte of needle
00F2AF  2  D0 08                BNE     HNOFT           ; if it doesn't match, we haven't found anything
00F2B1  2  C8                   INY                     ; if it does, check the next byte
00F2B2  2  C4 BA                CPY     SAVY            ; have we reached the end of the needle?
00F2B4  2  D0 F4                BNE     HLP3            ; if not, keep comparing bytes
00F2B6  2  20 83 F6             JSR     SHOWAD          ; match found, show address
00F2B9  2               HNOFT:
00F2B9  2  20 38 F8             JSR     STOP            ; no match, check for stop key
00F2BC  2  F0 08                BEQ     HEXIT           ; exit prematurely if pressed
00F2BE  2  20 23 F7             JSR     ADDA2           ; increment haystack pointer
00F2C1  2  20 15 F7             JSR     SUB13           ; decrement haystack length
00F2C4  2  B0 E2                BCS     HSCAN           ; still more haystack? keep searching
00F2C6  2               HEXIT:
00F2C6  2  4C B7 F0             JMP     STRT            ; back to main loop
00F2C9  2               HERROR:
00F2C9  2  4C 06 F1             JMP     ERROR           ; handle error
00F2CC  2               
00F2CC  2               
00F2CC  2               ; -----------------------------------------------------------------------------
00F2CC  2               ; fill memory [F]
00F2CC  2               FILL:
00F2CC  2  20 48 F7             JSR     GETDIF          ; start in TMP2, end in STASH, length in STORE
00F2CF  2  B0 20                BCS     FERROR          ; carry set indicates error
00F2D1  2  20 CC F5             JSR     GETPAR          ; get value to fill in TMP0
00F2D4  2  B0 1B                BCS     FERROR          ; carry set indicates error
00F2D6  2  20 D6 F6             JSR     GETCHR          ; any more characters triggers an error
00F2D9  2  D0 16                BNE     FERROR
00F2DB  2  A0 00                LDY     #0              ; no offset
00F2DD  2               FILLP:
00F2DD  2  A5 C1                LDA     TMP0            ; load value to fill in accumulator
00F2DF  2  91 C3                STA     (TMP2),Y        ; store fill value in current address
00F2E1  2  20 38 F8             JSR     STOP            ; check for stop key
00F2E4  2  F0 08                BEQ     FSTART          ; if pressed, back to main loop
00F2E6  2  20 23 F7             JSR     ADDA2           ; increment address
00F2E9  2  20 15 F7             JSR     SUB13           ; decrement length
00F2EC  2  B0 EF                BCS     FILLP           ; keep going until length reaches 0
00F2EE  2               FSTART:
00F2EE  2  4C B7 F0             JMP     STRT            ; back to main loop
00F2F1  2               FERROR:
00F2F1  2  4C 06 F1             JMP     ERROR           ; handle error
00F2F4  2               ; -----------------------------------------------------------------------------
00F2F4  2               ; Boot System [B]
00F2F4  2               BOOT:
00F2F4  2  B0 21                BCS     BOOTX           ; exit with error if no parameter given
00F2F6  2  A5 C1                LDA     TMP0
00F2F8  2  29 0F                AND     #$0F
00F2FA  2  8D 28 05             STA     DSKUNIT
00F2FD  2  A9 00                LDA     #$00
00F2FF  2  8D 10 05             STA     debcyll         ;
00F302  2  8D 11 05             STA     debcylm         ;
00F305  2  8D 12 05             STA     debsehd         ;
00F308  2  20 CC F5             JSR     GETPAR          ; get value for next byte of memory
00F30B  2  B0 0A                BCS     BOOTX           ; exit with error if no parameter given
00F30D  2  A5 C1                LDA     TMP0
00F30F  2  85 32                STA     farfunct
00F311  2  20 5F FA             JSR     DO_FARCALL
00F314  2  4C 00 02             JMP     hstbuf
00F317  2               BOOTX:
00F317  2  4C 06 F1             JMP     ERROR           ; back to main loop
00F31A  2               
00F31A  2               
00F31A  2               
00F31A  2               ; -----------------------------------------------------------------------------
00F31A  2               ; assemble [A.]
00F31A  2               ; read in mnemonic
00F31A  2               ASTART:
00F31A  2  4C B7 F0             JMP     STRT            ; back to main loop
00F31D  2               ASSEM:
00F31D  2  B0 31                BCS     AERROR          ; error if no address given
00F31F  2  20 EC F6             JSR     COPY12          ; copy address to TMP2
00F322  2               AGET1:
00F322  2  A2 00                LDX     #0
00F324  2  86 D1                STX     U0AA0+1         ; clear byte that mnemonic gets shifted into
00F326  2  86 CB                STX     DIGCNT          ; clear digit count
00F328  2               AGET2:
00F328  2  20 D6 F6             JSR     GETCHR          ; get a char
00F32B  2  D0 04                BNE     ALMOR           ; proceed if the character isn't null
00F32D  2  E0 00                CPX     #0              ; it's null, have read a mnemonic yet?
00F32F  2  F0 E9                BEQ     ASTART          ; if not, silently go back to main loop
00F331  2               ALMOR:
00F331  2  C9 20                CMP     #$20            ; skip leading spaces
00F333  2  F0 ED                BEQ     AGET1
00F335  2  95 C7                STA     MNEMW,X         ; put character in mnemonic buffer
00F337  2  E8                   INX
00F338  2  E0 03                CPX     #3              ; have we read 3 characters yet?
00F33A  2  D0 EC                BNE     AGET2           ; if not, get next character
00F33C  2               
00F33C  2               ; compress mnemonic into two bytes
00F33C  2               ASQEEZ:
00F33C  2  CA                   DEX                     ; move to previous char
00F33D  2  30 14                BMI     AOPRND          ; if we're done with mnemonic, look for operand
00F33F  2  B5 C7                LDA     MNEMW,X         ; get current character
00F341  2  38                   SEC                     ; pack 3-letter mnemonic into 2 bytes (15 bits)
00F342  2  E9 3F                SBC     #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
00F344  2  A0 05                LDY     #$05            ; letters now fit in 5 bits; shift them out
00F346  2               ASHIFT:
00F346  2  4A                   LSR     A               ;   into the first two bytes of the inst buffer
00F347  2  66 D1                ROR     U0AA0+1         ; catch the low bit from accumulator in right byte
00F349  2  66 D0                ROR     U0AA0           ; catch the low bit from right byte in left byte
00F34B  2  88                   DEY                     ; count down bits
00F34C  2  D0 F8                BNE     ASHIFT          ; keep looping until we reach zero
00F34E  2  F0 EC                BEQ     ASQEEZ          ; unconditional branch to handle next char
00F350  2               AERROR:
00F350  2  4C 06 F1             JMP     ERROR           ; handle error
00F353  2               
00F353  2               ; parse operand
00F353  2               AOPRND:
00F353  2  A2 02                LDX     #2              ; mnemonic is in first two bytes so start at third
00F355  2               ASCAN:
00F355  2  A5 CB                LDA     DIGCNT          ; did we find address digits last time?
00F357  2  D0 28                BNE     AFORM1          ; if so, look for mode chars
00F359  2  20 F1 F5             JSR     RDVAL           ; otherwise, look for an address
00F35C  2  F0 21                BEQ     AFORM0          ; we didn't find an address, look for characters
00F35E  2  B0 F0                BCS     AERROR          ; carry flag indicates error
00F360  2  A9 24                LDA     #'$'
00F362  2  95 D0                STA     U0AA0,X         ; prefix addresses with $
00F364  2  E8                   INX                     ; next position in buffer
00F365  2  A0 04                LDY     #4              ; non-zero page addresses are 4 hex digits
00F367  2  A5 CD                LDA     NUMBIT          ; check numeric base in which address was given
00F369  2  C9 08                CMP     #8              ; for addresses given in octal or binary
00F36B  2  90 04                BCC     AADDR           ;   use only the high byte to determine page
00F36D  2  C4 CB                CPY     DIGCNT          ; for decimal or hex, force non-zero page addressing
00F36F  2  F0 06                BEQ     AFILL0          ;   if address was given with four digits or more
00F371  2               AADDR:
00F371  2  A5 C2                LDA     TMP0+1          ; check whether high byte of address is zero
00F373  2  D0 02                BNE     AFILL0          ; non-zero high byte means we're not in zero page
00F375  2  A0 02                LDY     #2              ; if it's in zero page, addr is 2 hex digits
00F377  2               AFILL0:
00F377  2  A9 30                LDA     #$30            ; use 0 as placeholder for each hex digit in addr
00F379  2               AFIL0L:
00F379  2  95 D0                STA     U0AA0,X         ; put placeholder in assembly buffer
00F37B  2  E8                   INX                     ; move to next byte in buffer
00F37C  2  88                   DEY                     ; decrement number of remaining digits
00F37D  2  D0 FA                BNE     AFIL0L          ; loop until all digits have been placed
00F37F  2               AFORM0:
00F37F  2  C6 B9                DEC     CHRPNT          ; non-numeric input; back 1 char to see what it was
00F381  2               AFORM1:
00F381  2  20 D6 F6             JSR     GETCHR          ; get next character
00F384  2  F0 0D                BEQ     AESCAN          ; if there is none, we're finished scanning
00F386  2  C9 20                CMP     #$20            ; skip spaces
00F388  2  F0 CB                BEQ     ASCAN
00F38A  2  95 D0                STA     U0AA0,X         ; store character in assembly buffer
00F38C  2  E8                   INX                     ; move to next byte in buffer
00F38D  2  E0 0A                CPX     #U0AAE-U0AA0    ; is instruction buffer full?
00F38F  2  90 C4                BCC     ASCAN           ; if not, keep scanning
00F391  2  B0 BD                BCS     AERROR          ; error if buffer is full
00F393  2               
00F393  2               ; find matching opcode
00F393  2               AESCAN:
00F393  2  86 B7                STX     STORE           ; save number of bytes in assembly buffer
00F395  2  A2 00                LDX     #0              ; start at opcode $00 and check every one until
00F397  2  86 CB                STX     OPCODE          ;   we find one that matches our criteria
00F399  2               ATRYOP:
00F399  2  A2 00                LDX     #0
00F39B  2  86 BB                STX     U9F             ; reset index into work buffer
00F39D  2  A5 CB                LDA     OPCODE
00F39F  2  20 62 F5             JSR     INSTXX          ; look up instruction format for current opcode
00F3A2  2  A6 C5                LDX     ACMD            ; save addressing command for later
00F3A4  2  86 B8                STX     STORE+1
00F3A6  2  AA                   TAX                     ; use current opcode as index
00F3A7  2  BD 96 F9             LDA     MNEMR,X         ; check right byte of compressed mnemonic
00F3AA  2  20 98 F4             JSR     CHEKOP
00F3AD  2  BD 56 F9             LDA     MNEML,X         ; check left byte of compressed mnemonic
00F3B0  2  20 98 F4             JSR     CHEKOP
00F3B3  2  A2 06                LDX     #6              ; 6 possible characters to check against operand
00F3B5  2               TRYIT:
00F3B5  2  E0 03                CPX     #3              ; are we on character 3?
00F3B7  2  D0 12                BNE     TRYMOD          ; if not, check operand characters
00F3B9  2  A4 C6                LDY     LENGTH          ; otherwise, check number of bytes in operand
00F3BB  2  F0 0E                BEQ     TRYMOD          ; if zero, check operand characters
00F3BD  2               TRYAD:
00F3BD  2  A5 C5                LDA     ACMD            ; otherwise, look for an address
00F3BF  2  C9 E8                CMP     #$E8            ; special case for relative addressing mode
00F3C1  2                                               ;   since it's specified with 4 digits in assembly
00F3C1  2                                               ;   but encoded with only 1 byte in object code
00F3C1  2  A9 30                LDA     #$30            ; '0' is the digit placeholder we're looking for
00F3C3  2  B0 1D                BCS     TRY4B           ; ACMD >= $E8 indicates relative addressing
00F3C5  2  20 95 F4             JSR     CHEK2B          ; ACMD < $E8 indicates normal addressing
00F3C8  2  88                   DEY                     ; consume byte
00F3C9  2  D0 F2                BNE     TRYAD           ; check for 2 more digits if not zero-page
00F3CB  2               TRYMOD:
00F3CB  2  06 C5                ASL     ACMD            ; shift a bit out of the addressing command
00F3CD  2  90 0E                BCC     UB4DF           ; if it's zero, skip checking current character
00F3CF  2  BD 49 F9             LDA     CHAR1-1,X
00F3D2  2  20 98 F4             JSR     CHEKOP          ; otherwise first character against operand
00F3D5  2  BD 4F F9             LDA     CHAR2-1,X       ; get second character to check
00F3D8  2  F0 03                BEQ     UB4DF           ; if it's zero, skip checking it
00F3DA  2  20 98 F4             JSR     CHEKOP          ; otherwise check it against hte operand
00F3DD  2               UB4DF:
00F3DD  2  CA                   DEX                     ; move to next character
00F3DE  2  D0 D5                BNE     TRYIT           ; repeat tests
00F3E0  2  F0 06                BEQ     TRYBRAN
00F3E2  2               TRY4B:
00F3E2  2  20 95 F4             JSR     CHEK2B          ; check for 4 digit address placeholder
00F3E5  2  20 95 F4             JSR     CHEK2B          ;   by checking for 2 digits twice
00F3E8  2               TRYBRAN:
00F3E8  2  A5 B7                LDA     STORE           ; get number of bytes in assembly buffer
00F3EA  2  C5 BB                CMP     U9F             ; more bytes left to check?
00F3EC  2  F0 03                BEQ     ABRAN           ; if not, we've found a match; build instruction
00F3EE  2  4C A2 F4             JMP     BUMPOP          ; if so, this opcode doesn't match; try the next
00F3F1  2               
00F3F1  2               ; convert branches to relative address
00F3F1  2               ABRAN:
00F3F1  2  A4 C6                LDY     LENGTH          ; get number of bytes in operand
00F3F3  2  F0 33                BEQ     A1BYTE          ; if none, just output the opcode
00F3F5  2  A5 B8                LDA     STORE+1         ; otherwise check the address format
00F3F7  2  C9 9D                CMP     #$9D            ; is it a relative branch?
00F3F9  2  D0 25                BNE     OBJPUT          ; if not, skip relative branch calculation
00F3FB  2  A5 C1                LDA     TMP0            ; calculate the difference between the current
00F3FD  2  E5 C3                SBC     TMP2            ;   address and the branch target (low byte)
00F3FF  2  AA                   TAX                     ; save it in X
00F400  2  A5 C2                LDA     TMP0+1          ; borrow from the high byte if necessary
00F402  2  E5 C4                SBC     TMP2+1
00F404  2  90 0B                BCC     ABBACK          ; if result is negative, we're branching back
00F406  2  F0 03                BEQ     :++             ; high bytes must be equal when branching forward
00F408  2               :
00F408  2  4C 92 F4             JMP     SERROR
00F40B  2               :
00F40B  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
00F40D  2  B0 F9                BCS     :--             ; error if the address is too far away
00F40F  2  90 08                BCC     ABRANX
00F411  2               ABBACK:
00F411  2  A8                   TAY                     ; when branching backward high byte of target must
00F412  2  C8                   INY                     ;   be 1 less than high byte of current address
00F413  2  D0 7D                BNE     SERROR          ; if not, it's too far away
00F415  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
00F417  2  90 79                BCC     SERROR          ; if not, it's too far away
00F419  2               ABRANX:
00F419  2  CA                   DEX                     ; adjust branch target relative to the
00F41A  2  CA                   DEX                     ;   instruction following this one
00F41B  2  8A                   TXA
00F41C  2  A4 C6                LDY     LENGTH          ; load length of operand
00F41E  2  D0 03                BNE     OBJP2           ; don't use the absolute address
00F420  2               
00F420  2               ; assemble machine code
00F420  2               OBJPUT:
00F420  2  B9 C0 00             LDA     TMP0-1,Y        ; get the operand
00F423  2               OBJP2:
00F423  2  91 C3                STA     (TMP2),Y        ; store it after the opcode
00F425  2  88                   DEY
00F426  2  D0 F8                BNE     OBJPUT          ; copy the other byte of operand if there is one
00F428  2               A1BYTE:
00F428  2  A5 CB                LDA     OPCODE          ; put opcode into instruction
00F42A  2  91 C3                STA     (TMP2),Y
00F42C  2  A9 0D                LDA     #$0D            ; cr
00F42E  2  20 76 FA             JSR     CHROUT
00F431  2  A0 2E                LDY     #MSG7-MSGBAS    ; "A " prefix
00F433  2  20 17 F8             JSR     SNDCLR          ; clear line
00F436  2  A9 41                LDA     #'A'
00F438  2  20 76 FA             JSR     CHROUT
00F43B  2  A9 20                LDA     #' '
00F43D  2  20 76 FA             JSR     CHROUT
00F440  2  20 EA F4             JSR     DISLIN          ; disassemble the instruction we just assembled
00F443  2  E6 C6                INC     LENGTH          ; instruction length = operand length + 1 byte
00F445  2  A5 C6                LDA     LENGTH          ;   for the opcode
00F447  2  20 25 F7             JSR     BUMPAD2         ; increment address by length of instruction
00F44A  2                                               ; setup for the next assemble command
00F44A  2  20 98 F6             JSR     CRLF
00F44D  2  A9 41                LDA     #'A'            ; stuff keyboard buffer with next assemble command:
00F44F  2  8D 00 02             STA     INBUFF
00F452  2  20 76 FA             JSR     IOF_OUTCH
00F455  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
00F457  2  8D 01 02             STA     INBUFF+1
00F45A  2  20 76 FA             JSR     IOF_OUTCH
00F45D  2  A5 C4                LDA     TMP2+1          ; convert high byte of next address to hex
00F45F  2  20 BF F6             JSR     ASCTWO
00F462  2  8D 02 02             STA     INBUFF+2        ; put it in the keyboard buffer
00F465  2  20 76 FA             JSR     IOF_OUTCH
00F468  2  8E 03 02             STX     INBUFF+3
00F46B  2  8A                   TXA
00F46C  2  20 76 FA             JSR     IOF_OUTCH
00F46F  2  A5 C3                LDA     TMP2            ; convert low byte of next address to hex
00F471  2  20 BF F6             JSR     ASCTWO
00F474  2  8D 04 02             STA     INBUFF+4        ; put it in the keyboard buffer
00F477  2  20 76 FA             JSR     IOF_OUTCH
00F47A  2  8E 05 02             STX     INBUFF+5
00F47D  2  8A                   TXA
00F47E  2  20 76 FA             JSR     IOF_OUTCH
00F481  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
00F483  2  8D 06 02             STA     INBUFF+6
00F486  2  20 76 FA             JSR     IOF_OUTCH
00F489  2  A2 07                LDX     #7              ; set number of chars in keyboard buffer
00F48B  2  A9 00                LDA     #$00
00F48D  2  85 B9                STA     CHRPNT
00F48F  2  4C BE F0             JMP     SMOVE           ; back to main loop
00F492  2               SERROR:
00F492  2  4C 06 F1             JMP     ERROR           ; handle error
00F495  2               
00F495  2               ; check characters in operand
00F495  2               CHEK2B:
00F495  2  20 98 F4             JSR     CHEKOP          ; check two bytes against value in accumulator
00F498  2               CHEKOP:
00F498  2  86 CA                STX     SAVX            ; stash X
00F49A  2  A6 BB                LDX     U9F             ; get current index into work buffer
00F49C  2  D5 D0                CMP     U0AA0,X         ; check whether this opcode matches the buffer
00F49E  2  F0 09                BEQ     OPOK            ;   matching so far, check the next criteria
00F4A0  2  68                   PLA                     ; didn't match, so throw away return address
00F4A1  2  68                   PLA                     ;   on the stack because we're starting over
00F4A2  2               BUMPOP:
00F4A2  2  E6 CB                INC     OPCODE          ; check the next opcode
00F4A4  2  F0 EC                BEQ     SERROR          ; error if we tried every opcode and none fit
00F4A6  2  4C 99 F3             JMP     ATRYOP          ; start over with new opcode
00F4A9  2               OPOK:
00F4A9  2  E6 BB                INC     U9F             ; opcode matches so far; check the next criteria
00F4AB  2  A6 CA                LDX     SAVX            ; restore X
00F4AD  2  60                   RTS
00F4AE  2               
00F4AE  2               ; -----------------------------------------------------------------------------
00F4AE  2               ; disassemble [D]
00F4AE  2               DISASS:
00F4AE  2  B0 08                BCS     DIS0AD          ; if no address was given, start from last address
00F4B0  2  20 EC F6             JSR     COPY12          ; copy start address to TMP2
00F4B3  2  20 CC F5             JSR     GETPAR          ; get end address in TMP0
00F4B6  2  90 06                BCC     DIS2AD          ; if one was given, skip default
00F4B8  2               DIS0AD:
00F4B8  2  A9 14                LDA     #$14            ; disassemble 14 bytes by default
00F4BA  2  85 C1                STA     TMP0            ; store length in TMP0
00F4BC  2  D0 05                BNE     DISGO           ; skip length calculation
00F4BE  2               DIS2AD:
00F4BE  2  20 F5 F6             JSR     SUB12           ; calculate number of bytes between start and end
00F4C1  2  90 1C                BCC     DERROR          ; error if end address is before start address
00F4C3  2               DISGO:
00F4C3  2  20 11 F8             JSR     CLINE           ; clear the current line
00F4C6  2  20 38 F8             JSR     STOP            ; check for stop key
00F4C9  2  F0 11                BEQ     DISEXIT         ; exit early if pressed
00F4CB  2  20 E2 F4             JSR     DSOUT1          ; output disassembly prefix ". "
00F4CE  2  E6 C6                INC     LENGTH
00F4D0  2  A5 C6                LDA     LENGTH          ; add length of last instruction to start address
00F4D2  2  20 25 F7             JSR     BUMPAD2
00F4D5  2  A5 C6                LDA     LENGTH          ; subtract length of last inst from end address
00F4D7  2  20 05 F7             JSR     SUBA2
00F4DA  2  B0 E7                BCS     DISGO
00F4DC  2               DISEXIT:
00F4DC  2  4C B7 F0             JMP     STRT            ; back to mainloop
00F4DF  2               DERROR:
00F4DF  2  4C 06 F1             JMP     ERROR
00F4E2  2               
00F4E2  2               DSOUT1:
00F4E2  2  A9 2E                LDA     #'.'            ; output ". " prefix to allow edit and reassemble
00F4E4  2  20 76 FA             JSR     CHROUT
00F4E7  2  20 90 F6             JSR     SPACE
00F4EA  2               
00F4EA  2               DISLIN:
00F4EA  2  20 83 F6             JSR     SHOWAD          ; show the address of the instruction
00F4ED  2  20 90 F6             JSR     SPACE           ; insert a space
00F4F0  2  A0 00                LDY     #0              ; no offset
00F4F2  2  B1 C3                LDA     (TMP2),Y        ; load operand of current instruction
00F4F4  2  20 62 F5             JSR     INSTXX          ; get mnemonic and addressing mode for opcode
00F4F7  2  48                   PHA                     ; save index into mnemonic table
00F4F8  2  A6 C6                LDX     LENGTH          ; get length of operand
00F4FA  2  E8                   INX                     ; add 1 byte for opcode
00F4FB  2               DSBYT:
00F4FB  2  CA                   DEX                     ; decrement index
00F4FC  2  10 0C                BPL     DSHEX           ; show hex for byte being disassembled
00F4FE  2  84 BA                STY     SAVY            ; save index
00F500  2  A0 30                LDY     #MSG8-MSGBAS    ; skip 3 spaces
00F502  2  20 2A F8             JSR     SNDMSG
00F505  2  A4 BA                LDY     SAVY            ; restore index
00F507  2  4C 0F F5             JMP     NXBYT
00F50A  2               DSHEX:
00F50A  2  B1 C3                LDA     (TMP2),Y        ; show hex for byte
00F50C  2  20 8D F6             JSR     WRBYTE
00F50F  2               
00F50F  2               NXBYT:
00F50F  2  C8                   INY                     ; next byte
00F510  2  C0 03                CPY     #3              ; have we output 3 bytes yet?
00F512  2  90 E7                BCC     DSBYT           ; if not, loop
00F514  2  68                   PLA                     ; restore index into mnemonic table
00F515  2  A2 03                LDX     #3              ; 3 letters in mnemonic
00F517  2  20 A8 F5             JSR     PROPXX          ; print mnemonic
00F51A  2  A2 06                LDX     #6              ; 6 possible address mode character combos
00F51C  2               PRADR1:
00F51C  2  E0 03                CPX     #3              ; have we checked the third combo yet?
00F51E  2  D0 14                BNE     PRADR3          ; if so, output the leading characters
00F520  2  A4 C6                LDY     LENGTH          ; get the length of the operand
00F522  2  F0 10                BEQ     PRADR3          ; if it's zero, there's no operand to print
00F524  2               PRADR2:
00F524  2  A5 C5                LDA     ACMD            ; otherwise, get the addressing mode
00F526  2  C9 E8                CMP     #$E8            ; check for relative addressing
00F528  2  08                   PHP                     ; save result of check
00F529  2  B1 C3                LDA     (TMP2),Y        ; get the operand
00F52B  2  28                   PLP                     ; restore result of check
00F52C  2  B0 1C                BCS     RELAD           ; handle a relative address
00F52E  2  20 B1 F6             JSR     WRTWO           ; output digits from address
00F531  2  88                   DEY
00F532  2  D0 F0                BNE     PRADR2          ; repeat for next byte of operand, if there is one
00F534  2               PRADR3:
00F534  2  06 C5                ASL     ACMD            ; check whether addr mode uses the current char
00F536  2  90 0E                BCC     PRADR4          ; if not, skip it
00F538  2  BD 49 F9             LDA     CHAR1-1,X       ; look up the first char in the table
00F53B  2  20 76 FA             JSR     CHROUT          ; print first char
00F53E  2  BD 4F F9             LDA     CHAR2-1,X       ; look up the second char in the table
00F541  2  F0 03                BEQ     PRADR4          ; if there's no second character, skip it
00F543  2  20 76 FA             JSR     CHROUT          ; print second char
00F546  2               PRADR4:
00F546  2  CA                   DEX                     ; next potential address mode character
00F547  2  D0 D3                BNE     PRADR1          ; loop if we haven't checked them all yet
00F549  2  60                   RTS                     ; back to caller
00F54A  2               RELAD:
00F54A  2  20 56 F5             JSR     UB64D           ; calculate absolute address from relative
00F54D  2  18                   CLC
00F54E  2  69 01                ADC     #1              ; adjust address relative to next instruction
00F550  2  D0 01                BNE     RELEND          ; don't increment high byte unless we overflowed
00F552  2  E8                   INX                     ; increment high byte
00F553  2               RELEND:
00F553  2  4C 87 F6             JMP     WRADDR          ; print address
00F556  2               
00F556  2               UB64D:
00F556  2  A6 C4                LDX     TMP2+1          ; get high byte of current address
00F558  2  A8                   TAY                     ; is relative address positive or negative?
00F559  2  10 01                BPL     RELC2           ; if positive, leave high byte alone
00F55B  2  CA                   DEX                     ; if negative, decrement high byte
00F55C  2               RELC2:
00F55C  2  65 C3                ADC     TMP2            ; add relative address to low byte
00F55E  2  90 01                BCC     RELC3           ; if there's no carry, we're done
00F560  2  E8                   INX                     ; if there's a carry, increment the high byte
00F561  2               RELC3:
00F561  2  60                   RTS
00F562  2               
00F562  2               ; -----------------------------------------------------------------------------
00F562  2               ; get opcode mode and length
00F562  2               
00F562  2               ; Note: the labels are different, but the code of this subroutine is almost
00F562  2               ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
00F562  2               ; the Apple II Red Book. I'm not sure exactly where this code originated
00F562  2               ; (MOS or Apple) but it's clear that this part of Supermon64 and the
00F562  2               ; Mini-Asssembler share a common heritage.  The comments showing the way the
00F562  2               ; opcodes are transformed into indexes for the mnemonic lookup table come
00F562  2               ; from the Mini-Assembler source.
00F562  2               
00F562  2               INSTXX:
00F562  2  A8                   TAY                     ; stash opcode in accumulator in Y for later
00F563  2  4A                   LSR     A               ; is opcode even or odd?
00F564  2  90 0B                BCC     IEVEN
00F566  2  4A                   LSR     A
00F567  2  B0 17                BCS     ERR             ; invalid opcodes XXXXXX11
00F569  2  C9 22                CMP     #$22
00F56B  2  F0 13                BEQ     ERR             ; invalid opcode 10001001
00F56D  2  29 07                AND     #$07            ; mask bits to 10000XXX
00F56F  2  09 80                ORA     #$80
00F571  2               IEVEN:
00F571  2  4A                   LSR     A               ; LSB determines whether to use left/right nybble
00F572  2  AA                   TAX                     ; get format index using remaining high bytes
00F573  2  BD F8 F8             LDA     MODE,X
00F576  2  B0 04                BCS     RTMODE          ; look at left or right nybble based on carry bit
00F578  2  4A                   LSR     A               ; if carry = 0, use left nybble
00F579  2  4A                   LSR     A
00F57A  2  4A                   LSR     A
00F57B  2  4A                   LSR     A
00F57C  2               RTMODE:
00F57C  2  29 0F                AND     #$0F            ; if carry = 1, use right nybble
00F57E  2  D0 04                BNE     GETFMT
00F580  2               ERR:
00F580  2  A0 80                LDY     #$80            ; substitute 10000000 for invalid opcodes
00F582  2  A9 00                LDA     #0
00F584  2               GETFMT:
00F584  2  AA                   TAX
00F585  2  BD 3C F9             LDA     MODE2,X         ; lookup operand format using selected nybble
00F588  2  85 C5                STA     ACMD            ; save for later use
00F58A  2  29 03                AND     #$03            ; lower 2 bits indicate number of bytes in operand
00F58C  2  85 C6                STA     LENGTH
00F58E  2  98                   TYA                     ; restore original opcode
00F58F  2  29 8F                AND     #$8F            ; mask bits to X000XXXX
00F591  2  AA                   TAX                     ; save it
00F592  2  98                   TYA                     ; restore original opcode
00F593  2  A0 03                LDY     #3
00F595  2  E0 8A                CPX     #$8A            ; check if opcode = 1XXX1010
00F597  2  F0 0B                BEQ     GTFM4
00F599  2               GTFM2:
00F599  2  4A                   LSR     A               ; transform opcode into index for mnemonic table
00F59A  2  90 08                BCC     GTFM4
00F59C  2  4A                   LSR     A               ; opcodes transformed as follows:
00F59D  2               GTFM3:
00F59D  2  4A                   LSR     A               ; 1XXX1010->00101XXX
00F59E  2  09 20                ORA     #$20            ; XXXYYY01->00111XXX
00F5A0  2  88                   DEY                     ; XXXYYY10->00111XXX
00F5A1  2  D0 FA                BNE     GTFM3           ; XXXYY100->00110XXX
00F5A3  2  C8                   INY                     ; XXXXX000->000XXXXX
00F5A4  2               GTFM4:
00F5A4  2  88                   DEY
00F5A5  2  D0 F2                BNE     GTFM2
00F5A7  2  60                   RTS
00F5A8  2               
00F5A8  2               ; -----------------------------------------------------------------------------
00F5A8  2               ; extract and print packed mnemonics
00F5A8  2               PROPXX:
00F5A8  2  A8                   TAY                     ; use index in accumulator to look up mnemonic
00F5A9  2  B9 56 F9             LDA     MNEML,Y         ;   and place a temporary copy in STORE
00F5AC  2  85 B7                STA     STORE
00F5AE  2  B9 96 F9             LDA     MNEMR,Y
00F5B1  2  85 B8                STA     STORE+1
00F5B3  2               PRMN1:
00F5B3  2  A9 00                LDA     #0              ; clear accumulator
00F5B5  2  A0 05                LDY     #$05            ; shift 5 times
00F5B7  2               PRMN2:
00F5B7  2  06 B8                ASL     STORE+1         ; shift right byte
00F5B9  2  26 B7                ROL     STORE           ; rotate bits from right byte into left byte
00F5BB  2  2A                   ROL     A               ; rotate bits from left byte into accumulator
00F5BC  2  88                   DEY                     ; next bit
00F5BD  2  D0 F8                BNE     PRMN2           ; loop until all bits shifted
00F5BF  2  69 3F                ADC     #$3F            ; calculate ascii code for letter by adding to '?'
00F5C1  2  20 76 FA             JSR     CHROUT          ; output letter
00F5C4  2  CA                   DEX                     ; next letter
00F5C5  2  D0 EC                BNE     PRMN1           ; loop until all 3 letters are output
00F5C7  2  4C 90 F6             JMP     SPACE           ; output space
00F5CA  2               
00F5CA  2               ; -----------------------------------------------------------------------------
00F5CA  2               ; read parameters
00F5CA  2               RDPAR:
00F5CA  2  C6 B9                DEC     CHRPNT          ; back up one char
00F5CC  2               GETPAR:
00F5CC  2  20 F1 F5             JSR     RDVAL           ; read the value
00F5CF  2  B0 15                BCS     GTERR           ; carry set indicates error
00F5D1  2  20 D4 F6             JSR     GOTCHR          ; check previous character
00F5D4  2  D0 08                BNE     CKTERM          ; if it's not null, check if it's a valid separator
00F5D6  2  C6 B9                DEC     CHRPNT          ; back up one char
00F5D8  2  A5 CB                LDA     DIGCNT          ; get number of digits read
00F5DA  2  D0 11                BNE     GETGOT          ; found some digits
00F5DC  2  F0 0D                BEQ     GTNIL           ; didn't find any digits
00F5DE  2               CKTERM:
00F5DE  2  C9 20                CMP     #$20            ; space or comma are valid separators
00F5E0  2  F0 0B                BEQ     GETGOT          ; anything else is an error
00F5E2  2  C9 2C                CMP     #','
00F5E4  2  F0 07                BEQ     GETGOT
00F5E6  2               GTERR:
00F5E6  2  68                   PLA                     ; encountered error
00F5E7  2  68                   PLA                     ; get rid of command vector pushed on stack
00F5E8  2  4C 06 F1             JMP     ERROR           ; handle error
00F5EB  2               GTNIL:
00F5EB  2  38                   SEC                     ; set carry to indicate no parameter found
00F5EC  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00F5ED  2               GETGOT:
00F5ED  2  18                   CLC                     ; clear carry to indicate paremeter returned
00F5EE  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
00F5F0  2  60                   RTS                     ; return to address pushed from vector table
00F5F1  2               
00F5F1  2               ; -----------------------------------------------------------------------------
00F5F1  2               ; read a value in the specified base
00F5F1  2               RDVAL:
00F5F1  2  A9 00                LDA     #0              ; clear temp
00F5F3  2  85 C1                STA     TMP0
00F5F5  2  85 C2                STA     TMP0+1
00F5F7  2  85 CB                STA     DIGCNT          ; clear digit counter
00F5F9  2  8A                   TXA                     ; save X and Y
00F5FA  2  48                   PHA
00F5FB  2  98                   TYA
00F5FC  2  48                   PHA
00F5FD  2               RDVMOR:
00F5FD  2  20 D6 F6             JSR     GETCHR          ; get next character from input buffer
00F600  2  F0 1C                BEQ     RDNILK          ; null at end of buffer
00F602  2  C9 20                CMP     #$20            ; skip spaces
00F604  2  F0 F7                BEQ     RDVMOR
00F606  2  A2 03                LDX     #3              ; check numeric base [$+&%]
00F608  2               GNMODE:
00F608  2  DD E9 F9             CMP     HIKEY,X
00F60B  2  F0 06                BEQ     GOTMOD          ; got a match, set up base
00F60D  2  CA                   DEX
00F60E  2  10 F8                BPL     GNMODE          ; check next base
00F610  2  E8                   INX                     ; default to hex
00F611  2  C6 B9                DEC     CHRPNT          ; back up one character
00F613  2               GOTMOD:
00F613  2  BC 0B FA             LDY     MODTAB,X        ; get base value
00F616  2  BD 0F FA             LDA     LENTAB,X        ; get bits per digit
00F619  2  85 CD                STA     NUMBIT          ; store bits per digit
00F61B  2               NUDIG:
00F61B  2  20 D6 F6             JSR     GETCHR          ; get next char in A
00F61E  2               RDNILK:
00F61E  2  F0 59                BEQ     RDNIL           ; end of number if no more characters
00F620  2  38                   SEC
00F621  2  E9 30                SBC     #$30            ; subtract ascii value of 0 to get numeric value
00F623  2  90 54                BCC     RDNIL           ; end of number if character was less than 0
00F625  2  C9 0A                CMP     #$0A
00F627  2  90 06                BCC     DIGMOR          ; not a hex digit if less than A
00F629  2  E9 07                SBC     #$07            ; 7 chars between ascii 9 and A, so subtract 7
00F62B  2  C9 10                CMP     #$10            ; end of number if char is greater than F
00F62D  2  B0 4A                BCS     RDNIL
00F62F  2               DIGMOR:
00F62F  2  85 CC                STA     INDIG           ; store the digit
00F631  2  C4 CC                CPY     INDIG           ; compare base with the digit
00F633  2  90 42                BCC     RDERR           ; error if the digit >= the base
00F635  2  F0 40                BEQ     RDERR
00F637  2  E6 CB                INC     DIGCNT          ; increment the number of digits
00F639  2  C0 0A                CPY     #10
00F63B  2  D0 09                BNE     NODECM          ; skip the next part if not using base 10
00F63D  2  A2 01                LDX     #1
00F63F  2               DECLP1:
00F63F  2  B5 C1                LDA     TMP0,X          ; stash the previous 16-bit value for later use
00F641  2  95 CE                STA     STASH,X
00F643  2  CA                   DEX
00F644  2  10 F9                BPL     DECLP1
00F646  2               NODECM:
00F646  2  A6 CD                LDX     NUMBIT          ; number of bits to shift
00F648  2               TIMES2:
00F648  2  06 C1                ASL     TMP0            ; shift 16-bit value by specified number of bits
00F64A  2  26 C2                ROL     TMP0+1
00F64C  2  B0 29                BCS     RDERR           ; error if we overflowed 16 bits
00F64E  2  CA                   DEX
00F64F  2  D0 F7                BNE     TIMES2          ; shift remaining bits
00F651  2  C0 0A                CPY     #10
00F653  2  D0 14                BNE     NODEC2          ; skip the next part if not using base 10
00F655  2  06 CE                ASL     STASH           ; shift the previous 16-bit value one bit left
00F657  2  26 CF                ROL     STASH+1
00F659  2  B0 1C                BCS     RDERR           ; error if we overflowed 16 bits
00F65B  2  A5 CE                LDA     STASH           ; add shifted previous value to current value
00F65D  2  65 C1                ADC     TMP0
00F65F  2  85 C1                STA     TMP0
00F661  2  A5 CF                LDA     STASH+1
00F663  2  65 C2                ADC     TMP0+1
00F665  2  85 C2                STA     TMP0+1
00F667  2  B0 0E                BCS     RDERR           ; error if we overflowed 16 bits
00F669  2               NODEC2:
00F669  2  18                   CLC
00F66A  2  A5 CC                LDA     INDIG           ; load current digit
00F66C  2  65 C1                ADC     TMP0            ; add current digit to low byte
00F66E  2  85 C1                STA     TMP0            ; and store result back in low byte
00F670  2  8A                   TXA                     ; A=0
00F671  2  65 C2                ADC     TMP0+1          ; add carry to high byte
00F673  2  85 C2                STA     TMP0+1          ; and store result back in high byte
00F675  2  90 A4                BCC     NUDIG           ; get next digit if we didn't overflow
00F677  2               RDERR:
00F677  2  38                   SEC                     ; set carry to indicate error
00F678  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00F679  2               RDNIL:
00F679  2  18                   CLC                     ; clear carry to indicate success
00F67A  2  84 CD                STY     NUMBIT          ; save base of number
00F67C  2  68                   PLA                     ; restore X and Y
00F67D  2  A8                   TAY
00F67E  2  68                   PLA
00F67F  2  AA                   TAX
00F680  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
00F682  2  60                   RTS
00F683  2               
00F683  2               ; -----------------------------------------------------------------------------
00F683  2               ; print address
00F683  2               SHOWAD:
00F683  2  A5 C3                LDA     TMP2
00F685  2  A6 C4                LDX     TMP2+1
00F687  2               
00F687  2               WRADDR:
00F687  2  48                   PHA                     ; save low byte
00F688  2  8A                   TXA                     ; put high byte in A
00F689  2  20 B1 F6             JSR     WRTWO           ; output high byte
00F68C  2  68                   PLA                     ; restore low byte
00F68D  2               
00F68D  2               WRBYTE:
00F68D  2  20 B1 F6             JSR     WRTWO           ; output byte in A
00F690  2               
00F690  2               SPACE:
00F690  2  A9 20                LDA     #$20            ; output space
00F692  2  D0 0F                BNE     FLIP
00F694  2               
00F694  2               CHOUT:
00F694  2  C9 0D                CMP     #$0D            ; output char with special handling of CR
00F696  2  D0 0B                BNE     FLIP
00F698  2               CRLF:
00F698  2  A9 0D                LDA     #$0D            ; load CR in A
00F69A  2  24 13                BIT     $13             ; check default channel
00F69C  2  10 05                BPL     FLIP            ; if high bit is clear output CR only
00F69E  2  20 76 FA             JSR     CHROUT          ; otherwise output CR+LF
00F6A1  2  A9 0A                LDA     #$0A            ; output LF
00F6A3  2               FLIP:
00F6A3  2  4C 76 FA             JMP     CHROUT
00F6A6  2               
00F6A6  2               FRESH:
00F6A6  2  20 98 F6             JSR     CRLF            ; output CR
00F6A9  2  A9 20                LDA     #$20            ; load space in A
00F6AB  2  20 76 FA             JSR     CHROUT
00F6AE  2  4C 1A F8             JMP     SNCLR
00F6B1  2               
00F6B1  2               ; -----------------------------------------------------------------------------
00F6B1  2               ; output two hex digits for byte
00F6B1  2               WRTWO:
00F6B1  2  86 CA                STX     SAVX            ; save X
00F6B3  2  20 BF F6             JSR     ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
00F6B6  2  20 76 FA             JSR     CHROUT          ; output upper nybble
00F6B9  2  8A                   TXA                     ; transfer lower to A
00F6BA  2  A6 CA                LDX     SAVX            ; restore X
00F6BC  2  4C 76 FA             JMP     CHROUT          ; output lower nybble
00F6BF  2               
00F6BF  2               ; -----------------------------------------------------------------------------
00F6BF  2               ; convert byte in A to hex digits
00F6BF  2               ASCTWO:
00F6BF  2  48                   PHA                     ; save byte
00F6C0  2  20 C9 F6             JSR     ASCII           ; do low nybble
00F6C3  2  AA                   TAX                     ; save in X
00F6C4  2  68                   PLA                     ; restore byte
00F6C5  2  4A                   LSR     A               ; shift upper nybble down
00F6C6  2  4A                   LSR     A
00F6C7  2  4A                   LSR     A
00F6C8  2  4A                   LSR     A
00F6C9  2               
00F6C9  2               ; convert low nybble in A to hex digit
00F6C9  2               ASCII:
00F6C9  2  29 0F                AND     #$0F            ; clear upper nibble
00F6CB  2  C9 0A                CMP     #$0A            ; if less than A, skip next step
00F6CD  2  90 02                BCC     ASC1
00F6CF  2  69 06                ADC     #6              ; skip ascii chars between 9 and A
00F6D1  2               ASC1:
00F6D1  2  69 30                ADC     #$30            ; add ascii char 0 to value
00F6D3  2  60                   RTS
00F6D4  2               
00F6D4  2               ; -----------------------------------------------------------------------------
00F6D4  2               ; get prev char from input buffer
00F6D4  2               GOTCHR:
00F6D4  2  C6 B9                DEC     CHRPNT
00F6D6  2               
00F6D6  2               ; get next char from input buffer
00F6D6  2               GETCHR:
00F6D6  2  86 CA                STX     SAVX
00F6D8  2  A6 B9                LDX     CHRPNT          ; get pointer to next char
00F6DA  2  BD 00 02             LDA     INBUFF,X        ; load next char in A
00F6DD  2  F0 06                BEQ     NOCHAR          ; null, :, or ? signal end of buffer
00F6DF  2  C9 3A                CMP     #':'
00F6E1  2  F0 02                BEQ     NOCHAR
00F6E3  2  C9 3F                CMP     #'?'
00F6E5  2               NOCHAR:
00F6E5  2  08                   PHP
00F6E6  2  E6 B9                INC     CHRPNT          ; next char
00F6E8  2  A6 CA                LDX     SAVX
00F6EA  2  28                   PLP                     ; Z flag will signal last character
00F6EB  2  60                   RTS
00F6EC  2               
00F6EC  2               ; -----------------------------------------------------------------------------
00F6EC  2               ; copy TMP0 to TMP2
00F6EC  2               COPY12:
00F6EC  2  A5 C1                LDA     TMP0            ; low byte
00F6EE  2  85 C3                STA     TMP2
00F6F0  2  A5 C2                LDA     TMP0+1          ; high byte
00F6F2  2  85 C4                STA     TMP2+1
00F6F4  2  60                   RTS
00F6F5  2               
00F6F5  2               ; -----------------------------------------------------------------------------
00F6F5  2               ; subtract TMP2 from TMP0
00F6F5  2               SUB12:
00F6F5  2  38                   SEC
00F6F6  2  A5 C1                LDA     TMP0            ; subtract low byte
00F6F8  2  E5 C3                SBC     TMP2
00F6FA  2  85 C1                STA     TMP0
00F6FC  2  A5 C2                LDA     TMP0+1
00F6FE  2  E5 C4                SBC     TMP2+1          ; subtract high byte
00F700  2  85 C2                STA     TMP0+1
00F702  2  60                   RTS
00F703  2               
00F703  2               ; -----------------------------------------------------------------------------
00F703  2               ; subtract from TMP0
00F703  2               SUBA1:
00F703  2  A9 01                LDA     #1              ; shortcut to decrement by 1
00F705  2               SUBA2:
00F705  2  85 CA                STA     SAVX            ; subtrahend in accumulator
00F707  2  38                   SEC
00F708  2  A5 C1                LDA     TMP0            ; minuend in low byte
00F70A  2  E5 CA                SBC     SAVX
00F70C  2  85 C1                STA     TMP0
00F70E  2  A5 C2                LDA     TMP0+1          ; borrow from high byte
00F710  2  E9 00                SBC     #0
00F712  2  85 C2                STA     TMP0+1
00F714  2  60                   RTS
00F715  2               
00F715  2               ; -----------------------------------------------------------------------------
00F715  2               ; subtract 1 from STORE
00F715  2               SUB13:
00F715  2  38                   SEC
00F716  2  A5 B7                LDA     STORE
00F718  2  E9 01                SBC     #1              ; decrement low byte
00F71A  2  85 B7                STA     STORE
00F71C  2  A5 B8                LDA     STORE+1
00F71E  2  E9 00                SBC     #0              ; borrow from high byte
00F720  2  85 B8                STA     STORE+1
00F722  2  60                   RTS
00F723  2               
00F723  2               ; -----------------------------------------------------------------------------
00F723  2               ; add to TMP2
00F723  2               ADDA2:
00F723  2  A9 01                LDA     #1              ; shortcut to increment by 1
00F725  2               BUMPAD2:
00F725  2  18                   CLC
00F726  2  65 C3                ADC     TMP2            ; add value in accumulator to low byte
00F728  2  85 C3                STA     TMP2
00F72A  2  90 02                BCC     BUMPEX
00F72C  2  E6 C4                INC     TMP2+1          ; carry to high byte
00F72E  2               BUMPEX:
00F72E  2  60                   RTS
00F72F  2               
00F72F  2               ; -----------------------------------------------------------------------------
00F72F  2               ; subtract 1 from TMP2
00F72F  2               SUB21:
00F72F  2  38                   SEC
00F730  2  A5 C3                LDA     TMP2            ; decrement low byte
00F732  2  E9 01                SBC     #1
00F734  2  85 C3                STA     TMP2
00F736  2  A5 C4                LDA     TMP2+1          ; borrow from high byte
00F738  2  E9 00                SBC     #0
00F73A  2  85 C4                STA     TMP2+1
00F73C  2  60                   RTS
00F73D  2               
00F73D  2               ; -----------------------------------------------------------------------------
00F73D  2               ; copy TMP0 to PC
00F73D  2               COPY1P:
00F73D  2  B0 08                BCS     CPY1PX          ; do nothing if parameter is empty
00F73F  2  A5 C1                LDA     TMP0            ; copy low byte
00F741  2  A4 C2                LDY     TMP0+1          ; copy high byte
00F743  2  85 B1                STA     PCL
00F745  2  84 B0                STY     PCH
00F747  2               CPY1PX:
00F747  2  60                   RTS
00F748  2               
00F748  2               ; -----------------------------------------------------------------------------
00F748  2               ; get start/end addresses and calc difference
00F748  2               GETDIF:
00F748  2  B0 1F                BCS     GDIFX           ; exit with error if no parameter given
00F74A  2  20 EC F6             JSR     COPY12          ; save start address in TMP2
00F74D  2  20 CC F5             JSR     GETPAR          ; get end address in TMP0
00F750  2  B0 17                BCS     GDIFX           ; exit with error if no parameter given
00F752  2  A5 C1                LDA     TMP0            ; save end address in STASH
00F754  2  85 CE                STA     STASH
00F756  2  A5 C2                LDA     TMP0+1
00F758  2  85 CF                STA     STASH+1
00F75A  2  20 F5 F6             JSR     SUB12           ; subtract start address from end address
00F75D  2  A5 C1                LDA     TMP0
00F75F  2  85 B7                STA     STORE           ; save difference in STORE
00F761  2  A5 C2                LDA     TMP0+1
00F763  2  85 B8                STA     STORE+1
00F765  2  90 02                BCC     GDIFX           ; error if start address is after end address
00F767  2  18                   CLC                     ; clear carry to indicate success
00F768  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (SEC)
00F769  2               GDIFX:
00F769  2  38                   SEC                     ; set carry to indicate error
00F76A  2  60                   RTS
00F76B  2               
00F76B  2               ; -----------------------------------------------------------------------------
00F76B  2               ; convert base [$+&%]
00F76B  2               CONVRT:
00F76B  2  20 CA F5             JSR     RDPAR           ; read a parameter
00F76E  2  20 A6 F6             JSR     FRESH           ; next line and clear
00F771  2  A9 24                LDA     #'$'            ; output $ sigil for hex
00F773  2  20 76 FA             JSR     CHROUT
00F776  2  A5 C1                LDA     TMP0            ; load the 16-bit value entered
00F778  2  A6 C2                LDX     TMP0+1
00F77A  2  20 87 F6             JSR     WRADDR          ; print it in 4 hex digits
00F77D  2  20 A6 F6             JSR     FRESH
00F780  2  A9 2B                LDA     #'+'            ; output + sigil for decimal
00F782  2  20 76 FA             JSR     CHROUT
00F785  2  20 B6 F7             JSR     CVTDEC          ; convert to BCD using hardware mode
00F788  2  A9 00                LDA     #0              ; clear digit counter
00F78A  2  A2 06                LDX     #6              ; max digits + 1
00F78C  2  A0 03                LDY     #3              ; bits per digit - 1
00F78E  2  20 E9 F7             JSR     NMPRNT          ; print result without leading zeros
00F791  2  20 A6 F6             JSR     FRESH           ; next line and clear
00F794  2  A9 26                LDA     #'&'            ; print & sigil for octal
00F796  2  20 76 FA             JSR     CHROUT
00F799  2  A9 00                LDA     #0              ; clear digit counter
00F79B  2  A2 08                LDX     #8              ; max digits + 1
00F79D  2  A0 02                LDY     #2              ; bits per digit - 1
00F79F  2  20 DB F7             JSR     PRINUM          ; output number
00F7A2  2  20 A6 F6             JSR     FRESH           ; next line and clear
00F7A5  2  A9 25                LDA     #'%'            ; print % sigil for binary
00F7A7  2  20 76 FA             JSR     CHROUT
00F7AA  2  A9 00                LDA     #0              ; clear digit counter
00F7AC  2  A2 18                LDX     #$18            ; max digits + 1
00F7AE  2  A0 00                LDY     #0              ; bits per digit - 1
00F7B0  2  20 DB F7             JSR     PRINUM          ; output number
00F7B3  2  4C B7 F0             JMP     STRT            ; back to mainloop
00F7B6  2               
00F7B6  2               ; -----------------------------------------------------------------------------
00F7B6  2               ; convert binary to BCD
00F7B6  2               
00F7B6  2               CVTDEC:
00F7B6  2  20 EC F6             JSR     COPY12          ; copy value from TMP0 to TMP2
00F7B9  2  A9 00                LDA     #0
00F7BB  2  A2 02                LDX     #2              ; clear 3 bytes in work buffer
00F7BD  2               DECML1:
00F7BD  2  95 D0                STA     U0AA0,X
00F7BF  2  CA                   DEX
00F7C0  2  10 FB                BPL     DECML1
00F7C2  2  A0 10                LDY     #16             ; 16 bits in input
00F7C4  2  08                   PHP                     ; save status register
00F7C5  2  78                   SEI                     ; make sure no interrupts occur with BCD enabled
00F7C6  2  F8                   SED
00F7C7  2               DECML2:
00F7C7  2  06 C3                ASL     TMP2            ; rotate bytes out of input low byte
00F7C9  2  26 C4                ROL     TMP2+1          ; .. into high byte and carry bit
00F7CB  2  A2 02                LDX     #2              ; process 3 bytes
00F7CD  2               DECDBL:
00F7CD  2  B5 D0                LDA     U0AA0,X         ; load current value of byte
00F7CF  2  75 D0                ADC     U0AA0,X         ; add it to itself plus the carry bit
00F7D1  2  95 D0                STA     U0AA0,X         ; store it back in the same location
00F7D3  2  CA                   DEX                     ; decrement byte counter
00F7D4  2  10 F7                BPL     DECDBL          ; loop until all bytes processed
00F7D6  2  88                   DEY                     ; decrement bit counter
00F7D7  2  D0 EE                BNE     DECML2          ; loop until all bits processed
00F7D9  2  28                   PLP                     ; restore processor status
00F7DA  2  60                   RTS
00F7DB  2               
00F7DB  2               ; load the input value and fall through to print it
00F7DB  2               PRINUM:
00F7DB  2  48                   PHA                     ; save accumulator
00F7DC  2  A5 C1                LDA     TMP0            ; copy input low byte to work buffer
00F7DE  2  85 D2                STA     U0AA0+2
00F7E0  2  A5 C2                LDA     TMP0+1          ; copy input high byte to work buffer
00F7E2  2  85 D1                STA     U0AA0+1
00F7E4  2  A9 00                LDA     #0              ; clear overflow byte in work buffer
00F7E6  2  85 D0                STA     U0AA0
00F7E8  2  68                   PLA                     ; restore accumulator
00F7E9  2               
00F7E9  2               ; print number in specified base without leading zeros
00F7E9  2               NMPRNT:
00F7E9  2  85 CB                STA     DIGCNT          ; number of digits in accumulator
00F7EB  2  84 CD                STY     NUMBIT          ; bits per digit passed in Y register
00F7ED  2               DIGOUT:
00F7ED  2  A4 CD                LDY     NUMBIT          ; get bits to process
00F7EF  2  A9 00                LDA     #0              ; clear accumulator
00F7F1  2               ROLBIT:
00F7F1  2  06 D2                ASL     U0AA0+2         ; shift bits out of low byte
00F7F3  2  26 D1                ROL     U0AA0+1         ; ... into high byte
00F7F5  2  26 D0                ROL     U0AA0           ; ... into overflow byte
00F7F7  2  2A                   ROL     A               ; ... into accumulator
00F7F8  2  88                   DEY                     ; decrement bit counter
00F7F9  2  10 F6                BPL     ROLBIT          ; loop until all bits processed
00F7FB  2  A8                   TAY                     ; check whether accumulator is 0
00F7FC  2  D0 08                BNE     NZERO           ; if not, print it
00F7FE  2  E0 01                CPX     #1              ; have we output the max number of digits?
00F800  2  F0 04                BEQ     NZERO           ; if not, print it
00F802  2  A4 CB                LDY     DIGCNT          ; how many digits have we output?
00F804  2  F0 07                BEQ     ZERSUP          ; skip output if digit is 0
00F806  2               NZERO:
00F806  2  E6 CB                INC     DIGCNT          ; increment digit counter
00F808  2  09 30                ORA     #$30            ; add numeric value to ascii '0' to get ascii char
00F80A  2  20 76 FA             JSR     CHROUT          ; output character
00F80D  2               ZERSUP:
00F80D  2  CA                   DEX                     ; decrement number of leading zeros
00F80E  2  D0 DD                BNE     DIGOUT          ; next digit
00F810  2  60                   RTS
00F811  2               
00F811  2               
00F811  2               ; -----------------------------------------------------------------------------
00F811  2               ; print and clear routines
00F811  2               CLINE:
00F811  2  20 98 F6             JSR     CRLF
00F814  2  4C 1A F8             JMP     SNCLR           ; clear line
00F817  2               SNDCLR:
00F817  2  20 2A F8             JSR     SNDMSG
00F81A  2               SNCLR:
00F81A  2  A0 28                LDY     #$28            ; loop 40 times
00F81C  2               SNCLP:
00F81C  2  A9 20                LDA     #$20            ; output space character
00F81E  2  20 76 FA             JSR     CHROUT
00F821  2  88                   DEY
00F822  2  D0 F8                BNE     SNCLP
00F824  2  A9 0D                LDA     #13             ; output CR
00F826  2  20 76 FA             JSR     CHROUT          ; send CR
00F829  2  60                   RTS
00F82A  2               
00F82A  2               ; -----------------------------------------------------------------------------
00F82A  2               ; display message from table
00F82A  2               SNDMSG:
00F82A  2  B9 C5 F8             LDA     MSGBAS,Y        ; Y contains offset in msg table
00F82D  2  08                   PHP
00F82E  2  29 7F                AND     #$7F            ; strip high bit before output
00F830  2  20 94 F6             JSR     CHOUT
00F833  2  C8                   INY
00F834  2  28                   PLP
00F835  2  10 F3                BPL     SNDMSG          ; loop until high bit is set
00F837  2  60                   RTS
00F838  2               
00F838  2               ; -----------------------------------------------------------------------------
00F838  2               ; check for stop key
00F838  2               STOP:
00F838  2  20 6F FA             JSR     IOF_CONIN
00F83B  2  C9 03                CMP     #$03
00F83D  2  F0 03                BEQ     :+
00F83F  2  A9 FF                LDA     #$FF
00F841  2  60                   RTS
00F842  2               :
00F842  2  A9 00                LDA     #$00
00F844  2  60                   RTS
00F845  2               
00F845  2               ; -----------------------------------------------------------------------------
00F845  2               ; LOAD A MOTOROLA FORMATTED HEX FILE
00F845  2               LOADS19:
00F845  2  20 68 FA             JSR     IOF_CONINW      ;
00F848  2  C9 53                CMP     #'S'            ;
00F84A  2  D0 F9                BNE     LOADS19         ; FIRST CHAR NOT (S)
00F84C  2  20 68 FA             JSR     IOF_CONINW      ; READ CHAR
00F84F  2  C9 39                CMP     #'9'            ;
00F851  2  F0 33                BEQ     LOAD21          ;
00F853  2  C9 31                CMP     #'1'            ;
00F855  2  D0 EE                BNE     LOADS19         ; SECOND CHAR NOT (1)
00F857  2  A9 00                LDA     #$00            ;
00F859  2  85 BC                STA     CKSM            ; ZERO CHECKSUM
00F85B  2  20 87 F8             JSR     S19GETBYTE      ; READ BYTE
00F85E  2  E9 01                SBC     #$01            ;
00F860  2  85 CB                STA     DIGCNT          ; BYTE COUNT
00F862  2  20 B4 F8             JSR     BADDR           ; BUILD ADDRESS
00F865  2  A0 00                LDY     #$00            ;
00F867  2               LOAD11:
00F867  2  20 87 F8             JSR     S19GETBYTE      ;
00F86A  2  C6 CB                DEC     DIGCNT          ;
00F86C  2  F0 0F                BEQ     LOAD15          ; ZERO BYTE COUNT
00F86E  2  91 BD                STA     (LOADADR),Y     ; STORE DATA
00F870  2  E6 BD                INC     LOADADR         ; INCREMENT LOWBYTE
00F872  2  A5 BD                LDA     LOADADR
00F874  2  C9 00                CMP     #$00
00F876  2  D0 EF                BNE     LOAD11          ; NOT ZERO?, LOOP
00F878  2  E6 BE                INC     LOADADR+1       ; ZERO, INC HIGH BYTE
00F87A  2  4C 67 F8             JMP     LOAD11          ;
00F87D  2               
00F87D  2               LOAD15:
00F87D  2  E6 BC                INC     CKSM            ;
00F87F  2  F0 C4                BEQ     LOADS19         ;
00F881  2               LOAD19:
00F881  2  A9 3F                LDA     #'?'            ;
00F883  2  20 76 FA             JSR     IOF_OUTCH       ;
00F886  2               LOAD21:
00F886  2  60                   RTS
00F887  2               S19GETBYTE:
00F887  2  20 9F F8             JSR     INHEX           ; GET HEX CHAR
00F88A  2  0A                   ASL                     ;
00F88B  2  0A                   ASL                     ;
00F88C  2  0A                   ASL                     ;
00F88D  2  0A                   ASL                     ;
00F88E  2  85 BF                STA     LOADWRK         ;
00F890  2  20 9F F8             JSR     INHEX           ;
00F893  2  29 0F                AND     #$0F            ; MASK TO 4 BITS
00F895  2  05 BF                ORA     LOADWRK         ;
00F897  2  48                   PHA                     ;
00F898  2  18                   CLC                     ;
00F899  2  65 BC                ADC     CKSM            ;
00F89B  2  85 BC                STA     CKSM            ;
00F89D  2  68                   PLA                     ;
00F89E  2  60                   RTS                     ;
00F89F  2               ; INPUT HEX CHAR
00F89F  2               INHEX:
00F89F  2  20 68 FA             JSR     IOF_CONINW      ;
00F8A2  2  48                   PHA                     ;
00F8A3  2  20 76 FA             JSR     IOF_OUTCH       ;
00F8A6  2  68                   PLA                     ;
00F8A7  2  C9 3A                CMP     #$3A            ; LESS THAN 9?
00F8A9  2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00F8AB  2  E9 2F                SBC     #$2F            ; CONVERT 0-9
00F8AD  2               INHEX_BIG:
00F8AD  2  C9 41                CMP     #$41            ; A OR MORE?
00F8AF  2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
00F8B1  2  E9 37                SBC     #$37            ; CONVERT A-F
00F8B3  2               INHEX_SMALL:
00F8B3  2  60                   RTS                     ;
00F8B4  2               ; BUILD ADDRESS
00F8B4  2               BADDR:
00F8B4  2  20 87 F8             JSR     S19GETBYTE      ; READ 2 FRAMES
00F8B7  2  85 BE                STA     LOADADR+1       ;
00F8B9  2  20 87 F8             JSR     S19GETBYTE      ;
00F8BC  2  85 BD                STA     LOADADR         ;
00F8BE  2  60                   RTS
00F8BF  2               LOAD:
00F8BF  2  20 45 F8             JSR     LOADS19
00F8C2  2  4C B7 F0             JMP     STRT            ; back to main loop
00F8C5  2               
00F8C5  2               
00F8C5  2               
00F8C5  2               
00F8C5  2               ; -----------------------------------------------------------------------------
00F8C5  2               ; message table; last character has high bit set
00F8C5  2               MSGBAS:
00F8C5  2               
00F8C5  2               MSG2:
00F8C5  2  0D                   .BYTE   $0D             ; header for registers
00F8C6  2  20 20 20 50          .BYTE   "   PC  SR AC XR YR SP   V1.2"
00F8CA  2  43 20 20 53  
00F8CE  2  52 20 41 43  
00F8E2  2  8D                   .BYTE   $0D+$80
00F8E3  2               MSG3:
00F8E3  2  1D BF                .BYTE   $1D,$3F+$80     ; syntax error: move right, display "?"
00F8E5  2               MSG4:
00F8E5  2  2E 2E 53 59          .BYTE   "..SYS"         ; SYS call to enter monitor
00F8E9  2  53           
00F8EA  2  A0                   .BYTE   $20+$80
00F8EB  2               MSG5:
00F8EB  2  3A 92                .BYTE   $3A,$12+$80     ; ":" then RVS ON for memory ASCII dump
00F8ED  2               MSG6:
00F8ED  2  20 45 52 52          .BYTE   " ERRO"         ; I/O error: display " ERROR"
00F8F1  2  4F           
00F8F2  2  D2                   .BYTE   'R'+$80
00F8F3  2               MSG7:
00F8F3  2  41 A0                .BYTE   $41,$20+$80     ; assemble next instruction: "A " + addr
00F8F5  2               MSG8:
00F8F5  2  20 20                .BYTE   "  "            ; pad non-existent byte: skip 3 spaces
00F8F7  2  A0                   .BYTE   $20+$80
00F8F8  2               
00F8F8  2               ; -----------------------------------------------------------------------------
00F8F8  2               ; addressing mode table - nybbles provide index into MODE2 table
00F8F8  2               ; for opcodes XXXXXXY0, use XXXXXX as index into table
00F8F8  2               ; for opcodes WWWXXY01  use $40 + XX as index into table
00F8F8  2               ; use right nybble if Y=0; use left nybble if Y=1
00F8F8  2               
00F8F8  2               MODE:
00F8F8  2  40 02 45 03          .BYTE   $40,$02,$45,$03 ; even opcodes
00F8FC  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F900  2  30 22 45 33          .BYTE   $30,$22,$45,$33
00F904  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F908  2  40 02 45 33          .BYTE   $40,$02,$45,$33
00F90C  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F910  2  40 02 45 B3          .BYTE   $40,$02,$45,$B3
00F914  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F918  2  00 22 44 33          .BYTE   $00,$22,$44,$33
00F91C  2  D0 8C 44 00          .BYTE   $D0,$8C,$44,$00
00F920  2  11 22 44 33          .BYTE   $11,$22,$44,$33
00F924  2  D0 8C 44 9A          .BYTE   $D0,$8C,$44,$9A
00F928  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F92C  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F930  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F934  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F938  2  62 13 78 A9          .BYTE   $62,$13,$78,$A9 ; opcodes ending in 01
00F93C  2               
00F93C  2               ; addressing mode format definitions indexed by nybbles from MODE table
00F93C  2               
00F93C  2               ; left 6 bits define which characters appear in the assembly operand
00F93C  2               ; left 3 bits are before the address; next 3 bits are after
00F93C  2               
00F93C  2               ; right-most 2 bits define length of binary operand
00F93C  2               
00F93C  2               ; index               654 321
00F93C  2               ; 1st character       $(# ,),
00F93C  2               ; 2nd character        $$ X Y    length  format      idx mode
00F93C  2               MODE2:
00F93C  2  00                   .BYTE   $00             ; 000 000    00                  0   error
00F93D  2  21                   .BYTE   $21             ; 001 000    01      #$00        1   immediate
00F93E  2  81                   .BYTE   $81             ; 100 000    01      $00         2   zero-page
00F93F  2  82                   .BYTE   $82             ; 100 000    10      $0000       3   absolute
00F940  2  00                   .BYTE   $00             ; 000 000    00                  4   implied
00F941  2  00                   .BYTE   $00             ; 000 000    00                  5   accumulator
00F942  2  59                   .BYTE   $59             ; 010 110    01      ($00,X)     6   indirect,X
00F943  2  4D                   .BYTE   $4D             ; 010 011    01      ($00),Y     7   indirect,Y
00F944  2  91                   .BYTE   $91             ; 100 100    01      $00,X       8   zero-page,X
00F945  2  92                   .BYTE   $92             ; 100 100    10      $0000,X     9   absolute,X
00F946  2  86                   .BYTE   $86             ; 100 001    10      $0000,Y     A   absolute,Y
00F947  2  4A                   .BYTE   $4A             ; 010 010    10      ($0000)     B   indirect
00F948  2  85                   .BYTE   $85             ; 100 001    01      $00,Y       C   zero-page,Y
00F949  2  9D                   .BYTE   $9D             ; 100 111    01      $0000*      D   relative
00F94A  2               
00F94A  2               ; * relative is special-cased so format bits don't match
00F94A  2               
00F94A  2               
00F94A  2               ; character lookup tables for the format definitions in MODE2
00F94A  2               
00F94A  2               CHAR1:
00F94A  2  2C 29 2C             .BYTE   $2C,$29,$2C     ; ","  ")"  ","
00F94D  2  23 28 24             .BYTE   $23,$28,$24     ; "#"  "("  "$"
00F950  2               
00F950  2               CHAR2:
00F950  2  59 00 58             .BYTE   $59,$00,$58     ; "Y"   0   "X"
00F953  2  24 24 00             .BYTE   $24,$24,$00     ; "$"  "$"   0
00F956  2               
00F956  2               ; -----------------------------------------------------------------------------
00F956  2               ; 3-letter mnemonics packed into two bytes (5 bits per letter)
00F956  2               
00F956  2               ; left 8 bits
00F956  2               ; XXXXX000 opcodes
00F956  2               MNEML:
00F956  2  1C 8A 1C 23          .BYTE   $1C,$8A,$1C,$23 ; BRK PHP BPL CLC
00F95A  2  5D 8B 1B A1          .BYTE   $5D,$8B,$1B,$A1 ; JSR PLP BMI SEC
00F95E  2  9D 8A 1D 23          .BYTE   $9D,$8A,$1D,$23 ; RTI PHA BVC CLI
00F962  2  9D 8B 1D A1          .BYTE   $9D,$8B,$1D,$A1 ; RTS PLA BVS SEI
00F966  2  00 29 19 AE          .BYTE   $00,$29,$19,$AE ; ??? DEY BCC TYA
00F96A  2  69 A8 19 23          .BYTE   $69,$A8,$19,$23 ; LDY TAY BCS CLV
00F96E  2  24 53 1B 23          .BYTE   $24,$53,$1B,$23 ; CPY INY BNE CLD
00F972  2  24 53 19 A1          .BYTE   $24,$53,$19,$A1 ; CPX INX BEQ SED
00F976  2               ; XXXYY100 opcodes
00F976  2  00 1A 5B 5B          .BYTE   $00,$1A,$5B,$5B ; ??? BIT JMP JMP
00F97A  2  A5 69 24 24          .BYTE   $A5,$69,$24,$24 ; STY LDY CPY CPX
00F97E  2               ; 1XXX1010 opcodes
00F97E  2  AE AE A8 AD          .BYTE   $AE,$AE,$A8,$AD ; TXA TXS TAX TSX
00F982  2  29 00 7C 00          .BYTE   $29,$00,$7C,$00 ; DEX ??? NOP ???
00F986  2               ; XXXYYY10 opcodes
00F986  2  15 9C 6D 9C          .BYTE   $15,$9C,$6D,$9C ; ASL ROL LSR ROR
00F98A  2  A5 69 29 53          .BYTE   $A5,$69,$29,$53 ; STX LDX DEC INC
00F98E  2               ; XXXYYY01 opcodes
00F98E  2  84 13 34 11          .BYTE   $84,$13,$34,$11 ; ORA AND EOR ADC
00F992  2  A5 69 23 A0          .BYTE   $A5,$69,$23,$A0 ; STA LDA CMP SBC
00F996  2               
00F996  2               ; right 7 bits, left justified
00F996  2               ; XXXXX000 opcodes
00F996  2               MNEMR:
00F996  2  D8 62 5A 48          .BYTE   $D8,$62,$5A,$48 ; BRK PHP BPL CLC
00F99A  2  26 62 94 88          .BYTE   $26,$62,$94,$88 ; JSR PLP BMI SEC
00F99E  2  54 44 C8 54          .BYTE   $54,$44,$C8,$54 ; RTI PHA BVC CLI
00F9A2  2  68 44 E8 94          .BYTE   $68,$44,$E8,$94 ; RTS PLA BVS SEI
00F9A6  2  00 B4 08 84          .BYTE   $00,$B4,$08,$84 ; ??? DEY BCC TYA
00F9AA  2  74 B4 28 6E          .BYTE   $74,$B4,$28,$6E ; LDY TAY BCS CLV
00F9AE  2  74 F4 CC 4A          .BYTE   $74,$F4,$CC,$4A ; CPY INY BNE CLD
00F9B2  2  72 F2 A4 8A          .BYTE   $72,$F2,$A4,$8A ; CPX INX BEQ SED
00F9B6  2               ; XXXYY100 opcodes
00F9B6  2  00 AA A2 A2          .BYTE   $00,$AA,$A2,$A2 ; ??? BIT JMP JMP
00F9BA  2  74 74 74 72          .BYTE   $74,$74,$74,$72 ; STY LDY CPY CPX
00F9BE  2               ; 1XXX1010 opcodes
00F9BE  2  44 68 B2 32          .BYTE   $44,$68,$B2,$32 ; TXA TXS TAX TSX
00F9C2  2  B2 00 22 00          .BYTE   $B2,$00,$22,$00 ; DEX ??? NOP ???
00F9C6  2               ; XXXYYY10 opcodes
00F9C6  2  1A 1A 26 26          .BYTE   $1A,$1A,$26,$26 ; ASL ROL LSR ROR
00F9CA  2  72 72 88 C8          .BYTE   $72,$72,$88,$C8 ; STX LDX DEC INC
00F9CE  2               ; XXXYYY01 opcodes
00F9CE  2  C4 CA 26 48          .BYTE   $C4,$CA,$26,$48 ; ORA AND EOR ADC
00F9D2  2  44 44 A2 C8          .BYTE   $44,$44,$A2,$C8 ; STA LDA CMP SBC
00F9D6  2  0D 20 20 20          .BYTE   $0D,$20,$20,$20
00F9DA  2               
00F9DA  2               ; -----------------------------------------------------------------------------
00F9DA  2               ; single-character commands
00F9DA  2               KEYW:
00F9DA  2  41 42 43 44          .BYTE   "ABCDFGHJLMRT.>;"
00F9DE  2  46 47 48 4A  
00F9E2  2  4C 4D 52 54  
00F9E9  2               HIKEY:
00F9E9  2  24 2B 26 25          .BYTE   "$+&%"
00F9ED  2               KEYTOP:
00F9ED  2               
00F9ED  2               
00F9ED  2               ; vectors corresponding to commands above
00F9ED  2               KADDR:
00F9ED  2  1C F3 F3 F2          .WORD   ASSEM-1,BOOT-1,COMPAR-1,DISASS-1
00F9F1  2  F1 F1 AD F4  
00F9F5  2  CB F2 8F F1          .WORD   FILL-1,GOTO-1,HUNT-1,JSUB-1
00F9F9  2  6C F2 A6 F1  
00F9FD  2  BE F8 22 F1          .WORD   LOAD-1,DSPLYM-1,DSPLYR-1,TRANS-1
00FA01  2  95 F0 F4 F1  
00FA05  2  1C F3 6F F1          .WORD   ASSEM-1,ALTM-1,ALTR-1
00FA09  2  58 F1        
00FA0B  2               
00FA0B  2               ; -----------------------------------------------------------------------------
00FA0B  2               MODTAB:
00FA0B  2  10 0A 08 02          .BYTE   $10,$0A,$08,02  ; modulo number systems
00FA0F  2               LENTAB:
00FA0F  2  04 03 03 01          .BYTE   $04,$03,$03,$01 ; bits per digit
00FA13  2               
00FA13  1                       .INCLUDE "bios_pager.ASM"
00FA13  2               ;__BIOS PAGERS__________________________________________________________________________________________________________________
00FA13  2               ;
00FA13  2               ; 	Memory Page Management Functions
00FA13  2               ;
00FA13  2               ;________________________________________________________________________________________________________________________________
00FA13  2               ;
00FA13  2               
00FA13  2               ;__INITPAGES____________________________________________________
00FA13  2               ;
00FA13  2               ; SETUP MMU FOR BIOS PAGED MEMORY OPERATION
00FA13  2               ;
00FA13  2               ; SETUP:
00FA13  2               ; 	TASK 0, NORMAL OPERATION
00FA13  2               ;   TASK 1, ADDITIONAL ROM DRIVERS PAGED INTO C000-D000
00FA13  2               ;	TASKS 2-15 -- OPEN FOR OS/USER USE
00FA13  2               ;_______________________________________________________________
00FA13  2               INITPAGES:
00FA13  2  A9 00                LDA     #$00            ; ENSURE MMU IS DISABLED (SHOULD BE ALREADY, BUT . . . )
00FA15  2  8D 30 EA             STA     M6X0X_MMU_ENA
00FA18  2  A9 01                LDA     #$01
00FA1A  2  8D 10 EA             STA     M6X0X_MAP_SETUP ; Fill TASK 1
00FA1D  2  20 3D FA             JSR     INITPAGE        ; FILL TASK 1 WITH A 1:1 MAP
00FA20  2  A9 8C                LDA     #$8C            ; BUT, MAP Cxxx AND Dxxx TO ROM Cxxx AND Dxxx RATHER THAN RAM
00FA22  2  8D 2C EA             STA     M6X0X_MAP_SPACE+$0C
00FA25  2  A9 8D                LDA     #$8D
00FA27  2  8D 2D EA             STA     M6X0X_MAP_SPACE+$0D
00FA2A  2  A9 00                LDA     #$00
00FA2C  2  8D 10 EA             STA     M6X0X_MAP_SETUP ; Then do task 0
00FA2F  2  20 3D FA             JSR     INITPAGE        ; FILL TASK 0 WITH A 1:1 MAP
00FA32  2               ;  Why task 1 before task 0??   On some boards every write to the register also writes to task 0
00FA32  2               ;  so it is important to write task 0 last (or not use it)
00FA32  2  A9 00                LDA     #$00
00FA34  2  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FA37  2  A9 01                LDA     #$01
00FA39  2  8D 30 EA             STA     M6X0X_MMU_ENA   ; ENABLE MMU --- FEEEEEL THE POOOOWERRRR
00FA3C  2  60                   RTS
00FA3D  2               
00FA3D  2               INITPAGE:
00FA3D  2  A2 00                LDX     #$00
00FA3F  2               :
00FA3F  2  8A                   TXA
00FA40  2  9D 20 EA             STA     M6X0X_MAP_SPACE,X; CREATE A 1:1 MAP OF BANK
00FA43  2  E8                   INX
00FA44  2  E0 10                CPX     #$10
00FA46  2  D0 F7                BNE     :-
00FA48  2  60                   RTS
00FA49  2               PAGE_EXIT:
00FA49  2  48                   PHA
00FA4A  2  A9 00                LDA     #$00
00FA4C  2  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FA4F  2  68                   PLA
00FA50  2  60                   RTS
00FA51  2               PAGE_ENTER:
00FA51  2  48                   PHA
00FA52  2  78                   SEI
00FA53  2  A9 01                LDA     #$01
00FA55  2  8D 00 EA             STA     M6X0X_ACT_TASK  ; SET ACTIVE TASK TO 00
00FA58  2  A9 01                LDA     #$01
00FA5A  2  8D 30 EA             STA     M6X0X_MMU_ENA   ; ENSURE MMU IS ENABLED --- FEEEEEL THE POOOOWERRRR
00FA5D  2  68                   PLA
00FA5E  2  60                   RTS
00FA5F  2               
00FA5F  2               
00FA5F  2               DO_FARCALL:
00FA5F  2  20 51 FA             JSR     PAGE_ENTER
00FA62  2  20 71 C0             JSR     FUNCTION_DISPATCHER
00FA65  2  4C 49 FA             JMP     PAGE_EXIT
00FA68  2               
00FA68  1               
00FA68  1               ;__IOF_CONINW____________________________________________________________________________________________
00FA68  1               ;
00FA68  1               ; PERFORM BLOCKING CONSOLE READ
00FA68  1               ;________________________________________________________________________________________________________
00FA68  1               IOF_CONINW:
00FA68  1  A9 02                LDA     #02
00FA6A  1  85 32                STA     farfunct
00FA6C  1  4C 5F FA             JMP     DO_FARCALL
00FA6F  1               
00FA6F  1               ;__IOF_CONIN_____________________________________________________________________________________________
00FA6F  1               ;
00FA6F  1               ; PERFORM NON-BLOCKING CONSOLE READ
00FA6F  1               ;________________________________________________________________________________________________________
00FA6F  1               IOF_CONIN:
00FA6F  1  A9 01                LDA     #01
00FA71  1  85 32                STA     farfunct
00FA73  1  4C 5F FA             JMP     DO_FARCALL
00FA76  1               
00FA76  1               ;__OUTCH_________________________________________________________________________________________________
00FA76  1               ;
00FA76  1               ; PERFORM CONSOLE WRITE
00FA76  1               ;________________________________________________________________________________________________________
00FA76  1               IOF_OUTCH:
00FA76  1  48                   PHA
00FA77  1  48                   PHA
00FA78  1  A9 00                LDA     #00
00FA7A  1  85 32                STA     farfunct
00FA7C  1  68                   PLA
00FA7D  1  20 5F FA             JSR     DO_FARCALL
00FA80  1  68                   PLA
00FA81  1  60                   RTS
00FA82  1               
00FA82  1               ;__OUTSTR______________________________________________________
00FA82  1               ;
00FA82  1               ; OUTPUT THE STRING POINTED TO BY OUTSTR TO THE SCREEN
00FA82  1               ;
00FA82  1               ;______________________________________________________________
00FA82  1               OUTSTR:
00FA82  1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
00FA84  1               OUTSTRLP:
00FA84  1  B1 41                LDA     (STRPTR),Y      ; LOAD NEXT CHAR FROM STRING INTO ACC
00FA86  1  C9 00                CMP     #$00            ; IS NULL?
00FA88  1  F0 0C                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00FA8A  1  20 76 FA             JSR     IOF_OUTCH       ; PRINT CHAR IN ACC
00FA8D  1  E6 41                INC     STRPTR
00FA8F  1  D0 F3                BNE     OUTSTRLP
00FA91  1  E6 42                INC     STRPTR+1
00FA93  1  4C 84 FA             JMP     OUTSTRLP        ; DO NEXT CHAR
00FA96  1               ENDOUTSTR:
00FA96  1  60                   RTS                     ; RETURN
00FA97  1               
00FA97  1               DSKYMSG:
00FA97  1  7C 06 3F 6D          .BYTE   $7C, $6, $3F, $6D, $0, $3E, $73, $0
00FA9B  1  00 3E 73 00  
00FA9F  1               STARTUP:
00FA9F  1  0D 0A                .BYTE   $0D,$0A
00FAA1  1               
00FAA1  1  20 20 52 65          .BYTE   "  RetroBrew Computers 6x0x",$0D,$0A,$0D,$0A
00FAA5  1  74 72 6F 42  
00FAA9  1  72 65 77 20  
00FABF  1  20 2E 64 38          .BYTE   " .d8888b.            .d8888b. ",$0D,$0A
00FAC3  1  38 38 38 62  
00FAC7  1  2E 20 20 20  
00FADF  1  64 38 38 50          .BYTE   "d88P  Y88b          d88P  Y88b ",$0D,$0A
00FAE3  1  20 20 59 38  
00FAE7  1  38 62 20 20  
00FB00  1  38 38 38 20          .BYTE   "888                 888    888 ",$0D,$0A
00FB04  1  20 20 20 20  
00FB08  1  20 20 20 20  
00FB21  1  38 38 38 64          .BYTE   "888d888b.  888  888 888    888 888  888 ",$0D,$0A
00FB25  1  38 38 38 62  
00FB29  1  2E 20 20 38  
00FB4B  1  38 38 38 50          .BYTE   "888P  Y88b `Y8bd8P' 888    888 `Y8bd8P' ",$0D,$0A
00FB4F  1  20 20 59 38  
00FB53  1  38 62 20 60  
00FB75  1  38 38 38 20          .BYTE   "888    888   X88K   888    888   X88K ",$0D,$0A
00FB79  1  20 20 20 38  
00FB7D  1  38 38 20 20  
00FB9D  1  59 38 38 62          .BYTE   "Y88b  d88P .d8  8b. Y88b  d88P .d8  8b. ",$0D,$0A
00FBA1  1  20 20 64 38  
00FBA5  1  38 50 20 2E  
00FBC7  1  20 20 59 38          .BYTE   "  Y8888P   888  888   Y8888P   888  888 ",$0D,$0A,$0D,$0A
00FBCB  1  38 38 38 50  
00FBCF  1  20 20 20 38  
00FBF3  1               
00FBF3  1                       .SEGMENT "IVECTOR"
00FBF3  1                       .ORG    $FFF0
00FFF0  1  4C 5F FA             JMP     DO_FARCALL
00FFF3  1  4C 45 F8             JMP     LOADS19
00FFF6  1               
00FFF6  1                       .SEGMENT "VECTORS"
00FFF6  1                       .ORG    $FFFA
00FFFA  1               NNTVECTOR:
00FFFA  1  86 F0                .WORD   NINTERRUPT      ;
00FFFC  1               RSTVECTOR:
00FFFC  1  00 F0                .WORD   COLD_START      ;
00FFFE  1               INTVECTOR:
00FFFE  1  70 F0                .WORD   INTERRUPT       ; ROM VECTOR FOR IRQ
010000  1               
010000  1                       .END
