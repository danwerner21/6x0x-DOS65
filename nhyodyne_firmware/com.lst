ca65 V2.18 - Ubuntu 2.19-1
Main file   : com.asm
Current file: com.asm

000000r 1               
000000r 1               ;__COM_______________________________________________________
000000r 1               ; This is the bootstrap code for the "DOS65.COM" file to be ran on
000000r 1               ; nhyodyne from Z80 mode.
000000r 1               ;
000000r 1               ; It assumes that the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;REGISTER		IO PORT		; FUNCTION
000000r 1               
000000r 1               ; UART 16C550 SERIAL -- Assumes IO is in page $03 -- DIP Switch settings $83
000000r 1               UART0           = $0368         ; DATA IN/OUT
000000r 1               UART1           = $0369         ; CHECK RX
000000r 1               UART2           = $036A         ; INTERRUPTS
000000r 1               UART3           = $036B         ; LINE CONTROL
000000r 1               UART4           = $036C         ; MODEM CONTROL
000000r 1               UART5           = $036D         ; LINE STATUS
000000r 1               UART6           = $036E         ; MODEM STATUS
000000r 1               UART7           = $036F         ; SCRATCH REG.
000000r 1               
000000r 1               
000000r 1                       .INCLUDE "../dos65_os/dosdefn.asm"; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	DOS/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp          = $0100         ; warm boot jump
000000r 2               pemjmp          = $0103         ; jump to pem
000000r 2               iostat          = $0106         ; i/o status
000000r 2               dflfcb          = $0107         ; default fcb
000000r 2               dflbuf          = $0128         ; default buffer
000000r 2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
000000r 2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
000000r 2               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 2               MPCL_ROM        = $037C         ; ROM MAPPER
000000r 2               MPCL_RAM        = $0378         ; RAM MAPPER
000000r 2               hstbuf          = $0400         ; 0400-05ff host buffer
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               
000000r 2               
000000r 2               DSKY_BUF        = $0600         ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN     = 8             ;
000000r 2               DSKY_HEXBUF     = $0608         ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN  = 4             ;
000000r 2               sektrk          = $060C         ; seek track number
000000r 2               seksec          = $060E         ; seek sector number
000000r 2               debcyll         = $0610         ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         = $0611         ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         = $0612         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          = $0616         ; seek disk number
000000r 2               dskcfg          = $0617         ; 16 bytes disk configuration table
000000r 2               DSKUNIT         = $0628         ; seek disk number
000000r 2               slicetmp        = $0631         ; (word)
000000r 2               STACKA          = $0635
000000r 2               nmsstr          = $0636
000000r 2               FLRETRY         = $0637         ;
000000r 2               FLRETRY1        = $0638         ;
000000r 2               ST0             = $0639         ;
000000r 2               FLERR           = $063A         ;
000000r 2               FCMD            = $063B         ;
000000r 2               PPIDEINDEX      = $063C
000000r 2               currentDrive    = $063D
000000r 2               DSKY_X_STORAGE  = $063E
000000r 2               DSKY_Y_STORAGE  = $063F
000000r 2               DSKY_TEMP_VAL   = $0640
000000r 2               DSKY_PPIX_VAL   = $0641
000000r 2               FLOPPY_DETCT    = $0642
000000r 2               DSKY_PRESENT    = $0643
000000r 2               Cdebcyll        = $0644         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 2               Cdebcylm        = $0645         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 2               Cdebsehd        = $0646         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 2               
000000r 2               
000000r 2               tea             = $800          ;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               addinp          = $02           ;initialized to a,y
000000r 2               bufadd          = $04           ;buffer address
000000r 2               alcpnt          = $06           ;allocation map pointer
000000r 2               chkpnt          = $08           ;checksum map pointer
000000r 2               numvar          = 8             ;eight bytes
000000r 2               
000000r 2               
000000r 2               msgptr          = chkpnt+2      ;message pointer
000000r 2               movptr          = msgptr        ;and move pointer
000000r 2               dcbloc          = msgptr+2      ;pointer to dcb
000000r 2               
000000r 2               dcbpc           = $2C           ;pointer to DCB table
000000r 2               dskcfpc         = $2E           ;pointer to disk configuration table
000000r 2               cmdlnp          = $30           ;pointer to command line buffer
000000r 2               farfunct        = $32           ; function to call in driver area
000000r 2               farpointer      = $33           ;
000000r 2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 2               CONSOLE         = $3A
000000r 2               TEMPWORD        = $3B           ;
000000r 2               TEMPWORD1       = $3D           ;
000000r 2               TEMPWORD2       = $3F           ;
000000r 2               STRPTR          = $41           ;
000000r 2               DSKYMODE        = $43           ; DSKY MODE (0=NONE, 1=DSKY, 2=DSKY NG
000000r 2               
000000r 2               
000000r 2               DO_FARCALL      = $FFF0
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST            = $EC           ;pointer for OutMsg
000000r 2               SRC             = $EE           ;pointer for OutMsg
000000r 2               OUTMSG_W        = $F0           ;pointer for OutMsg
000000r 2               dmaadr          = $f4           ;pointer for r/w
000000r 2               
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall           = 0             ;write to allocated
000000r 2               wrdir           = 1             ;write to directory
000000r 2               wrual           = 2             ;write to unallocated
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf              = $a            ;linefeeed
000000r 2               cr              = $d            ;return
000000r 2               eof             = $1a           ;end of file
000000r 2               null            = 0             ;null
000000r 2               ctlc            = 3             ;abort
000000r 2               ctle            = 5             ;physical cr lf
000000r 2               ctli            = 9             ;tab character
000000r 2               ctlp            = $10           ;toggle printer
000000r 2               ctlr            = $12           ;repeat line
000000r 2               ctls            = $13           ;freeze
000000r 2               ctlx            = $18           ;cancel
000000r 2               semico          = $3b           ;semicolon
000000r 2               delete          = $08           ;delete character
000000r 2               numcmd          = 36            ;number commands
000000r 2               DEFDRV          = 0             ; SET TO DEFAULT DRIVE LETTER
000000r 2               
000000r 2               
000000r 2                       .IFDEF  RBC6X0X
000000r 2                       .DEFINE COMSUFFIX "COM"
000000r 2                       .ENDIF
000000r 2               
000000r 2                       .IFDEF  NHYODYNE
000000r 2                       .DEFINE COMSUFFIX "CO6"
000000r 2                       .ENDIF
000000r 2               
000000r 2               DEBUG           = 0
000000r 2               BANKED_DRIVER_DISPATCHER=$8800
000000r 2               
000000r 1               
000000r 1               ROM_FARCALL     = farcall - md_pagecode + MD_PAGERA
000000r 1               
000000r 1                       .SEGMENT "SROM"
000000r 1               
000000r 1               ;__COLD_START___________________________________________________
000000r 1               ;
000000r 1               ; PERFORM SYSTEM COLD INIT
000000r 1               ;
000000r 1               ;_______________________________________________________________
000000r 1               COLD_START:
000000r 1  78                   SEI                     ; DISABLE INTERRUPTS
000001r 1  D8                   CLD                     ;  VERIFY DECIMAL MODE IS OFF
000002r 1  A2 FF                LDX     #$FF            ;
000004r 1  9A                   TXS                     ; CLEAR STACK
000005r 1               
000005r 1  A9 rr                LDA     #<IRQROUTINE
000007r 1  85 35                STA     IRQVECTOR
000009r 1  85 37                STA     NMIVECTOR
00000Br 1  A9 rr                LDA     #>IRQROUTINE
00000Dr 1  85 36                STA     IRQVECTOR+1
00000Fr 1  85 38                STA     NMIVECTOR+1
000011r 1               
000011r 1  20 rr rr             JSR     PAGER_INIT
000014r 1               
000014r 1  A9 04                LDA     #$04            ; SET SERIAL DEFAULT CONSOLE
000016r 1  85 3A                STA     CONSOLE
000018r 1               
000018r 1  A9 rr                LDA     #<STARTUP       ; OUTPUT STARTUP STRING
00001Ar 1  85 41                STA     STRPTR          ;
00001Cr 1  A9 rr                LDA     #>STARTUP       ;
00001Er 1  85 42                STA     STRPTR+1        ;
000020r 1  20 rr rr             JSR     OUTSTR          ;
000023r 1               
000023r 1  4C 00 D0             JMP     $D000           ; START DOS/65
000026r 1               
000026r 1               ;
000026r 1  00                   BRK                     ; PERFORM BRK (START MONITOR)
000027r 1               
000027r 1               
000027r 1               ;__IRQROUTINE___________________________________________________
000027r 1               ;
000027r 1               ; HANDLE INTERRUPT PROCESING
000027r 1               ;
000027r 1               ;_______________________________________________________________
000027r 1               IRQROUTINE:
000027r 1  58                   CLI                     ; ENABLE INTERRUPTS AGAIN
000028r 1  40                   RTI
000029r 1               
000029r 1               ;__INTERRUPT____________________________________________________
000029r 1               ;
000029r 1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
000029r 1               ;
000029r 1               ;_______________________________________________________________
000029r 1               INTERRUPT:
000029r 1  78                   SEI                     ; DISABLE INTERRUPTS
00002Ar 1  85 3B                STA     TEMPWORD
00002Cr 1  68                   PLA                     ; GET STATUS REGISTER
00002Dr 1  48                   PHA                     ; SAVE STATUS REGISTER
00002Er 1  29 10                AND     #$10            ; MASK BRK
000030r 1  D0 03                BNE     BRKCMD          ; BRK CMD
000032r 1  6C 35 00             JMP     (IRQVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
000035r 1               BRKCMD:
000035r 1  A5 3B                LDA     TEMPWORD
000037r 1  48                   PHA
000038r 1  8A                   TXA
000039r 1  48                   PHA
00003Ar 1  98                   TYA
00003Br 1  48                   PHA
00003Cr 1  4C rr rr             JMP     BRKROUTINE      ; MONITOR BRK ROUTINE
00003Fr 1               
00003Fr 1               NINTERRUPT:
00003Fr 1  6C 37 00             JMP     (NMIVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED NMI)
000042r 1               
000042r 1               ;__________________________________________________________________________________________________________
000042r 1               ;
000042r 1               ;  AT SOME POINT, REPLACE THIS WITH 6502HBIOS CALLS
000042r 1               ;
000042r 1               INIT_SERIAL:
000042r 1  A9 80                LDA     #$80            ;
000044r 1  8D 6B 03             STA     UART3           ; SET DLAB FLAG
000047r 1  A9 0C                LDA     #12             ; SET TO 12 = 9600 BAUD
000049r 1  8D 68 03             STA     UART0           ; save baud rate
00004Cr 1  A9 00                LDA     #00             ;
00004Er 1  8D 69 03             STA     UART1           ;
000051r 1  A9 03                LDA     #03             ;
000053r 1  8D 6B 03             STA     UART3           ; SET 8 BIT DATA, 1 STOPBIT
000056r 1  8D 6C 03             STA     UART4           ;
000059r 1  60                   RTS
00005Ar 1               
00005Ar 1               ;__IOF_CONINW____________________________________________________________________________________________
00005Ar 1               ;
00005Ar 1               ; PERFORM BLOCKING CONSOLE READ
00005Ar 1               ;________________________________________________________________________________________________________
00005Ar 1               IOF_CONINW:
00005Ar 1  A9 02                LDA     #02
00005Cr 1  85 32                STA     farfunct
00005Er 1  4C F0 FF             JMP     DO_FARCALL
000061r 1               
000061r 1               
000061r 1               ;__IOF_CONIN_____________________________________________________________________________________________
000061r 1               ;
000061r 1               ; PERFORM NON-BLOCKING CONSOLE READ
000061r 1               ;________________________________________________________________________________________________________
000061r 1               IOF_CONIN:
000061r 1  A9 01                LDA     #01
000063r 1  85 32                STA     farfunct
000065r 1  4C F0 FF             JMP     DO_FARCALL
000068r 1               
000068r 1               ;__OUTCH_________________________________________________________________________________________________
000068r 1               ;
000068r 1               ; PERFORM CONSOLE WRITE
000068r 1               ;________________________________________________________________________________________________________
000068r 1               IOF_OUTCH:
000068r 1  48                   PHA
000069r 1  48                   PHA
00006Ar 1  A9 00                LDA     #00
00006Cr 1  85 32                STA     farfunct
00006Er 1  68                   PLA
00006Fr 1  20 F0 FF             JSR     DO_FARCALL
000072r 1  68                   PLA
000073r 1  60                   RTS
000074r 1               
000074r 1               
000074r 1               ;__OUTSTR______________________________________________________
000074r 1               ;
000074r 1               ; OUTPUT THE STRING POINTED TO BY OUTSTR TO THE SCREEN
000074r 1               ;
000074r 1               ;______________________________________________________________
000074r 1               OUTSTR:
000074r 1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
000076r 1               OUTSTRLP:
000076r 1  B1 41                LDA     (STRPTR),Y      ; LOAD NEXT CHAR FROM STRING INTO ACC
000078r 1  C9 00                CMP     #$00            ; IS NULL?
00007Ar 1  F0 0C                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00007Cr 1  20 rr rr             JSR     IOF_OUTCH       ; PRINT CHAR IN ACC
00007Fr 1  E6 41                INC     STRPTR
000081r 1  D0 F3                BNE     OUTSTRLP
000083r 1  E6 42                INC     STRPTR+1
000085r 1  4C rr rr             JMP     OUTSTRLP        ; DO NEXT CHAR
000088r 1               ENDOUTSTR:
000088r 1  60                   RTS                     ; RETURN
000089r 1               
000089r 1               Z80:
000089r 1  00                   BRK
00008Ar 1  00 00 00             .BYTE   00,00,00
00008Dr 1               
00008Dr 1                       .INCLUDE"../SUPERMON/SUPERMON.ASM"
00008Dr 2               ; ********************************
00008Dr 2               ; * SUPERMON+ 64 JIM BUTTERFIELD *
00008Dr 2               ; * V1.2   AUGUST 20 1985        *
00008Dr 2               ; ********************************
00008Dr 2               
00008Dr 2               ; Reformatted and annotated in late 2016/early 2017 by J.B. Langston.
00008Dr 2               ; Modified for Nhyodyne/Retrobrew 3/12/2023 D. Werner
00008Dr 2               ;
00008Dr 2               ; Mr. Butterfield . . you inspired many of us, thank you.
00008Dr 2               ;
00008Dr 2               ; -----------------------------------------------------------------------------
00008Dr 2               ; temporary pointers
00008Dr 2               TMP0            = $C1           ; used to return input, often holds end address
00008Dr 2               TMP2            = $C3           ; usually holds start address
00008Dr 2               
00008Dr 2               ; these 7 locations are used to store the registers when
00008Dr 2               ; entering the monitor and restore them when exiting.
00008Dr 2               
00008Dr 2               PCH             = $B0           ; program counter high byte
00008Dr 2               PCL             = $B1           ; program counter low byte
00008Dr 2               SR              = $B2           ; status register
00008Dr 2               ACC             = $B3           ; accumulator
00008Dr 2               XR              = $B4           ; X register
00008Dr 2               YR              = $B5           ; Y register
00008Dr 2               SP              = $B6           ; stack pointer
00008Dr 2               STORE           = $B7           ; 2-byte temp storage
00008Dr 2               CHRPNT          = $B9           ; current position in input buffer
00008Dr 2               SAVY            = $BA           ; temp storage, often to save Y register
00008Dr 2               U9F             = $BB           ; index into assembler work buffer
00008Dr 2               CKSM            = $BC           ; S19 loader checksum store
00008Dr 2               LOADADR         = $BD           ; S19 load address
00008Dr 2               LOADWRK         = $BF           ; S19 load work
00008Dr 2               
00008Dr 2               ;-----------------------------------------------------------------------------
00008Dr 2               ; variables
00008Dr 2               ACMD            = $C5           ; addressing command
00008Dr 2               LENGTH          = $C6           ; length of operand
00008Dr 2               MNEMW           = $C7           ; 3 letter mnemonic buffer
00008Dr 2               SAVX            = $CA           ; 1 byte temp storage, often to save X register
00008Dr 2               OPCODE          = $CB           ; current opcode for assembler/disassembler
00008Dr 2               UPFLG           = $CC           ; flag: count up (bit 7 clear) or down (bit 7 set)
00008Dr 2               DIGCNT          = $CB           ; digit count
00008Dr 2               INDIG           = $CC           ; numeric value of single digit
00008Dr 2               NUMBIT          = $CD           ; numeric base of input
00008Dr 2               STASH           = $CE           ; 2-byte temp storage
00008Dr 2               U0AA0           = $D0           ; 10 byte work buffer
00008Dr 2               U0AAE           = $D0+10        ; end of 10 byte work buffer
00008Dr 2               STAGE           = $DA           ; 30 byte staging buffer for filename, search, etc.
00008Dr 2               ESTAGE          = $DA+30        ; end of 30 byte staging buffer for filename, search, etc.
00008Dr 2               INBUFF          = $0400
00008Dr 2               CHROUT          = IOF_OUTCH
00008Dr 2               
00008Dr 2               
00008Dr 2               ; -----------------------------------------------------------------------------
00008Dr 2               ; BRK handler
00008Dr 2               BRKROUTINE:
00008Dr 2               BREAK:
00008Dr 2  A2 05                LDX     #$05            ; pull registers off the stack
00008Fr 2               BSTACK:
00008Fr 2  68                   PLA                     ; order: Y,X,A,SR,PCL,PCH
000090r 2  95 B0                STA     PCH,X           ; store in memory
000092r 2  CA                   DEX
000093r 2  10 FA                BPL     BSTACK
000095r 2  D8                   CLD                     ; disable bcd mode
000096r 2  BA                   TSX                     ; store stack pointer in memory
000097r 2  86 B6                STX     SP
000099r 2  58                   CLI                     ; enable interupts
00009Ar 2               
00009Ar 2               ; -----------------------------------------------------------------------------
00009Ar 2               ; display registers [R]
00009Ar 2               DSPLYR:
00009Ar 2  A0 00                LDY     #MSG2-MSGBAS    ; display headers
00009Cr 2  20 rr rr             JSR     SNDCLR
00009Fr 2  A9 3B                LDA     #$3B            ; prefix registers with "; " to allow editing
0000A1r 2  20 rr rr             JSR     CHROUT
0000A4r 2  A9 20                LDA     #$20
0000A6r 2  20 rr rr             JSR     CHROUT
0000A9r 2  A5 B0                LDA     PCH             ; print 2-byte program counter
0000ABr 2  20 rr rr             JSR     WRTWO
0000AEr 2  A0 01                LDY     #1              ; start 1 byte after PC high byte
0000B0r 2               DISJ:
0000B0r 2  B9 B0 00             LDA     PCH,Y           ; loop through rest of the registers
0000B3r 2  20 rr rr             JSR     WRBYTE          ; print 1-byte register value
0000B6r 2  C8                   INY
0000B7r 2  C0 07                CPY     #7              ; there are a total of 5 registers to print
0000B9r 2  90 F5                BCC     DISJ
0000BBr 2               
0000BBr 2               ; -----------------------------------------------------------------------------
0000BBr 2               ; main loop
0000BBr 2               STRT:
0000BBr 2  20 rr rr             JSR     CRLF            ; new line
0000BEr 2  A2 00                LDX     #0              ; point at start of input buffer
0000C0r 2  86 B9                STX     CHRPNT
0000C2r 2               SMOVE:
0000C2r 2  20 rr rr             JSR     IOF_CONINW      ; CHRIN kernal call to input a character
0000C5r 2               
0000C5r 2  C9 08                CMP     #$08            ; IS BACKSPACE?
0000C7r 2  D0 1A                BNE     :+              ; NO, SKUP BACKSPACE RTN
0000C9r 2  E0 00                CPX     #$00            ; IS INDEX =0 ?
0000CBr 2  F0 F5                BEQ     SMOVE           ; YES, SKIP BACKSPACE
0000CDr 2  20 rr rr             JSR     IOF_OUTCH       ; BACK UP CURSOR
0000D0r 2  A9 20                LDA     #$20
0000D2r 2  20 rr rr             JSR     IOF_OUTCH       ; SPACE ON SCREEN
0000D5r 2  A9 08                LDA     #$08
0000D7r 2  20 rr rr             JSR     IOF_OUTCH       ; BACK UP CURSOR
0000DAr 2               
0000DAr 2  A9 00                LDA     #0
0000DCr 2  9D 00 04             STA     INBUFF,X        ; store in input buffer
0000DFr 2  CA                   DEX
0000E0r 2  4C rr rr             JMP     SMOVE
0000E3r 2               :
0000E3r 2  20 rr rr             JSR     IOF_OUTCH       ; OUTPUT CHAR TO SCREEN
0000E6r 2               
0000E6r 2  9D 00 04             STA     INBUFF,X        ; store in input buffer
0000E9r 2  E8                   INX
0000EAr 2  E0 00                CPX     #00             ; error if buffer is full
0000ECr 2  F0 1C                BEQ     ERROR
0000EEr 2  C9 0D                CMP     #$0D            ; keep reading until CR
0000F0r 2  D0 D0                BNE     SMOVE
0000F2r 2  A9 00                LDA     #0              ; null-terminate input buffer
0000F4r 2  9D FF 03             STA     INBUFF-1,X      ; (replacing the CR)
0000F7r 2               ST1:
0000F7r 2  20 rr rr             JSR     GETCHR          ; get a character from the buffer
0000FAr 2  F0 BF                BEQ     STRT            ; start over if buffer is empty
0000FCr 2  C9 20                CMP     #$20            ; skip leading spaces
0000FEr 2  F0 F7                BEQ     ST1
000100r 2               S0:
000100r 2  A2 13                LDX     #KEYTOP-KEYW    ; loop through valid command characters
000102r 2               S1:
000102r 2  DD rr rr             CMP     KEYW,X          ; see if input character matches
000105r 2  F0 0B                BEQ     S2              ; command matched, dispatch it
000107r 2  CA                   DEX                     ; no match, check next command
000108r 2  10 F8                BPL     S1              ; keep trying until we've checked them all
00010Ar 2                                               ; then fall through to error handler
00010Ar 2               
00010Ar 2               ; -----------------------------------------------------------------------------
00010Ar 2               ; handle error
00010Ar 2               ERROR:
00010Ar 2  A0 1E                LDY     #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
00010Cr 2  20 rr rr             JSR     SNDMSG
00010Fr 2  4C rr rr             JMP     STRT            ; back to main loop
000112r 2               
000112r 2               ; -----------------------------------------------------------------------------
000112r 2               ; dispatch command
000112r 2               S2:
000112r 2  E0 0E                CPX     #$0E            ; next 4 commands are base conversions
000114r 2  B0 0E                BCS     CNVLNK          ;   which are handled by the same subroutine
000116r 2  8A                   TXA                     ; remaining commands dispatch through vector table
000117r 2  0A                   ASL     A               ; multiply index of command by 2
000118r 2  AA                   TAX                     ;   since table contains 2-byte addresses
000119r 2  BD rr rr             LDA     KADDR+1,X       ; push address from vector table onto stack
00011Cr 2  48                   PHA                     ;   so that the RTS from GETPAR will jump there
00011Dr 2  BD rr rr             LDA     KADDR,X
000120r 2  48                   PHA
000121r 2  4C rr rr             JMP     GETPAR          ; get the first parameter for the command
000124r 2               CNVLNK:
000124r 2  4C rr rr             JMP     CONVRT          ; handle base conversion
000127r 2               
000127r 2               
000127r 2               ; -----------------------------------------------------------------------------
000127r 2               ; display memory [M]
000127r 2               DSPLYM:
000127r 2  B0 08                BCS     DSPM11          ; start from previous end addr if no address given
000129r 2  20 rr rr             JSR     COPY12          ; save start address in TMP2
00012Cr 2  20 rr rr             JSR     GETPAR          ; get end address in TMP0
00012Fr 2  90 06                BCC     DSMNEW          ; did user specify one?
000131r 2               DSPM11:
000131r 2  A9 0B                LDA     #$0B            ; if not, show 12 lines by default
000133r 2  85 C1                STA     TMP0
000135r 2  D0 0E                BNE     DSPBYT          ; always true, but BNE uses 1 byte less than JMP
000137r 2               DSMNEW:
000137r 2  20 rr rr             JSR     SUB12           ; end addr given, calc bytes between start and end
00013Ar 2  90 1E                BCC     MERROR          ; error if start is after end
00013Cr 2  A2 03                LDX     #3              ; divide by 8 (shift right 3 times)
00013Er 2               DSPM01:
00013Er 2  46 C2                LSR     TMP0+1
000140r 2  66 C1                ROR     TMP0
000142r 2  CA                   DEX
000143r 2  D0 F9                BNE     DSPM01
000145r 2               DSPBYT:
000145r 2  20 rr rr             JSR     STOP            ; check for stop key
000148r 2  F0 0D                BEQ     DSPMX           ; exit early if pressed
00014Ar 2  20 rr rr             JSR     DISPMEM         ; display 1 line containing 8 bytes
00014Dr 2  A9 08                LDA     #8              ; increase start address by 8 bytes
00014Fr 2  20 rr rr             JSR     BUMPAD2
000152r 2  20 rr rr             JSR     SUBA1           ; decrement line counter
000155r 2  B0 EE                BCS     DSPBYT          ; show another line until it's < 0
000157r 2               DSPMX:
000157r 2  4C rr rr             JMP     STRT            ; back to main loop
00015Ar 2               MERROR:
00015Ar 2  4C rr rr             JMP     ERROR           ; handle error
00015Dr 2               
00015Dr 2               ; -----------------------------------------------------------------------------
00015Dr 2               ; alter registers [;]
00015Dr 2               ALTR:
00015Dr 2  20 rr rr             JSR     COPY1P          ; store first parameter in PC
000160r 2  A0 00                LDY     #0              ; init counter
000162r 2               ALTR1:
000162r 2  20 rr rr             JSR     GETPAR          ; get value for next register
000165r 2  B0 0A                BCS     ALTRX           ; exit early if no more values given
000167r 2  A5 C1                LDA     TMP0            ; store in memory, offset from SR
000169r 2  99 B2 00             STA     SR,Y            ; these locations will be transferred to the
00016Cr 2  C8                   INY                     ;   actual registers before exiting the monitor
00016Dr 2  C0 05                CPY     #$05            ; have we updated all 5 yet?
00016Fr 2  90 F1                BCC     ALTR1           ; if not, get next
000171r 2               ALTRX:
000171r 2  4C rr rr             JMP     STRT            ; back to main loop
000174r 2               
000174r 2               ; -----------------------------------------------------------------------------
000174r 2               ; alter memory [>]
000174r 2               ALTM:
000174r 2  B0 13                BCS     ALTMX           ; exit if no parameter provided
000176r 2  20 rr rr             JSR     COPY12          ; copy parameter to start address
000179r 2  A0 00                LDY     #0
00017Br 2               ALTM1:
00017Br 2  20 rr rr             JSR     GETPAR          ; get value for next byte of memory
00017Er 2  B0 09                BCS     ALTMX           ; if none given, exit early
000180r 2  A5 C1                LDA     TMP0            ; poke value into memory at start address + Y
000182r 2  91 C3                STA     (TMP2),Y
000184r 2  C8                   INY                     ; next byte
000185r 2  C0 08                CPY     #8              ; have we read 8 bytes yet?
000187r 2  90 F2                BCC     ALTM1           ; if not, read the next one
000189r 2               ALTMX:
000189r 2  A9 91                LDA     #$91            ; move cursor up
00018Br 2  20 rr rr             JSR     CHROUT
00018Er 2  20 rr rr             JSR     DISPMEM         ; re-display line to make ascii match hex
000191r 2  4C rr rr             JMP     STRT            ; back to main loop
000194r 2               
000194r 2               ; -----------------------------------------------------------------------------
000194r 2               ; goto (run) [G]
000194r 2               GOTO:
000194r 2  A6 B6                LDX     SP              ; load stack pointer from memory
000196r 2  9A                   TXS                     ; save in SP register
000197r 2               GOTO2:
000197r 2  20 rr rr             JSR     COPY1P          ; copy provided address to PC
00019Ar 2  78                   SEI                     ; disable interrupts
00019Br 2  A5 B0                LDA     PCH             ; push PC high byte on stack
00019Dr 2  48                   PHA
00019Er 2  A5 B1                LDA     PCL             ; push PC low byte on stack
0001A0r 2  48                   PHA
0001A1r 2  A5 B2                LDA     SR              ; push status byte on stack
0001A3r 2  48                   PHA
0001A4r 2  A5 B3                LDA     ACC             ; load accumulator from memory
0001A6r 2  A6 B4                LDX     XR              ; load X from memory
0001A8r 2  A4 B5                LDY     YR              ; load Y from memory
0001AAr 2  40                   RTI                     ; return from interrupt (pops PC and SR)
0001ABr 2               
0001ABr 2               ; jump to subroutine [J]
0001ABr 2               JSUB:
0001ABr 2  A6 B6                LDX     SP              ; load stack pointer from memory
0001ADr 2  9A                   TXS                     ; save value in SP register
0001AEr 2  20 rr rr             JSR     GOTO2           ; same as goto command
0001B1r 2  84 B5                STY     YR              ; save Y to memory
0001B3r 2  86 B4                STX     XR              ; save X to memory
0001B5r 2  85 B3                STA     ACC             ; save accumulator to memory
0001B7r 2  08                   PHP                     ; push processor status on stack
0001B8r 2  68                   PLA                     ; pull processor status into A
0001B9r 2  85 B2                STA     SR              ; save processor status to memory
0001BBr 2  4C rr rr             JMP     DSPLYR          ; display registers
0001BEr 2               
0001BEr 2               ; -----------------------------------------------------------------------------
0001BEr 2               ; display 8 bytes of memory
0001BEr 2               DISPMEM:
0001BEr 2  20 rr rr             JSR     CRLF            ; new line
0001C1r 2  A9 3E                LDA     #'>'            ; prefix > so memory can be edited in place
0001C3r 2  20 rr rr             JSR     CHROUT
0001C6r 2  20 rr rr             JSR     SHOWAD          ; show address of first byte on line
0001C9r 2  A0 00                LDY     #0
0001CBr 2  F0 03                BEQ     DMEMGO          ; SHOWAD already printed a space after the address
0001CDr 2               DMEMLP:
0001CDr 2  20 rr rr             JSR     SPACE           ; print space between bytes
0001D0r 2               DMEMGO:
0001D0r 2  B1 C3                LDA     (TMP2),Y        ; load byte from start address + Y
0001D2r 2  20 rr rr             JSR     WRTWO           ; output hex digits for byte
0001D5r 2  C8                   INY                     ; next byte
0001D6r 2  C0 08                CPY     #8              ; have we output 8 bytes yet?
0001D8r 2  90 F3                BCC     DMEMLP          ; if not, output next byte
0001DAr 2  A0 26                LDY     #MSG5-MSGBAS    ; if so, output : and turn on reverse video
0001DCr 2  20 rr rr             JSR     SNDMSG          ;   before displaying ascii representation
0001DFr 2  A0 00                LDY     #0              ; back to first byte in line
0001E1r 2               DCHAR:
0001E1r 2  B1 C3                LDA     (TMP2),Y        ; load byte at start address + Y
0001E3r 2  C9 20                CMP     #$20            ; is it a printable character (>= $20)?
0001E5r 2  90 04                BCC     DDOT            ; if NOT printable, output '.'
0001E7r 2  C9 80                CMP     #$80
0001E9r 2  90 02                BCC     DCHROK          ; if printable, output character
0001EBr 2               DDOT:
0001EBr 2  A9 2E                LDA     #$2E            ; if not, output '.' instaed
0001EDr 2               DCHROK:
0001EDr 2  20 rr rr             JSR     CHROUT
0001F0r 2  C8                   INY                     ; next byte
0001F1r 2  C0 08                CPY     #8              ; have we output 8 bytes yet?
0001F3r 2  90 EC                BCC     DCHAR           ; if not, output next byte
0001F5r 2  60                   RTS
0001F6r 2               
0001F6r 2               ; -----------------------------------------------------------------------------
0001F6r 2               ; compare memory [C]
0001F6r 2               COMPAR:
0001F6r 2  A9 00                LDA     #0              ; bit 7 clear signals compare
0001F8r 2  2C                   .BYTE   $2C             ; absolute BIT opcode consumes next word (LDA #$80)
0001F9r 2               
0001F9r 2               ; transfer memory [T]
0001F9r 2               TRANS:
0001F9r 2  A9 80                LDA     #$80            ; bit 7 set signals transfer
0001FBr 2  85 BA                STA     SAVY            ; save compare/transfer flag in SAVY
0001FDr 2  A9 00                LDA     #0              ; assume we're counting up (bit 7 clear)
0001FFr 2  85 CC                STA     UPFLG           ; save direction flag
000201r 2  20 rr rr             JSR     GETDIF          ; get two addresses and calculate difference
000204r 2                                               ;   TMP2 = source start
000204r 2                                               ;   STASH = source end
000204r 2                                               ;   STORE = length
000204r 2  B0 05                BCS     TERROR          ; carry set indicates error
000206r 2  20 rr rr             JSR     GETPAR          ; get destination address in TMP0
000209r 2  90 03                BCC     TOKAY           ; carry set indicates error
00020Br 2               TERROR:
00020Br 2  4C rr rr             JMP     ERROR           ; handle error
00020Er 2               TOKAY:
00020Er 2  24 BA                BIT     SAVY            ; transfer or compare?
000210r 2  10 23                BPL     COMPAR1         ; high bit clear indicates compare
000212r 2  A5 C3                LDA     TMP2            ; if it's a transfer, we must take steps
000214r 2  C5 C1                CMP     TMP0            ;   to avoid overwriting the source bytes before
000216r 2  A5 C4                LDA     TMP2+1          ;   they have been transferred
000218r 2  E5 C2                SBC     TMP0+1          ; compare source (TMP2) to destination (TMP0)
00021Ar 2  B0 19                BCS     COMPAR1         ; and count up if source is before than desitnation
00021Cr 2  A5 B7                LDA     STORE           ; otherwise, start at end and count down...
00021Er 2  65 C1                ADC     TMP0            ; add length (STORE) to desintation (TMP0)
000220r 2  85 C1                STA     TMP0            ; to calculate end of destination
000222r 2  A5 B8                LDA     STORE+1
000224r 2  65 C2                ADC     TMP0+1
000226r 2  85 C2                STA     TMP0+1
000228r 2  A2 01                LDX     #1              ; change source pointer from beginning to end
00022Ar 2               TDOWN:
00022Ar 2  B5 CE                LDA     STASH,X         ; TMP2 = source end (STASH)
00022Cr 2  95 C3                STA     TMP2,X
00022Er 2  CA                   DEX
00022Fr 2  10 F9                BPL     TDOWN
000231r 2  A9 80                LDA     #$80            ; high bit set in UPFLG means count down
000233r 2  85 CC                STA     UPFLG
000235r 2               COMPAR1:
000235r 2  20 rr rr             JSR     CRLF            ; new line
000238r 2  A0 00                LDY     #0              ; no offset from pointer
00023Ar 2               TCLOOP:
00023Ar 2  20 rr rr             JSR     STOP            ; check for stop key
00023Dr 2  F0 2F                BEQ     TEXIT           ; exit if pressed
00023Fr 2  B1 C3                LDA     (TMP2),Y        ; load byte from source
000241r 2  24 BA                BIT     SAVY            ; transfer or compare?
000243r 2  10 02                BPL     COMPAR2         ; skip store if comparing
000245r 2  91 C1                STA     (TMP0),Y        ; otherwise, store in destination
000247r 2               COMPAR2:
000247r 2  D1 C1                CMP     (TMP0),Y        ; compare to destination
000249r 2  F0 03                BEQ     TMVAD           ; don't show address if equal
00024Br 2  20 rr rr             JSR     SHOWAD          ; show address
00024Er 2               TMVAD:
00024Er 2  24 CC                BIT     UPFLG           ; counting up or down?
000250r 2  30 0B                BMI     TDECAD          ; high bit set means we're counting down
000252r 2  E6 C1                INC     TMP0            ; increment destination low byte
000254r 2  D0 10                BNE     TINCOK
000256r 2  E6 C2                INC     TMP0+1          ; carry to high byte if necessary
000258r 2  D0 0C                BNE     TINCOK
00025Ar 2  4C rr rr             JMP     ERROR           ; error if high byte overflowed
00025Dr 2               TDECAD:
00025Dr 2  20 rr rr             JSR     SUBA1           ; decrement destination (TMP0)
000260r 2  20 rr rr             JSR     SUB21           ; decrement source (TMP2)
000263r 2  4C rr rr             JMP     TMOR
000266r 2               TINCOK:
000266r 2  20 rr rr             JSR     ADDA2           ; increment source (TMP2)
000269r 2               TMOR:
000269r 2  20 rr rr             JSR     SUB13           ; decrement length
00026Cr 2  B0 CC                BCS     TCLOOP          ; loop until length is 0
00026Er 2               TEXIT:
00026Er 2  4C rr rr             JMP     STRT            ; back to main loop
000271r 2               
000271r 2               ; -----------------------------------------------------------------------------
000271r 2               ; hunt memory [H]
000271r 2               HUNT:
000271r 2  20 rr rr             JSR     GETDIF          ; get start (TMP2) and end (TMP0) of haystack
000274r 2  B0 57                BCS     HERROR          ; carry indicates error
000276r 2  A0 00                LDY     #0
000278r 2  20 rr rr             JSR     GETCHR          ; get a single character
00027Br 2  C9 27                CMP     #39             ; is it a single quote?
00027Dr 2  D0 16                BNE     NOSTRH          ; if not, input needle as hex bytes
00027Fr 2  20 rr rr             JSR     GETCHR          ; if so, input needle as string
000282r 2  C9 00                CMP     #0
000284r 2  F0 47                BEQ     HERROR          ; error if needle isn't at least one byte
000286r 2               HPAR:
000286r 2  99 DA 00             STA     STAGE,Y         ; save char in staging area
000289r 2  C8                   INY
00028Ar 2  20 rr rr             JSR     GETCHR          ; get another char
00028Dr 2  F0 18                BEQ     HTGO            ; if it's null start searching
00028Fr 2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
000291r 2  D0 F3                BNE     HPAR            ; if not, get another character
000293r 2  F0 12                BEQ     HTGO            ; if so, start searching
000295r 2               NOSTRH:
000295r 2  20 rr rr             JSR     RDPAR           ; read hex bytes if string not indicated
000298r 2               HLP:
000298r 2  A5 C1                LDA     TMP0            ; save last read byte in staging area
00029Ar 2  99 DA 00             STA     STAGE,Y
00029Dr 2  C8                   INY                     ; get another hex byte
00029Er 2  20 rr rr             JSR     GETPAR
0002A1r 2  B0 04                BCS     HTGO            ; if there is none, start searching
0002A3r 2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
0002A5r 2  D0 F1                BNE     HLP             ; if not, get another byte
0002A7r 2               HTGO:
0002A7r 2  84 BA                STY     SAVY            ; save length of needle
0002A9r 2  20 rr rr             JSR     CRLF            ; new line
0002ACr 2               HSCAN:
0002ACr 2  A0 00                LDY     #0
0002AEr 2               HLP3:
0002AEr 2  B1 C3                LDA     (TMP2),Y        ; get first byte in haystack
0002B0r 2  D9 DA 00             CMP     STAGE,Y         ; compare it to first byte of needle
0002B3r 2  D0 08                BNE     HNOFT           ; if it doesn't match, we haven't found anything
0002B5r 2  C8                   INY                     ; if it does, check the next byte
0002B6r 2  C4 BA                CPY     SAVY            ; have we reached the end of the needle?
0002B8r 2  D0 F4                BNE     HLP3            ; if not, keep comparing bytes
0002BAr 2  20 rr rr             JSR     SHOWAD          ; match found, show address
0002BDr 2               HNOFT:
0002BDr 2  20 rr rr             JSR     STOP            ; no match, check for stop key
0002C0r 2  F0 08                BEQ     HEXIT           ; exit prematurely if pressed
0002C2r 2  20 rr rr             JSR     ADDA2           ; increment haystack pointer
0002C5r 2  20 rr rr             JSR     SUB13           ; decrement haystack length
0002C8r 2  B0 E2                BCS     HSCAN           ; still more haystack? keep searching
0002CAr 2               HEXIT:
0002CAr 2  4C rr rr             JMP     STRT            ; back to main loop
0002CDr 2               HERROR:
0002CDr 2  4C rr rr             JMP     ERROR           ; handle error
0002D0r 2               
0002D0r 2               
0002D0r 2               ; -----------------------------------------------------------------------------
0002D0r 2               ; fill memory [F]
0002D0r 2               FILL:
0002D0r 2  20 rr rr             JSR     GETDIF          ; start in TMP2, end in STASH, length in STORE
0002D3r 2  B0 20                BCS     FERROR          ; carry set indicates error
0002D5r 2  20 rr rr             JSR     GETPAR          ; get value to fill in TMP0
0002D8r 2  B0 1B                BCS     FERROR          ; carry set indicates error
0002DAr 2  20 rr rr             JSR     GETCHR          ; any more characters triggers an error
0002DDr 2  D0 16                BNE     FERROR
0002DFr 2  A0 00                LDY     #0              ; no offset
0002E1r 2               FILLP:
0002E1r 2  A5 C1                LDA     TMP0            ; load value to fill in accumulator
0002E3r 2  91 C3                STA     (TMP2),Y        ; store fill value in current address
0002E5r 2  20 rr rr             JSR     STOP            ; check for stop key
0002E8r 2  F0 08                BEQ     FSTART          ; if pressed, back to main loop
0002EAr 2  20 rr rr             JSR     ADDA2           ; increment address
0002EDr 2  20 rr rr             JSR     SUB13           ; decrement length
0002F0r 2  B0 EF                BCS     FILLP           ; keep going until length reaches 0
0002F2r 2               FSTART:
0002F2r 2  4C rr rr             JMP     STRT            ; back to main loop
0002F5r 2               FERROR:
0002F5r 2  4C rr rr             JMP     ERROR           ; handle error
0002F8r 2               ; -----------------------------------------------------------------------------
0002F8r 2               ; Boot System [B]
0002F8r 2               BOOT:
0002F8r 2  B0 21                BCS     BOOTX           ; exit with error if no parameter given
0002FAr 2  A5 C1                LDA     TMP0
0002FCr 2  29 0F                AND     #$0F
0002FEr 2  8D 28 06             STA     DSKUNIT
000301r 2  A9 00                LDA     #$00
000303r 2  8D 10 06             STA     debcyll         ;
000306r 2  8D 11 06             STA     debcylm         ;
000309r 2  8D 12 06             STA     debsehd         ;
00030Cr 2  20 rr rr             JSR     GETPAR          ; get value for next byte of memory
00030Fr 2  B0 0A                BCS     BOOTX           ; exit with error if no parameter given
000311r 2  A5 C1                LDA     TMP0
000313r 2  85 32                STA     farfunct
000315r 2  20 F0 FF             JSR     DO_FARCALL
000318r 2  4C 00 04             JMP     hstbuf
00031Br 2               BOOTX:
00031Br 2  4C rr rr             JMP     ERROR           ; back to main loop
00031Er 2               
00031Er 2               
00031Er 2               
00031Er 2               ; -----------------------------------------------------------------------------
00031Er 2               ; assemble [A.]
00031Er 2               ; read in mnemonic
00031Er 2               ASTART:
00031Er 2  4C rr rr             JMP     STRT            ; back to main loop
000321r 2               ASSEM:
000321r 2  B0 31                BCS     AERROR          ; error if no address given
000323r 2  20 rr rr             JSR     COPY12          ; copy address to TMP2
000326r 2               AGET1:
000326r 2  A2 00                LDX     #0
000328r 2  86 D1                STX     U0AA0+1         ; clear byte that mnemonic gets shifted into
00032Ar 2  86 CB                STX     DIGCNT          ; clear digit count
00032Cr 2               AGET2:
00032Cr 2  20 rr rr             JSR     GETCHR          ; get a char
00032Fr 2  D0 04                BNE     ALMOR           ; proceed if the character isn't null
000331r 2  E0 00                CPX     #0              ; it's null, have read a mnemonic yet?
000333r 2  F0 E9                BEQ     ASTART          ; if not, silently go back to main loop
000335r 2               ALMOR:
000335r 2  C9 20                CMP     #$20            ; skip leading spaces
000337r 2  F0 ED                BEQ     AGET1
000339r 2  95 C7                STA     MNEMW,X         ; put character in mnemonic buffer
00033Br 2  E8                   INX
00033Cr 2  E0 03                CPX     #3              ; have we read 3 characters yet?
00033Er 2  D0 EC                BNE     AGET2           ; if not, get next character
000340r 2               
000340r 2               ; compress mnemonic into two bytes
000340r 2               ASQEEZ:
000340r 2  CA                   DEX                     ; move to previous char
000341r 2  30 14                BMI     AOPRND          ; if we're done with mnemonic, look for operand
000343r 2  B5 C7                LDA     MNEMW,X         ; get current character
000345r 2  38                   SEC                     ; pack 3-letter mnemonic into 2 bytes (15 bits)
000346r 2  E9 3F                SBC     #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
000348r 2  A0 05                LDY     #$05            ; letters now fit in 5 bits; shift them out
00034Ar 2               ASHIFT:
00034Ar 2  4A                   LSR     A               ;   into the first two bytes of the inst buffer
00034Br 2  66 D1                ROR     U0AA0+1         ; catch the low bit from accumulator in right byte
00034Dr 2  66 D0                ROR     U0AA0           ; catch the low bit from right byte in left byte
00034Fr 2  88                   DEY                     ; count down bits
000350r 2  D0 F8                BNE     ASHIFT          ; keep looping until we reach zero
000352r 2  F0 EC                BEQ     ASQEEZ          ; unconditional branch to handle next char
000354r 2               AERROR:
000354r 2  4C rr rr             JMP     ERROR           ; handle error
000357r 2               
000357r 2               ; parse operand
000357r 2               AOPRND:
000357r 2  A2 02                LDX     #2              ; mnemonic is in first two bytes so start at third
000359r 2               ASCAN:
000359r 2  A5 CB                LDA     DIGCNT          ; did we find address digits last time?
00035Br 2  D0 28                BNE     AFORM1          ; if so, look for mode chars
00035Dr 2  20 rr rr             JSR     RDVAL           ; otherwise, look for an address
000360r 2  F0 21                BEQ     AFORM0          ; we didn't find an address, look for characters
000362r 2  B0 F0                BCS     AERROR          ; carry flag indicates error
000364r 2  A9 24                LDA     #'$'
000366r 2  95 D0                STA     U0AA0,X         ; prefix addresses with $
000368r 2  E8                   INX                     ; next position in buffer
000369r 2  A0 04                LDY     #4              ; non-zero page addresses are 4 hex digits
00036Br 2  A5 CD                LDA     NUMBIT          ; check numeric base in which address was given
00036Dr 2  C9 08                CMP     #8              ; for addresses given in octal or binary
00036Fr 2  90 04                BCC     AADDR           ;   use only the high byte to determine page
000371r 2  C4 CB                CPY     DIGCNT          ; for decimal or hex, force non-zero page addressing
000373r 2  F0 06                BEQ     AFILL0          ;   if address was given with four digits or more
000375r 2               AADDR:
000375r 2  A5 C2                LDA     TMP0+1          ; check whether high byte of address is zero
000377r 2  D0 02                BNE     AFILL0          ; non-zero high byte means we're not in zero page
000379r 2  A0 02                LDY     #2              ; if it's in zero page, addr is 2 hex digits
00037Br 2               AFILL0:
00037Br 2  A9 30                LDA     #$30            ; use 0 as placeholder for each hex digit in addr
00037Dr 2               AFIL0L:
00037Dr 2  95 D0                STA     U0AA0,X         ; put placeholder in assembly buffer
00037Fr 2  E8                   INX                     ; move to next byte in buffer
000380r 2  88                   DEY                     ; decrement number of remaining digits
000381r 2  D0 FA                BNE     AFIL0L          ; loop until all digits have been placed
000383r 2               AFORM0:
000383r 2  C6 B9                DEC     CHRPNT          ; non-numeric input; back 1 char to see what it was
000385r 2               AFORM1:
000385r 2  20 rr rr             JSR     GETCHR          ; get next character
000388r 2  F0 0D                BEQ     AESCAN          ; if there is none, we're finished scanning
00038Ar 2  C9 20                CMP     #$20            ; skip spaces
00038Cr 2  F0 CB                BEQ     ASCAN
00038Er 2  95 D0                STA     U0AA0,X         ; store character in assembly buffer
000390r 2  E8                   INX                     ; move to next byte in buffer
000391r 2  E0 0A                CPX     #U0AAE-U0AA0    ; is instruction buffer full?
000393r 2  90 C4                BCC     ASCAN           ; if not, keep scanning
000395r 2  B0 BD                BCS     AERROR          ; error if buffer is full
000397r 2               
000397r 2               ; find matching opcode
000397r 2               AESCAN:
000397r 2  86 B7                STX     STORE           ; save number of bytes in assembly buffer
000399r 2  A2 00                LDX     #0              ; start at opcode $00 and check every one until
00039Br 2  86 CB                STX     OPCODE          ;   we find one that matches our criteria
00039Dr 2               ATRYOP:
00039Dr 2  A2 00                LDX     #0
00039Fr 2  86 BB                STX     U9F             ; reset index into work buffer
0003A1r 2  A5 CB                LDA     OPCODE
0003A3r 2  20 rr rr             JSR     INSTXX          ; look up instruction format for current opcode
0003A6r 2  A6 C5                LDX     ACMD            ; save addressing command for later
0003A8r 2  86 B8                STX     STORE+1
0003AAr 2  AA                   TAX                     ; use current opcode as index
0003ABr 2  BD rr rr             LDA     MNEMR,X         ; check right byte of compressed mnemonic
0003AEr 2  20 rr rr             JSR     CHEKOP
0003B1r 2  BD rr rr             LDA     MNEML,X         ; check left byte of compressed mnemonic
0003B4r 2  20 rr rr             JSR     CHEKOP
0003B7r 2  A2 06                LDX     #6              ; 6 possible characters to check against operand
0003B9r 2               TRYIT:
0003B9r 2  E0 03                CPX     #3              ; are we on character 3?
0003BBr 2  D0 12                BNE     TRYMOD          ; if not, check operand characters
0003BDr 2  A4 C6                LDY     LENGTH          ; otherwise, check number of bytes in operand
0003BFr 2  F0 0E                BEQ     TRYMOD          ; if zero, check operand characters
0003C1r 2               TRYAD:
0003C1r 2  A5 C5                LDA     ACMD            ; otherwise, look for an address
0003C3r 2  C9 E8                CMP     #$E8            ; special case for relative addressing mode
0003C5r 2                                               ;   since it's specified with 4 digits in assembly
0003C5r 2                                               ;   but encoded with only 1 byte in object code
0003C5r 2  A9 30                LDA     #$30            ; '0' is the digit placeholder we're looking for
0003C7r 2  B0 1D                BCS     TRY4B           ; ACMD >= $E8 indicates relative addressing
0003C9r 2  20 rr rr             JSR     CHEK2B          ; ACMD < $E8 indicates normal addressing
0003CCr 2  88                   DEY                     ; consume byte
0003CDr 2  D0 F2                BNE     TRYAD           ; check for 2 more digits if not zero-page
0003CFr 2               TRYMOD:
0003CFr 2  06 C5                ASL     ACMD            ; shift a bit out of the addressing command
0003D1r 2  90 0E                BCC     UB4DF           ; if it's zero, skip checking current character
0003D3r 2  BD rr rr             LDA     CHAR1-1,X
0003D6r 2  20 rr rr             JSR     CHEKOP          ; otherwise first character against operand
0003D9r 2  BD rr rr             LDA     CHAR2-1,X       ; get second character to check
0003DCr 2  F0 03                BEQ     UB4DF           ; if it's zero, skip checking it
0003DEr 2  20 rr rr             JSR     CHEKOP          ; otherwise check it against hte operand
0003E1r 2               UB4DF:
0003E1r 2  CA                   DEX                     ; move to next character
0003E2r 2  D0 D5                BNE     TRYIT           ; repeat tests
0003E4r 2  F0 06                BEQ     TRYBRAN
0003E6r 2               TRY4B:
0003E6r 2  20 rr rr             JSR     CHEK2B          ; check for 4 digit address placeholder
0003E9r 2  20 rr rr             JSR     CHEK2B          ;   by checking for 2 digits twice
0003ECr 2               TRYBRAN:
0003ECr 2  A5 B7                LDA     STORE           ; get number of bytes in assembly buffer
0003EEr 2  C5 BB                CMP     U9F             ; more bytes left to check?
0003F0r 2  F0 03                BEQ     ABRAN           ; if not, we've found a match; build instruction
0003F2r 2  4C rr rr             JMP     BUMPOP          ; if so, this opcode doesn't match; try the next
0003F5r 2               
0003F5r 2               ; convert branches to relative address
0003F5r 2               ABRAN:
0003F5r 2  A4 C6                LDY     LENGTH          ; get number of bytes in operand
0003F7r 2  F0 33                BEQ     A1BYTE          ; if none, just output the opcode
0003F9r 2  A5 B8                LDA     STORE+1         ; otherwise check the address format
0003FBr 2  C9 9D                CMP     #$9D            ; is it a relative branch?
0003FDr 2  D0 25                BNE     OBJPUT          ; if not, skip relative branch calculation
0003FFr 2  A5 C1                LDA     TMP0            ; calculate the difference between the current
000401r 2  E5 C3                SBC     TMP2            ;   address and the branch target (low byte)
000403r 2  AA                   TAX                     ; save it in X
000404r 2  A5 C2                LDA     TMP0+1          ; borrow from the high byte if necessary
000406r 2  E5 C4                SBC     TMP2+1
000408r 2  90 0B                BCC     ABBACK          ; if result is negative, we're branching back
00040Ar 2  F0 03                BEQ     :++             ; high bytes must be equal when branching forward
00040Cr 2               :
00040Cr 2  4C rr rr             JMP     SERROR
00040Fr 2               :
00040Fr 2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
000411r 2  B0 F9                BCS     :--             ; error if the address is too far away
000413r 2  90 08                BCC     ABRANX
000415r 2               ABBACK:
000415r 2  A8                   TAY                     ; when branching backward high byte of target must
000416r 2  C8                   INY                     ;   be 1 less than high byte of current address
000417r 2  D0 7D                BNE     SERROR          ; if not, it's too far away
000419r 2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
00041Br 2  90 79                BCC     SERROR          ; if not, it's too far away
00041Dr 2               ABRANX:
00041Dr 2  CA                   DEX                     ; adjust branch target relative to the
00041Er 2  CA                   DEX                     ;   instruction following this one
00041Fr 2  8A                   TXA
000420r 2  A4 C6                LDY     LENGTH          ; load length of operand
000422r 2  D0 03                BNE     OBJP2           ; don't use the absolute address
000424r 2               
000424r 2               ; assemble machine code
000424r 2               OBJPUT:
000424r 2  B9 C0 00             LDA     TMP0-1,Y        ; get the operand
000427r 2               OBJP2:
000427r 2  91 C3                STA     (TMP2),Y        ; store it after the opcode
000429r 2  88                   DEY
00042Ar 2  D0 F8                BNE     OBJPUT          ; copy the other byte of operand if there is one
00042Cr 2               A1BYTE:
00042Cr 2  A5 CB                LDA     OPCODE          ; put opcode into instruction
00042Er 2  91 C3                STA     (TMP2),Y
000430r 2  A9 0D                LDA     #$0D            ; cr
000432r 2  20 rr rr             JSR     CHROUT
000435r 2  A0 2E                LDY     #MSG7-MSGBAS    ; "A " prefix
000437r 2  20 rr rr             JSR     SNDCLR          ; clear line
00043Ar 2  A9 41                LDA     #'A'
00043Cr 2  20 rr rr             JSR     CHROUT
00043Fr 2  A9 20                LDA     #' '
000441r 2  20 rr rr             JSR     CHROUT
000444r 2  20 rr rr             JSR     DISLIN          ; disassemble the instruction we just assembled
000447r 2  E6 C6                INC     LENGTH          ; instruction length = operand length + 1 byte
000449r 2  A5 C6                LDA     LENGTH          ;   for the opcode
00044Br 2  20 rr rr             JSR     BUMPAD2         ; increment address by length of instruction
00044Er 2                                               ; setup for the next assemble command
00044Er 2  20 rr rr             JSR     CRLF
000451r 2  A9 41                LDA     #'A'            ; stuff keyboard buffer with next assemble command:
000453r 2  8D 00 04             STA     INBUFF
000456r 2  20 rr rr             JSR     IOF_OUTCH
000459r 2  A9 20                LDA     #' '            ;   after the previously assembled instruction
00045Br 2  8D 01 04             STA     INBUFF+1
00045Er 2  20 rr rr             JSR     IOF_OUTCH
000461r 2  A5 C4                LDA     TMP2+1          ; convert high byte of next address to hex
000463r 2  20 rr rr             JSR     ASCTWO
000466r 2  8D 02 04             STA     INBUFF+2        ; put it in the keyboard buffer
000469r 2  20 rr rr             JSR     IOF_OUTCH
00046Cr 2  8E 03 04             STX     INBUFF+3
00046Fr 2  8A                   TXA
000470r 2  20 rr rr             JSR     IOF_OUTCH
000473r 2  A5 C3                LDA     TMP2            ; convert low byte of next address to hex
000475r 2  20 rr rr             JSR     ASCTWO
000478r 2  8D 04 04             STA     INBUFF+4        ; put it in the keyboard buffer
00047Br 2  20 rr rr             JSR     IOF_OUTCH
00047Er 2  8E 05 04             STX     INBUFF+5
000481r 2  8A                   TXA
000482r 2  20 rr rr             JSR     IOF_OUTCH
000485r 2  A9 20                LDA     #' '            ;   after the previously assembled instruction
000487r 2  8D 06 04             STA     INBUFF+6
00048Ar 2  20 rr rr             JSR     IOF_OUTCH
00048Dr 2  A2 07                LDX     #7              ; set number of chars in keyboard buffer
00048Fr 2  A9 00                LDA     #$00
000491r 2  85 B9                STA     CHRPNT
000493r 2  4C rr rr             JMP     SMOVE           ; back to main loop
000496r 2               SERROR:
000496r 2  4C rr rr             JMP     ERROR           ; handle error
000499r 2               
000499r 2               ; check characters in operand
000499r 2               CHEK2B:
000499r 2  20 rr rr             JSR     CHEKOP          ; check two bytes against value in accumulator
00049Cr 2               CHEKOP:
00049Cr 2  86 CA                STX     SAVX            ; stash X
00049Er 2  A6 BB                LDX     U9F             ; get current index into work buffer
0004A0r 2  D5 D0                CMP     U0AA0,X         ; check whether this opcode matches the buffer
0004A2r 2  F0 09                BEQ     OPOK            ;   matching so far, check the next criteria
0004A4r 2  68                   PLA                     ; didn't match, so throw away return address
0004A5r 2  68                   PLA                     ;   on the stack because we're starting over
0004A6r 2               BUMPOP:
0004A6r 2  E6 CB                INC     OPCODE          ; check the next opcode
0004A8r 2  F0 EC                BEQ     SERROR          ; error if we tried every opcode and none fit
0004AAr 2  4C rr rr             JMP     ATRYOP          ; start over with new opcode
0004ADr 2               OPOK:
0004ADr 2  E6 BB                INC     U9F             ; opcode matches so far; check the next criteria
0004AFr 2  A6 CA                LDX     SAVX            ; restore X
0004B1r 2  60                   RTS
0004B2r 2               
0004B2r 2               ; -----------------------------------------------------------------------------
0004B2r 2               ; disassemble [D]
0004B2r 2               DISASS:
0004B2r 2  B0 08                BCS     DIS0AD          ; if no address was given, start from last address
0004B4r 2  20 rr rr             JSR     COPY12          ; copy start address to TMP2
0004B7r 2  20 rr rr             JSR     GETPAR          ; get end address in TMP0
0004BAr 2  90 06                BCC     DIS2AD          ; if one was given, skip default
0004BCr 2               DIS0AD:
0004BCr 2  A9 14                LDA     #$14            ; disassemble 14 bytes by default
0004BEr 2  85 C1                STA     TMP0            ; store length in TMP0
0004C0r 2  D0 05                BNE     DISGO           ; skip length calculation
0004C2r 2               DIS2AD:
0004C2r 2  20 rr rr             JSR     SUB12           ; calculate number of bytes between start and end
0004C5r 2  90 1C                BCC     DERROR          ; error if end address is before start address
0004C7r 2               DISGO:
0004C7r 2  20 rr rr             JSR     CLINE           ; clear the current line
0004CAr 2  20 rr rr             JSR     STOP            ; check for stop key
0004CDr 2  F0 11                BEQ     DISEXIT         ; exit early if pressed
0004CFr 2  20 rr rr             JSR     DSOUT1          ; output disassembly prefix ". "
0004D2r 2  E6 C6                INC     LENGTH
0004D4r 2  A5 C6                LDA     LENGTH          ; add length of last instruction to start address
0004D6r 2  20 rr rr             JSR     BUMPAD2
0004D9r 2  A5 C6                LDA     LENGTH          ; subtract length of last inst from end address
0004DBr 2  20 rr rr             JSR     SUBA2
0004DEr 2  B0 E7                BCS     DISGO
0004E0r 2               DISEXIT:
0004E0r 2  4C rr rr             JMP     STRT            ; back to mainloop
0004E3r 2               DERROR:
0004E3r 2  4C rr rr             JMP     ERROR
0004E6r 2               
0004E6r 2               DSOUT1:
0004E6r 2  A9 2E                LDA     #'.'            ; output ". " prefix to allow edit and reassemble
0004E8r 2  20 rr rr             JSR     CHROUT
0004EBr 2  20 rr rr             JSR     SPACE
0004EEr 2               
0004EEr 2               DISLIN:
0004EEr 2  20 rr rr             JSR     SHOWAD          ; show the address of the instruction
0004F1r 2  20 rr rr             JSR     SPACE           ; insert a space
0004F4r 2  A0 00                LDY     #0              ; no offset
0004F6r 2  B1 C3                LDA     (TMP2),Y        ; load operand of current instruction
0004F8r 2  20 rr rr             JSR     INSTXX          ; get mnemonic and addressing mode for opcode
0004FBr 2  48                   PHA                     ; save index into mnemonic table
0004FCr 2  A6 C6                LDX     LENGTH          ; get length of operand
0004FEr 2  E8                   INX                     ; add 1 byte for opcode
0004FFr 2               DSBYT:
0004FFr 2  CA                   DEX                     ; decrement index
000500r 2  10 0C                BPL     DSHEX           ; show hex for byte being disassembled
000502r 2  84 BA                STY     SAVY            ; save index
000504r 2  A0 30                LDY     #MSG8-MSGBAS    ; skip 3 spaces
000506r 2  20 rr rr             JSR     SNDMSG
000509r 2  A4 BA                LDY     SAVY            ; restore index
00050Br 2  4C rr rr             JMP     NXBYT
00050Er 2               DSHEX:
00050Er 2  B1 C3                LDA     (TMP2),Y        ; show hex for byte
000510r 2  20 rr rr             JSR     WRBYTE
000513r 2               
000513r 2               NXBYT:
000513r 2  C8                   INY                     ; next byte
000514r 2  C0 03                CPY     #3              ; have we output 3 bytes yet?
000516r 2  90 E7                BCC     DSBYT           ; if not, loop
000518r 2  68                   PLA                     ; restore index into mnemonic table
000519r 2  A2 03                LDX     #3              ; 3 letters in mnemonic
00051Br 2  20 rr rr             JSR     PROPXX          ; print mnemonic
00051Er 2  A2 06                LDX     #6              ; 6 possible address mode character combos
000520r 2               PRADR1:
000520r 2  E0 03                CPX     #3              ; have we checked the third combo yet?
000522r 2  D0 14                BNE     PRADR3          ; if so, output the leading characters
000524r 2  A4 C6                LDY     LENGTH          ; get the length of the operand
000526r 2  F0 10                BEQ     PRADR3          ; if it's zero, there's no operand to print
000528r 2               PRADR2:
000528r 2  A5 C5                LDA     ACMD            ; otherwise, get the addressing mode
00052Ar 2  C9 E8                CMP     #$E8            ; check for relative addressing
00052Cr 2  08                   PHP                     ; save result of check
00052Dr 2  B1 C3                LDA     (TMP2),Y        ; get the operand
00052Fr 2  28                   PLP                     ; restore result of check
000530r 2  B0 1C                BCS     RELAD           ; handle a relative address
000532r 2  20 rr rr             JSR     WRTWO           ; output digits from address
000535r 2  88                   DEY
000536r 2  D0 F0                BNE     PRADR2          ; repeat for next byte of operand, if there is one
000538r 2               PRADR3:
000538r 2  06 C5                ASL     ACMD            ; check whether addr mode uses the current char
00053Ar 2  90 0E                BCC     PRADR4          ; if not, skip it
00053Cr 2  BD rr rr             LDA     CHAR1-1,X       ; look up the first char in the table
00053Fr 2  20 rr rr             JSR     CHROUT          ; print first char
000542r 2  BD rr rr             LDA     CHAR2-1,X       ; look up the second char in the table
000545r 2  F0 03                BEQ     PRADR4          ; if there's no second character, skip it
000547r 2  20 rr rr             JSR     CHROUT          ; print second char
00054Ar 2               PRADR4:
00054Ar 2  CA                   DEX                     ; next potential address mode character
00054Br 2  D0 D3                BNE     PRADR1          ; loop if we haven't checked them all yet
00054Dr 2  60                   RTS                     ; back to caller
00054Er 2               RELAD:
00054Er 2  20 rr rr             JSR     UB64D           ; calculate absolute address from relative
000551r 2  18                   CLC
000552r 2  69 01                ADC     #1              ; adjust address relative to next instruction
000554r 2  D0 01                BNE     RELEND          ; don't increment high byte unless we overflowed
000556r 2  E8                   INX                     ; increment high byte
000557r 2               RELEND:
000557r 2  4C rr rr             JMP     WRADDR          ; print address
00055Ar 2               
00055Ar 2               UB64D:
00055Ar 2  A6 C4                LDX     TMP2+1          ; get high byte of current address
00055Cr 2  A8                   TAY                     ; is relative address positive or negative?
00055Dr 2  10 01                BPL     RELC2           ; if positive, leave high byte alone
00055Fr 2  CA                   DEX                     ; if negative, decrement high byte
000560r 2               RELC2:
000560r 2  65 C3                ADC     TMP2            ; add relative address to low byte
000562r 2  90 01                BCC     RELC3           ; if there's no carry, we're done
000564r 2  E8                   INX                     ; if there's a carry, increment the high byte
000565r 2               RELC3:
000565r 2  60                   RTS
000566r 2               
000566r 2               ; -----------------------------------------------------------------------------
000566r 2               ; get opcode mode and length
000566r 2               
000566r 2               ; Note: the labels are different, but the code of this subroutine is almost
000566r 2               ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
000566r 2               ; the Apple II Red Book. I'm not sure exactly where this code originated
000566r 2               ; (MOS or Apple) but it's clear that this part of Supermon64 and the
000566r 2               ; Mini-Asssembler share a common heritage.  The comments showing the way the
000566r 2               ; opcodes are transformed into indexes for the mnemonic lookup table come
000566r 2               ; from the Mini-Assembler source.
000566r 2               
000566r 2               INSTXX:
000566r 2  A8                   TAY                     ; stash opcode in accumulator in Y for later
000567r 2  4A                   LSR     A               ; is opcode even or odd?
000568r 2  90 0B                BCC     IEVEN
00056Ar 2  4A                   LSR     A
00056Br 2  B0 17                BCS     ERR             ; invalid opcodes XXXXXX11
00056Dr 2  C9 22                CMP     #$22
00056Fr 2  F0 13                BEQ     ERR             ; invalid opcode 10001001
000571r 2  29 07                AND     #$07            ; mask bits to 10000XXX
000573r 2  09 80                ORA     #$80
000575r 2               IEVEN:
000575r 2  4A                   LSR     A               ; LSB determines whether to use left/right nybble
000576r 2  AA                   TAX                     ; get format index using remaining high bytes
000577r 2  BD rr rr             LDA     MODE,X
00057Ar 2  B0 04                BCS     RTMODE          ; look at left or right nybble based on carry bit
00057Cr 2  4A                   LSR     A               ; if carry = 0, use left nybble
00057Dr 2  4A                   LSR     A
00057Er 2  4A                   LSR     A
00057Fr 2  4A                   LSR     A
000580r 2               RTMODE:
000580r 2  29 0F                AND     #$0F            ; if carry = 1, use right nybble
000582r 2  D0 04                BNE     GETFMT
000584r 2               ERR:
000584r 2  A0 80                LDY     #$80            ; substitute 10000000 for invalid opcodes
000586r 2  A9 00                LDA     #0
000588r 2               GETFMT:
000588r 2  AA                   TAX
000589r 2  BD rr rr             LDA     MODE2,X         ; lookup operand format using selected nybble
00058Cr 2  85 C5                STA     ACMD            ; save for later use
00058Er 2  29 03                AND     #$03            ; lower 2 bits indicate number of bytes in operand
000590r 2  85 C6                STA     LENGTH
000592r 2  98                   TYA                     ; restore original opcode
000593r 2  29 8F                AND     #$8F            ; mask bits to X000XXXX
000595r 2  AA                   TAX                     ; save it
000596r 2  98                   TYA                     ; restore original opcode
000597r 2  A0 03                LDY     #3
000599r 2  E0 8A                CPX     #$8A            ; check if opcode = 1XXX1010
00059Br 2  F0 0B                BEQ     GTFM4
00059Dr 2               GTFM2:
00059Dr 2  4A                   LSR     A               ; transform opcode into index for mnemonic table
00059Er 2  90 08                BCC     GTFM4
0005A0r 2  4A                   LSR     A               ; opcodes transformed as follows:
0005A1r 2               GTFM3:
0005A1r 2  4A                   LSR     A               ; 1XXX1010->00101XXX
0005A2r 2  09 20                ORA     #$20            ; XXXYYY01->00111XXX
0005A4r 2  88                   DEY                     ; XXXYYY10->00111XXX
0005A5r 2  D0 FA                BNE     GTFM3           ; XXXYY100->00110XXX
0005A7r 2  C8                   INY                     ; XXXXX000->000XXXXX
0005A8r 2               GTFM4:
0005A8r 2  88                   DEY
0005A9r 2  D0 F2                BNE     GTFM2
0005ABr 2  60                   RTS
0005ACr 2               
0005ACr 2               ; -----------------------------------------------------------------------------
0005ACr 2               ; extract and print packed mnemonics
0005ACr 2               PROPXX:
0005ACr 2  A8                   TAY                     ; use index in accumulator to look up mnemonic
0005ADr 2  B9 rr rr             LDA     MNEML,Y         ;   and place a temporary copy in STORE
0005B0r 2  85 B7                STA     STORE
0005B2r 2  B9 rr rr             LDA     MNEMR,Y
0005B5r 2  85 B8                STA     STORE+1
0005B7r 2               PRMN1:
0005B7r 2  A9 00                LDA     #0              ; clear accumulator
0005B9r 2  A0 05                LDY     #$05            ; shift 5 times
0005BBr 2               PRMN2:
0005BBr 2  06 B8                ASL     STORE+1         ; shift right byte
0005BDr 2  26 B7                ROL     STORE           ; rotate bits from right byte into left byte
0005BFr 2  2A                   ROL     A               ; rotate bits from left byte into accumulator
0005C0r 2  88                   DEY                     ; next bit
0005C1r 2  D0 F8                BNE     PRMN2           ; loop until all bits shifted
0005C3r 2  69 3F                ADC     #$3F            ; calculate ascii code for letter by adding to '?'
0005C5r 2  20 rr rr             JSR     CHROUT          ; output letter
0005C8r 2  CA                   DEX                     ; next letter
0005C9r 2  D0 EC                BNE     PRMN1           ; loop until all 3 letters are output
0005CBr 2  4C rr rr             JMP     SPACE           ; output space
0005CEr 2               
0005CEr 2               ; -----------------------------------------------------------------------------
0005CEr 2               ; read parameters
0005CEr 2               RDPAR:
0005CEr 2  C6 B9                DEC     CHRPNT          ; back up one char
0005D0r 2               GETPAR:
0005D0r 2  20 rr rr             JSR     RDVAL           ; read the value
0005D3r 2  B0 15                BCS     GTERR           ; carry set indicates error
0005D5r 2  20 rr rr             JSR     GOTCHR          ; check previous character
0005D8r 2  D0 08                BNE     CKTERM          ; if it's not null, check if it's a valid separator
0005DAr 2  C6 B9                DEC     CHRPNT          ; back up one char
0005DCr 2  A5 CB                LDA     DIGCNT          ; get number of digits read
0005DEr 2  D0 11                BNE     GETGOT          ; found some digits
0005E0r 2  F0 0D                BEQ     GTNIL           ; didn't find any digits
0005E2r 2               CKTERM:
0005E2r 2  C9 20                CMP     #$20            ; space or comma are valid separators
0005E4r 2  F0 0B                BEQ     GETGOT          ; anything else is an error
0005E6r 2  C9 2C                CMP     #','
0005E8r 2  F0 07                BEQ     GETGOT
0005EAr 2               GTERR:
0005EAr 2  68                   PLA                     ; encountered error
0005EBr 2  68                   PLA                     ; get rid of command vector pushed on stack
0005ECr 2  4C rr rr             JMP     ERROR           ; handle error
0005EFr 2               GTNIL:
0005EFr 2  38                   SEC                     ; set carry to indicate no parameter found
0005F0r 2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
0005F1r 2               GETGOT:
0005F1r 2  18                   CLC                     ; clear carry to indicate paremeter returned
0005F2r 2  A5 CB                LDA     DIGCNT          ; return number of digits in A
0005F4r 2  60                   RTS                     ; return to address pushed from vector table
0005F5r 2               
0005F5r 2               ; -----------------------------------------------------------------------------
0005F5r 2               ; read a value in the specified base
0005F5r 2               RDVAL:
0005F5r 2  A9 00                LDA     #0              ; clear temp
0005F7r 2  85 C1                STA     TMP0
0005F9r 2  85 C2                STA     TMP0+1
0005FBr 2  85 CB                STA     DIGCNT          ; clear digit counter
0005FDr 2  8A                   TXA                     ; save X and Y
0005FEr 2  48                   PHA
0005FFr 2  98                   TYA
000600r 2  48                   PHA
000601r 2               RDVMOR:
000601r 2  20 rr rr             JSR     GETCHR          ; get next character from input buffer
000604r 2  F0 1C                BEQ     RDNILK          ; null at end of buffer
000606r 2  C9 20                CMP     #$20            ; skip spaces
000608r 2  F0 F7                BEQ     RDVMOR
00060Ar 2  A2 03                LDX     #3              ; check numeric base [$+&%]
00060Cr 2               GNMODE:
00060Cr 2  DD rr rr             CMP     HIKEY,X
00060Fr 2  F0 06                BEQ     GOTMOD          ; got a match, set up base
000611r 2  CA                   DEX
000612r 2  10 F8                BPL     GNMODE          ; check next base
000614r 2  E8                   INX                     ; default to hex
000615r 2  C6 B9                DEC     CHRPNT          ; back up one character
000617r 2               GOTMOD:
000617r 2  BC rr rr             LDY     MODTAB,X        ; get base value
00061Ar 2  BD rr rr             LDA     LENTAB,X        ; get bits per digit
00061Dr 2  85 CD                STA     NUMBIT          ; store bits per digit
00061Fr 2               NUDIG:
00061Fr 2  20 rr rr             JSR     GETCHR          ; get next char in A
000622r 2               RDNILK:
000622r 2  F0 59                BEQ     RDNIL           ; end of number if no more characters
000624r 2  38                   SEC
000625r 2  E9 30                SBC     #$30            ; subtract ascii value of 0 to get numeric value
000627r 2  90 54                BCC     RDNIL           ; end of number if character was less than 0
000629r 2  C9 0A                CMP     #$0A
00062Br 2  90 06                BCC     DIGMOR          ; not a hex digit if less than A
00062Dr 2  E9 07                SBC     #$07            ; 7 chars between ascii 9 and A, so subtract 7
00062Fr 2  C9 10                CMP     #$10            ; end of number if char is greater than F
000631r 2  B0 4A                BCS     RDNIL
000633r 2               DIGMOR:
000633r 2  85 CC                STA     INDIG           ; store the digit
000635r 2  C4 CC                CPY     INDIG           ; compare base with the digit
000637r 2  90 42                BCC     RDERR           ; error if the digit >= the base
000639r 2  F0 40                BEQ     RDERR
00063Br 2  E6 CB                INC     DIGCNT          ; increment the number of digits
00063Dr 2  C0 0A                CPY     #10
00063Fr 2  D0 09                BNE     NODECM          ; skip the next part if not using base 10
000641r 2  A2 01                LDX     #1
000643r 2               DECLP1:
000643r 2  B5 C1                LDA     TMP0,X          ; stash the previous 16-bit value for later use
000645r 2  95 CE                STA     STASH,X
000647r 2  CA                   DEX
000648r 2  10 F9                BPL     DECLP1
00064Ar 2               NODECM:
00064Ar 2  A6 CD                LDX     NUMBIT          ; number of bits to shift
00064Cr 2               TIMES2:
00064Cr 2  06 C1                ASL     TMP0            ; shift 16-bit value by specified number of bits
00064Er 2  26 C2                ROL     TMP0+1
000650r 2  B0 29                BCS     RDERR           ; error if we overflowed 16 bits
000652r 2  CA                   DEX
000653r 2  D0 F7                BNE     TIMES2          ; shift remaining bits
000655r 2  C0 0A                CPY     #10
000657r 2  D0 14                BNE     NODEC2          ; skip the next part if not using base 10
000659r 2  06 CE                ASL     STASH           ; shift the previous 16-bit value one bit left
00065Br 2  26 CF                ROL     STASH+1
00065Dr 2  B0 1C                BCS     RDERR           ; error if we overflowed 16 bits
00065Fr 2  A5 CE                LDA     STASH           ; add shifted previous value to current value
000661r 2  65 C1                ADC     TMP0
000663r 2  85 C1                STA     TMP0
000665r 2  A5 CF                LDA     STASH+1
000667r 2  65 C2                ADC     TMP0+1
000669r 2  85 C2                STA     TMP0+1
00066Br 2  B0 0E                BCS     RDERR           ; error if we overflowed 16 bits
00066Dr 2               NODEC2:
00066Dr 2  18                   CLC
00066Er 2  A5 CC                LDA     INDIG           ; load current digit
000670r 2  65 C1                ADC     TMP0            ; add current digit to low byte
000672r 2  85 C1                STA     TMP0            ; and store result back in low byte
000674r 2  8A                   TXA                     ; A=0
000675r 2  65 C2                ADC     TMP0+1          ; add carry to high byte
000677r 2  85 C2                STA     TMP0+1          ; and store result back in high byte
000679r 2  90 A4                BCC     NUDIG           ; get next digit if we didn't overflow
00067Br 2               RDERR:
00067Br 2  38                   SEC                     ; set carry to indicate error
00067Cr 2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00067Dr 2               RDNIL:
00067Dr 2  18                   CLC                     ; clear carry to indicate success
00067Er 2  84 CD                STY     NUMBIT          ; save base of number
000680r 2  68                   PLA                     ; restore X and Y
000681r 2  A8                   TAY
000682r 2  68                   PLA
000683r 2  AA                   TAX
000684r 2  A5 CB                LDA     DIGCNT          ; return number of digits in A
000686r 2  60                   RTS
000687r 2               
000687r 2               ; -----------------------------------------------------------------------------
000687r 2               ; print address
000687r 2               SHOWAD:
000687r 2  A5 C3                LDA     TMP2
000689r 2  A6 C4                LDX     TMP2+1
00068Br 2               
00068Br 2               WRADDR:
00068Br 2  48                   PHA                     ; save low byte
00068Cr 2  8A                   TXA                     ; put high byte in A
00068Dr 2  20 rr rr             JSR     WRTWO           ; output high byte
000690r 2  68                   PLA                     ; restore low byte
000691r 2               
000691r 2               WRBYTE:
000691r 2  20 rr rr             JSR     WRTWO           ; output byte in A
000694r 2               
000694r 2               SPACE:
000694r 2  A9 20                LDA     #$20            ; output space
000696r 2  D0 0B                BNE     FLIP
000698r 2               
000698r 2               CHOUT:
000698r 2  C9 0D                CMP     #$0D            ; output char with special handling of CR
00069Ar 2  D0 07                BNE     FLIP
00069Cr 2               CRLF:
00069Cr 2  A9 0D                LDA     #$0D            ; load CR in A
00069Er 2  20 rr rr             JSR     CHROUT          ; otherwise output CR+LF
0006A1r 2  A9 0A                LDA     #$0A            ; output LF
0006A3r 2               FLIP:
0006A3r 2  4C rr rr             JMP     CHROUT
0006A6r 2               
0006A6r 2               FRESH:
0006A6r 2  20 rr rr             JSR     CRLF            ; output CR
0006A9r 2  A9 20                LDA     #$20            ; load space in A
0006ABr 2  20 rr rr             JSR     CHROUT
0006AEr 2  4C rr rr             JMP     SNCLR
0006B1r 2               
0006B1r 2               ; -----------------------------------------------------------------------------
0006B1r 2               ; output two hex digits for byte
0006B1r 2               WRTWO:
0006B1r 2  86 CA                STX     SAVX            ; save X
0006B3r 2  20 rr rr             JSR     ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
0006B6r 2  20 rr rr             JSR     CHROUT          ; output upper nybble
0006B9r 2  8A                   TXA                     ; transfer lower to A
0006BAr 2  A6 CA                LDX     SAVX            ; restore X
0006BCr 2  4C rr rr             JMP     CHROUT          ; output lower nybble
0006BFr 2               
0006BFr 2               ; -----------------------------------------------------------------------------
0006BFr 2               ; convert byte in A to hex digits
0006BFr 2               ASCTWO:
0006BFr 2  48                   PHA                     ; save byte
0006C0r 2  20 rr rr             JSR     ASCII           ; do low nybble
0006C3r 2  AA                   TAX                     ; save in X
0006C4r 2  68                   PLA                     ; restore byte
0006C5r 2  4A                   LSR     A               ; shift upper nybble down
0006C6r 2  4A                   LSR     A
0006C7r 2  4A                   LSR     A
0006C8r 2  4A                   LSR     A
0006C9r 2               
0006C9r 2               ; convert low nybble in A to hex digit
0006C9r 2               ASCII:
0006C9r 2  29 0F                AND     #$0F            ; clear upper nibble
0006CBr 2  C9 0A                CMP     #$0A            ; if less than A, skip next step
0006CDr 2  90 02                BCC     ASC1
0006CFr 2  69 06                ADC     #6              ; skip ascii chars between 9 and A
0006D1r 2               ASC1:
0006D1r 2  69 30                ADC     #$30            ; add ascii char 0 to value
0006D3r 2  60                   RTS
0006D4r 2               
0006D4r 2               ; -----------------------------------------------------------------------------
0006D4r 2               ; get prev char from input buffer
0006D4r 2               GOTCHR:
0006D4r 2  C6 B9                DEC     CHRPNT
0006D6r 2               
0006D6r 2               ; get next char from input buffer
0006D6r 2               GETCHR:
0006D6r 2  86 CA                STX     SAVX
0006D8r 2  A6 B9                LDX     CHRPNT          ; get pointer to next char
0006DAr 2  BD 00 04             LDA     INBUFF,X        ; load next char in A
0006DDr 2  F0 06                BEQ     NOCHAR          ; null, :, or ? signal end of buffer
0006DFr 2  C9 3A                CMP     #':'
0006E1r 2  F0 02                BEQ     NOCHAR
0006E3r 2  C9 3F                CMP     #'?'
0006E5r 2               NOCHAR:
0006E5r 2  08                   PHP
0006E6r 2  E6 B9                INC     CHRPNT          ; next char
0006E8r 2  A6 CA                LDX     SAVX
0006EAr 2  28                   PLP                     ; Z flag will signal last character
0006EBr 2  60                   RTS
0006ECr 2               
0006ECr 2               ; -----------------------------------------------------------------------------
0006ECr 2               ; copy TMP0 to TMP2
0006ECr 2               COPY12:
0006ECr 2  A5 C1                LDA     TMP0            ; low byte
0006EEr 2  85 C3                STA     TMP2
0006F0r 2  A5 C2                LDA     TMP0+1          ; high byte
0006F2r 2  85 C4                STA     TMP2+1
0006F4r 2  60                   RTS
0006F5r 2               
0006F5r 2               ; -----------------------------------------------------------------------------
0006F5r 2               ; subtract TMP2 from TMP0
0006F5r 2               SUB12:
0006F5r 2  38                   SEC
0006F6r 2  A5 C1                LDA     TMP0            ; subtract low byte
0006F8r 2  E5 C3                SBC     TMP2
0006FAr 2  85 C1                STA     TMP0
0006FCr 2  A5 C2                LDA     TMP0+1
0006FEr 2  E5 C4                SBC     TMP2+1          ; subtract high byte
000700r 2  85 C2                STA     TMP0+1
000702r 2  60                   RTS
000703r 2               
000703r 2               ; -----------------------------------------------------------------------------
000703r 2               ; subtract from TMP0
000703r 2               SUBA1:
000703r 2  A9 01                LDA     #1              ; shortcut to decrement by 1
000705r 2               SUBA2:
000705r 2  85 CA                STA     SAVX            ; subtrahend in accumulator
000707r 2  38                   SEC
000708r 2  A5 C1                LDA     TMP0            ; minuend in low byte
00070Ar 2  E5 CA                SBC     SAVX
00070Cr 2  85 C1                STA     TMP0
00070Er 2  A5 C2                LDA     TMP0+1          ; borrow from high byte
000710r 2  E9 00                SBC     #0
000712r 2  85 C2                STA     TMP0+1
000714r 2  60                   RTS
000715r 2               
000715r 2               ; -----------------------------------------------------------------------------
000715r 2               ; subtract 1 from STORE
000715r 2               SUB13:
000715r 2  38                   SEC
000716r 2  A5 B7                LDA     STORE
000718r 2  E9 01                SBC     #1              ; decrement low byte
00071Ar 2  85 B7                STA     STORE
00071Cr 2  A5 B8                LDA     STORE+1
00071Er 2  E9 00                SBC     #0              ; borrow from high byte
000720r 2  85 B8                STA     STORE+1
000722r 2  60                   RTS
000723r 2               
000723r 2               ; -----------------------------------------------------------------------------
000723r 2               ; add to TMP2
000723r 2               ADDA2:
000723r 2  A9 01                LDA     #1              ; shortcut to increment by 1
000725r 2               BUMPAD2:
000725r 2  18                   CLC
000726r 2  65 C3                ADC     TMP2            ; add value in accumulator to low byte
000728r 2  85 C3                STA     TMP2
00072Ar 2  90 02                BCC     BUMPEX
00072Cr 2  E6 C4                INC     TMP2+1          ; carry to high byte
00072Er 2               BUMPEX:
00072Er 2  60                   RTS
00072Fr 2               
00072Fr 2               ; -----------------------------------------------------------------------------
00072Fr 2               ; subtract 1 from TMP2
00072Fr 2               SUB21:
00072Fr 2  38                   SEC
000730r 2  A5 C3                LDA     TMP2            ; decrement low byte
000732r 2  E9 01                SBC     #1
000734r 2  85 C3                STA     TMP2
000736r 2  A5 C4                LDA     TMP2+1          ; borrow from high byte
000738r 2  E9 00                SBC     #0
00073Ar 2  85 C4                STA     TMP2+1
00073Cr 2  60                   RTS
00073Dr 2               
00073Dr 2               ; -----------------------------------------------------------------------------
00073Dr 2               ; copy TMP0 to PC
00073Dr 2               COPY1P:
00073Dr 2  B0 08                BCS     CPY1PX          ; do nothing if parameter is empty
00073Fr 2  A5 C1                LDA     TMP0            ; copy low byte
000741r 2  A4 C2                LDY     TMP0+1          ; copy high byte
000743r 2  85 B1                STA     PCL
000745r 2  84 B0                STY     PCH
000747r 2               CPY1PX:
000747r 2  60                   RTS
000748r 2               
000748r 2               ; -----------------------------------------------------------------------------
000748r 2               ; get start/end addresses and calc difference
000748r 2               GETDIF:
000748r 2  B0 1F                BCS     GDIFX           ; exit with error if no parameter given
00074Ar 2  20 rr rr             JSR     COPY12          ; save start address in TMP2
00074Dr 2  20 rr rr             JSR     GETPAR          ; get end address in TMP0
000750r 2  B0 17                BCS     GDIFX           ; exit with error if no parameter given
000752r 2  A5 C1                LDA     TMP0            ; save end address in STASH
000754r 2  85 CE                STA     STASH
000756r 2  A5 C2                LDA     TMP0+1
000758r 2  85 CF                STA     STASH+1
00075Ar 2  20 rr rr             JSR     SUB12           ; subtract start address from end address
00075Dr 2  A5 C1                LDA     TMP0
00075Fr 2  85 B7                STA     STORE           ; save difference in STORE
000761r 2  A5 C2                LDA     TMP0+1
000763r 2  85 B8                STA     STORE+1
000765r 2  90 02                BCC     GDIFX           ; error if start address is after end address
000767r 2  18                   CLC                     ; clear carry to indicate success
000768r 2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (SEC)
000769r 2               GDIFX:
000769r 2  38                   SEC                     ; set carry to indicate error
00076Ar 2  60                   RTS
00076Br 2               
00076Br 2               ; -----------------------------------------------------------------------------
00076Br 2               ; convert base [$+&%]
00076Br 2               CONVRT:
00076Br 2  20 rr rr             JSR     RDPAR           ; read a parameter
00076Er 2  20 rr rr             JSR     FRESH           ; next line and clear
000771r 2  A9 24                LDA     #'$'            ; output $ sigil for hex
000773r 2  20 rr rr             JSR     CHROUT
000776r 2  A5 C1                LDA     TMP0            ; load the 16-bit value entered
000778r 2  A6 C2                LDX     TMP0+1
00077Ar 2  20 rr rr             JSR     WRADDR          ; print it in 4 hex digits
00077Dr 2  20 rr rr             JSR     FRESH
000780r 2  A9 2B                LDA     #'+'            ; output + sigil for decimal
000782r 2  20 rr rr             JSR     CHROUT
000785r 2  20 rr rr             JSR     CVTDEC          ; convert to BCD using hardware mode
000788r 2  A9 00                LDA     #0              ; clear digit counter
00078Ar 2  A2 06                LDX     #6              ; max digits + 1
00078Cr 2  A0 03                LDY     #3              ; bits per digit - 1
00078Er 2  20 rr rr             JSR     NMPRNT          ; print result without leading zeros
000791r 2  20 rr rr             JSR     FRESH           ; next line and clear
000794r 2  A9 26                LDA     #'&'            ; print & sigil for octal
000796r 2  20 rr rr             JSR     CHROUT
000799r 2  A9 00                LDA     #0              ; clear digit counter
00079Br 2  A2 08                LDX     #8              ; max digits + 1
00079Dr 2  A0 02                LDY     #2              ; bits per digit - 1
00079Fr 2  20 rr rr             JSR     PRINUM          ; output number
0007A2r 2  20 rr rr             JSR     FRESH           ; next line and clear
0007A5r 2  A9 25                LDA     #'%'            ; print % sigil for binary
0007A7r 2  20 rr rr             JSR     CHROUT
0007AAr 2  A9 00                LDA     #0              ; clear digit counter
0007ACr 2  A2 18                LDX     #$18            ; max digits + 1
0007AEr 2  A0 00                LDY     #0              ; bits per digit - 1
0007B0r 2  20 rr rr             JSR     PRINUM          ; output number
0007B3r 2  4C rr rr             JMP     STRT            ; back to mainloop
0007B6r 2               
0007B6r 2               ; -----------------------------------------------------------------------------
0007B6r 2               ; convert binary to BCD
0007B6r 2               
0007B6r 2               CVTDEC:
0007B6r 2  20 rr rr             JSR     COPY12          ; copy value from TMP0 to TMP2
0007B9r 2  A9 00                LDA     #0
0007BBr 2  A2 02                LDX     #2              ; clear 3 bytes in work buffer
0007BDr 2               DECML1:
0007BDr 2  95 D0                STA     U0AA0,X
0007BFr 2  CA                   DEX
0007C0r 2  10 FB                BPL     DECML1
0007C2r 2  A0 10                LDY     #16             ; 16 bits in input
0007C4r 2  08                   PHP                     ; save status register
0007C5r 2  78                   SEI                     ; make sure no interrupts occur with BCD enabled
0007C6r 2  F8                   SED
0007C7r 2               DECML2:
0007C7r 2  06 C3                ASL     TMP2            ; rotate bytes out of input low byte
0007C9r 2  26 C4                ROL     TMP2+1          ; .. into high byte and carry bit
0007CBr 2  A2 02                LDX     #2              ; process 3 bytes
0007CDr 2               DECDBL:
0007CDr 2  B5 D0                LDA     U0AA0,X         ; load current value of byte
0007CFr 2  75 D0                ADC     U0AA0,X         ; add it to itself plus the carry bit
0007D1r 2  95 D0                STA     U0AA0,X         ; store it back in the same location
0007D3r 2  CA                   DEX                     ; decrement byte counter
0007D4r 2  10 F7                BPL     DECDBL          ; loop until all bytes processed
0007D6r 2  88                   DEY                     ; decrement bit counter
0007D7r 2  D0 EE                BNE     DECML2          ; loop until all bits processed
0007D9r 2  28                   PLP                     ; restore processor status
0007DAr 2  60                   RTS
0007DBr 2               
0007DBr 2               ; load the input value and fall through to print it
0007DBr 2               PRINUM:
0007DBr 2  48                   PHA                     ; save accumulator
0007DCr 2  A5 C1                LDA     TMP0            ; copy input low byte to work buffer
0007DEr 2  85 D2                STA     U0AA0+2
0007E0r 2  A5 C2                LDA     TMP0+1          ; copy input high byte to work buffer
0007E2r 2  85 D1                STA     U0AA0+1
0007E4r 2  A9 00                LDA     #0              ; clear overflow byte in work buffer
0007E6r 2  85 D0                STA     U0AA0
0007E8r 2  68                   PLA                     ; restore accumulator
0007E9r 2               
0007E9r 2               ; print number in specified base without leading zeros
0007E9r 2               NMPRNT:
0007E9r 2  85 CB                STA     DIGCNT          ; number of digits in accumulator
0007EBr 2  84 CD                STY     NUMBIT          ; bits per digit passed in Y register
0007EDr 2               DIGOUT:
0007EDr 2  A4 CD                LDY     NUMBIT          ; get bits to process
0007EFr 2  A9 00                LDA     #0              ; clear accumulator
0007F1r 2               ROLBIT:
0007F1r 2  06 D2                ASL     U0AA0+2         ; shift bits out of low byte
0007F3r 2  26 D1                ROL     U0AA0+1         ; ... into high byte
0007F5r 2  26 D0                ROL     U0AA0           ; ... into overflow byte
0007F7r 2  2A                   ROL     A               ; ... into accumulator
0007F8r 2  88                   DEY                     ; decrement bit counter
0007F9r 2  10 F6                BPL     ROLBIT          ; loop until all bits processed
0007FBr 2  A8                   TAY                     ; check whether accumulator is 0
0007FCr 2  D0 08                BNE     NZERO           ; if not, print it
0007FEr 2  E0 01                CPX     #1              ; have we output the max number of digits?
000800r 2  F0 04                BEQ     NZERO           ; if not, print it
000802r 2  A4 CB                LDY     DIGCNT          ; how many digits have we output?
000804r 2  F0 07                BEQ     ZERSUP          ; skip output if digit is 0
000806r 2               NZERO:
000806r 2  E6 CB                INC     DIGCNT          ; increment digit counter
000808r 2  09 30                ORA     #$30            ; add numeric value to ascii '0' to get ascii char
00080Ar 2  20 rr rr             JSR     CHROUT          ; output character
00080Dr 2               ZERSUP:
00080Dr 2  CA                   DEX                     ; decrement number of leading zeros
00080Er 2  D0 DD                BNE     DIGOUT          ; next digit
000810r 2  60                   RTS
000811r 2               
000811r 2               
000811r 2               ; -----------------------------------------------------------------------------
000811r 2               ; print and clear routines
000811r 2               CLINE:
000811r 2  20 rr rr             JSR     CRLF
000814r 2  4C rr rr             JMP     SNCLR           ; clear line
000817r 2               SNDCLR:
000817r 2  20 rr rr             JSR     SNDMSG
00081Ar 2               SNCLR:
00081Ar 2  A0 28                LDY     #$28            ; loop 40 times
00081Cr 2               SNCLP:
00081Cr 2  A9 20                LDA     #$20            ; output space character
00081Er 2  20 rr rr             JSR     CHROUT
000821r 2  88                   DEY
000822r 2  D0 F8                BNE     SNCLP
000824r 2  A9 0D                LDA     #13             ; output CR
000826r 2  20 rr rr             JSR     CHROUT          ; send CR
000829r 2  60                   RTS
00082Ar 2               
00082Ar 2               ; -----------------------------------------------------------------------------
00082Ar 2               ; display message from table
00082Ar 2               SNDMSG:
00082Ar 2  B9 rr rr             LDA     MSGBAS,Y        ; Y contains offset in msg table
00082Dr 2  08                   PHP
00082Er 2  29 7F                AND     #$7F            ; strip high bit before output
000830r 2  20 rr rr             JSR     CHOUT
000833r 2  C8                   INY
000834r 2  28                   PLP
000835r 2  10 F3                BPL     SNDMSG          ; loop until high bit is set
000837r 2  60                   RTS
000838r 2               
000838r 2               ; -----------------------------------------------------------------------------
000838r 2               ; check for stop key
000838r 2               STOP:
000838r 2  20 rr rr             JSR     IOF_CONIN
00083Br 2  C9 03                CMP     #$03
00083Dr 2  F0 03                BEQ     :+
00083Fr 2  A9 FF                LDA     #$FF
000841r 2  60                   RTS
000842r 2               :
000842r 2  A9 00                LDA     #$00
000844r 2  60                   RTS
000845r 2               
000845r 2               ; -----------------------------------------------------------------------------
000845r 2               ; LOAD A MOTOROLA FORMATTED HEX FILE
000845r 2               LOADS19:
000845r 2  20 rr rr             JSR     IOF_CONINW      ;
000848r 2  C9 53                CMP     #'S'            ;
00084Ar 2  D0 F9                BNE     LOADS19         ; FIRST CHAR NOT (S)
00084Cr 2  20 rr rr             JSR     IOF_CONINW      ; READ CHAR
00084Fr 2  C9 39                CMP     #'9'            ;
000851r 2  F0 33                BEQ     LOAD21          ;
000853r 2  C9 31                CMP     #'1'            ;
000855r 2  D0 EE                BNE     LOADS19         ; SECOND CHAR NOT (1)
000857r 2  A9 00                LDA     #$00            ;
000859r 2  85 BC                STA     CKSM            ; ZERO CHECKSUM
00085Br 2  20 rr rr             JSR     S19GETBYTE      ; READ BYTE
00085Er 2  E9 01                SBC     #$01            ;
000860r 2  85 CB                STA     DIGCNT          ; BYTE COUNT
000862r 2  20 rr rr             JSR     BADDR           ; BUILD ADDRESS
000865r 2  A0 00                LDY     #$00            ;
000867r 2               LOAD11:
000867r 2  20 rr rr             JSR     S19GETBYTE      ;
00086Ar 2  C6 CB                DEC     DIGCNT          ;
00086Cr 2  F0 0F                BEQ     LOAD15          ; ZERO BYTE COUNT
00086Er 2  91 BD                STA     (LOADADR),Y     ; STORE DATA
000870r 2  E6 BD                INC     LOADADR         ; INCREMENT LOWBYTE
000872r 2  A5 BD                LDA     LOADADR
000874r 2  C9 00                CMP     #$00
000876r 2  D0 EF                BNE     LOAD11          ; NOT ZERO?, LOOP
000878r 2  E6 BE                INC     LOADADR+1       ; ZERO, INC HIGH BYTE
00087Ar 2  4C rr rr             JMP     LOAD11          ;
00087Dr 2               
00087Dr 2               LOAD15:
00087Dr 2  E6 BC                INC     CKSM            ;
00087Fr 2  F0 C4                BEQ     LOADS19         ;
000881r 2               LOAD19:
000881r 2  A9 3F                LDA     #'?'            ;
000883r 2  20 rr rr             JSR     IOF_OUTCH       ;
000886r 2               LOAD21:
000886r 2  60                   RTS
000887r 2               S19GETBYTE:
000887r 2  20 rr rr             JSR     INHEX           ; GET HEX CHAR
00088Ar 2  0A                   ASL                     ;
00088Br 2  0A                   ASL                     ;
00088Cr 2  0A                   ASL                     ;
00088Dr 2  0A                   ASL                     ;
00088Er 2  85 BF                STA     LOADWRK         ;
000890r 2  20 rr rr             JSR     INHEX           ;
000893r 2  29 0F                AND     #$0F            ; MASK TO 4 BITS
000895r 2  05 BF                ORA     LOADWRK         ;
000897r 2  48                   PHA                     ;
000898r 2  18                   CLC                     ;
000899r 2  65 BC                ADC     CKSM            ;
00089Br 2  85 BC                STA     CKSM            ;
00089Dr 2  68                   PLA                     ;
00089Er 2  60                   RTS                     ;
00089Fr 2               ; INPUT HEX CHAR
00089Fr 2               INHEX:
00089Fr 2  20 rr rr             JSR     IOF_CONINW      ;
0008A2r 2  48                   PHA                     ;
0008A3r 2  20 rr rr             JSR     IOF_OUTCH       ;
0008A6r 2  68                   PLA                     ;
0008A7r 2  C9 3A                CMP     #$3A            ; LESS THAN 9?
0008A9r 2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
0008ABr 2  E9 2F                SBC     #$2F            ; CONVERT 0-9
0008ADr 2               INHEX_BIG:
0008ADr 2  C9 41                CMP     #$41            ; A OR MORE?
0008AFr 2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
0008B1r 2  E9 37                SBC     #$37            ; CONVERT A-F
0008B3r 2               INHEX_SMALL:
0008B3r 2  60                   RTS                     ;
0008B4r 2               ; BUILD ADDRESS
0008B4r 2               BADDR:
0008B4r 2  20 rr rr             JSR     S19GETBYTE      ; READ 2 FRAMES
0008B7r 2  85 BE                STA     LOADADR+1       ;
0008B9r 2  20 rr rr             JSR     S19GETBYTE      ;
0008BCr 2  85 BD                STA     LOADADR         ;
0008BEr 2  60                   RTS
0008BFr 2               LOAD:
0008BFr 2  20 rr rr             JSR     LOADS19
0008C2r 2  4C rr rr             JMP     STRT            ; back to main loop
0008C5r 2               
0008C5r 2               
0008C5r 2               ; -----------------------------------------------------------------------------
0008C5r 2               ; message table; last character has high bit set
0008C5r 2               MSGBAS:
0008C5r 2               
0008C5r 2               MSG2:
0008C5r 2  0D                   .BYTE   $0D             ; header for registers
0008C6r 2  20 20 20 50          .BYTE   "   PC  SR AC XR YR SP   V1.2"
0008CAr 2  43 20 20 53  
0008CEr 2  52 20 41 43  
0008E2r 2  8D                   .BYTE   $0D+$80
0008E3r 2               MSG3:
0008E3r 2  1D BF                .BYTE   $1D,$3F+$80     ; syntax error: move right, display "?"
0008E5r 2               MSG4:
0008E5r 2  2E 2E 53 59          .BYTE   "..SYS"         ; SYS call to enter monitor
0008E9r 2  53           
0008EAr 2  A0                   .BYTE   $20+$80
0008EBr 2               MSG5:
0008EBr 2  3A 92                .BYTE   $3A,$12+$80     ; ":" then RVS ON for memory ASCII dump
0008EDr 2               MSG6:
0008EDr 2  20 45 52 52          .BYTE   " ERRO"         ; I/O error: display " ERROR"
0008F1r 2  4F           
0008F2r 2  D2                   .BYTE   'R'+$80
0008F3r 2               MSG7:
0008F3r 2  41 A0                .BYTE   $41,$20+$80     ; assemble next instruction: "A " + addr
0008F5r 2               MSG8:
0008F5r 2  20 20                .BYTE   "  "            ; pad non-existent byte: skip 3 spaces
0008F7r 2  A0                   .BYTE   $20+$80
0008F8r 2               
0008F8r 2               ; -----------------------------------------------------------------------------
0008F8r 2               ; addressing mode table - nybbles provide index into MODE2 table
0008F8r 2               ; for opcodes XXXXXXY0, use XXXXXX as index into table
0008F8r 2               ; for opcodes WWWXXY01  use $40 + XX as index into table
0008F8r 2               ; use right nybble if Y=0; use left nybble if Y=1
0008F8r 2               
0008F8r 2               MODE:
0008F8r 2  40 02 45 03          .BYTE   $40,$02,$45,$03 ; even opcodes
0008FCr 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000900r 2  30 22 45 33          .BYTE   $30,$22,$45,$33
000904r 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000908r 2  40 02 45 33          .BYTE   $40,$02,$45,$33
00090Cr 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000910r 2  40 02 45 B3          .BYTE   $40,$02,$45,$B3
000914r 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000918r 2  00 22 44 33          .BYTE   $00,$22,$44,$33
00091Cr 2  D0 8C 44 00          .BYTE   $D0,$8C,$44,$00
000920r 2  11 22 44 33          .BYTE   $11,$22,$44,$33
000924r 2  D0 8C 44 9A          .BYTE   $D0,$8C,$44,$9A
000928r 2  10 22 44 33          .BYTE   $10,$22,$44,$33
00092Cr 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000930r 2  10 22 44 33          .BYTE   $10,$22,$44,$33
000934r 2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
000938r 2  62 13 78 A9          .BYTE   $62,$13,$78,$A9 ; opcodes ending in 01
00093Cr 2               
00093Cr 2               ; addressing mode format definitions indexed by nybbles from MODE table
00093Cr 2               
00093Cr 2               ; left 6 bits define which characters appear in the assembly operand
00093Cr 2               ; left 3 bits are before the address; next 3 bits are after
00093Cr 2               
00093Cr 2               ; right-most 2 bits define length of binary operand
00093Cr 2               
00093Cr 2               ; index               654 321
00093Cr 2               ; 1st character       $(# ,),
00093Cr 2               ; 2nd character        $$ X Y    length  format      idx mode
00093Cr 2               MODE2:
00093Cr 2  00                   .BYTE   $00             ; 000 000    00                  0   error
00093Dr 2  21                   .BYTE   $21             ; 001 000    01      #$00        1   immediate
00093Er 2  81                   .BYTE   $81             ; 100 000    01      $00         2   zero-page
00093Fr 2  82                   .BYTE   $82             ; 100 000    10      $0000       3   absolute
000940r 2  00                   .BYTE   $00             ; 000 000    00                  4   implied
000941r 2  00                   .BYTE   $00             ; 000 000    00                  5   accumulator
000942r 2  59                   .BYTE   $59             ; 010 110    01      ($00,X)     6   indirect,X
000943r 2  4D                   .BYTE   $4D             ; 010 011    01      ($00),Y     7   indirect,Y
000944r 2  91                   .BYTE   $91             ; 100 100    01      $00,X       8   zero-page,X
000945r 2  92                   .BYTE   $92             ; 100 100    10      $0000,X     9   absolute,X
000946r 2  86                   .BYTE   $86             ; 100 001    10      $0000,Y     A   absolute,Y
000947r 2  4A                   .BYTE   $4A             ; 010 010    10      ($0000)     B   indirect
000948r 2  85                   .BYTE   $85             ; 100 001    01      $00,Y       C   zero-page,Y
000949r 2  9D                   .BYTE   $9D             ; 100 111    01      $0000*      D   relative
00094Ar 2               
00094Ar 2               ; * relative is special-cased so format bits don't match
00094Ar 2               
00094Ar 2               
00094Ar 2               ; character lookup tables for the format definitions in MODE2
00094Ar 2               
00094Ar 2               CHAR1:
00094Ar 2  2C 29 2C             .BYTE   $2C,$29,$2C     ; ","  ")"  ","
00094Dr 2  23 28 24             .BYTE   $23,$28,$24     ; "#"  "("  "$"
000950r 2               
000950r 2               CHAR2:
000950r 2  59 00 58             .BYTE   $59,$00,$58     ; "Y"   0   "X"
000953r 2  24 24 00             .BYTE   $24,$24,$00     ; "$"  "$"   0
000956r 2               
000956r 2               ; -----------------------------------------------------------------------------
000956r 2               ; 3-letter mnemonics packed into two bytes (5 bits per letter)
000956r 2               
000956r 2               ; left 8 bits
000956r 2               ; XXXXX000 opcodes
000956r 2               MNEML:
000956r 2  1C 8A 1C 23          .BYTE   $1C,$8A,$1C,$23 ; BRK PHP BPL CLC
00095Ar 2  5D 8B 1B A1          .BYTE   $5D,$8B,$1B,$A1 ; JSR PLP BMI SEC
00095Er 2  9D 8A 1D 23          .BYTE   $9D,$8A,$1D,$23 ; RTI PHA BVC CLI
000962r 2  9D 8B 1D A1          .BYTE   $9D,$8B,$1D,$A1 ; RTS PLA BVS SEI
000966r 2  00 29 19 AE          .BYTE   $00,$29,$19,$AE ; ??? DEY BCC TYA
00096Ar 2  69 A8 19 23          .BYTE   $69,$A8,$19,$23 ; LDY TAY BCS CLV
00096Er 2  24 53 1B 23          .BYTE   $24,$53,$1B,$23 ; CPY INY BNE CLD
000972r 2  24 53 19 A1          .BYTE   $24,$53,$19,$A1 ; CPX INX BEQ SED
000976r 2               ; XXXYY100 opcodes
000976r 2  00 1A 5B 5B          .BYTE   $00,$1A,$5B,$5B ; ??? BIT JMP JMP
00097Ar 2  A5 69 24 24          .BYTE   $A5,$69,$24,$24 ; STY LDY CPY CPX
00097Er 2               ; 1XXX1010 opcodes
00097Er 2  AE AE A8 AD          .BYTE   $AE,$AE,$A8,$AD ; TXA TXS TAX TSX
000982r 2  29 00 7C 00          .BYTE   $29,$00,$7C,$00 ; DEX ??? NOP ???
000986r 2               ; XXXYYY10 opcodes
000986r 2  15 9C 6D 9C          .BYTE   $15,$9C,$6D,$9C ; ASL ROL LSR ROR
00098Ar 2  A5 69 29 53          .BYTE   $A5,$69,$29,$53 ; STX LDX DEC INC
00098Er 2               ; XXXYYY01 opcodes
00098Er 2  84 13 34 11          .BYTE   $84,$13,$34,$11 ; ORA AND EOR ADC
000992r 2  A5 69 23 A0          .BYTE   $A5,$69,$23,$A0 ; STA LDA CMP SBC
000996r 2               
000996r 2               ; right 7 bits, left justified
000996r 2               ; XXXXX000 opcodes
000996r 2               MNEMR:
000996r 2  D8 62 5A 48          .BYTE   $D8,$62,$5A,$48 ; BRK PHP BPL CLC
00099Ar 2  26 62 94 88          .BYTE   $26,$62,$94,$88 ; JSR PLP BMI SEC
00099Er 2  54 44 C8 54          .BYTE   $54,$44,$C8,$54 ; RTI PHA BVC CLI
0009A2r 2  68 44 E8 94          .BYTE   $68,$44,$E8,$94 ; RTS PLA BVS SEI
0009A6r 2  00 B4 08 84          .BYTE   $00,$B4,$08,$84 ; ??? DEY BCC TYA
0009AAr 2  74 B4 28 6E          .BYTE   $74,$B4,$28,$6E ; LDY TAY BCS CLV
0009AEr 2  74 F4 CC 4A          .BYTE   $74,$F4,$CC,$4A ; CPY INY BNE CLD
0009B2r 2  72 F2 A4 8A          .BYTE   $72,$F2,$A4,$8A ; CPX INX BEQ SED
0009B6r 2               ; XXXYY100 opcodes
0009B6r 2  00 AA A2 A2          .BYTE   $00,$AA,$A2,$A2 ; ??? BIT JMP JMP
0009BAr 2  74 74 74 72          .BYTE   $74,$74,$74,$72 ; STY LDY CPY CPX
0009BEr 2               ; 1XXX1010 opcodes
0009BEr 2  44 68 B2 32          .BYTE   $44,$68,$B2,$32 ; TXA TXS TAX TSX
0009C2r 2  B2 00 22 00          .BYTE   $B2,$00,$22,$00 ; DEX ??? NOP ???
0009C6r 2               ; XXXYYY10 opcodes
0009C6r 2  1A 1A 26 26          .BYTE   $1A,$1A,$26,$26 ; ASL ROL LSR ROR
0009CAr 2  72 72 88 C8          .BYTE   $72,$72,$88,$C8 ; STX LDX DEC INC
0009CEr 2               ; XXXYYY01 opcodes
0009CEr 2  C4 CA 26 48          .BYTE   $C4,$CA,$26,$48 ; ORA AND EOR ADC
0009D2r 2  44 44 A2 C8          .BYTE   $44,$44,$A2,$C8 ; STA LDA CMP SBC
0009D6r 2  0D 20 20 20          .BYTE   $0D,$20,$20,$20
0009DAr 2               
0009DAr 2               ; -----------------------------------------------------------------------------
0009DAr 2               ; single-character commands
0009DAr 2               KEYW:
0009DAr 2  41 42 43 44          .BYTE   "ABCDFGHJLMRT.>;"
0009DEr 2  46 47 48 4A  
0009E2r 2  4C 4D 52 54  
0009E9r 2               HIKEY:
0009E9r 2  24 2B 26 25          .BYTE   "$+&%"
0009EDr 2               KEYTOP:
0009EDr 2               
0009EDr 2               
0009EDr 2               ; vectors corresponding to commands above
0009EDr 2               KADDR:
0009EDr 2  rr rr rr rr          .WORD   ASSEM-1,BOOT-1,COMPAR-1,DISASS-1
0009F1r 2  rr rr rr rr  
0009F5r 2  rr rr rr rr          .WORD   FILL-1,GOTO-1,HUNT-1,JSUB-1
0009F9r 2  rr rr rr rr  
0009FDr 2  rr rr rr rr          .WORD   LOAD-1,DSPLYM-1,DSPLYR-1,TRANS-1
000A01r 2  rr rr rr rr  
000A05r 2  rr rr rr rr          .WORD   ASSEM-1,ALTM-1,ALTR-1
000A09r 2  rr rr        
000A0Br 2               
000A0Br 2               ; -----------------------------------------------------------------------------
000A0Br 2               MODTAB:
000A0Br 2  10 0A 08 02          .BYTE   $10,$0A,$08,02  ; modulo number systems
000A0Fr 2               LENTAB:
000A0Fr 2  04 03 03 01          .BYTE   $04,$03,$03,$01 ; bits per digit
000A13r 2               
000A13r 1                       .INCLUDE"DOSPAGER.ASM"
000A13r 2               ;__pager_________________________________________________________________________________________________________________________
000A13r 2               ;
000A13r 2               ; 	Nhyodyne Memory page management code
000A13r 2               ;
000A13r 2               ;	Entry points:
000A13r 2               ;		PAGER_INIT          - called during OS init
000A13r 2               ;________________________________________________________________________________________________________________________________
000A13r 2               ;
000A13r 2               ; RAM BANK $0C is RAM area for Drivers
000A13r 2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
000A13r 2               ; RAM BANK $0F is fixed bank $0000-$7FFF
000A13r 2               ;
000A13r 2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
000A13r 2               ;
000A13r 2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
000A13r 2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
000A13r 2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
000A13r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
000A13r 2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
000A13r 2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
000A13r 2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
000A13r 2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
000A13r 2               ;
000A13r 2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
000A13r 2               ;
000A13r 2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
000A13r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
000A13r 2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
000A13r 2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
000A13r 2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
000A13r 2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
000A13r 2               
000A13r 2               
000A13r 2               ;__PAGER_INIT___________________________________________________________________________________________
000A13r 2               ;
000A13r 2               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
000A13r 2               ;____________________________________________________________________________________________________
000A13r 2               PAGER_INIT:
000A13r 2  A2 00                LDX     #$00
000A15r 2               :
000A15r 2  BD rr rr             LDA     md_pagecode,X
000A18r 2  9D 00 02             STA     MD_PAGERA,X
000A1Br 2  E8                   INX
000A1Cr 2  E0 00                CPX     #$00
000A1Er 2  D0 F5                BNE     :-
000A20r 2  60                   RTS
000A21r 2               
000A21r 2               ;       X=Control Word
000A21r 2               ;	7 6 5 4  3 2 1 0
000A21r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
000A21r 2               ;       X : : X  X X X X    = UNUSED
000A21r 2               ;	X : :-------------0 = Read=0, Write=1
000A21r 2               ;	X :---------------0 = RAM=0, ROM=1
000A21r 2               ;
000A21r 2               ;       A= bank
000A21r 2               ;       Y= page
000A21r 2               ;
000A21r 2               md_pagecode:
000A21r 2  48                   PHA
000A22r 2  84 ED                STY     DEST+1     ; setup copy from pointer
000A24r 2  8A                   TXA
000A25r 2  29 80                AND     #$80
000A27r 2  A8                   TAY
000A28r 2  84 EC                STY     DEST
000A2Ar 2  8A                   TXA
000A2Br 2  29 20                AND     #%00100000
000A2Dr 2  C9 00                CMP     #$00
000A2Fr 2  D0 4F                BNE     MD_PAGE_WRITE
000A31r 2               ; PERFORM READ HERE
000A31r 2  8A                   TXA
000A32r 2  29 40                AND     #%01000000
000A34r 2  C9 00                CMP     #$00
000A36r 2  D0 0E                BNE     MD_PAGE_ROREAD
000A38r 2               ; DO RAM READ
000A38r 2  A9 80                LDA     #$80
000A3Ar 2  8D 7C 03             STA     MPCL_ROM
000A3Dr 2  68                   PLA
000A3Er 2  09 80                ORA     #$80
000A40r 2  8D 78 03             STA     MPCL_RAM
000A43r 2  18                   CLC
000A44r 2  90 0B                BCC     MD_PAGE_COPYFRM
000A46r 2               MD_PAGE_ROREAD:
000A46r 2  A9 00                LDA     #$00
000A48r 2  8D 78 03             STA     MPCL_RAM
000A4Br 2  68                   PLA
000A4Cr 2  29 7F                AND     #$7F
000A4Er 2  8D 7C 03             STA     MPCL_ROM
000A51r 2               MD_PAGE_COPYFRM:
000A51r 2               ; DO THE COPY
000A51r 2  A2 00                LDX     #$00
000A53r 2  A0 00                LDY     #$00
000A55r 2               :
000A55r 2  B1 EC                LDA     (DEST),Y
000A57r 2  9D 00 04             STA     hstbuf,X
000A5Ar 2  E8                   INX
000A5Br 2  C8                   INY
000A5Cr 2  E0 00                CPX     #$00
000A5Er 2  D0 F5                BNE     :-
000A60r 2  A2 00                LDX     #$00
000A62r 2  A0 00                LDY     #$00
000A64r 2  E6 ED                INC     DEST+1
000A66r 2               :
000A66r 2  B1 EC                LDA     (DEST),Y
000A68r 2  9D 00 05             STA     hstbuf+$100,X
000A6Br 2  E8                   INX
000A6Cr 2  C8                   INY
000A6Dr 2  E0 00                CPX     #$00
000A6Fr 2  D0 F5                BNE     :-
000A71r 2  A9 80                LDA     #$80
000A73r 2  8D 7C 03             STA     MPCL_ROM
000A76r 2  EA                   NOP
000A77r 2  EA                   NOP
000A78r 2  A9 8C                LDA     #$8C
000A7Ar 2  8D 78 03             STA     MPCL_RAM
000A7Dr 2  EA                   NOP
000A7Er 2  EA                   NOP
000A7Fr 2  60                   RTS
000A80r 2               MD_PAGE_WRITE:
000A80r 2  68                   PLA
000A81r 2  09 80                ORA     #%10000000
000A83r 2  8D 78 03             STA     MPCL_RAM
000A86r 2               ; DO THE COPY
000A86r 2  A2 00                LDX     #$00
000A88r 2  A0 00                LDY     #$00
000A8Ar 2               :
000A8Ar 2  BD 00 04             LDA     hstbuf,X
000A8Dr 2  91 EC                STA     (DEST),Y
000A8Fr 2  E8                   INX
000A90r 2  C8                   INY
000A91r 2  E0 00                CPX     #$00
000A93r 2  D0 F5                BNE     :-
000A95r 2  A2 00                LDX     #$00
000A97r 2  A0 00                LDY     #$00
000A99r 2  E6 ED                INC     DEST+1
000A9Br 2               :
000A9Br 2  BD 00 05             LDA     hstbuf+$100,X
000A9Er 2  91 EC                STA     (DEST),Y
000AA0r 2  E8                   INX
000AA1r 2  C8                   INY
000AA2r 2  E0 00                CPX     #$00
000AA4r 2  D0 F5                BNE     :-
000AA6r 2  A9 8C                LDA     #$8C
000AA8r 2  8D 78 03             STA     MPCL_RAM
000AABr 2  EA                   NOP
000AACr 2  EA                   NOP
000AADr 2  60                   RTS
000AAEr 2               md_pagecodeend:
000AAEr 2               farcall:
000AAEr 2                       .IF     USEROM=1
000AAEr 2                           PHA
000AAEr 2                           LDA     #$80
000AAEr 2                           STA     MPCL_ROM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           LDA     #$8C
000AAEr 2                           STA     MPCL_RAM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           PLA
000AAEr 2                           JSR     BANKED_DRIVER_DISPATCHER
000AAEr 2                           PHA
000AAEr 2                           LDA     #$00
000AAEr 2                           STA     MPCL_RAM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           STA     MPCL_ROM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           PLA
000AAEr 2                           RTS
000AAEr 2               md_farrun:
000AAEr 2                           LDA     #$80
000AAEr 2                           STA     MPCL_ROM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           LDA     $00
000AAEr 2                           STA     MPCL_RAM
000AAEr 2                           NOP
000AAEr 2                           NOP
000AAEr 2                           JMP     ($0001)
000AAEr 2                       .ELSE
000AAEr 2  48                       PHA
000AAFr 2  A9 8C                    LDA     #$8C
000AB1r 2  8D 78 03                 STA     MPCL_RAM
000AB4r 2  EA                       NOP
000AB5r 2  EA                       NOP
000AB6r 2  68                       PLA
000AB7r 2  20 00 88                 JSR     BANKED_DRIVER_DISPATCHER
000ABAr 2  48                       PHA
000ABBr 2  A9 8E                    LDA     #$8E
000ABDr 2  8D 78 03                 STA     MPCL_RAM
000AC0r 2  68                       PLA
000AC1r 2  60                       RTS
000AC2r 2                       .ENDIF
000AC2r 2               
000AC2r 1               
000AC2r 1               ; START BANNER
000AC2r 1               STARTUP:
000AC2r 1  0D 0A                .BYTE   $0D,$0A
000AC4r 1               
000AC4r 1  20 20 4E 68          .BYTE   "  Nhyodyne",$0D,$0A
000AC8r 1  79 6F 64 79  
000ACCr 1  6E 65 0D 0A  
000AD0r 1  20 20 20 5F          .BYTE   "   __ _____  _____ ___ ___ ",$0D,$0A
000AD4r 1  5F 20 5F 5F  
000AD8r 1  5F 5F 5F 20  
000AEDr 1  20 20 2F 20          .BYTE   "  / /| ____|/ ____/ _ \__ \ ",$0D,$0A
000AF1r 1  2F 7C 20 5F  
000AF5r 1  5F 5F 5F 7C  
000B0Br 1  20 2F 20 2F          .BYTE   " / /_| |__ | |   | | | | ) | ",$0D,$0A
000B0Fr 1  5F 7C 20 7C  
000B13r 1  5F 5F 20 7C  
000B2Ar 1  7C 20 27 5F          .BYTE   "| '_ \___ \| |   | | | |/ / ",$0D,$0A
000B2Er 1  20 5C 5F 5F  
000B32r 1  5F 20 5C 7C  
000B48r 1  7C 20 28 5F          .BYTE   "| (_) |__) | |___| |_| / /_ ",$0D,$0A
000B4Cr 1  29 20 7C 5F  
000B50r 1  5F 29 20 7C  
000B66r 1  20 5C 5F 5F          .BYTE   " \___/____/ \_____\___/____| ",$0D,$0A
000B6Ar 1  5F 2F 5F 5F  
000B6Er 1  5F 5F 2F 20  
000B85r 1  2A 20 36 35          .BYTE   "* 65c02 SuperMON ",$0D,$0A,$00
000B89r 1  63 30 32 20  
000B8Dr 1  53 75 70 65  
000B99r 1               
000B99r 1                       .SEGMENT "IVECTOR"
000000r 1               ;    .ORG    $FFF0
000000r 1  4C 8D 02             JMP     ROM_FARCALL     ;F0
000003r 1  4C rr rr             JMP     LOADS19         ;F3
000006r 1               
000006r 1                       .SEGMENT "VECTORS"
000000r 1               ;    .ORG    $FFFA
000000r 1               NNTVECTOR:
000000r 1  rr rr                .WORD   NINTERRUPT      ;
000002r 1               RSTVECTOR:
000002r 1  rr rr                .WORD   COLD_START      ;
000004r 1               INTVECTOR:
000004r 1  rr rr                .WORD   INTERRUPT       ; ROM VECTOR FOR IRQ
000006r 1               
000006r 1                       .END
