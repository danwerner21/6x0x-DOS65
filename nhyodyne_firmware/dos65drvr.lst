ca65 V2.19 - Git 128b15a71
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0C
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               
000000r 1               DSKYOSC         = 1000000       ; Set DSKY NG Osc frequency
000000r 1               
000000r 1                       .SEGMENT "DRIVERS"
000000r 1                       .ORG    $8800
008800  1                       .INCLUDE "../dos65_os/dosdefn.asm"; base addresses and definitions
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               ;
008800  2               ;	DOS/65 base addresses and definitions
008800  2               ;
008800  2               ;  DWERNER 04/24/2022 	Initial
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               
008800  2               ;base addresses and definitions
008800  2               btejmp          = $0100         ; warm boot jump
008800  2               pemjmp          = $0103         ; jump to pem
008800  2               iostat          = $0106         ; i/o status
008800  2               dflfcb          = $0107         ; default fcb
008800  2               dflbuf          = $0128         ; default buffer
008800  2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
008800  2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
008800  2               IO              = $0300         ; 0300-03FF Memory mapped IO
008800  2               MPCL_ROM        = $037C         ; ROM MAPPER
008800  2               MPCL_RAM        = $0378         ; RAM MAPPER
008800  2               hstbuf          = $0400         ; 0400-05ff host buffer
008800  2               ;
008800  2               ; DRIVER WORKING STORAGE
008800  2               ;
008800  2               
008800  2               
008800  2               DSKY_BUF        = $0600         ; Eight Bytes DSKY display buffer
008800  2               DSKY_BUFLEN     = 8             ;
008800  2               DSKY_HEXBUF     = $0608         ; Four Bytes DSKY hex buffer
008800  2               DSKY_HEXBUFLEN  = 4             ;
008800  2               sektrk          = $060C         ; seek track number
008800  2               seksec          = $060E         ; seek sector number
008800  2               debcyll         = $0610         ; DEBLOCKED CYLINDER LSB
008800  2               debcylm         = $0611         ; DEBLOCKED CYLINDER MSB
008800  2               debsehd         = $0612         ; DEBLOCKED SECTOR AND HEAD (HS)
008800  2               sekdsk          = $0616         ; seek disk number
008800  2               dskcfg          = $0617         ; 16 bytes disk configuration table
008800  2               DSKUNIT         = $0628         ; seek disk number
008800  2               slicetmp        = $0631         ; (word)
008800  2               STACKA          = $0635
008800  2               nmsstr          = $0636
008800  2               FLRETRY         = $0637         ;
008800  2               FLRETRY1        = $0638         ;
008800  2               ST0             = $0639         ;
008800  2               FLERR           = $063A         ;
008800  2               FCMD            = $063B         ;
008800  2               PPIDEINDEX      = $063C
008800  2               CURRENT_IDE_DRIVE = $063D
008800  2               DSKY_X_STORAGE  = $063E
008800  2               DSKY_Y_STORAGE  = $063F
008800  2               DSKY_TEMP_VAL   = $0640
008800  2               DSKY_PPIX_VAL   = $0641
008800  2               FLOPPY_DETCT    = $0642
008800  2               DSKY_PRESENT    = $0643
008800  2               Cdebcyll        = $0644         ; DEBLOCKED CYLINDER LSB (IN CACHE)
008800  2               Cdebcylm        = $0645         ; DEBLOCKED CYLINDER MSB (IN CACHE)
008800  2               Cdebsehd        = $0646         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
008800  2               
008800  2               tea             = $800          ;tea start
008800  2               
008800  2               ;zero page for setup
008800  2               addinp          = $02           ;initialized to a,y
008800  2               bufadd          = $04           ;buffer address
008800  2               alcpnt          = $06           ;allocation map pointer
008800  2               chkpnt          = $08           ;checksum map pointer
008800  2               numvar          = 8             ;eight bytes
008800  2               
008800  2               
008800  2               msgptr          = chkpnt+2      ;message pointer
008800  2               movptr          = msgptr        ;and move pointer
008800  2               dcbloc          = msgptr+2      ;pointer to dcb
008800  2               
008800  2               dcbpc           = $2C           ;pointer to DCB table
008800  2               dskcfpc         = $2E           ;pointer to disk configuration table
008800  2               cmdlnp          = $30           ;pointer to command line buffer
008800  2               farfunct        = $32           ; function to call in driver area
008800  2               farpointer      = $33           ;
008800  2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
008800  2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
008800  2               CONSOLE         = $3A
008800  2               TEMPWORD        = $3B           ;
008800  2               TEMPWORD1       = $3D           ;
008800  2               TEMPWORD2       = $3F           ;
008800  2               STRPTR          = $41           ;
008800  2               DSKYMODE        = $43           ; DSKY MODE (0=NONE, 1=DSKY, 2=DSKY NG
008800  2               
008800  2               
008800  2               DO_FARCALL      = $FFF0
008800  2               
008800  2               ;page zero and system ram assignments
008800  2               DEST            = $EC           ;pointer for OutMsg
008800  2               SRC             = $EE           ;pointer for OutMsg
008800  2               OUTMSG_W        = $F0           ;pointer for OutMsg
008800  2               dmaadr          = $f4           ;pointer for r/w
008800  2               
008800  2               
008800  2               ;pem constants on entry to write
008800  2               wrall           = 0             ;write to allocated
008800  2               wrdir           = 1             ;write to directory
008800  2               wrual           = 2             ;write to unallocated
008800  2               
008800  2               ;fixed parameters
008800  2               lf              = $a            ;linefeeed
008800  2               cr              = $d            ;return
008800  2               eof             = $1a           ;end of file
008800  2               null            = 0             ;null
008800  2               ctlc            = 3             ;abort
008800  2               ctle            = 5             ;physical cr lf
008800  2               ctli            = 9             ;tab character
008800  2               ctlp            = $10           ;toggle printer
008800  2               ctlr            = $12           ;repeat line
008800  2               ctls            = $13           ;freeze
008800  2               ctlx            = $18           ;cancel
008800  2               semico          = $3b           ;semicolon
008800  2               delete          = $08           ;delete character
008800  2               numcmd          = 36            ;number commands
008800  2               DEFDRV          = 0             ; SET TO DEFAULT DRIVE LETTER
008800  2               
008800  2               
008800  2                       .IFDEF RBC6X0X
008800  2                       .DEFINE COMSUFFIX "COM"
008800  2                       .ENDIF
008800  2               
008800  2                       .IFDEF NHYODYNE
008800  2                       .DEFINE COMSUFFIX "CO6"
008800  2                       .ENDIF
008800  2               
008800  2               DEBUG           = 0
008800  2               BANKED_DRIVER_DISPATCHER=$8800
008800  2               
008800  1               
008800  1               ; for Nhyodyne:
008800  1               ; RAM BANK $0C is RAM area for Drivers
008800  1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
008800  1               ; RAM BANK $0F is fixed bank $0000-$7FFF
008800  1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code (AS A SECONDARY CPU)
008800  1               
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for work RAM for drivers (FOR SECONDARY CPU, UNDER ROMWBW)
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for ROM for drivers (FOR PRIMARY CPU, NO ROMWBW)
008800  1               ;
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1               FUNCTION_DISPATCHER:
008800  1  48                   PHA
008801  1  8A                   TXA
008802  1  48                   PHA
008803  1  A5 32                LDA     farfunct
008805  1  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
008806  1  AA                   TAX
008807  1  BD 17 88             LDA     DISPATCHTABLE,X
00880A  1  85 33                STA     farpointer
00880C  1  BD 18 88             LDA     DISPATCHTABLE+1,X
00880F  1  85 34                STA     farpointer+1
008811  1               
008811  1  68                   PLA
008812  1  AA                   TAX
008813  1  68                   PLA
008814  1  6C 33 00             JMP     (farpointer)
008817  1               
008817  1               
008817  1               DISPATCHTABLE:
008817  1  16 97                .WORD   DFT_CONSOLE     ; FUNCTION 00 - WRITE CONSOLE
008819  1  16 97                .WORD   DFT_CONSOLE     ; FUNCTION 01 - READ CONSOLE
00881B  1  16 97                .WORD   DFT_CONSOLE     ; FUNCTION 02 - READ CONSOLE (BLOCKING)
00881D  1  16 97                .WORD   DFT_CONSOLE     ; FUNCTION 03 - GET CONSOLE STATUS
00881F  1               
00881F  1  2E 89                .WORD   WRSER1          ; FUNCTION 04 - WRITE SERIAL PORT
008821  1  3D 89                .WORD   RDSER1          ; FUNCTION 05 - READ SERIAL PORT
008823  1  4D 89                .WORD   RDSER1W         ; FUNCTION 06 - READ SERIAL PORT (BLOCKING)
008825  1  5C 89                .WORD   SERIALSTATUS    ; FUNCTION 07 - GET SERIAL STATUS
008827  1  2D 89                .WORD   SERIALINIT      ; FUNCTION 08 - SERIAL PORT INIT
008829  1               
008829  1  2E 89                .WORD   WRSER1          ; FUNCTION 09 - WRITE VIDEO
00882B  1  3D 89                .WORD   RDSER1          ; FUNCTION 10 - READ KEYBOARD
00882D  1  4D 89                .WORD   RDSER1W         ; FUNCTION 11 - READ KEYBOARD (BLOCKING)
00882F  1  5C 89                .WORD   SERIALSTATUS    ; FUNCTION 12 - GET KEYBOARD STATUS
008831  1  2D 89                .WORD   SERIALINIT      ; FUNCTION 13 - INIT INTERFACE
008833  1               
008833  1  22 97                .WORD   drv_noop        ; FUNCTION 14
008835  1  22 97                .WORD   drv_noop        ; FUNCTION 15
008837  1  22 97                .WORD   drv_noop        ; FUNCTION 16
008839  1  22 97                .WORD   drv_noop        ; FUNCTION 17
00883B  1  22 97                .WORD   drv_noop        ; FUNCTION 18
00883D  1  22 97                .WORD   drv_noop        ; FUNCTION 19
00883F  1  22 97                .WORD   drv_noop        ; FUNCTION 20
008841  1  22 97                .WORD   drv_noop        ; FUNCTION 21
008843  1  22 97                .WORD   drv_noop        ; FUNCTION 22
008845  1  22 97                .WORD   drv_noop        ; FUNCTION 23
008847  1  22 97                .WORD   drv_noop        ; FUNCTION 24
008849  1  22 97                .WORD   drv_noop        ; FUNCTION 25
00884B  1  22 97                .WORD   drv_noop        ; FUNCTION 26
00884D  1  22 97                .WORD   drv_noop        ; FUNCTION 27
00884F  1  22 97                .WORD   drv_noop        ; FUNCTION 28
008851  1  22 97                .WORD   drv_noop        ; FUNCTION 29
008853  1  22 97                .WORD   drv_noop        ; FUNCTION 30
008855  1  22 97                .WORD   drv_noop        ; FUNCTION 31
008857  1  22 97                .WORD   drv_noop        ; FUNCTION 32
008859  1  22 97                .WORD   drv_noop        ; FUNCTION 33
00885B  1  22 97                .WORD   drv_noop        ; FUNCTION 34
00885D  1  22 97                .WORD   drv_noop        ; FUNCTION 35
00885F  1  22 97                .WORD   drv_noop        ; FUNCTION 36
008861  1  22 97                .WORD   drv_noop        ; FUNCTION 37
008863  1  22 97                .WORD   drv_noop        ; FUNCTION 38
008865  1  22 97                .WORD   drv_noop        ; FUNCTION 39
008867  1               ;
008867  1  1C 8E                .WORD   DSKY_INIT       ; FUNCTION 40 -
008869  1  E1 8F                .WORD   DSKY_SHOW       ; FUNCTION 41 -
00886B  1  A2 8F                .WORD   DSKY_BIN2SEG    ; FUNCTION 42 -
00886D  1  24 8F                .WORD   DSKY_RESET      ; FUNCTION 43 -
00886F  1  3F 8F                .WORD   DSKY_STAT       ; FUNCTION 44 -
008871  1  4C 8F                .WORD   DSKY_GETKEY     ; FUNCTION 45 -
008873  1  C4 90                .WORD   DSKY_BEEP       ; FUNCTION 46 -
008875  1  F5 90                .WORD   DSKY_DSPL       ; FUNCTION 47 -
008877  1  A9 90                .WORD   DSKY_PUTLED     ; FUNCTION 48 -
008879  1  6F 90                .WORD   DSKY_BLANK      ; FUNCTION 49 -
00887B  1               ;
00887B  1  22 97                .WORD   drv_noop        ; FUNCTION 50 -
00887D  1  22 97                .WORD   drv_noop        ; FUNCTION 51 -
00887F  1  22 97                .WORD   drv_noop        ; FUNCTION 52 -
008881  1               
008881  1  22 97                .WORD   drv_noop        ; FUNCTION 53
008883  1  22 97                .WORD   drv_noop        ; FUNCTION 54
008885  1  22 97                .WORD   drv_noop        ; FUNCTION 55
008887  1  22 97                .WORD   drv_noop        ; FUNCTION 56
008889  1  22 97                .WORD   drv_noop        ; FUNCTION 57
00888B  1  22 97                .WORD   drv_noop        ; FUNCTION 58
00888D  1  22 97                .WORD   drv_noop        ; FUNCTION 59
00888F  1               
00888F  1  6B 89                .WORD   PPIDE_INIT      ; FUNCTION 60 - called during OS init
008891  1  33 8C                .WORD   IDE_READ_SECTOR ; FUNCTION 61 - read a sector from drive
008893  1  7D 8C                .WORD   IDE_WRITE_SECTOR; FUNCTION 62 - write a sector to drive
008895  1               ;
008895  1  4F 91                .WORD   MD_SHOW         ; FUNCTION 63 - init the mem device
008897  1  98 91                .WORD   MD_READ_SECTOR  ; FUNCTION 64 - read a sector from the memory device
008899  1  C8 91                .WORD   MD_WRITE_SECTOR ; FUNCTION 65 - write a sector to the memory device
00889B  1               ;
00889B  1  0F 92                .WORD   FL_SETUP        ; FUNCTION 66 - init floppy device
00889D  1  3C 93                .WORD   FL_READ_SECTOR  ; FUNCTION 67 - read a sector from floppy device
00889F  1  BB 93                .WORD   FL_WRITE_SECTOR ; FUNCTION 68 - write a sector to floppy device
0088A1  1               
0088A1  1               
0088A1  1               ;__DRIVERS___________________________________________________________________________________________
0088A1  1               ;
0088A1  1                       .INCLUDE "drvmacro.asm"
0088A1  2               ;__MACRO___________________________________________________________________________________________________________________
0088A1  2               ;
0088A1  2               ; 	Macros for the betterment of Mankind
0088A1  2               ;________________________________________________________________________________________________________________________________
0088A1  2               ;
0088A1  2               
0088A1  2               .macro          PRTDBG      message
0088A1  2               .LOCAL p1
0088A1  2               .LOCAL p2
0088A1  2               .LOCAL p3
0088A1  2               .LOCAL p4
0088A1  2               .LOCAL p5
0088A1  2                 .if     .paramcount <> 1
0088A1  2                       .error  "Too few parameters for macro PRTDBG"
0088A1  2                       .endif
0088A1  2                       .if DEBUG=1
0088A1  2                       PHA
0088A1  2                       txa
0088A1  2                       PHA
0088A1  2                       tya
0088A1  2                       PHA
0088A1  2                       LDX #$00
0088A1  2               p1:
0088A1  2                       LDA p4,x
0088A1  2                       INX
0088A1  2                       CMP #'$'
0088A1  2                       BEQ p2
0088A1  2                       JSR MACRO_OUTCH
0088A1  2                       JMP p1
0088A1  2               p2:
0088A1  2                       LDA #13
0088A1  2                       jsr MACRO_OUTCH
0088A1  2                       LDA #10
0088A1  2                       jsr MACRO_OUTCH
0088A1  2                       PLA
0088A1  2                       tay
0088A1  2                       PLA
0088A1  2                       tax
0088A1  2                       pla
0088A1  2                       JMP p5
0088A1  2               p4:
0088A1  2                       .BYTE message
0088A1  2               p5:
0088A1  2                       .endif
0088A1  2               .endmacro
0088A1  2               
0088A1  2               .macro          PRTS      message
0088A1  2               .LOCAL p1
0088A1  2               .LOCAL p2
0088A1  2               .LOCAL p3
0088A1  2               .LOCAL p4
0088A1  2               .LOCAL p5
0088A1  2                 .if     .paramcount <> 1
0088A1  2                       .error  "Too few parameters for macro PRTS"
0088A1  2                       .endif
0088A1  2                       PHA
0088A1  2                       TXA
0088A1  2                       PHA
0088A1  2                       tay
0088A1  2                       PHa
0088A1  2                       LDX #$00
0088A1  2               p1:
0088A1  2                       LDA p4,x
0088A1  2                       INX
0088A1  2                       CMP #'$'
0088A1  2                       BEQ p2
0088A1  2                       JSR MACRO_OUTCH
0088A1  2                       JMP p1
0088A1  2               p2:
0088A1  2                       PLA
0088A1  2                       tay
0088A1  2                       PLA
0088A1  2                       tax
0088A1  2                       pla
0088A1  2                       JMP p5
0088A1  2               p4:
0088A1  2                       .BYTE message
0088A1  2               p5:
0088A1  2               .endmacro
0088A1  2               
0088A1  2               .macro          DBGFLAG      character
0088A1  2                 .if     .paramcount <> 1
0088A1  2                       .error  "Too few parameters for macro DBGFLAG"
0088A1  2                       .endif
0088A1  2                       .if DEBUG=1
0088A1  2                       PHA
0088A1  2                       LDA #character
0088A1  2                       JSR MACRO_OUTCH
0088A1  2                       pla
0088A1  2                       .endif
0088A1  2               .endmacro
0088A1  2               
0088A1  2               
0088A1  2               ;__PRTHEXBYTE__________________________________________________
0088A1  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0088A1  2               ;______________________________________________________________
0088A1  2               PRTHEXBYTE:
0088A1  2  48                   PHA
0088A2  2  8D 35 06             sta     STACKA
0088A5  2  8A                   txa
0088A6  2  48                   PHa
0088A7  2  98                   tya
0088A8  2  48                   PHA
0088A9  2  AD 35 06             lda     STACKA
0088AC  2  AA                   TAX				; SAVE A REGISTER
0088AD  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
0088AE  2  4A                   LSR 				;
0088AF  2  4A                   LSR 				;
0088B0  2  4A                   LSR 				;
0088B1  2  18                   CLC               		; CLEAR CARRY
0088B2  2  20 BF 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0088B5  2  8A                   TXA				; RESTORE ACCUMULATOR
0088B6  2  20 BF 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0088B9  2  68                   pla
0088BA  2  A8                   TAY
0088BB  2  68                   pla
0088BC  2  AA                   TAX
0088BD  2  68                   PLA
0088BE  2  60                   RTS
0088BF  2               
0088BF  2               ;__PRINT_DIGIT_________________________________________________
0088BF  2               ;
0088BF  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0088BF  2               ;
0088BF  2               ;______________________________________________________________
0088BF  2               PRINT_DIGIT:
0088BF  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
0088C1  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
0088C3  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
0088C5  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0088C7  2  18                          CLC				; CLEAR CARRY
0088C8  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
0088CA  2               PRINT_DIGIT_OUT:					;
0088CA  2  4C 24 89                    JMP MACRO_OUTCH              		; PRINT OUT CHAR
0088CD  2               
0088CD  2               NEWLINE:
0088CD  2  48                           pha
0088CE  2  A9 0D                        LDA #$0D
0088D0  2  20 24 89                     JSR MACRO_OUTCH
0088D3  2  A9 0A                        LDA #$0A
0088D5  2  20 24 89                     Jsr MACRO_OUTCH
0088D8  2  68                           pla
0088D9  2  60                           rts
0088DA  2               
0088DA  2               PRTDEC:
0088DA  2  48                           PHA
0088DB  2  8D 35 06                     STA     STACKA
0088DE  2  98                           TYA
0088DF  2  48                           phA
0088E0  2  8A                           TXA
0088E1  2  48                           PHA
0088E2  2  AD 35 06                     LDA     STACKA
0088E5  2  48                           PHA
0088E6  2  A0 00                        ldy #00
0088E8  2  A2 FF                        LDX #$FF
0088EA  2  38                           SEC
0088EB  2               PrDec100:
0088EB  2  E8                           INX
0088EC  2  E9 64                        SBC #100
0088EE  2  B0 FB                        BCS PrDec100            ;Count how many 100s
0088F0  2  69 64                        ADC #100
0088F2  2  20 0E 89                     JSR PrDecDigit          ;Print the 100s
0088F5  2  A2 FF                        LDX #$FF
0088F7  2  38                           SEC                     ;Prepare for subtraction
0088F8  2               PrDec10:
0088F8  2  E8                           INX
0088F9  2  E9 0A                        SBC #10
0088FB  2  B0 FB                        BCS PrDec10             ;Count how many 10s
0088FD  2  69 0A                        ADC #10
0088FF  2  20 0E 89                     JSR PrDecDigit          ;Print the 10s
008902  2  AA                           TAX                     ;Pass 1s into X
008903  2  A0 01                        ldy #1
008905  2  20 0E 89                     JSR PrDecDigit          ;Print the 1s
008908  2  68                           PLA
008909  2  68                           pla
00890A  2  AA                           TAX
00890B  2  68                           pla
00890C  2  A8                           TAY
00890D  2  60                           RTS
00890E  2               PrDecDigit:
00890E  2  48                           PHA
00890F  2  C0 00                        cpy #$00
008911  2  D0 09                        bne PrDecDigit1
008913  2  8A                           txa
008914  2  A8                           tay
008915  2  C0 00                        cpy #$00
008917  2  D0 03                        bne PrDecDigit1
008919  2  4C 22 89                     jmp PrDecDigit2
00891C  2               PrDecDigit1:
00891C  2  8A                           TXA                     ;Save A, pass digit to A
00891D  2  09 30                        ORA #'0'
00891F  2  20 24 89                     JSR  MACRO_OUTCH        ;Convert to character and print it
008922  2               PrDecDigit2:
008922  2  68                           PLA
008923  2  60                           RTS                     ;Restore A and return
008924  2               
008924  2               
008924  2               MACRO_OUTCH:
008924  2  48                   PHA
008925  2  A5 3A                LDA     CONSOLE
008927  2  85 32                STA     farfunct
008929  2  68                   PLA
00892A  2  4C 00 88             JMP     FUNCTION_DISPATCHER
00892D  2               
00892D  1                       .INCLUDE "dosser.asm"
00892D  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00892D  2               ;
00892D  2               ; 	Nhyodyne serial drivers for single serial port card
00892D  2               ;
00892D  2               ;	Entry points:
00892D  2               ;		SERIALINIT  - called during OS init
00892D  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00892D  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00892D  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00892D  2               ;		SERIALSTATUS- GET UART STATUS
00892D  2               ;________________________________________________________________________________________________________________________________
00892D  2               ;
00892D  2               
00892D  2               
00892D  2               ;*
00892D  2               ;* HARDWARE I/O ADDRESSES
00892D  2               ;*
00892D  2               
00892D  2               ; UART 16C550 SERIAL
00892D  2               UART0           = $0368         ; DATA IN/OUT
00892D  2               UART1           = $0369         ; CHECK RX
00892D  2               UART2           = $036A         ; INTERRUPTS
00892D  2               UART3           = $036B         ; LINE CONTROL
00892D  2               UART4           = $036C         ; MODEM CONTROL
00892D  2               UART5           = $036D         ; LINE STATUS
00892D  2               UART6           = $036E         ; MODEM STATUS
00892D  2               UART7           = $036F         ; SCRATCH REG.
00892D  2               
00892D  2               
00892D  2               ;__SERIALINIT____________________________________________________________________________________________________________________
00892D  2               ;
00892D  2               ;	INITIALIZE SERIAL PORTS
00892D  2               ;________________________________________________________________________________________________________________________________
00892D  2               ;
00892D  2               SERIALINIT:
00892D  2               ;	LDA	#$80			;
00892D  2               ;	STA	UART3			; SET DLAB FLAG
00892D  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
00892D  2               ;	STA	UART0			; save baud rate
00892D  2               ;	LDA	#00			;
00892D  2               ;	STA	UART1			;
00892D  2               ;	LDA	#03			;
00892D  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
00892D  2               ;	STA	UART4			;
00892D  2               
00892D  2  60                   RTS
00892E  2               
00892E  2               
00892E  2               
00892E  2               ;__WRSER1________________________________________________________________________________________________________________________
00892E  2               ;
00892E  2               ;	WRITE CHARACTER(A) TO UART
00892E  2               ;________________________________________________________________________________________________________________________________
00892E  2               ;
00892E  2               WRSER1:
00892E  2  48                   PHA
00892F  2               WRSER1a:
00892F  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008932  2  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
008934  2  C9 00                CMP     #$00
008936  2  F0 F7                BEQ     WRSER1a         ; NO, WAIT FOR IT
008938  2  68                   PLA
008939  2  8D 68 03             STA     UART0           ; THEN WRITE THE CHAR TO UART
00893C  2  60                   RTS
00893D  2               
00893D  2               ;__RDSER1________________________________________________________________________________________________________________________
00893D  2               ;
00893D  2               ;	READ CHARACTER FROM UART TO (A)
00893D  2               ;________________________________________________________________________________________________________________________________
00893D  2               ;
00893D  2               RDSER1:
00893D  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008940  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008942  2  C9 00                CMP     #$00
008944  2  F0 04                BEQ     RDSER1N         ; LOOP UNTIL DATA IS READY
008946  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
008949  2  60                   RTS
00894A  2               RDSER1N:
00894A  2  A9 00                LDA     #$00            ;
00894C  2  60                   RTS                     ;
00894D  2               
00894D  2               ;__RDSER1W_______________________________________________________________________________________________________________________
00894D  2               ;
00894D  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
00894D  2               ;________________________________________________________________________________________________________________________________
00894D  2               ;
00894D  2               
00894D  2               RDSER1W:
00894D  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008950  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008952  2  C9 00                CMP     #$00
008954  2  F0 F7                BEQ     RDSER1W         ; LOOP UNTIL DATA IS READY
008956  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
008959  2  29 7F                AND     #$7F
00895B  2  60                   RTS
00895C  2               
00895C  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00895C  2               ;
00895C  2               ;	READ UARD STATUS
00895C  2               ;________________________________________________________________________________________________________________________________
00895C  2               ;
00895C  2               SERIALSTATUS:
00895C  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
00895F  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008961  2  C9 00                CMP     #$00
008963  2  F0 03                BEQ     RDSTAT1         ; NO, INDICATE NO CHAR
008965  2  A9 FF                LDA     #$FF            ; GET DATA CHAR
008967  2  60                   RTS
008968  2               RDSTAT1:
008968  2  A9 00                LDA     #$00            ; GET DATA CHAR
00896A  2  60                   RTS
00896B  2               
00896B  2               ; end
00896B  2               
00896B  1                       .INCLUDE "doside.asm"
00896B  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00896B  2               ;
00896B  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
00896B  2               ;
00896B  2               ;	Entry points:
00896B  2               ;		PPIDE_INIT   	- called during OS init
00896B  2               ;		IDE_READ_SECTOR - read a sector from drive
00896B  2               ;		IDE_WRITE_SECTOR- write a sector to drive
00896B  2               ;________________________________________________________________________________________________________________________________
00896B  2               ;
00896B  2               PPIDE_PPI       = $0360         ; PORT A
00896B  2               ;
00896B  2               PPIDELO         = PPIDE_PPI+0   ; LSB
00896B  2               PPIDEHI         = PPIDE_PPI+1   ; MSB
00896B  2               PPIDECNTRL      = PPIDE_PPI+2   ; Control Signals
00896B  2               PPIDEPPIC       = PPIDE_PPI+3   ; CONTROL BYTE PPI 82C55
00896B  2               
00896B  2               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
00896B  2               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
00896B  2               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
00896B  2               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00896B  2               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00896B  2               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00896B  2               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00896B  2               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00896B  2               
00896B  2               PPIDE_DATA      = PPIDE_CS0_LINE
00896B  2               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
00896B  2               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
00896B  2               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00896B  2               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
00896B  2               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
00896B  2               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00896B  2               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00896B  2               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00896B  2               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00896B  2               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00896B  2               
00896B  2               
00896B  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00896B  2               PPIDE_CMD_RECAL = $10
00896B  2               PPIDE_CMD_READ  = $20
00896B  2               PPIDE_CMD_WRITE = $30
00896B  2               PPIDE_CMD_INIT  = $91
00896B  2               PPIDE_CMD_ID    = $EC
00896B  2               PPIDE_CMD_SPINDOWN = $E0
00896B  2               PPIDE_CMD_SPINUP = $E1
00896B  2               
00896B  2               
00896B  2               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00896B  2               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
00896B  2               
00896B  2               
00896B  2               ;__PPIDE_INIT_________________________________________________________________________________________
00896B  2               ;
00896B  2               ;  INIT AND DISPLAY IDE INFO
00896B  2               ;____________________________________________________________________________________________________
00896B  2               ;
00896B  2               PPIDE_INIT:
00896B  2                       PRTDBG  "PPIDE INIT:$"
00896B  2  48 8A 48 A8          PRTS    "PPIDE :$"
00896F  2  48 A2 00 BD  
008973  2  88 89 E8 C9  
008990  2  20 CD 88             JSR     NEWLINE
008993  2  20 25 8C             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
008996  2  D0 39                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
008998  2               ;
008998  2  48 8A 48 A8          PRTS    " IO=0x$"
00899C  2  48 A2 00 BD  
0089A0  2  B5 89 E8 C9  
0089BC  2  A9 03                LDA     #>PPIDE_PPI     ; GET BASE PORT
0089BE  2  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0089C1  2  A9 60                LDA     #<PPIDE_PPI     ; GET BASE PORT
0089C3  2  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0089C6  2               ;
0089C6  2  20 AA 8C             JSR     PPIDE_RESET     ; RESET THE BUS
0089C9  2  20 6B 8A             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
0089CC  2  B0 03                BCS     IDE_ABORT
0089CE  2  4C FE 89             JMP     IDE_PRINT_INFO
0089D1  2               IDE_ABORT:
0089D1  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
0089D5  2  48 A2 00 BD  
0089D9  2  EE 89 E8 C9  
0089FB  2  4C 67 8A             JMP     IDE_INITA
0089FE  2               IDE_PRINT_INFO:
0089FE  2  20 CD 88             JSR     NEWLINE
008A01  2  48 8A 48 A8          PRTS    " PPIDE0: Blocks=$"
008A05  2  48 A2 00 BD  
008A09  2  1E 8A E8 C9  
008A2F  2  A9 00                LDA     #$00
008A31  2  20 F4 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A34  2  48 8A 48 A8          PRTS    " PPIDE1: Blocks=$"
008A38  2  48 A2 00 BD  
008A3C  2  51 8A E8 C9  
008A62  2  A9 01                LDA     #$01
008A64  2  20 F4 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A67  2               IDE_INITA:
008A67  2  20 CD 88             JSR     NEWLINE
008A6A  2  60                   RTS                     ; DONE
008A6B  2               ;
008A6B  2               ;__PPIDE_PROBE_______________________________________________________________________________________
008A6B  2               ;
008A6B  2               ;  PROBE FOR IDE HARDWARE
008A6B  2               ;____________________________________________________________________________________________________
008A6B  2               ;
008A6B  2               PPIDE_PROBE:
008A6B  2               ;
008A6B  2               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008A6B  2               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008A6B  2               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008A6B  2               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008A6B  2               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008A6B  2               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008A6B  2               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008A6B  2               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008A6B  2               
008A6B  2  A9 00                LDA     #$00
008A6D  2  8D 60 03             STA     PPIDELO         ; PPI PORT A, DATALO
008A70  2               
008A70  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
008A73  2  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
008A75  2  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
008A77  2  20 D4 8D             JSR     IDE_READ
008A7A  2  8A                   TXA
008A7B  2  29 40                AND     #%01000000
008A7D  2  C9 00                CMP     #$00
008A7F  2  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008A81  2               
008A81  2               ; CHECK SIGNATURE
008A81  2  A9 0A                LDA     #PPIDE_SEC_CNT
008A83  2  20 D4 8D             JSR     IDE_READ
008A86  2  E0 01                CPX     #$01
008A88  2  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A8A  2  A9 0B                LDA     #PPIDE_LBALOW
008A8C  2  20 D4 8D             JSR     IDE_READ
008A8F  2  E0 01                CPX     #$01
008A91  2  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A93  2  A9 0C                LDA     #PPIDE_LBAMID
008A95  2  20 D4 8D             JSR     IDE_READ
008A98  2  E0 00                CPX     #$00
008A9A  2  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008A9C  2  A9 0D                LDA     #PPIDE_LBAHI
008A9E  2  20 D4 8D             JSR     IDE_READ
008AA1  2  E0 00                CPX     #$00
008AA3  2  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008AA5  2  18                   CLC
008AA6  2  4C AA 8A             JMP     PPIDE_PROBE_SUCCESS
008AA9  2               PPIDE_PROBE_FAIL:
008AA9  2  38                   SEC
008AAA  2               PPIDE_PROBE_SUCCESS:
008AAA  2  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
008AAB  2               
008AAB  2               
008AAB  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008AAB  2               ;
008AAB  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008AAB  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
008AAB  2               ;________________________________________________________________________________________________________
008AAB  2               
008AAB  2               IDE_IDENTIFY_TYPE:
008AAB  2  48                   PHA
008AAC  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008AAF  2  B0 40                BCS     IDE_IDENTIFY_TYPE_ERROR; IF TIMEOUT, REPORT ERROR
008AB1  2  A9 00                LDA     #$00
008AB3  2  8D 12 06             STA     debsehd
008AB6  2  8D 10 06             STA     debcyll         ; STORE IN TRACK (lsb)
008AB9  2  8D 11 06             STA     debcylm         ; STORE IN TRACK (msb)
008ABC  2  68                   PLA                     ; GET DRIVE TYPE
008ABD  2  20 53 8C             JSR     IDE_READ_SECTOR_DIRTY1
008AC0  2  C9 FF                CMP     #$FF            ; IS THERE A READ ERROR?
008AC2  2  F0 2D                BEQ     IDE_IDENTIFY_TYPE_ERROR
008AC4  2  AD FE 05             LDA     hstbuf+$01FE
008AC7  2  C9 55                CMP     #$55
008AC9  2  D0 23                BNE     IDE_IDENTIFY_TYPE_OK
008ACB  2  AD FF 05             LDA     hstbuf+$01FF
008ACE  2  C9 AA                CMP     #$AA
008AD0  2  D0 1C                BNE     IDE_IDENTIFY_TYPE_OK
008AD2  2  AD C2 05             LDA     hstbuf+$01C2
008AD5  2  C9 00                CMP     #$00
008AD7  2  D0 18                BNE     IDE_IDENTIFY_TYPE_ERROR
008AD9  2  AD D2 05             LDA     hstbuf+$01D2
008ADC  2  C9 00                CMP     #$00
008ADE  2  D0 11                BNE     IDE_IDENTIFY_TYPE_ERROR
008AE0  2  AD E2 05             LDA     hstbuf+$01E2
008AE3  2  C9 00                CMP     #$00
008AE5  2  D0 0A                BNE     IDE_IDENTIFY_TYPE_ERROR
008AE7  2  AD F2 05             LDA     hstbuf+$01F2
008AEA  2  C9 00                CMP     #$00
008AEC  2  D0 03                BNE     IDE_IDENTIFY_TYPE_ERROR
008AEE  2               IDE_IDENTIFY_TYPE_OK:
008AEE  2  A9 00                LDA     #$00            ; EVERYTHING IS AWESOME
008AF0  2  60                   RTS
008AF1  2               IDE_IDENTIFY_TYPE_ERROR:
008AF1  2  A9 FF                LDA     #$FF            ; SIGNIFY ERROR
008AF3  2  60                   RTS
008AF4  2               
008AF4  2               
008AF4  2               ;*__IDE_READ_INFO___________________________________________________________________________________
008AF4  2               ;*
008AF4  2               ;*  READ IDE INFORMATION
008AF4  2               ;*	CARRY SET ON ERROR
008AF4  2               ;* 	A=MST/SLV
008AF4  2               ;*____________________________________________________________________________________________________
008AF4  2               IDE_READ_INFO:
008AF4  2                       PRTDBG  "IDE Read INFORMATION$"
008AF4  2  48                   PHA
008AF5  2  48                   PHA
008AF6  2               ; SET DRIVE BIT
008AF6  2  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
008AF8  2  0A                   ASL     a               ; SHIFT 4
008AF9  2  0A                   ASL     a               ;
008AFA  2  0A                   ASL     a               ;
008AFB  2  0A                   ASL     a               ;
008AFC  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008AFE  2  AA                   TAX
008AFF  2  A0 00                LDY     #$00
008B01  2  A9 0E                LDA     #PPIDE_DEVICE
008B03  2  20 F0 8D             JSR     IDE_WRITE
008B06  2               
008B06  2               
008B06  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008B09  2  B0 52                BCS     IDE_READ_INFO_ABORT
008B0B  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008B0D  2  A2 EC                LDX     #PPIDE_CMD_ID
008B0F  2  20 F0 8D             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008B12  2  20 01 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008B15  2  B0 46                BCS     IDE_READ_INFO_ABORT
008B17  2  20 35 8D             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008B1A  2  48 8A 48 A8          PRTS    "0x$"
008B1E  2  48 A2 00 BD  
008B22  2  37 8B E8 C9  
008B3A  2  AD 7B 04             LDA     hstbuf+123
008B3D  2  20 A1 88             JSR     PRTHEXBYTE
008B40  2  AD 7A 04             LDA     hstbuf+122
008B43  2  20 A1 88             JSR     PRTHEXBYTE
008B46  2  AD 79 04             LDA     hstbuf+121
008B49  2  20 A1 88             JSR     PRTHEXBYTE
008B4C  2  AD 78 04             LDA     hstbuf+120
008B4F  2  20 A1 88             JSR     PRTHEXBYTE
008B52  2  68                   PLA
008B53  2  20 AB 8A             JSR     IDE_IDENTIFY_TYPE
008B56  2  C9 00                CMP     #$00
008B58  2  D0 36                BNE     IDE_READ_INFO_BADFS
008B5A  2  4C C6 8B             JMP     IDE_READ_INFO_OK
008B5D  2               IDE_READ_INFO_ABORT:
008B5D  2  68                   PLA
008B5E  2  48 8A 48 A8          PRTS    "NOT PRESENT$"  ; NOT PRESENT
008B62  2  48 A2 00 BD  
008B66  2  7B 8B E8 C9  
008B87  2  20 CD 88             JSR     NEWLINE
008B8A  2  68                   PLA
008B8B  2  20 01 8C             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008B8E  2  38                   SEC
008B8F  2  60                   RTS                     ;
008B90  2               IDE_READ_INFO_BADFS:
008B90  2  48 8A 48 A8          PRTS    " BAD FILESYSTEM$"; NOT PRESENT
008B94  2  48 A2 00 BD  
008B98  2  AD 8B E8 C9  
008BBD  2  20 CD 88             JSR     NEWLINE
008BC0  2  68                   PLA
008BC1  2  20 01 8C             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008BC4  2  38                   SEC
008BC5  2  60                   RTS                     ;
008BC6  2               IDE_READ_INFO_OK:
008BC6  2  48 8A 48 A8          PRTS    " FILE SYSTEM COMPATIBLE$"; NOT PRESENT
008BCA  2  48 A2 00 BD  
008BCE  2  E3 8B E8 C9  
008BFB  2  20 CD 88             JSR     NEWLINE
008BFE  2  68                   PLA
008BFF  2  18                   CLC
008C00  2  60                   RTS
008C01  2               
008C01  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008C01  2  18                   CLC
008C02  2  69 30                ADC     #$30
008C04  2  A2 00                LDX     #$00
008C06  2               @1:
008C06  2  DD 17 06             CMP     dskcfg,X        ; GET device
008C09  2  F0 09                BEQ     @2
008C0B  2  E8                   INX
008C0C  2  E8                   INX
008C0D  2  E0 10                CPX     #16
008C0F  2  D0 F5                BNE     @1
008C11  2  4C 24 8C             JMP     @3
008C14  2               @2:
008C14  2  48                   PHA
008C15  2  A9 00                LDA     #$00
008C17  2  9D 17 06             STA     dskcfg,X        ; SET device
008C1A  2  E8                   INX
008C1B  2  9D 17 06             STA     dskcfg,X        ; SET device
008C1E  2  68                   PLA
008C1F  2  E8                   INX
008C20  2  E0 10                CPX     #16
008C22  2  D0 E2                BNE     @1
008C24  2               @3:
008C24  2  60                   RTS
008C25  2               
008C25  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008C25  2               ;
008C25  2               ;  PROBE FOR PPI HARDWARE
008C25  2               ;____________________________________________________________________________________________________
008C25  2               ;
008C25  2               IDE_PPIDETECT:
008C25  2               ;
008C25  2               ; TEST FOR PPI EXISTENCE
008C25  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008C25  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008C25  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008C25  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008C25  2               ; INTERFERE WITH THE VALUE BEING READ.
008C25  2  20 14 8E             JSR     SET_PPI_WR
008C28  2               ;
008C28  2  A9 00                LDA     #$00            ; VALUE ZERO
008C2A  2  8D 60 03             STA     PPIDELO         ; PUSH VALUE TO PORT
008C2D  2  AD 60 03             LDA     PPIDELO         ; GET PORT VALUE
008C30  2  C9 00                CMP     #$00
008C32  2  60                   RTS                     ; AND RETURN
008C33  2               ;
008C33  2               
008C33  2               
008C33  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008C33  2               ;*
008C33  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008C33  2               ;*
008C33  2               ;*____________________________________________________________________________________________________
008C33  2               IDE_READ_SECTOR:
008C33  2  AD 12 06             LDA     debsehd         ; STORE CURRENT PARMS
008C36  2  CD 46 06             CMP     Cdebsehd        ;
008C39  2  D0 13                BNE     IDE_READ_SECTOR_DIRTY
008C3B  2  AD 11 06             LDA     debcylm         ;
008C3E  2  CD 45 06             CMP     Cdebcylm        ;
008C41  2  D0 0B                BNE     IDE_READ_SECTOR_DIRTY
008C43  2  AD 10 06             LDA     debcyll         ;
008C46  2  CD 44 06             CMP     Cdebcyll        ;
008C49  2  D0 03                BNE     IDE_READ_SECTOR_DIRTY
008C4B  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C4D  2  60                   RTS
008C4E  2               
008C4E  2               IDE_READ_SECTOR_DIRTY:
008C4E  2                       PRTDBG  "IDE Read Sector Buffer Dirty$"
008C4E  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C51  2  B0 27                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C53  2               IDE_READ_SECTOR_DIRTY1:
008C53  2  20 A1 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C56  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008C58  2  A2 20                LDX     #PPIDE_CMD_READ
008C5A  2  20 F0 8D             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008C5D  2  20 01 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008C60  2  B0 18                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C62  2  20 35 8D             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008C65  2  AD 12 06             LDA     debsehd         ; STORE CURRENT PARMS
008C68  2  8D 46 06             STA     Cdebsehd        ;
008C6B  2  AD 10 06             LDA     debcyll         ;
008C6E  2  8D 44 06             STA     Cdebcyll        ;
008C71  2  AD 11 06             LDA     debcylm         ;
008C74  2  8D 45 06             STA     Cdebcylm        ;
008C77  2               
008C77  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C79  2  60                   RTS
008C7A  2               IDE_READ_SECTOR_DIRTY_ERROR:
008C7A  2  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
008C7C  2  60                   RTS
008C7D  2               
008C7D  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008C7D  2               ;*
008C7D  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008C7D  2               ;*
008C7D  2               ;*____________________________________________________________________________________________________
008C7D  2               IDE_WRITE_SECTOR:
008C7D  2                       PRTDBG  "IDE Write Sector$"
008C7D  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C80  2  B0 25                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C82  2               IDE_WRITE_SECTOR_RAW:
008C82  2  20 A1 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C85  2  A9 0F                LDA     #PPIDE_COMMAND
008C87  2  A2 30                LDX     #PPIDE_CMD_WRITE
008C89  2  20 F0 8D             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
008C8C  2  20 01 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
008C8F  2  B0 16                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C91  2  20 6A 8D             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
008C94  2  20 D5 8C             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
008C97  2  B0 0E                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C99  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
008C9B  2  8D 46 06             STA     Cdebsehd        ;
008C9E  2  8D 44 06             STA     Cdebcyll        ;
008CA1  2  8D 45 06             STA     Cdebcylm        ;
008CA4  2               
008CA4  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008CA6  2  60                   RTS
008CA7  2               IDE_WRITE_SECTOR_ERROR:
008CA7  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008CA9  2  60                   RTS
008CAA  2               
008CAA  2               ;*__PPIDE_RESET____________________________________________________________________________________
008CAA  2               ;*
008CAA  2               ;*  SOFT RESET IDE CHANNEL
008CAA  2               ;*
008CAA  2               ;*____________________________________________________________________________________________________
008CAA  2               PPIDE_RESET:
008CAA  2                       PRTDBG  "IDE Reset$"
008CAA  2  A9 00                LDA     #$00
008CAC  2  8D 12 06             STA     debsehd
008CAF  2  8D 10 06             STA     debcyll
008CB2  2  8D 11 06             STA     debcylm
008CB5  2  A9 FF                LDA     #$FF            ;
008CB7  2  8D 46 06             STA     Cdebsehd        ;
008CBA  2  8D 44 06             STA     Cdebcyll        ;
008CBD  2  8D 45 06             STA     Cdebcylm        ;
008CC0  2               
008CC0  2  A9 80                LDA     #PPIDE_RST_LINE
008CC2  2  8D 62 03             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
008CC5  2  A2 00                LDX     #$00
008CC7  2                       PRTDBG  "IDE Reset Delay$"
008CC7  2               RST_DLY:
008CC7  2  CA                   DEX
008CC8  2  E0 00                CPX     #$00
008CCA  2  D0 FB                BNE     RST_DLY
008CCC  2  A9 00                LDA     #$00
008CCE  2  8D 62 03             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
008CD1  2               
008CD1  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008CD1  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008CD1  2  20 1C 8F             JSR     DSKY_REINIT
008CD4  2               
008CD4  2  60                   RTS
008CD5  2               
008CD5  2               
008CD5  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008CD5  2               ;*
008CD5  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008CD5  2               ;*
008CD5  2               ;*____________________________________________________________________________________________________
008CD5  2               IDE_WAIT_NOT_BUSY:
008CD5  2  48                   PHA
008CD6  2  8A                   TXA
008CD7  2  48                   PHA
008CD8  2  98                   TYA
008CD9  2  48                   PHA
008CDA  2  A9 00                LDA     #$00
008CDC  2  8D 37 06             STA     FLRETRY
008CDF  2  8D 38 06             STA     FLRETRY+1
008CE2  2               IDE_WAIT_NOT_BUSY1:
008CE2  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
008CE4  2  20 D4 8D             JSR     IDE_READ
008CE7  2  8A                   TXA
008CE8  2  29 80                AND     #$80
008CEA  2  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
008CEC  2  EE 37 06             INC     FLRETRY
008CEF  2  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
008CF1  2  EE 38 06             INC     FLRETRY+1
008CF4  2  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
008CF6  2  38                   SEC
008CF7  2  4C FB 8C             JMP     IDE_WAIT_NOT_BUSY3
008CFA  2               IDE_WAIT_NOT_BUSY2:
008CFA  2  18                   CLC
008CFB  2               IDE_WAIT_NOT_BUSY3:
008CFB  2  68                   PLA
008CFC  2  A8                   TAY
008CFD  2  68                   PLA
008CFE  2  AA                   TAX
008CFF  2  68                   PLA
008D00  2  60                   RTS
008D01  2               
008D01  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008D01  2               ;*
008D01  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008D01  2               ;*
008D01  2               ;*____________________________________________________________________________________________________
008D01  2               IDE_WAIT_DRQ:
008D01  2  48                   PHA
008D02  2  8A                   TXA
008D03  2  48                   PHA
008D04  2  98                   TYA
008D05  2  48                   PHA
008D06  2  A9 00                LDA     #$00
008D08  2  8D 37 06             STA     FLRETRY
008D0B  2  8D 38 06             STA     FLRETRY+1
008D0E  2               IDE_WAIT_DRQ1:
008D0E  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
008D10  2  20 D4 8D             JSR     IDE_READ
008D13  2  8A                   TXA
008D14  2  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
008D16  2  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008D18  2  F0 14                BEQ     IDE_WAIT_DRQ2
008D1A  2  29 01                AND     #%00000001      ; IS ERROR?
008D1C  2  C9 01                CMP     #%00000001      ;
008D1E  2  F0 0A                BEQ     IDE_WAIT_DRQE
008D20  2  EE 37 06             INC     FLRETRY
008D23  2  D0 E9                BNE     IDE_WAIT_DRQ1
008D25  2  EE 38 06             INC     FLRETRY+1
008D28  2  D0 E4                BNE     IDE_WAIT_DRQ1
008D2A  2               IDE_WAIT_DRQE:
008D2A  2  38                   SEC
008D2B  2  4C 2F 8D             JMP     IDE_WAIT_DRQ3
008D2E  2               IDE_WAIT_DRQ2:
008D2E  2  18                   CLC
008D2F  2               IDE_WAIT_DRQ3:
008D2F  2  68                   PLA
008D30  2  A8                   TAY
008D31  2  68                   PLA
008D32  2  AA                   TAX
008D33  2  68                   PLA
008D34  2  60                   RTS
008D35  2               
008D35  2               
008D35  2               
008D35  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008D35  2               ;*
008D35  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008D35  2               ;*
008D35  2               ;*____________________________________________________________________________________________________
008D35  2               IDE_READ_BUFFER:
008D35  2  A2 00                LDX     #$00            ; INDEX
008D37  2               IDEBUFRD:
008D37  2  8E 3C 06             STX     PPIDEINDEX
008D3A  2  A9 08                LDA     #PPIDE_DATA
008D3C  2  20 D4 8D             JSR     IDE_READ
008D3F  2  8A                   TXA
008D40  2  AE 3C 06             LDX     PPIDEINDEX
008D43  2  9D 00 04             STA     hstbuf,X        ;
008D46  2  E8                   INX                     ;
008D47  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D48  2  9D 00 04             STA     hstbuf,X        ;
008D4B  2  E8                   INX
008D4C  2  E0 00                CPX     #$00            ;
008D4E  2  D0 E7                BNE     IDEBUFRD        ;
008D50  2               IDEBUFRD1:
008D50  2  8E 3C 06             STX     PPIDEINDEX
008D53  2  A9 08                LDA     #PPIDE_DATA
008D55  2  20 D4 8D             JSR     IDE_READ
008D58  2  8A                   TXA
008D59  2  AE 3C 06             LDX     PPIDEINDEX
008D5C  2  9D 00 05             STA     hstbuf+256,X    ;
008D5F  2  E8                   INX                     ;
008D60  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D61  2  9D 00 05             STA     hstbuf+256,X    ;
008D64  2  E8                   INX                     ;
008D65  2  E0 00                CPX     #$00            ;
008D67  2  D0 E7                BNE     IDEBUFRD1       ;
008D69  2  60                   RTS                     ;
008D6A  2               
008D6A  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008D6A  2               ;*
008D6A  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008D6A  2               ;*
008D6A  2               ;*____________________________________________________________________________________________________
008D6A  2               IDE_WRITE_BUFFER:
008D6A  2  A2 00                LDX     #$00            ; INDEX
008D6C  2               IDEBUFWT:
008D6C  2  8E 3C 06             STX     PPIDEINDEX
008D6F  2  BD 01 04             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
008D72  2  A8                   TAY                     ;
008D73  2  BD 00 04             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
008D76  2  AA                   TAX
008D77  2  A9 08                LDA     #PPIDE_DATA
008D79  2  20 F0 8D             JSR     IDE_WRITE
008D7C  2  AE 3C 06             LDX     PPIDEINDEX
008D7F  2  E8                   INX                     ;
008D80  2  E8                   INX                     ;
008D81  2  E0 00                CPX     #$00            ;
008D83  2  D0 E7                BNE     IDEBUFWT        ;
008D85  2  A2 00                LDX     #$00            ; INDEX
008D87  2               IDEBUFWT1:
008D87  2  8E 3C 06             STX     PPIDEINDEX
008D8A  2  BD 01 05             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
008D8D  2  A8                   TAY
008D8E  2  BD 00 05             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
008D91  2  AA                   TAX
008D92  2  A9 08                LDA     #PPIDE_DATA
008D94  2  20 F0 8D             JSR     IDE_WRITE
008D97  2  AE 3C 06             LDX     PPIDEINDEX
008D9A  2  E8                   INX                     ;
008D9B  2  E8                   INX                     ;
008D9C  2  E0 00                CPX     #$00            ;
008D9E  2  D0 E7                BNE     IDEBUFWT1       ;
008DA0  2  60                   RTS                     ;
008DA1  2               
008DA1  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008DA1  2               ;*
008DA1  2               ;*  SETUP LBA DATA
008DA1  2               ;*  A= DRIVE DEVICE
008DA1  2               ;*____________________________________________________________________________________________________
008DA1  2               IDE_SETUP_LBA:
008DA1  2                       PRTDBG  "PPIDE SETUP LBA$"
008DA1  2  AD 3D 06             LDA     CURRENT_IDE_DRIVE
008DA4  2  29 01                AND     #$01            ; only want drive cfg
008DA6  2  0A                   ASL     a               ; SHIFT 4
008DA7  2  0A                   ASL     a               ;
008DA8  2  0A                   ASL     a               ;
008DA9  2  0A                   ASL     a               ;
008DAA  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008DAC  2  AA                   TAX
008DAD  2  A0 00                LDY     #$00
008DAF  2  A9 0E                LDA     #PPIDE_DEVICE
008DB1  2  20 F0 8D             JSR     IDE_WRITE
008DB4  2               
008DB4  2  AE 11 06             LDX     debcylm
008DB7  2  A9 0D                LDA     #PPIDE_LBAHI
008DB9  2  20 F0 8D             JSR     IDE_WRITE
008DBC  2               
008DBC  2  AE 10 06             LDX     debcyll         ;
008DBF  2  A9 0C                LDA     #PPIDE_LBAMID
008DC1  2  20 F0 8D             JSR     IDE_WRITE
008DC4  2               
008DC4  2  AE 12 06             LDX     debsehd         ;
008DC7  2  A9 0B                LDA     #PPIDE_LBALOW
008DC9  2  20 F0 8D             JSR     IDE_WRITE
008DCC  2               
008DCC  2  A2 01                LDX     #$01
008DCE  2  A9 0A                LDA     #PPIDE_SEC_CNT
008DD0  2  20 F0 8D             JSR     IDE_WRITE
008DD3  2               
008DD3  2  60                   RTS
008DD4  2               
008DD4  2               
008DD4  2               ;-------------------------------------------------------------------------------
008DD4  2               
008DD4  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008DD4  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008DD4  2               ; PROGRAM WOULD NOT CALL TO THESE.
008DD4  2               
008DD4  2               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008DD4  2               ;INPUT A = IDE REGSITER ADDRESS
008DD4  2               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008DD4  2               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008DD4  2               
008DD4  2               IDE_READ:
008DD4  2  20 0C 8E             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
008DD7  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008DDA  2  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
008DDC  2  8D 62 03             STA     PPIDECNTRL
008DDF  2  AE 60 03             LDX     PPIDELO         ; READ LOWER BYTE
008DE2  2  AC 61 03             LDY     PPIDEHI         ; READ UPPER BYTE
008DE5  2  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
008DE7  2  8D 62 03             STA     PPIDECNTRL
008DEA  2  A9 00                LDA     #$00
008DEC  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008DEF  2  60                   RTS
008DF0  2               
008DF0  2               
008DF0  2               
008DF0  2               
008DF0  2               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008DF0  2               ;INPUT A = IDE REGISTER ADDRESS
008DF0  2               ;INPUT REGISTER X = LSB TO WRITE
008DF0  2               ;INPUT REGISTER Y = MSB TO WRITE
008DF0  2               ;
008DF0  2               
008DF0  2               
008DF0  2               IDE_WRITE:
008DF0  2  20 14 8E             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
008DF3  2               
008DF3  2  8E 60 03             STX     PPIDELO         ; WRITE LOWER BYTE
008DF6  2  8C 61 03             STY     PPIDEHI         ; WRITE UPPER BYTE
008DF9  2               
008DF9  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008DFC  2               
008DFC  2  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
008DFE  2  8D 62 03             STA     PPIDECNTRL
008E01  2               
008E01  2  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
008E03  2  8D 62 03             STA     PPIDECNTRL
008E06  2               
008E06  2  A9 00                LDA     #$00
008E08  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008E0B  2  60                   RTS
008E0C  2               
008E0C  2               
008E0C  2               ;-----------------------------------------------------------------------------------
008E0C  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008E0C  2               ;
008E0C  2               ;------------------------------------------------------------------------------------
008E0C  2               
008E0C  2               SET_PPI_RD:
008E0C  2  48                   PHA
008E0D  2  A9 92                LDA     #PPRD_IDE_8255
008E0F  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
008E12  2  68                   PLA
008E13  2  60                   RTS
008E14  2               
008E14  2               SET_PPI_WR:
008E14  2  48                   PHA
008E15  2  A9 80                LDA     #PPWR_IDE_8255
008E17  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
008E1A  2  68                   PLA
008E1B  2  60                   RTS
008E1C  2               
008E1C  1                       .INCLUDE "dosdskyn.asm"
008E1C  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
008E1C  2               ;
008E1C  2               ; 	Nhyodyne DSKY/NG drivers
008E1C  2               ;
008E1C  2               ;	Entry points:
008E1C  2               ;               DSKY_INIT
008E1C  2               ;               DSKY_SHOW
008E1C  2               ;               DSKY_BIN2SEG
008E1C  2               ;               DSKY_RESET
008E1C  2               ;               DSKY_STAT
008E1C  2               ;               DSKY_GETKEY
008E1C  2               ;               DSKY_BEEP
008E1C  2               ;               DSKY_L1ON
008E1C  2               ;               DSKY_L2ON
008E1C  2               ;               DSKY_L1OFF
008E1C  2               ;               DSKY_L2OFF
008E1C  2               ;               DSKY_PUTLED
008E1C  2               ;               DSKY_BLANK
008E1C  2               ;________________________________________________________________________________________________________________________________
008E1C  2               ;
008E1C  2               ;
008E1C  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
008E1C  2               ;
008E1C  2               ; LED SEGMENTS (BIT VALUES)
008E1C  2               ;
008E1C  2               ;	+--01--+
008E1C  2               ;	20    02
008E1C  2               ;	+--40--+
008E1C  2               ;	10    04
008E1C  2               ;	+--08--+  80
008E1C  2               ;
008E1C  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
008E1C  2               ;                          ||||||||
008E1C  2               ;                          |||||+++-- ROW
008E1C  2               ;                          ||+++----- COL
008E1C  2               ;                          |+-------- SHIFT
008E1C  2               ;                          +--------- CONTROL
008E1C  2               ;
008E1C  2               ;	00	08	10	18	23
008E1C  2               ;	01	09	11	19	22
008E1C  2               ;	02	0A	12	1A	21
008E1C  2               ;	03	0B	13	1B	20
008E1C  2               ;	04	0C	14	1C	SHIFT
008E1C  2               ;	05	0D	15	1D	CTRL
008E1C  2               ;
008E1C  2               ; LED BIT MAP (BIT VALUES)
008E1C  2               ;
008E1C  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
008E1C  2               ;	---	---	---	---	---	---	---	---
008E1C  2               ;	01	01	01	01	01
008E1C  2               ;	02	02	02	02	02
008E1C  2               ;	04      04      04      04	04
008E1C  2               ;	08      08      08      08	08
008E1C  2               ;	10      10      10      10	10
008E1C  2               ;	20      20      20      20	20	L1	L2 	BUZZ
008E1C  2               ;
008E1C  2               DSKY_PPI        = $0360         ; PORT
008E1C  2               DSKY_PPIA       = DSKY_PPI + 0  ; PORT A
008E1C  2               DSKY_PPIB       = DSKY_PPI + 1  ; PORT B
008E1C  2               DSKY_PPIC       = DSKY_PPI + 2  ; PORT C
008E1C  2               DSKY_PPIX       = DSKY_PPI + 3  ; PPI CONTROL PORT
008E1C  2               ;
008E1C  2               DSKY_PPIX_RD    = %10010010     ; PPIX VALUE FOR READS
008E1C  2               DSKY_PPIX_WR    = %10000010     ; PPIX VALUE FOR WRITES
008E1C  2               ;
008E1C  2               ; PIO CHANNEL C:
008E1C  2               ;
008E1C  2               ;	7	6	5	4	3	2	1	0
008E1C  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
008E1C  2               ;
008E1C  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
008E1C  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
008E1C  2               ;
008E1C  2               DSKY_PPI_IDLE   = %00000110
008E1C  2               ;
008E1C  2               DSKY_CMD_CLR    = %11011111     ; CLEAR (ALL OFF)
008E1C  2               DSKY_CMD_CLRX   = %11010011     ; CLEAR (ALL ON)
008E1C  2               DSKY_CMD_WDSP   = %10010000     ; WRITE DISPLAY RAM
008E1C  2               DSKY_CMD_RDSP   = %01110000     ; READ DISPLAY RAM
008E1C  2               DSKY_CMD_CLK    = %00100000     ; SET CLK PRESCALE
008E1C  2               DSKY_CMD_FIFO   = %01000000     ; READ FIFO
008E1C  2               ;
008E1C  2               DSKY_PRESCL     = DSKYOSC/100000; PRESCALER
008E1C  2               ;
008E1C  2               ;__DSKY_INIT_________________________________________________________________________________________
008E1C  2               ;
008E1C  2               ;  DISPLAY DSKY INFO
008E1C  2               ;____________________________________________________________________________________________________
008E1C  2               ;
008E1C  2               DSKY_INIT:
008E1C  2                       PRTDBG  "DSKY INIT:$"
008E1C  2  20 EC 8E             JSR     DSKY_PREINIT
008E1F  2  48 8A 48 A8          PRTS    "DSKY:$"
008E23  2  48 A2 00 BD  
008E27  2  3C 8E E8 C9  
008E42  2  20 CD 88             JSR     NEWLINE
008E45  2               
008E45  2               ;
008E45  2  48 8A 48 A8          PRTS    " IO=0x$"
008E49  2  48 A2 00 BD  
008E4D  2  62 8E E8 C9  
008E69  2  A9 03                LDA     #>DSKY_PPI      ; GET BASE PORT
008E6B  2  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008E6E  2  A9 60                LDA     #<DSKY_PPI      ; GET BASE PORT
008E70  2  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008E73  2  48 8A 48 A8          PRTS    " MODE=$"
008E77  2  48 A2 00 BD  
008E7B  2  90 8E E8 C9  
008E97  2  48 8A 48 A8          PRTS    "NG$"           ; PRINT DSKY TYPE
008E9B  2  48 A2 00 BD  
008E9F  2  B4 8E E8 C9  
008EB7  2               ;
008EB7  2  AD 43 06             LDA     DSKY_PRESENT    ; PRESENT?
008EBA  2  C9 FF                CMP     #$FF            ; SET FLAGS
008EBC  2  F0 2A                BEQ     DSKY_INITA
008EBE  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
008EC2  2  48 A2 00 BD  
008EC6  2  DB 8E E8 C9  
008EE8  2               DSKY_INITA:
008EE8  2  20 CD 88             JSR     NEWLINE
008EEB  2  60                   RTS                     ; DONE
008EEC  2               ;
008EEC  2               ;__DSKY_PREINIT______________________________________________________________________________________
008EEC  2               ;
008EEC  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
008EEC  2               ;____________________________________________________________________________________________________
008EEC  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
008EEC  2               DSKY_PREINIT:
008EEC  2               ; CHECK FOR PPI
008EEC  2  20 31 8F             JSR     DSKY_PPIDETECT  ; TEST FOR PPI HARDWARE
008EEF  2  D0 2A                BNE     DSKY_ABORT      ; BAIL OUT IF NOT THERE
008EF1  2               
008EF1  2               ; SETUP PPI TO DEFAULT MODE
008EF1  2  20 2A 91             JSR     DSKY_PPIRD
008EF4  2               ; INIT 8279 VALUES TO IDLE STATE
008EF4  2  A9 06                LDA     #DSKY_PPI_IDLE
008EF6  2  8D 62 03             STA     DSKY_PPIC
008EF9  2               ; PULSE RESET SIGNAL ON 8279
008EF9  2  09 80                ORA     #%10000000
008EFB  2  8D 62 03             STA     DSKY_PPIC
008EFE  2  29 7F                AND     #%01111111
008F00  2  8D 62 03             STA     DSKY_PPIC
008F03  2               ; INITIALIZE 8279
008F03  2  20 1C 8F             JSR     DSKY_REINIT
008F06  2               ; NOW SEE IF A DSKYNG IS REALLY THERE...
008F06  2  A9 A5                LDA     #$A5
008F08  2  A0 00                LDY     #$00
008F0A  2  20 7F 90             JSR     DSKY_PUTBYTE
008F0D  2  A0 00                LDY     #$00
008F0F  2  20 9B 90             JSR     DSKY_GETBYTE
008F12  2  C9 A5                CMP     #$A5
008F14  2  D0 05                BNE     DSKY_ABORT      ; BAIL OUT IF MISCOMPARE
008F16  2  A9 FF                LDA     #$FF
008F18  2  8D 43 06             STA     DSKY_PRESENT
008F1B  2               DSKY_ABORT:
008F1B  2  60                   RTS
008F1C  2               ;
008F1C  2               DSKY_REINIT:
008F1C  2  20 3C 91             JSR     DSKY_PPIIDLE
008F1F  2               ; SET CLOCK SCALER TO 20
008F1F  2  A9 2A                LDA     #DSKY_CMD_CLK | DSKY_PRESCL
008F21  2  20 FF 8F             JSR     DSKY_CMD
008F24  2               ; FALL THRU
008F24  2               ;
008F24  2               DSKY_RESET:
008F24  2               ; RESET DSKY -- CLEAR RAM AND FIFO
008F24  2  A9 DF                LDA     #DSKY_CMD_CLR
008F26  2  20 FF 8F             JSR     DSKY_CMD
008F29  2               ;
008F29  2               ; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
008F29  2               ; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
008F29  2               ; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
008F29  2               ; IS USED TO IMPLEMENT A TIMEOUT.
008F29  2  A2 00                LDX     #0              ; TIMEOUT LOOP COUNTER
008F2B  2               DSKY_RESET1:
008F2B  2  48                   PHA                     ; SAVE COUNTER
008F2C  2  68                   PLA                     ; RECOVER COUNTER
008F2D  2  CA                   DEX
008F2E  2  D0 FB                BNE     DSKY_RESET1     ; LOOP TILL TIMEOUT
008F30  2               ;
008F30  2               DSKY_RESET2:
008F30  2  60                   RTS
008F31  2               ;
008F31  2               ;
008F31  2               ;
008F31  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
008F31  2               ;
008F31  2               ;  PROBE FOR PPI HARDWARE
008F31  2               ;____________________________________________________________________________________________________
008F31  2               ;
008F31  2               DSKY_PPIDETECT:
008F31  2               ;
008F31  2               ; TEST FOR PPI EXISTENCE
008F31  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008F31  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008F31  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008F31  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008F31  2               ; INTERFERE WITH THE VALUE BEING READ.
008F31  2  20 13 91             JSR     DSKY_PPIWR
008F34  2               ;
008F34  2  A9 00                LDA     #$00            ; VALUE ZERO
008F36  2  8D 60 03             STA     DSKY_PPIA       ; PUSH VALUE TO PORT
008F39  2  AD 60 03             LDA     DSKY_PPIA       ; GET PORT VALUE
008F3C  2  C9 00                CMP     #$00
008F3E  2  60                   RTS                     ; AND RETURN
008F3F  2               ;
008F3F  2               ;
008F3F  2               KY_0            = $00
008F3F  2               KY_1            = $01
008F3F  2               KY_2            = $02
008F3F  2               KY_3            = $03
008F3F  2               KY_4            = $04
008F3F  2               KY_5            = $05
008F3F  2               KY_6            = $06
008F3F  2               KY_7            = $07
008F3F  2               KY_8            = $08
008F3F  2               KY_9            = $09
008F3F  2               KY_A            = $0A
008F3F  2               KY_B            = $0B
008F3F  2               KY_C            = $0C
008F3F  2               KY_D            = $0D
008F3F  2               KY_E            = $0E
008F3F  2               KY_F            = $0F
008F3F  2               KY_FW           = $10           ; FORWARD
008F3F  2               KY_BK           = $11           ; BACKWARD
008F3F  2               KY_CL           = $12           ; CLEAR
008F3F  2               KY_EN           = $13           ; ENTER
008F3F  2               KY_DE           = $14           ; DEPOSIT
008F3F  2               KY_EX           = $15           ; EXAMINE
008F3F  2               KY_GO           = $16           ; GO
008F3F  2               KY_BO           = $17           ; BOOT
008F3F  2               KY_F4           = $18           ; F4
008F3F  2               KY_F3           = $19           ; F3
008F3F  2               KY_F2           = $20           ; F2
008F3F  2               KY_F1           = $21           ; F1
008F3F  2               ;
008F3F  2               ;__DSKY_STAT_________________________________________________________________________________________
008F3F  2               ;
008F3F  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
008F3F  2               ;____________________________________________________________________________________________________
008F3F  2               ;
008F3F  2               DSKY_STAT:
008F3F  2  AD 43 06             LDA     DSKY_PRESENT    ; DOES IT EXIST?
008F42  2  C9 FF                CMP     #$FF            ; SET FLAGS
008F44  2  D0 05                BNE     DSKY_STATA      ; ABORT WITH A=0 IF NOT THERE
008F46  2  20 38 90             JSR     DSKY_ST
008F49  2  29 0F                AND     #$0F            ; ISOLATE THE CUR FIFO LEN
008F4B  2               DSKY_STATA:
008F4B  2  60                   RTS
008F4C  2               ;
008F4C  2               ;__DSKY_GETKEY_____________________________________________________________________________________
008F4C  2               ;
008F4C  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
008F4C  2               ;____________________________________________________________________________________________________
008F4C  2               ;
008F4C  2               DSKY_GETKEY:
008F4C  2  AD 43 06             LDA     DSKY_PRESENT    ; DOES IT EXIST?
008F4F  2  C9 FF                CMP     #$FF            ; SET FLAGS
008F51  2  D0 24                BNE     DSKY_GETKEY1A   ; ABORT WITH A=0 IF NOT THERE
008F53  2  20 3F 8F             JSR     DSKY_STAT
008F56  2  F0 F4                BEQ     DSKY_GETKEY     ; LOOP IF NOTHING THERE
008F58  2  A9 40                LDA     #DSKY_CMD_FIFO
008F5A  2  20 FF 8F             JSR     DSKY_CMD
008F5D  2  20 3D 90             JSR     DSKY_DIN
008F60  2  49 C0                EOR     #%11000000      ; FLIP POLARITY OF SHIFT/CTL BITS
008F62  2  48                   PHA
008F63  2  29 3F                AND     #$3F            ; STRIP SHIFT/CTL BITS FOR LOOKUP
008F65  2  8D 40 06             STA     DSKY_TEMP_VAL
008F68  2  A2 00                LDX     #0              ; INDEX
008F6A  2               DSKY_GETKEY1:
008F6A  2  BD 86 8F             LDA     DSKY_KEYMAP,X
008F6D  2  CD 40 06             CMP     DSKY_TEMP_VAL   ; MATCH?
008F70  2  F0 09                BEQ     DSKY_GETKEY2    ; FOUND, DONE
008F72  2  E8                   INX
008F73  2  E0 1C                CPX     #28
008F75  2  D0 F3                BNE     DSKY_GETKEY1    ; LOOP UNTIL EOT
008F77  2               DSKY_GETKEY1A:
008F77  2  68                   PLA
008F78  2  A9 FF                LDA     #$FF            ; NOT FOUND ERR, RETURN $FF
008F7A  2  60                   RTS
008F7B  2               DSKY_GETKEY2:
008F7B  2               ; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
008F7B  2               ; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
008F7B  2  68                   PLA                     ; RESTORE RAW VALUE
008F7C  2  25 C0                AND     %11000000       ; ISOLATE SHIFT/CTRL BITS
008F7E  2  8D 40 06             STA     DSKY_TEMP_VAL
008F81  2  8A                   TXA
008F82  2  0D 40 06             ORA     DSKY_TEMP_VAL   ; COMBINE WITH INDEX VALUE
008F85  2  60                   RTS
008F86  2               ;
008F86  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
008F86  2               ;
008F86  2               DSKY_KEYMAP:
008F86  2               ; POS	$00  $01  $02  $03  $04  $05  $06  $07
008F86  2               ; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
008F86  2  0D 04 0C 14          .BYTE   $0D, $04, $0C, $14, $03, $0B, $13, $02
008F8A  2  03 0B 13 02  
008F8E  2               ;
008F8E  2               ; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
008F8E  2               ; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
008F8E  2  0A 12 01 09          .BYTE   $0A, $12, $01, $09, $11, $00, $08, $10
008F92  2  11 00 08 10  
008F96  2               ;
008F96  2               ; POS	$10  $11  $12  $13  $14  $15  $16  $17
008F96  2               ; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
008F96  2  05 15 1D 1C          .BYTE   $05, $15, $1D, $1C, $1B, $1A, $19, $18
008F9A  2  1B 1A 19 18  
008F9E  2               
008F9E  2               ; POS	$18  $19  $20  $21
008F9E  2               ; KEY   [F4] [F3] [F2] [F1]
008F9E  2  23 22 21 20          .BYTE   $23, $22, $21, $20
008FA2  2               
008FA2  2               ;
008FA2  2               ;
008FA2  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
008FA2  2               ;
008FA2  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
008FA2  2               ;
008FA2  2               ; DSKY_BUF: 32 BIT BINARY
008FA2  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
008FA2  2               ;____________________________________________________________________________________________________
008FA2  2               ;
008FA2  2               DSKY_BIN2SEG:
008FA2  2  A2 00                LDX     #$00
008FA4  2               DSKY_BIN2SEG1:
008FA4  2  BD 08 06             LDA     DSKY_HEXBUF,X   ; FIRST NIBBLE
008FA7  2  4A                   LSR     A
008FA8  2  4A                   LSR     A
008FA9  2  4A                   LSR     A
008FAA  2  4A                   LSR     A
008FAB  2  8E 35 06             STX     STACKA          ; STORE READ INDEX
008FAE  2  AA                   TAX                     ; MOVE DIGIT TO LOOKUP INDEX
008FAF  2  BD 3F 91             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
008FB2  2  AE 35 06             LDX     STACKA          ; GET READ INDEX
008FB5  2  48                   PHA
008FB6  2  8A                   TXA
008FB7  2  0A                   ASL     a
008FB8  2  AA                   TAX
008FB9  2  68                   PLA
008FBA  2  9D 00 06             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
008FBD  2  AE 35 06             LDX     STACKA          ; GET READ INDEX
008FC0  2  BD 08 06             LDA     DSKY_HEXBUF,X   ; SECOND NIBBLE
008FC3  2               
008FC3  2  29 0F                AND     #$0F
008FC5  2  8E 35 06             STX     STACKA          ; STORE READ INDEX
008FC8  2  AA                   TAX
008FC9  2  BD 3F 91             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
008FCC  2  AE 35 06             LDX     STACKA          ; GET READ INDEX
008FCF  2  48                   PHA
008FD0  2  8A                   TXA                     ; GET READ INDEX
008FD1  2  0A                   ASL     a
008FD2  2  AA                   TAX
008FD3  2  E8                   INX
008FD4  2  68                   PLA
008FD5  2  9D 00 06             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
008FD8  2  AE 35 06             LDX     STACKA          ; GET READ INDEX
008FDB  2  E8                   INX
008FDC  2  E0 04                CPX     #4
008FDE  2  D0 C4                BNE     DSKY_BIN2SEG1
008FE0  2  60                   RTS
008FE1  2               ;
008FE1  2               ;__DSKY_SHOW___________________________________________________________________________________________
008FE1  2               ; DSKY SHOW BUFFER
008FE1  2               ;______________________________________________________________________________________________________
008FE1  2               ;
008FE1  2               DSKY_SHOW:
008FE1  2  48                   PHA
008FE2  2  8A                   TXA
008FE3  2  48                   PHA
008FE4  2  98                   TYA
008FE5  2  48                   PHA
008FE6  2  A2 00                LDX     #0
008FE8  2               DSKY_SHOW1:
008FE8  2  BD 00 06             LDA     DSKY_BUF,X
008FEB  2  8E 35 06             STX     STACKA
008FEE  2  AC 35 06             LDY     STACKA
008FF1  2  20 7F 90             JSR     DSKY_PUTBYTE
008FF4  2  E8                   INX
008FF5  2  E0 08                CPX     #8
008FF7  2  D0 EF                BNE     DSKY_SHOW1
008FF9  2  68                   PLA
008FFA  2  A8                   TAY
008FFB  2  68                   PLA
008FFC  2  AA                   TAX
008FFD  2  68                   PLA
008FFE  2  60                   RTS
008FFF  2               
008FFF  2               ;______________________________________________________________________________________________________
008FFF  2               ; DSKYNG OUTPUT ROUTINES
008FFF  2               ;______________________________________________________________________________________________________
008FFF  2               
008FFF  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
008FFF  2               DSKY_CMD:
008FFF  2  48                   PHA
009000  2  A9 01                LDA     #$01
009002  2  4C 08 90             JMP     DSKY_DOUT2
009005  2               ;
009005  2               ; SEND DSKY DATA BYTE IN REGISTER A
009005  2               ; TRASHES BC
009005  2               ;
009005  2               DSKY_DOUT:
009005  2  48                   PHA
009006  2  A9 00                LDA     #$00
009008  2               ;
009008  2               DSKY_DOUT2:
009008  2               ; SET PPI LINE CONFIG TO WRITE MODE
009008  2  20 13 91             JSR     DSKY_PPIWR
00900B  2               ;
00900B  2               ; SET ADDRESS FIRST
00900B  2  09 06                ORA     #DSKY_PPI_IDLE
00900D  2  8D 62 03             STA     DSKY_PPIC
009010  2               ;
009010  2               ; ASSERT 8279 /CS
009010  2  09 18                ORA     #%00011000
009012  2  8D 62 03             STA     DSKY_PPIC
009015  2               ;
009015  2               ; PPIC WORKING VALUE TO DSKY_TEMP_VAL
009015  2  8D 40 06             STA     DSKY_TEMP_VAL
009018  2               ;
009018  2               ; ASSERT DATA BYTE VALUE
009018  2  68                   PLA
009019  2  8D 60 03             STA     DSKY_PPIA
00901C  2               ;
00901C  2               ; PULSE /WR
00901C  2  AD 40 06             LDA     DSKY_TEMP_VAL
00901F  2  29 FD                AND     #%11111101
009021  2  8D 62 03             STA     DSKY_PPIC
009024  2  EA                   NOP                     ; MAY NOT BE NEEDED
009025  2  09 02                ORA     #%00000010
009027  2  8D 62 03             STA     DSKY_PPIC
00902A  2               ;
00902A  2               ; DEASSERT /CS
00902A  2  29 E7                AND     #%11100111
00902C  2  8D 62 03             STA     DSKY_PPIC
00902F  2               ;
00902F  2               ; CLEAR ADDRESS BIT
00902F  2  29 E6                AND     #%11100110
009031  2  8D 62 03             STA     DSKY_PPIC
009034  2               ;
009034  2               ; DONE
009034  2  20 3C 91             JSR     DSKY_PPIIDLE
009037  2  60                   RTS
009038  2               ;
009038  2               ;==================================================================================================
009038  2               ; DSKYNG OUTPUT ROUTINES
009038  2               ;==================================================================================================
009038  2               ;
009038  2               ; RETURN DSKY STATUS VALUE IN A
009038  2               ;
009038  2               DSKY_ST:
009038  2  A9 01                LDA     #$01
00903A  2  4C 3F 90             JMP     DSKY_DIN2
00903D  2               ;
00903D  2               ; RETURN NEXT DATA VALUE IN A
00903D  2               ;
00903D  2               DSKY_DIN:
00903D  2  A9 00                LDA     #$00
00903F  2               ;
00903F  2               DSKY_DIN2:
00903F  2               ; SET PPI LINE CONFIG TO READ MODE
00903F  2  20 2A 91             JSR     DSKY_PPIRD
009042  2               ;
009042  2               ; SET ADDRESS FIRST
009042  2  09 06                ORA     #DSKY_PPI_IDLE
009044  2  8D 62 03             STA     DSKY_PPIC
009047  2               ;
009047  2               ; ASSERT 8279 /CS
009047  2  09 18                ORA     #%00011000
009049  2  8D 62 03             STA     DSKY_PPIC
00904C  2               ;
00904C  2               ; ASSERT /RD
00904C  2  29 7B                AND     #%01111011
00904E  2  8D 62 03             STA     DSKY_PPIC
009051  2               ;
009051  2  8D 40 06             STA     DSKY_TEMP_VAL
009054  2               ; GET VALUE
009054  2  AD 60 03             LDA     DSKY_PPIA
009057  2  48                   PHA
009058  2               
009058  2  AD 40 06             LDA     DSKY_TEMP_VAL
00905B  2               ; DEASSERT /RD
00905B  2  09 04                ORA     #%00000100
00905D  2  8D 62 03             STA     DSKY_PPIC
009060  2               ;
009060  2               ; DEASSERT /CS
009060  2  29 E7                AND     #%11100111
009062  2  8D 62 03             STA     DSKY_PPIC
009065  2               ;
009065  2               ; CLEAR ADDRESS BIT
009065  2  29 E6                AND     #%11100110
009067  2  8D 62 03             STA     DSKY_PPIC
00906A  2               ;
00906A  2               ; DONE
00906A  2  20 3C 91             JSR     DSKY_PPIIDLE
00906D  2  68                   PLA
00906E  2  60                   RTS
00906F  2               
00906F  2               ;__DSKY_BLANK_____________________________________________________________________________________
00906F  2               ;
00906F  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
00906F  2               ;
00906F  2               ;_________________________________________________________________________________________________
00906F  2               ;
00906F  2               DSKY_BLANK:
00906F  2  A9 90                LDA     #DSKY_CMD_WDSP
009071  2  20 FF 8F             JSR     DSKY_CMD
009074  2  A2 10                LDX     #16
009076  2               DSKY_BLANK1:
009076  2  A9 FF                LDA     #$FF
009078  2  20 05 90             JSR     DSKY_DOUT
00907B  2  CA                   DEX
00907C  2  D0 F8                BNE     DSKY_BLANK1
00907E  2  60                   RTS
00907F  2               ;
00907F  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
00907F  2               ;
00907F  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
00907F  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
00907F  2               ;
00907F  2               ;__________________________________________________________________________________________________
00907F  2               ;
00907F  2               DSKY_PUTBYTE:
00907F  2  8D 35 06             STA     STACKA
009082  2  48                   PHA
009083  2  98                   TYA
009084  2  48                   PHA
009085  2  AD 35 06             LDA     STACKA
009088  2  48                   PHA
009089  2  18                   CLC
00908A  2  98                   TYA
00908B  2  69 90                ADC     #DSKY_CMD_WDSP
00908D  2  A8                   TAY
00908E  2  20 FF 8F             JSR     DSKY_CMD
009091  2  68                   PLA
009092  2  49 FF                EOR     #$FF
009094  2  20 05 90             JSR     DSKY_DOUT
009097  2  68                   PLA
009098  2  A8                   TAY
009099  2  68                   PLA
00909A  2  60                   RTS
00909B  2               ;
00909B  2               ;__DSKY_GETBYTE___________________________________________________________________________________
00909B  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
00909B  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
00909B  2               ;
00909B  2               ;_________________________________________________________________________________________________
00909B  2               ;
00909B  2               DSKY_GETBYTE:
00909B  2  18                   CLC
00909C  2  98                   TYA
00909D  2  69 70                ADC     #DSKY_CMD_RDSP
00909F  2  A8                   TAY
0090A0  2  20 FF 8F             JSR     DSKY_CMD
0090A3  2  20 3D 90             JSR     DSKY_DIN
0090A6  2  49 FF                EOR     #$FF
0090A8  2  60                   RTS
0090A9  2               
0090A9  2               ;
0090A9  2               ;__DSKY_PUTLED____________________________________________________________________________________
0090A9  2               ;
0090A9  2               ;	This function is intended to update the LEDs.
0090A9  2               ;	VALUES SHOULD BE IN DSKY_BUF
0090A9  2               ;_________________________________________________________________________________________________
0090A9  2               ;
0090A9  2               DSKY_PUTLED:
0090A9  2  48                   PHA
0090AA  2  8A                   TXA
0090AB  2  48                   PHA
0090AC  2  98                   TYA
0090AD  2  48                   PHA
0090AE  2  A0 00                LDY     #$00
0090B0  2  A2 00                LDX     #$00
0090B2  2               DSKY_PUTLED_1:
0090B2  2  BD 00 06             LDA     DSKY_BUF,X      ; GET BYTE
0090B5  2  20 7F 90             JSR     DSKY_PUTBYTE    ; SEND IT TO DSKY
0090B8  2  C8                   INY                     ; LOOP TIL DONE
0090B9  2  E8                   INX
0090BA  2  C0 08                CPY     #8
0090BC  2  D0 F4                BNE     DSKY_PUTLED_1
0090BE  2  68                   PLA                     ; RESTORE REGISTERS
0090BF  2  A8                   TAY
0090C0  2  68                   PLA
0090C1  2  AA                   TAX
0090C2  2  68                   PLA
0090C3  2  60                   RTS
0090C4  2               ;
0090C4  2               ;__DSKY_BEEP______________________________________________________________________________________
0090C4  2               ;	This function is intended to beep the speaker on the DSKY
0090C4  2               ;_________________________________________________________________________________________________
0090C4  2               ;
0090C4  2               DSKY_BEEP:
0090C4  2  48                   PHA
0090C5  2  8A                   TXA
0090C6  2  48                   PHA
0090C7  2  98                   TYA
0090C8  2  48                   PHA
0090C9  2               
0090C9  2  A0 0F                LDY     #$0F
0090CB  2  20 9B 90             JSR     DSKY_GETBYTE
0090CE  2  09 20                ORA     #$20
0090D0  2  A9 20                LDA     #$20
0090D2  2  A0 0F                LDY     #$0F
0090D4  2  20 7F 90             JSR     DSKY_PUTBYTE
0090D7  2               
0090D7  2               ;;; 	timer . . .
0090D7  2  A2 8F                LDX     #$8F
0090D9  2  A0 FF                LDY     #$FF
0090DB  2               DSKY_BEEP1:
0090DB  2  88                   DEY
0090DC  2  D0 FD                BNE     DSKY_BEEP1
0090DE  2  CA                   DEX
0090DF  2  D0 FA                BNE     DSKY_BEEP1
0090E1  2               
0090E1  2  A0 0F                LDY     #$0F
0090E3  2  20 9B 90             JSR     DSKY_GETBYTE
0090E6  2  29 DF                AND     #$DF
0090E8  2  A9 DF                LDA     #$DF
0090EA  2  A0 0F                LDY     #$0F
0090EC  2  20 7F 90             JSR     DSKY_PUTBYTE
0090EF  2               
0090EF  2  68                   PLA                     ; RESTORE REGISTERS
0090F0  2  A8                   TAY
0090F1  2  68                   PLA
0090F2  2  AA                   TAX
0090F3  2  68                   PLA
0090F4  2  60                   RTS
0090F5  2               ;___DSKYNG_DSPL______________________________________________________________________________________
0090F5  2               ;
0090F5  2               ;	This function is intended to turn on or off the DSKY L1 & L2 leds
0090F5  2               ;
0090F5  2               ;   A= LED# (0 or 1)
0090F5  2               ;   X= On(1) or Off(0)
0090F5  2               ;_________________________________________________________________________________________________
0090F5  2               ;
0090F5  2               DSKY_DSPL:
0090F5  2  8C 3F 06             STY     DSKY_Y_STORAGE
0090F8  2  18                   CLC
0090F9  2  29 01                AND     #$01
0090FB  2  69 0D                ADC     #$0D
0090FD  2  A8                   TAY
0090FE  2  20 9B 90             JSR     DSKY_GETBYTE
009101  2  E0 00                CPX     #$00
009103  2  F0 05                BEQ     :+
009105  2  09 20                ORA     #$20
009107  2  4C 0C 91             JMP     DSKY_DSPL_1
00910A  2               :
00910A  2  29 DF                AND     #$DF
00910C  2               DSKY_DSPL_1:
00910C  2  20 7F 90             JSR     DSKY_PUTBYTE
00910F  2  AC 3F 06             LDY     DSKY_Y_STORAGE
009112  2  60                   RTS
009113  2               
009113  2               ;
009113  2               ;_________________________________________________________________________________________________
009113  2               ; DSKYNG LINE CONTROL ROUTINES
009113  2               ;
009113  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
009113  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
009113  2               ;
009113  2               ;_________________________________________________________________________________________________
009113  2               ;
009113  2               DSKY_PPIWR:
009113  2  48                   PHA
009114  2               ;
009114  2               ; CHECK FOR WRITE MODE
009114  2  AD 41 06             LDA     DSKY_PPIX_VAL
009117  2  C9 82                CMP     #DSKY_PPIX_WR
009119  2  F0 0D                BEQ     DSKY_PPIWR1
00911B  2               ;
00911B  2               ; SET PPI TO WRITE MODE
00911B  2  A9 82                LDA     #DSKY_PPIX_WR
00911D  2  8D 63 03             STA     DSKY_PPIX
009120  2  8D 41 06             STA     DSKY_PPIX_VAL
009123  2               ;
009123  2               ; RESTORE PORT C (MAY NOT BE NEEDED)
009123  2  A9 06                LDA     #DSKY_PPI_IDLE
009125  2  8D 62 03             STA     DSKY_PPIC
009128  2               ;
009128  2               DSKY_PPIWR1:
009128  2               ;
009128  2  68                   PLA
009129  2  60                   RTS
00912A  2               ;
00912A  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
00912A  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
00912A  2               ;
00912A  2               DSKY_PPIRD:
00912A  2  48                   PHA
00912B  2               ;
00912B  2               ; CHECK FOR READ MODE
00912B  2  AD 41 06             LDA     DSKY_PPIX_VAL
00912E  2  C9 92                CMP     #DSKY_PPIX_RD
009130  2  F0 08                BEQ     DSKY_PPIRD1
009132  2               ;
009132  2               ; SET PPI TO READ MODE
009132  2  A9 92                LDA     #DSKY_PPIX_RD
009134  2  8D 63 03             STA     DSKY_PPIX
009137  2  8D 41 06             STA     DSKY_PPIX_VAL
00913A  2               ;
00913A  2               DSKY_PPIRD1:
00913A  2  68                   PLA
00913B  2  60                   RTS
00913C  2               ;
00913C  2               ; RELEASE USE OF PPI
00913C  2               ;
00913C  2               DSKY_PPIIDLE:
00913C  2  4C 2A 91             JMP     DSKY_PPIRD      ; SAME AS READ MODE
00913F  2               ;
00913F  2               ;__STORAGE_________________________________________________________________________________________
00913F  2               ; CODES FOR NUMERICS
00913F  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
00913F  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
00913F  2               ;_________________________________________________________________________________________________
00913F  2               ;
00913F  2               DSKY_HEXMAP:
00913F  2  3F                   .BYTE   $3F             ; 0
009140  2  06                   .BYTE   $06             ; 1
009141  2  5B                   .BYTE   $5B             ; 2
009142  2  4F                   .BYTE   $4F             ; 3
009143  2  66                   .BYTE   $66             ; 4
009144  2  6D                   .BYTE   $6D             ; 5
009145  2  7D                   .BYTE   $7D             ; 6
009146  2  07                   .BYTE   $07             ; 7
009147  2  7F                   .BYTE   $7F             ; 8
009148  2  67                   .BYTE   $67             ; 9
009149  2  77                   .BYTE   $77             ; A
00914A  2  7C                   .BYTE   $7C             ; B
00914B  2  39                   .BYTE   $39             ; C
00914C  2  5E                   .BYTE   $5E             ; D
00914D  2  79                   .BYTE   $79             ; E
00914E  2  71                   .BYTE   $71             ; F
00914F  2               
00914F  1                       .INCLUDE "dosmd.asm"
00914F  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
00914F  2               ;
00914F  2               ; 	Nhyodyne Memory disk drivers
00914F  2               ;
00914F  2               ;	Entry points:
00914F  2               ;		MD_SHOW         - called during OS init
00914F  2               ;		MD_READ_SECTOR  - read a sector from drive
00914F  2               ;		MD_WRITE_SECTOR - write a sector to drive
00914F  2               ;________________________________________________________________________________________________________________________________
00914F  2               ;
00914F  2               ; RAM BANK $0C is RAM area for Drivers
00914F  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00914F  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
00914F  2               ;
00914F  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00914F  2               ;
00914F  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00914F  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00914F  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00914F  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00914F  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00914F  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00914F  2               ;
00914F  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00914F  2               ;
00914F  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00914F  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00914F  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00914F  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00914F  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00914F  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00914F  2               
00914F  2               
00914F  2               ;__MD_SHOW___________________________________________________________________________________________
00914F  2               ;
00914F  2               ;  Display info on MD devices
00914F  2               ;____________________________________________________________________________________________________
00914F  2               ;
00914F  2               MD_SHOW:
00914F  2                       PRTDBG  "MD INIT:$"
00914F  2  48 8A 48 A8          PRTS    "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
009153  2  48 A2 00 BD  
009157  2  6C 91 E8 C9  
009194  2  20 CD 88             JSR     NEWLINE
009197  2  60                   RTS
009198  2               
009198  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
009198  2               ;*
009198  2               ;*  READ MD SECTOR INTO BUFFER
009198  2               ;*
009198  2               ;*____________________________________________________________________________________________________
009198  2               MD_READ_SECTOR:
009198  2                       PRTDBG  "MD Read Sector$"
009198  2  AD 28 06             LDA     DSKUNIT
00919B  2  29 01                AND     #$01            ; only want drive cfg
00919D  2  0A                   ASL     a               ; SHIFT 6
00919E  2  0A                   ASL     a               ;
00919F  2  0A                   ASL     a               ;
0091A0  2  0A                   ASL     a               ;
0091A1  2  0A                   ASL     a               ;
0091A2  2  0A                   ASL     a               ;
0091A3  2  29 5F                AND     #%01011111      ; TOGGLE READ
0091A5  2  AA                   TAX                     ; STASH CONTROL WORD
0091A6  2  20 E5 91             JSR     MD_CONVERT_SECTOR
0091A9  2  8A                   TXA
0091AA  2  29 40                AND     #%01000000
0091AC  2  C9 00                CMP     #$00            ; read if ram
0091AE  2  F0 0C                BEQ     :+
0091B0  2  EE 10 06             INC     debcyll         ; if rom, inc bank by 4 ()
0091B3  2  EE 10 06             INC     debcyll
0091B6  2  EE 10 06             INC     debcyll
0091B9  2  EE 10 06             INC     debcyll
0091BC  2               :
0091BC  2  AD 10 06             LDA     debcyll         ; GET BANK
0091BF  2  AC 12 06             LDY     debsehd         ; GET PAGE
0091C2  2                       PRTDBG  "DO PAGER RD$"
0091C2  2  20 00 02             JSR     MD_PAGERA
0091C5  2                       PRTDBG  "PAGER RETURN$"
0091C5  2  A9 00                LDA     #$00
0091C7  2  60                   RTS
0091C8  2               
0091C8  2               
0091C8  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
0091C8  2               ;*
0091C8  2               ;*  WRITE MD SECTOR FROM BUFFER
0091C8  2               ;*
0091C8  2               ;*____________________________________________________________________________________________________
0091C8  2               MD_WRITE_SECTOR:
0091C8  2                       PRTDBG  "MD Write Sector$"
0091C8  2  AD 28 06             LDA     DSKUNIT
0091CB  2  29 01                AND     #$01            ; only want drive cfg
0091CD  2  C9 00                CMP     #$00            ; NO WRITE FOR ROM
0091CF  2  F0 03                BEQ     MD_WRITE_SECTOR_RAM
0091D1  2  A9 FF                LDA     #$FF
0091D3  2  60                   RTS
0091D4  2               MD_WRITE_SECTOR_RAM:
0091D4  2  20 E5 91             JSR     MD_CONVERT_SECTOR
0091D7  2  A2 20                LDX     #%00100000      ; TOGGLE WRITE RAM (LO)
0091D9  2  AD 10 06             LDA     debcyll         ; GET BANK
0091DC  2  AC 12 06             LDY     debsehd         ; GET PAGE
0091DF  2                       PRTDBG  "DO PAGER WR$"
0091DF  2  20 00 02             JSR     MD_PAGERA
0091E2  2                       PRTDBG  "PAGER RETURN$"
0091E2  2  A9 00                LDA     #$00
0091E4  2  60                   RTS
0091E5  2               
0091E5  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
0091E5  2               ;
0091E5  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
0091E5  2               ;________________________________________________________________________________________________________
0091E5  2               MD_CONVERT_SECTOR:
0091E5  2                       PRTDBG  "CONVERT SECTOR$"
0091E5  2  48                   PHA
0091E6  2  8A                   TXA
0091E7  2  48                   PHA
0091E8  2  AD 0E 06             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
0091EB  2  4A                   LSR     A               ; DIVIDE BY 2 (FOR BLOCKING)
0091EC  2  29 1E                AND     #$1E            ; CLEAR UPPER 3 BITS AND ALWAYS GET EVENS (TO MAKE DEBLOCKING WORK PROPERLY)
0091EE  2  8D 12 06             STA     debsehd         ; STORE IN SECTOR/HEAD
0091F1  2  AD 0C 06             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0091F4  2  29 03                AND     #$03            ; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
0091F6  2  0A                   ASL     a               ; MOVE TO HIGH BITS
0091F7  2  0A                   ASL     a
0091F8  2  0A                   ASL     a
0091F9  2  0A                   ASL     a
0091FA  2  0A                   ASL     a
0091FB  2  09 80                ORA     #$80            ; PAGES ARE ALWAYS IN UPPER BANK
0091FD  2  0D 12 06             ORA     debsehd         ; STORE IN SECTOR/HEAD
009200  2  8D 12 06             STA     debsehd         ; STORE IN SECTOR/HEAD
009203  2                                               ; AT THIS POINT PAGE REGISTER SHOULD BE
009203  2                                               ; SET
009203  2  AD 0C 06             LDA     sektrk          ; LOAD TRACK #
009206  2  4A                   LSR     a               ; LOSE BOTTOM TWO BITS
009207  2  4A                   LSR     a
009208  2  8D 10 06             STA     debcyll         ; THIS SHOULD BE BANK#
00920B  2               
00920B  2  68                   PLA
00920C  2  AA                   TAX
00920D  2  68                   PLA
00920E  2  60                   RTS
00920F  2               
00920F  1                       .INCLUDE "dosflp.asm"
00920F  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
00920F  2               ;
00920F  2               ; 	DOS/65 floppy drivers for MBC FDC card
00920F  2               ;
00920F  2               ;	Entry points:
00920F  2               ;		FL_SETUP        - called during OS init
00920F  2               ;		FL_READ_SECTOR	- read a sector from drive
00920F  2               ;		FL_WRITE_SECTOR	- write a sector to drive
00920F  2               ;
00920F  2               ;________________________________________________________________________________________________________________________________
00920F  2               ;
00920F  2               ;*
00920F  2               ;* HARDWARE I/O ADDRESSES
00920F  2               ;*
00920F  2               FDC_MSR         = $0330         ; ADDRESS OF MAIN STATUS REGISTER
00920F  2               FDC_DATA        = $0331         ; FLOPPY DATA REGISTER
00920F  2               FDC_RESET       = $0333         ; FLOPPY RESET
00920F  2               FDC_DCR         = $0335         ; LOAD CONTROL REGISTER
00920F  2               FDC_DOR         = $0336         ; CONFIGURATION CONTROL REGISTER
00920F  2               FDC_TC          = $0337         ; TERMINAL COUNT
00920F  2               
00920F  2               ;
00920F  2               ; FDC COMMANDS
00920F  2               ;
00920F  2               CFD_READ        = %00000110     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_READDEL     = %00001100     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_WRITE       = %00000101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_WRITEDEL    = %00001001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_READTRK     = %00000010     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_READID      = %00001010     ; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_FMTTRK      = %00001101     ; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_SCANEQ      = %00010001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_SCANLOEQ    = %00011001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_SCANHIEQ    = %00011101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
00920F  2               CFD_RECAL       = %00000111     ; CMD,DS --> <EMPTY>
00920F  2               CFD_SENSEINT    = %00001000     ; CMD --> ST0,PCN
00920F  2               CFD_SPECIFY     = %00000011     ; CMD,SRT/HUT,HLT/ND --> <EMPTY>
00920F  2               CFD_DRVSTAT     = %00000100     ; CMD,HDS/DS --> ST3
00920F  2               CFD_SEEK        = %00001111     ; CMD,HDS/DS --> <EMPTY>
00920F  2               CFD_VERSION     = %00010000     ; CMD --> ST0
00920F  2               
00920F  2               CFD_MFM         = %01000000     ;
00920F  2               
00920F  2               ;
00920F  2               ;
00920F  2               ; Specify Command:
00920F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
00920F  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
00920F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
00920F  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
00920F  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
00920F  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
00920F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
00920F  2               ;
00920F  2               ;
00920F  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
00920F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
00920F  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
00920F  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
00920F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
00920F  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
00920F  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
00920F  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
00920F  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
00920F  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
00920F  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
00920F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
00920F  2               ;
00920F  2               ; IBM PS/2 CALLS FOR:
00920F  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
00920F  2               ;   HEAD LOAD TIME: 15ms
00920F  2               
00920F  2               DOR_INIT        = %00001100     ; SOFT RESET INACTIVE, DMA ENABLED
00920F  2               DOR_BR250       = DOR_INIT
00920F  2               DOR_BR500       = DOR_INIT
00920F  2               
00920F  2               
00920F  2               
00920F  2               FLOPPY_RETRIES  = 6             ; HOW ABOUT SIX RETIRES?
00920F  2               FLOPPY_RETRIES1 = 2             ; TWO ITERATIONS OF RECAL?
00920F  2               
00920F  2               ;__FL_SETUP______________________________________________________________________________________________________________________
00920F  2               ;
00920F  2               ;	SETUP FLOPPY DRIVE SETTINGS
00920F  2               ;________________________________________________________________________________________________________________________________
00920F  2               ;
00920F  2               FL_SETUP:
00920F  2  A9 00                LDA     #$00            ; RESET TRACK/CYL/SEC STORAGE
009211  2  8D 11 06             STA     debcylm         ;
009214  2  8D 10 06             STA     debcyll         ;
009217  2  8D 12 06             STA     debsehd         ;
00921A  2  A9 FF                LDA     #$FF            ; SET CACHE TO INVALID
00921C  2  8D 45 06             STA     Cdebcylm        ;
00921F  2  8D 44 06             STA     Cdebcyll        ;
009222  2  8D 46 06             STA     Cdebsehd        ;
009225  2               
009225  2  48 8A 48 A8          PRTS    "FD: MODE=MBC$"
009229  2  48 A2 00 BD  
00922D  2  42 92 E8 C9  
00924F  2               ;
00924F  2  48 8A 48 A8          PRTS    " IO=0x$"
009253  2  48 A2 00 BD  
009257  2  6C 92 E8 C9  
009273  2  A9 03                LDA     #>FDC_MSR
009275  2  20 A1 88             JSR     PRTHEXBYTE
009278  2  A9 30                LDA     #<FDC_MSR
00927A  2  20 A1 88             JSR     PRTHEXBYTE
00927D  2  20 ED 95             JSR     FD_DETECT       ; CHECK FOR FDC
009280  2  C9 00                CMP     #$00
009282  2  F0 30                BEQ     :+              ; CONTINUE IF FOUND
009284  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT ZERO, H/W NOT PRESENT
009288  2  48 A2 00 BD  
00928C  2  A1 92 E8 C9  
0092AE  2  20 CD 88             JSR     NEWLINE
0092B1  2  A9 FF                LDA     #$FF
0092B3  2  60                   RTS                     ; BAIL OUT
0092B4  2               :
0092B4  2  48 8A 48 A8          PRTS    " PRESENT$"     ; NOT ZERO, H/W NOT PRESENT
0092B8  2  48 A2 00 BD  
0092BC  2  D1 92 E8 C9  
0092DA  2  20 CD 88             JSR     NEWLINE
0092DD  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
0092DF  2  8D 36 03             STA     FDC_DOR
0092E2  2               
0092E2  2  20 8B 95             JSR     CHECKINT        ;
0092E5  2  A9 03                LDA     #CFD_SPECIFY    ; SPECIFY COMMAND
0092E7  2  20 47 95             JSR     PFDATA          ; OUTPUT TO FDC
0092EA  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
0092EC  2  20 47 95             JSR     PFDATA          ; OUTPUT TO FDC
0092EF  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
0092F1  2  20 47 95             JSR     PFDATA          ; OUTPUT TO FDC
0092F4  2               
0092F4  2  20 8B 95             JSR     CHECKINT        ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
0092F7  2  20 8B 95             JSR     CHECKINT        ;
0092FA  2  20 8B 95             JSR     CHECKINT        ;
0092FD  2  20 8B 95             JSR     CHECKINT        ;
009300  2  20 8B 95             JSR     CHECKINT        ;
009303  2  20 8B 95             JSR     CHECKINT        ;
009306  2               
009306  2  A9 00                LDA     #$00
009308  2  8D 16 06             STA     sekdsk
00930B  2  A9 10                LDA     #%00010000
00930D  2  8D 28 06             STA     DSKUNIT
009310  2  20 1C 95             JSR     RECAL           ;
009313  2  A9 27                LDA     #39             ;
009315  2  8D 10 06             STA     debcyll         ;
009318  2  20 FF 94             JSR     SETTRK1
00931B  2  20 1C 95             JSR     RECAL           ;
00931E  2               
00931E  2  A9 01                LDA     #$01
009320  2  8D 16 06             STA     sekdsk
009323  2  A9 21                LDA     #%00100001
009325  2  8D 28 06             STA     DSKUNIT
009328  2  20 1C 95             JSR     RECAL           ;
00932B  2  A9 27                LDA     #39             ;
00932D  2  8D 10 06             STA     debcyll         ;
009330  2  20 FF 94             JSR     SETTRK1
009333  2  20 1C 95             JSR     RECAL           ;
009336  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
009338  2  8D 36 03             STA     FDC_DOR
00933B  2  60                   RTS
00933C  2               
00933C  2               
00933C  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
00933C  2               ;
00933C  2               ; 	READ A FLOPPY SECTOR
00933C  2               ;________________________________________________________________________________________________________________________________
00933C  2               ;
00933C  2               ;
00933C  2               FL_READ_SECTOR:
00933C  2  AD 42 06             LDA     FLOPPY_DETCT
00933F  2  C9 00                CMP     #$00
009341  2  F0 01                BEQ     :+
009343  2  60                   RTS
009344  2               :
009344  2  A9 00                LDA     #$00
009346  2  8D 37 06             STA     FLRETRY         ; BLANK RETRIES
009349  2  8D 38 06             STA     FLRETRY1
00934C  2  A9 0C                LDA     #DOR_INIT
00934E  2  0D 28 06             ORA     DSKUNIT         ;
009351  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009354  2  AD 11 06             LDA     debcylm         ;
009357  2  CD 45 06             CMP     Cdebcylm        ;
00935A  2  D0 13                BNE     READFL_DIRTY
00935C  2  AD 10 06             LDA     debcyll         ;
00935F  2  CD 44 06             CMP     Cdebcyll        ;
009362  2  D0 0B                BNE     READFL_DIRTY
009364  2  AD 12 06             LDA     debsehd         ;
009367  2  CD 46 06             CMP     Cdebsehd        ;
00936A  2  D0 03                BNE     READFL_DIRTY
00936C  2               ; SECTOR ALREADY IN CACHE, DEBLOCK
00936C  2  A9 00                LDA     #$00
00936E  2  60                   RTS
00936F  2               READFL_DIRTY:
00936F  2  AD 11 06             LDA     debcylm         ; STORE CURRENT PARMS
009372  2  8D 45 06             STA     Cdebcylm        ;
009375  2  AD 10 06             LDA     debcyll         ;
009378  2  8D 44 06             STA     Cdebcyll        ;
00937B  2  AD 12 06             LDA     debsehd         ;
00937E  2  8D 46 06             STA     Cdebsehd        ;
009381  2               
009381  2               READFL1:
009381  2  A9 46                LDA     #CFD_READ|CFD_MFM; BIT 6 SETS MFM, 06H IS READ COMMAND
009383  2  8D 3B 06             STA     FCMD            ; SET COMMAND
009386  2  20 10 94             JSR     DSKOP           ; DO DISK OPERATION
009389  2               
009389  2  C9 00                CMP     #$00
00938B  2  F0 2B                BEQ     READFLDONE      ; OPERATION SUCCESSFUL
00938D  2  EE 37 06             INC     FLRETRY         ; LET'S RETRY
009390  2  AD 37 06             LDA     FLRETRY
009393  2  C9 06                CMP     #FLOPPY_RETRIES
009395  2  D0 EA                BNE     READFL1
009397  2  20 1C 95             JSR     RECAL           ; AFTER X RETRIES, LET'S RECAL THE HEAD
00939A  2  20 ED 94             JSR     SETTRACK        ;
00939D  2  A9 00                LDA     #$00            ;
00939F  2  8D 37 06             STA     FLRETRY         ; MORE RETRIES!
0093A2  2  EE 38 06             INC     FLRETRY1
0093A5  2  AD 38 06             LDA     FLRETRY1
0093A8  2  C9 02                CMP     #FLOPPY_RETRIES1
0093AA  2  D0 D5                BNE     READFL1
0093AC  2               
0093AC  2  A9 FF                LDA     #$FF            ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
0093AE  2  8D 45 06             STA     Cdebcylm        ;
0093B1  2  8D 44 06             STA     Cdebcyll        ;
0093B4  2  8D 46 06             STA     Cdebsehd        ;
0093B7  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
0093B8  2               READFLDONE:
0093B8  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
0093BA  2  60                   RTS
0093BB  2               
0093BB  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
0093BB  2               ;
0093BB  2               ; 	WRITE A FLOPPY SECTOR
0093BB  2               ;________________________________________________________________________________________________________________________________
0093BB  2               ;
0093BB  2               FL_WRITE_SECTOR:
0093BB  2  AD 42 06             LDA     FLOPPY_DETCT
0093BE  2  C9 00                CMP     #$00
0093C0  2  F0 01                BEQ     :+
0093C2  2  60                   RTS
0093C3  2               :
0093C3  2  A9 00                LDA     #$00
0093C5  2  8D 37 06             STA     FLRETRY         ; BLANK RETRIES
0093C8  2  8D 38 06             STA     FLRETRY1
0093CB  2  A9 FF                LDA     #$FF
0093CD  2  8D 45 06             STA     Cdebcylm        ; INVALIDATE CACHE
0093D0  2  8D 44 06             STA     Cdebcyll        ;
0093D3  2  8D 46 06             STA     Cdebsehd        ;
0093D6  2               
0093D6  2               WRITEFL1:
0093D6  2  A9 45                LDA     #CFD_WRITE|CFD_MFM; BIT 6 SETS MFM, 05H IS WRITE COMMAND
0093D8  2  8D 3B 06             STA     FCMD
0093DB  2  20 10 94             JSR     DSKOP
0093DE  2               
0093DE  2  C9 00                CMP     #$00
0093E0  2  F0 2B                BEQ     WRITEFLDONE
0093E2  2  EE 37 06             INC     FLRETRY
0093E5  2  AD 37 06             LDA     FLRETRY
0093E8  2  C9 06                CMP     #FLOPPY_RETRIES
0093EA  2  D0 EA                BNE     WRITEFL1
0093EC  2  20 1C 95             JSR     RECAL
0093EF  2  20 ED 94             JSR     SETTRACK
0093F2  2  A9 00                LDA     #$00
0093F4  2  8D 37 06             STA     FLRETRY
0093F7  2  EE 38 06             INC     FLRETRY1
0093FA  2  AD 38 06             LDA     FLRETRY1
0093FD  2  C9 02                CMP     #FLOPPY_RETRIES1
0093FF  2  D0 D5                BNE     WRITEFL1
009401  2  A9 FF                LDA     #$FF            ; INVALIDATE CACHE
009403  2  8D 45 06             STA     Cdebcylm        ;
009406  2  8D 44 06             STA     Cdebcyll        ;
009409  2  8D 46 06             STA     Cdebsehd        ;
00940C  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00940D  2               WRITEFLDONE:
00940D  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00940F  2  60                   RTS
009410  2               
009410  2               
009410  2               ;__DSKOP__________________________________________________________________________________________________________________________
009410  2               ;
009410  2               ; 	PERFORM A DISK OPERATION
009410  2               ;________________________________________________________________________________________________________________________________
009410  2               ;
009410  2               DSKOP:
009410  2  78                   SEI
009411  2  20 8B 95             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009414  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
009416  2  F0 10                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
009418  2               ;
009418  2  20 ED 94             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
00941B  2               ;
00941B  2  AD 3B 06             LDA     FCMD            ; WHAT COMMAND IS PENDING?
00941E  2  C9 46                CMP     #CFD_READ|CFD_MFM; IS IT A READ COMMAND?
009420  2  D0 03                BNE     GWRR_POLL       ;
009422  2  4C 7D 94             JMP     RDD_POLL        ;
009425  2               GWRR_POLL:
009425  2  4C C3 94             JMP     WRR_POLL        ;
009428  2               DSKEXIT:
009428  2  A9 00                LDA     #0              ; SET MOTOR OFF
00942A  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
00942D  2  A9 FF                LDA     #$FF            ; SET IF ERROR
00942F  2  58                   CLI
009430  2  60                   RTS
009431  2               
009431  2               SNDFDWR:
009431  2  18                   CLC
009432  2  AD 28 06             LDA     DSKUNIT         ; GET DISK UNIT NUMBER
009435  2  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
009437  2  8D 31 06             STA     slicetmp        ; PARK IT IN TEMP
00943A  2  AD 11 06             LDA     debcylm         ; GET HEAD SELECTION
00943D  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00943F  2  0A                   ASL     A               ;
009440  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
009441  2  0D 31 06             ORA     slicetmp        ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
009444  2  8D 31 06             STA     slicetmp        ; STORE IN UNIT
009447  2  AD 3B 06             LDA     FCMD            ;
00944A  2  20 47 95             JSR     PFDATA          ; PUSH COMMAND TO I8272
00944D  2  AD 31 06             LDA     slicetmp        ;
009450  2  20 47 95             JSR     PFDATA          ;
009453  2  AD 10 06             LDA     debcyll         ;
009456  2  20 47 95             JSR     PFDATA          ;
009459  2  AD 11 06             LDA     debcylm         ;
00945C  2  20 47 95             JSR     PFDATA          ;
00945F  2  18                   CLC                     ;
009460  2  AD 12 06             LDA     debsehd         ;
009463  2  69 01                ADC     #$01            ;
009465  2  20 47 95             JSR     PFDATA          ;
009468  2  A9 02                LDA     #$02            ;
00946A  2  20 47 95             JSR     PFDATA          ; WHAT DENSITY
00946D  2  A9 09                LDA     #$09            ;
00946F  2  20 47 95             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
009472  2  A9 1B                LDA     #$1B            ;
009474  2  20 47 95             JSR     PFDATA          ; WHAT GAP IS NEEDED
009477  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
009479  2  20 72 95             JSR     PFDATAS
00947C  2  60                   RTS
00947D  2               
00947D  2               
00947D  2               ; PERFORM READ
00947D  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
00947D  2               ;
00947D  2               RDD_POLL:
00947D  2  A2 00                LDX     #$00
00947F  2  A0 00                LDY     #$00
009481  2  20 31 94             JSR     SNDFDWR         ;
009484  2               RDS1:
009484  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS  (4 CYCLES)
009487  2  10 FB                BPL     RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
009489  2  29 20                AND     #%00100000      ; EXECUTION MODE? (2 CYCLES)
00948B  2  F0 1D                BEQ     DSKOPEND        ; NO, ERROR
00948D  2               RDS1A:
00948D  2  AD 31 03             LDA     FDC_DATA        ; GET DATA (4 CYCLES)
009490  2  99 00 04             STA     hstbuf,Y        ; WRITE IT (5 CYCLES)
009493  2  C8                   INY                     ; (2 CYCLES)
009494  2  D0 EE                BNE     RDS1            ; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
009496  2  A2 00                LDX     #$00
009498  2               RDS2:
009498  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
00949B  2  10 FB                BPL     RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
00949D  2  29 20                AND     #%00100000      ; EXECUTION MODE?
00949F  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
0094A1  2               RDS2A:
0094A1  2  AD 31 03             LDA     FDC_DATA        ; GET DATA
0094A4  2  99 00 05             STA     hstbuf+256,Y    ; WRITE IT
0094A7  2  C8                   INY
0094A8  2  D0 EE                BNE     RDS2            ; KEEP GOING
0094AA  2               DSKOPEND:
0094AA  2  AD 37 03             LDA     FDC_TC
0094AD  2  20 39 96             JSR     FDDELAY
0094B0  2               ;
0094B0  2  20 D4 95             JSR     GFDATA          ;GET ERROR TYPE
0094B3  2  8D 3A 06             STA     FLERR
0094B6  2               ;* CLEAR OUT ANY REMAINING DATA
0094B6  2               RESUL3:
0094B6  2  20 D4 95             JSR     GFDATA          ;READ BYTE FROM FDC
0094B9  2  C9 00                CMP     #$00
0094BB  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
0094BD  2  AD 3A 06             LDA     FLERR           ;
0094C0  2  29 C0                AND     #%11000000      ;
0094C2  2  60                   RTS
0094C3  2               
0094C3  2               
0094C3  2               WRR_POLL:
0094C3  2  20 31 94             JSR     SNDFDWR         ;
0094C6  2               WRS1:   ;
0094C6  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0094C9  2  10 FB                BPL     WRS1            ; NOT READY
0094CB  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0094CD  2  F0 1B                BEQ     WRS3            ; NO, ERROR
0094CF  2  B9 00 04             LDA     hstbuf,Y        ; WRITE IT
0094D2  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0094D5  2  C8                   INY
0094D6  2  D0 EE                BNE     WRS1            ; DO NEXT
0094D8  2               WRS2:   ;
0094D8  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0094DB  2  10 FB                BPL     WRS2            ; NOT READY
0094DD  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0094DF  2  F0 09                BEQ     WRS3            ; NO, ERROR
0094E1  2  B9 00 05             LDA     hstbuf+256,Y    ; WRITE IT
0094E4  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0094E7  2  C8                   INY
0094E8  2  D0 EE                BNE     WRS2            ; DO NEXT
0094EA  2               WRS3:
0094EA  2  4C AA 94             JMP     DSKOPEND        ;
0094ED  2               
0094ED  2               
0094ED  2               ;__SETTRACK__________________________________________________________________________________________________________________________
0094ED  2               ;
0094ED  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
0094ED  2               ; 	A: TRACK #
0094ED  2               ;________________________________________________________________________________________________________________________________
0094ED  2               ;
0094ED  2               SETTRACK:
0094ED  2  A9 0C                LDA     #DOR_INIT
0094EF  2  0D 28 06             ORA     DSKUNIT         ; SET MOTOR ON
0094F2  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
0094F5  2               
0094F5  2               ; ANY INTERUPT PENDING
0094F5  2               ; IF YES FIND OUT WHY/CLEAR
0094F5  2  20 8B 95             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
0094F8  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
0094FA  2  D0 03                BNE     SETTRK1
0094FC  2  4C 46 95             JMP     SETTRKEXIT      ;
0094FF  2               
0094FF  2               ;
0094FF  2               SETTRK1:
0094FF  2  AD 10 06             LDA     debcyll         ; GET TRACK
009502  2  C9 00                CMP     #$00            ;
009504  2  F0 16                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
009506  2  A9 0F                LDA     #CFD_SEEK       ; SEEK COMMAND
009508  2  20 47 95             JSR     PFDATA          ; PUSH COMMAND
00950B  2  AD 28 06             LDA     DSKUNIT         ; SAY WHICH UNIT
00950E  2  29 01                AND     #$01
009510  2  20 47 95             JSR     PFDATA          ; SEND THAT
009513  2  AD 10 06             LDA     debcyll         ; TO WHAT TRACK
009516  2  20 47 95             JSR     PFDATA          ; SEND THAT TOO
009519  2  4C 31 95             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
00951C  2               RECAL:
00951C  2  A9 0C                LDA     #DOR_INIT
00951E  2  0D 28 06             ORA     DSKUNIT         ; SET MOTOR ON
009521  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009524  2  A9 07                LDA     #CFD_RECAL      ; RECAL TO TRACK 0
009526  2  20 47 95             JSR     PFDATA          ; SEND IT
009529  2  AD 28 06             LDA     DSKUNIT         ; SAY WHICH UNIT
00952C  2  29 01                AND     #$01
00952E  2  20 47 95             JSR     PFDATA          ; SEND THAT TOO
009531  2               ;
009531  2               WAINT:
009531  2  48                   PHA
009532  2  8A                   TXA
009533  2  48                   PHA
009534  2  A2 64                LDX     #100
009536  2  20 3E 96             JSR     FDVDELAY
009539  2  68                   PLA
00953A  2  AA                   TAX
00953B  2  68                   PLA
00953C  2               :
00953C  2  20 8B 95             JSR     CHECKINT
00953F  2  AD 30 03             LDA     FDC_MSR         ; READ SEEK STATUS
009542  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
009544  2  D0 F6                BNE     :-              ; YES, WAIT FOR THEM
009546  2               ;
009546  2               SETTRKEXIT:
009546  2  60                   RTS
009547  2               
009547  2               ;__PFDATA__________________________________________________________________________________________________________________________
009547  2               ;
009547  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
009547  2               ;
009547  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009547  2               ;	RQM  DIO
009547  2               ;	0	0	BUSY
009547  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009547  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009547  2               ;	0	1	BUSY
009547  2               ;
009547  2               ;________________________________________________________________________________________________________________________________
009547  2               ;
009547  2               PFDATA:
009547  2  48                   PHA                     ; SAVE DATA BYTE
009548  2  A0 00                LDY     #$00
00954A  2               WRF1:
00954A  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
00954D  2  AA                   TAX
00954E  2  29 80                AND     #$80            ;
009550  2  D0 07                BNE     :+
009552  2  C8                   INY
009553  2  D0 F5                BNE     WRF1            ; FDC IS NOT READY, WAIT FOR IT
009555  2  68                   PLA
009556  2  A9 FF                LDA     #$FF
009558  2  60                   RTS
009559  2               :
009559  2  8A                   TXA
00955A  2  29 40                AND     #$40            ; TEST DIO BIT
00955C  2  D0 0E                BNE     WRF2            ; FDC IS OUT OF SYNC
00955E  2  68                   PLA                     ; RESTORE DATA
00955F  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009562  2  20 39 96             JSR     FDDELAY
009565  2  20 39 96             JSR     FDDELAY
009568  2  20 39 96             JSR     FDDELAY
00956B  2  60                   RTS
00956C  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00956C  2               WRF2:
00956C  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
00956F  2  4C 4A 95             JMP     WRF1            ; AND CONTINUE
009572  2               
009572  2               ;__PFDATAS_________________________________________________________________________________________________________________________
009572  2               ;
009572  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
009572  2               ;
009572  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009572  2               ;	RQM  DIO
009572  2               ;	0	0	BUSY
009572  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009572  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009572  2               ;	0	1	BUSY
009572  2               ;
009572  2               ;________________________________________________________________________________________________________________________________
009572  2               ;
009572  2               PFDATAS:
009572  2  48                   PHA                     ; SAVE DATA BYTE
009573  2               WRF1S:
009573  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
009576  2  AA                   TAX
009577  2  29 80                AND     #$80            ;
009579  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
00957B  2  8A                   TXA
00957C  2  29 40                AND     #$40            ; TEST DIO BIT
00957E  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
009580  2  68                   PLA                     ; RESTORE DATA
009581  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009584  2  60                   RTS
009585  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009585  2               WRF2S:
009585  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009588  2  4C 73 95             JMP     WRF1S           ; AND CONTINUE
00958B  2               
00958B  2               
00958B  2               
00958B  2               ;__CHECKINT__________________________________________________________________________________________________________________________
00958B  2               ;
00958B  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
00958B  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
00958B  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
00958B  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
00958B  2               ;________________________________________________________________________________________________________________________________
00958B  2               ;
00958B  2               CHECKINT:
00958B  2  A0 00                LDY     #$00
00958D  2               :
00958D  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009590  2  29 80                AND     #$80
009592  2  D0 09                BNE     :+              ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
009594  2  20 39 96             JSR     FDDELAY
009597  2  C8                   INY
009598  2  D0 F3                BNE     :-
00959A  2  4C A5 95             JMP     ERRCLR
00959D  2               
00959D  2               :
00959D  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
0095A0  2  29 40                AND     #$40            ; WAITING FOR INPUT?
0095A2  2  F0 16                BEQ     SENDINT
0095A4  2  60                   RTS
0095A5  2               
0095A5  2               ERRCLR:
0095A5  2  A0 00                LDY     #$00
0095A7  2               :
0095A7  2  AD 31 03             LDA     FDC_DATA        ; CLEAR THE JUNK OUT OF DATA REGISTER
0095AA  2  AD 30 03             LDA     FDC_MSR         ; CHECK WITH RQM
0095AD  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
0095AF  2  D0 06                BNE     :+              ;
0095B1  2  20 39 96             JSR     FDDELAY
0095B4  2  C8                   INY
0095B5  2  D0 F0                BNE     :-
0095B7  2               :
0095B7  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
0095B9  2               ;
0095B9  2  60                   RTS
0095BA  2               
0095BA  2               ;__SENDINT__________________________________________________________________________________________________________________________
0095BA  2               ;
0095BA  2               ; SENSE INTERRUPT COMMAND
0095BA  2               ;________________________________________________________________________________________________________________________________
0095BA  2               ;
0095BA  2               SENDINT:
0095BA  2  A9 08                LDA     #CFD_SENSEINT   ; SENSE INTERRUPT COMMAND
0095BC  2  20 47 95             JSR     PFDATA          ; SEND IT
0095BF  2  20 D4 95             JSR     GFDATA          ; GET RESULTS
0095C2  2  8D 39 06             STA     ST0             ; STORE THAT
0095C5  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
0095C7  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
0095C9  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
0095CB  2  20 D4 95             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
0095CE  2  AD 39 06             LDA     ST0             ; GET FIRST ONE
0095D1  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
0095D3  2               ENDSENDINT:
0095D3  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
0095D4  2               
0095D4  2               
0095D4  2               ;__GFDATA__________________________________________________________________________________________________________________________
0095D4  2               ;
0095D4  2               ; GET DATA FROM FLOPPY CONTROLLER
0095D4  2               ;
0095D4  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
0095D4  2               ;	RQM  DIO
0095D4  2               ;	0	0	BUSY
0095D4  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
0095D4  2               ;	1	1	BYTE FOR READ BY HOST PENDING
0095D4  2               ;	0	1	BUSY
0095D4  2               ;
0095D4  2               ;________________________________________________________________________________________________________________________________
0095D4  2               ;
0095D4  2               GFDATA:
0095D4  2  A0 00                LDY     #$00
0095D6  2               :
0095D6  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0095D9  2  AA                   TAX                     ;
0095DA  2  29 80                AND     #%10000000      ; NOT READY, WAIT
0095DC  2  D0 06                BNE     :+              ;
0095DE  2  C8                   INY
0095DF  2  D0 F5                BNE     :-
0095E1  2  A9 00                LDA     #$00
0095E3  2  60                   RTS
0095E4  2               :
0095E4  2  8A                   TXA
0095E5  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
0095E7  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
0095E9  2  AD 31 03             LDA     FDC_DATA        ; GET FDC DATA
0095EC  2               GFDATA1:
0095EC  2  60                   RTS
0095ED  2               
0095ED  2               ;__FD_DETECT______________________________________________________________________________________________________________________
0095ED  2               ;
0095ED  2               ; 	DETECT FLOPPY HARDWARE
0095ED  2               ;________________________________________________________________________________________________________________________________
0095ED  2               FD_DETECT:
0095ED  2               ; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
0095ED  2  20 1B 96             JSR     FC_RESETFDC     ; RESET FDC
0095F0  2               
0095F0  2  AD 30 03             LDA     FDC_MSR         ; READ MSR
0095F3  2  C9 80                CMP     #$80
0095F5  2  F0 0A                BEQ     FD_DETECT1      ; $80 IS OK
0095F7  2  C9 D0                CMP     #$D0
0095F9  2  F0 06                BEQ     FD_DETECT1      ; $D0 IS OK
0095FB  2  A9 FF                LDA     #$FF            ; NOT OK
0095FD  2  8D 42 06             STA     FLOPPY_DETCT
009600  2  60                   RTS
009601  2               ;
009601  2               FD_DETECT1:
009601  2  A2 64                LDX     #100
009603  2  20 3E 96             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009606  2  AD 30 03             LDA     FDC_MSR         ; READ MSR AGAIN
009609  2  C9 80                CMP     #$80
00960B  2  F0 08                BEQ     :+              ; $80 IS OK
00960D  2  C9 D0                CMP     #$D0
00960F  2  A9 FF                LDA     #$FF            ; NOT OK
009611  2  8D 42 06             STA     FLOPPY_DETCT
009614  2  60                   RTS
009615  2               :
009615  2  A9 00                LDA     #$00            ; OK
009617  2  8D 42 06             STA     FLOPPY_DETCT
00961A  2  60                   RTS
00961B  2               
00961B  2               FC_RESETFDC:
00961B  2  AD 33 03             LDA     FDC_RESET
00961E  2  AD 33 03             LDA     FDC_RESET
009621  2  A2 96                LDX     #150
009623  2  20 3E 96             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009626  2               
009626  2  A9 00                LDA     #$00
009628  2  8D 36 03             STA     FDC_DOR
00962B  2  20 39 96             JSR     FDDELAY
00962E  2  A9 0C                LDA     #DOR_INIT
009630  2  8D 36 03             STA     FDC_DOR
009633  2  A2 96                LDX     #150            ;
009635  2  20 3E 96             JSR     FDVDELAY
009638  2  60                   RTS
009639  2               
009639  2               
009639  2               FDDELAY:
009639  2  48                   PHA
00963A  2  68                   PLA
00963B  2  48                   PHA
00963C  2  68                   PLA
00963D  2  60                   RTS
00963E  2               FDVDELAY:
00963E  2  48                   PHA
00963F  2  68                   PLA
009640  2  48                   PHA
009641  2  68                   PLA
009642  2  CA                   DEX
009643  2  E0 00                CPX     #$00
009645  2  D0 F7                BNE     FDVDELAY
009647  2  60                   RTS
009648  2               
009648  1                       .INCLUDE "dospager.asm"
009648  2               ;__pager_________________________________________________________________________________________________________________________
009648  2               ;
009648  2               ; 	Nhyodyne Memory page management code
009648  2               ;
009648  2               ;	Entry points:
009648  2               ;		PAGER_INIT          - called during OS init
009648  2               ;________________________________________________________________________________________________________________________________
009648  2               ;
009648  2               ; RAM BANK $0C is RAM area for Drivers
009648  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
009648  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
009648  2               ;
009648  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
009648  2               ;
009648  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
009648  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
009648  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009648  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009648  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
009648  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
009648  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
009648  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
009648  2               ;
009648  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
009648  2               ;
009648  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009648  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009648  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
009648  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
009648  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
009648  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
009648  2               
009648  2               
009648  2               ;__PAGER_INIT___________________________________________________________________________________________
009648  2               ;
009648  2               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
009648  2               ;____________________________________________________________________________________________________
009648  2               PAGER_INIT:
009648  2  A2 00                LDX     #$00
00964A  2               :
00964A  2  BD 56 96             LDA     md_pagecode,X
00964D  2  9D 00 02             STA     MD_PAGERA,X
009650  2  E8                   INX
009651  2  E0 00                CPX     #$00
009653  2  D0 F5                BNE     :-
009655  2  60                   RTS
009656  2               
009656  2               ;       X=Control Word
009656  2               ;	7 6 5 4  3 2 1 0
009656  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009656  2               ;       X : : X  X X X X    = UNUSED
009656  2               ;	X : :-------------0 = Read=0, Write=1
009656  2               ;	X :---------------0 = RAM=0, ROM=1
009656  2               ;
009656  2               ;       A= bank
009656  2               ;       Y= page
009656  2               ;
009656  2               md_pagecode:
009656  2  48                   PHA
009657  2  84 ED                STY     DEST+1     ; setup copy from pointer
009659  2  8A                   TXA
00965A  2  29 80                AND     #$80
00965C  2  A8                   TAY
00965D  2  84 EC                STY     DEST
00965F  2  8A                   TXA
009660  2  29 20                AND     #%00100000
009662  2  C9 00                CMP     #$00
009664  2  D0 4F                BNE     MD_PAGE_WRITE
009666  2               ; PERFORM READ HERE
009666  2  8A                   TXA
009667  2  29 40                AND     #%01000000
009669  2  C9 00                CMP     #$00
00966B  2  D0 0E                BNE     MD_PAGE_ROREAD
00966D  2               ; DO RAM READ
00966D  2  A9 80                LDA     #$80
00966F  2  8D 7C 03             STA     MPCL_ROM
009672  2  68                   PLA
009673  2  09 80                ORA     #$80
009675  2  8D 78 03             STA     MPCL_RAM
009678  2  18                   CLC
009679  2  90 0B                BCC     MD_PAGE_COPYFRM
00967B  2               MD_PAGE_ROREAD:
00967B  2  A9 00                LDA     #$00
00967D  2  8D 78 03             STA     MPCL_RAM
009680  2  68                   PLA
009681  2  29 7F                AND     #$7F
009683  2  8D 7C 03             STA     MPCL_ROM
009686  2               MD_PAGE_COPYFRM:
009686  2               ; DO THE COPY
009686  2  A2 00                LDX     #$00
009688  2  A0 00                LDY     #$00
00968A  2               :
00968A  2  B1 EC                LDA     (DEST),Y
00968C  2  9D 00 04             STA     hstbuf,X
00968F  2  E8                   INX
009690  2  C8                   INY
009691  2  E0 00                CPX     #$00
009693  2  D0 F5                BNE     :-
009695  2  A2 00                LDX     #$00
009697  2  A0 00                LDY     #$00
009699  2  E6 ED                INC     DEST+1
00969B  2               :
00969B  2  B1 EC                LDA     (DEST),Y
00969D  2  9D 00 05             STA     hstbuf+$100,X
0096A0  2  E8                   INX
0096A1  2  C8                   INY
0096A2  2  E0 00                CPX     #$00
0096A4  2  D0 F5                BNE     :-
0096A6  2  A9 80                LDA     #$80
0096A8  2  8D 7C 03             STA     MPCL_ROM
0096AB  2  EA                   NOP
0096AC  2  EA                   NOP
0096AD  2  A9 8C                LDA     #$8C
0096AF  2  8D 78 03             STA     MPCL_RAM
0096B2  2  EA                   NOP
0096B3  2  EA                   NOP
0096B4  2  60                   RTS
0096B5  2               MD_PAGE_WRITE:
0096B5  2  68                   PLA
0096B6  2  09 80                ORA     #%10000000
0096B8  2  8D 78 03             STA     MPCL_RAM
0096BB  2               ; DO THE COPY
0096BB  2  A2 00                LDX     #$00
0096BD  2  A0 00                LDY     #$00
0096BF  2               :
0096BF  2  BD 00 04             LDA     hstbuf,X
0096C2  2  91 EC                STA     (DEST),Y
0096C4  2  E8                   INX
0096C5  2  C8                   INY
0096C6  2  E0 00                CPX     #$00
0096C8  2  D0 F5                BNE     :-
0096CA  2  A2 00                LDX     #$00
0096CC  2  A0 00                LDY     #$00
0096CE  2  E6 ED                INC     DEST+1
0096D0  2               :
0096D0  2  BD 00 05             LDA     hstbuf+$100,X
0096D3  2  91 EC                STA     (DEST),Y
0096D5  2  E8                   INX
0096D6  2  C8                   INY
0096D7  2  E0 00                CPX     #$00
0096D9  2  D0 F5                BNE     :-
0096DB  2  A9 8C                LDA     #$8C
0096DD  2  8D 78 03             STA     MPCL_RAM
0096E0  2  EA                   NOP
0096E1  2  EA                   NOP
0096E2  2  60                   RTS
0096E3  2               md_pagecodeend:
0096E3  2               farcall:
0096E3  2                       .IF     USEROM=1
0096E3  2  48                       PHA
0096E4  2  A9 80                    LDA     #$80
0096E6  2  8D 7C 03                 STA     MPCL_ROM
0096E9  2  EA                       NOP
0096EA  2  EA                       NOP
0096EB  2  A9 8C                    LDA     #$8C
0096ED  2  8D 78 03                 STA     MPCL_RAM
0096F0  2  EA                       NOP
0096F1  2  EA                       NOP
0096F2  2  68                       PLA
0096F3  2  20 00 88                 JSR     BANKED_DRIVER_DISPATCHER
0096F6  2  48                       PHA
0096F7  2  A9 00                    LDA     #$00
0096F9  2  8D 78 03                 STA     MPCL_RAM
0096FC  2  EA                       NOP
0096FD  2  EA                       NOP
0096FE  2  8D 7C 03                 STA     MPCL_ROM
009701  2  EA                       NOP
009702  2  EA                       NOP
009703  2  68                       PLA
009704  2  60                       RTS
009705  2               md_farrun:
009705  2  A9 80                    LDA     #$80
009707  2  8D 7C 03                 STA     MPCL_ROM
00970A  2  EA                       NOP
00970B  2  EA                       NOP
00970C  2  A5 00                    LDA     $00
00970E  2  8D 78 03                 STA     MPCL_RAM
009711  2  EA                       NOP
009712  2  EA                       NOP
009713  2  6C 01 00                 JMP     ($0001)
009716  2                       .ELSE
009716  2                           PHA
009716  2                           LDA     #$8C
009716  2                           STA     MPCL_RAM
009716  2                           NOP
009716  2                           NOP
009716  2                           PLA
009716  2                           JSR     BANKED_DRIVER_DISPATCHER
009716  2                           PHA
009716  2                           LDA     #$8E
009716  2                           STA     MPCL_RAM
009716  2                           PLA
009716  2                           RTS
009716  2                       .ENDIF
009716  2               
009716  1               
009716  1               
009716  1               
009716  1               ;__DFT_CONSOLE___________________________________________________________________________________________________________________
009716  1               ;
009716  1               ;	      TRANSFER CONSOLE COMMAND TO DESIGNATED CONSOLE
009716  1               ;________________________________________________________________________________________________________________________________
009716  1               DFT_CONSOLE:
009716  1  48                   PHA
009717  1  A5 3A                LDA     CONSOLE
009719  1  18                   CLC
00971A  1  65 32                ADC     farfunct
00971C  1  85 32                STA     farfunct
00971E  1  68                   PLA
00971F  1  4C 00 88             JMP     FUNCTION_DISPATCHER
009722  1               
009722  1               
009722  1               drv_noop:
009722  1  60                   RTS
009723  1                       .END
