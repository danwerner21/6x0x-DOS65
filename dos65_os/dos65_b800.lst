ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               
000000r 1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	DOS/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp          = $0100         ; warm boot jump
000000r 2               pemjmp          = $0103         ; jump to pem
000000r 2               iostat          = $0106         ; i/o status
000000r 2               dflfcb          = $0107         ; default fcb
000000r 2               dflbuf          = $0128         ; default buffer
000000r 2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
000000r 2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
000000r 2               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 2               MPCL_ROM        = $037C         ; ROM MAPPER
000000r 2               MPCL_RAM        = $0378         ; RAM MAPPER
000000r 2               hstbuf          = $0400         ; 0400-05ff host buffer
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               
000000r 2               
000000r 2               DSKY_BUF        = $0600         ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN     = 8             ;
000000r 2               DSKY_HEXBUF     = $0608         ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN  = 4             ;
000000r 2               sektrk          = $060C         ; seek track number
000000r 2               seksec          = $060E         ; seek sector number
000000r 2               debcyll         = $0610         ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         = $0611         ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         = $0612         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          = $0616         ; seek disk number
000000r 2               dskcfg          = $0617         ; 16 bytes disk configuration table
000000r 2               DSKUNIT         = $0628         ; seek disk number
000000r 2               slicetmp        = $0631         ; (word)
000000r 2               STACKA          = $0635
000000r 2               nmsstr          = $0636
000000r 2               FLRETRY         = $0637         ;
000000r 2               FLRETRY1        = $0638         ;
000000r 2               ST0             = $0639         ;
000000r 2               FLERR           = $063A         ;
000000r 2               FCMD            = $063B         ;
000000r 2               PPIDEINDEX      = $063C
000000r 2               currentDrive    = $063D
000000r 2               DSKY_X_STORAGE  = $063E
000000r 2               DSKY_Y_STORAGE  = $063F
000000r 2               DSKY_TEMP_VAL   = $0640
000000r 2               DSKY_PPIX_VAL   = $0641
000000r 2               FLOPPY_DETCT    = $0642
000000r 2               DSKY_PRESENT    = $0643
000000r 2               Cdebcyll        = $0644         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 2               Cdebcylm        = $0645         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 2               Cdebsehd        = $0646         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 2               
000000r 2               
000000r 2               tea             = $800          ;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               addinp          = $02           ;initialized to a,y
000000r 2               bufadd          = $04           ;buffer address
000000r 2               alcpnt          = $06           ;allocation map pointer
000000r 2               chkpnt          = $08           ;checksum map pointer
000000r 2               numvar          = 8             ;eight bytes
000000r 2               
000000r 2               
000000r 2               msgptr          = chkpnt+2      ;message pointer
000000r 2               movptr          = msgptr        ;and move pointer
000000r 2               dcbloc          = msgptr+2      ;pointer to dcb
000000r 2               
000000r 2               dcbpc           = $2C           ;pointer to DCB table
000000r 2               dskcfpc         = $2E           ;pointer to disk configuration table
000000r 2               cmdlnp          = $30           ;pointer to command line buffer
000000r 2               farfunct        = $32           ; function to call in driver area
000000r 2               farpointer      = $33           ;
000000r 2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 2               CONSOLE         = $3A
000000r 2               TEMPWORD        = $3B           ;
000000r 2               TEMPWORD1       = $3D           ;
000000r 2               TEMPWORD2       = $3F           ;
000000r 2               STRPTR          = $41           ;
000000r 2               DSKYMODE        = $43           ; DSKY MODE (0=NONE, 1=DSKY, 2=DSKY NG
000000r 2               
000000r 2               
000000r 2               DO_FARCALL      = $FFF0
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST            = $EC           ;pointer for OutMsg
000000r 2               SRC             = $EE           ;pointer for OutMsg
000000r 2               OUTMSG_W        = $F0           ;pointer for OutMsg
000000r 2               dmaadr          = $f4           ;pointer for r/w
000000r 2               
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall           = 0             ;write to allocated
000000r 2               wrdir           = 1             ;write to directory
000000r 2               wrual           = 2             ;write to unallocated
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf              = $a            ;linefeeed
000000r 2               cr              = $d            ;return
000000r 2               eof             = $1a           ;end of file
000000r 2               null            = 0             ;null
000000r 2               ctlc            = 3             ;abort
000000r 2               ctle            = 5             ;physical cr lf
000000r 2               ctli            = 9             ;tab character
000000r 2               ctlp            = $10           ;toggle printer
000000r 2               ctlr            = $12           ;repeat line
000000r 2               ctls            = $13           ;freeze
000000r 2               ctlx            = $18           ;cancel
000000r 2               semico          = $3b           ;semicolon
000000r 2               delete          = $08           ;delete character
000000r 2               numcmd          = 36            ;number commands
000000r 2               DEFDRV          = 0             ; SET TO DEFAULT DRIVE LETTER
000000r 2               
000000r 2               
000000r 2                       .IFDEF  RBC6X0X
000000r 2                       .DEFINE COMSUFFIX "COM"
000000r 2                       .ENDIF
000000r 2               
000000r 2                       .IFDEF  NHYODYNE
000000r 2                       .DEFINE COMSUFFIX "CO6"
000000r 2                       .ENDIF
000000r 2               
000000r 2               DEBUG           = 0
000000r 2               BANKED_DRIVER_DISPATCHER=$8800
000000r 2               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1                       .SEGMENT "OS"
000000r 1                       .ORG    DOSBEGIN
00B800  1                       .INCLUDE "ccm215.asm"
00B800  2               ;________________________________________________________________________________________________________________________________
00B800  2               ;
00B800  2               ;	DOS/65 console command module (ccm)
00B800  2               ;
00B800  2               ;________________________________________________________________________________________________________________________________
00B800  2               
00B800  2               ;ccm unique definitions
00B800  2               nbuilt          = 7             ;number built in commands
00B800  2               ;main program
00B800  2               ; warm boot vector
00B800  2  4C 2E CD             JMP     boot
00B803  2               ccm:
00B803  2  D8                   CLD                     ;set binary mode
00B804  2  48                   PHA                     ;save drive number
00B805  2  20 F7 BB             JSR     rstdsk          ;initialize system
00B808  2  68                   PLA                     ;restore drive num
00B809  2  20 FB BB             JSR     slctds          ;select drive
00B80C  2  AD 18 CC             LDA     sysdef+6        ;get line length
00B80F  2  4A                   LSR     a               ;divide
00B810  2  4A                   LSR     a               ;by
00B811  2  4A                   LSR     a               ;16
00B812  2  4A                   LSR     a               ;for dir
00B813  2  8D F2 BF             STA     sixten          ;and save
00B816  2  AD 3E BF             LDA     cnslng          ;get buffer length
00B819  2  D0 37                BNE     mrecmd          ;if more handle it
00B81B  2               ccmlpe:
00B81B  2                       .IFDEF  DUODYNE
00B81B  2                       CLD                     ; VERIFY DECIMAL MODE IS OFF
00B81B  2                       CLC                     ;
00B81B  2                       XCE                     ; SET NATIVE MODE
00B81B  2                       ACCUMULATORINDEX16
00B81B  2                       LDA     #STACK          ; get the stack address
00B81B  2                       TCS                     ; and set the stack to it
00B81B  2                       ACCUMULATORINDEX8
00B81B  2                       .ELSE
00B81B  2  A2 FF                LDX     #$ff            ;set
00B81D  2  9A                   TXS                     ;stack
00B81E  2                       .ENDIF
00B81E  2  D8                   CLD                     ;set binary mode
00B81F  2               ;        LDA     #17             ; SEND A XON
00B81F  2               ;        JSR     chrout          ; ----------
00B81F  2  20 64 BC             JSR     hdrout          ;send header
00B822  2  A9 3E                LDA     #'>'            ;then print
00B824  2  20 EB BB             JSR     chrout          ;prompt
00B827  2  AD 86 BE             LDA     cnsbvc          ;point to start
00B82A  2  AC 87 BE             LDY     cnsbvc+1        ;of buffer
00B82D  2  20 EF BB             JSR     rdebuf          ;do buffer read
00B830  2  A0 00                LDY     #0              ;clear index
00B832  2  AE 3E BF             LDX     cnslng          ;get length
00B835  2  F0 E4                BEQ     ccmlpe          ;loop if empty
00B837  2               lwrupr:
00B837  2  B9 3F BF             LDA     cnstxt,y        ;else get char
00B83A  2  C9 61                CMP     #'a'            ;if less than a
00B83C  2  90 09                BCC     nxtchg          ;skip convert
00B83E  2  C9 7B                CMP     #'z'+1          ;if over z
00B840  2  B0 05                BCS     nxtchg          ;skip convert
00B842  2  29 5F                AND     #%01011111      ;else convert
00B844  2  99 3F BF             STA     cnstxt,y        ;put back in buffer
00B847  2               nxtchg:
00B847  2  C8                   INY                     ;bump index
00B848  2  CA                   DEX                     ;count down
00B849  2  D0 EC                BNE     lwrupr          ;loop if more
00B84B  2  8A                   TXA                     ;set a to zero
00B84C  2  99 3F BF             STA     cnstxt,y        ;insert stopper
00B84F  2  8D E2 BF             STA     cnbfpt          ;initialize pointer
00B852  2               mrecmd:
00B852  2  20 9F BD             JSR     stdflb          ;set default buffer
00B855  2  20 26 BC             JSR     intdsk          ;get drive number
00B858  2  8D E3 BF             STA     dfldsk          ;store as default
00B85B  2  20 A0 BC             JSR     prslin          ;parse command
00B85E  2  D0 64                BNE     cmderr          ;error if afn
00B860  2  AD E4 BF             LDA     tmpdsk          ;get temporary
00B863  2  F0 04                BEQ     nodrch          ;if zero ok
00B865  2  A9 15                LDA     #nbuilt*3       ;else set and
00B867  2  D0 2E                BNE     dotrns          ;do transient
00B869  2               nodrch:
00B869  2  A9 00                LDA     #0              ;clear
00B86B  2  AA                   TAX                     ;table index
00B86C  2  8D E8 BF             STA     ccmcount        ;and count
00B86F  2               tsnxfn:
00B86F  2  A0 01                LDY     #1              ;set fcb index
00B871  2               tsnxch:
00B871  2  BD 18 BF             LDA     fnctbl,x        ;get table entry
00B874  2  F0 1A                BEQ     gotcmd          ;if zero got it
00B876  2  D9 BE BF             CMP     fcbone,y        ;else test
00B879  2  D0 04                BNE     nocmpr          ;no good if not =
00B87B  2  E8                   INX                     ;bump
00B87C  2  C8                   INY                     ;pointers
00B87D  2  D0 F2                BNE     tsnxch          ;and loop
00B87F  2               nocmpr:
00B87F  2  E8                   INX                     ;go to end
00B880  2  BD 18 BF             LDA     fnctbl,x        ;of table
00B883  2  D0 FA                BNE     nocmpr          ;entry
00B885  2  E8                   INX                     ;point to next
00B886  2  EE E8 BF             INC     ccmcount        ;bump count
00B889  2  AD E8 BF             LDA     ccmcount        ;and if not
00B88C  2  C9 07                CMP     #nbuilt         ;limit then
00B88E  2  D0 DF                BNE     tsnxfn          ;try next
00B890  2               gotcmd:
00B890  2  AD E8 BF             LDA     ccmcount        ;get count
00B893  2  0A                   ASL     a               ;multiply by two
00B894  2  6D E8 BF             ADC     ccmcount        ;then add for x3
00B897  2               dotrns:
00B897  2  AA                   TAX                     ;use as index
00B898  2  E8                   INX                     ;bump to pass jmp
00B899  2  BD 91 BE             LDA     xqfntb,x        ;to get
00B89C  2  BC 92 BE             LDY     xqfntb+1,x      ;entry address
00B89F  2  8D E6 BF             STA     vector          ;then set
00B8A2  2  8C E7 BF             STY     vector+1        ;vector
00B8A5  2  AD 8A BE             LDA     extcvc+1        ;save
00B8A8  2  48                   PHA                     ;return
00B8A9  2  AD 89 BE             LDA     extcvc          ;address
00B8AC  2  48                   PHA                     ;on stack
00B8AD  2                       .IFDEF  DUODYNE
00B8AD  2                       LDX     #$00
00B8AD  2                       JMP     (vector,x)      ;execute
00B8AD  2                       .ELSE
00B8AD  2  6C E6 BF             JMP     (vector)        ;execute
00B8B0  2                       .ENDIF
00B8B0  2               extcmd:
00B8B0  2  20 2F BC             JSR     rstddr          ;restore default
00B8B3  2               extwod:
00B8B3  2  20 A0 BC             JSR     prslin          ;parse more
00B8B6  2  AD BF BF             LDA     fcbone+1        ;if first
00B8B9  2  38                   SEC                     ;character
00B8BA  2  E9 20                SBC     #' '            ;not a space
00B8BC  2  0D E4 BF             ORA     tmpdsk          ;or if temporary
00B8BF  2  D0 03                BNE     cmderr          ;then an error
00B8C1  2  4C 1B B8             JMP     ccmlpe          ;else loop
00B8C4  2               ;command error syntax handler
00B8C4  2               cmderr:
00B8C4  2  20 DC BB             JSR     ccrlf           ;do a cr lf
00B8C7  2  AC E9 BF             LDY     curpnt          ;get command pointer
00B8CA  2               cmerlp:
00B8CA  2  B9 3F BF             LDA     cnstxt,y        ;get char
00B8CD  2  F0 0A                BEQ     cmerex          ;if null then done
00B8CF  2  C9 20                CMP     #' '            ;if space
00B8D1  2  F0 06                BEQ     cmerex          ;then done
00B8D3  2  20 6D BC             JSR     cotsxy          ;output with save
00B8D6  2  C8                   INY                     ;point to next
00B8D7  2  D0 F1                BNE     cmerlp          ;and loop
00B8D9  2               cmerex:
00B8D9  2  A9 3F                LDA     #'?'            ;send a
00B8DB  2  20 EB BB             JSR     chrout          ;question mark
00B8DE  2  4C 1B B8             JMP     ccmlpe          ;and start over
00B8E1  2               ;execute dir command
00B8E1  2               ; dir <afn>
00B8E1  2               dir:
00B8E1  2  20 A0 BC             JSR     prslin          ;find object file
00B8E4  2  20 A6 BD             JSR     clrslt          ;clear auto and select
00B8E7  2  A9 20                LDA     #' '            ;if name
00B8E9  2  CD BF BF             CMP     fcbone+1        ;and
00B8EC  2  D0 0F                BNE     findfr          ;type are
00B8EE  2  CD C7 BF             CMP     fcbone+9        ;not empty
00B8F1  2  D0 0A                BNE     findfr          ;then use it
00B8F3  2  A9 3F                LDA     #'?'            ;else
00B8F5  2  A0 0B                LDY     #11             ;fill
00B8F7  2               fillqu:
00B8F7  2  99 BE BF             STA     fcbone,y        ;fcb
00B8FA  2  88                   DEY                     ;with
00B8FB  2  D0 FA                BNE     fillqu          ;question marks
00B8FD  2               findfr:
00B8FD  2  20 5A BC             JSR     srchf1          ;search for first match
00B900  2  30 58                BMI     notfnd          ;error if none
00B902  2               fnddir:
00B902  2  AD F2 BF             LDA     sixten          ;set across
00B905  2  8D F1 BF             STA     across          ;to four
00B908  2  20 DC BB             JSR     ccrlf           ;do a crlf
00B90B  2               
00B90B  2               dirl:
00B90B  2  20 67 BC             JSR     hdr             ;do header
00B90E  2  A9 3A                LDA     #':'            ;then a
00B910  2  20 EB BB             JSR     chrout          ;colon
00B913  2  AD EA BF             LDA     diradd          ;get number
00B916  2  0A                   ASL     a               ;and
00B917  2  0A                   ASL     a               ;multiply
00B918  2  0A                   ASL     a               ;by
00B919  2  0A                   ASL     a               ;thirty two
00B91A  2  0A                   ASL     a               ;then
00B91B  2  29 60                AND     #%01100000      ;mask out insignificant
00B91D  2  A8                   TAY                     ;make a pointer
00B91E  2  C8                   INY                     ;and bump
00B91F  2  A2 01                LDX     #1              ;set counter
00B921  2               nmelpe:
00B921  2  B9 28 01             LDA     dflbuf,y        ;get name
00B924  2  29 7F                AND     #$7F            ;mask out read only bit
00B926  2  20 6D BC             JSR     cotsxy          ;else send to console
00B929  2               noname:
00B929  2  C8                   INY                     ;bump index
00B92A  2  E8                   INX                     ;and count
00B92B  2  E0 0C                CPX     #12             ;if count is 12
00B92D  2  F0 0C                BEQ     endnme          ;then done
00B92F  2  E0 09                CPX     #9              ;or if not 9
00B931  2  D0 EE                BNE     nmelpe          ;then loop
00B933  2  A9 2E                LDA     #'.'            ;else send
00B935  2  20 6D BC             JSR     cotsxy          ;a period
00B938  2  4C 21 B9             JMP     nmelpe          ;and loop
00B93B  2               endnme:
00B93B  2  20 F3 BB             JSR     chkcst          ;check console status
00B93E  2  D0 19                BNE     extdir          ;if key down quit
00B940  2  20 92 BC             JSR     setone          ;else point to fcb
00B943  2  20 0B BC             JSR     srchnx          ;else search for next
00B946  2  8D EA BF             STA     diradd          ;save number
00B949  2  30 0E                BMI     extdir          ;quit if not found
00B94B  2  CE F1 BF             DEC     across          ;drop count
00B94E  2  F0 B2                BEQ     fnddir          ;new line if 0
00B950  2  20 E9 BB             JSR     spcout          ;send
00B953  2  20 E9 BB             JSR     spcout          ;two spaces
00B956  2  4C 0B B9             JMP     dirl            ;and stay
00B959  2               extdir:
00B959  2  60                   RTS                     ;else done
00B95A  2               ;not found error handler
00B95A  2               notfnd:
00B95A  2  A0 34                LDY     #ntfnms         ;point to message
00B95C  2  4C BB BD             JMP     sndmsg          ;send and exit
00B95F  2               ;execute ren command
00B95F  2               ; ren <ufn> <ufn>
00B95F  2               ;where first ufn is from name and second is to name
00B95F  2               ren:
00B95F  2  20 A0 BC             JSR     prslin          ;get old name
00B962  2  D0 57                BNE     renerr          ;error if afn
00B964  2  20 99 BC             JSR     tmpold          ;save drive
00B967  2  20 A6 BD             JSR     clrslt          ;clear auto and select
00B96A  2  20 5A BC             JSR     srchf1          ;if file does not exist
00B96D  2  30 4F                BMI     fntfnd          ;then an error
00B96F  2  20 DB BD             JSR     frssec          ;move name to second half
00B972  2  AC E2 BF             LDY     cnbfpt          ;get pointer
00B975  2  B9 3F BF             LDA     cnstxt,y        ;and then char
00B978  2  C9 20                CMP     #' '            ;if not a space
00B97A  2  D0 3C                BNE     rensyn          ;then error
00B97C  2  20 A0 BC             JSR     prslin          ;get new name
00B97F  2  D0 37                BNE     rensyn          ;error if afn
00B981  2  AD E4 BF             LDA     tmpdsk          ;get new drive
00B984  2  F0 12                BEQ     nonwdr          ;if zero ok
00B986  2  CD EE BF             CMP     oldtmp          ;compare to old
00B989  2  F0 0D                BEQ     nonwdr          ;ok if same
00B98B  2  38                   SEC                     ;drop for default check
00B98C  2  E9 01                SBC     #1
00B98E  2  CD E3 BF             CMP     dfldsk          ;if not default
00B991  2  D0 25                BNE     rensyn          ;is error
00B993  2  AD EE BF             LDA     oldtmp          ;and then if from not
00B996  2  D0 20                BNE     rensyn          ;default is error
00B998  2               nonwdr:
00B998  2  AD EE BF             LDA     oldtmp          ;else get old
00B99B  2  8D E4 BF             STA     tmpdsk          ;and save
00B99E  2  A9 00                LDA     #0              ;clear
00B9A0  2  8D CE BF             STA     fcbone+16
00B9A3  2  20 A6 BD             JSR     clrslt          ;reselect
00B9A6  2  20 5A BC             JSR     srchf1          ;search for old
00B9A9  2  10 09                BPL     filexs          ;error if found
00B9AB  2  20 DB BD             JSR     frssec          ;swap names
00B9AE  2  20 92 BC             JSR     setone          ;point to fcb
00B9B1  2  4C 22 BC             JMP     renmfl          ;and do it
00B9B4  2               ;ren file exists error handler
00B9B4  2               filexs:
00B9B4  2  A0 3E                LDY     #flexms         ;point to
00B9B6  2  D0 08                BNE     remsg           ;and send
00B9B8  2               ;ren syntax error handler
00B9B8  2               rensyn:
00B9B8  2  20 2F BC             JSR     rstddr          ;restore default
00B9BB  2               renerr:
00B9BB  2  4C C4 B8             JMP     cmderr          ;do error
00B9BE  2               ;ren source file not found error handler
00B9BE  2               fntfnd:
00B9BE  2  A0 34                LDY     #ntfnms         ;point to
00B9C0  2               remsg:
00B9C0  2  4C BB BD             JMP     sndmsg          ;and send
00B9C3  2               ;execute save command
00B9C3  2               ; save <length> <drive:>ufn (<address>)
00B9C3  2               save:
00B9C3  2  A9 00                LDA     #<tea           ;set start address to tea start
00B9C5  2  A0 08                LDY     #>tea
00B9C7  2  8D F8 BF             STA     sadr
00B9CA  2  8C F9 BF             STY     sadr+1
00B9CD  2  20 00 BE             JSR     bldnum          ;calculate length
00B9D0  2  D0 7A                BNE     saverr          ;error if > 255 pages
00B9D2  2  8D ED BF             STA     length          ;else save low
00B9D5  2  0D ED BF             ORA     length          ;test for zero length
00B9D8  2  F0 72                BEQ     saverr          ;error if is
00B9DA  2  20 A0 BC             JSR     prslin          ;get file name
00B9DD  2  D0 6D                BNE     saverr          ;error if afn
00B9DF  2  20 DB BD             JSR     frssec          ;move name to second half
00B9E2  2  20 99 BC             JSR     tmpold          ;save drive
00B9E5  2  20 00 BE             JSR     bldnum          ;it is so find value
00B9E8  2  AE BF BF             LDX     fcbone+1        ;see if there
00B9EB  2  E0 20                CPX     #' '
00B9ED  2  F0 0A                BEQ     nosadr          ;it is not
00B9EF  2  8D F8 BF             STA     sadr            ;and set address
00B9F2  2  8C F9 BF             STY     sadr+1
00B9F5  2  C0 02                CPY     #2              ;make sure is high enough
00B9F7  2  90 53                BCC     saverr          ;error if not
00B9F9  2               nosadr:
00B9F9  2  20 EE BD             JSR     secfrs          ;move name back
00B9FC  2  20 A6 BD             JSR     clrslt          ;clear auto and select
00B9FF  2  20 0F BC             JSR     dlt1            ;delete
00BA02  2  20 92 BC             JSR     setone          ;then create
00BA05  2  20 1E BC             JSR     cratfl          ;new file
00BA08  2  30 45                BMI     noroom          ;say no room if error
00BA0A  2  20 45 BC             JSR     open1           ;open file
00BA0D  2  30 44                BMI     noopen          ;if error
00BA0F  2  18                   CLC                     ;now find end page
00BA10  2  AD F9 BF             LDA     sadr+1
00BA13  2  6D ED BF             ADC     length
00BA16  2  8D ED BF             STA     length
00BA19  2  AD F8 BF             LDA     sadr            ;get start address
00BA1C  2  AC F9 BF             LDY     sadr+1
00BA1F  2               wrtmre:
00BA1F  2  8D EF BF             STA     dskbuf          ;set
00BA22  2  8C F0 BF             STY     dskbuf+1        ;buffer
00BA25  2  20 C1 CA             JSR     mv128           ;move data to buffer
00BA28  2  20 92 BC             JSR     setone          ;point to fcb
00BA2B  2  20 1A BC             JSR     wrrcrd          ;write record
00BA2E  2  D0 27                BNE     wrterr          ;exit if error
00BA30  2  18                   CLC                     ;else
00BA31  2  AD EF BF             LDA     dskbuf          ;get old
00BA34  2  AC F0 BF             LDY     dskbuf+1        ;buffer
00BA37  2  69 80                ADC     #128            ;add 128
00BA39  2  90 03                BCC     donotc          ;if carry
00BA3B  2  C8                   INY                     ;bump upper
00BA3C  2  F0 05                BEQ     clssav          ;done if page zero
00BA3E  2               donotc:
00BA3E  2  CC ED BF             CPY     length          ;loop if upper
00BA41  2  D0 DC                BNE     wrtmre          ;not at limit
00BA43  2               clssav:
00BA43  2  20 92 BC             JSR     setone          ;else point to
00BA46  2  20 03 BC             JSR     clsefl          ;and close file
00BA49  2  30 10                BMI     cantcl          ;say so if error
00BA4B  2               extera:
00BA4B  2  60                   RTS
00BA4C  2               ;save error handler
00BA4C  2               saverr:
00BA4C  2  4C C4 B8             JMP     cmderr          ;do error
00BA4F  2               ;save no room error handler
00BA4F  2               noroom:
00BA4F  2  A0 01                LDY     #nospms         ;point to
00BA51  2  D0 0A                BNE     semsg           ;and send
00BA53  2               ;save can not open error handler
00BA53  2               noopen:
00BA53  2  A0 55                LDY     #cnnoms         ;point to
00BA55  2  D0 06                BNE     semsg           ;and send
00BA57  2               ;save write error handler
00BA57  2               wrterr:
00BA57  2  A0 62                LDY     #wrerms         ;point
00BA59  2  D0 02                BNE     semsg           ;to and send
00BA5B  2               ;save can not close error
00BA5B  2               cantcl:
00BA5B  2  A0 0A                LDY     #ntclms         ;point to
00BA5D  2               semsg:
00BA5D  2  4C BB BD             JMP     sndmsg          ;and send
00BA60  2               ;execute era command
00BA60  2               ; era <afn>
00BA60  2               era:
00BA60  2  20 A0 BC             JSR     prslin          ;get file name
00BA63  2  C9 0B                CMP     #11             ;if not all ?
00BA65  2  D0 13                BNE     nteral          ;then skip verify
00BA67  2  A0 18                LDY     #alflms         ;else point to
00BA69  2  20 BB BD             JSR     sndmsg          ;and send all files
00BA6C  2  20 E5 BB             JSR     cnsrde          ;get an input
00BA6F  2  48                   PHA                     ;and save
00BA70  2  20 DC BB             JSR     ccrlf           ;do a cr lf
00BA73  2  68                   PLA                     ;restore char
00BA74  2  29 5F                AND     #$5f            ;convert to upper case
00BA76  2  C9 59                CMP     #'Y'            ;if not y
00BA78  2  D0 D1                BNE     extera          ;then quit
00BA7A  2               nteral:
00BA7A  2  20 A6 BD             JSR     clrslt          ;clear auto and select
00BA7D  2  4C 0F BC             JMP     dlt1            ;delete first
00BA80  2               ;execute type command
00BA80  2               ; type d:ufn
00BA80  2               type:
00BA80  2  20 A0 BC             JSR     prslin          ;get file
00BA83  2  D0 30                BNE     typafn          ;error if afn
00BA85  2  20 42 BC             JSR     casdo1          ;clear - select - open file 1
00BA88  2  30 32                BMI     notype          ;error if not found
00BA8A  2  20 DC BB             JSR     ccrlf           ;else do cr lf
00BA8D  2               typmre:
00BA8D  2  20 54 BC             JSR     read1           ;read record
00BA90  2  F0 04                BEQ     okread          ;if ok continue
00BA92  2  10 20                BPL     exttyp          ;exit if just end
00BA94  2  30 22                BMI     typerr          ;else error
00BA96  2               okread:
00BA96  2  A2 00                LDX     #0              ;clear index
00BA98  2               typlpe:
00BA98  2  BD 28 01             LDA     dflbuf,x        ;get char
00BA9B  2  C9 1A                CMP     #eof            ;if eof
00BA9D  2  F0 15                BEQ     exttyp          ;then exit
00BA9F  2  20 6D BC             JSR     cotsxy          ;else send
00BAA2  2  20 F3 BB             JSR     chkcst          ;if key down
00BAA5  2  D0 08                BNE     exttok          ;then exit
00BAA7  2  AE EB BF             LDX     savx            ;else get index
00BAAA  2  E8                   INX                     ;bump it
00BAAB  2  10 EB                BPL     typlpe          ;and loop if < 128
00BAAD  2  30 DE                BMI     typmre          ;else read more
00BAAF  2               exttok:
00BAAF  2  A2 06                LDX     #6              ;clear console
00BAB1  2  20 03 01             JSR     pemjmp          ;with no echo
00BAB4  2               exttyp:
00BAB4  2  60                   RTS
00BAB5  2               ;type syntax error handler
00BAB5  2               typafn:
00BAB5  2  4C C4 B8             JMP     cmderr          ;error return
00BAB8  2               ;type read error handler
00BAB8  2               typerr:
00BAB8  2  A0 29                LDY     #rderms         ;point to
00BABA  2  D0 02                BNE     temsg           ;and send
00BABC  2               ;type not found error handler
00BABC  2               notype:
00BABC  2  A0 34                LDY     #ntfnms         ;point to
00BABE  2               temsg:
00BABE  2  4C BB BD             JMP     sndmsg          ;and send
00BAC1  2               ;execute load command
00BAC1  2               ; load <ufn> (<address>)
00BAC1  2               load:
00BAC1  2  20 D0 BD             JSR     setddb          ;set load start to tea start
00BAC4  2  20 A0 BC             JSR     prslin          ;build fcb
00BAC7  2  D0 EC                BNE     typafn          ;error if afn
00BAC9  2  20 DB BD             JSR     frssec          ;save in second half
00BACC  2  20 99 BC             JSR     tmpold          ;save file
00BACF  2  20 00 BE             JSR     bldnum          ;find start address
00BAD2  2  AE BF BF             LDX     fcbone+1        ;see if number
00BAD5  2  E0 20                CPX     #' '
00BAD7  2  F0 03                BEQ     usedfl          ;if none use default
00BAD9  2  20 D4 BD             JSR     setdb           ;and set
00BADC  2               usedfl:
00BADC  2  20 EE BD             JSR     secfrs          ;move name back
00BADF  2  20 42 BC             JSR     casdo1          ;clear - select - open file 1
00BAE2  2  30 D8                BMI     notype          ;exit if not found
00BAE4  2  AD EF BF             LDA     dskbuf          ;get load start
00BAE7  2  AC F0 BF             LDY     dskbuf+1
00BAEA  2               lcmdlp:
00BAEA  2  20 2A BC             JSR     setbuf          ;set as disk buffer
00BAED  2  20 54 BC             JSR     read1           ;read record
00BAF0  2  D0 06                BNE     loadnd          ;done if not zero
00BAF2  2  20 AE CA             JSR     adjdb           ;bump address
00BAF5  2  4C EA BA             JMP     lcmdlp          ;and loop
00BAF8  2               loadnd:
00BAF8  2  30 BE                BMI     typerr          ;if error say so
00BAFA  2  4C 9F BD             JMP     stdflb          ;back to default buffer
00BAFD  2               ;execute go command
00BAFD  2               ; go (<address>)
00BAFD  2               go:
00BAFD  2  20 00 BE             JSR     bldnum          ;get address
00BB00  2  AE BF BF             LDX     fcbone+1        ;get first char
00BB03  2  E0 20                CPX     #' '            ;see if nothing
00BB05  2  F0 03                BEQ     nolnum          ;nothing so use tea
00BB07  2  4C 71 BB             JMP     godoit          ;then execute
00BB0A  2               nolnum:
00BB0A  2  4C 6D BB             JMP     gotea
00BB0D  2               ;execute trns (transient) command
00BB0D  2               ; <ufn> (<fn>) (<fn>)
00BB0D  2               trns:
00BB0D  2  AD BF BF             LDA     fcbone+1        ;get first char
00BB10  2  C9 20                CMP     #' '            ;if not space
00BB12  2  D0 11                BNE     chktyp          ;check type
00BB14  2  AD E4 BF             LDA     tmpdsk          ;else test temp
00BB17  2  F0 09                BEQ     skpdrv          ;if none skip
00BB19  2  38                   SEC                     ;else convert
00BB1A  2  E9 01                SBC     #1              ;to number
00BB1C  2  8D E3 BF             STA     dfldsk          ;set default
00BB1F  2  20 FB BB             JSR     slctds          ;and select
00BB22  2               skpdrv:
00BB22  2  4C B3 B8             JMP     extwod          ;return
00BB25  2               chktyp:
00BB25  2  AD C7 BF             LDA     fcbone+9        ;get type
00BB28  2  C9 20                CMP     #' '            ;if space
00BB2A  2  F0 03                BEQ     typemp          ;then ok
00BB2C  2  4C D4 BB             JMP     trnerr          ;else error
00BB2F  2               typemp:
00BB2F  2  A2 02                LDX     #2              ;make
00BB31  2               setcom:
00BB31  2  BD DF BF             LDA     typcom,x        ;type
00BB34  2  9D C7 BF             STA     fcbone+9,x      ;com
00BB37  2  CA                   DEX                     ;then
00BB38  2  10 F7                BPL     setcom          ;continue
00BB3A  2  20 42 BC             JSR     casdo1          ;clear - select - open file one
00BB3D  2  10 03                BPL     gottrn          ;jump if ok
00BB3F  2  4C D1 BB             JMP     topner          ;else do error
00BB42  2               gottrn:
00BB42  2  20 D0 BD             JSR     setddb          ;set start to tea
00BB45  2               nxtrcr:
00BB45  2  20 2A BC             JSR     setbuf          ;set address
00BB48  2  20 54 BC             JSR     read1           ;read fcb 1
00BB4B  2  D0 1E                BNE     endlde          ;branch if error or eof
00BB4D  2  20 AE CA             JSR     adjdb           ;adjust address up by 128
00BB50  2  CD 8C BE             CMP     ccmvc           ;if new low
00BB53  2  90 07                BCC     tryhig          ;ok try high
00BB55  2  CC 8D BE             CPY     ccmvc+1         ;else if high
00BB58  2  90 EB                BCC     nxtrcr          ;ok do more
00BB5A  2  B0 07                BCS     chklnd          ;else check for end
00BB5C  2               tryhig:
00BB5C  2  CC 8D BE             CPY     ccmvc+1         ;if high less
00BB5F  2  90 E4                BCC     nxtrcr          ;then ok
00BB61  2  F0 E2                BEQ     nxtrcr          ;or ok if same
00BB63  2               chklnd:
00BB63  2  20 9F BD             JSR     stdflb          ;set buffer to default
00BB66  2  20 54 BC             JSR     read1           ;read (should be eof)
00BB69  2  F0 6C                BEQ     tlderr          ;error if more
00BB6B  2               endlde:
00BB6B  2  30 6A                BMI     tlderr          ;do error
00BB6D  2               gotea:
00BB6D  2  A9 00                LDA     #<tea           ;set go address to tea start
00BB6F  2  A0 08                LDY     #>tea
00BB71  2               godoit:
00BB71  2  8D C6 BB             STA     do+1            ;set to ay
00BB74  2  8C C7 BB             STY     do+2
00BB77  2  20 2F BC             JSR     rstddr          ;else restore default
00BB7A  2  20 A0 BC             JSR     prslin          ;parse file
00BB7D  2  AD E4 BF             LDA     tmpdsk          ;set auto
00BB80  2  8D BE BF             STA     fcbone          ;select position
00BB83  2  A2 10                LDX     #16             ;do a second
00BB85  2  20 A2 BC             JSR     prsmre          ;fcb if there
00BB88  2  AD E4 BF             LDA     tmpdsk          ;set auto select
00BB8B  2  8D CE BF             STA     fcbone+16       ;again
00BB8E  2  A0 00                LDY     #0              ;clear record
00BB90  2  8C DE BF             STY     fcbone+32       ;counter
00BB93  2  A2 20                LDX     #32             ;move
00BB95  2               movfcb:
00BB95  2  BD BE BF             LDA     fcbone,x        ;all
00BB98  2  9D 07 01             STA     dflfcb,x        ;to
00BB9B  2  CA                   DEX                     ;default
00BB9C  2  10 F7                BPL     movfcb          ;fcb
00BB9E  2  E8                   INX                     ;set x to zero
00BB9F  2               tstbuf:
00BB9F  2  B9 3F BF             LDA     cnstxt,y        ;get char
00BBA2  2  F0 07                BEQ     isnull          ;if null jump
00BBA4  2  C9 20                CMP     #' '            ;or if space
00BBA6  2  F0 03                BEQ     isnull          ;jump
00BBA8  2  C8                   INY                     ;else bump pointer
00BBA9  2  D0 F4                BNE     tstbuf          ;and loop
00BBAB  2               isnull:
00BBAB  2  A9 00                LDA     #0              ;clear
00BBAD  2  8D 28 01             STA     dflbuf          ;count
00BBB0  2               movbuf:
00BBB0  2  B9 3F BF             LDA     cnstxt,y        ;get char
00BBB3  2  9D 29 01             STA     dflbuf+1,x      ;and move
00BBB6  2  F0 07                BEQ     fillov          ;exit if null
00BBB8  2  E8                   INX                     ;increment
00BBB9  2  C8                   INY                     ;counters
00BBBA  2  EE 28 01             INC     dflbuf          ;and length
00BBBD  2  D0 F1                BNE     movbuf          ;and loop
00BBBF  2               fillov:
00BBBF  2  20 DC BB             JSR     ccrlf           ;do a cr lf
00BBC2  2  20 9F BD             JSR     stdflb          ;set default
00BBC5  2               do:
00BBC5  2  20 00 08             JSR     tea             ;execute
00BBC8  2  AD E3 BF             LDA     dfldsk          ;get default
00BBCB  2  20 FB BB             JSR     slctds          ;and set
00BBCE  2  4C 1B B8             JMP     ccmlpe          ;then loop
00BBD1  2               ;trns syntax error handler
00BBD1  2               topner:
00BBD1  2  20 2F BC             JSR     rstddr          ;restore default
00BBD4  2               trnerr:
00BBD4  2  4C C4 B8             JMP     cmderr          ;do error
00BBD7  2               ;trns load error
00BBD7  2               tlderr:
00BBD7  2  A0 4A                LDY     #lderms         ;point to
00BBD9  2  4C BB BD             JMP     sndmsg          ;and send
00BBDC  2               ;carriage return and linefeed
00BBDC  2               ccrlf:
00BBDC  2  A9 0D                LDA     #cr             ;get a cr
00BBDE  2  20 EB BB             JSR     chrout          ;send
00BBE1  2  A9 0A                LDA     #lf             ;get a lf
00BBE3  2  D0 06                BNE     chrout          ;and send
00BBE5  2               ;pem entry routines
00BBE5  2               cnsrde:
00BBE5  2  A2 01                LDX     #1              ;console read
00BBE7  2  D0 43                BNE     pemgo
00BBE9  2               spcout:
00BBE9  2  A9 20                LDA     #' '            ;output space
00BBEB  2               chrout:
00BBEB  2  A2 02                LDX     #2              ;console output
00BBED  2  D0 3D                BNE     pemgo
00BBEF  2               rdebuf:
00BBEF  2  A2 0A                LDX     #10             ;buffered input
00BBF1  2  D0 39                BNE     pemgo
00BBF3  2               chkcst:
00BBF3  2  A2 0B                LDX     #11             ;check console
00BBF5  2  D0 35                BNE     pemgo
00BBF7  2               rstdsk:
00BBF7  2  A2 0D                LDX     #13             ;initialize system
00BBF9  2  D0 31                BNE     pemgo
00BBFB  2               slctds:
00BBFB  2  A2 0E                LDX     #14             ;select drive
00BBFD  2  D0 2D                BNE     pemgo
00BBFF  2               openfl:
00BBFF  2  A2 0F                LDX     #15             ;open file
00BC01  2  D0 29                BNE     pemgo
00BC03  2               clsefl:
00BC03  2  A2 10                LDX     #16             ;close file
00BC05  2  D0 25                BNE     pemgo
00BC07  2               srchfr:
00BC07  2  A2 11                LDX     #17             ;first match
00BC09  2  D0 21                BNE     pemgo
00BC0B  2               srchnx:
00BC0B  2  A2 12                LDX     #18             ;next match
00BC0D  2  D0 1D                BNE     pemgo
00BC0F  2               ;delete file one
00BC0F  2               dlt1:
00BC0F  2  20 92 BC             JSR     setone          ;point to fcb
00BC12  2               dltfil:
00BC12  2  A2 13                LDX     #19             ;delete file
00BC14  2  D0 16                BNE     pemgo
00BC16  2               rdrcrd:
00BC16  2  A2 14                LDX     #20             ;read record
00BC18  2  D0 12                BNE     pemgo
00BC1A  2               wrrcrd:
00BC1A  2  A2 15                LDX     #21             ;write record
00BC1C  2  D0 0E                BNE     pemgo
00BC1E  2               cratfl:
00BC1E  2  A2 16                LDX     #22             ;create file
00BC20  2  D0 0A                BNE     pemgo
00BC22  2               renmfl:
00BC22  2  A2 17                LDX     #23             ;rename file
00BC24  2  D0 06                BNE     pemgo
00BC26  2               intdsk:
00BC26  2  A2 19                LDX     #25             ;read drive num
00BC28  2  D0 02                BNE     pemgo
00BC2A  2               setbuf:
00BC2A  2  A2 1A                LDX     #26             ;set buffer add
00BC2C  2               pemgo:
00BC2C  2  4C 03 01             JMP     pemjmp          ;go to pem
00BC2F  2               ;restore default drive
00BC2F  2               rstddr:
00BC2F  2  AD E4 BF             LDA     tmpdsk          ;if temp drive
00BC32  2  F0 1F                BEQ     extddr          ;zero then exit
00BC34  2  38                   SEC                     ;else
00BC35  2  E9 01                SBC     #1              ;subtract one
00BC37  2  CD E3 BF             CMP     dfldsk          ;compare to default
00BC3A  2  F0 17                BEQ     extddr          ;exit if same
00BC3C  2               seldfl:
00BC3C  2  AD E3 BF             LDA     dfldsk          ;else get default
00BC3F  2  4C FB BB             JMP     slctds          ;select
00BC42  2               ;clear auto - select disk - open file at fcbone
00BC42  2               casdo1:
00BC42  2  20 A6 BD             JSR     clrslt          ;clear auto and select
00BC45  2               ;open file one
00BC45  2               ; returns:n=1 if not found
00BC45  2               open1:
00BC45  2  A9 00                LDA     #0              ;clear
00BC47  2  8D DE BF             STA     fcbone+32       ;record number
00BC4A  2  20 92 BC             JSR     setone          ;point to fcb
00BC4D  2  20 FF BB             JSR     openfl          ;open it
00BC50  2  8D EA BF             STA     diradd          ;save number
00BC53  2               extddr:
00BC53  2  60                   RTS
00BC54  2               ;read file one
00BC54  2               read1:
00BC54  2  20 92 BC             JSR     setone          ;point to fcb
00BC57  2  4C 16 BC             JMP     rdrcrd          ;do read
00BC5A  2               ;search for first file one
00BC5A  2               ; returns:n=1 if not found
00BC5A  2               srchf1:
00BC5A  2  20 92 BC             JSR     setone          ;point to fcb
00BC5D  2  20 07 BC             JSR     srchfr          ;search for first
00BC60  2  8D EA BF             STA     diradd          ;save number
00BC63  2  60                   RTS
00BC64  2               ;header output
00BC64  2               hdrout:
00BC64  2  20 DC BB             JSR     ccrlf           ;do cr lf
00BC67  2               hdr:
00BC67  2  20 26 BC             JSR     intdsk          ;get drive number
00BC6A  2  18                   CLC                     ;make
00BC6B  2  69 41                ADC     #'A'            ;a letter
00BC6D  2               ;output with save of x and y
00BC6D  2               ;this routine calls the pem resident routine
00BC6D  2               ;tstchr to see if a char is a printing char.
00BC6D  2               ;if it is then c=1 upon return from tstchr.
00BC6D  2               cotsxy:
00BC6D  2  8E EB BF             STX     savx            ;save x
00BC70  2  8C EC BF             STY     savy            ;and y
00BC73  2  20 B8 C8             JSR     tstchr          ;see if printing
00BC76  2  B0 10                BCS     isprnt          ;jump if is
00BC78  2  48                   PHA                     ;else save
00BC79  2  AD 16 CC             LDA     sysdef+4        ;get invert
00BC7C  2  20 EB BB             JSR     chrout          ;send it
00BC7F  2  68                   PLA                     ;get char
00BC80  2  09 40                ORA     #'@'            ;make printing
00BC82  2  20 EB BB             JSR     chrout          ;send it
00BC85  2  AD 15 CC             LDA     sysdef+3        ;get normal
00BC88  2               isprnt:
00BC88  2  20 EB BB             JSR     chrout          ;do output
00BC8B  2  AC EC BF             LDY     savy            ;get y
00BC8E  2  AE EB BF             LDX     savx            ;and x
00BC91  2  60                   RTS
00BC92  2               ;set up fcb one pointer
00BC92  2               setone:
00BC92  2  AD 8F BE             LDA     fcb1vc          ;low
00BC95  2  AC 90 BE             LDY     fcb1vc+1        ;and high
00BC98  2  60                   RTS
00BC99  2               ;save tmpdsk in oldtmp
00BC99  2               tmpold:
00BC99  2  AD E4 BF             LDA     tmpdsk
00BC9C  2  8D EE BF             STA     oldtmp
00BC9F  2  60                   RTS
00BCA0  2               ;parse command line
00BCA0  2               prslin:
00BCA0  2  A2 00                LDX     #0              ;clear index
00BCA2  2               prsmre:
00BCA2  2  8A                   TXA                     ;save
00BCA3  2  48                   PHA                     ;index
00BCA4  2  A9 00                LDA     #0              ;clear temp
00BCA6  2  8D E4 BF             STA     tmpdsk          ;drive flag
00BCA9  2  AC E2 BF             LDY     cnbfpt          ;get buffer pointer
00BCAC  2  20 6D BD             JSR     skpspc          ;find first non-space
00BCAF  2  8C E9 BF             STY     curpnt          ;save index
00BCB2  2  F0 0D                BEQ     nulchr          ;jump if null
00BCB4  2  29 0F                AND     #%00001111      ;else look at 4 lsbs
00BCB6  2  48                   PHA                     ;and save
00BCB7  2  C8                   INY                     ;point to next char
00BCB8  2  B9 3F BF             LDA     cnstxt,y        ;and get it
00BCBB  2  C9 3A                CMP     #':'            ;if a colon
00BCBD  2  F0 0A                BEQ     drvinp          ;jump and set drive
00BCBF  2  68                   PLA                     ;else clear stack
00BCC0  2  88                   DEY                     ;backup index
00BCC1  2               nulchr:
00BCC1  2  AD E3 BF             LDA     dfldsk          ;set automatic
00BCC4  2  9D BE BF             STA     fcbone,x        ;to default
00BCC7  2  10 08                BPL     trynme          ;then parse name
00BCC9  2               drvinp:
00BCC9  2  68                   PLA                     ;get number
00BCCA  2  8D E4 BF             STA     tmpdsk          ;set temp flag
00BCCD  2  9D BE BF             STA     fcbone,x        ;and fcb
00BCD0  2  C8                   INY                     ;point past colon
00BCD1  2               trynme:
00BCD1  2  A9 08                LDA     #8              ;set name count
00BCD3  2  8D E8 BF             STA     ccmcount        ;to eight
00BCD6  2               tstnme:
00BCD6  2  20 7A BD             JSR     tstlgl          ;test for illegal
00BCD9  2  F0 1D                BEQ     flnmsp          ;if illegal jump
00BCDB  2  E8                   INX                     ;bump pointer
00BCDC  2  C9 2A                CMP     #'*'            ;if not *
00BCDE  2  D0 07                BNE     notafn          ;skip ? fill
00BCE0  2  A9 3F                LDA     #'?'            ;get a ?
00BCE2  2  9D BE BF             STA     fcbone,x        ;store
00BCE5  2  D0 04                BNE     nxtout          ;and jump
00BCE7  2               notafn:
00BCE7  2  9D BE BF             STA     fcbone,x        ;store char
00BCEA  2  C8                   INY                     ;bump source
00BCEB  2               nxtout:
00BCEB  2  CE E8 BF             DEC     ccmcount        ;drop counter down
00BCEE  2  D0 E6                BNE     tstnme          ;and loop
00BCF0  2               skpmre:
00BCF0  2  20 7A BD             JSR     tstlgl          ;if illegal
00BCF3  2  F0 11                BEQ     trytyp          ;try type
00BCF5  2  C8                   INY                     ;else bump index
00BCF6  2  D0 F8                BNE     skpmre          ;and loop
00BCF8  2               flnmsp:
00BCF8  2  E8                   INX                     ;next position
00BCF9  2  A9 20                LDA     #' '            ;get a space
00BCFB  2  9D BE BF             STA     fcbone,x        ;store
00BCFE  2  CE E8 BF             DEC     ccmcount        ;count down
00BD01  2  D0 F5                BNE     flnmsp          ;and loop
00BD03  2  B9 3F BF             LDA     cnstxt,y        ;get char again
00BD06  2               trytyp:
00BD06  2  48                   PHA                     ;save char
00BD07  2  A9 03                LDA     #3              ;set count
00BD09  2  8D E8 BF             STA     ccmcount        ;to three
00BD0C  2  68                   PLA                     ;get char
00BD0D  2  C9 2E                CMP     #'.'            ;if not .
00BD0F  2  D0 23                BNE     fltysp          ;then fill spaces
00BD11  2  C8                   INY                     ;else bump source
00BD12  2               tsttyp:
00BD12  2  20 7A BD             JSR     tstlgl          ;if not legal
00BD15  2  F0 1D                BEQ     fltysp          ;then fill spaces
00BD17  2  E8                   INX                     ;else bump index
00BD18  2  C9 2A                CMP     #'*'            ;if not *
00BD1A  2  D0 07                BNE     notaft          ;then skip fill
00BD1C  2  A9 3F                LDA     #'?'            ;else get ?
00BD1E  2  9D BE BF             STA     fcbone,x        ;move to fcb
00BD21  2  D0 04                BNE     mrtyfl          ;and loop
00BD23  2               notaft:
00BD23  2  9D BE BF             STA     fcbone,x        ;move char to fcb
00BD26  2  C8                   INY                     ;bump source
00BD27  2               mrtyfl:
00BD27  2  CE E8 BF             DEC     ccmcount        ;count down
00BD2A  2  D0 E6                BNE     tsttyp          ;and loop
00BD2C  2               nttype:
00BD2C  2  20 7A BD             JSR     tstlgl          ;if illegal
00BD2F  2  F0 0E                BEQ     filnul          ;fill out nulls
00BD31  2  C8                   INY                     ;else bump source
00BD32  2  D0 F8                BNE     nttype          ;and loop
00BD34  2               fltysp:
00BD34  2  E8                   INX                     ;bump fcb pointer
00BD35  2  A9 20                LDA     #' '            ;get space
00BD37  2  9D BE BF             STA     fcbone,x        ;put in fcb
00BD3A  2  CE E8 BF             DEC     ccmcount        ;count down
00BD3D  2  D0 F5                BNE     fltysp          ;and continue
00BD3F  2               filnul:
00BD3F  2  A9 03                LDA     #3              ;clear
00BD41  2  8D E8 BF             STA     ccmcount        ;three
00BD44  2               mrnlty:
00BD44  2  E8                   INX                     ;bump fcb pointer
00BD45  2  A9 00                LDA     #0              ;get a zero
00BD47  2  9D BE BF             STA     fcbone,x        ;move to fcb
00BD4A  2  CE E8 BF             DEC     ccmcount        ;count down
00BD4D  2  D0 F5                BNE     mrnlty          ;loop until done
00BD4F  2  8C E2 BF             STY     cnbfpt          ;update start pointer
00BD52  2  A9 00                LDA     #0              ;clear
00BD54  2  8D E8 BF             STA     ccmcount        ;count
00BD57  2  68                   PLA                     ;restore stack
00BD58  2  A8                   TAY                     ;move to index
00BD59  2  A2 0B                LDX     #11             ;counter to 11
00BD5B  2               tstqus:
00BD5B  2  C8                   INY                     ;point to
00BD5C  2  B9 BE BF             LDA     fcbone,y        ;and get char
00BD5F  2  C9 3F                CMP     #'?'            ;if not a ?
00BD61  2  D0 03                BNE     nxtqus          ;then jump
00BD63  2  EE E8 BF             INC     ccmcount        ;else bump count
00BD66  2               nxtqus:
00BD66  2  CA                   DEX                     ;loop until
00BD67  2  D0 F2                BNE     tstqus          ;11 tested
00BD69  2  AD E8 BF             LDA     ccmcount        ;get count
00BD6C  2  60                   RTS                     ;and return
00BD6D  2               ;skip space
00BD6D  2               skpspc:
00BD6D  2  B9 3F BF             LDA     cnstxt,y        ;get char
00BD70  2  F0 07                BEQ     extskp          ;jump if null
00BD72  2  C9 20                CMP     #' '            ;if not space
00BD74  2  D0 03                BNE     extskp          ;then exit
00BD76  2  C8                   INY                     ;else go to next
00BD77  2  D0 F4                BNE     skpspc          ;and test
00BD79  2               extskp:
00BD79  2  60                   RTS
00BD7A  2               ;test legal
00BD7A  2               tstlgl:
00BD7A  2  B9 3F BF             LDA     cnstxt,y        ;get char
00BD7D  2  F0 1C                BEQ     extlgl
00BD7F  2  C9 20                CMP     #' '            ;if space
00BD81  2  90 19                BCC     badinp          ;ok - less is error
00BD83  2  F0 16                BEQ     extlgl
00BD85  2  C9 3D                CMP     #'='
00BD87  2  F0 12                BEQ     extlgl
00BD89  2  C9 2E                CMP     #'.'
00BD8B  2  F0 0E                BEQ     extlgl
00BD8D  2  C9 3A                CMP     #':'
00BD8F  2  F0 0A                BEQ     extlgl
00BD91  2  C9 3B                CMP     #semico
00BD93  2  F0 06                BEQ     extlgl
00BD95  2  C9 3C                CMP     #'<'
00BD97  2  F0 02                BEQ     extlgl
00BD99  2  C9 3E                CMP     #'>'
00BD9B  2               extlgl:
00BD9B  2  60                   RTS
00BD9C  2               badinp:
00BD9C  2  4C C4 B8             JMP     cmderr
00BD9F  2               ;set default buffer address
00BD9F  2               stdflb:
00BD9F  2  A9 28                LDA     #<dflbuf        ;point to
00BDA1  2  A0 01                LDY     #>dflbuf        ;location
00BDA3  2  4C 2A BC             JMP     setbuf          ;and set
00BDA6  2               ;clear automatic and select
00BDA6  2               clrslt:
00BDA6  2  A9 00                LDA     #0              ;clear auto
00BDA8  2  8D BE BF             STA     fcbone          ;select
00BDAB  2               slttmp:
00BDAB  2  AD E4 BF             LDA     tmpdsk          ;get temp
00BDAE  2  F0 1F                BEQ     extsnd          ;if zero exit
00BDB0  2  38                   SEC                     ;else subtract
00BDB1  2  E9 01                SBC     #1              ;one
00BDB3  2  CD E3 BF             CMP     dfldsk          ;if same as default
00BDB6  2  F0 17                BEQ     extsnd          ;then quit
00BDB8  2  4C FB BB             JMP     slctds          ;else set
00BDBB  2               ;send message
00BDBB  2               sndmsg:
00BDBB  2  8C EC BF             STY     savy            ;save index
00BDBE  2  20 DC BB             JSR     ccrlf           ;do cr and lf
00BDC1  2  AC EC BF             LDY     savy            ;get index
00BDC4  2               lpesnd:
00BDC4  2  B9 AA BE             LDA     msgtbl,y        ;get char
00BDC7  2  F0 06                BEQ     extsnd          ;if null quit
00BDC9  2  20 6D BC             JSR     cotsxy          ;else send
00BDCC  2  C8                   INY                     ;point to next
00BDCD  2  D0 F5                BNE     lpesnd          ;and loop
00BDCF  2               extsnd:
00BDCF  2  60                   RTS
00BDD0  2               ;set load start address
00BDD0  2               setddb:
00BDD0  2  A9 00                LDA     #<tea           ;to tea start
00BDD2  2  A0 08                LDY     #>tea
00BDD4  2               setdb:
00BDD4  2  8D EF BF             STA     dskbuf          ;to ay
00BDD7  2  8C F0 BF             STY     dskbuf+1
00BDDA  2  60                   RTS
00BDDB  2               ;move first part of fcb to second half
00BDDB  2               ;and move second part to first part.
00BDDB  2               ;only ren depends upon this routine to actually
00BDDB  2               ;swap fcb halves.
00BDDB  2               ;alters:a,x,p
00BDDB  2               ;returns:x=$ff
00BDDB  2               frssec:
00BDDB  2  A2 0F                LDX     #15             ;set index to last
00BDDD  2               frsclp:
00BDDD  2  BD BE BF             LDA     fcbone,x        ;get byte
00BDE0  2  BC CE BF             LDY     fcbone+16,x
00BDE3  2  9D CE BF             STA     fcbone+16,x     ;move it
00BDE6  2  98                   TYA
00BDE7  2  9D BE BF             STA     fcbone,x
00BDEA  2  CA                   DEX
00BDEB  2  10 F0                BPL     frsclp          ;until 16 moved
00BDED  2  60                   RTS
00BDEE  2               ;move second part of fcb to first half
00BDEE  2               ;restore tmpdsk from save location
00BDEE  2               ;alters:a,x,p
00BDEE  2               ;returns:x=$ff
00BDEE  2               secfrs:
00BDEE  2  A2 0F                LDX     #15             ;set index to last
00BDF0  2               scfrlp:
00BDF0  2  BD CE BF             LDA     fcbone+16,x     ;get byte
00BDF3  2  9D BE BF             STA     fcbone,x        ;move it
00BDF6  2  CA                   DEX
00BDF7  2  10 F7                BPL     scfrlp          ;loop until done
00BDF9  2  AD EE BF             LDA     oldtmp          ;get old flag
00BDFC  2  8D E4 BF             STA     tmpdsk          ;and set
00BDFF  2  60                   RTS
00BE00  2               ;build a number from command line and leave in num
00BE00  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00BE00  2               ;move parse index past number
00BE00  2               ;modifies:all
00BE00  2               ;returns:a,y set to low and high of number
00BE00  2               ;	 flags set according to y which is high part of number
00BE00  2               bldnum:
00BE00  2  A9 09                LDA     #9              ;preset to decimal
00BE02  2  8D F3 BF             STA     moduls
00BE05  2  20 A0 BC             JSR     prslin          ;put in fcb
00BE08  2  AD E4 BF             LDA     tmpdsk          ;if temp
00BE0B  2  D0 67                BNE     numerr          ;is error
00BE0D  2  8D F4 BF             STA     num             ;else clear num
00BE10  2  8D F5 BF             STA     num+1
00BE13  2  A8                   TAY                     ;and index
00BE14  2  B9 BF BF             LDA     fcbone+1,y      ;get first char
00BE17  2  C9 24                CMP     #'$'            ;see if hex signal
00BE19  2  D0 06                BNE     bnumlp          ;skip if not
00BE1B  2  A9 0F                LDA     #15             ;set for modulus
00BE1D  2  8D F3 BF             STA     moduls
00BE20  2  C8                   INY                     ;bump past $
00BE21  2               bnumlp:
00BE21  2  C8                   INY                     ;next char
00BE22  2  B9 BE BF             LDA     fcbone,y        ;get digit
00BE25  2  C9 20                CMP     #' '            ;see if space
00BE27  2  F0 4E                BEQ     endnlp          ;done if is
00BE29  2  20 98 CA             JSR     tstdec          ;see if decimal
00BE2C  2  90 0E                BCC     usedig          ;use if is
00BE2E  2  20 A2 CA             JSR     tsthex          ;see if hex
00BE31  2  B0 41                BCS     numerr          ;error if not
00BE33  2  E9 06                SBC     #6              ;remove offset
00BE35  2  A2 0F                LDX     #15             ;test for hex modulus
00BE37  2  EC F3 BF             CPX     moduls
00BE3A  2  D0 38                BNE     numerr          ;error if not
00BE3C  2               usedig:
00BE3C  2  29 0F                AND     #%00001111      ;eliminate ascii bias
00BE3E  2  48                   PHA                     ;save result
00BE3F  2  AD F4 BF             LDA     num             ;move number to temp
00BE42  2  8D F6 BF             STA     tnum
00BE45  2  AD F5 BF             LDA     num+1
00BE48  2  8D F7 BF             STA     tnum+1
00BE4B  2  AE F3 BF             LDX     moduls          ;get modulus
00BE4E  2  18                   CLC
00BE4F  2               addlpe:
00BE4F  2  AD F4 BF             LDA     num             ;add number to itself
00BE52  2  6D F6 BF             ADC     tnum
00BE55  2  8D F4 BF             STA     num
00BE58  2  AD F5 BF             LDA     num+1           ;modulus times
00BE5B  2  6D F7 BF             ADC     tnum+1
00BE5E  2  8D F5 BF             STA     num+1
00BE61  2  B0 11                BCS     numerr          ;error if carry out
00BE63  2  CA                   DEX
00BE64  2  D0 E9                BNE     addlpe          ;loop if more
00BE66  2  68                   PLA                     ;get input back
00BE67  2  6D F4 BF             ADC     num             ;add in
00BE6A  2  8D F4 BF             STA     num
00BE6D  2  90 B2                BCC     bnumlp          ;loop if no carry
00BE6F  2  EE F5 BF             INC     num+1           ;else bump high
00BE72  2  D0 AD                BNE     bnumlp          ;and loop for more
00BE74  2               ;error in bldnum - handle and quit
00BE74  2               numerr:
00BE74  2  4C C4 B8             JMP     cmderr          ;do general error
00BE77  2               ;end of use of name part - check type
00BE77  2               endnlp:
00BE77  2  AD C7 BF             LDA     fcbone+9        ;get first
00BE7A  2  C9 20                CMP     #' '            ;see if space
00BE7C  2  D0 F6                BNE     numerr          ;error if not
00BE7E  2  AD F4 BF             LDA     num             ;return with result
00BE81  2  AC F5 BF             LDY     num+1
00BE84  2  60                   RTS
00BE85  2               ;relocatable vectors
00BE85  2  4C                   .BYTE   $4c
00BE86  2               cnsbvc:
00BE86  2  3D BF                .WORD   cnsbuf
00BE88  2  4C                   .BYTE   $4c
00BE89  2               extcvc:
00BE89  2  AF B8                .WORD   extcmd-1
00BE8B  2  4C                   .BYTE   $4c
00BE8C  2               ccmvc:
00BE8C  2  03 B8                .WORD   ccm
00BE8E  2  4C                   .BYTE   $4c
00BE8F  2               fcb1vc:
00BE8F  2  BE BF                .WORD   fcbone
00BE91  2               ;function entry vector
00BE91  2               xqfntb:
00BE91  2  4C E1 B8             JMP     dir
00BE94  2  4C C3 B9             JMP     save
00BE97  2  4C 60 BA             JMP     era
00BE9A  2  4C 80 BA             JMP     type
00BE9D  2  4C 5F B9             JMP     ren
00BEA0  2  4C FD BA             JMP     go
00BEA3  2  4C C1 BA             JMP     load
00BEA6  2  4C 0D BB             JMP     trns
00BEA9  2               ;terminator for relocation
00BEA9  2  FF                   .BYTE   $ff
00BEAA  2               ;messages
00BEAA  2               msgtbl:
00BEAA  2  00                   .BYTE   0
00BEAB  2               nospms          = *-msgtbl
00BEAB  2  4E 4F 20 53          .BYTE   "NO SPACE",0
00BEAF  2  50 41 43 45  
00BEB3  2  00           
00BEB4  2               ntclms          = *-msgtbl
00BEB4  2  43 41 4E 20          .BYTE   "CAN NOT CLOSE",0
00BEB8  2  4E 4F 54 20  
00BEBC  2  43 4C 4F 53  
00BEC2  2               alflms          = *-msgtbl
00BEC2  2  41 4C 4C 20          .BYTE   "ALL FILES (Y/N)?",0
00BEC6  2  46 49 4C 45  
00BECA  2  53 20 28 59  
00BED3  2               rderms          = *-msgtbl
00BED3  2  52 45 41 44          .BYTE   "READ ERROR",0
00BED7  2  20 45 52 52  
00BEDB  2  4F 52 00     
00BEDE  2               ntfnms          = *-msgtbl
00BEDE  2  4E 4F 54 20          .BYTE   "NOT FOUND",0
00BEE2  2  46 4F 55 4E  
00BEE6  2  44 00        
00BEE8  2               flexms          = *-msgtbl
00BEE8  2  46 49 4C 45          .BYTE   "FILE EXISTS",0
00BEEC  2  20 45 58 49  
00BEF0  2  53 54 53 00  
00BEF4  2               lderms          = *-msgtbl
00BEF4  2  4C 4F 41 44          .BYTE   "LOAD ERROR",0
00BEF8  2  20 45 52 52  
00BEFC  2  4F 52 00     
00BEFF  2               cnnoms          = *-msgtbl
00BEFF  2  43 41 4E 20          .BYTE   "CAN NOT OPEN",0
00BF03  2  4E 4F 54 20  
00BF07  2  4F 50 45 4E  
00BF0C  2               wrerms          = *-msgtbl
00BF0C  2  57 52 49 54          .BYTE   "WRITE ERROR",0
00BF10  2  45 20 45 52  
00BF14  2  52 4F 52 00  
00BF18  2               ;function name table
00BF18  2               fnctbl:
00BF18  2  44 49 52 20          .BYTE   "DIR ",0
00BF1C  2  00           
00BF1D  2  53 41 56 45          .BYTE   "SAVE ",0
00BF21  2  20 00        
00BF23  2  45 52 41 20          .BYTE   "ERA ",0
00BF27  2  00           
00BF28  2  54 59 50 45          .BYTE   "TYPE ",0
00BF2C  2  20 00        
00BF2E  2  52 45 4E 20          .BYTE   "REN ",0
00BF32  2  00           
00BF33  2  47 4F 20 00          .BYTE   "GO ",0
00BF37  2  4C 4F 41 44          .BYTE   "LOAD ",0
00BF3B  2  20 00        
00BF3D  2               ;input buffer
00BF3D  2               cnsbuf:
00BF3D  2               cnsmax:
00BF3D  2  7F                   .BYTE   127
00BF3E  2               cnslng:
00BF3E  2  00                   .BYTE   0
00BF3F  2               cnstxt:
00BF3F  2  xx xx xx xx          .RES    127
00BF43  2  xx xx xx xx  
00BF47  2  xx xx xx xx  
00BFBE  2               ;fcb one
00BFBE  2               fcbone:
00BFBE  2  xx xx xx xx          .RES    33
00BFC2  2  xx xx xx xx  
00BFC6  2  xx xx xx xx  
00BFDF  2               ;com type field
00BFDF  2               
00BFDF  2               typcom:
00BFDF  2  43 4F 4D             .BYTE   COMSUFFIX
00BFE2  2               
00BFE2  2               ;variable storage
00BFE2  2               cnbfpt:
00BFE2  2  00                   .BYTE   0               ;buffer index
00BFE3  2               dfldsk:
00BFE3  2  00                   .BYTE   0               ;default drive
00BFE4  2               tmpdsk:
00BFE4  2  00                   .BYTE   0               ;temporary dvive
00BFE5  2               ;align vector on word boundary
00BFE5  2  xx                   .ALIGN  2
00BFE6  2               vector:
00BFE6  2  00 00                .WORD   0               ;execution vector
00BFE8  2               ccmcount:
00BFE8  2  00                   .BYTE   0               ;counter
00BFE9  2               curpnt:
00BFE9  2  00                   .BYTE   0               ;input parse start
00BFEA  2               diradd:
00BFEA  2  00                   .BYTE   0               ;directory number
00BFEB  2               savx:
00BFEB  2  00                   .BYTE   0               ;save x location
00BFEC  2               savy:
00BFEC  2  00                   .BYTE   0               ;save y location
00BFED  2               length:
00BFED  2  00                   .BYTE   0               ;number tages to save
00BFEE  2               oldtmp:
00BFEE  2  00                   .BYTE   0               ;temp drive in ren
00BFEF  2               dskbuf:
00BFEF  2  00 08                .WORD   tea             ;disk buffer start
00BFF1  2               across:
00BFF1  2  00                   .BYTE   0               ;dir count on line
00BFF2  2               sixten:
00BFF2  2  00                   .BYTE   0               ;line length div 16
00BFF3  2               moduls:
00BFF3  2  09                   .BYTE   9               ;modulus-1 for number input
00BFF4  2               num:
00BFF4  2  00 00                .WORD   0               ;input number
00BFF6  2               tnum:
00BFF6  2  00 00                .WORD   0               ;temp in bldnum
00BFF8  2               sadr:
00BFF8  2  00 08                .WORD   tea             ;save start address
00BFFA  2               
00BFFA  1                       .INCLUDE "pemrbc.asm"
00BFFA  2               .P816
00BFFA  2               ;________________________________________________________________________________________________________________________________
00BFFA  2               ;
00BFFA  2               ;	DOS/65 primitive execution module (pem)
00BFFA  2               ;
00BFFA  2               ;
00BFFA  2               ;________________________________________________________________________________________________________________________________
00BFFA  2               
00BFFA  2               ;main program
00BFFA  2               ; input:x=command,a=value,a&y=address
00BFFA  2               ; returns:a=value,a&y=address
00BFFA  2               ; alters:all
00BFFA  2               
00BFFA  2               pem:
00BFFA  2  D8                   CLD                     ;set binary mode
00BFFB  2  8D 8F CB             STA     bytinp          ;save input
00BFFE  2  8D D4 CB             STA     lowin           ;value and
00C001  2  8C 90 CB             STY     bytinp+1        ;save high
00C004  2  8C D5 CB             STY     lowin+1         ;address
00C007  2  8E 91 CB             STX     cmdinp          ;and command
00C00A  2  E0 24                CPX     #numcmd         ;if invalid
00C00C  2  B0 50                BCS     extpem          ;then exit
00C00E  2  BD 4B CB             LDA     swctbl,x        ;if flag zero
00C011  2  F0 08                BEQ     noswin          ;skip switch
00C013  2  A9 FF                LDA     #255            ;else set
00C015  2  8D 8E CB             STA     swcflg          ;memory switch flag
00C018  2  20 E5 C2             JSR     switch          ;move data to page zero
00C01B  2               noswin:
00C01B  2  A9 00                LDA     #0              ;clear drive
00C01D  2  8D 96 CB             STA     tmpdrv          ;switch flag
00C020  2  AD 91 CB             LDA     cmdinp          ;get command
00C023  2  0A                   ASL     a               ;multiply by two
00C024  2  6D 91 CB             ADC     cmdinp          ;then add to get x3
00C027  2  AA                   TAX                     ;and make a pointer
00C028  2  E8                   INX                     ;bump to pass jmp
00C029  2  BD 72 C0             LDA     cmdtbl,x        ;get command
00C02C  2  BC 73 C0             LDY     cmdtbl+1,x      ;address
00C02F  2  8D 98 CB             STA     xqtvec          ;and put
00C032  2  8C 99 CB             STY     xqtvec+1        ;in vector
00C035  2  AD DB CA             LDA     extevc+1        ;get return
00C038  2  48                   PHA                     ;address
00C039  2  AD DA CA             LDA     extevc          ;and push
00C03C  2  48                   PHA                     ;as return
00C03D  2  AD 8F CB             LDA     bytinp          ;get input value
00C040  2  AC 90 CB             LDY     bytinp+1
00C043  2                       .IFDEF DUODYNE
00C043  2                       ldx     #$00
00C043  2                       JMP     (xqtvec,x)        ;then execute
00C043  2                       .ELSE
00C043  2  6C 98 CB             JMP     (xqtvec)        ;then execute
00C046  2                       .ENDIF
00C046  2               extexq:
00C046  2  8D 92 CB             STA     bytout          ;save value
00C049  2  8C 93 CB             STY     addout+1        ;and address
00C04C  2  AD 96 CB             LDA     tmpdrv          ;get temp drive
00C04F  2  F0 0D                BEQ     extpem          ;if zero skip switch
00C051  2  A0 00                LDY     #0              ;else
00C053  2  91 02                STA     (addinp),y      ;put back in fcb
00C055  2  AD A1 CB             LDA     olddrv          ;get old drive number
00C058  2  8D 8F CB             STA     bytinp          ;set input value
00C05B  2  20 00 C3             JSR     chgdrv          ;then switch back
00C05E  2               extpem:
00C05E  2  2C 8E CB             BIT     swcflg          ;test memory switch
00C061  2  10 08                BPL     noswot          ;if not set skip
00C063  2  20 E5 C2             JSR     switch          ;else do memory switch
00C066  2  A9 00                LDA     #0              ;clear
00C068  2  8D 8E CB             STA     swcflg          ;flag
00C06B  2               noswot:
00C06B  2  AC 93 CB             LDY     addout+1        ;get address
00C06E  2  AD 92 CB             LDA     bytout          ;and value (address low)
00C071  2  60                   RTS
00C072  2               ;command vector table
00C072  2               cmdtbl:
00C072  2  4C E6 C0             JMP     xwboot          ;warm boot
00C075  2  4C D7 C2             JMP     xcnsin          ;console input with echo
00C078  2  4C 10 C9             JMP     sndchr          ;console output
00C07B  2  4C F1 CB             JMP     sim+21          ;tape reader
00C07E  2  4C EE CB             JMP     sim+18          ;tape punch
00C081  2  4C EB CB             JMP     sim+15          ;printer output
00C084  2  4C 82 C8             JMP     getcon          ;console input w/o echo
00C087  2  4C 1B C1             JMP     xgtios          ;read i/o status
00C08A  2  4C 26 C1             JMP     xstios          ;set i/o status
00C08D  2  4C C7 C8             JMP     sndstr          ;print buffer
00C090  2  4C 7C C9             JMP     bufinp          ;read buffer
00C093  2  4C 92 C8             JMP     kbdsts          ;test console ready
00C096  2  4C 09 CC             JMP     sim+45          ;read list status
00C099  2  4C 2E C3             JMP     xintds          ;initialize system
00C09C  2  4C 00 C3             JMP     chgdrv          ;log in drive
00C09F  2  4C AB C5             JMP     xopen           ;open file
00C0A2  2  4C E6 C5             JMP     xclose          ;close file
00C0A5  2  4C 0A C6             JMP     xfndfr          ;find first match
00C0A8  2  4C 36 C1             JMP     xfndnx          ;find next match
00C0AB  2  4C 9E C1             JMP     xdltfl          ;delete file
00C0AE  2  4C 3E C1             JMP     xread           ;read record
00C0B1  2  4C C3 C1             JMP     xwrite          ;write record
00C0B4  2  4C AD C6             JMP     xmake           ;create file
00C0B7  2  4C 7C C1             JMP     xrenme          ;rename file
00C0BA  2  4C 2E C1             JMP     xintlg          ;interrogate log in status
00C0BD  2  4C 2A C1             JMP     xintdr          ;interrogate current drive
00C0C0  2  4C F5 C2             JMP     chgdma          ;set buffer address
00C0C3  2  4C 1F C1             JMP     xrdalv          ;read allocation map start
00C0C6  2  4C 69 C5             JMP     setron          ;set r/w status
00C0C9  2  4C 32 C1             JMP     xrdros          ;read r/w status
00C0CC  2  4C DE C0             JMP     setlst          ;set list echo status
00C0CF  2  4C E2 C0             JMP     lststs          ;read list echo status
00C0D2  2  4C F6 C0             JMP     xrtclo          ;read low clock
00C0D5  2  4C 0A C1             JMP     xrtchi          ;read high clock
00C0D8  2  4C 14 C1             JMP     xrddcb          ;read dcb address
00C0DB  2  4C 0F CC             JMP     sim+51          ;translate sector
00C0DE  2               ;set list echo status
00C0DE  2               setlst:
00C0DE  2  8D 8C CB             STA     lstflg          ;set flag
00C0E1  2  60                   RTS
00C0E2  2               ;read list echo status
00C0E2  2               lststs:
00C0E2  2  AD 8C CB             LDA     lstflg          ;read flag
00C0E5  2  60                   RTS
00C0E6  2               ;execute warm boot
00C0E6  2               ; ***this command does not return to pem***
00C0E6  2               ; ***instead it jumps to sim, resets	***
00C0E6  2               ; ***system and stack and jumps to ccm. ***
00C0E6  2               xwboot:
00C0E6  2  2C 8E CB             BIT     swcflg          ;test memory switch flag
00C0E9  2  10 08                BPL     dowmbt          ;if clear do not
00C0EB  2  20 E5 C2             JSR     switch          ;switch memory
00C0EE  2  A9 00                LDA     #0              ;clear
00C0F0  2  8D 8E CB             STA     swcflg          ;flag
00C0F3  2               dowmbt:
00C0F3  2  4C DF CB             JMP     sim+3           ;go to sim
00C0F6  2               
00C0F6  2               ;execute read real time clock
00C0F6  2               xrtclo:
00C0F6  2  20 0C CC             JSR     sim+48          ;read clock
00C0F9  2               
00C0F9  2  8D BD CB             STA     rtclk           ;save low
00C0FC  2  8C BE CB             STY     rtclk+1         ;middle
00C0FF  2  8E BF CB             STX     rtclk+2         ;high
00C102  2  8A                   TXA
00C103  2  29 80                AND     #%10000000      ;test for valid
00C105  2  A8                   TAY
00C106  2  AD BD CB             LDA     rtclk           ;get low
00C109  2  60                   RTS
00C10A  2               ;execute read real time clock high
00C10A  2               xrtchi:
00C10A  2  AD BF CB             LDA     rtclk+2         ;get high
00C10D  2  29 7F                AND     #%01111111      ;clear status
00C10F  2  A8                   TAY
00C110  2  AD BE CB             LDA     rtclk+1         ;get middle
00C113  2  60                   RTS
00C114  2               ;execute read dcb address
00C114  2               xrddcb:
00C114  2  AD 68 C3             LDA     cptdcb+1        ;get address
00C117  2  AC 69 C3             LDY     cptdcb+2
00C11A  2  60                   RTS
00C11B  2               ;execute read i/o status
00C11B  2               xgtios:
00C11B  2  AD 06 01             LDA     iostat          ;get status byte
00C11E  2  60                   RTS
00C11F  2               ;execute read allocation map starting address
00C11F  2               xrdalv:
00C11F  2  AD CC CB             LDA     alcmap          ;get
00C122  2  AC CD CB             LDY     alcmap+1        ;starting address
00C125  2  60                   RTS                     ;then return
00C126  2               ;execute set i/o status
00C126  2               xstios:
00C126  2  8D 06 01             STA     iostat          ;set status
00C129  2  60                   RTS
00C12A  2               ;execute interrogate current drive
00C12A  2               xintdr:
00C12A  2  AD A2 CB             LDA     curdrv          ;get number
00C12D  2  60                   RTS
00C12E  2               ;execute read log in status
00C12E  2               xintlg:
00C12E  2  AD A3 CB             LDA     lginvc          ;get status
00C131  2  60                   RTS
00C132  2               ;execute read read/write status
00C132  2               xrdros:
00C132  2  AD A4 CB             LDA     ronlst          ;get status
00C135  2  60                   RTS
00C136  2               ;execute find next match
00C136  2               xfndnx:
00C136  2  20 0E C3             JSR     autodr          ;auto drive select
00C139  2  A9 0D                LDA     #13             ;match including
00C13B  2  4C 17 C6             JMP     search          ;extent
00C13E  2               ;execute read next record
00C13E  2               xread:
00C13E  2  20 0E C3             JSR     autodr          ;auto drive select
00C141  2  20 8B C5             JSR     inrcct          ;initialize record counters
00C144  2  AD AD CB             LDA     nxtrec          ;if next record less
00C147  2  CD AE CB             CMP     numrec          ;then number records
00C14A  2  90 13                BCC     tryrde          ;then try to read
00C14C  2  C9 80                CMP     #128            ;but if not and
00C14E  2  F0 03                BEQ     tryext          ;is max try to extend
00C150  2               rdeeof:
00C150  2  A9 01                LDA     #1              ;else set eof
00C152  2  60                   RTS                     ;code and return
00C153  2               tryext:
00C153  2  A2 01                LDX     #1              ;try for a read
00C155  2  20 E9 C6             JSR     extend          ;file extension
00C158  2  C9 00                CMP     #0              ;if not ok exit eof
00C15A  2  D0 F4                BNE     rdeeof          ;with jump back
00C15C  2  8D AD CB             STA     nxtrec          ;clear next record
00C15F  2               tryrde:
00C15F  2  20 7B C7             JSR     getblk          ;and get block
00C162  2  AD A8 CB             LDA     blknum          ;if block not zero
00C165  2  0D A9 CB             ORA     blknum+1
00C168  2  D0 03                BNE     dorde           ;do the read
00C16A  2  A9 02                LDA     #2              ;else set unwritten
00C16C  2  60                   RTS                     ;code and exit
00C16D  2               dorde:
00C16D  2  20 5C C6             JSR     calrcn          ;calculate record number
00C170  2  20 A8 C4             JSR     sttrsc          ;set track and sector
00C173  2  20 34 C8             JSR     rdesec          ;do sector read
00C176  2  20 9A C5             JSR     updtrc          ;update counters
00C179  2  A9 00                LDA     #0              ;return w/o error
00C17B  2               extrde:
00C17B  2  60                   RTS
00C17C  2               ;execute file rename
00C17C  2               xrenme:
00C17C  2  20 0E C3             JSR     autodr          ;automatic drive select
00C17F  2  20 11 C8             JSR     tstron          ;test for r/o
00C182  2  A9 0C                LDA     #12             ;match name
00C184  2  20 0F C6             JSR     frstsr          ;and type
00C187  2  30 14                BMI     extren          ;exit if not found
00C189  2               doren:
00C189  2  A9 00                LDA     #0              ;clear drive select
00C18B  2  A0 10                LDY     #16             ;in new name
00C18D  2  91 02                STA     (addinp),y      ;part of fcb
00C18F  2  A9 0C                LDA     #12             ;then move
00C191  2  A2 10                LDX     #16             ;new name
00C193  2  20 7C C6             JSR     dirchg          ;to directory
00C196  2  A9 0C                LDA     #12             ;see if
00C198  2  20 17 C6             JSR     search          ;another match
00C19B  2  10 EC                BPL     doren           ;loop if found
00C19D  2               extren:
00C19D  2  60                   RTS                     ;number
00C19E  2               ;execute delete file
00C19E  2               xdltfl:
00C19E  2  20 0E C3             JSR     autodr          ;automatic drive select
00C1A1  2  20 11 C8             JSR     tstron          ;test for r/o
00C1A4  2  A9 0C                LDA     #12             ;match name
00C1A6  2  20 0F C6             JSR     frstsr          ;and type
00C1A9  2  30 17                BMI     extdlt          ;done if not found
00C1AB  2               dodlt:
00C1AB  2  A2 00                LDX     #0              ;else do a
00C1AD  2  20 E1 C7             JSR     mapdir          ;delete
00C1B0  2  AC A7 CB             LDY     subrec          ;then change
00C1B3  2  AD 4A CB             LDA     empty           ;byte zero to
00C1B6  2  91 04                STA     (bufadd),y      ;empty code
00C1B8  2  20 3A C8             JSR     updtck          ;then update directory
00C1BB  2  A9 0C                LDA     #12             ;search
00C1BD  2  20 17 C6             JSR     search          ;for next
00C1C0  2  10 E9                BPL     dodlt           ;loop if found
00C1C2  2               extdlt:
00C1C2  2  60                   RTS                     ;exit
00C1C3  2               ;execute write next record
00C1C3  2               xwrite:
00C1C3  2  20 0E C3             JSR     autodr          ;automatic drive select
00C1C6  2  20 11 C8             JSR     tstron          ;test for r/o
00C1C9  2  20 8B C5             JSR     inrcct          ;initialize counters
00C1CC  2  AD AD CB             LDA     nxtrec          ;get next record
00C1CF  2  C9 80                CMP     #128            ;compare to max
00C1D1  2  90 03                BCC     ntexte          ;continue if less
00C1D3  2  A9 01                LDA     #1              ;else flag as extend
00C1D5  2  60                   RTS                     ;error and exit
00C1D6  2               ntexte:
00C1D6  2  20 7B C7             JSR     getblk          ;calculate block num
00C1D9  2  A9 00                LDA     #0              ;say normal write
00C1DB  2  8D D1 CB             STA     pemwrtype       ;for now
00C1DE  2  AD A8 CB             LDA     blknum          ;get it and if
00C1E1  2  0D A9 CB             ORA     blknum+1
00C1E4  2  F0 03                BEQ     *+5             ;zero then get number
00C1E6  2  4C A6 C2             JMP     blkopn          ;else go write
00C1E9  2  A9 02                LDA     #2              ;say unalloc write
00C1EB  2  8D D1 CB             STA     pemwrtype
00C1EE  2  AD 88 CB             LDA     fcbind          ;get index from prior
00C1F1  2  48                   PHA                     ;and save
00C1F2  2  C9 10                CMP     #16             ;if first block
00C1F4  2  F0 1A                BEQ     isfrst          ;then don't change
00C1F6  2  A8                   TAY                     ;else make an index
00C1F7  2  88                   DEY                     ;point to last
00C1F8  2  2C B8 CB             BIT     blmode          ;test mode
00C1FB  2  10 01                BPL     *+3             ;done if byte
00C1FD  2  88                   DEY                     ;else drop for word
00C1FE  2  B1 02                LDA     (addinp),y      ;and get that number
00C200  2  8D A8 CB             STA     blknum          ;store as starting
00C203  2  C8                   INY                     ;bump for word
00C204  2  A9 00                LDA     #0              ;preset for byte
00C206  2  2C B8 CB             BIT     blmode          ;test mode
00C209  2  10 02                BPL     *+4             ;done if byte
00C20B  2  B1 02                LDA     (addinp),y      ;else get high
00C20D  2  8D A9 CB             STA     blknum+1        ;then set high
00C210  2               isfrst:
00C210  2  AD A8 CB             LDA     blknum          ;get block
00C213  2  8D 9D CB             STA     lkdown          ;set lower and
00C216  2  8D 9F CB             STA     lookup          ;upper pointers
00C219  2  AD A9 CB             LDA     blknum+1        ;now set high part
00C21C  2  8D 9E CB             STA     lkdown+1
00C21F  2  8D A0 CB             STA     lookup+1
00C222  2               srblag:
00C222  2  AD 9F CB             LDA     lookup          ;if upper pointer
00C225  2  CD C3 CB             CMP     maxblk          ;not at max
00C228  2  D0 08                BNE     upnemx          ;then keep going
00C22A  2  AC A0 CB             LDY     lookup+1        ;now check high
00C22D  2  CC C4 CB             CPY     maxblk+1
00C230  2  F0 12                BEQ     tstdwn          ;go test down
00C232  2               upnemx:
00C232  2  EE 9F CB             INC     lookup          ;else bump upper
00C235  2  D0 03                BNE     *+5
00C237  2  EE A0 CB             INC     lookup+1
00C23A  2  AD 9D CB             LDA     lkdown          ;then if lower
00C23D  2  0D 9E CB             ORA     lkdown+1
00C240  2  F0 18                BEQ     dotest          ;is zero start test
00C242  2  D0 0B                BNE     dcdown          ;else drop lower
00C244  2               tstdwn:
00C244  2  AD 9D CB             LDA     lkdown          ;if upper & lower at
00C247  2  0D 9E CB             ORA     lkdown+1
00C24A  2  D0 03                BNE     dcdown          ;drop if not zero
00C24C  2  A8                   TAY                     ;also set y
00C24D  2  F0 30                BEQ     extsbl          ;then exit
00C24F  2               dcdown:
00C24F  2  AD 9D CB             LDA     lkdown          ;drop lower
00C252  2  D0 03                BNE     *+5
00C254  2  CE 9E CB             DEC     lkdown+1
00C257  2  CE 9D CB             DEC     lkdown
00C25A  2               dotest:
00C25A  2  AD 9D CB             LDA     lkdown          ;get lower
00C25D  2  AC 9E CB             LDY     lkdown+1
00C260  2  20 4D C5             JSR     tstblk          ;and test
00C263  2  D0 09                BNE     trylup          ;if full try upper
00C265  2  AD 9D CB             LDA     lkdown          ;else use lower
00C268  2  AC 9E CB             LDY     lkdown+1
00C26B  2  4C 7F C2             JMP     extsbl          ;as result
00C26E  2               trylup:
00C26E  2  AD 9F CB             LDA     lookup          ;get upper
00C271  2  AC A0 CB             LDY     lookup+1
00C274  2  20 4D C5             JSR     tstblk          ;if full
00C277  2  D0 A9                BNE     srblag          ;then loop
00C279  2  AD 9F CB             LDA     lookup          ;else use upper
00C27C  2  AC A0 CB             LDY     lookup+1
00C27F  2               extsbl:
00C27F  2  8D A8 CB             STA     blknum          ;then save number
00C282  2  8C A9 CB             STY     blknum+1
00C285  2  0D A9 CB             ORA     blknum+1        ;see if zero
00C288  2  D0 04                BNE     gtgood          ;then proceed
00C28A  2  68                   PLA                     ;clear stack
00C28B  2  A9 02                LDA     #2              ;set end
00C28D  2  60                   RTS                     ;of data return
00C28E  2               gtgood:
00C28E  2  AD A8 CB             LDA     blknum          ;get low again
00C291  2  20 61 C5             JSR     setblk          ;set allocation map
00C294  2  68                   PLA                     ;get block
00C295  2  A8                   TAY                     ;pointer back
00C296  2  AD A8 CB             LDA     blknum          ;get number
00C299  2  91 02                STA     (addinp),y      ;and put in fcb
00C29B  2  AD A9 CB             LDA     blknum+1        ;get high
00C29E  2  C8                   INY
00C29F  2  2C B8 CB             BIT     blmode          ;test mode
00C2A2  2  10 02                BPL     *+4             ;done if byte
00C2A4  2  91 02                STA     (addinp),y      ;else set high
00C2A6  2               blkopn:
00C2A6  2  20 5C C6             JSR     calrcn          ;calculate record num
00C2A9  2  20 A8 C4             JSR     sttrsc          ;set track and sector
00C2AC  2  20 40 C8             JSR     wrtsec          ;do write
00C2AF  2  AE AD CB             LDX     nxtrec          ;get next record
00C2B2  2  EC AE CB             CPX     numrec          ;if less than max
00C2B5  2  90 05                BCC     notful          ;then ok
00C2B7  2  E8                   INX                     ;else bump count
00C2B8  2  8E AE CB             STX     numrec          ;and save
00C2BB  2  CA                   DEX                     ;back down
00C2BC  2               notful:
00C2BC  2  E0 7F                CPX     #127            ;if not at max
00C2BE  2  D0 11                BNE     noawex          ;skip extending
00C2C0  2  20 9A C5             JSR     updtrc          ;update record counters
00C2C3  2  A2 00                LDX     #0              ;do write
00C2C5  2  20 E9 C6             JSR     extend          ;file extension
00C2C8  2  C9 00                CMP     #0              ;if not ok
00C2CA  2  D0 0A                BNE     extwrt          ;exit
00C2CC  2  A9 FF                LDA     #255            ;else start counter
00C2CE  2  8D AD CB             STA     nxtrec          ;at one short
00C2D1  2               noawex:
00C2D1  2  20 9A C5             JSR     updtrc          ;then update counters
00C2D4  2  A9 00                LDA     #0              ;good return
00C2D6  2               extwrt:
00C2D6  2  60                   RTS                     ;exit
00C2D7  2               ;execute console input
00C2D7  2               xcnsin:
00C2D7  2  20 82 C8             JSR     getcon          ;get input
00C2DA  2  20 B8 C8             JSR     tstchr          ;test it and
00C2DD  2  90 05                BCC     extxci          ;if control exit
00C2DF  2  48                   PHA                     ;else save
00C2E0  2  20 10 C9             JSR     sndchr          ;echo
00C2E3  2  68                   PLA                     ;restore
00C2E4  2               extxci:
00C2E4  2  60                   RTS                     ;return
00C2E5  2               ;switch memory
00C2E5  2               ;page zero block begins at $02 and is numvar bytes long.
00C2E5  2               switch:
00C2E5  2  A2 07                LDX     #numvar-1       ;get number to switch
00C2E7  2               nxtswh:
00C2E7  2  B5 02                LDA     2,x             ;get zero page
00C2E9  2  BC D4 CB             LDY     varblk,x        ;and save area
00C2EC  2  9D D4 CB             STA     varblk,x        ;save zero
00C2EF  2  94 02                STY     2,x             ;and high
00C2F1  2  CA                   DEX                     ;count down
00C2F2  2  10 F3                BPL     nxtswh          ;and loop until done
00C2F4  2               drvsme:
00C2F4  2  60                   RTS                     ;then return
00C2F5  2               ;change dma address
00C2F5  2               ; input:addinp=address
00C2F5  2               ; returns:none
00C2F5  2               ; alters:all
00C2F5  2               chgdma:
00C2F5  2  A5 02                LDA     addinp          ;get low
00C2F7  2  A4 03                LDY     addinp+1        ;and high address
00C2F9  2  85 04                STA     bufadd          ;then store
00C2FB  2  84 05                STY     bufadd+1        ;in address
00C2FD  2  4C 00 CC             JMP     sim+36          ;then go to sim
00C300  2               
00C300  2               ;change drive
00C300  2               ; input:bytinp
00C300  2               ; returns:none
00C300  2               ; alters:all
00C300  2               chgdrv:
00C300  2  AD 8F CB             LDA     bytinp          ;get input
00C303  2  CD A2 CB             CMP     curdrv          ;if same as current
00C306  2  F0 EC                BEQ     drvsme          ;do nothing
00C308  2  8D A2 CB             STA     curdrv          ;else change current
00C30B  2  4C 41 C3             JMP     mapdrv          ;then log it in
00C30E  2               ;automatic drive select
00C30E  2               ; input:(addinp) 0=no change
00C30E  2               ; 1-8 or 'A'-'H' = change
00C30E  2               ; returns:none
00C30E  2               ; alters:all
00C30E  2               autodr:
00C30E  2  A0 00                LDY     #0              ;get
00C310  2  B1 02                LDA     (addinp),y      ;first byte of fcb
00C312  2  F0 19                BEQ     qtatdr          ;if zero quit
00C314  2  38                   SEC                     ;set carry for
00C315  2  E9 01                SBC     #1              ;subtract one
00C317  2  29 07                AND     #%00000111      ;look at three lsbs
00C319  2  8D 8F CB             STA     bytinp          ;make parameter
00C31C  2  AD A2 CB             LDA     curdrv          ;get current
00C31F  2  8D A1 CB             STA     olddrv          ;and save
00C322  2  B1 02                LDA     (addinp),y      ;get fcb entry
00C324  2  8D 96 CB             STA     tmpdrv          ;and save as flag
00C327  2  98                   TYA                     ;set a to 0
00C328  2  91 02                STA     (addinp),y      ;clear byte zero in fcb
00C32A  2  20 00 C3             JSR     chgdrv          ;then select new drive
00C32D  2               qtatdr:
00C32D  2  60                   RTS                     ;and return
00C32E  2               ;execute initialize system
00C32E  2               ; input:none
00C32E  2               ; returns:none
00C32E  2               ; alters:all,curdrv,lginvc,bufadd
00C32E  2               xintds:
00C32E  2  A9 00                LDA     #DEFDRV         ;set current
00C330  2  8D A2 CB             STA     curdrv          ;drive to a
00C333  2  8D A3 CB             STA     lginvc          ;clear log in status
00C336  2  A9 28                LDA     #<dflbuf        ;get default buffer
00C338  2  A0 01                LDY     #>dflbuf        ;address
00C33A  2  85 02                STA     addinp          ;and set up
00C33C  2  84 03                STY     addinp+1        ;parameters
00C33E  2  20 F5 C2             JSR     chgdma          ;change address
00C341  2               
00C341  2               ;log in drive and set pointers and maps
00C341  2               ; input:curdrv
00C341  2               ; returns:none
00C341  2               ; alters:all
00C341  2               mapdrv:
00C341  2  AD A2 CB             LDA     curdrv          ;if current drive
00C344  2  C9 08                CMP     #8              ;is 0 to 7
00C346  2  90 0F                BCC     vlddrv          ;then log it in
00C348  2               drserr:
00C348  2  20 63 C8             JSR     errout          ;send error message
00C34B  2  AD DD CA             LDA     sltmvc          ;point to
00C34E  2  AC DE CA             LDY     sltmvc+1        ;select message
00C351  2  20 C7 C8             JSR     sndstr          ;and send it
00C354  2               
00C354  2  4C E6 C0             JMP     xwboot          ;and abort
00C357  2               
00C357  2               vlddrv:
00C357  2               ; meep meep meep -- SELF MODIFYING CODE ALERT!
00C357  2  20 F7 CB             JSR     sim+27          ;go to sim to set
00C35A  2  8D 68 C3             STA     cptdcb+1        ;save
00C35D  2  8C 69 C3             STY     cptdcb+2
00C360  2  0D 69 C3             ORA     cptdcb+2        ;see if invalid
00C363  2               
00C363  2  F0 E3                BEQ     drserr          ;error if is
00C365  2               ;capture dcb
00C365  2  A0 0D                LDY     #14-1           ;do 14 bytes
00C367  2               cptdcb:
00C367  2  B9 FF FF             LDA     $ffff,y         ;get value from sim
00C36A  2  99 C3 CB             STA     dcb,y           ;store it
00C36D  2  88                   DEY
00C36E  2  10 F7                BPL     cptdcb          ;loop for more
00C370  2  AD C9 CB             LDA     blkscd          ;get block size code
00C373  2  A8                   TAY                     ;save in y
00C374  2  18                   CLC
00C375  2  69 03                ADC     #3              ;convert to sxb
00C377  2  8D BC CB             STA     sxb             ;and save
00C37A  2  B9 82 CB             LDA     sabtbl,y        ;get sab
00C37D  2  8D BB CB             STA     sab             ;and set
00C380  2  AD CA CB             LDA     maxdir          ;get max dir
00C383  2  8D B9 CB             STA     maxdrc          ;set max dir record
00C386  2  AD CB CB             LDA     maxdir+1
00C389  2  4A                   LSR     a               ;divide by 4
00C38A  2  6E B9 CB             ROR     maxdrc
00C38D  2  4A                   LSR     a
00C38E  2  6E B9 CB             ROR     maxdrc
00C391  2  8D BA CB             STA     maxdrc+1        ;then save high
00C394  2  A9 00                LDA     #0              ;set mode to byte
00C396  2  8D B8 CB             STA     blmode
00C399  2  AD C4 CB             LDA     maxblk+1        ;branch if max block
00C39C  2  F0 05                BEQ     ntm255          ;not over 255
00C39E  2               ;if y=0 when the following line is executed it means
00C39E  2               ;that the user has put an illegal combination into
00C39E  2               ;the disk definition table. may want to consider
00C39E  2               ;putting some error checking here in the future if
00C39E  2               ;there is space in pem.
00C39E  2  88                   DEY                     ;back up index
00C39F  2  38                   SEC                     ;else set mode to word
00C3A0  2  6E B8 CB             ROR     blmode
00C3A3  2               ntm255:
00C3A3  2  B9 7F CB             LDA     exmtbl,y        ;get extent mask
00C3A6  2  8D D2 CB             STA     exm
00C3A9  2               
00C3A9  2  38                   SEC                     ;now calculate cexm1f
00C3AA  2  A9 1F                LDA     #31
00C3AC  2  F9 7F CB             SBC     exmtbl,y
00C3AF  2  8D D3 CB             STA     cexm1f
00C3B2  2  AE A2 CB             LDX     curdrv          ;get drive as pointer
00C3B5  2  BD 77 CB             LDA     bitmap,x        ;get bit
00C3B8  2  2D A3 CB             AND     lginvc          ;if logged in
00C3BB  2  D0 0C                BNE     extstm          ;then exit
00C3BD  2  BD 77 CB             LDA     bitmap,x        ;get bit back
00C3C0  2  0D A3 CB             ORA     lginvc          ;set in log-in
00C3C3  2  8D A3 CB             STA     lginvc          ;and update
00C3C6  2  4C CA C3             JMP     flinal          ;then fill in maps
00C3C9  2               
00C3C9  2               extstm:
00C3C9  2  60                   RTS                     ;and return
00C3CA  2               ;fill in allocation map
00C3CA  2               flinal:
00C3CA  2  20 25 C8             JSR     setrw           ;set to read/write
00C3CD  2  AD C3 CB             LDA     maxblk          ;divide max block by
00C3D0  2  8D C0 CB             STA     gpcnt           ;eight to get max
00C3D3  2  AD C4 CB             LDA     maxblk+1
00C3D6  2  A2 03                LDX     #3
00C3D8  2               clcnab:
00C3D8  2  4A                   LSR     a               ;use a for speed
00C3D9  2  6E C0 CB             ROR     gpcnt
00C3DC  2  CA                   DEX
00C3DD  2  D0 F9                BNE     clcnab          ;loop if more
00C3DF  2  8D C1 CB             STA     gpcnt+1         ;save high
00C3E2  2  EE C0 CB             INC     gpcnt           ;bump by one
00C3E5  2  D0 03                BNE     *+5
00C3E7  2  EE C1 CB             INC     gpcnt+1         ;with carry
00C3EA  2  AD CC CB             LDA     alcmap          ;get map start
00C3ED  2  AC CD CB             LDY     alcmap+1
00C3F0  2  85 06                STA     alcpnt          ;set pointer to start
00C3F2  2  84 07                STY     alcpnt+1
00C3F4  2  A0 00                LDY     #0              ;clear index
00C3F6  2               clraml:
00C3F6  2  A9 00                LDA     #0              ;clear byte
00C3F8  2  91 06                STA     (alcpnt),y      ;put in map
00C3FA  2  E6 06                INC     alcpnt          ;bump pointer
00C3FC  2  D0 02                BNE     *+4
00C3FE  2  E6 07                INC     alcpnt+1        ;with carry
00C400  2  AD C0 CB             LDA     gpcnt           ;get low of count
00C403  2  D0 03                BNE     *+5             ;skip if not zero
00C405  2  CE C1 CB             DEC     gpcnt+1         ;else drop high
00C408  2  CE C0 CB             DEC     gpcnt           ;always drop low
00C40B  2  AD C0 CB             LDA     gpcnt           ;test for zero
00C40E  2  0D C1 CB             ORA     gpcnt+1
00C411  2  D0 E3                BNE     clraml          ;loop if more
00C413  2               ;at this point complete map is cleared
00C413  2  AD B9 CB             LDA     maxdrc          ;get low of max dir record
00C416  2  8D C0 CB             STA     gpcnt
00C419  2  AD BA CB             LDA     maxdrc+1        ;high in a
00C41C  2  AE BC CB             LDX     sxb             ;set x according to block size
00C41F  2               clcmdb:
00C41F  2  4A                   LSR     a               ;do division
00C420  2  6E C0 CB             ROR     gpcnt
00C423  2  CA                   DEX
00C424  2  D0 F9                BNE     clcmdb          ;until x is zero
00C426  2  8D C1 CB             STA     gpcnt+1         ;set high
00C429  2  EE C0 CB             INC     gpcnt           ;then bump by one
00C42C  2  D0 03                BNE     *+5
00C42E  2  EE C1 CB             INC     gpcnt+1
00C431  2  8E A8 CB             STX     blknum          ;clear block number
00C434  2  8E A9 CB             STX     blknum+1
00C437  2               fildal:
00C437  2  AD A8 CB             LDA     blknum          ;get block number
00C43A  2  AC A9 CB             LDY     blknum+1
00C43D  2  20 61 C5             JSR     setblk          ;set bit
00C440  2  EE A8 CB             INC     blknum          ;bump block number
00C443  2  D0 03                BNE     *+5
00C445  2  EE A9 CB             INC     blknum+1
00C448  2  AD C0 CB             LDA     gpcnt           ;get low of count
00C44B  2  D0 03                BNE     *+5             ;skip if not zero
00C44D  2  CE C1 CB             DEC     gpcnt+1         ;else drop high
00C450  2  CE C0 CB             DEC     gpcnt           ;always do low
00C453  2  AD C0 CB             LDA     gpcnt           ;test for zero
00C456  2  0D C1 CB             ORA     gpcnt+1
00C459  2  D0 DC                BNE     fildal          ;loop if more
00C45B  2               ;at this point directory space is mapped
00C45B  2  20 7A C4             JSR     intdrv          ;initialize drive
00C45E  2  20 D5 C7             JSR     cldrnm          ;clear directory number
00C461  2               
00C461  2               fillpe:
00C461  2  A2 01                LDX     #1              ;parameter for fill
00C463  2  20 1C C7             JSR     nxtdir          ;execute for next directory
00C466  2  30 11                BMI     extfil          ;done if invalid
00C468  2  AC A7 CB             LDY     subrec          ;get offset
00C46B  2  B1 04                LDA     (bufadd),y      ;get empty/valid flag
00C46D  2  C9 E5                CMP     #$e5            ;if empty
00C46F  2  F0 F0                BEQ     fillpe          ;try next
00C471  2  A2 01                LDX     #1              ;parameter for fill in
00C473  2  20 E1 C7             JSR     mapdir          ;do directory map
00C476  2  4C 61 C4             JMP     fillpe          ;then loop
00C479  2               extfil:
00C479  2  60                   RTS                     ;return
00C47A  2               ;initialize drive
00C47A  2               ; input:nsystr
00C47A  2               ; returns:none
00C47A  2               ; alters:all
00C47A  2               intdrv:
00C47A  2  20 F4 CB             JSR     sim+24          ;home then
00C47D  2  AD C7 CB             LDA     nsystr          ;get number of system tracks
00C480  2  AC C8 CB             LDY     nsystr+1
00C483  2  4C FA CB             JMP     sim+30          ;and set in sim
00C486  2               
00C486  2               ;directory record set up
00C486  2               ; input:dirnum
00C486  2               ; returns:none
00C486  2               ; alters:all,recnum,dirrec
00C486  2               drrcsu:
00C486  2  AD A6 CB             LDA     dirnum+1        ;move high dir number
00C489  2  8D A9 CB             STA     recnum+1        ;to record number
00C48C  2  AD A5 CB             LDA     dirnum          ;divide
00C48F  2  4E A9 CB             LSR     recnum+1        ;directory by four
00C492  2  6A                   ROR     a
00C493  2  4E A9 CB             LSR     recnum+1
00C496  2  6A                   ROR     a
00C497  2  8D AF CB             STA     dirrec          ;and save
00C49A  2  8D A8 CB             STA     recnum          ;set low record number
00C49D  2  AD A9 CB             LDA     recnum+1        ;get high
00C4A0  2  8D B0 CB             STA     dirrec+1        ;and set
00C4A3  2  A9 00                LDA     #0              ;clear top byte
00C4A5  2  8D AA CB             STA     recnum+2
00C4A8  2               ;set track and sector
00C4A8  2               ; input:recnum
00C4A8  2               ; returns:none
00C4A8  2               ; alters:all,countr,trkctr
00C4A8  2               sttrsc:
00C4A8  2  A2 00                LDX     #0              ;clear track counter
00C4AA  2  8E C2 CB             STX     trkctr
00C4AD  2  8E 9A CB             STX     countr          ;and record
00C4B0  2  8E 9B CB             STX     countr+1        ;counter
00C4B3  2  8E 9C CB             STX     countr+2
00C4B6  2               trnxtr:
00C4B6  2  AD A8 CB             LDA     recnum          ;from
00C4B9  2  CD 9A CB             CMP     countr          ;record number
00C4BC  2  AD A9 CB             LDA     recnum+1        ;and if a
00C4BF  2  ED 9B CB             SBC     countr+1        ;borrow then
00C4C2  2  AD AA CB             LDA     recnum+2
00C4C5  2  ED 9C CB             SBC     countr+2
00C4C8  2  90 21                BCC     higher          ;gone too far
00C4CA  2  18                   CLC                     ;else
00C4CB  2  AD 9A CB             LDA     countr          ;get counter
00C4CE  2  6D C5 CB             ADC     sectrk          ;add sectors per track
00C4D1  2  8D 9A CB             STA     countr          ;sectors per track
00C4D4  2  AD 9B CB             LDA     countr+1
00C4D7  2  6D C6 CB             ADC     sectrk+1
00C4DA  2  8D 9B CB             STA     countr+1
00C4DD  2  90 03                BCC     bumptr          ;done if no carry
00C4DF  2  EE 9C CB             INC     countr+2        ;else bump high
00C4E2  2               bumptr:
00C4E2  2  E8                   INX                     ;increase track count
00C4E3  2  D0 D1                BNE     trnxtr          ;with carry
00C4E5  2  EE C2 CB             INC     trkctr
00C4E8  2  4C B6 C4             JMP     trnxtr          ;then loop
00C4EB  2               higher:
00C4EB  2  CA                   DEX                     ;back up track
00C4EC  2  E0 FF                CPX     #$ff            ;see if wrap around
00C4EE  2  D0 03                BNE     *+5             ;wasn't
00C4F0  2  CE C2 CB             DEC     trkctr          ;else drop high
00C4F3  2  8A                   TXA                     ;move to a
00C4F4  2  18                   CLC                     ;add starting track
00C4F5  2  6D C7 CB             ADC     nsystr
00C4F8  2  AA                   TAX                     ;save in x
00C4F9  2  AD C2 CB             LDA     trkctr
00C4FC  2  6D C8 CB             ADC     nsystr+1
00C4FF  2  A8                   TAY                     ;move to correct registers
00C500  2  8A                   TXA
00C501  2  20 FA CB             JSR     sim+30          ;then set in sim
00C504  2               
00C504  2  38                   SEC                     ;back
00C505  2  AD 9A CB             LDA     countr          ;counter down
00C508  2  ED C5 CB             SBC     sectrk          ;by sectors per track
00C50B  2  8D 9A CB             STA     countr          ;and save
00C50E  2  AD 9B CB             LDA     countr+1
00C511  2  ED C6 CB             SBC     sectrk+1
00C514  2  8D 9B CB             STA     countr+1
00C517  2  38                   SEC                     ;now
00C518  2  AD A8 CB             LDA     recnum          ;find difference
00C51B  2  ED 9A CB             SBC     countr          ;as sector
00C51E  2  AA                   TAX                     ;save in x
00C51F  2  AD A9 CB             LDA     recnum+1
00C522  2  ED 9B CB             SBC     countr+1
00C525  2  A8                   TAY                     ;move to correct registers
00C526  2  8A                   TXA
00C527  2  20 0F CC             JSR     sim+51          ;translate
00C52A  2               
00C52A  2  4C FD CB             JMP     sim+33          ;and set through sim
00C52D  2               
00C52D  2               ;get block bit mask and index
00C52D  2               ; input:a&y=block number
00C52D  2               ; returns:a=bit mask and y=0
00C52D  2               ; alters:all and alcpnt
00C52D  2               blkmsk:
00C52D  2  48                   PHA                     ;save block number
00C52E  2  84 07                STY     alcpnt+1        ;including high
00C530  2  A0 03                LDY     #3              ;divide by eight
00C532  2               blkmlp:
00C532  2  46 07                LSR     alcpnt+1        ;shift high
00C534  2  6A                   ROR     a
00C535  2  88                   DEY                     ;loop until done
00C536  2  D0 FA                BNE     blkmlp
00C538  2  18                   CLC                     ;now add map start
00C539  2  6D CC CB             ADC     alcmap
00C53C  2  85 06                STA     alcpnt
00C53E  2  A5 07                LDA     alcpnt+1
00C540  2  6D CD CB             ADC     alcmap+1
00C543  2  85 07                STA     alcpnt+1
00C545  2  68                   PLA                     ;get number back
00C546  2  29 07                AND     #%00000111      ;look at 3 lsbs
00C548  2  AA                   TAX                     ;get
00C549  2  BD 6F CB             LDA     bitmsk,x        ;mask
00C54C  2  60                   RTS                     ;and return
00C54D  2               ;test block
00C54D  2               ; input:a&y=block number
00C54D  2               ; returns:z=1 if unassigned
00C54D  2               ; 	   =0 if assigned and bit in a is set
00C54D  2               ; alters:all
00C54D  2               tstblk:
00C54D  2  20 2D C5             JSR     blkmsk          ;get mask and index
00C550  2  31 06                AND     (alcpnt),y      ;mask with map entry
00C552  2  60                   RTS                     ;then return
00C553  2               ;alter block status
00C553  2               ; input:a&y=block number,x=1 if set
00C553  2               ;		   	  =0 if reset
00C553  2               ; returns:none
00C553  2               ; alters:all and allocation map
00C553  2               altalc:
00C553  2  E0 01                CPX     #1              ;if set
00C555  2  F0 0A                BEQ     setblk          ;go do it
00C557  2               clrblk:
00C557  2  20 2D C5             JSR     blkmsk          ;else get mask
00C55A  2  49 FF                EOR     #$ff            ;and complement
00C55C  2  31 06                AND     (alcpnt),y      ;preserve others
00C55E  2  91 06                STA     (alcpnt),y      ;and save
00C560  2  60                   RTS                     ;then return
00C561  2               setblk:
00C561  2  20 2D C5             JSR     blkmsk          ;get mask
00C564  2  11 06                ORA     (alcpnt),y      ;set bit
00C566  2  91 06                STA     (alcpnt),y      ;and put back
00C568  2  60                   RTS                     ;then return
00C569  2               ;set current drive to read only
00C569  2               ; input:curdrv,ronlst,bitmap
00C569  2               ; returns:none
00C569  2               ; alters:a,x,p and ronlst
00C569  2               setron:
00C569  2  AE A2 CB             LDX     curdrv          ;get number
00C56C  2  BD 77 CB             LDA     bitmap,x        ;and get mask
00C56F  2  0D A4 CB             ORA     ronlst          ;or with status
00C572  2  8D A4 CB             STA     ronlst          ;and put back
00C575  2  60                   RTS                     ;then return
00C576  2               ;calculate checksum of buffer @ bufadd
00C576  2               ; input: buffer@(bufadd)
00C576  2               ; returns:a=checksum
00C576  2               ; alters:a,y,p
00C576  2               clcchk:
00C576  2  A9 00                LDA     #0              ;clear accumulator
00C578  2  A0 7F                LDY     #127            ;start at end
00C57A  2               chkmre:
00C57A  2  18                   CLC                     ;no carry
00C57B  2  71 04                ADC     (bufadd),y      ;add byte
00C57D  2  88                   DEY                     ;count down
00C57E  2  10 FA                BPL     chkmre          ;and loop until done
00C580  2  60                   RTS                     ;then return
00C581  2               ;check read/write status
00C581  2               ; input:curdrv,ronlst
00C581  2               ; returns:z=0 if r/o or z=1 if r/w
00C581  2               ; alters:a,x,p
00C581  2               chkron:
00C581  2  AE A2 CB             LDX     curdrv          ;get current drive
00C584  2  BD 77 CB             LDA     bitmap,x        ;get mask
00C587  2  2D A4 CB             AND     ronlst          ;and test status
00C58A  2  60                   RTS
00C58B  2               ;initialize record counters from fcb
00C58B  2               ; input:fcb@(addinp)
00C58B  2               ; returns:none
00C58B  2               ; alters:a,y,p,nxtrec,numrec
00C58B  2               inrcct:
00C58B  2  A0 20                LDY     #32             ;next record offset
00C58D  2  B1 02                LDA     (addinp),y      ;get next record
00C58F  2  8D AD CB             STA     nxtrec          ;and save
00C592  2  A0 0F                LDY     #15             ;number records offset
00C594  2  B1 02                LDA     (addinp),y      ;get number
00C596  2  8D AE CB             STA     numrec          ;and save
00C599  2  60                   RTS                     ;and return
00C59A  2               ;update record counters in fcb
00C59A  2               ; input:nxtrec,numrec
00C59A  2               ; returns:none
00C59A  2               ; alters:all,fcb@(addinp)
00C59A  2               updtrc:
00C59A  2  AE AD CB             LDX     nxtrec          ;get next record
00C59D  2  E8                   INX                     ;bump it
00C59E  2  8A                   TXA                     ;transfer
00C59F  2  A0 20                LDY     #32             ;set offset
00C5A1  2  91 02                STA     (addinp),y      ;and store in fcb
00C5A3  2  AD AE CB             LDA     numrec          ;get number
00C5A6  2  A0 0F                LDY     #15             ;and its offset
00C5A8  2  91 02                STA     (addinp),y      ;and store
00C5AA  2  60                   RTS                     ;then return
00C5AB  2               ;execute open file
00C5AB  2               xopen:
00C5AB  2  20 0E C3             JSR     autodr          ;auto drive select
00C5AE  2               ;open file
00C5AE  2               ; input:fcb @ (addinp)
00C5AE  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00C5AE  2               ; alters:all
00C5AE  2               opnfle:
00C5AE  2  20 0D C6             JSR     fndf13          ;match all including extent
00C5B1  2  30 32                BMI     extopn          ;done if not found
00C5B3  2  A9 0C                LDA     #12             ;point to first char
00C5B5  2  0D A7 CB             ORA     subrec          ;add offset
00C5B8  2  A8                   TAY                     ;make it a pointer
00C5B9  2               nxopmv:
00C5B9  2  B1 04                LDA     (bufadd),y      ;get buffer contents
00C5BB  2  AA                   TAX                     ;and save
00C5BC  2  98                   TYA                     ;save index
00C5BD  2  29 1F                AND     #%00011111      ;remove offset
00C5BF  2  A8                   TAY                     ;back to index
00C5C0  2  8A                   TXA                     ;get byte back
00C5C1  2  91 02                STA     (addinp),y      ;and store in fcb
00C5C3  2  98                   TYA                     ;get index
00C5C4  2  0D A7 CB             ORA     subrec          ;add offset back
00C5C7  2  A8                   TAY                     ;and make index again
00C5C8  2  C8                   INY                     ;next position
00C5C9  2  98                   TYA                     ;if index
00C5CA  2  29 1F                AND     #%00011111      ;not gone past
00C5CC  2  D0 EB                BNE     nxopmv          ;end then loop
00C5CE  2               ;now correct extent and max records
00C5CE  2  A0 0C                LDY     #12             ;point at extent in fcb
00C5D0  2  AD 89 CB             LDA     savext          ;get save from search
00C5D3  2  D1 02                CMP     (addinp),y      ;compare
00C5D5  2  F0 0B                BEQ     extsme          ;jump ahead if same
00C5D7  2  91 02                STA     (addinp),y      ;else change extent
00C5D9  2  A9 80                LDA     #128            ;assume fcb ext < dir ext
00C5DB  2  90 01                BCC     fcbxls          ;jump ahead if true
00C5DD  2  0A                   ASL     a               ;clear a
00C5DE  2               fcbxls:
00C5DE  2  A0 0F                LDY     #15             ;point to max
00C5E0  2  91 02                STA     (addinp),y      ;and set
00C5E2  2               extsme:
00C5E2  2  AD B1 CB             LDA     dirmod          ;else get number
00C5E5  2               extopn:
00C5E5  2  60                   RTS                     ;and return
00C5E6  2               ;execute close file
00C5E6  2               xclose:
00C5E6  2  20 0E C3             JSR     autodr          ;auto drive select
00C5E9  2               ;close file
00C5E9  2               ;if file is r/o then no actual close
00C5E9  2               ;operation is performed.
00C5E9  2               ; input:fcb @ (addinp)
00C5E9  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00C5E9  2               ; alters:all
00C5E9  2               clsfle:
00C5E9  2  20 0D C6             JSR     fndf13          ;match including extent
00C5EC  2  30 1B                BMI     extcls          ;exit if not found
00C5EE  2  20 81 C5             JSR     chkron          ;see if r/o
00C5F1  2  D0 13                BNE     noclse          ;branch if is
00C5F3  2               ;now set flag to ensure directory extent and number of
00C5F3  2               ;records fields are only changed if necessary.
00C5F3  2               ;The decision to change is determined by whether or
00C5F3  2               ;not the system is closing an extent less than the
00C5F3  2               ;maximum extent in the directory entry. If that is
00C5F3  2               ;the case, the directory extent and number of record
00C5F3  2               ;fields are not changed.
00C5F3  2  A0 0C                LDY     #12             ;get extent
00C5F5  2  B1 02                LDA     (addinp),y
00C5F7  2  48                   PHA                     ;save it
00C5F8  2  98                   TYA                     ;now look in directory
00C5F9  2  0D A7 CB             ORA     subrec
00C5FC  2  A8                   TAY
00C5FD  2  68                   PLA                     ;get extent back
00C5FE  2  D1 04                CMP     (bufadd),y
00C600  2  6E 87 CB             ROR     skpdir          ;save result
00C603  2               ;now go do it
00C603  2  20 78 C6             JSR     updtdr          ;update directory
00C606  2               noclse:
00C606  2  AD B1 CB             LDA     dirmod          ;get directory number
00C609  2               extcls:
00C609  2  60                   RTS                     ;and return
00C60A  2               ;execute find first match
00C60A  2               xfndfr:
00C60A  2  20 0E C3             JSR     autodr          ;auto drive select
00C60D  2               fndf13:
00C60D  2  A9 0D                LDA     #13             ;match including extent
00C60F  2               ;search for first match
00C60F  2               ; input:a=number char to match
00C60F  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00C60F  2               ; alters:all
00C60F  2               frstsr:
00C60F  2  48                   PHA                     ;save number to match
00C610  2  20 D5 C7             JSR     cldrnm          ;clear directory number to -1
00C613  2  20 7A C4             JSR     intdrv          ;and drive
00C616  2  68                   PLA                     ;get number to match
00C617  2               ;search for directory match
00C617  2               ; input:a=number char to match
00C617  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00C617  2               ; alters:all
00C617  2               search:
00C617  2  8D AB CB             STA     chrcnt          ;save number
00C61A  2               newtry:
00C61A  2  A2 00                LDX     #0              ;set for search
00C61C  2  8E AC CB             STX     cmppnt          ;clear pointer
00C61F  2  20 1C C7             JSR     nxtdir          ;get next entry
00C622  2  30 37                BMI     exitsr          ;exit if not found
00C624  2  AE AB CB             LDX     chrcnt          ;get count
00C627  2               mremch:
00C627  2  AC AC CB             LDY     cmppnt          ;get pointer
00C62A  2  EE AC CB             INC     cmppnt          ;and bump
00C62D  2  B1 02                LDA     (addinp),y      ;get fcb entry
00C62F  2  C0 0C                CPY     #12             ;see if at extent
00C631  2  D0 13                BNE     notaex          ;jump if not
00C633  2  8D 89 CB             STA     savext          ;save for later use
00C636  2  48                   PHA                     ;save extent
00C637  2  98                   TYA                     ;change to directory
00C638  2  0D A7 CB             ORA     subrec          ;coordinates
00C63B  2  A8                   TAY
00C63C  2  68                   PLA                     ;get extent back
00C63D  2  51 04                EOR     (bufadd),y      ;exclusive or with dir
00C63F  2  2D D3 CB             AND     cexm1f          ;and with exm complement + 1f
00C642  2  F0 11                BEQ     trynxt          ;ok if zero
00C644  2  D0 D4                BNE     newtry          ;else get next directory
00C646  2               notaex:
00C646  2  C9 3F                CMP     #'?'            ;if a ? then
00C648  2  F0 0B                BEQ     trynxt          ;is a match
00C64A  2  48                   PHA                     ;save char
00C64B  2  98                   TYA                     ;then add
00C64C  2  0D A7 CB             ORA     subrec          ;offset to
00C64F  2  A8                   TAY                     ;make pointer
00C650  2  68                   PLA                     ;get char back
00C651  2               ;        sta     savex
00C651  2               ;        lda	(bufadd),y	;if not same
00C651  2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
00C651  2               ;	cmp	savex	        ;if not same
00C651  2  D1 04                CMP     (bufadd),y      ;if not same
00C653  2  D0 C5                BNE     newtry          ;try next directory
00C655  2               trynxt:
00C655  2  CA                   DEX                     ;else count number down
00C656  2  D0 CF                BNE     mremch          ;and loop if more
00C658  2  AD B1 CB             LDA     dirmod          ;return with directory
00C65B  2               exitsr:
00C65B  2  60                   RTS                     ;number mod 4
00C65C  2               ;calculate logical record number
00C65C  2               ; input:blknum
00C65C  2               ; returns:none
00C65C  2               ; alters:a,x,p,recnum
00C65C  2               calrcn:
00C65C  2  AE BC CB             LDX     sxb             ;set x according to blkscd
00C65F  2               mulmre:
00C65F  2  0E A8 CB             ASL     blknum          ;multiply block
00C662  2  2E A9 CB             ROL     blknum+1        ;number
00C665  2  2E AA CB             ROL     blknum+2
00C668  2  CA                   DEX                     ;by code
00C669  2  D0 F4                BNE     mulmre
00C66B  2  AD BB CB             LDA     sab             ;set mask in a
00C66E  2  2D AD CB             AND     nxtrec          ;and with next record
00C671  2  0D A8 CB             ORA     recnum          ;or with number
00C674  2  8D A8 CB             STA     recnum          ;and save
00C677  2  60                   RTS
00C678  2               ;update directory
00C678  2               updtdr:
00C678  2  A9 20                LDA     #32             ;change all
00C67A  2  A2 00                LDX     #0              ;from start
00C67C  2               ;change directory entry
00C67C  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00C67C  2               ; returns:none
00C67C  2               ; alters:all,directory,checksums
00C67C  2               dirchg:
00C67C  2  8D AB CB             STA     chrcnt          ;save count
00C67F  2  CE AB CB             DEC     chrcnt          ;back up
00C682  2               mrechg:
00C682  2  18                   CLC                     ;clear carry
00C683  2  8A                   TXA                     ;get offset
00C684  2  6D AB CB             ADC     chrcnt          ;compute index
00C687  2  A8                   TAY                     ;and set
00C688  2  C0 0C                CPY     #12             ;see if at extent
00C68A  2  F0 04                BEQ     docare          ;if so do special
00C68C  2  C0 0F                CPY     #15             ;see if at number rec
00C68E  2  D0 05                BNE     dntcar          ;if not skip
00C690  2               docare:
00C690  2  2C 87 CB             BIT     skpdir          ;check flag
00C693  2  10 0D                BPL     nochng          ;skip if ok
00C695  2               dntcar:
00C695  2  B1 02                LDA     (addinp),y      ;get char
00C697  2  48                   PHA                     ;save it
00C698  2  AD AB CB             LDA     chrcnt          ;get count
00C69B  2  0D A7 CB             ORA     subrec          ;add offset
00C69E  2  A8                   TAY                     ;make an index
00C69F  2  68                   PLA                     ;get char back
00C6A0  2  91 04                STA     (bufadd),y      ;and put in buffer
00C6A2  2               nochng:
00C6A2  2  CE AB CB             DEC     chrcnt          ;count down
00C6A5  2  10 DB                BPL     mrechg          ;and loop
00C6A7  2  20 86 C4             JSR     drrcsu          ;set it up
00C6AA  2  4C 3A C8             JMP     updtck          ;and do change
00C6AD  2               ;execute create file
00C6AD  2               xmake:
00C6AD  2  20 0E C3             JSR     autodr          ;auto drive select
00C6B0  2               ;create file
00C6B0  2               ; input:fcb@(addinp)
00C6B0  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00C6B0  2               ; alters:dirnum,dirmod,fcb@(addinp)
00C6B0  2               mkefle:
00C6B0  2  20 11 C8             JSR     tstron          ;test for r/o
00C6B3  2  A5 02                LDA     addinp          ;save fcb
00C6B5  2  48                   PHA                     ;address
00C6B6  2  A5 03                LDA     addinp+1        ;on
00C6B8  2  48                   PHA                     ;stack
00C6B9  2  AD E0 CA             LDA     empdvc          ;then point
00C6BC  2  AC E1 CA             LDY     empdvc+1        ;to empty
00C6BF  2  85 02                STA     addinp          ;dummy
00C6C1  2  84 03                STY     addinp+1        ;fcb
00C6C3  2  A9 01                LDA     #1              ;match only
00C6C5  2  20 0F C6             JSR     frstsr          ;first char
00C6C8  2  68                   PLA                     ;restore
00C6C9  2  85 03                STA     addinp+1        ;fcb
00C6CB  2  68                   PLA                     ;address
00C6CC  2  85 02                STA     addinp          ;from stack
00C6CE  2  AD B1 CB             LDA     dirmod          ;get number mod 4
00C6D1  2  30 15                BMI     extmke          ;quit if not found
00C6D3  2  A0 0D                LDY     #13             ;else set up
00C6D5  2  A9 00                LDA     #0              ;to clear
00C6D7  2               mkeagn:
00C6D7  2  91 02                STA     (addinp),y      ;rest of
00C6D9  2  C8                   INY                     ;fcb
00C6DA  2  C0 21                CPY     #33             ;including next
00C6DC  2  D0 F9                BNE     mkeagn          ;record
00C6DE  2               ;the next two lines ensure that the extent and
00C6DE  2               ;number of records fields are updated
00C6DE  2  38                   SEC
00C6DF  2  6E 87 CB             ROR     skpdir
00C6E2  2  20 78 C6             JSR     updtdr          ;update directory
00C6E5  2  AD B1 CB             LDA     dirmod          ;get number
00C6E8  2               extmke:
00C6E8  2  60                   RTS                     ;and quit
00C6E9  2               ;extend file
00C6E9  2               ; input:fcb@(addinp), x=1 read
00C6E9  2               ;		        0 write
00C6E9  2               extend:
00C6E9  2  8E 95 CB             STX     exrwfl          ;save parameter
00C6EC  2  20 E9 C5             JSR     clsfle          ;close current extent
00C6EF  2  30 2A                BMI     extext          ;exit if not found
00C6F1  2  A0 0C                LDY     #12             ;else
00C6F3  2  B1 02                LDA     (addinp),y      ;get extent
00C6F5  2  18                   CLC                     ;and
00C6F6  2  69 01                ADC     #1              ;add one
00C6F8  2  29 1F                AND     #%00011111      ;see if overflow
00C6FA  2  F0 17                BEQ     exteof          ;eof if so
00C6FC  2  91 02                STA     (addinp),y      ;and save
00C6FE  2  20 0D C6             JSR     fndf13          ;see if next extent exists
00C701  2  10 0B                BPL     opnext          ;if so open
00C703  2  AD 95 CB             LDA     exrwfl          ;if not and is write then create
00C706  2  D0 13                BNE     extext          ;else return as eof
00C708  2               dwrtex:
00C708  2  20 B0 C6             JSR     mkefle          ;create file
00C70B  2  4C 11 C7             JMP     tstext          ;and test
00C70E  2               opnext:
00C70E  2  20 AE C5             JSR     opnfle          ;open
00C711  2               tstext:
00C711  2  10 03                BPL     extnok          ;continue if ok
00C713  2               exteof:
00C713  2  A9 01                LDA     #1              ;else set eof
00C715  2  60                   RTS                     ;and return
00C716  2               extnok:
00C716  2  20 8B C5             JSR     inrcct          ;initialize counters
00C719  2  A9 00                LDA     #0              ;good
00C71B  2               extext:
00C71B  2  60                   RTS                     ;return
00C71C  2               ;set up next directory block
00C71C  2               ; input:dirnum,x=1 for update checksum
00C71C  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00C71C  2               ; alters:alll,dirnum,dirmod
00C71C  2               nxtdir:
00C71C  2  8A                   TXA                     ;save operation
00C71D  2  48                   PHA                     ;on stack
00C71E  2  EE A5 CB             INC     dirnum          ;bump directory
00C721  2  D0 03                BNE     *+5
00C723  2  EE A6 CB             INC     dirnum+1
00C726  2               
00C726  2  AD CA CB             LDA     maxdir          ;if not at limit continue
00C729  2  CD A5 CB             CMP     dirnum
00C72C  2  AD CB CB             LDA     maxdir+1
00C72F  2  ED A6 CB             SBC     dirnum+1
00C732  2  B0 05                BCS     gtnxdr          ;then continue
00C734  2  68                   PLA                     ;else clear stack
00C735  2  AA                   TAX                     ;and set x
00C736  2  4C D5 C7             JMP     cldrnm          ;set to invalid
00C739  2               gtnxdr:
00C739  2  AD A5 CB             LDA     dirnum          ;get low again
00C73C  2  29 03                AND     #%00000011      ;look at 2 lsbs
00C73E  2  8D B1 CB             STA     dirmod          ;save mod 4
00C741  2  0A                   ASL     a               ;multiply
00C742  2  0A                   ASL     a               ;by
00C743  2  0A                   ASL     a               ;32 to
00C744  2  0A                   ASL     a               ;get pointer
00C745  2  0A                   ASL     a               ;offset
00C746  2  8D A7 CB             STA     subrec          ;and save
00C749  2  F0 05                BEQ     getdir          ;if zero read new
00C74B  2  68                   PLA                     ;else clear stack
00C74C  2  AA                   TAX                     ;set x
00C74D  2  4C 58 C7             JMP     gotdir          ;and exit
00C750  2               getdir:
00C750  2  20 86 C4             JSR     drrcsu          ;set up to read
00C753  2  20 34 C8             JSR     rdesec          ;do read
00C756  2  68                   PLA                     ;get operation
00C757  2  AA                   TAX                     ;code
00C758  2               ;;;;;;	jsr	chksop		;do it
00C758  2               gotdir:
00C758  2  AD B1 CB             LDA     dirmod          ;and return
00C75B  2               exnxdr:
00C75B  2  60                   RTS                     ;with number
00C75C  2               ;checksum operation
00C75C  2               ;this routine assumes calling routine has checked for
00C75C  2               ;valid dirnum and hence valid dirrec
00C75C  2               ; input:chkflg,dirrec,x (1=update else check)
00C75C  2               ; returns:none
00C75C  2               ; alters:map@(chkmap)
00C75C  2               chksop:
00C75C  2  60                   rts
00C75D  2  2C CE CB             BIT     chkflg          ;check flag
00C760  2  30 F9                BMI     exnxdr          ;done if set
00C762  2  CA                   DEX                     ;dec code
00C763  2  D0 09                BNE     tstchk          ;if not zero test
00C765  2  20 76 C5             JSR     clcchk          ;else calculate
00C768  2  20 BF C7             JSR     clcckp          ;calculate pointer
00C76B  2  91 08                STA     (chkpnt),y      ;and save
00C76D  2  60                   RTS                     ;then return
00C76E  2               tstchk:
00C76E  2  20 76 C5             JSR     clcchk          ;do calculation
00C771  2  20 BF C7             JSR     clcckp          ;calculate pointer
00C774  2  D1 08                CMP     (chkpnt),y      ;compare to old
00C776  2  F0 E3                BEQ     exnxdr          ;if equal ok
00C778  2  4C 69 C5             JMP     setron          ;else set to r/o
00C77B  2               ;get block number
00C77B  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00C77B  2               ; returns:none
00C77B  2               ; alters:all,blknum
00C77B  2               getblk:
00C77B  2  AE BC CB             LDX     sxb             ;set x according to blkscd
00C77E  2  AD AD CB             LDA     nxtrec          ;get next record
00C781  2               gblp:
00C781  2  4A                   LSR     a               ;divide by 2 x times
00C782  2  CA                   DEX
00C783  2  D0 FC                BNE     gblp
00C785  2  8D A8 CB             STA     blknum          ;save previous as temp
00C788  2               ;use extent as offset but first use sxb to create param
00C788  2  38                   SEC
00C789  2  A9 08                LDA     #8
00C78B  2  ED BC CB             SBC     sxb
00C78E  2  AA                   TAX
00C78F  2               ;now get extent from fcb
00C78F  2  A0 0C                LDY     #12
00C791  2  B1 02                LDA     (addinp),y
00C793  2  2D D2 CB             AND     exm             ;and with mask
00C796  2  4A                   LSR     a               ;shift with lsb to c
00C797  2               gbxlp:
00C797  2  2A                   ROL     a               ;now go other way
00C798  2  CA                   DEX
00C799  2  D0 FC                BNE     gbxlp
00C79B  2  18                   CLC                     ;now add saved value
00C79C  2  6D A8 CB             ADC     blknum          ;back
00C79F  2  2C B8 CB             BIT     blmode          ;test mode
00C7A2  2  10 01                BPL     *+3             ;skip if byte
00C7A4  2  0A                   ASL     a               ;else times two
00C7A5  2  18                   CLC                     ;then add
00C7A6  2  69 10                ADC     #16             ;offset into fcb
00C7A8  2  8D 88 CB             STA     fcbind          ;save for later
00C7AB  2  A8                   TAY                     ;set index
00C7AC  2  B1 02                LDA     (addinp),y      ;get number
00C7AE  2  8D A8 CB             STA     blknum          ;store
00C7B1  2  C8                   INY
00C7B2  2  A9 00                LDA     #0              ;clear
00C7B4  2  2C B8 CB             BIT     blmode          ;test mode
00C7B7  2  10 02                BPL     *+4             ;skip if byte
00C7B9  2  B1 02                LDA     (addinp),y      ;else get high
00C7BB  2  8D A9 CB             STA     blknum+1        ;high byte
00C7BE  2  60                   RTS                     ;and return
00C7BF  2               ;calculate chkpnt as function of dirrec and chkmap
00C7BF  2               ; input:dirrec,chkmap
00C7BF  2               ; returns:y=0
00C7BF  2               ; alters:y,p,chkpnt
00C7BF  2               clcckp:
00C7BF  2  48                   PHA                     ;save a
00C7C0  2  18                   CLC
00C7C1  2  AD AF CB             LDA     dirrec          ;add record number
00C7C4  2  6D CF CB             ADC     chkmap          ;to start
00C7C7  2  85 08                STA     chkpnt
00C7C9  2  AD B0 CB             LDA     dirrec+1
00C7CC  2  6D D0 CB             ADC     chkmap+1
00C7CF  2  85 09                STA     chkpnt+1
00C7D1  2  A0 00                LDY     #0
00C7D3  2  68                   PLA                     ;get a back
00C7D4  2  60                   RTS
00C7D5  2               ;clear directory number to $ffff
00C7D5  2               ; input:none
00C7D5  2               ; returns:a=$ff,n=1,z=0
00C7D5  2               ; alters:a,p,dirnum,dirmod
00C7D5  2               cldrnm:
00C7D5  2  A9 FF                LDA     #$ff            ;set to $ff
00C7D7  2  8D A5 CB             STA     dirnum
00C7DA  2  8D A6 CB             STA     dirnum+1
00C7DD  2  8D B1 CB             STA     dirmod
00C7E0  2  60                   RTS
00C7E1  2               ;change allocation map
00C7E1  2               ; input:subrec,directory record @ (bufadd)
00C7E1  2               ; returns:none
00C7E1  2               ; alters:all,allocation map
00C7E1  2               mapdir:
00C7E1  2  18                   CLC                     ;add 16 to
00C7E2  2  AD A7 CB             LDA     subrec          ;to subrec to point
00C7E5  2  69 10                ADC     #16             ;to block number field
00C7E7  2  A8                   TAY                     ;make index
00C7E8  2               lpmpdr:
00C7E8  2  8C B6 CB             STY     mpdrsy          ;save index
00C7EB  2  8A                   TXA                     ;save x
00C7EC  2  48                   PHA                     ;operation
00C7ED  2  B1 04                LDA     (bufadd),y      ;get block number
00C7EF  2  8D B7 CB             STA     mpdrtm          ;save in temp
00C7F2  2  C8                   INY                     ;bump index for word
00C7F3  2  20 75 C8             JSR     gthibn          ;get high part of number
00C7F6  2               mpdrnw:
00C7F6  2  0D B7 CB             ORA     mpdrtm          ;see if zero
00C7F9  2  F0 0A                BEQ     skpedr          ;skip if zero
00C7FB  2  20 75 C8             JSR     gthibn          ;get high again
00C7FE  2  A8                   TAY                     ;move to y
00C7FF  2  AD B7 CB             LDA     mpdrtm          ;get low again
00C802  2  20 53 C5             JSR     altalc          ;else alter map
00C805  2               skpedr:
00C805  2  68                   PLA                     ;get operation
00C806  2  AA                   TAX                     ;back
00C807  2  AC B6 CB             LDY     mpdrsy          ;get index back
00C80A  2  C8                   INY                     ;bump it
00C80B  2  98                   TYA                     ;if still
00C80C  2  29 0F                AND     #%00001111      ;in field
00C80E  2  D0 D8                BNE     lpmpdr          ;then loop
00C810  2  60                   RTS                     ;else quit
00C811  2               ;test r/w status
00C811  2               ;does warm boot if r/o
00C811  2               ; input:curdrv,ronlst
00C811  2               ; returns:none
00C811  2               ; alters:a,x,p
00C811  2               tstron:
00C811  2  20 81 C5             JSR     chkron          ;test bit
00C814  2  F0 1D                BEQ     exttro          ;exit if r/w
00C816  2  20 63 C8             JSR     errout          ;else send error
00C819  2  AD E3 CA             LDA     rommvc          ;point to r/o
00C81C  2  AC E4 CA             LDY     rommvc+1        ;message
00C81F  2  20 C7 C8             JSR     sndstr          ;send it
00C822  2  4C E6 C0             JMP     xwboot          ;then abort
00C825  2               ;set current drive to r/w
00C825  2               ; input:curdrv,ronlst
00C825  2               ; returns:ronlst
00C825  2               ; alters:a,x,p,ronlst
00C825  2               setrw:
00C825  2  AE A2 CB             LDX     curdrv          ;get drive
00C828  2  BD 77 CB             LDA     bitmap,x        ;and mask
00C82B  2  49 FF                EOR     #$ff            ;complement
00C82D  2  2D A4 CB             AND     ronlst          ;and with status
00C830  2  8D A4 CB             STA     ronlst          ;save
00C833  2               exttro:
00C833  2  60                   RTS                     ;return
00C834  2               ;read sector
00C834  2               rdesec:
00C834  2  20 03 CC             JSR     sim+39          ;do read
00C837  2               
00C837  2  4C 46 C8             JMP     chkrwe          ;check for error
00C83A  2               ;update checksum and directory
00C83A  2               updtck:
00C83A  2  A2 01                LDX     #1              ;set for update
00C83C  2               ;;;;;	jsr	chksop		;do it
00C83C  2  A9 01                LDA     #1              ;say is directory op
00C83E  2  D0 03                BNE     secwrt          ;do it
00C840  2               ;write sector
00C840  2               wrtsec:
00C840  2  AD D1 CB             LDA     pemwrtype       ;get write type
00C843  2               secwrt:
00C843  2  20 06 CC             JSR     sim+42          ;do write
00C846  2               
00C846  2               chkrwe:
00C846  2  C9 00                CMP     #0              ;if not ok
00C848  2  F0 E9                BEQ     exttro          ;done if zero
00C84A  2               ;read/write error
00C84A  2               rwerrt:
00C84A  2  20 63 C8             JSR     errout          ;send error message
00C84D  2  AD E6 CA             LDA     bdsmvc          ;point to
00C850  2  AC E7 CA             LDY     bdsmvc+1        ;bad sector message
00C853  2  20 C7 C8             JSR     sndstr          ;and send
00C856  2  20 82 C8             JSR     getcon          ;get input
00C859  2  C9 0D                CMP     #cr             ;if a cr
00C85B  2  F0 03                BEQ     ignerr          ;then continue
00C85D  2  4C E6 C0             JMP     xwboot          ;else abort
00C860  2               ignerr:
00C860  2  4C 5E CA             JMP     pcrlf           ;crlf and return
00C863  2               ;error output routine
00C863  2               ; input:curdrv,pemmvc
00C863  2               ; returns:none
00C863  2               ; alters:all
00C863  2               errout:
00C863  2  AD E9 CA             LDA     pemmvc          ;point to
00C866  2  AC EA CA             LDY     pemmvc+1        ;error message
00C869  2  20 C7 C8             JSR     sndstr          ;send it
00C86C  2  AD A2 CB             LDA     curdrv          ;get drive number
00C86F  2  18                   CLC                     ;add
00C870  2  69 41                ADC     #'A'            ;ascii a
00C872  2  4C 10 C9             JMP     sndchr          ;and send it
00C875  2               ;get high part of block number if word (zero if byte)
00C875  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00C875  2               ; returns:a=high part of block number
00C875  2               ; alters:a,p,mpdrsy iff word
00C875  2               gthibn:
00C875  2  A9 00                LDA     #0              ;preset for byte
00C877  2  2C B8 CB             BIT     blmode          ;test mode
00C87A  2  10 05                BPL     gthiex          ;done if byte
00C87C  2  B1 04                LDA     (bufadd),y      ;get high
00C87E  2  8C B6 CB             STY     mpdrsy          ;alter y
00C881  2               gthiex:
00C881  2  60                   RTS
00C882  2               ;get console input
00C882  2               ; input:pndkey
00C882  2               ; returns:a=character
00C882  2               ; alters:all,pndkey
00C882  2               getcon:
00C882  2  AD 8B CB             LDA     pndkey          ;get pending
00C885  2  48                   PHA                     ;save it
00C886  2  A9 00                LDA     #0              ;clear
00C888  2  8D 8B CB             STA     pndkey          ;pending
00C88B  2  68                   PLA                     ;restore
00C88C  2  D0 03                BNE     extget          ;exit if not null
00C88E  2  20 E5 CB             JSR     sim+9           ;else get new
00C891  2               
00C891  2               extget:
00C891  2  60                   RTS                     ;and return
00C892  2               ;check keyboard status
00C892  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00C892  2               ; input:pndkey
00C892  2               ; returns:a=0 if no input or <>0 if input
00C892  2               ; alters:all,pndkey
00C892  2               kbdsts:
00C892  2  AD 8B CB             LDA     pndkey          ;get pending
00C895  2  D0 20                BNE     extkbd          ;if there quit
00C897  2  20 E2 CB             JSR     sim+6           ;else test
00C89A  2  C9 00                CMP     #$00            ;if zero
00C89C  2  F0 19                BEQ     extkbd          ;exit
00C89E  2  20 E5 CB             JSR     sim+9           ;else get input
00C8A1  2  C9 13                CMP     #ctls           ;if not freeze
00C8A3  2  D0 0D                BNE     newpnd          ;save input
00C8A5  2  20 E5 CB             JSR     sim+9           ;else wait for more
00C8A8  2  C9 03                CMP     #ctlc           ;if not abort
00C8AA  2  D0 03                BNE     nowarm          ;then jump
00C8AC  2  4C E6 C0             JMP     xwboot          ;else do warm boot
00C8AF  2               nowarm:
00C8AF  2  A9 00                LDA     #0              ;clear
00C8B1  2  60                   RTS                     ;and return
00C8B2  2               newpnd:
00C8B2  2  8D 8B CB             STA     pndkey          ;save
00C8B5  2  A9 FF                LDA     #$ff            ;set ready
00C8B7  2               extkbd:
00C8B7  2  60                   RTS                     ;and return
00C8B8  2               ;test character
00C8B8  2               ; input:a=character
00C8B8  2               ; returns:c=0 if control or c=1 if printing
00C8B8  2               ; alters:p
00C8B8  2               tstchr:
00C8B8  2  C9 0D                CMP     #cr             ;if cr
00C8BA  2  F0 0A                BEQ     chtext          ;quit
00C8BC  2  C9 0A                CMP     #lf             ;if linefeed
00C8BE  2  F0 06                BEQ     chtext          ;quit
00C8C0  2  C9 09                CMP     #ctli           ;if tab
00C8C2  2  F0 02                BEQ     chtext          ;quit
00C8C4  2  C9 20                CMP     #' '            ;see if control
00C8C6  2               chtext:
00C8C6  2  60                   RTS                     ;and return
00C8C7  2               ;send string ending in $
00C8C7  2               ; input:ay=string address
00C8C7  2               ; returns:none
00C8C7  2               ; alters:all,index,sndlpe+1 and +2
00C8C7  2               sndstr:
00C8C7  2  8D D0 C8             STA     sndlpe+1        ;set pointer
00C8CA  2  8C D1 C8             STY     sndlpe+2
00C8CD  2  A0 00                LDY     #0
00C8CF  2               sndlpe:
00C8CF  2  B9 FF FF             LDA     $ffff,y         ;get char
00C8D2  2  C9 24                CMP     #'$'            ;if terminator
00C8D4  2  F0 0C                BEQ     sndext          ;then exit
00C8D6  2  C8                   INY                     ;else bump
00C8D7  2  8C B2 CB             STY     index           ;and save
00C8DA  2  20 10 C9             JSR     sndchr          ;send char
00C8DD  2  AC B2 CB             LDY     index           ;get index
00C8E0  2  D0 ED                BNE     sndlpe          ;and loop
00C8E2  2               sndext:
00C8E2  2  60                   RTS                     ;return
00C8E3  2               ;send char to printer if enabled
00C8E3  2               ; input:a=character,lstflg
00C8E3  2               ; returns:a=character
00C8E3  2               ; alters:x,y,p
00C8E3  2               lstout:
00C8E3  2  2C 8C CB             BIT     lstflg          ;test flag
00C8E6  2  10 0A                BPL     extlst          ;exit if off
00C8E8  2  2C B4 CB             BIT     outflg          ;test output flag
00C8EB  2  30 05                BMI     extlst          ;done if set
00C8ED  2  48                   PHA                     ;save char
00C8EE  2  20 EB CB             JSR     sim+15          ;send
00C8F1  2  68                   PLA                     ;get char
00C8F2  2               extlst:
00C8F2  2  60                   RTS                     ;and done
00C8F3  2               ;output a character
00C8F3  2               ; input:a=character,console definition block in sim
00C8F3  2               ; returns:none
00C8F3  2               ; alters:all,positn
00C8F3  2               output:
00C8F3  2  20 B8 C8             JSR     tstchr          ;test it
00C8F6  2  B0 18                BCS     sndchr          ;if not control jump
00C8F8  2  48                   PHA                     ;else save
00C8F9  2  AD 16 CC             LDA     sysdef+4        ;get invert
00C8FC  2  20 29 C9             JSR     nolist          ;send to console
00C8FF  2  A9 5E                LDA     #'^'            ;get arrow
00C901  2  20 E3 C8             JSR     lstout          ;send to printer
00C904  2  68                   PLA                     ;get character
00C905  2  09 40                ORA     #'A'-1          ;convert to ascii
00C907  2  20 21 C9             JSR     pchrot          ;send to all
00C90A  2  AD 15 CC             LDA     sysdef+3        ;get normal
00C90D  2  4C 29 C9             JMP     nolist          ;to console
00C910  2               sndchr:
00C910  2  C9 09                CMP     #ctli           ;if not tab
00C912  2  D0 0D                BNE     pchrot          ;send
00C914  2               tabspc:
00C914  2  A9 20                LDA     #' '            ;else get space
00C916  2  20 21 C9             JSR     pchrot          ;send
00C919  2  AD 8D CB             LDA     positn          ;get count
00C91C  2  29 07                AND     #7              ;if not mod 8
00C91E  2  D0 F4                BNE     tabspc          ;loop
00C920  2  60                   RTS                     ;else exit
00C921  2               pchrot:
00C921  2  48                   PHA                     ;save char
00C922  2  20 92 C8             JSR     kbdsts          ;test input
00C925  2  68                   PLA                     ;restore
00C926  2  20 E3 C8             JSR     lstout          ;to printer if on
00C929  2               nolist:
00C929  2  48                   PHA                     ;save again
00C92A  2  2C B4 CB             BIT     outflg          ;test flag
00C92D  2  30 03                BMI     *+5             ;done if set
00C92F  2  20 E8 CB             JSR     sim+12          ;to console
00C932  2  68                   PLA                     ;restore
00C933  2  EE 8D CB             INC     positn          ;bump col
00C936  2  C9 20                CMP     #' '            ;if space or more
00C938  2  B0 26                BCS     extchr          ;is ok
00C93A  2  CD 14 CC             CMP     sysdef+2        ;also ok
00C93D  2  F0 21                BEQ     extchr          ;if forward
00C93F  2  CE 8D CB             DEC     positn          ;else drop back
00C942  2  CD 12 CC             CMP     sysdef+0        ;see if bs
00C945  2  D0 06                BNE     tryotr          ;branch if not
00C947  2  CE 8D CB             DEC     positn          ;else drop again
00C94A  2  30 0F                BMI     zrocol          ;zero if <0
00C94C  2  60                   RTS                     ;else ok
00C94D  2               tryotr:
00C94D  2  C9 0D                CMP     #cr             ;if a cr
00C94F  2  F0 0A                BEQ     zrocol          ;clear col
00C951  2  CD 19 CC             CMP     sysdef+7        ;if a formfeed
00C954  2  F0 05                BEQ     zrocol          ;also clear
00C956  2  CD 1A CC             CMP     sysdef+8        ;if not home
00C959  2  D0 05                BNE     extchr          ;then done
00C95B  2               zrocol:
00C95B  2  A9 00                LDA     #0              ;clear
00C95D  2  8D 8D CB             STA     positn          ;column
00C960  2               extchr:
00C960  2  60                   RTS                     ;and exit
00C961  2               ;go to left and space past prompt
00C961  2               ; input:frscol,positn
00C961  2               ; returns:none
00C961  2               ; alters:positn
00C961  2               spcovr:
00C961  2  A9 0D                LDA     #cr             ;get cr
00C963  2  20 21 C9             JSR     pchrot          ;send to all
00C966  2  A9 0A                LDA     #lf             ;send lf
00C968  2  20 E3 C8             JSR     lstout          ;only to printer
00C96B  2               mreovr:
00C96B  2  AD 8A CB             LDA     frscol          ;get first
00C96E  2  CD 8D CB             CMP     positn          ;see if there
00C971  2  F0 ED                BEQ     extchr          ;done if is
00C973  2  AD 14 CC             LDA     sysdef+2        ;get forward
00C976  2  20 29 C9             JSR     nolist          ;send it
00C979  2  4C 6B C9             JMP     mreovr          ;and loop
00C97C  2               ;buffered read
00C97C  2               ; input:buffer@(addinp)
00C97C  2               ; returns:none
00C97C  2               ; alters:all,buffer@(addinp)
00C97C  2               bufinp:
00C97C  2  A9 00                LDA     #0              ;clear
00C97E  2  A0 01                LDY     #1              ;length
00C980  2  91 02                STA     (addinp),y      ;position in buffer
00C982  2  8C 94 CB             STY     bufpsn          ;set point to 1
00C985  2  AD 8D CB             LDA     positn          ;get current
00C988  2  8D 8A CB             STA     frscol          ;and save
00C98B  2               nxtinp:
00C98B  2  20 82 C8             JSR     getcon          ;get input
00C98E  2  AC 94 CB             LDY     bufpsn          ;get index
00C991  2  C9 0D                CMP     #cr             ;if not a cr
00C993  2  D0 03                BNE     notcr           ;then jump
00C995  2  4C 5B CA             JMP     endlin          ;else done
00C998  2               notcr:
00C998  2  C9 08                CMP     #delete         ;if not delete
00C99A  2  D0 5E                BNE     ntdelt          ;then jump
00C99C  2  C0 01                CPY     #1              ;else if start
00C99E  2  F0 EB                BEQ     nxtinp          ;then loop
00C9A0  2  B1 02                LDA     (addinp),y      ;get last
00C9A2  2  48                   PHA                     ;save char
00C9A3  2  A0 01                LDY     #1              ;point to count
00C9A5  2  38                   SEC                     ;set carry
00C9A6  2  B1 02                LDA     (addinp),y      ;get count
00C9A8  2  E9 01                SBC     #1              ;decrement
00C9AA  2  91 02                STA     (addinp),y      ;then save
00C9AC  2  68                   PLA                     ;restore char
00C9AD  2  CE 94 CB             DEC     bufpsn          ;backup pointer
00C9B0  2  C9 20                CMP     #' '            ;if space or more
00C9B2  2  B0 40                BCS     nrmbs           ;just backspace
00C9B4  2  C9 09                CMP     #ctli           ;see if tab
00C9B6  2  D0 30                BNE     ctlbs           ;if not is control
00C9B8  2  38                   SEC                     ;set flag
00C9B9  2  6E B4 CB             ROR     outflg
00C9BC  2  AD 8D CB             LDA     positn          ;get position and save
00C9BF  2  8D B5 CB             STA     lstcol
00C9C2  2  20 61 C9             JSR     spcovr          ;else go back
00C9C5  2  20 68 CA             JSR     rptlne          ;and retype
00C9C8  2  AD 8D CB             LDA     positn          ;get new last position
00C9CB  2  48                   PHA                     ;save on stack
00C9CC  2  38                   SEC                     ;subtract to get delta
00C9CD  2  AD B5 CB             LDA     lstcol
00C9D0  2  ED 8D CB             SBC     positn
00C9D3  2  8D B5 CB             STA     lstcol          ;and save
00C9D6  2  0E B4 CB             ASL     outflg          ;clear flag
00C9D9  2               bstab:
00C9D9  2  20 88 CA             JSR     dobs            ;do one
00C9DC  2  CE B5 CB             DEC     lstcol          ;drop count
00C9DF  2  D0 F8                BNE     bstab           ;loop if more
00C9E1  2  68                   PLA                     ;get position
00C9E2  2  8D 8D CB             STA     positn          ;and set
00C9E5  2  4C 8B C9             JMP     nxtinp          ;then loop
00C9E8  2               ctlbs:
00C9E8  2  AD 15 CC             LDA     sysdef+3        ;get normal
00C9EB  2  20 84 CA             JSR     chkbs           ;bs if printing
00C9EE  2  AD 16 CC             LDA     sysdef+4        ;same for invert
00C9F1  2  20 84 CA             JSR     chkbs           ;then delete char itself
00C9F4  2               nrmbs:
00C9F4  2  20 88 CA             JSR     dobs            ;do a backspace
00C9F7  2  4C 8B C9             JMP     nxtinp          ;and loop
00C9FA  2               ntdelt:
00C9FA  2  C9 10                CMP     #ctlp           ;if not ctl-p
00C9FC  2  D0 0B                BNE     ntctlp          ;then jump
00C9FE  2  AD 8C CB             LDA     lstflg          ;else get printer flag
00CA01  2  49 FF                EOR     #$ff            ;complement
00CA03  2  8D 8C CB             STA     lstflg          ;save
00CA06  2  4C 8B C9             JMP     nxtinp          ;and loop
00CA09  2               ntctlp:
00CA09  2  C9 18                CMP     #ctlx           ;if not ctl-x
00CA0B  2  D0 0C                BNE     ntctlx          ;then jump
00CA0D  2  20 61 C9             JSR     spcovr          ;restart
00CA10  2  AD 13 CC             LDA     sysdef+1        ;get clear to eol
00CA13  2  20 29 C9             JSR     nolist          ;send it
00CA16  2  4C 7C C9             JMP     bufinp          ;and start over
00CA19  2               ntctlx:
00CA19  2  C9 12                CMP     #ctlr           ;if not ctl-r
00CA1B  2  D0 09                BNE     ntctlr          ;then jump
00CA1D  2  20 61 C9             JSR     spcovr          ;restart
00CA20  2  20 68 CA             JSR     rptlne          ;retype line
00CA23  2  4C 8B C9             JMP     nxtinp          ;and start over
00CA26  2               ntctlr:
00CA26  2  C8                   INY                     ;next position
00CA27  2  91 02                STA     (addinp),y      ;store char
00CA29  2  48                   PHA                     ;and save
00CA2A  2  8C 94 CB             STY     bufpsn          ;index
00CA2D  2  A0 01                LDY     #1              ;point to count
00CA2F  2  98                   TYA                     ;set a to 1
00CA30  2  18                   CLC                     ;then
00CA31  2  71 02                ADC     (addinp),y      ;add count
00CA33  2  91 02                STA     (addinp),y      ;and save
00CA35  2  68                   PLA                     ;restore char
00CA36  2               dontsv:
00CA36  2  20 F3 C8             JSR     output          ;send char
00CA39  2  AC 94 CB             LDY     bufpsn          ;get index
00CA3C  2  B1 02                LDA     (addinp),y      ;get char
00CA3E  2  C9 03                CMP     #ctlc           ;if not ctl-c
00CA40  2  D0 0B                BNE     ignrcc          ;ignore
00CA42  2  A0 01                LDY     #1              ;get count
00CA44  2  B1 02                LDA     (addinp),y      ;from buffer
00CA46  2  C9 01                CMP     #1              ;if not at start
00CA48  2  D0 03                BNE     ignrcc          ;ignore
00CA4A  2  4C E6 C0             JMP     xwboot          ;else do warm boot
00CA4D  2               ignrcc:
00CA4D  2  A0 01                LDY     #1              ;get
00CA4F  2  B1 02                LDA     (addinp),y      ;count
00CA51  2  88                   DEY                     ;point to max
00CA52  2  D1 02                CMP     (addinp),y      ;if length
00CA54  2  B0 03                BCS     lineen          ;at max jump
00CA56  2  4C 8B C9             JMP     nxtinp          ;else loop
00CA59  2               lineen:
00CA59  2  A9 0D                LDA     #cr             ;get a cr
00CA5B  2               endlin:
00CA5B  2  4C 21 C9             JMP     pchrot          ;and send
00CA5E  2               ;cr and lf
00CA5E  2               pcrlf:
00CA5E  2  A9 0D                LDA     #cr             ;then a
00CA60  2  20 21 C9             JSR     pchrot          ;cr
00CA63  2  A9 0A                LDA     #lf             ;and a
00CA65  2  4C 21 C9             JMP     pchrot          ;lf
00CA68  2               ;retype line
00CA68  2               rptlne:
00CA68  2  AD 94 CB             LDA     bufpsn          ;save point
00CA6B  2  8D B3 CB             STA     numcnt          ;as count
00CA6E  2  A9 01                LDA     #1              ;start position
00CA70  2  48                   PHA                     ;save
00CA71  2               mrerpt:
00CA71  2  68                   PLA                     ;get position
00CA72  2  CE B3 CB             DEC     numcnt          ;count down
00CA75  2  D0 01                BNE     *+3             ;continue if more
00CA77  2  60                   RTS                     ;else done
00CA78  2  A8                   TAY                     ;else make index
00CA79  2  C8                   INY                     ;and bump
00CA7A  2  98                   TYA                     ;save
00CA7B  2  48                   PHA                     ;on stack
00CA7C  2  B1 02                LDA     (addinp),y      ;get char
00CA7E  2  20 F3 C8             JSR     output          ;send
00CA81  2  4C 71 CA             JMP     mrerpt          ;and loop
00CA84  2               ;check for printing and backspace if needed
00CA84  2               chkbs:
00CA84  2  C9 20                CMP     #' '            ;compare to space
00CA86  2  90 19                BCC     extdec          ;not printing so done
00CA88  2               ;do a backspace
00CA88  2               dobs:
00CA88  2  AD 12 CC             LDA     sysdef+0        ;get backspace
00CA8B  2  48                   PHA                     ;save it
00CA8C  2  20 29 C9             JSR     nolist          ;send
00CA8F  2  A9 20                LDA     #' '            ;get space
00CA91  2  20 29 C9             JSR     nolist          ;send
00CA94  2  68                   PLA                     ;get backspace
00CA95  2  4C 29 C9             JMP     nolist          ;send it
00CA98  2               ;test for decimal digit
00CA98  2               ;if decimal then c=0 else c=1
00CA98  2               tstdec:
00CA98  2  C9 30                CMP     #'0'            ;if under 0
00CA9A  2  90 04                BCC     notdec          ;then not decimal
00CA9C  2  C9 3A                CMP     #'9'+1          ;if 9 or under is ok
00CA9E  2  90 01                BCC     extdec
00CAA0  2               notdec:
00CAA0  2  38                   SEC                     ;else not a match
00CAA1  2               extdec:
00CAA1  2  60                   RTS
00CAA2  2               ;test for hexadecimal digit
00CAA2  2               ;if hex then c=0 else c=1
00CAA2  2               tsthex:
00CAA2  2  20 98 CA             JSR     tstdec          ;first try decimal
00CAA5  2  90 FA                BCC     extdec          ;ok if dec
00CAA7  2  C9 41                CMP     #'A'            ;if under A
00CAA9  2  90 F5                BCC     notdec          ;then not hex
00CAAB  2  C9 47                CMP     #'F'+1          ;set c in F compare
00CAAD  2  60                   RTS
00CAAE  2               ;bump load address by 128 and return in ay
00CAAE  2               adjdb:
00CAAE  2  AD EF BF             LDA     dskbuf          ;get old
00CAB1  2  AC F0 BF             LDY     dskbuf+1        ;address
00CAB4  2  18                   CLC                     ;and bump
00CAB5  2  69 80                ADC     #128            ;by 128
00CAB7  2  8D EF BF             STA     dskbuf          ;save low
00CABA  2  90 04                BCC     *+6             ;then bump
00CABC  2  C8                   INY                     ;and save
00CABD  2  8C F0 BF             STY     dskbuf+1        ;high as needed
00CAC0  2  60                   RTS
00CAC1  2               ;move record from disk buffer to default buffer
00CAC1  2               mv128:
00CAC1  2  AD EF BF             LDA     dskbuf          ;get address
00CAC4  2  AC F0 BF             LDY     dskbuf+1
00CAC7  2  8D D0 CA             STA     mvfrom+1        ;and set pointer
00CACA  2  8C D1 CA             STY     mvfrom+2
00CACD  2  A2 00                LDX     #0              ;clear index
00CACF  2               mvfrom:
00CACF  2  BD FF FF             LDA     $ffff,x         ;get byte
00CAD2  2  9D 28 01             STA     dflbuf,x        ;move it
00CAD5  2  E8                   INX
00CAD6  2  10 F7                BPL     mvfrom          ;loop until done
00CAD8  2  60                   RTS
00CAD9  2               
00CAD9  2               ;relocatable vectors
00CAD9  2  4C                   .BYTE   $4c
00CADA  2               extevc:
00CADA  2  45 C0                .WORD   extexq-1
00CADC  2  4C                   .BYTE   $4c
00CADD  2               sltmvc:
00CADD  2  39 CB                .WORD   sltmsg
00CADF  2  4C                   .BYTE   $4c
00CAE0  2               empdvc:
00CAE0  2  4A CB                .WORD   empty
00CAE2  2  4C                   .BYTE   $4c
00CAE3  2               rommvc:
00CAE3  2  EF CA                .WORD   romsg
00CAE5  2  4C                   .BYTE   $4c
00CAE6  2               bdsmvc:
00CAE6  2  F6 CA                .WORD   bdsmsg
00CAE8  2  4C                   .BYTE   $4c
00CAE9  2               pemmvc:
00CAE9  2  29 CB                .WORD   pemmsg
00CAEB  2  4C                   .BYTE   $4c
00CAEC  2               dcbevc:
00CAEC  2  C3 CB                .WORD   dcb
00CAEE  2               ;relocation stopper
00CAEE  2  FF                   .BYTE   $ff
00CAEF  2               ;messages
00CAEF  2               romsg:
00CAEF  2  20 2D 20 52          .BYTE   " - R/O$"
00CAF3  2  2F 4F 24     
00CAF6  2               bdsmsg:
00CAF6  2  20 2D 20 42          .BYTE   " - BAD SECTOR"
00CAFA  2  41 44 20 53  
00CAFE  2  45 43 54 4F  
00CB03  2  0D 0A 3C 52          .BYTE   cr,lf,"<RET> TO IGNORE -- <OTHER> "
00CB07  2  45 54 3E 20  
00CB0B  2  54 4F 20 49  
00CB20  2  54 4F 20 41          .BYTE   "TO ABORT$"
00CB24  2  42 4F 52 54  
00CB28  2  24           
00CB29  2               pemmsg:
00CB29  2  0D 0A 50 45          .BYTE   cr,lf,"PEM ERROR ON $"
00CB2D  2  4D 20 45 52  
00CB31  2  52 4F 52 20  
00CB39  2               sltmsg:
00CB39  2  20 2D 20 49          .BYTE   " - INVALID DRIVE$"
00CB3D  2  4E 56 41 4C  
00CB41  2  49 44 20 44  
00CB4A  2               
00CB4A  2               ;dummy fcb
00CB4A  2               empty:
00CB4A  2  E5                   .BYTE   $e5
00CB4B  2               ;zero page switch enable table
00CB4B  2               swctbl:
00CB4B  2  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0
00CB4F  2  00 00 00 00  
00CB53  2  00 00 01 00          .BYTE   0,0,1,0,0,1,1,1
00CB57  2  00 01 01 01  
00CB5B  2  01 01 01 01          .BYTE   1,1,1,1,1,1,1,1
00CB5F  2  01 01 01 01  
00CB63  2  00 00 01 00          .BYTE   0,0,1,0,0,0,0,0
00CB67  2  00 00 00 00  
00CB6B  2  00 00 00 00          .BYTE   0,0,0,0
00CB6F  2               ;bit mask table
00CB6F  2               bitmsk:
00CB6F  2  80 40 20 10          .BYTE   128,64,32,16,8,4,2,1
00CB73  2  08 04 02 01  
00CB77  2               ;bit map table
00CB77  2               bitmap:
00CB77  2  01 02 04 08          .BYTE   1,2,4,8,16,32,64,128
00CB7B  2  10 20 40 80  
00CB7F  2               ;extent mask table (also uses 3 bytes in sabtbl
00CB7F  2               exmtbl:
00CB7F  2  00 01 03             .BYTE   0,1,3
00CB82  2               ;sab table
00CB82  2               sabtbl:
00CB82  2  07 0F 1F 3F          .BYTE   7,15,31,63,127
00CB86  2  7F           
00CB87  2               ;variable storage
00CB87  2               skpdir:
00CB87  2  00                   .BYTE   0               ;positive if no change
00CB88  2               fcbind:
00CB88  2  00                   .BYTE   0               ;index to block number
00CB89  2               savext:
00CB89  2  00                   .BYTE   0               ;save extent
00CB8A  2               frscol:
00CB8A  2  00                   .BYTE   0               ;first col
00CB8B  2               pndkey:
00CB8B  2  00                   .BYTE   0               ;pending input
00CB8C  2               lstflg:
00CB8C  2  00                   .BYTE   0               ;printer flag
00CB8D  2               positn:
00CB8D  2  00                   .BYTE   0               ;print position
00CB8E  2               swcflg:
00CB8E  2  00                   .BYTE   0               ;zero page switch flag
00CB8F  2               bytinp:
00CB8F  2  00 00                .WORD   0               ;input value
00CB91  2               cmdinp:
00CB91  2  00                   .BYTE   0               ;input command
00CB92  2               addout:
00CB92  2  00 00                .WORD   0               ;output address
00CB94  2               bytout          = addout        ;output value
00CB94  2               bufpsn:
00CB94  2  00                   .BYTE   0               ;input buffer position
00CB95  2               exrwfl:
00CB95  2  00                   .BYTE   0               ;extend flag
00CB96  2               tmpdrv:
00CB96  2  00                   .BYTE   0               ;temporary drive number
00CB97  2               ;align xqtvec on word boundary
00CB97  2  xx                   .ALIGN  2
00CB98  2               xqtvec:
00CB98  2  00 00                .WORD   0               ;command vector
00CB9A  2               countr:
00CB9A  2  00 00                .WORD   0               ;record counter
00CB9C  2  00                   .BYTE   0               ;overflow
00CB9D  2               lkdown:
00CB9D  2  00 00                .WORD   0               ;down pnt. for block search
00CB9F  2               lookup:
00CB9F  2  00 00                .WORD   0               ;up pnt. for block search
00CBA1  2               olddrv:
00CBA1  2  00                   .BYTE   0               ;old drive number
00CBA2  2               curdrv:
00CBA2  2  00                   .BYTE   0               ;current drive
00CBA3  2               lginvc:
00CBA3  2  00                   .BYTE   0               ;log in status
00CBA4  2               ronlst:
00CBA4  2  00                   .BYTE   0               ;read write status
00CBA5  2               dirnum:
00CBA5  2  00 00                .WORD   0               ;directory number
00CBA7  2               subrec:
00CBA7  2  00                   .BYTE   0               ;directory offset
00CBA8  2               recnum:
00CBA8  2  00 00                .WORD   0               ;record number
00CBAA  2               blknum          = recnum        ;block number
00CBAA  2  00                   .BYTE   0               ;overflow
00CBAB  2               chrcnt:
00CBAB  2  00                   .BYTE   0               ;character count
00CBAC  2               cmppnt:
00CBAC  2  00                   .BYTE   0               ;comparison pointer
00CBAD  2               nxtrec:
00CBAD  2  00                   .BYTE   0               ;next record
00CBAE  2               numrec:
00CBAE  2  00                   .BYTE   0               ;number records
00CBAF  2               dirrec:
00CBAF  2  00 00                .WORD   0               ;directory record
00CBB1  2               dirmod:
00CBB1  2  00                   .BYTE   0               ;directory mod 4
00CBB2  2               index:
00CBB2  2  00                   .BYTE   0               ;buffer index
00CBB3  2               numcnt:
00CBB3  2  00                   .BYTE   0               ;counter
00CBB4  2               outflg:
00CBB4  2  00                   .BYTE   0               ;output enable flag
00CBB5  2               lstcol:
00CBB5  2  00                   .BYTE   0               ;last column
00CBB6  2               mpdrsy:
00CBB6  2  00                   .BYTE   0               ;save for y in mapdir
00CBB7  2               mpdrtm:
00CBB7  2  00                   .BYTE   0               ;temp in mapdir
00CBB8  2               blmode:
00CBB8  2  00                   .BYTE   0               ;<128 if byte else word
00CBB9  2               maxdrc:
00CBB9  2  00 00                .WORD   0               ;max directory record
00CBBB  2               sab:
00CBBB  2  00                   .BYTE   0               ;mask for block
00CBBC  2               sxb:
00CBBC  2  00                   .BYTE   0               ;shift for block
00CBBD  2               rtclk:
00CBBD  2  00 00 00             .BYTE   0,0,0           ;real time clock
00CBC0  2               gpcnt:
00CBC0  2  00 00                .WORD   0               ;gp counter
00CBC2  2               trkctr:
00CBC2  2  00                   .BYTE   0               ;track counter
00CBC3  2               ;following region is used to capture dcb
00CBC3  2               dcb:
00CBC3  2               maxblk:
00CBC3  2  00 00                .WORD   0               ;maximum block number
00CBC5  2               sectrk:
00CBC5  2  00 00                .WORD   0               ;sectors per track
00CBC7  2               nsystr:
00CBC7  2  00 00                .WORD   0               ;number system tracks
00CBC9  2               blkscd:
00CBC9  2  00                   .BYTE   0               ;block size code
00CBCA  2               maxdir:
00CBCA  2  00 00                .WORD   0               ;maximum directory number
00CBCC  2               alcmap:
00CBCC  2  00 00                .WORD   0               ;address of allocation map
00CBCE  2               chkflg:
00CBCE  2  00                   .BYTE   0               ;check flag
00CBCF  2               chkmap:
00CBCF  2  00 00                .WORD   0               ;address of checksum map
00CBD1  2               pemwrtype:
00CBD1  2  00                   .BYTE   0               ;write type 0=norm,1=dir,2=unalloc
00CBD2  2               exm:
00CBD2  2  00                   .BYTE   0               ;extent mask
00CBD3  2               cexm1f:
00CBD3  2  00                   .BYTE   0               ;exm complemented and 1f
00CBD4  2               ;zero page save block
00CBD4  2               varblk:
00CBD4  2               lowin:
00CBD4  2  xx xx xx xx          .RES    numvar
00CBD8  2  xx xx xx xx  
00CBDC  2               
00CBDC  1                       .INCLUDE "simrbc.asm"
00CBDC  2               ;--------------------------------
00CBDC  2               ;dos/65 system interface module (sim)
00CBDC  2               ;--------------------------------
00CBDC  2               
00CBDC  2               
00CBDC  2               ;dos/65 system interface module (sim)
00CBDC  2               ;version 3.00
00CBDC  2               ;this version is designed to work with the 6x0x
00CBDC  2               
00CBDC  2               ;fixed parameters
00CBDC  2               simstart:
00CBDC  2               
00CBDC  2               ;main program
00CBDC  2               ;jump vector used by pem
00CBDC  2               sim:
00CBDC  2  4C 2E CD             JMP     boot            ;from cold start
00CBDF  2               wboote:
00CBDF  2  4C DF CD             JMP     wboot           ;from warm boot
00CBE2  2  4C D2 CE             JMP     consts          ;check for input
00CBE5  2  4C D9 CE             JMP     conrde          ;get input
00CBE8  2  4C E0 CE             JMP     conwrt          ;send to terminal
00CBEB  2  4C E9 CE             JMP     prnwrt          ;printer output
00CBEE  2  4C EA CE             JMP     punwrt          ;punch output
00CBF1  2  4C EB CE             JMP     rdrinp          ;reader input
00CBF4  2  4C 05 CE             JMP     home            ;home drive
00CBF7  2  4C E7 CD             JMP     seldsk          ;select disk
00CBFA  2  4C 09 CE             JMP     seltrk          ;set track
00CBFD  2  4C 10 CE             JMP     selsec          ;set sector
00CC00  2  4C CD CE             JMP     setdma          ;set buffer address
00CC03  2  4C 17 CE             JMP     read            ;read sector
00CC06  2  4C 64 CE             JMP     write           ;write sector
00CC09  2  A9 01                LDA     #1              ;printer always ready
00CC0B  2  60                   RTS
00CC0C  2  4C EC CE             JMP     rdtime          ;clock entry
00CC0F  2  4C EF CE             JMP     xlate           ;translate
00CC12  2               
00CC12  2               ;console definition block
00CC12  2               sysdef:
00CC12  2  08                   .BYTE   8               ;backspace
00CC13  2  01                   .BYTE   1               ;clear to end of line
00CC14  2  0C                   .BYTE   $c              ;forward space
00CC15  2  00                   .BYTE   0               ;normal video
00CC16  2  5E                   .BYTE   '^'             ;invert video
00CC17  2  18                   .BYTE   24              ;lines per screen
00CC18  2  50                   .BYTE   80              ;char per line
00CC19  2  0C                   .BYTE   $c              ;formfeed
00CC1A  2  1E                   .BYTE   $1e             ;home
00CC1B  2  02                   .BYTE   2               ;clear to end of screen
00CC1C  2               
00CC1C  2               ;opening id message
00CC1C  2               opnmsg:
00CC1C  2  0D 0A                .BYTE   cr, lf
00CC1E  2               
00CC1E  2  64 38 38 38          .BYTE   "d8888b.  .d88b.  .d8888.    dD     ooooo", cr, lf
00CC22  2  38 62 2E 20  
00CC26  2  20 2E 64 38  
00CC48  2  38 38 20 20          .BYTE   "88  `8D .8P  Y8. 88'  YP   d8'    8P~~~~", cr, lf
00CC4C  2  60 38 44 20  
00CC50  2  2E 38 50 20  
00CC72  2  38 38 20 20          .BYTE   "88   88 88    88 `8bo.    d8'    dP", cr, lf
00CC76  2  20 38 38 20  
00CC7A  2  38 38 20 20  
00CC97  2  38 38 20 20          .BYTE   "88   88 88    88   `Y8b. d8888b. V8888b.", cr, lf,0
00CC9B  2  20 38 38 20  
00CC9F  2  38 38 20 20  
00CCC2  2               opnmsg1:
00CCC2  2  38 38 20 20          .BYTE   "88  .8D `8b  d8' db   8D 88' `8D     `8D ", cr, lf
00CCC6  2  2E 38 44 20  
00CCCA  2  60 38 62 20  
00CCED  2  59 38 38 38          .BYTE   "Y8888D'  `Y88P'  `8888Y' `8888P  88oobY'", cr, lf
00CCF1  2  38 44 27 20  
00CCF5  2  20 60 59 38  
00CD17  2  44 4F 53 2F          .BYTE   "DOS/65 V3.00", cr, lf, 0
00CD1B  2  36 35 20 56  
00CD1F  2  33 2E 30 30  
00CD26  2               
00CD26  2               DSKYMSG:
00CD26  2  54 6E 5C 5E          .BYTE   $54, $6E, $5C, $5E, $6E, $54, $79, $40
00CD2A  2  6E 54 79 40  
00CD2E  2               
00CD2E  2               ;cold entry from loader
00CD2E  2               boot:
00CD2E  2                       .IFDEF  DUODYNE
00CD2E  2                       CLD                     ; VERIFY DECIMAL MODE IS OFF
00CD2E  2                       CLC                     ;
00CD2E  2                       XCE                     ; SET NATIVE MODE
00CD2E  2                       ACCUMULATORINDEX16
00CD2E  2                       LDA     #STACK          ; get the stack address
00CD2E  2                       TCS                     ; and set the stack to it
00CD2E  2                       ACCUMULATORINDEX8
00CD2E  2                       .ELSE
00CD2E  2  78                   SEI
00CD2F  2  A2 FF                LDX     #$ff            ;set stack
00CD31  2  9A                   TXS                     ;pointer
00CD32  2  D8                   CLD                     ;set binary mode
00CD33  2                       .ENDIF
00CD33  2               
00CD33  2  A9 1C                LDA     #<opnmsg        ;point to message
00CD35  2  A0 CC                LDY     #>opnmsg
00CD37  2  20 F0 CE             JSR     outmsg          ;send it
00CD3A  2  A9 C2                LDA     #<opnmsg1       ;point to message
00CD3C  2  A0 CC                LDY     #>opnmsg1
00CD3E  2  20 F0 CE             JSR     outmsg          ;send it
00CD41  2               ;set up jumps into dos/65 in page one
00CD41  2               
00CD41  2               ; setup diskconfig table
00CD41  2  A2 00                LDX     #0
00CD43  2               :
00CD43  2  BD F8 D0             LDA     dftdskcfg, x
00CD46  2  9D 17 06             STA     dskcfg, x
00CD49  2  E8                   INX
00CD4A  2  E0 10                CPX     #$10
00CD4C  2  D0 F5                BNE     :-
00CD4E  2               
00CD4E  2  A9 28                LDA     #40             ; DSKY INITIALIZE
00CD50  2  85 32                STA     farfunct
00CD52  2  20 F0 FF             JSR     DO_FARCALL
00CD55  2               
00CD55  2  A9 34                LDA     #52             ; RTC_RESET
00CD57  2  85 32                STA     farfunct
00CD59  2  20 F0 FF             JSR     DO_FARCALL
00CD5C  2               
00CD5C  2  A9 3C                LDA     #60             ; IDE INITIALIZE
00CD5E  2  85 32                STA     farfunct
00CD60  2  20 F0 FF             JSR     DO_FARCALL
00CD63  2               
00CD63  2  A9 3F                LDA     #63             ; SD INITIALIZE
00CD65  2  85 32                STA     farfunct
00CD67  2  20 F0 FF             JSR     DO_FARCALL
00CD6A  2               
00CD6A  2  A9 42                LDA     #66             ; FLOPPY INITIALIZE
00CD6C  2  85 32                STA     farfunct
00CD6E  2  20 F0 FF             JSR     DO_FARCALL
00CD71  2               
00CD71  2  A9 3F                LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
00CD73  2  85 30                STA     cmdlnp
00CD75  2  A9 BF                LDA     #>cnstxt
00CD77  2  85 31                STA     cmdlnp + 1
00CD79  2               
00CD79  2  A9 17                LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00CD7B  2  85 2E                STA     dskcfpc
00CD7D  2  A9 06                LDA     #>dskcfg
00CD7F  2  85 2F                STA     dskcfpc + 1
00CD81  2               
00CD81  2  A9 88                LDA     #<dcba          ; STORE POINTER TO DCB TABLES FOR APPS
00CD83  2  85 2C                STA     dcbpc
00CD85  2  A9 D0                LDA     #>dcba
00CD87  2  85 2D                STA     dcbpc + 1
00CD89  2               
00CD89  2               
00CD89  2               setup:
00CD89  2  A2 00                LDX     #0              ;clear index
00CD8B  2               ;
00CD8B  2  A9 3F                LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
00CD8D  2  85 30                STA     cmdlnp
00CD8F  2  A9 BF                LDA     #>cnstxt
00CD91  2  85 31                STA     cmdlnp + 1
00CD93  2               
00CD93  2  A9 17                LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00CD95  2  85 2E                STA     dskcfpc
00CD97  2  A9 06                LDA     #>dskcfg
00CD99  2  85 2F                STA     dskcfpc + 1
00CD9B  2               
00CD9B  2  A9 88                LDA     #<dcba          ; STORE POINTER TO DCB TABLES FOR APPS
00CD9D  2  85 2C                STA     dcbpc
00CD9F  2  A9 D0                LDA     #>dcba
00CDA1  2  85 2D                STA     dcbpc + 1
00CDA3  2               ;
00CDA3  2               ;first clear key dba variables
00CDA3  2               ;        STX     hstact          ;host buffer inactive
00CDA3  2               ;        STX     unacnt          ;clear unalloc count
00CDA3  2               setupl:
00CDA3  2  BD D9 CD             LDA     inttbl,x        ;get byte
00CDA6  2  9D 00 01             STA     $100,x          ;insert at start
00CDA9  2  E8                   INX
00CDAA  2  E0 06                CPX     #6
00CDAC  2  D0 F5                BNE     setupl          ;loop until done
00CDAE  2  A9 28                LDA     #<dflbuf        ;get low buffer
00CDB0  2  A0 01                LDY     #>dflbuf        ;and high
00CDB2  2  20 CD CE             JSR     setdma          ;and set
00CDB5  2  AD 16 06             LDA     sekdsk          ;get disk
00CDB8  2               
00CDB8  2  A2 00                LDX     #$00            ; SHOW A STARTUP MESSAGE ON DSKY
00CDBA  2               :
00CDBA  2  BD 26 CD             LDA     DSKYMSG,x
00CDBD  2  9D 00 06             STA     DSKY_BUF,x
00CDC0  2  E8                   INX
00CDC1  2  E0 08                CPX     #8
00CDC3  2  D0 F5                BNE     :-
00CDC5  2  A9 29                LDA     #41             ; DSKY_SHOW
00CDC7  2  85 32                STA     farfunct
00CDC9  2  20 F0 FF             JSR     DO_FARCALL
00CDCC  2               
00CDCC  2  A9 00                LDA     #DEFDRV         ;set zero
00CDCE  2  20 E7 CD             JSR     seldsk          ;and select drive zero
00CDD1  2  20 05 CE             JSR     home            ;home that drive
00CDD4  2  A9 00                LDA     #DEFDRV         ;set zero
00CDD6  2  4C 03 B8             JMP     ccm             ;and go to ccm
00CDD9  2               ;initialization table
00CDD9  2               inttbl:
00CDD9  2  4C DF CB 4C          .BYTE   $4c,<wboote,>wboote,$4c,<pem,>pem
00CDDD  2  FA BF        
00CDDF  2               ;warm boot-read dos/65 back except sim and then
00CDDF  2               ; jump to ccm.
00CDDF  2               
00CDDF  2               
00CDDF  2               wboot:
00CDDF  2                       .IFDEF  DUODYNE
00CDDF  2                       CLD                     ; VERIFY DECIMAL MODE IS OFF
00CDDF  2                       CLC                     ;
00CDDF  2                       XCE                     ; SET NATIVE MODE
00CDDF  2                       ACCUMULATORINDEX16
00CDDF  2                       LDA     #STACK          ; get the stack address
00CDDF  2                       TCS                     ; and set the stack to it
00CDDF  2                       ACCUMULATORINDEX8
00CDDF  2                       PHK
00CDDF  2                       PLB
00CDDF  2                       .ELSE
00CDDF  2  78                   SEI
00CDE0  2  A2 FF                LDX     #$ff            ;set stack
00CDE2  2  9A                   TXS                     ;pointer
00CDE3  2  D8                   CLD                     ;set binary mode
00CDE4  2                       .ENDIF
00CDE4  2               
00CDE4  2  4C 89 CD             JMP     setup           ;go setup
00CDE7  2               
00CDE7  2               
00CDE7  2               
00CDE7  2               ;__SELDSK_________________________________________________________________________________________________
00CDE7  2               ;
00CDE7  2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
00CDE7  2               ;________________________________________________________________________________________________________
00CDE7  2               ;select disk
00CDE7  2               seldsk:
00CDE7  2  29 07                AND     #7              ;eight drives only
00CDE9  2  8D 16 06             STA     sekdsk          ;save for later
00CDEC  2  0A                   ASL     a               ;multiply by two
00CDED  2  AA                   TAX                     ;make an Index
00CDEE  2  BD F5 CD             LDA     dcbtbl,x        ;get address
00CDF1  2  BC F6 CD             LDY     dcbtbl+1,x
00CDF4  2  60                   RTS
00CDF5  2               
00CDF5  2               ;table of dcb addresses
00CDF5  2               dcbtbl:
00CDF5  2  88 D0                .WORD   dcba
00CDF7  2  96 D0                .WORD   dcbb
00CDF9  2  A4 D0                .WORD   dcbc
00CDFB  2  B2 D0                .WORD   dcbd
00CDFD  2  C0 D0                .WORD   dcbe
00CDFF  2  CE D0                .WORD   dcbf
00CE01  2  DC D0                .WORD   dcbg
00CE03  2  EA D0                .WORD   dcbh
00CE05  2               
00CE05  2               
00CE05  2               
00CE05  2               ;__HOME__________________________________________________________________________________________________
00CE05  2               ;
00CE05  2               ; 	PERFORM DOS/65 HEAD HOME
00CE05  2               ;________________________________________________________________________________________________________
00CE05  2               home:
00CE05  2  A9 00                LDA     #$00
00CE07  2  A0 00                LDY     #$00
00CE09  2               
00CE09  2               ;__SELTRK________________________________________________________________________________________________
00CE09  2               ;
00CE09  2               ; 	PERFORM DOS/65 SELECT TRACK
00CE09  2               ;
00CE09  2               ;	A=TRACK LOW BYTE
00CE09  2               ;	Y=TRACK HIGH BYTE
00CE09  2               ;________________________________________________________________________________________________________
00CE09  2               seltrk:
00CE09  2  8D 0C 06             STA     sektrk          ;save number
00CE0C  2  8C 0D 06             STY     sektrk+1
00CE0F  2  60                   RTS
00CE10  2               
00CE10  2               ;__SELSEC________________________________________________________________________________________________
00CE10  2               ;
00CE10  2               ; 	PERFORM DOS/65 SECTOR SELECT
00CE10  2               ;
00CE10  2               ;	A=SECTOR LOW BYTE
00CE10  2               ;	Y=SECTOR HIGH BYTE
00CE10  2               ;________________________________________________________________________________________________________
00CE10  2               selsec:
00CE10  2  8D 0E 06             STA     seksec          ;save low and high
00CE13  2  8C 0F 06             STY     seksec+1
00CE16  2  60                   RTS
00CE17  2               
00CE17  2               ;__READ__________________________________________________________________________________________________
00CE17  2               ;
00CE17  2               ; PERFORM DOS / 65 SECTOR READ
00CE17  2               ;________________________________________________________________________________________________________
00CE17  2               read:
00CE17  2  20 66 D0             JSR     GET_DRIVE_DEVICE;
00CE1A  2  29 F0                AND     #$F0            ; only want first nybble
00CE1C  2  C9 00                CMP     #$00
00CE1E  2  D0 0B                BNE     :+              ; not MD drive
00CE20  2               ;MD
00CE20  2  A9 40                LDA     #64             ; md read sector
00CE22  2  85 32                STA     farfunct
00CE24  2  20 F0 FF             JSR     DO_FARCALL
00CE27  2  20 0D D0             JSR     DEBSECR
00CE2A  2  60                   RTS
00CE2B  2               :
00CE2B  2  C9 10                CMP     #$10
00CE2D  2  D0 0E                BNE     :+              ; not SD drive
00CE2F  2               ;SD
00CE2F  2                       .IFDEF DUODYNE
00CE2F  2                       .ELSE
00CE2F  2  20 04 CF             JSR     CONVERT_SECTOR_LBA
00CE32  2                       .ENDIF
00CE32  2  A9 40                LDA     #64             ; sd read sector
00CE34  2  85 32                STA     farfunct
00CE36  2  20 F0 FF             JSR     DO_FARCALL
00CE39  2  20 0D D0             JSR     DEBSECR
00CE3C  2  60                   RTS
00CE3D  2               :
00CE3D  2  C9 20                CMP     #$20
00CE3F  2  D0 0E                BNE     :+              ; not floppy drive
00CE41  2               ;FD
00CE41  2                       .IFDEF DUODYNE
00CE41  2                       .ELSE
00CE41  2  20 CF CF             JSR     SETUP_FD_CHS
00CE44  2                       .ENDIF
00CE44  2  A9 43                LDA     #67             ; floppy read sector
00CE46  2  85 32                STA     farfunct
00CE48  2  20 F0 FF             JSR     DO_FARCALL
00CE4B  2  20 0D D0             JSR     DEBSECR
00CE4E  2  60                   RTS
00CE4F  2               :
00CE4F  2  C9 30                CMP     #$30
00CE51  2  D0 0E                BNE     :+              ; invalid drive
00CE53  2               ;PPIDE
00CE53  2                       .IFDEF DUODYNE
00CE53  2                       .ELSE
00CE53  2  20 04 CF             JSR     CONVERT_SECTOR_LBA
00CE56  2                       .ENDIF
00CE56  2  A9 3D                LDA     #61             ; IDE_READ_SECTOR
00CE58  2  85 32                STA     farfunct
00CE5A  2  20 F0 FF             JSR     DO_FARCALL
00CE5D  2  20 0D D0             JSR     DEBSECR
00CE60  2  60                   RTS
00CE61  2               :
00CE61  2  A9 FF                LDA     #$FF            ; signal error
00CE63  2  60                   RTS                     ;
00CE64  2               
00CE64  2               
00CE64  2               ;__WRITE_________________________________________________________________________________________________
00CE64  2               ;
00CE64  2               ; PERFORM DOS / 65 SECTOR WRITE
00CE64  2               ;________________________________________________________________________________________________________
00CE64  2               write:
00CE64  2  20 66 D0             JSR     GET_DRIVE_DEVICE;
00CE67  2  29 F0                AND     #$F0            ; only want first nybble
00CE69  2               
00CE69  2  C9 00                CMP     #$00
00CE6B  2  D0 12                BNE     :+              ; not MD drive
00CE6D  2               ;MD
00CE6D  2  A9 40                LDA     #64             ;PPP_READ_SECTOR
00CE6F  2  85 32                STA     farfunct
00CE71  2  20 F0 FF             JSR     DO_FARCALL
00CE74  2  20 38 D0             JSR     BLKSECR
00CE77  2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
00CE79  2  85 32                STA     farfunct
00CE7B  2  20 F0 FF             JSR     DO_FARCALL
00CE7E  2  60                   RTS
00CE7F  2               :
00CE7F  2  C9 10                CMP     #$10
00CE81  2  D0 15                BNE     :+              ; not SD drive
00CE83  2               ;SD
00CE83  2                       .IFDEF DUODYNE
00CE83  2                       .ELSE
00CE83  2  20 04 CF             JSR     CONVERT_SECTOR_LBA
00CE86  2                       .ENDIF
00CE86  2               
00CE86  2  A9 40                LDA     #64             ;PPP_READ_SECTOR
00CE88  2  85 32                STA     farfunct
00CE8A  2  20 F0 FF             JSR     DO_FARCALL
00CE8D  2  20 38 D0             JSR     BLKSECR
00CE90  2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
00CE92  2  85 32                STA     farfunct
00CE94  2  20 F0 FF             JSR     DO_FARCALL
00CE97  2  60                   RTS
00CE98  2               :
00CE98  2               
00CE98  2  C9 20                CMP     #$20
00CE9A  2  D0 15                BNE     :+              ; not floppy drive
00CE9C  2               ;FD
00CE9C  2                       .IFDEF DUODYNE
00CE9C  2                       .ELSE
00CE9C  2  20 CF CF             JSR     SETUP_FD_CHS
00CE9F  2                       .ENDIF
00CE9F  2  A9 43                LDA     #67             ; floppy read sector
00CEA1  2  85 32                STA     farfunct
00CEA3  2  20 F0 FF             JSR     DO_FARCALL
00CEA6  2  20 38 D0             JSR     BLKSECR
00CEA9  2  A9 44                LDA     #68             ; floppy write sector
00CEAB  2  85 32                STA     farfunct
00CEAD  2  20 F0 FF             JSR     DO_FARCALL
00CEB0  2  60                   RTS
00CEB1  2               :
00CEB1  2  C9 30                CMP     #$30
00CEB3  2  D0 15                BNE     :+              ; invalid drive
00CEB5  2               ;PPIDE
00CEB5  2                       .IFDEF DUODYNE
00CEB5  2                       .ELSE
00CEB5  2  20 04 CF             JSR     CONVERT_SECTOR_LBA
00CEB8  2                       .ENDIF
00CEB8  2               
00CEB8  2  A9 3D                LDA     #61             ; IDE read sector
00CEBA  2  85 32                STA     farfunct
00CEBC  2  20 F0 FF             JSR     DO_FARCALL
00CEBF  2  20 38 D0             JSR     BLKSECR
00CEC2  2  A9 3E                LDA     #62             ; IDE_WRITE_SECTOR
00CEC4  2  85 32                STA     farfunct
00CEC6  2  20 F0 FF             JSR     DO_FARCALL
00CEC9  2  60                   RTS
00CECA  2               :
00CECA  2  A9 FF                LDA     #$FF            ; signal error
00CECC  2  60                   RTS                     ;
00CECD  2               
00CECD  2               
00CECD  2               ;__SETDMA________________________________________________________________________________________________
00CECD  2               ;
00CECD  2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
00CECD  2               ;
00CECD  2               ;	A=BUFFER LOW BYTE
00CECD  2               ;	Y=BUFFER HIGH BYTE
00CECD  2               ;________________________________________________________________________________________________________
00CECD  2               setdma:
00CECD  2  85 F4                STA     dmaadr          ;store low
00CECF  2  84 F5                STY     dmaadr+1        ;and high
00CED1  2  60                   RTS
00CED2  2               
00CED2  2               
00CED2  2               ;__CONSTS________________________________________________________________________________________________
00CED2  2               ;
00CED2  2               ; 	GET DOS/65 CONSOLE STATUS
00CED2  2               ;________________________________________________________________________________________________________
00CED2  2               consts:
00CED2  2  A9 03                LDA     #03
00CED4  2  85 32                STA     farfunct
00CED6  2  4C F0 FF             JMP     DO_FARCALL
00CED9  2               
00CED9  2               ;__CONRDE________________________________________________________________________________________________
00CED9  2               ;
00CED9  2               ; 	PERFORM DOS/65 CONSOLE READ
00CED9  2               ;________________________________________________________________________________________________________
00CED9  2               conrde:
00CED9  2  A9 02                LDA     #02
00CEDB  2  85 32                STA     farfunct
00CEDD  2  4C F0 FF             JMP     DO_FARCALL      ;console read
00CEE0  2               
00CEE0  2               ;__CONWRT________________________________________________________________________________________________
00CEE0  2               ;
00CEE0  2               ; 	PERFORM DOS/65 CONSOLE WRITE
00CEE0  2               ;________________________________________________________________________________________________________
00CEE0  2               conwrt:
00CEE0  2  48                   PHA
00CEE1  2  A9 00                LDA     #00
00CEE3  2  85 32                STA     farfunct
00CEE5  2  68                   PLA
00CEE6  2  4C F0 FF             JMP     DO_FARCALL
00CEE9  2               
00CEE9  2               prnwrt:
00CEE9  2  60                   RTS                     ;printer
00CEEA  2               punwrt:
00CEEA  2  60                   RTS                     ;punch output
00CEEB  2               rdrinp:
00CEEB  2  60                   RTS                     ;reader input
00CEEC  2               rdtime:
00CEEC  2  A2 80                LDX     #128
00CEEE  2  60                   RTS                     ;read clock
00CEEF  2               xlate:
00CEEF  2  60                   RTS                     ;sector translate
00CEF0  2               
00CEF0  2               
00CEF0  2               ;__OUTMSG________________________________________________________________________________________________
00CEF0  2               ;
00CEF0  2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
00CEF0  2               ;
00CEF0  2               ;	A=POINTER LOW BYTE
00CEF0  2               ;	Y=POINTER HIGH BYTE
00CEF0  2               ;________________________________________________________________________________________________________
00CEF0  2               outmsg: ;output message
00CEF0  2  85 F0                STA     OUTMSG_W
00CEF2  2  84 F1                STY     OUTMSG_W+1
00CEF4  2  A0 00                LDY     #$00
00CEF6  2               OUTSTRLP:
00CEF6  2  B1 F0                LDA     (OUTMSG_W),Y    ; LOAD NEXT CHAR FROM STRING INTO ACC
00CEF8  2  C9 00                CMP     #$00            ; IS NULL?
00CEFA  2  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00CEFC  2  20 E0 CE             JSR     conwrt          ; PRINT CHAR IN ACC
00CEFF  2  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
00CF00  2  4C F6 CE             JMP     OUTSTRLP        ; DO NEXT CHAR
00CF03  2               ENDOUTSTR:
00CF03  2  60                   RTS                     ; RETURN
00CF04  2               
00CF04  2                       .IFDEF DUODYNE
00CF04  2                       .ELSE
00CF04  2               
00CF04  2               ;___CONVERT_SECTOR_LBA___________________________________________________________________________________
00CF04  2               ;
00CF04  2               ; 	TRANSLATE LBA SECTORS
00CF04  2               ;________________________________________________________________________________________________________
00CF04  2               CONVERT_SECTOR_LBA:
00CF04  2  AD 0C 06             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
00CF07  2  29 0F                AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
00CF09  2  0A                   ASL     a               ; MOVE TO HIGH BYTE
00CF0A  2  0A                   ASL     a
00CF0B  2  0A                   ASL     a
00CF0C  2  0A                   ASL     a
00CF0D  2  AA                   TAX                     ; PARK IN X
00CF0E  2  AD 0E 06             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
00CF11  2  4A                   LSR     A               ;
00CF12  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
00CF13  2  29 0F                AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
00CF15  2  8D 12 06             STA     debsehd         ; STORE IN SECTOR/HEAD
00CF18  2  8A                   TXA                     ; GET HEAD BACK
00CF19  2  0D 12 06             ORA     debsehd
00CF1C  2  8D 12 06             STA     debsehd         ; STORE IN SECTOR/HEAD
00CF1F  2               
00CF1F  2  AD 0C 06             LDA     sektrk
00CF22  2  8D 10 06             STA     debcyll         ; STORE IN TRACK (lsb)
00CF25  2  AD 0D 06             LDA     sektrk+1
00CF28  2  8D 11 06             STA     debcylm         ; STORE IN TRACK (msb)
00CF2B  2               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
00CF2B  2  AD 11 06             LDA     debcylm
00CF2E  2  4A                   LSR     A
00CF2F  2  8D 11 06             STA     debcylm
00CF32  2  AD 10 06             LDA     debcyll
00CF35  2  6A                   ROR     A
00CF36  2  8D 10 06             STA     debcyll
00CF39  2               
00CF39  2  AD 11 06             LDA     debcylm
00CF3C  2  4A                   LSR     A
00CF3D  2  8D 11 06             STA     debcylm
00CF40  2  AD 10 06             LDA     debcyll
00CF43  2  6A                   ROR     A
00CF44  2  8D 10 06             STA     debcyll
00CF47  2               
00CF47  2  AD 11 06             LDA     debcylm
00CF4A  2  4A                   LSR     A
00CF4B  2  8D 11 06             STA     debcylm
00CF4E  2  AD 10 06             LDA     debcyll
00CF51  2  6A                   ROR     A
00CF52  2  8D 10 06             STA     debcyll
00CF55  2               
00CF55  2  AD 11 06             LDA     debcylm
00CF58  2  4A                   LSR     A
00CF59  2  8D 11 06             STA     debcylm
00CF5C  2  AD 10 06             LDA     debcyll
00CF5F  2  6A                   ROR     A
00CF60  2  8D 10 06             STA     debcyll
00CF63  2               ;	ADD SLICE OFFSET
00CF63  2  AD 16 06             LDA     sekdsk          ; GET DRIVE#
00CF66  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00CF68  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00CF69  2  AA                   TAX                     ; MOVE TO X REGISTER
00CF6A  2  E8                   INX                     ; WANT SECOND BYTE OF ENTRY
00CF6B  2  BD 17 06             LDA     dskcfg,X        ; GET SLICE#
00CF6E  2  8D 32 06             STA     slicetmp+1      ; SLICE OFFSET MSB
00CF71  2  A9 00                LDA     #0              ; GET SLICE#
00CF73  2  8D 31 06             STA     slicetmp        ; SLICE OFFSET LSB
00CF76  2  18                   CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
00CF77  2  6E 32 06             ROR     slicetmp+1
00CF7A  2  6E 31 06             ROR     slicetmp
00CF7D  2  6E 32 06             ROR     slicetmp+1
00CF80  2  6E 31 06             ROR     slicetmp
00CF83  2               
00CF83  2  BD 17 06             LDA     dskcfg,X        ; GET SLICE#
00CF86  2  18                   CLC
00CF87  2  6D 31 06             ADC     slicetmp
00CF8A  2  8D 31 06             STA     slicetmp
00CF8D  2  A9 00                LDA     #$00            ; LOGIC ERROR FOR SLICES THAT CARRY?
00CF8F  2  6D 32 06             ADC     slicetmp+1      ;
00CF92  2  8D 32 06             STA     slicetmp+1      ;
00CF95  2               
00CF95  2               ; ADD SLICE OFFSET TO TRACK #
00CF95  2  18                   CLC                     ; clear carry
00CF96  2  AD 31 06             LDA     slicetmp
00CF99  2  6D 10 06             ADC     debcyll
00CF9C  2  8D 10 06             STA     debcyll         ; store sum of LSBs
00CF9F  2  AD 32 06             LDA     slicetmp+1
00CFA2  2  6D 11 06             ADC     debcylm         ; add the MSBs using carry from
00CFA5  2  8D 11 06             STA     debcylm         ; the previous calculation
00CFA8  2               
00CFA8  2               
00CFA8  2               ; DISPLAY ON DSKY IF PRESENT
00CFA8  2  AD 16 06             LDA     sekdsk
00CFAB  2  8D 08 06             STA     DSKY_HEXBUF
00CFAE  2  AD 11 06             LDA     debcylm
00CFB1  2  8D 09 06             STA     DSKY_HEXBUF+1
00CFB4  2  AD 10 06             LDA     debcyll
00CFB7  2  8D 0A 06             STA     DSKY_HEXBUF+2
00CFBA  2  AD 12 06             LDA     debsehd
00CFBD  2  8D 0B 06             STA     DSKY_HEXBUF+3
00CFC0  2  A9 2A                LDA     #42             ; DSKY_BIN2SEG
00CFC2  2  85 32                STA     farfunct
00CFC4  2  20 F0 FF             JSR     DO_FARCALL
00CFC7  2  A9 29                LDA     #41             ; DSKY_SHOW
00CFC9  2  85 32                STA     farfunct
00CFCB  2  20 F0 FF             JSR     DO_FARCALL
00CFCE  2  60                   RTS
00CFCF  2               
00CFCF  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
00CFCF  2               ;
00CFCF  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
00CFCF  2               ;________________________________________________________________________________________________________________________________
00CFCF  2               ;
00CFCF  2               SETUP_FD_CHS:
00CFCF  2  AD 0C 06             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
00CFD2  2  29 01                AND     #$01            ; FILTER OUT HEAD
00CFD4  2  8D 11 06             STA     debcylm         ; STORE HEAD
00CFD7  2  AD 0C 06             LDA     sektrk          ; SAVE TRACK IN A
00CFDA  2  4A                   LSR     A               ; REMOVE HEAD BIT
00CFDB  2  8D 10 06             STA     debcyll         ; STORE IN TRACK
00CFDE  2  AD 0E 06             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
00CFE1  2  4A                   LSR     A               ;
00CFE2  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
00CFE3  2  8D 12 06             STA     debsehd         ; STORE IN SECTOR
00CFE6  2               
00CFE6  2  AD 16 06             LDA     sekdsk
00CFE9  2  8D 08 06             STA     DSKY_HEXBUF
00CFEC  2  AD 11 06             LDA     debcylm
00CFEF  2  8D 09 06             STA     DSKY_HEXBUF+1
00CFF2  2  AD 10 06             LDA     debcyll
00CFF5  2  8D 0A 06             STA     DSKY_HEXBUF+2
00CFF8  2  AD 12 06             LDA     debsehd
00CFFB  2  8D 0B 06             STA     DSKY_HEXBUF+3
00CFFE  2  A9 2A                LDA     #42             ; DSKY_BIN2SEG
00D000  2  85 32                STA     farfunct
00D002  2  20 F0 FF             JSR     DO_FARCALL
00D005  2  A9 29                LDA     #41             ; DSKY_SHOW
00D007  2  85 32                STA     farfunct
00D009  2  20 F0 FF             JSR     DO_FARCALL
00D00C  2  60                   RTS
00D00D  2               
00D00D  2                       .ENDIF
00D00D  2               
00D00D  2               
00D00D  2               ;___DEBSECR______________________________________________________________________________________________
00D00D  2               ;
00D00D  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
00D00D  2               ;
00D00D  2               ;________________________________________________________________________________________________________
00D00D  2               DEBSECR:
00D00D  2  08                   PHP
00D00E  2  48                   PHA
00D00F  2  AD 0E 06             LDA     seksec          ;
00D012  2  29 03                AND     #$03            ; GET SECTOR INDEX
00D014  2  18                   CLC                     ;
00D015  2  2A                   ROL     A               ;
00D016  2  AA                   TAX                     ;
00D017  2  BD 30 D0             LDA     DEBTAB,X        ;
00D01A  2  85 EE                STA     SRC
00D01C  2  E8                   INX
00D01D  2  BD 30 D0             LDA     DEBTAB,X        ;
00D020  2  85 EF                STA     SRC+1           ;
00D022  2  A5 F4                LDA     dmaadr          ;
00D024  2  85 EC                STA     DEST            ;
00D026  2  A5 F5                LDA     dmaadr+1        ;
00D028  2  85 ED                STA     DEST+1          ;
00D02A  2  20 59 D0             JSR     COPY_DOS_SECTOR ;
00D02D  2  68                   PLA
00D02E  2  28                   PLP
00D02F  2  60                   RTS
00D030  2               
00D030  2               DEBTAB:
00D030  2  00 04                .WORD   hstbuf          ;
00D032  2  80 04                .WORD   hstbuf+128      ;
00D034  2  00 05                .WORD   hstbuf+256      ;
00D036  2  80 05                .WORD   hstbuf+384      ;
00D038  2               
00D038  2               
00D038  2               ;___BLKSECR______________________________________________________________________________________________
00D038  2               ;
00D038  2               ;	BLOCK 512 BYTE SECTOR FOR DOS/65
00D038  2               ;
00D038  2               ;________________________________________________________________________________________________________
00D038  2               BLKSECR:
00D038  2  08                   PHP
00D039  2  AD 0E 06             LDA     seksec          ;
00D03C  2  29 03                AND     #$03            ; GET SECTOR INDEX
00D03E  2  18                   CLC                     ;
00D03F  2  2A                   ROL     A               ;
00D040  2  AA                   TAX                     ;
00D041  2  BD 30 D0             LDA     DEBTAB,X        ;
00D044  2  85 EC                STA     DEST
00D046  2  E8                   INX
00D047  2  BD 30 D0             LDA     DEBTAB,X        ;
00D04A  2  85 ED                STA     DEST+1          ;
00D04C  2  A5 F4                LDA     dmaadr          ;
00D04E  2  85 EE                STA     SRC             ;
00D050  2  A5 F5                LDA     dmaadr+1        ;
00D052  2  85 EF                STA     SRC+1           ;
00D054  2  20 59 D0             JSR     COPY_DOS_SECTOR ;
00D057  2  28                   PLP
00D058  2  60                   RTS
00D059  2               
00D059  2               
00D059  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00D059  2               ;
00D059  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
00D059  2               ;
00D059  2               ;________________________________________________________________________________________________________
00D059  2               COPY_DOS_SECTOR:
00D059  2  A0 00                LDY     #$00            ;
00D05B  2               COPY_DOS_SECTOR1:
00D05B  2  B1 EE                LDA     (SRC),Y         ;
00D05D  2  91 EC                STA     (DEST),Y        ;
00D05F  2  C8                   INY                     ;
00D060  2  98                   TYA                     ;
00D061  2  C9 80                CMP     #$80            ;
00D063  2  D0 F6                BNE     COPY_DOS_SECTOR1;
00D065  2  60                   RTS
00D066  2               
00D066  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00D066  2               ;
00D066  2               ; GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00D066  2               ;
00D066  2               ;________________________________________________________________________________________________________
00D066  2               GET_DRIVE_DEVICE:
00D066  2  8E 87 D0             STX     GET_DRIVE_DEVICE_TMP
00D069  2  AD 16 06             LDA     sekdsk          ; GET DRIVE
00D06C  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00D06E  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00D06F  2  AA                   TAX                     ; MOVE TO X REGISTER
00D070  2  BD 17 06             LDA     dskcfg, X       ; GET device
00D073  2  29 0F                AND     #$0F
00D075  2  8D 3D 06             STA     currentDrive
00D078  2  BD 17 06             LDA     dskcfg, X       ; GET device
00D07B  2               ; SETUP FLOPPY CONTROL WHILE WE ARE HERE
00D07B  2  29 01                AND     #$01
00D07D  2  8D 28 06             STA     DSKUNIT
00D080  2  BD 17 06             LDA     dskcfg, X       ; GET device
00D083  2  AE 87 D0             LDX     GET_DRIVE_DEVICE_TMP
00D086  2  60                   RTS
00D087  2               
00D087  2               GET_DRIVE_DEVICE_TMP:
00D087  2  00                   .BYTE   00
00D088  2               ;------------------------------------------------------------------------------------
00D088  2               
00D088  2                       .IFDEF  RBC6X0X
00D088  2               ;disk control blocks
00D088  2               dcba:
00D088  2  FF 07                .WORD   2047            ;max block number
00D08A  2  40 00                .WORD   64              ;sectors per track
00D08C  2  10 00                .WORD   16              ;number system tracks
00D08E  2  02                   .BYTE   2               ;block size = 4096
00D08F  2  FF 01                .WORD   511             ;max directory number
00D091  2  08 D1                .WORD   almpa           ;address of map for a
00D093  2  80                   .BYTE   128             ;no checksums
00D094  2  08 D9                .WORD   ckmp            ;checksum map
00D096  2               dcbb:
00D096  2  FF 07                .WORD   2047            ;max block number
00D098  2  40 00                .WORD   64              ;sectors per track
00D09A  2  10 00                .WORD   16              ;number system tracks
00D09C  2  02                   .BYTE   2               ;block size = 4096
00D09D  2  FF 01                .WORD   511             ;max directory number
00D09F  2  08 D2                .WORD   almpb           ;address of map for a
00D0A1  2  80                   .BYTE   128             ;no checksums
00D0A2  2  08 D9                .WORD   ckmp            ;checksum map
00D0A4  2               dcbc:
00D0A4  2  FF 07                .WORD   2047            ;max block number
00D0A6  2  40 00                .WORD   64              ;sectors per track
00D0A8  2  10 00                .WORD   16              ;number system tracks
00D0AA  2  02                   .BYTE   2               ;block size = 4096
00D0AB  2  FF 01                .WORD   511             ;max directory number
00D0AD  2  08 D3                .WORD   almpc           ;address of map for a
00D0AF  2  80                   .BYTE   128             ;no checksums
00D0B0  2  08 D9                .WORD   ckmp            ;checksum map
00D0B2  2               dcbd:
00D0B2  2  FF 07                .WORD   2047            ;max block number
00D0B4  2  40 00                .WORD   64              ;sectors per track
00D0B6  2  10 00                .WORD   16              ;number system tracks
00D0B8  2  02                   .BYTE   2               ;block size = 4096
00D0B9  2  FF 01                .WORD   511             ;max directory number
00D0BB  2  08 D4                .WORD   almpd           ;address of map for a
00D0BD  2  80                   .BYTE   128             ;no checksums
00D0BE  2  08 D9                .WORD   ckmp            ;checksum map
00D0C0  2               dcbe:
00D0C0  2  FF 07                .WORD   2047            ;max block number
00D0C2  2  40 00                .WORD   64              ;sectors per track
00D0C4  2  10 00                .WORD   16              ;number system tracks
00D0C6  2  02                   .BYTE   2               ;block size = 4096
00D0C7  2  FF 01                .WORD   511             ;max directory number
00D0C9  2  08 D5                .WORD   almpe           ;address of map for a
00D0CB  2  80                   .BYTE   128             ;no checksums
00D0CC  2  08 D9                .WORD   ckmp            ;checksum map
00D0CE  2               dcbf:
00D0CE  2  FF 07                .WORD   2047            ;max block number
00D0D0  2  40 00                .WORD   64              ;sectors per track
00D0D2  2  10 00                .WORD   16              ;number system tracks
00D0D4  2  02                   .BYTE   2               ;block size = 4096
00D0D5  2  FF 01                .WORD   511             ;max directory number
00D0D7  2  08 D6                .WORD   almpf           ;address of map for a
00D0D9  2  80                   .BYTE   128             ;no checksums
00D0DA  2  08 D9                .WORD   ckmp            ;checksum map
00D0DC  2               dcbg:
00D0DC  2  FF 07                .WORD   2047            ;max block number
00D0DE  2  40 00                .WORD   64              ;sectors per track
00D0E0  2  10 00                .WORD   16              ;number system tracks
00D0E2  2  02                   .BYTE   2               ;block size = 4096
00D0E3  2  FF 01                .WORD   511             ;max directory number
00D0E5  2  08 D7                .WORD   almpg           ;address of map for a
00D0E7  2  80                   .BYTE   128             ;no checksums
00D0E8  2  08 D9                .WORD   ckmp            ;checksum map
00D0EA  2               dcbh:
00D0EA  2  FF 07                .WORD   2047            ;max block number
00D0EC  2  40 00                .WORD   64              ;sectors per track
00D0EE  2  10 00                .WORD   16              ;number system tracks
00D0F0  2  02                   .BYTE   2               ;block size = 4096
00D0F1  2  FF 01                .WORD   511             ;max directory number
00D0F3  2  08 D8                .WORD   almph           ;address of map for a
00D0F5  2  80                   .BYTE   128             ;no checksums
00D0F6  2  08 D9                .WORD   ckmp            ;checksum map
00D0F8  2               
00D0F8  2               ; See Platform Documentation for Drive Types.
00D0F8  2               dftdskcfg:
00D0F8  2  10 00                .BYTE   $10, $00        ; disk A: unit, slice (invalid for floppy disks) SD
00D0FA  2  30 00                .BYTE   $30, $00        ; disk B: unit, slice (invalid for floppy disks) PPIDE
00D0FC  2  90 00                .BYTE   $90, $00        ; disk C: unit, slice (invalid for floppy disks)
00D0FE  2  90 00                .BYTE   $90, $00        ; disk D: unit, slice (invalid for floppy disks)
00D100  2  90 00                .BYTE   $90, $00        ; disk E: unit, slice (invalid for floppy disks)
00D102  2  90 00                .BYTE   $90, $00        ; disk F: unit, slice (invalid for floppy disks)
00D104  2  90 00                .BYTE   $90, $00        ; disk G: unit, slice (invalid for floppy disks)
00D106  2  90 00                .BYTE   $90, $00        ; disk H: unit, slice (invalid for floppy disks)
00D108  2               
00D108  2               
00D108  2               
00D108  2                       .ENDIF
00D108  2               
00D108  2               ;__________________________________________________________________________________________________________________________________
00D108  2                       .IFDEF  NHYODYNE
00D108  2               dcba:
00D108  2                       .WORD   127             ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   0               ;number system tracks
00D108  2                       .BYTE   1               ;block size = 2048
00D108  2                       .WORD   255             ;max directory number
00D108  2                       .WORD   almpa           ;address of map for a
00D108  2                       .BYTE   00              ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbb:
00D108  2                       .WORD   191             ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   0               ;number system tracks
00D108  2                       .BYTE   1               ;block size = 2048
00D108  2                       .WORD   155             ;max directory number
00D108  2                       .WORD   almpb           ;address of map for b
00D108  2                       .BYTE   00              ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbc:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpc           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbd:
00D108  2                       .WORD   350             ;max block number
00D108  2                       .WORD   36              ;sectors per track
00D108  2                       .WORD   4               ;number system tracks
00D108  2                       .BYTE   1               ;block size = 2048
00D108  2                       .WORD   127             ;max directory number
00D108  2                       .WORD   almpd           ;address of map for d
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbe:
00D108  2                       .WORD   350             ;max block number
00D108  2                       .WORD   36              ;sectors per track
00D108  2                       .WORD   4               ;number system tracks
00D108  2                       .BYTE   1               ;block size = 2048
00D108  2                       .WORD   127             ;max directory number
00D108  2                       .WORD   almpe           ;address of map for e
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbf:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpf           ;address of map for f
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbg:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpg           ;address of map for g
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbh:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almph           ;address of map for h
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               
00D108  2               dftdskcfg:
00D108  2                       .BYTE   $00, $00        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00D108  2                       .BYTE   $01, $00        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00D108  2                       .BYTE   $30, $06        ; disk C: unit, slice IDE
00D108  2                       .BYTE   $20, $00        ; disk D: unit, slice FLOPPY A
00D108  2                       .BYTE   $21, $00        ; disk E: unit, slice FLOPPY B
00D108  2                       .BYTE   $30, $03        ; disk F: unit, slice IDE
00D108  2                       .BYTE   $30, $04        ; disk G: unit, slice IDE
00D108  2                       .BYTE   $30, $00        ; disk H: unit, slice IDE
00D108  2               
00D108  2                       .ENDIF
00D108  2               
00D108  2               ;__________________________________________________________________________________________________________________________________
00D108  2                       .IFDEF  DUODYNE
00D108  2               dcba:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpc           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbb:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpc           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbc:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpc           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbd:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpd           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbe:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpe           ;address of map for C
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbf:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpf           ;address of map for f
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbg:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almpg           ;address of map for g
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               dcbh:
00D108  2                       .WORD   2047            ;max block number
00D108  2                       .WORD   64              ;sectors per track
00D108  2                       .WORD   16              ;number system tracks
00D108  2                       .BYTE   2               ;block size = 4096
00D108  2                       .WORD   511             ;max directory number
00D108  2                       .WORD   almph           ;address of map for h
00D108  2                       .BYTE   0               ;do checksums
00D108  2                       .WORD   ckmp            ;checksum map
00D108  2               
00D108  2               dftdskcfg:
00D108  2                       .BYTE   $30, $06        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00D108  2                       .BYTE   $30, $01        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00D108  2                       .BYTE   $30, $06        ; disk C: unit, slice
00D108  2                       .BYTE   $30, $00        ; disk D: unit, slice
00D108  2                       .BYTE   $30, $01        ; disk E: unit, slice
00D108  2                       .BYTE   $30, $02        ; disk F: unit, slice
00D108  2                       .BYTE   $30, $03        ; disk G: unit, slice
00D108  2                       .BYTE   $30, $04        ; disk H: unit, slice
00D108  2                       .ENDIF
00D108  2               
00D108  2               
00D108  2               ;allocation maps
00D108  2               almpa:
00D108  2  xx xx xx xx          .RES    256
00D10C  2  xx xx xx xx  
00D110  2  xx xx xx xx  
00D208  2               almpb:
00D208  2  xx xx xx xx          .RES    256
00D20C  2  xx xx xx xx  
00D210  2  xx xx xx xx  
00D308  2               almpc:
00D308  2  xx xx xx xx          .RES    256
00D30C  2  xx xx xx xx  
00D310  2  xx xx xx xx  
00D408  2               almpd:
00D408  2  xx xx xx xx          .RES    256
00D40C  2  xx xx xx xx  
00D410  2  xx xx xx xx  
00D508  2               almpe:
00D508  2  xx xx xx xx          .RES    256
00D50C  2  xx xx xx xx  
00D510  2  xx xx xx xx  
00D608  2               almpf:
00D608  2  xx xx xx xx          .RES    256
00D60C  2  xx xx xx xx  
00D610  2  xx xx xx xx  
00D708  2               almpg:
00D708  2  xx xx xx xx          .RES    256
00D70C  2  xx xx xx xx  
00D710  2  xx xx xx xx  
00D808  2               almph:
00D808  2  xx xx xx xx          .RES    256
00D80C  2  xx xx xx xx  
00D810  2  xx xx xx xx  
00D908  2               
00D908  2               ;checksum maps
00D908  2               ;drive a
00D908  2               ckmp:
00D908  2  xx xx xx xx          .RES    128
00D90C  2  xx xx xx xx  
00D910  2  xx xx xx xx  
00D988  2               
00D988  1               
00D988  1                       .END
