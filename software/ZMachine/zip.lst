ca65 V2.18 - Ubuntu 2.19-1
Main file   : zip.asm
Current file: zip.asm

000000r 1               ; TITLE   "ZIP/6502-C INFOCOM, INC. --- EQUATES"
000000r 1               ; --------------------------
000000r 1               ; ZIP/6502 2.0 VERSION F
000000r 1               ; Z-CODE INTERPRETER PROGRAM
000000r 1               ; FOR DUODYNE DOS/65 65816
000000r 1               ; --------------------------
000000r 1               ; INFOCOM, INC.
000000r 1               ; 55 WHEELER STREET
000000r 1               ; CAMBRIDGE, MA 02136
000000r 1               ; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
000000r 1               
000000r 1               MSTART          = $0800         ; START OF FREE PROGRAM RAM
000000r 1               ZEROPG          = $60           ; START OF FREE Z-PAGE RAM
000000r 1               ZPGTOP          = $DF           ; END OF FREE Z-PAGE RAM
000000r 1               
000000r 1               ;DEBUG           = 0             ; ASSEMBLY FLAG FOR DEBUGGER
000000r 1               
000000r 1               ; -----------
000000r 1               ; ERROR CODES
000000r 1               ; -----------
000000r 1               ; 00 -- INSUFFICIENT RAM
000000r 1               ; 01 -- ILLEGAL X-OP
000000r 1               ; 02 -- ILLEGAL 0-OP
000000r 1               ; 03 -- ILLEGAL 1-OP
000000r 1               ; 04 -- ILLEGAL 2-OP
000000r 1               ; 05 -- Z-STACK UNDERFLOW
000000r 1               ; 06 -- Z-STACK OVERFLOW
000000r 1               ; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
000000r 1               ; 08 -- DIVISION BY ZERO
000000r 1               ; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
000000r 1               ; 10 -- ILLEGAL PROPERTY ID (PUTP)
000000r 1               ; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
000000r 1               ; 12 -- DISK ADDRESS OUT OF RANGE
000000r 1               ; 13 -- PARSER OVERFLOW
000000r 1               ; 14 -- DRIVE ACCESS
000000r 1               ; 15 -- Z-STACK DESTROYED
000000r 1               
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 00 0E             JMP     COLD
000803  1                       .INCLUDE "eq.asm"
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- MEMORY ORGANIZATION ---"
000803  2               
000803  2               TRUE	=	$FF
000803  2               FALSE	=	0
000803  2               LO	=	0
000803  2               HI	=	1
000803  2               
000803  2               IOBUFF	=	MSTART		; 256-BYTE DISK BUFFER
000803  2               ZSTAKL	=	MSTART+$100	; Z-STACK LSBS
000803  2               ZSTAKH	=	MSTART+$200	; Z-STACK MSBS
000803  2               PTABL	=	MSTART+$300	; PAGING TABLE LSBS ($A0 BYTES)
000803  2               PTABH	=	MSTART+$3A0	; PAGING TABLE MSBS ($A0 BYTES)
000803  2               LRUMAP	=	MSTART+$450	; TIMESTAMP MAP ($A0 BYTES) (BM 11/24/84)
000803  2               LOCALS  =     MSTART+$500     ; LOCAL VARIABLE STORAGE (32 BYTES)
000803  2               BUFSAV  =     MSTART+$520     ; I/O AUX BUFFER (80 BYTES)
000803  2               
000803  2               ZIP	=	MSTART+$600	; START OF EXECUTABLE CODE
000803  2               ZBEGIN	=	ZIP+$1D00	; START OF Z-CODE
000803  2               
000803  2               	; ---------------------
000803  2               	; Z-CODE HEADER OFFSETS
000803  2               	; ---------------------
000803  2               
000803  2               ZVERS	=	0		; VERSION BYTE
000803  2               ZMODE	=	1		; MODE SELECT BYTE
000803  2               ZID	=	2		; GAME ID WORD
000803  2               ZENDLD	=	4		; START OF NON-PRELOADED Z-CODE
000803  2               ZGO	=	6		; EXECUTION ADDRESS
000803  2               ZVOCAB	=	8		; START OF VOCABULARY TABLE
000803  2               ZOBJEC	=	10		; START OF OBJECT TABLE
000803  2               ZGLOBA	=	12		; START OF GLOBAL VARIABLE TABLE
000803  2               ZPURBT	=	14		; START OF "PURE" Z-CODE
000803  2               ZSCRIP	=	16		; FLAG WORD
000803  2               ZSERIA	=	18		; 3-WORD ASCII SERIAL NUMBER
000803  2               ZFWORD	=	24		; START OF FWORDS TABLE
000803  2               ZLENTH	=	26		; LENGTH OF Z-PROGRAM IN WORDS
000803  2               ZCHKSM	=	28		; Z-CODE CHECKSUM WORD
000803  2               
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- ZIP Z-PAGE VARIABLES ---"
000803  2               
000803  2               OPCODE	=	ZEROPG		; (BYTE) CURRENT OPCODE
000803  2               NARGS	=	OPCODE+1	; (BYTE) # ARGUMENTS
000803  2               ARG1	=	OPCODE+2	; (WORD) ARGUMENT #1
000803  2               ARG2	=	OPCODE+4	; (WORD) ARGUMENT #2
000803  2               ARG3	=	OPCODE+6	; (WORD) ARGUMENT #3
000803  2               ARG4	=	OPCODE+8	; (WORD) ARGUMENT #4
000803  2               ABYTE	=	OPCODE+10	; (BYTE) X-OP ARGUMENT BYTE
000803  2               ADEX	=	OPCODE+11	; (BYTE) X-OP ARGUMENT INDEX
000803  2               
000803  2               VALUE	=	OPCODE+12	; (WORD) VALUE RETURN REGISTER
000803  2               I	=	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
000803  2               J	=	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
000803  2               K	=	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
000803  2               
000803  2               ZSP	=	VALUE+8		; (BYTE) Z-STACK POINTER
000803  2               OLDZSP	=	ZSP+1		; (BYTE) OLD Z-STACK POINTER
000803  2               
000803  2               ZPC	=	ZSP+2		; (3 BYTES) ZIP PROGRAM COUNTER
000803  2               ZPCL	=	ZPC		; (BYTE) LOW 8 BITS OF [ZPC]
000803  2               ZPCM	=	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
000803  2               ZPCH	=	ZPC+2		; (BYTE) HIGH BIT OF [ZPC]
000803  2               ZPCFLG	=	ZPC+3		; (BYTE) FLAG: "TRUE" IF [ZPCPNT] VALID
000803  2               ZPCPNT	=	ZPC+4		; (WORD) ABS POINTER TO CURRENT Z-PAGE
000803  2               
000803  2               MPC	=	ZPC+6		; (3 BYTES) MEMORY PROGRAM COUNTER
000803  2               MPCL	=	MPC		; (BYTE) LOW 8 BITS OF [MPC]
000803  2               MPCM	=	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
000803  2               MPCH	=	MPC+2		; (BYTE) HIGH BIT OF [MPC]
000803  2               MPCFLG	=	MPC+3		; (BYTE) FLAG: "TRUE" IF [MPCPNT] VALID
000803  2               MPCPNT	=	MPC+4		; (WORD) ABS POINTER TO CURRENT M-PAGE
000803  2               
000803  2               LRU	=	MPC+6		; (BYTE) PAGING INDEX
000803  2               ZCODE	=	LRU+1		; (BYTE) 1ST ABSOLUTE PAGE OF PRELOAD
000803  2               ZPURE	=	LRU+2		; (BYTE) 1ST VIRTUAL PAGE OF "PURE" Z-CODE
000803  2               PAGE0	=	LRU+3		; (BYTE) 1ST PAGE OF ACTUAL SWAPPING SPACE
000803  2               PMAX	=	LRU+4		; (BYTE) MAXIMUM # OF SWAPPING PAGES
000803  2               ZPAGE	=	LRU+5		; (BYTE) CURRENT SWAPPING PAGE
000803  2               TARGET	=	LRU+6		; (WORD) TARGET PAGE FOR SWAPPING
000803  2               STAMP	=	LRU+8		; (BYTE) CURRENT TIMESTAMP (BM 11/24/84)
000803  2               SWAP	=	LRU+9		; (BYTE) EARLIEST PAGE (BM 11/24/84)
000803  2               
000803  2               GLOBAL	=	LRU+10		; (WORD) GLOBAL VARIABLE POINTER
000803  2               VOCAB	=	GLOBAL+2	; (WORD) VOCAB TABLE POINTER
000803  2               FWORDS	=	GLOBAL+4	; (WORD) F-WORDS TABLE POINTER
000803  2               OBJTAB	=	GLOBAL+6	; (WORD) OBJECT TABLE POINTER
000803  2               
000803  2               	; Z-STRING MANIPULATION VARIABLES
000803  2               
000803  2               IN	=	GLOBAL+8	; (6 BYTES) INPUT BUFFER
000803  2               OUT	=	IN+6		; (6 BYTES) OUTPUT BUFFER
000803  2               
000803  2               SOURCE	=	OUT+6		; (BYTE) SOURCE BUFFER POINTER
000803  2               RESULT	=	SOURCE+1	; (BYTE) RESULT TABLE POINTER
000803  2               LINLEN	=	SOURCE+2	; (BYTE) LENGTH OF CURRENT LINE
000803  2               WRDLEN	=	SOURCE+3	; (BYTE) LENGTH OF CURRENT WORD
000803  2               ENTRY	=	SOURCE+4	; (WORD) ADDR OF CURRENT RESULT ENTRY
000803  2               NENTS	=	SOURCE+6	; (WORD) # ENTRIES IN VOCAB TABLE
000803  2               ESIZE	=	SOURCE+8	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
000803  2               PSET	=	SOURCE+9	; (BYTE) PERMANENT CHARSET
000803  2               TSET	=	SOURCE+10	; (BYTE) TEMPORARY CHARSET
000803  2               ZCHAR	=	SOURCE+11	; (BYTE) CURRENT Z-CHAR
000803  2               OFFSET	=	SOURCE+12	; (BYTE) F-WORD TABLE OFFSET
000803  2               ZFLAG	=	SOURCE+13	; (BYTE) Z-WORD ACCESS FLAG
000803  2               ZWORD	=	SOURCE+14	; (WORD) CURRENT Z-WORD
000803  2               CONCNT	=	SOURCE+16	; (BYTE) Z-STRING SOURCE COUNTER
000803  2               CONIN	=	SOURCE+17	; (BYTE) CONVERSION SOURCE INDEX
000803  2               CONOUT	=	SOURCE+18	; (BYTE) CONVERSION DEST INDEX
000803  2               
000803  2               QUOT	=	SOURCE+19	; (WORD) QUOTIENT FOR DIVISION
000803  2               REMAIN	=	QUOT+2		; (WORD) REMAINDER FOR DIVISION
000803  2               MTEMP	=	QUOT+4		; (WORD) MATH TEMPORARY REGISTER
000803  2               QSIGN	=	QUOT+6		; (BYTE) SIGN OF QUOTIENT
000803  2               RSIGN	=	QUOT+7		; (BYTE) SIGN OF REMAINDER
000803  2               DIGITS	=	QUOT+8		; (BYTE) DIGIT COUNT FOR "PRINTN"
000803  2               
000803  2               TIMEFL	=	QUOT+9		; (BYTE) "TRUE" IF TIME MODE
000803  2               LENGTH	=	TIMEFL+1	; (BYTE) LENGTH OF LINE IN [LINBUF]
000803  2               OLDLEN	=	TIMEFL+2	; (BYTE) OLD LINE LENGTH
000803  2               SCRIPT	=	TIMEFL+3	; (BYTE) SCRIPT ENABLE FLAG
000803  2               OLDX	=	TIMEFL+4	; (BYTE) OLD CURSOR X
000803  2               OLDY	=	TIMEFL+5	; (BYTE) OLD CURSOR Y
000803  2               LINCNT	=	TIMEFL+6	; (BYTE) LINE COUNTER
000803  2               LMAX	=	TIMEFL+7	; (BYTE) MAX # LINES/SCREEN
000803  2               
000803  2               IOCHAR	=	TIMEFL+8	; (BYTE) CHARACTER BUFFER
000803  2               SLINE	=	IOCHAR+1	; (BYTE) BORDERLINE FOR SPLIT
000803  2               SPSTAT	=	IOCHAR+2	; (BYTE) SPLIT SCREEN STATUS FLAG
000803  2               LFROM	=	IOCHAR+3	; (WORD) "FROM" LINE ADDRESS
000803  2               LTO	=	IOCHAR+5	; (WORD) "TO" LINE ADDRESS
000803  2               PSTAT	=	IOCHAR+7	; (BYTE) PRINTER STATUS FLAG
000803  2               PRLEN	=	IOCHAR+8	; (BYTE) SCRIPT LINE LENGTH
000803  2               
000803  2               DBLOCK	=	IOCHAR+9	; (WORD) Z-BLOCK TO READ
000803  2               DBUFF	=	DBLOCK+2	; (WORD) RAM PAGE TO ACCESS (LSB = 0)
000803  2               ;TRACK	=	DBLOCK+4	; (BYTE) TARGET TRACK
000803  2               ;SECTOR	=	DBLOCK+5	; (BYTE) TARGET SECTOR
000803  2               GPOSIT	=	DBLOCK+6	; (BYTE) DEFAULT SAVE POSITION
000803  2               GDRIVE	=	DBLOCK+7	; (BYTE) DEFAULT SAVE DRIVE
000803  2               TPOSIT	=	DBLOCK+8	; (BYTE) TEMP SAVE POSITION
000803  2               TDRIVE	=	DBLOCK+9	; (BYTE) TEMP SAVE DRIVE
000803  2               
000803  2               BLINK	=	DBLOCK+11	; (WORD) CURSOR BLINK TIMER
000803  2               
000803  2               ;DVD	=	DBLOCK+13	; (WORD) DISK DIVIDEND
000803  2               ;DSOR	=	DBLOCK+15	; (WORD) DISK DIVISOR
000803  2               DTEMP	=	DBLOCK+17	; (WORD) DISK TEMP VARIABLE
000803  2               
000803  1                       .SEGMENT "ZIP"
000803  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT INIT"
000803  1                       .INCLUDE "hardeq.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- HARDWARE EQUATES: DOS/65 ---"
000803  2               
000803  2               ; ---------
000803  2               ; CONSTANTS
000803  2               ; ---------
000803  2               
000803  2               XSIZE           = 79            ; X-SIZE OF SCREEN
000803  2               YSIZE           = 24            ; Y-SIZE OF SCREEN
000803  2               
000803  2               EOL             = $0D           ; EOL CHAR
000803  2               SPACE           = $20           ; SPACE CHAR
000803  2               BACKSP          = $08           ; BACKSPACE
000803  2               
000803  2               DFLFCB          = $107          ;DEFAULT FCB
000803  2               PEM             = $103          ;PEM ENTRY
000803  2               BOOT            = $100          ;WARM BOOT
000803  2               CCMLNG          = 2048          ;CCM LENGTH
000803  2               
000803  2               ; ---------
000803  2               ; ZERO-PAGE
000803  2               ; ---------
000803  2               
000803  2               
000803  2               ; -----------
000803  2               ; PAGES 2 & 3
000803  2               ; -----------
000803  2               
000803  2               LBUFF           = $0740         ; 89-BYTE LINE BUFFER
000803  2               
000803  1                       .INCLUDE "cold.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- MACHINE COLDSTART: DOS/65 ---"
000803  2               
000803  2               
000803  2               ; ---------
000803  2               ; COLDSTART
000803  2               ; ---------
000803  2                       .ORG    ZIP
000E00  2               
000E00  2               
000E00  2               COLD:
000E00  2  A9 00                LDA     #0
000E02  2  8D 91 21             STA     SFLAG           ; NO PREVIOUS SCRIPTING (BM 5/14/85)
000E05  2  4C 5B 0E             JMP     WARM1
000E08  2               
000E08  2               ; ---------------
000E08  2               ; WARMSTART ENTRY
000E08  2               ; ---------------
000E08  2               
000E08  2               SLOAD:
000E08  2  49 6E 66 6F          .BYTE   "Infocom ZMachine Interpreter for DOS/65"
000E0C  2  63 6F 6D 20  
000E10  2  5A 4D 61 63  
000E2F  2  0D                   .BYTE   EOL
000E30  2  0D                   .BYTE   EOL
000E31  2  20 20 20 20          .BYTE   "                 The story is loading ..."
000E35  2  20 20 20 20  
000E39  2  20 20 20 20  
000E5A  2  0D                   .BYTE   EOL
000E5B  2               SLOADL          = *-SLOAD
000E5B  2               
000E5B  2               WARM1:
000E5B  2  D8                   CLD
000E5C  2                       .IFDEF  DUODYNE
000E5C  2                       .ELSE
000E5C  2  A2 FF                LDX     #$FF            ; (Dont do this for Duodyne . . . . .)
000E5E  2  9A                   TXS                     ; RESET MACHINE STACK
000E5F  2                       .ENDIF
000E5F  2               
000E5F  2               
000E5F  2               
000E5F  2  20 13 22             JSR     CLS             ; CLEAR SCREEN, ETC.
000E62  2               
000E62  2  A0 08                LDY     #8              ; POSITION "STORY LOADING" MESSAGE
000E64  2  A2 0B                LDX     #11             ; AT (8,11)
000E66  2  18                   CLC
000E67  2  20 CD 21             JSR     PLOT
000E6A  2               
000E6A  2  A2 08                LDX     #<SLOAD
000E6C  2  A9 0E                LDA     #>SLOAD
000E6E  2  A0 53                LDY     #SLOADL
000E70  2  20 7C 21             JSR     DLINE           ; "THE STORY IS LOADING ..."
000E73  2  20 71 26             JSR     DOPEN           ; AND OPEN THE STORY
000E76  2               
000E76  2               
000E76  2               ; FALL THROUGH TO ZIP WARMSTART AT "WARM2"
000E76  2               
000E76  1               
000E76  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- INIT & MAINLINE"
000E76  1                       .INCLUDE "warm.asm"
000E76  2               ;        PAGE
000E76  2               ;        SBTTL   "--- WARMSTART ROUTINE ---"
000E76  2               
000E76  2               ; -------------
000E76  2               ; ZIP WARMSTART
000E76  2               ; -------------
000E76  2               
000E76  2               WARM2:
000E76  2               
000E76  2               ; PROBABLY NOT THE BEST WAY TO DO THIS
000E76  2               ; I NEED TO USE THE CLOCK TO SEED THE RNG
000E76  2  A5 44                LDA     $44
000E78  2  8D C5 1E             STA     state+0
000E7B  2  A5 46                LDA     $46
000E7D  2  8D CA 1E             STA     state1+0
000E80  2  A5 3B                LDA     $3B
000E82  2  8D C6 1E             STA     state+1
000E85  2  A5 3D                LDA     $3D
000E87  2  8D CB 1E             STA     state1+1
000E8A  2  AD 35 06             LDA     $0635
000E8D  2  8D C7 1E             STA     state+2
000E90  2  8D CC 1E             STA     state1+2
000E93  2  08                   PHP
000E94  2  68                   PLA
000E95  2  8D C8 1E             STA     state+3
000E98  2  BA                   TSX
000E99  2  8E CD 1E             STX     state1+3
000E9C  2  AD 00 04             LDA     $0400
000E9F  2  8D C9 1E             STA     state+4
000EA2  2  AD 01 04             LDA     $0401
000EA5  2  8D CE 1E             STA     state1+4
000EA8  2               
000EA8  2               
000EA8  2  A9 00                LDA     #0              ; CLEAR ALL Z-PAGE VARIABLES
000EAA  2  A2 60                LDX     #ZEROPG
000EAC  2               ST0:
000EAC  2  95 00                STA     0,X
000EAE  2  E8                   INX
000EAF  2  E0 DF                CPX     #ZPGTOP
000EB1  2  90 F9                BCC     ST0
000EB3  2               
000EB3  2               ; INIT THE PAGING TABLES
000EB3  2               
000EB3  2  AA                   TAX                     ; = 0
000EB4  2  A9 FF                LDA     #$FF
000EB6  2               ST1A:
000EB6  2  9D 00 0B             STA     PTABL,X
000EB9  2  9D A0 0B             STA     PTABH,X
000EBC  2  E8                   INX
000EBD  2  E0 A0                CPX     #$A0
000EBF  2  90 F5                BCC     ST1A
000EC1  2               
000EC1  2               ; INIT THE TIMESTAMP MAP (BM 11/24/84)\
000EC1  2               
000EC1  2  A9 00                LDA     #0
000EC3  2  AA                   TAX
000EC4  2               ST1B:
000EC4  2  9D 50 0C             STA     LRUMAP,X
000EC7  2  E8                   INX
000EC8  2  E0 A0                CPX     #$A0
000ECA  2  90 F8                BCC     ST1B
000ECC  2               
000ECC  2  E6 74                INC     ZSP             ; INIT Z-STACK POINTERS
000ECE  2  E6 75                INC     OLDZSP          ; TO "1"
000ED0  2  E6 8A                INC     STAMP           ; INIT TIMESTAMP (BM 11/24/84)
000ED2  2               
000ED2  2               ; GRAB THE FIRST BLOCK OF PRELOAD
000ED2  2               
000ED2  2  A9 2B                LDA     #>ZBEGIN        ; MSB OF PRELOAD START ADDRESS
000ED4  2  85 83                STA     ZCODE           ; FREEZE IT HERE
000ED6  2  85 D0                STA     DBUFF+HI        ; LSB IS ALWAYS ZERO
000ED8  2  20 5A 22             JSR     GETDSK          ; [DBLOCK] SET TO Z-BLOCK 0
000EDB  2               
000EDB  2               ; EXTRACT GAME DATA FROM Z-CODE HEADER
000EDB  2               
000EDB  2  AE 04 2B             LDX     ZBEGIN+ZENDLD   ; MSB OF ENDLOAD POINTER
000EDE  2  E8                   INX                     ; ADD 1 TO GET
000EDF  2  86 84                STX     ZPURE           ; 1ST "PURE" PAGE OF Z-CODE
000EE1  2               
000EE1  2  8A                   TXA                     ; ADD START PAGE OF PRELOAD
000EE2  2  18                   CLC                     ; TO CALC ABSOLUTE START ADDRESS
000EE3  2  65 83                ADC     ZCODE           ; OF PAGING SPACE
000EE5  2  85 85                STA     PAGE0
000EE7  2               
000EE7  2  20 58 1E             JSR     MEMTOP          ; RETURNS TOP RAM PAGE IN [A]
000EEA  2  38                   SEC
000EEB  2  E5 85                SBC     PAGE0           ; SUBTRACT ADDRESS OF PAGING SPACE
000EED  2  F0 02                BEQ     NORAM
000EEF  2  B0 05                BCS     SETNP           ; ERROR IF NOT ENOUGH RAM
000EF1  2               
000EF1  2               ; *** ERROR #0 -- INSUFFICIENT RAM ***
000EF1  2               
000EF1  2               NORAM:
000EF1  2  A9 00                LDA     #0
000EF3  2  4C EE 1D             JMP     ZERROR
000EF6  2               
000EF6  2               SETNP:
000EF6  2  C9 A0                CMP     #$A0            ; DON'T ALLOW MORE THAN $A0 PAGES
000EF8  2  90 02                BCC     SETA0
000EFA  2  A9 A0                LDA     #$A0
000EFC  2               SETA0:
000EFC  2  85 86                STA     PMAX            ; SET # SWAPPING PAGES
000EFE  2               
000EFE  2  AD 01 2B             LDA     ZBEGIN+ZMODE
000F01  2  09 20                ORA     #%00100000      ; ENABLE SPLIT-SCREEN
000F03  2  8D 01 2B             STA     ZBEGIN+ZMODE
000F06  2               
000F06  2  29 02                AND     #%00000010      ; ISOLATE STATUS-FORMAT BIT
000F08  2  85 BC                STA     TIMEFL          ; 0=SCORE, NZ=TIME
000F0A  2               
000F0A  2  AD 0C 2B             LDA     ZBEGIN+ZGLOBA   ; GET MSB OF GLOBAL TABLE ADDR
000F0D  2  18                   CLC                     ; CONVERT TO
000F0E  2  65 83                ADC     ZCODE           ; ABSOLUTE ADDRESS
000F10  2  85 8D                STA     GLOBAL+HI
000F12  2  AD 0D 2B             LDA     ZBEGIN+ZGLOBA+1 ; LSB NEEDN'T CHANGE
000F15  2  85 8C                STA     GLOBAL+LO
000F17  2               
000F17  2  AD 18 2B             LDA     ZBEGIN+ZFWORD   ; DO SAME FOR FWORDS TABLE
000F1A  2  18                   CLC
000F1B  2  65 83                ADC     ZCODE
000F1D  2  85 91                STA     FWORDS+HI
000F1F  2  AD 19 2B             LDA     ZBEGIN+ZFWORD+1 ; NO CHANGE FOR LSB
000F22  2  85 90                STA     FWORDS+LO
000F24  2               
000F24  2  AD 08 2B             LDA     ZBEGIN+ZVOCAB   ; NOW DO VOCABULARY TABLE
000F27  2  18                   CLC
000F28  2  65 83                ADC     ZCODE
000F2A  2  85 8F                STA     VOCAB+HI
000F2C  2  AD 09 2B             LDA     ZBEGIN+ZVOCAB+1 ; LSB SAME
000F2F  2  85 8E                STA     VOCAB+LO
000F31  2               
000F31  2  AD 0A 2B             LDA     ZBEGIN+ZOBJEC   ; NOT TO MENTION
000F34  2  18                   CLC                     ; THE OBJECT TABLE
000F35  2  65 83                ADC     ZCODE
000F37  2  85 93                STA     OBJTAB+HI
000F39  2  AD 0B 2B             LDA     ZBEGIN+ZOBJEC+1 ; LSB SAME
000F3C  2  85 92                STA     OBJTAB+LO
000F3E  2               
000F3E  2               ; FETCH THE REST OF THE PRELOAD
000F3E  2               
000F3E  2               LDPRE:
000F3E  2  A5 CD                LDA     DBLOCK+LO       ; CHECK CURRENT BLOCK #
000F40  2  C5 84                CMP     ZPURE           ; LOADED LAST PRELOAD PAGE YET?
000F42  2  B0 06                BCS     WARMEX          ; YES, TIME TO PLAY!
000F44  2  20 5A 22             JSR     GETDSK          ; ELSE GRAB NEXT Z-BLOCK
000F47  2  4C 3E 0F             JMP     LDPRE
000F4A  2               
000F4A  2               WARMEX:
000F4A  2  AD 06 2B             LDA     ZBEGIN+ZGO      ; GET START ADDRESS OF Z-CODE
000F4D  2  85 77                STA     ZPCM            ; MSB
000F4F  2  AD 07 2B             LDA     ZBEGIN+ZGO+1    ; AND LSB
000F52  2  85 76                STA     ZPCL            ; HIGH BIT ALREADY ZEROED
000F54  2               
000F54  2  E6 BF                INC     SCRIPT          ; ENABLE SCRIPTING
000F56  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; STUFF IN THE
000F59  2  0D 91 21             ORA     SFLAG           ; PREVIOUS SCRIPT MODE
000F5C  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1 ; (BM 5/14/85)
000F5F  2               
000F5F  2  20 13 22             JSR     CLS             ; CLEAR SCREEN, DISABLE SPLIT
000F62  2               
000F62  2               ; ... AND FALL INTO MAIN LOOP
000F62  2               
000F62  1                       .INCLUDE "main.asm"
000F62  2               ;        PAGE
000F62  2               ;        SBTTL   "--- MAIN LOOP ---"
000F62  2               
000F62  2               MLOOP:
000F62  2  A9 00                LDA     #0
000F64  2  85 61                STA     NARGS           ; RESET # ARGUMENTS
000F66  2  20 E6 19             JSR     NEXTPC          ; GET NEXT INSTRUCTION INTO [A]
000F69  2  85 60                STA     OPCODE          ; SAVE IT HERE
000F6B  2               
000F6B  2                       .IFDEF  DEBUG
000F6B  2                       STA     MBYTE
000F6B  2                       LDA     #0              ; BREAKPOINT #0
000F6B  2                       JSR     DOBUG
000F6B  2                       LDA     MBYTE
000F6B  2                       .ENDIF
000F6B  2               
000F6B  2               ; DECODE AN OPCODE
000F6B  2               
000F6B  2  AA                   TAX                     ; SET FLAGS
000F6C  2  30 03                BMI     DC0             ; IF POSITIVE,
000F6E  2  4C 2C 10             JMP     OP2             ; IT'S A 2-OP
000F71  2               
000F71  2               DC0:
000F71  2  C9 B0                CMP     #$B0
000F73  2  B0 03                BCS     DC1
000F75  2  4C FD 0F             JMP     OP1             ; OR MAYBE A 1-OP
000F78  2               
000F78  2               DC1:
000F78  2  C9 C0                CMP     #$C0
000F7A  2  B0 03                BCS     OPEXT
000F7C  2  4C EE 0F             JMP     OP0             ; PERHAPS A 0-OP
000F7F  2               
000F7F  2               ; --------------
000F7F  2               ; HANDLE AN X-OP
000F7F  2               ; --------------
000F7F  2               
000F7F  2               OPEXT:
000F7F  2  20 E6 19             JSR     NEXTPC          ; GRAB THE ARGUMENT ID BYTE
000F82  2  85 6A                STA     ABYTE           ; HOLD IT HERE
000F84  2               
000F84  2  A2 00                LDX     #0
000F86  2  86 6B                STX     ADEX            ; INIT ARGUMENT INDEX
000F88  2  F0 06                BEQ     OPX1            ; JUMP TO TOP OF LOOP
000F8A  2               
000F8A  2               OPX0:
000F8A  2  A5 6A                LDA     ABYTE           ; GET ARG BYTE
000F8C  2  0A                   ASL     A               ; SHIFT NEXT 2 ARG BITS
000F8D  2  0A                   ASL     A               ; INTO BITS 7 & 6
000F8E  2  85 6A                STA     ABYTE           ; HOLD FOR LATER
000F90  2               
000F90  2               OPX1:
000F90  2  29 C0                AND     #%11000000      ; MASK OUT GARBAGE BITS
000F92  2  D0 06                BNE     OPX2
000F94  2  20 78 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
000F97  2  4C AB 0F             JMP     OPXNXT
000F9A  2               
000F9A  2               OPX2:
000F9A  2  C9 40                CMP     #%01000000      ; IS IT A SHORT IMMEDIATE?
000F9C  2  D0 06                BNE     OPX3            ; NO, KEEP GUESSING
000F9E  2  20 74 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
000FA1  2  4C AB 0F             JMP     OPXNXT
000FA4  2               
000FA4  2               OPX3:
000FA4  2  C9 80                CMP     #%10000000      ; LAST TEST
000FA6  2  D0 17                BNE     OPX4            ; 11 = NO MORE ARGUMENTS
000FA8  2  20 8C 10             JSR     GETVAR          ; 10 = VARIABLE
000FAB  2               
000FAB  2               OPXNXT:
000FAB  2  A6 6B                LDX     ADEX            ; RETRIEVE ARGUMENT INDEX
000FAD  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB OF VALUE
000FAF  2  95 62                STA     ARG1+LO,X       ; STORE IN ARGUMENT TABLE
000FB1  2  A5 6D                LDA     VALUE+HI        ; GRAB MSB OF VALUE
000FB3  2  95 63                STA     ARG1+HI,X       ; STORE THAT, TOO
000FB5  2               
000FB5  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNTER
000FB7  2               
000FB7  2  E8                   INX
000FB8  2  E8                   INX
000FB9  2  86 6B                STX     ADEX            ; UPDATE INDEX
000FBB  2  E0 08                CPX     #8              ; DONE 4 ARGUMENTS YET?
000FBD  2  90 CB                BCC     OPX0            ; NO, GET SOME MORE
000FBF  2               
000FBF  2               ; ALL X-OP ARGUMENTS READY
000FBF  2               
000FBF  2               OPX4:
000FBF  2  A5 60                LDA     OPCODE          ; IS THIS
000FC1  2  C9 E0                CMP     #$E0            ; AN EXTENDED 2-OP?
000FC3  2  B0 03                BCS     DOXOP           ; NO, IT'S A REAL X-OP
000FC5  2  4C 55 10             JMP     OP2EX           ; ELSE TREAT IT LIKE A 2-OP
000FC8  2               
000FC8  2               DOXOP:
000FC8  2  A2 36                LDX     #<OPTX          ; GET ADDR OF X-OP TABLE
000FCA  2  A0 12                LDY     #>OPTX          ; INTO [X/Y]
000FCC  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
000FCE  2  C9 0C                CMP     #NOPSX          ; IS IT A LEGAL X-OP?
000FD0  2  90 05                BCC     DODIS           ; YUP; TIME TO DISPATCH IT
000FD2  2               
000FD2  2               ; *** ERROR #1 -- ILLEGAL X-OP ***
000FD2  2               
000FD2  2  A9 01                LDA     #1
000FD4  2  4C EE 1D             JMP     ZERROR
000FD7  2               
000FD7  2               ; ---------------
000FD7  2               ; OPCODE DISPATCH
000FD7  2               ; ---------------
000FD7  2               
000FD7  2               ; ENTRY: MASKED OPCODE INDEX IN [A]
000FD7  2               ;        OP-TABLE ADDR IN X/Y (LSB/MSB)
000FD7  2               
000FD7  2               DODIS:
000FD7  2  86 6E                STX     I+LO            ; SAVE TABLE ADDRESS
000FD9  2  84 6F                STY     I+HI            ; IN A POINTER
000FDB  2               
000FDB  2  0A                   ASL     A               ; WORD-ALIGN THE OP INDEX
000FDC  2  A8                   TAY
000FDD  2  B1 6E                LDA     (I),Y           ; GET LSB OF DISPATCH ADDRESS
000FDF  2  8D E9 0F             STA     GO+LO           ; INSTALL AS JSR OPERAND
000FE2  2  C8                   INY
000FE3  2  B1 6E                LDA     (I),Y           ; SAME WITH MSB
000FE5  2  8D EA 0F             STA     GO+HI
000FE8  2               
000FE8  2  20                   .BYTE   $20             ; 6502 "JSR" OPCODE
000FE9  2               GO:
000FE9  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
000FEB  2               
000FEB  2  4C 62 0F             JMP     MLOOP           ; GO BACK FOR ANOTHER OPCODE
000FEE  2               
000FEE  2               ; -------------
000FEE  2               ; HANDLE A 0-OP
000FEE  2               ; -------------
000FEE  2               
000FEE  2               OP0:
000FEE  2  A2 C8                LDX     #<OPT0          ; GET 0-OP TABLE ADDR
000FF0  2  A0 11                LDY     #>OPT0          ; INTO [X/Y]
000FF2  2  29 0F                AND     #%00001111      ; ISOLATE 0-OP ID BITS
000FF4  2  C9 0E                CMP     #NOPS0          ; OUT OF RANGE?
000FF6  2  90 DF                BCC     DODIS           ; NO, DISPATCH IT
000FF8  2               
000FF8  2               ; *** ERROR #2 -- ILLEGAL 0-OP ***
000FF8  2               
000FF8  2  A9 02                LDA     #2
000FFA  2  4C EE 1D             JMP     ZERROR
000FFD  2               
000FFD  2               ; -------------
000FFD  2               ; HANDLE A 1-OP
000FFD  2               ; -------------
000FFD  2               
000FFD  2               OP1:
000FFD  2  29 30                AND     #%00110000      ; ISOLATE ARGUMENT BITS
000FFF  2  D0 06                BNE     OP1A
001001  2  20 78 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
001004  2  4C 18 10             JMP     OP1EX
001007  2               
001007  2               OP1A:
001007  2  C9 10                CMP     #%00010000      ; TEST AGAIN
001009  2  D0 06                BNE     OP1B
00100B  2  20 74 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
00100E  2  4C 18 10             JMP     OP1EX
001011  2               
001011  2               OP1B:
001011  2  C9 20                CMP     #%00100000      ; ONE MORE TEST
001013  2  D0 12                BNE     BADOP1          ; UNDEFINED STATE!
001015  2  20 8C 10             JSR     GETVAR          ; 10 = VARIABLE
001018  2               
001018  2               OP1EX:
001018  2  20 69 10             JSR     V2A1            ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
00101B  2  A2 E4                LDX     #<OPT1          ; GET ADDR OF 1-OP TABLE
00101D  2  A0 11                LDY     #>OPT1          ; INTO [X/Y]
00101F  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE
001021  2  29 0F                AND     #%00001111      ; ISOLATE OP ID BITS
001023  2  C9 10                CMP     #NOPS1          ; IF WITHIN RANGE,
001025  2  90 B0                BCC     DODIS           ; EXECUTE THE 1-OP
001027  2               
001027  2               ; *** ERROR #3 -- ILLEGAL 1-OP ***
001027  2               
001027  2               BADOP1:
001027  2  A9 03                LDA     #3
001029  2  4C EE 1D             JMP     ZERROR
00102C  2               
00102C  2               ; -------------
00102C  2               ; HANDLE A 2-OP
00102C  2               ; -------------
00102C  2               
00102C  2               OP2:
00102C  2  29 40                AND     #%01000000      ; ISOLATE 1ST ARG BIT
00102E  2  D0 06                BNE     OP2A
001030  2  20 74 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
001033  2  4C 39 10             JMP     OP2B
001036  2               OP2A:
001036  2  20 8C 10             JSR     GETVAR          ; 1 = VARIABLE
001039  2               OP2B:
001039  2  20 69 10             JSR     V2A1            ; [VALUE] TO [ARG1], UPDATE [NARGS]
00103C  2               
00103C  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
00103E  2  29 20                AND     #%00100000      ; ISOLATE 2ND ARG BIT
001040  2  D0 06                BNE     OP2C
001042  2  20 74 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
001045  2  4C 4B 10             JMP     OP2D
001048  2               OP2C:
001048  2  20 8C 10             JSR     GETVAR          ; 1 = VARIABLE
00104B  2               OP2D:
00104B  2  A5 6C                LDA     VALUE+LO        ; MOVE 2ND [VALUE]
00104D  2  85 64                STA     ARG2+LO         ; INTO [ARG2]
00104F  2  A5 6D                LDA     VALUE+HI
001051  2  85 65                STA     ARG2+HI
001053  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNT
001055  2               
001055  2               ; EXECUTE A 2-OP OR EXTENDED 2-OP
001055  2               
001055  2               OP2EX:
001055  2  A2 04                LDX     #<OPT2          ; LSB OF DISPATCH TABLE
001057  2  A0 12                LDY     #>OPT2          ; MSB
001059  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
00105B  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
00105D  2  C9 19                CMP     #NOPS2
00105F  2  B0 03                BCS     BADOP2          ; ERROR IF OUT OF RANGE
001061  2  4C D7 0F             JMP     DODIS           ; ELSE DISPATCH
001064  2               
001064  2               ; *** ERROR #4 -- ILLEGAL 2-OP ****
001064  2               
001064  2               BADOP2:
001064  2  A9 04                LDA     #4
001066  2  4C EE 1D             JMP     ZERROR
001069  2               
001069  2               ; --------------------------------------
001069  2               ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
001069  2               ; --------------------------------------
001069  2               
001069  2               V2A1:
001069  2  A5 6C                LDA     VALUE+LO
00106B  2  85 62                STA     ARG1+LO
00106D  2  A5 6D                LDA     VALUE+HI
00106F  2  85 63                STA     ARG1+HI
001071  2  E6 61                INC     NARGS
001073  2  60                   RTS
001074  2               
001074  1                       .INCLUDE "subs.asm"
001074  2               ;        PAGE
001074  2               ;        SBTTL   "--- OPCODE SUPPORT SUBROUTINES ---"
001074  2               
001074  2               ; -----------------------
001074  2               ; FETCH A SHORT IMMEDIATE
001074  2               ; -----------------------
001074  2               
001074  2               GETSHT:
001074  2  A9 00                LDA     #0              ; MSB IS ZERO
001076  2  F0 03                BEQ     GETV            ; FETCH LSB FROM Z-CODE
001078  2               
001078  2               ; ----------------------
001078  2               ; FETCH A LONG IMMEDIATE
001078  2               ; ----------------------
001078  2               
001078  2               GETLNG:
001078  2  20 E6 19             JSR     NEXTPC          ; GRAB MSB
00107B  2               
00107B  2               GETV:
00107B  2  85 6D                STA     VALUE+HI
00107D  2  20 E6 19             JSR     NEXTPC          ; GRAB LSB
001080  2  85 6C                STA     VALUE+LO
001082  2  60                   RTS
001083  2               
001083  2               ; ----------------
001083  2               ; FETCH A VARIABLE
001083  2               ; ----------------
001083  2               
001083  2               ; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
001083  2               
001083  2               VARGET:
001083  2  AA                   TAX                     ; IF NON-ZERO,
001084  2  D0 0B                BNE     GETVR1          ; ACCESS A VARIABLE
001086  2               
001086  2  20 B2 10             JSR     POPVAL          ; ELSE PULL VAR OFF Z-STACK
001089  2  4C C8 10             JMP     PSHVAL          ; WITHOUT ALTERING STACK
00108C  2               
00108C  2               ; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
00108C  2               
00108C  2               GETVAR:
00108C  2  20 E6 19             JSR     NEXTPC          ; GRAB VAR-TYPE BYTE
00108F  2  F0 21                BEQ     POPVAL          ; VALUE IS ON Z-STACK
001091  2               
001091  2               ; IS VARIABLE LOCAL OR GLOBAL?
001091  2               
001091  2               GETVR1:
001091  2  C9 10                CMP     #$10            ; IF >= 16,
001093  2  B0 10                BCS     GETVRG          ; IT'S GLOBAL
001095  2               
001095  2               ; HANDLE A LOCAL VARIABLE
001095  2               
001095  2               GETVRL:
001095  2  38                   SEC
001096  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
001098  2  0A                   ASL     A               ; WORD INDEX
001099  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
00109A  2               
00109A  2  BD 00 0D             LDA     LOCALS+LO,X     ; GRAB LSB
00109D  2  85 6C                STA     VALUE+LO
00109F  2  BD 01 0D             LDA     LOCALS+HI,X     ; AND MSB
0010A2  2  85 6D                STA     VALUE+HI
0010A4  2  60                   RTS
0010A5  2               
0010A5  2               ; HANDLE A GLOBAL VARIABLE
0010A5  2               
0010A5  2               GETVRG:
0010A5  2  20 16 11             JSR     GVCALC          ; GET ADDRESS OF GLOBAL INTO [I]
0010A8  2  B1 6E                LDA     (I),Y           ; MSB OF GLOBAL ([Y] = 0)
0010AA  2  85 6D                STA     VALUE+HI
0010AC  2  C8                   INY                     ; = 1
0010AD  2  B1 6E                LDA     (I),Y           ; LSB OF GLOBAL
0010AF  2  85 6C                STA     VALUE+LO        ; SAVE IT
0010B1  2  60                   RTS                     ; AND WE'RE DONE
0010B2  2               
0010B2  2               ; ----------------------------------
0010B2  2               ; POP Z-STACK INTO [VALUE] AND [X/A]
0010B2  2               ; ----------------------------------
0010B2  2               
0010B2  2               POPVAL:
0010B2  2  C6 74                DEC     ZSP
0010B4  2  F0 0D                BEQ     UNDER           ; UNDERFLOW IF ZERO!
0010B6  2               
0010B6  2  A4 74                LDY     ZSP             ; READ STACK POINTER
0010B8  2  BE 00 09             LDX     ZSTAKL,Y        ; GRAB LSB OF STACK VALUE
0010BB  2  86 6C                STX     VALUE+LO        ; GIVE TO [VALUE]
0010BD  2  B9 00 0A             LDA     ZSTAKH,Y        ; ALSO GRAB MSB
0010C0  2  85 6D                STA     VALUE+HI        ; A SIMILAR FATE
0010C2  2  60                   RTS
0010C3  2               
0010C3  2               ; *** ERROR #5 -- Z-STACK UNDERFLOW ***
0010C3  2               
0010C3  2               UNDER:
0010C3  2  A9 05                LDA     #5
0010C5  2  4C EE 1D             JMP     ZERROR
0010C8  2               
0010C8  2               ; -----------------------
0010C8  2               ; PUSH [VALUE] TO Z-STACK
0010C8  2               ; -----------------------
0010C8  2               
0010C8  2               PSHVAL:
0010C8  2  A6 6C                LDX     VALUE+LO
0010CA  2  A5 6D                LDA     VALUE+HI
0010CC  2               
0010CC  2               ; ---------------------
0010CC  2               ; PUSH [X/A] TO Z-STACK
0010CC  2               ; ---------------------
0010CC  2               
0010CC  2               PUSHXA:
0010CC  2  A4 74                LDY     ZSP             ; READ STACK POINTER
0010CE  2  99 00 0A             STA     ZSTAKH,Y        ; PUSH MSB IN [A]
0010D1  2  8A                   TXA
0010D2  2  99 00 09             STA     ZSTAKL,Y        ; AND LSB IN [X]
0010D5  2               
0010D5  2  E6 74                INC     ZSP             ; UPDATE Z-STACK POINTER
0010D7  2  F0 01                BEQ     OVER            ; OVERFLOW IF ZEROED!
0010D9  2  60                   RTS
0010DA  2               
0010DA  2               ; *** ERROR #6 -- Z-STACK OVERFLOW ***
0010DA  2               
0010DA  2               OVER:
0010DA  2  A9 06                LDA     #6
0010DC  2  4C EE 1D             JMP     ZERROR
0010DF  2               
0010DF  2               ; --------------
0010DF  2               ; RETURN A VALUE
0010DF  2               ; --------------
0010DF  2               
0010DF  2               ; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
0010DF  2               
0010DF  2               VARPUT:
0010DF  2  AA                   TAX                     ; IF ZERO,
0010E0  2  D0 13                BNE     PUTVR1
0010E2  2               
0010E2  2  C6 74                DEC     ZSP             ; FLUSH TOP WORD OFF STACK
0010E4  2  D0 E2                BNE     PSHVAL          ; AND REPLACE WITH [VALUE]
0010E6  2  F0 DB                BEQ     UNDER           ; ERROR IF [ZSP] BECAME ZERO!
0010E8  2               
0010E8  2               ; RETURN A ZERO
0010E8  2               
0010E8  2               RET0:
0010E8  2  A9 00                LDA     #0
0010EA  2               
0010EA  2               ; RETURN BYTE IN [A]
0010EA  2               
0010EA  2               PUTBYT:
0010EA  2  85 6C                STA     VALUE+LO
0010EC  2  A9 00                LDA     #0
0010EE  2  85 6D                STA     VALUE+HI        ; CLEAR MSB
0010F0  2               
0010F0  2               ; RETURN [VALUE]
0010F0  2               
0010F0  2               PUTVAL:
0010F0  2  20 E6 19             JSR     NEXTPC          ; GET VARIABLE ID BYTE
0010F3  2  F0 D3                BEQ     PSHVAL          ; [VALUE] GOES TO Z-STACK
0010F5  2               
0010F5  2               ; LOCAL OR GLOBAL VARIABLE?
0010F5  2               
0010F5  2               PUTVR1:
0010F5  2  C9 10                CMP     #$10            ; IF >= 16,
0010F7  2  B0 10                BCS     PUTVLG          ; IT'S GLOBAL
0010F9  2               
0010F9  2               ; PUT A LOCAL VARIABLE
0010F9  2               
0010F9  2               PUTVLL:
0010F9  2  38                   SEC
0010FA  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
0010FC  2  0A                   ASL     A               ; WORD INDEX
0010FD  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
0010FE  2               
0010FE  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB
001100  2  9D 00 0D             STA     LOCALS+LO,X     ; SAVE IN LOCAL TABLE
001103  2  A5 6D                LDA     VALUE+HI        ; DO SAME TO
001105  2  9D 01 0D             STA     LOCALS+HI,X     ; MSB
001108  2  60                   RTS
001109  2               
001109  2               ; RETURN A GLOBAL VARIABLE
001109  2               
001109  2               PUTVLG:
001109  2  20 16 11             JSR     GVCALC
00110C  2  A5 6D                LDA     VALUE+HI        ; GET MSB
00110E  2  91 6E                STA     (I),Y           ; STORE AS 1ST BYTE ([Y] = 0)
001110  2  C8                   INY                     ; = 1
001111  2  A5 6C                LDA     VALUE+LO        ; NOW GET LSB
001113  2  91 6E                STA     (I),Y           ; STORE AS 2ND BYTE
001115  2  60                   RTS
001116  2               
001116  2               ; -----------------------
001116  2               ; CALC GLOBAL WORD OFFSET
001116  2               ; -----------------------
001116  2               
001116  2               ; ENTRY: VAR-ID BYTE (16-255) IN [A]
001116  2               ; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [I]
001116  2               ;       [Y] = 0 FOR INDEXING
001116  2               
001116  2               GVCALC:
001116  2  38                   SEC
001117  2  E9 10                SBC     #$10            ; FORM A ZERO-ALIGNED INDEX
001119  2  A0 00                LDY     #0              ; MAKE SURE MSB OF OFFSET AND [Y]
00111B  2  84 6F                STY     I+HI            ; ARE CLEARED
00111D  2               
00111D  2  0A                   ASL     A               ; MULTIPLY OFFSET BY 2
00111E  2  26 6F                ROL     I+HI            ; TO WORD-ALIGN IT
001120  2               
001120  2  18                   CLC                     ; ADD OFFSET TO ADDR OF GLOBAL TABLE
001121  2  65 8C                ADC     GLOBAL+LO       ; TO FORM THE ABSOLUTE
001123  2  85 6E                STA     I+LO            ; ADDRESS OF THE
001125  2  A5 6F                LDA     I+HI            ; DESIRED GLOBAL VARIABLE
001127  2  65 8D                ADC     GLOBAL+HI       ; STORE ADDRESS BACK IN [VAL]
001129  2  85 6F                STA     I+HI            ; AS A POINTER
00112B  2               
00112B  2               WCEX:
00112B  2  60                   RTS
00112C  2               
00112C  2               ; ---------------
00112C  2               ; PREDICATE FAILS
00112C  2               ; ---------------
00112C  2               
00112C  2               PREDF:
00112C  2  20 E6 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
00112F  2  10 0C                BPL     PREDB           ; DO BRANCH IF BIT 7 OFF
001131  2               
001131  2               ; -----------------------
001131  2               ; IGNORE PREDICATE BRANCH
001131  2               ; -----------------------
001131  2               
001131  2               ; ENTRY: 1ST BRANCH BYTE IN [A]
001131  2               
001131  2               PREDNB:
001131  2  29 40                AND     #%01000000      ; TEST BIT 6
001133  2  D0 F6                BNE     WCEX            ; SHORT BRANCH IF SET
001135  2  4C E6 19             JMP     NEXTPC          ; ELSE SKIP OVER 2ND BRANCH BYTE
001138  2               
001138  2               ; ------------------
001138  2               ; PREDICATE SUCCEEDS
001138  2               ; ------------------
001138  2               
001138  2               PREDS:
001138  2  20 E6 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
00113B  2  10 F4                BPL     PREDNB          ; DON'T BRANCH IF BIT 7 CLEAR
00113D  2               
00113D  2               ; --------------------------
00113D  2               ; PERFORM A PREDICATE BRANCH
00113D  2               ; --------------------------
00113D  2               
00113D  2               ; ENTRY: 1ST PRED BYTE IN [A]
00113D  2               
00113D  2               PREDB:
00113D  2  AA                   TAX                     ; SAVE HERE
00113E  2  29 40                AND     #%01000000      ; LONG OR SHORT BRANCH?
001140  2  F0 0B                BEQ     PREDLB          ; LONG IF BIT 6 IS CLEAR
001142  2               
001142  2               ; HANDLE A SHORT BRANCH
001142  2               
001142  2  8A                   TXA                     ; RESTORE PRED BYTE
001143  2  29 3F                AND     #%00111111      ; FORM SHORT OFFSET
001145  2  85 6C                STA     VALUE+LO        ; USE AS LSB OF BRANCH OFFSET
001147  2  A9 00                LDA     #0
001149  2  85 6D                STA     VALUE+HI        ; MSB OF OFFSET IS ZERO
00114B  2  F0 13                BEQ     PREDB1          ; DO THE BRANCH
00114D  2               
00114D  2               ; HANDLE A LONG BRANCH
00114D  2               
00114D  2               PREDLB:
00114D  2  8A                   TXA                     ; RESTORE 1ST PRED BYTE
00114E  2  29 3F                AND     #%00111111      ; FORM MSB OF OFFSET
001150  2               
001150  2  AA                   TAX                     ; SAVE HERE FOR REFERENCE
001151  2               
001151  2  29 20                AND     #%00100000      ; CHECK SIGN OF 14-BIT VALUE
001153  2  F0 04                BEQ     DOB2            ; POSITIVE IF ZERO, SO USE [X]
001155  2               
001155  2  8A                   TXA                     ; ELSE RESTORE BYTE
001156  2  09 E0                ORA     #%11100000      ; EXTEND THE SIGN BIT
001158  2  AA                   TAX                     ; BACK HERE FOR STORAGE
001159  2               
001159  2               DOB2:
001159  2  86 6D                STX     VALUE+HI
00115B  2  20 E6 19             JSR     NEXTPC          ; FETCH LSB OF 14-BIT OFFSET
00115E  2  85 6C                STA     VALUE+LO
001160  2               
001160  2               ; BRANCH TO Z-ADDRESS IN [VALUE]
001160  2               
001160  2               PREDB1:
001160  2  A5 6D                LDA     VALUE+HI        ; CHECK MSB OF OFFSET
001162  2  D0 0E                BNE     PREDB3          ; DO BRANCH IF NZ
001164  2               
001164  2  A5 6C                LDA     VALUE+LO        ; IF LSB IS NON-ZERO,
001166  2  D0 03                BNE     PREDB2          ; MAKE SURE IT ISN'T 1
001168  2  4C 59 12             JMP     ZRFALS          ; ELSE DO AN "RFALSE"
00116B  2               
00116B  2               PREDB2:
00116B  2  C9 01                CMP     #1              ; IF OFFSET = 1
00116D  2  D0 03                BNE     PREDB3
00116F  2  4C 4E 12             JMP     ZRTRUE          ; DO AN "RTRUE"
001172  2               
001172  2               ; ENTRY POINT FOR "JUMP"
001172  2               
001172  2               PREDB3:
001172  2  20 AC 11             JSR     DECVAL          ; SUBTRACT 2 FROM THE OFFSET
001175  2  20 AC 11             JSR     DECVAL          ; IN [VALUE]
001178  2               
001178  2  A9 00                LDA     #0              ; CLEAR THE MSB
00117A  2  85 6F                STA     I+HI            ; OF [I]
00117C  2               
00117C  2  A5 6D                LDA     VALUE+HI        ; MAKE MSB OF OFFSET
00117E  2  85 6E                STA     I+LO            ; THE LSB OF [I]
001180  2  0A                   ASL     A               ; EXTEND THE SIGN OF OFFSET
001181  2  26 6F                ROL     I+HI            ; INTO MSB OF [I]
001183  2               
001183  2  A5 6C                LDA     VALUE+LO        ; GET LSB OF OFFSET
001185  2  18                   CLC
001186  2  65 76                ADC     ZPCL            ; ADD LOW 8 BITS OF ZPC
001188  2  90 06                BCC     PREDB5          ; IF OVERFLOWED,
00118A  2               
00118A  2  E6 6E                INC     I+LO            ; UPDATE UPPER 9 BITS
00118C  2  D0 02                BNE     PREDB5
00118E  2  E6 6F                INC     I+HI
001190  2               
001190  2               PREDB5:
001190  2  85 76                STA     ZPCL            ; UPDATE ZPC
001192  2               
001192  2  A5 6E                LDA     I+LO            ; IF UPPER 9 BITS ARE ZERO,
001194  2  05 6F                ORA     I+HI            ; NO NEED TO CHANGE PAGES
001196  2  F0 13                BEQ     ZNOOP
001198  2               
001198  2  A5 6E                LDA     I+LO            ; ELSE CALC NEW UPPER BITS
00119A  2  18                   CLC
00119B  2  65 77                ADC     ZPCM
00119D  2  85 77                STA     ZPCM
00119F  2               
00119F  2  A5 6F                LDA     I+HI
0011A1  2  65 78                ADC     ZPCH
0011A3  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
0011A5  2  85 78                STA     ZPCH
0011A7  2               
0011A7  2  A9 00                LDA     #0
0011A9  2  85 79                STA     ZPCFLG          ; [ZPC] NO LONGER VALID
0011AB  2               
0011AB  2               ; FALL THROUGH ...
0011AB  2               
0011AB  2               ; ----
0011AB  2               ; NOOP
0011AB  2               ; ----
0011AB  2               
0011AB  2               ZNOOP:
0011AB  2  60                   RTS
0011AC  2               
0011AC  2               ; -----------------
0011AC  2               ; DECREMENT [VALUE]
0011AC  2               ; -----------------
0011AC  2               
0011AC  2               DECVAL:
0011AC  2  A5 6C                LDA     VALUE+LO
0011AE  2  38                   SEC
0011AF  2  E9 01                SBC     #1
0011B1  2  85 6C                STA     VALUE+LO
0011B3  2  B0 02                BCS     DVX
0011B5  2  C6 6D                DEC     VALUE+HI
0011B7  2               DVX:
0011B7  2  60                   RTS
0011B8  2               
0011B8  2               ; -----------------
0011B8  2               ; INCREMENT [VALUE]
0011B8  2               ; -----------------
0011B8  2               
0011B8  2               INCVAL:
0011B8  2  E6 6C                INC     VALUE+LO
0011BA  2  D0 02                BNE     IVX
0011BC  2  E6 6D                INC     VALUE+HI
0011BE  2               IVX:
0011BE  2  60                   RTS
0011BF  2               
0011BF  2               ; ----------------------
0011BF  2               ; MOVE [ARG1] TO [VALUE]
0011BF  2               ; ----------------------
0011BF  2               
0011BF  2               A12VAL:
0011BF  2  A5 62                LDA     ARG1+LO
0011C1  2  85 6C                STA     VALUE+LO
0011C3  2  A5 63                LDA     ARG1+HI
0011C5  2  85 6D                STA     VALUE+HI
0011C7  2  60                   RTS
0011C8  2               
0011C8  1                       .INCLUDE "dispatch.asm"
0011C8  2               ;        PAGE
0011C8  2               ;        SBTTL   "--- OPCODE DISPATCH TABLES ---"
0011C8  2               
0011C8  2               ; 0-OPS
0011C8  2               
0011C8  2               OPT0:
0011C8  2  4E 12                .WORD   ZRTRUE          ; 0
0011CA  2  59 12                .WORD   ZRFALS          ; 1
0011CC  2  5D 12                .WORD   ZPRI            ; 2
0011CE  2  7A 12                .WORD   ZPRR            ; 3
0011D0  2  AB 11                .WORD   ZNOOP           ; 4
0011D2  2  90 23                .WORD   ZSAVE           ; 5
0011D4  2  05 24                .WORD   ZREST           ; 6
0011D6  2  2D 1E                .WORD   ZSTART          ; 7
0011D8  2  83 12                .WORD   ZRSTAK          ; 8
0011DA  2  B2 10                .WORD   POPVAL          ; 9
0011DC  2  0C 1E                .WORD   ZQUIT           ; 10
0011DE  2  0D 1F                .WORD   ZCRLF           ; 11
0011E0  2  7F 1F                .WORD   ZUSL            ; 12
0011E2  2  89 12                .WORD   ZVER            ; 13
0011E4  2               
0011E4  2               NOPS0           = 14            ; NUMBER OF 0-OPS
0011E4  2               
0011E4  2               ; 1-OPS
0011E4  2               
0011E4  2               OPT1:
0011E4  2  E7 12                .WORD   ZZERO           ; 0
0011E6  2  F0 12                .WORD   ZNEXT           ; 1
0011E8  2  F9 12                .WORD   ZFIRST          ; 2
0011EA  2  0C 13                .WORD   ZLOC            ; 3
0011EC  2  18 13                .WORD   ZPTSIZ          ; 4
0011EE  2  35 13                .WORD   ZINC            ; 5
0011F0  2  40 13                .WORD   ZDEC            ; 6
0011F2  2  4D 13                .WORD   ZPRB            ; 7
0011F4  2  27 10                .WORD   BADOP1          ; 8 (UNDEFINED)
0011F6  2  5B 13                .WORD   ZREMOV          ; 9
0011F8  2  9D 13                .WORD   ZPRD            ; 10
0011FA  2  BA 13                .WORD   ZRET            ; 11
0011FC  2  02 14                .WORD   ZJUMP           ; 12
0011FE  2  08 14                .WORD   ZPRINT          ; 13
001200  2  16 14                .WORD   ZVALUE          ; 14
001202  2  1E 14                .WORD   ZBCOM           ; 15
001204  2               
001204  2               NOPS1           = 16            ; NUMBER OF 1-OPS
001204  2               
001204  2               ; 2-OPS
001204  2               
001204  2               OPT2:
001204  2  64 10                .WORD   BADOP2          ; 0 (UNDEFINED)
001206  2  CC 16                .WORD   ZEQUAL          ; 1
001208  2  2E 14                .WORD   ZLESS           ; 2
00120A  2  42 14                .WORD   ZGRTR           ; 3
00120C  2  34 14                .WORD   ZDLESS          ; 4
00120E  2  4D 14                .WORD   ZIGRTR          ; 5
001210  2  7D 14                .WORD   ZIN             ; 6
001212  2  8D 14                .WORD   ZBTST           ; 7
001214  2  A0 14                .WORD   ZBOR            ; 8
001216  2  AC 14                .WORD   ZBAND           ; 9
001218  2  B8 14                .WORD   ZFSETP          ; 10
00121A  2  CC 14                .WORD   ZFSET           ; 11
00121C  2  DF 14                .WORD   ZFCLR           ; 12
00121E  2  F6 14                .WORD   ZSET            ; 13
001220  2  03 15                .WORD   ZMOVE           ; 14
001222  2  2D 15                .WORD   ZGET            ; 15
001224  2  3D 15                .WORD   ZGETB           ; 16
001226  2  5A 15                .WORD   ZGETP           ; 17
001228  2  A2 15                .WORD   ZGETPT          ; 18
00122A  2  CF 15                .WORD   ZNEXTP          ; 19
00122C  2  EE 15                .WORD   ZADD            ; 20
00122E  2  FB 15                .WORD   ZSUB            ; 21
001230  2  08 16                .WORD   ZMUL            ; 22
001232  2  2C 16                .WORD   ZDIV            ; 23
001234  2  36 16                .WORD   ZMOD            ; 24
001236  2               
001236  2               NOPS2           = 25            ; NUMBER OF 2-OPS
001236  2               
001236  2               ; X-OPS
001236  2               
001236  2               OPTX:
001236  2  FF 16                .WORD   ZCALL           ; 0
001238  2  94 17                .WORD   ZPUT            ; 1
00123A  2  A2 17                .WORD   ZPUTB           ; 2
00123C  2  BD 17                .WORD   ZPUTP           ; 3
00123E  2  69 18                .WORD   ZREAD           ; 4
001240  2  EE 17                .WORD   ZPRC            ; 5
001242  2  F3 17                .WORD   ZPRN            ; 6
001244  2  38 18                .WORD   ZRAND           ; 7
001246  2  5A 18                .WORD   ZPUSH           ; 8
001248  2  61 18                .WORD   ZPOP            ; 9
00124A  2  C3 21                .WORD   ZSPLIT          ; 10
00124C  2  C4 21                .WORD   ZSCRN           ; 11
00124E  2               
00124E  2               NOPSX           = 12            ; NUMBER OF X-OPS
00124E  2               
00124E  1               
00124E  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OPCODE EXECUTORS"
00124E  1                       .INCLUDE "ops0.asm"
00124E  2               ;        PAGE
00124E  2               ;        SBTTL   "--- 0-OPS ---"
00124E  2               
00124E  2               ; -----
00124E  2               ; RTRUE
00124E  2               ; -----
00124E  2               
00124E  2               ; SIMULATE A "RETURN 1"
00124E  2               
00124E  2               ZRTRUE:
00124E  2  A2 01                LDX     #1
001250  2               
001250  2               ZRT0:
001250  2  A9 00                LDA     #0
001252  2               
001252  2               ZRT1:
001252  2  86 62                STX     ARG1+LO         ; GIVE TO
001254  2  85 63                STA     ARG1+HI         ; [ARG1]
001256  2  4C BA 13             JMP     ZRET            ; AND DO THE RETURN
001259  2               
001259  2               ; ------
001259  2               ; RFALSE
001259  2               ; ------
001259  2               
001259  2               ; SIMULATE A "RETURN 0"
001259  2               
001259  2               ZRFALS:
001259  2  A2 00                LDX     #0
00125B  2  F0 F3                BEQ     ZRT0
00125D  2               
00125D  2               ; ------
00125D  2               ; PRINTI
00125D  2               ; ------
00125D  2               
00125D  2               ; PRINT Z-STRING FOLLOWING THE OPCODE
00125D  2               
00125D  2               ZPRI:
00125D  2  A5 78                LDA     ZPCH            ; MOVE [ZPC] INTO [MPC]
00125F  2  85 7E                STA     MPCH
001261  2  A5 77                LDA     ZPCM
001263  2  85 7D                STA     MPCM
001265  2  A5 76                LDA     ZPCL
001267  2  85 7C                STA     MPCL
001269  2               
001269  2  A9 00                LDA     #0
00126B  2  85 7F                STA     MPCFLG          ; [MPC] NO LONGER VALID
00126D  2               
00126D  2  20 37 1B             JSR     PZSTR           ; PRINT THE Z-STRING AT [MPC]
001270  2               
001270  2  A2 05                LDX     #5              ; COPY STATE OF [MPC]
001272  2               PRIL:
001272  2  B5 7C                LDA     MPC,X           ; INTO [ZPC]
001274  2  95 76                STA     ZPC,X
001276  2  CA                   DEX
001277  2  10 F9                BPL     PRIL
001279  2  60                   RTS
00127A  2               
00127A  2               ; ------
00127A  2               ; PRINTR
00127A  2               ; ------
00127A  2               
00127A  2               ; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
00127A  2               
00127A  2               ZPRR:
00127A  2  20 5D 12             JSR     ZPRI
00127D  2  20 0D 1F             JSR     ZCRLF
001280  2  4C 4E 12             JMP     ZRTRUE
001283  2               
001283  2               ; ------
001283  2               ; RSTACK
001283  2               ; ------
001283  2               
001283  2               ; "RETURN" WITH VALUE ON STACK
001283  2               
001283  2               ZRSTAK:
001283  2  20 B2 10             JSR     POPVAL          ; GET VALUE INTO [X/A]
001286  2  4C 52 12             JMP     ZRT1            ; AND GIVE IT TO "RETURN"
001289  2               
001289  2               ; ------
001289  2               ; VERIFY
001289  2               ; ------
001289  2               
001289  2               ; VERIFY GAME CODE ON DISK
001289  2               
001289  2               ZVER:
001289  2  20 4C 1E             JSR     VERNUM          ; DISPLAY ZIP VERSION NUMBER
00128C  2               
00128C  2  A2 03                LDX     #3
00128E  2  A9 00                LDA     #0
001290  2               ZVR:
001290  2  95 70                STA     J+LO,X          ; CLEAR [J], [K]
001292  2  95 7C                STA     MPC,X           ; [MPC] AND [MPCFLG]
001294  2  CA                   DEX
001295  2  10 F9                BPL     ZVR
001297  2               
001297  2  A9 40                LDA     #64             ; POINT [MPC] TO Z-ADDRESS $00040
001299  2  85 7C                STA     MPCL            ; 1ST 64 BYTES AREN'T CHECKED
00129B  2               
00129B  2  AD 1A 2B             LDA     ZBEGIN+ZLENTH   ; GET LENGTH OF Z-CODE
00129E  2  85 6F                STA     I+HI            ; IN WORDS
0012A0  2  AD 1B 2B             LDA     ZBEGIN+ZLENTH+1 ; FIRST MSB
0012A3  2  85 6E                STA     I+LO            ; THEN LSB
0012A5  2               
0012A5  2  06 6E                ASL     I+LO            ; CONVERT Z-CODE LENGTH
0012A7  2  26 6F                ROL     I+HI            ; TO # BYTES
0012A9  2  26 72                ROL     K+LO            ; TOP BIT IN [K+LO]
0012AB  2               
0012AB  2  A9 73                LDA     #K+HI           ; PATCH THE "GETBYT" ROUTINE
0012AD  2  8D 27 1A             STA     PATCH           ; TO USE [K+HI]=0 INSTEAD OF [ZPURE]
0012B0  2               
0012B0  2               VSUM:
0012B0  2  20 1C 1A             JSR     GETBYT          ; GET A Z-BYTE INTO [A]
0012B3  2  18                   CLC
0012B4  2  65 70                ADC     J+LO            ; ADD IT TO SUM
0012B6  2  85 70                STA     J+LO            ; IN [J]
0012B8  2  90 02                BCC     VSUM0
0012BA  2  E6 71                INC     J+HI
0012BC  2               
0012BC  2               VSUM0:
0012BC  2  A5 7C                LDA     MPCL            ; END OF Z-CODE YET?
0012BE  2  C5 6E                CMP     I+LO            ; CHECK LSB
0012C0  2  D0 EE                BNE     VSUM
0012C2  2               
0012C2  2  A5 7D                LDA     MPCM            ; MIDDLE BYTE
0012C4  2  C5 6F                CMP     I+HI
0012C6  2  D0 E8                BNE     VSUM
0012C8  2               
0012C8  2  A5 7E                LDA     MPCH            ; AND HIGH BIT
0012CA  2  C5 72                CMP     K+LO
0012CC  2  D0 E2                BNE     VSUM
0012CE  2               
0012CE  2  A9 84                LDA     #ZPURE          ; UNPATCH "GETBYT"
0012D0  2  8D 27 1A             STA     PATCH
0012D3  2               
0012D3  2  AD 1D 2B             LDA     ZBEGIN+ZCHKSM+1 ; GET LSB OF CHECKSUM
0012D6  2  C5 70                CMP     J+LO            ; DOES IT MATCH?
0012D8  2  D0 0A                BNE     BADVER          ; NO, PREDICATE FAILS
0012DA  2               
0012DA  2  AD 1C 2B             LDA     ZBEGIN+ZCHKSM   ; ELSE CHECK MSB
0012DD  2  C5 71                CMP     J+HI            ; LOOK GOOD?
0012DF  2  D0 03                BNE     BADVER          ; IF MATCHED,
0012E1  2  4C 38 11             JMP     PREDS           ; GAME IS OKAY
0012E4  2               
0012E4  2               BADVER:
0012E4  2  4C 2C 11             JMP     PREDF
0012E7  2               
0012E7  1                       .INCLUDE "ops1.asm"
0012E7  2               ;        PAGE
0012E7  2               ;        SBTTL   "--- 1-OPS ---"
0012E7  2               
0012E7  2               ; -----
0012E7  2               ; ZERO?
0012E7  2               ; -----
0012E7  2               
0012E7  2               ; [ARG1] = 0?
0012E7  2               
0012E7  2               ZZERO:
0012E7  2  A5 62                LDA     ARG1+LO
0012E9  2  05 63                ORA     ARG1+HI
0012EB  2  F0 1C                BEQ     PFINE
0012ED  2               
0012ED  2               PYUCK:
0012ED  2  4C 2C 11             JMP     PREDF
0012F0  2               
0012F0  2               ; -----
0012F0  2               ; NEXT?
0012F0  2               ; -----
0012F0  2               
0012F0  2               ; RETURN "NEXT" POINTER IN OBJECT [ARG1];
0012F0  2               ; FAIL IF LAST AND RETURN ZERO
0012F0  2               
0012F0  2               ZNEXT:
0012F0  2  A5 62                LDA     ARG1+LO
0012F2  2  20 42 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012F5  2  A0 05                LDY     #5              ; POINT TO "NEXT" SLOT
0012F7  2  D0 07                BNE     FIRST1
0012F9  2               
0012F9  2               ; ------
0012F9  2               ; FIRST?
0012F9  2               ; ------
0012F9  2               
0012F9  2               ; RETURN "FIRST" POINTER IN OBJECT [ARG1];
0012F9  2               ; FAIL IF LAST AND RETURN ZERO
0012F9  2               
0012F9  2               ZFIRST:
0012F9  2  A5 62                LDA     ARG1+LO
0012FB  2  20 42 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012FE  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
001300  2               
001300  2               FIRST1:
001300  2  B1 6E                LDA     (I),Y           ; GET CONTENTS OF SLOT
001302  2  20 EA 10             JSR     PUTBYT          ; PASS IT TO VARIABLE
001305  2               
001305  2  A5 6C                LDA     VALUE+LO        ; EXAMINE THE VALUE JUST "PUT"
001307  2  F0 E4                BEQ     PYUCK           ; FAIL IF IT WAS ZERO
001309  2               
001309  2               PFINE:
001309  2  4C 38 11             JMP     PREDS           ; ELSE REJOICE
00130C  2               
00130C  2               ; ---
00130C  2               ; LOC
00130C  2               ; ---
00130C  2               
00130C  2               ; RETURN THE OBJECT CONTAINING OBJECT [ARG1];
00130C  2               ; RETURN ZERO IF NONE
00130C  2               
00130C  2               ZLOC:
00130C  2  A5 62                LDA     ARG1+LO
00130E  2  20 42 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
001311  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001313  2  B1 6E                LDA     (I),Y           ; GET THE BYTE
001315  2  4C EA 10             JMP     PUTBYT          ; AND SHIP IT OUT
001318  2               
001318  2               ; ------
001318  2               ; PTSIZE
001318  2               ; ------
001318  2               
001318  2               ; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
001318  2               
001318  2               ZPTSIZ:
001318  2  A5 63                LDA     ARG1+HI         ; MOVE ABS ADDR OF
00131A  2  18                   CLC                     ; THE PROP TABLE
00131B  2  65 83                ADC     ZCODE           ; INTO [I]
00131D  2  85 6F                STA     I+HI
00131F  2               
00131F  2  A5 62                LDA     ARG1+LO         ; DECREMENT THE
001321  2  38                   SEC                     ; ADDRESS
001322  2  E9 01                SBC     #1              ; WHILE MOVING LSB
001324  2  85 6E                STA     I+LO
001326  2  B0 02                BCS     PTZ0
001328  2  C6 6F                DEC     I+HI
00132A  2               
00132A  2               PTZ0:
00132A  2  A0 00                LDY     #0              ; GET THE LENGTH
00132C  2  20 8C 1D             JSR     PROPL           ; OF PROPERTY AT [I] INTO [A]
00132F  2               
00132F  2  18                   CLC
001330  2  69 01                ADC     #1              ; INCREMENT RESULT
001332  2  4C EA 10             JMP     PUTBYT          ; AND RETURN IT
001335  2               
001335  2               ; ---
001335  2               ; INC
001335  2               ; ---
001335  2               
001335  2               ; INCREMENT VARIABLE [ARG1]
001335  2               
001335  2               ZINC:
001335  2  A5 62                LDA     ARG1+LO
001337  2  20 83 10             JSR     VARGET          ; FETCH VARIABLE INTO [VALUE]
00133A  2  20 B8 11             JSR     INCVAL          ; INCREMENT IT
00133D  2  4C 48 13             JMP     ZD0
001340  2               
001340  2               ; ---
001340  2               ; DEC
001340  2               ; ---
001340  2               
001340  2               ; DECREMENT VARIABLE [ARG1]
001340  2               
001340  2               ZDEC:
001340  2  A5 62                LDA     ARG1+LO
001342  2  20 83 10             JSR     VARGET          ; FETCH VAR INTO [VALUE]
001345  2  20 AC 11             JSR     DECVAL          ; DECREMENT IT
001348  2               
001348  2               ZD0:
001348  2  A5 62                LDA     ARG1+LO         ; PUT RESULT BACK
00134A  2  4C DF 10             JMP     VARPUT          ; INTO THE SAME VARIABLE
00134D  2               
00134D  2               ; ------
00134D  2               ; PRINTB
00134D  2               ; ------
00134D  2               
00134D  2               ; PRINT Z-STRING AT [ARG1]
00134D  2               
00134D  2               ZPRB:
00134D  2  A5 62                LDA     ARG1+LO
00134F  2  85 6E                STA     I+LO
001351  2  A5 63                LDA     ARG1+HI
001353  2  85 6F                STA     I+HI
001355  2               
001355  2  20 0B 1B             JSR     SETWRD          ; MOVE Z-ADDR TO [MPC]
001358  2  4C 37 1B             JMP     PZSTR           ; AND PRINT
00135B  2               
00135B  2               ; ------
00135B  2               ; REMOVE
00135B  2               ; ------
00135B  2               
00135B  2               ; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
00135B  2               
00135B  2               ZREMOV:
00135B  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ADDR
00135D  2  20 42 1D             JSR     OBJLOC          ; INTO [I]
001360  2               
001360  2  A5 6E                LDA     I+LO            ; COPY THE SOURCE ADDR
001362  2  85 70                STA     J+LO            ; INTO [J]
001364  2  A5 6F                LDA     I+HI            ; FOR LATER REFERENCE
001366  2  85 71                STA     J+HI
001368  2               
001368  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
00136A  2  B1 6E                LDA     (I),Y           ; GET THE DATA
00136C  2  F0 2E                BEQ     REMVEX          ; SCRAM IF NO OBJECT
00136E  2               
00136E  2  20 42 1D             JSR     OBJLOC          ; ELSE GET ADDR OF OBJECT [A] INTO [I]
001371  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
001373  2  B1 6E                LDA     (I),Y           ; GRAB DATA
001375  2  C5 62                CMP     ARG1+LO         ; IS THIS THE FIRST?
001377  2  D0 09                BNE     REMVC1          ; NO, KEEP SEARCHING
001379  2               
001379  2  A0 05                LDY     #5              ; ELSE COPY SOURCE'S "NEXT" SLOT
00137B  2  B1 70                LDA     (J),Y
00137D  2  C8                   INY                     ; INTO DEST'S "FIRST" SLOT ([Y] = 6)
00137E  2  91 6E                STA     (I),Y
001380  2  D0 11                BNE     REMVC2          ; BRANCH ALWAYS
001382  2               
001382  2               REMVC1:
001382  2  20 42 1D             JSR     OBJLOC
001385  2  A0 05                LDY     #5              ; GET "NEXT"
001387  2  B1 6E                LDA     (I),Y
001389  2  C5 62                CMP     ARG1+LO         ; FOUND IT?
00138B  2  D0 F5                BNE     REMVC1          ; NO, KEEP TRYING
00138D  2               
00138D  2  A0 05                LDY     #5              ; WHEN FOUND
00138F  2  B1 70                LDA     (J),Y           ; MOVE "NEXT" SLOT OF SOURCE
001391  2  91 6E                STA     (I),Y           ; TO "NEXT" SLOT OF DEST
001393  2               
001393  2               REMVC2:
001393  2  A9 00                LDA     #0
001395  2  A0 04                LDY     #4              ; CLEAR "LOC"
001397  2  91 70                STA     (J),Y
001399  2  C8                   INY                     ; AND "NEXT" SLOTS ([Y] = 5)
00139A  2  91 70                STA     (J),Y           ; OF SOURCE OBJECT
00139C  2               
00139C  2               REMVEX:
00139C  2  60                   RTS
00139D  2               
00139D  2               ; ------
00139D  2               ; PRINTD
00139D  2               ; ------
00139D  2               
00139D  2               ; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
00139D  2               
00139D  2               ZPRD:
00139D  2  A5 62                LDA     ARG1+LO
00139F  2               
00139F  2               ; ENTRY POINT FOR "USL"
00139F  2               
00139F  2               PRNTDC:
00139F  2  20 42 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
0013A2  2  A0 07                LDY     #7              ; GET PROP TABLE POINTER
0013A4  2  B1 6E                LDA     (I),Y           ; FETCH MSB
0013A6  2  AA                   TAX                     ; SAVE IT HERE
0013A7  2  C8                   INY
0013A8  2  B1 6E                LDA     (I),Y           ; FETCH LSB
0013AA  2  85 6E                STA     I+LO            ; STORE LSB
0013AC  2  86 6F                STX     I+HI            ; AND MSB
0013AE  2               
0013AE  2  E6 6E                INC     I+LO            ; POINT PAST THE
0013B0  2  D0 02                BNE     PDC0            ; LENGTH BYTE
0013B2  2  E6 6F                INC     I+HI
0013B4  2               
0013B4  2               PDC0:
0013B4  2  20 0B 1B             JSR     SETWRD          ; CALC Z-STRING ADDR
0013B7  2  4C 37 1B             JMP     PZSTR           ; AND PRINT IT
0013BA  2               
0013BA  2               ; ------
0013BA  2               ; RETURN
0013BA  2               ; ------
0013BA  2               
0013BA  2               ; RETURN FROM "CALL" WITH VALUE [ARG1]
0013BA  2               
0013BA  2               ZRET:
0013BA  2  A5 75                LDA     OLDZSP          ; RE-SYNC THE
0013BC  2  85 74                STA     ZSP             ; Z-STACK POINTER
0013BE  2               
0013BE  2  20 B2 10             JSR     POPVAL          ; POP # LOCALS INTO [X/A]
0013C1  2  86 6F                STX     I+HI            ; SAVE HERE
0013C3  2               
0013C3  2               ; MAKE SURE [X] WAS COMPLEMENT OF [A] (BM 11/24/84)
0013C3  2               
0013C3  2  49 FF                EOR     #$FF            ; COMPLEMENT [A]
0013C5  2  C5 6F                CMP     I+HI            ; MATCHED?
0013C7  2  D0 34                BNE     STKERR          ; ERROR IF NOT
0013C9  2               
0013C9  2  8A                   TXA                     ; SET FLAGS; ANY LOCALS?
0013CA  2  F0 19                BEQ     RET2            ; SKIP IF NOT
0013CC  2               
0013CC  2               ; RESTORE PUSHED LOCALS
0013CC  2               
0013CC  2  CA                   DEX                     ; ZERO-ALIGN
0013CD  2  8A                   TXA                     ; AND
0013CE  2  0A                   ASL     A               ; WORD-ALIGN # LOCALS
0013CF  2  85 6E                STA     I+LO            ; FOR USE AS A STORAGE INDEX
0013D1  2               
0013D1  2               RET1:
0013D1  2  20 B2 10             JSR     POPVAL          ; POP A LOCAL INTO [X/A]
0013D4  2               
0013D4  2  A4 6E                LDY     I+LO            ; RETRIEVE STORAGE INDEX
0013D6  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE MSB OF LOCAL
0013D9  2  8A                   TXA                     ; MOVE LSB
0013DA  2  99 00 0D             STA     LOCALS+LO,Y     ; AND STORE THAT TOO
0013DD  2               
0013DD  2  C6 6E                DEC     I+LO
0013DF  2  C6 6E                DEC     I+LO            ; UPDATE STORAGE INDEX
0013E1  2               
0013E1  2  C6 6F                DEC     I+HI            ; AND LOCALS COUNT
0013E3  2  D0 EC                BNE     RET1            ; POP TILL NO MORE LOCALS
0013E5  2               
0013E5  2               ; RESTORE OTHER VARIABLES
0013E5  2               
0013E5  2               RET2:
0013E5  2  20 B2 10             JSR     POPVAL          ; POP [ZPCH] AND [ZPCM]
0013E8  2  86 77                STX     ZPCM
0013EA  2  85 78                STA     ZPCH
0013EC  2               
0013EC  2  20 B2 10             JSR     POPVAL          ; POP AND RESTORE
0013EF  2  86 75                STX     OLDZSP
0013F1  2  85 76                STA     ZPCL
0013F3  2               
0013F3  2  A9 00                LDA     #0
0013F5  2  85 79                STA     ZPCFLG          ; ZPC CHANGED!
0013F7  2               
0013F7  2  20 BF 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
0013FA  2  4C F0 10             JMP     PUTVAL          ; AND RETURN IT
0013FD  2               
0013FD  2               ; *** ERROR #15: Z-STACK DESTROYED ***
0013FD  2               
0013FD  2               STKERR:
0013FD  2  A9 0F                LDA     #15             ; (BM 11/24/84)
0013FF  2  4C EE 1D             JMP     ZERROR
001402  2               
001402  2               ; ----
001402  2               ; JUMP
001402  2               ; ----
001402  2               
001402  2               ; JUMP TO Z-LOCATION IN [ARG1]
001402  2               
001402  2               ZJUMP:
001402  2  20 BF 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
001405  2  4C 72 11             JMP     PREDB3          ; A BRANCH THAT ALWAYS SUCCEEDS
001408  2               
001408  2               ; -----
001408  2               ; PRINT
001408  2               ; -----
001408  2               
001408  2               ; PRINT Z-STRING AT WORD POINTER [ARG1]
001408  2               
001408  2               ZPRINT:
001408  2  A5 62                LDA     ARG1+LO
00140A  2  85 6E                STA     I+LO
00140C  2  A5 63                LDA     ARG1+HI
00140E  2  85 6F                STA     I+HI
001410  2               
001410  2  20 25 1B             JSR     SETSTR          ; CALC STRING ADDRESS
001413  2  4C 37 1B             JMP     PZSTR           ; AND PRINT IT
001416  2               
001416  2               ; -----
001416  2               ; VALUE
001416  2               ; -----
001416  2               
001416  2               ; RETURN VALUE OF VARIABLE [ARG1]
001416  2               
001416  2               ZVALUE:
001416  2  A5 62                LDA     ARG1+LO
001418  2  20 83 10             JSR     VARGET          ; GET THE VALUE
00141B  2  4C F0 10             JMP     PUTVAL          ; EASY ENOUGH
00141E  2               
00141E  2               ; ----
00141E  2               ; BCOM
00141E  2               ; ----
00141E  2               
00141E  2               ; COMPLEMENT [ARG1]
00141E  2               
00141E  2               ZBCOM:
00141E  2  A5 62                LDA     ARG1+LO
001420  2  49 FF                EOR     #$FF
001422  2  AA                   TAX
001423  2  A5 63                LDA     ARG1+HI
001425  2  49 FF                EOR     #$FF
001427  2               
001427  2               ; FALL THROUGH ...
001427  2               
001427  2               ; ---------------------
001427  2               ; RETURN VALUE IN [X/A]
001427  2               ; ---------------------
001427  2               
001427  2               VEXIT:
001427  2  86 6C                STX     VALUE+LO
001429  2  85 6D                STA     VALUE+HI
00142B  2  4C F0 10             JMP     PUTVAL
00142E  2               
00142E  1                       .INCLUDE "ops2.asm"
00142E  2               ;        PAGE
00142E  2               ;        SBTTL   "--- 2-OPS ---"
00142E  2               
00142E  2               ; -----
00142E  2               ; LESS?
00142E  2               ; -----
00142E  2               
00142E  2               ; [ARG1] < [ARG2]?
00142E  2               
00142E  2               ZLESS:
00142E  2  20 BF 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
001431  2  4C 37 14             JMP     DLS0            ; MOVE [ARG2] TO [I] & COMPARE
001434  2               
001434  2               ; ------
001434  2               ; DLESS?
001434  2               ; ------
001434  2               
001434  2               ; DECREMENT [ARG1]; SUCCEED IF < [ARG2]
001434  2               
001434  2               ZDLESS:
001434  2  20 40 13             JSR     ZDEC            ; MOVES ([ARG1]-1) TO [VALUE]
001437  2               
001437  2               DLS0:
001437  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [I]
001439  2  85 6E                STA     I+LO
00143B  2  A5 65                LDA     ARG2+HI
00143D  2  85 6F                STA     I+HI
00143F  2               
00143F  2  4C 60 14             JMP     COMPAR          ; COMPARE & RETURN
001442  2               
001442  2               ; -----
001442  2               ; GRTR?
001442  2               ; -----
001442  2               
001442  2               ; [ARG1] > [ARG2]?
001442  2               
001442  2               ZGRTR:
001442  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [I]
001444  2  85 6E                STA     I+LO
001446  2  A5 63                LDA     ARG1+HI
001448  2  85 6F                STA     I+HI
00144A  2               
00144A  2  4C 58 14             JMP     A2VAL           ; MOVE [ARG2] TO [VALUE] & COMPARE
00144D  2               
00144D  2               ; ------
00144D  2               ; IGRTR?
00144D  2               ; ------
00144D  2               
00144D  2               ; INCREMENT [ARG1]; SUCCEED IF GREATER THAN [ARG2]
00144D  2               
00144D  2               ZIGRTR:
00144D  2  20 35 13             JSR     ZINC            ; GET ([ARG1]+1) INTO [VALUE]
001450  2               
001450  2  A5 6C                LDA     VALUE+LO        ; MOVE [VALUE] TO [I]
001452  2  85 6E                STA     I+LO
001454  2  A5 6D                LDA     VALUE+HI
001456  2  85 6F                STA     I+HI
001458  2               
001458  2               A2VAL:
001458  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [VALUE]
00145A  2  85 6C                STA     VALUE+LO
00145C  2  A5 65                LDA     ARG2+HI
00145E  2  85 6D                STA     VALUE+HI
001460  2               
001460  2               COMPAR:
001460  2  20 67 14             JSR     SCOMP           ; COMPARE [VALUE] AND [I]
001463  2  90 38                BCC     PGOOD
001465  2  B0 23                BCS     PBAD
001467  2               
001467  2               ; -----------------
001467  2               ; SIGNED COMPARISON
001467  2               ; -----------------
001467  2               
001467  2               ; ENTRY: VALUES IN [VALUE] AND [I]
001467  2               
001467  2               SCOMP:
001467  2  A5 6F                LDA     I+HI
001469  2  45 6D                EOR     VALUE+HI
00146B  2  10 05                BPL     SCMP
00146D  2  A5 6F                LDA     I+HI
00146F  2  C5 6D                CMP     VALUE+HI
001471  2  60                   RTS
001472  2               
001472  2               SCMP:
001472  2  A5 6D                LDA     VALUE+HI
001474  2  C5 6F                CMP     I+HI
001476  2  D0 04                BNE     SCEX
001478  2  A5 6C                LDA     VALUE+LO
00147A  2  C5 6E                CMP     I+LO
00147C  2               SCEX:
00147C  2  60                   RTS
00147D  2               
00147D  2               ; ---
00147D  2               ; IN?
00147D  2               ; ---
00147D  2               
00147D  2               ; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
00147D  2               
00147D  2               ZIN:
00147D  2  A5 62                LDA     ARG1+LO
00147F  2  20 42 1D             JSR     OBJLOC          ; GET ADDR OF TARGET OBJECT INTO [I]
001482  2               
001482  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001484  2  B1 6E                LDA     (I),Y           ; GET DATA
001486  2  C5 64                CMP     ARG2+LO         ; IS IT THERE?
001488  2  F0 13                BEQ     PGOOD           ; YES, SUCCEED
00148A  2               
00148A  2               PBAD:
00148A  2  4C 2C 11             JMP     PREDF           ; TOO BAD, CHUM ...
00148D  2               
00148D  2               ; ----
00148D  2               ; BTST
00148D  2               ; ----
00148D  2               
00148D  2               ; IS EVERY "ON" BIT IN [ARG1]
00148D  2               ; ALSO "ON" IN [ARG2]?
00148D  2               
00148D  2               ZBTST:
00148D  2  A5 64                LDA     ARG2+LO         ; FIRST CHECK LSBS
00148F  2  25 62                AND     ARG1+LO
001491  2  C5 64                CMP     ARG2+LO         ; LSBS MATCH?
001493  2  D0 F5                BNE     PBAD            ; NO, EXIT NOW
001495  2               
001495  2  A5 65                LDA     ARG2+HI         ; ELSE CHECK MSBS
001497  2  25 63                AND     ARG1+HI
001499  2  C5 65                CMP     ARG2+HI         ; MATCHED?
00149B  2  D0 ED                BNE     PBAD            ; SORRY ...
00149D  2               
00149D  2               PGOOD:
00149D  2  4C 38 11             JMP     PREDS
0014A0  2               
0014A0  2               ; ---
0014A0  2               ; BOR
0014A0  2               ; ---
0014A0  2               
0014A0  2               ; RETURN [ARG1] "OR" [ARG2]
0014A0  2               
0014A0  2               ZBOR:
0014A0  2  A5 62                LDA     ARG1+LO
0014A2  2  05 64                ORA     ARG2+LO
0014A4  2  AA                   TAX
0014A5  2  A5 63                LDA     ARG1+HI
0014A7  2  05 65                ORA     ARG2+HI
0014A9  2  4C 27 14             JMP     VEXIT
0014AC  2               
0014AC  2               ; ----
0014AC  2               ; BAND
0014AC  2               ; ----
0014AC  2               
0014AC  2               ; RETURN [ARG1] "AND" [ARG2]
0014AC  2               
0014AC  2               ZBAND:
0014AC  2  A5 62                LDA     ARG1+LO
0014AE  2  25 64                AND     ARG2+LO
0014B0  2  AA                   TAX
0014B1  2  A5 63                LDA     ARG1+HI
0014B3  2  25 65                AND     ARG2+HI
0014B5  2  4C 27 14             JMP     VEXIT
0014B8  2               
0014B8  2               ; -----
0014B8  2               ; FSET?
0014B8  2               ; -----
0014B8  2               
0014B8  2               ; IS FLAG [ARG1] SET IN OBJECT [ARG2]?
0014B8  2               
0014B8  2               ZFSETP:
0014B8  2  20 9E 1D             JSR     FLAGSU          ; GET BITS INTO [K] AND [J]
0014BB  2  A5 73                LDA     K+HI            ; DO MSBS
0014BD  2  25 71                AND     J+HI
0014BF  2  85 73                STA     K+HI
0014C1  2               
0014C1  2  A5 72                LDA     K+LO            ; DO LSBS
0014C3  2  25 70                AND     J+LO
0014C5  2               
0014C5  2  05 73                ORA     K+HI            ; ANY BITS ON?
0014C7  2  D0 D4                BNE     PGOOD           ; TARGET BIT MUST BE ON
0014C9  2  4C 2C 11             JMP     PREDF
0014CC  2               
0014CC  2               ; ----
0014CC  2               ; FSET
0014CC  2               ; ----
0014CC  2               
0014CC  2               ; SET FLAG [ARG2] IN OBJECT [ARG1]
0014CC  2               
0014CC  2               ZFSET:
0014CC  2  20 9E 1D             JSR     FLAGSU          ; GET BITS INTO [K] & [J], ADDR IN [I]
0014CF  2               
0014CF  2  A0 00                LDY     #0
0014D1  2  A5 73                LDA     K+HI            ; FIRST DO MSBS
0014D3  2  05 71                ORA     J+HI
0014D5  2  91 6E                STA     (I),Y
0014D7  2               
0014D7  2  C8                   INY
0014D8  2  A5 72                LDA     K+LO            ; THEN LSBS
0014DA  2  05 70                ORA     J+LO
0014DC  2  91 6E                STA     (I),Y
0014DE  2  60                   RTS
0014DF  2               
0014DF  2               ; ------
0014DF  2               ; FCLEAR
0014DF  2               ; ------
0014DF  2               
0014DF  2               ; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
0014DF  2               
0014DF  2               ZFCLR:
0014DF  2  20 9E 1D             JSR     FLAGSU          ; GETS BITS INTO [J] & [K], ADDR IN [I]
0014E2  2               
0014E2  2  A0 00                LDY     #0
0014E4  2  A5 71                LDA     J+HI            ; FETCH MSB
0014E6  2  49 FF                EOR     #$FF            ; COMPLEMENT IT
0014E8  2  25 73                AND     K+HI            ; RUB OUT FLAG
0014EA  2  91 6E                STA     (I),Y
0014EC  2               
0014EC  2  C8                   INY
0014ED  2  A5 70                LDA     J+LO            ; SAME FOR LSB
0014EF  2  49 FF                EOR     #$FF
0014F1  2  25 72                AND     K+LO
0014F3  2  91 6E                STA     (I),Y
0014F5  2  60                   RTS
0014F6  2               
0014F6  2               ; ---
0014F6  2               ; SET
0014F6  2               ; ---
0014F6  2               
0014F6  2               ; SET VARIABLE [ARG1] EQUAL TO [ARG2]
0014F6  2               
0014F6  2               ZSET:
0014F6  2  A5 64                LDA     ARG2+LO         ; MOVE THE VALUE
0014F8  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
0014FA  2  A5 65                LDA     ARG2+HI
0014FC  2  85 6D                STA     VALUE+HI
0014FE  2               
0014FE  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
001500  2  4C DF 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
001503  2               
001503  2               ; ----
001503  2               ; MOVE
001503  2               ; ----
001503  2               
001503  2               ; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
001503  2               
001503  2               ZMOVE:
001503  2  20 5B 13             JSR     ZREMOV          ; REMOVE FIRST
001506  2               
001506  2  A5 62                LDA     ARG1+LO
001508  2  20 42 1D             JSR     OBJLOC          ; GET SOURCE OBJECT ADDR INTO [I]
00150B  2               
00150B  2  A5 6E                LDA     I+LO            ; COPY SOURCE ADDRESS
00150D  2  85 70                STA     J+LO            ; INTO [J]
00150F  2  A5 6F                LDA     I+HI
001511  2  85 71                STA     J+HI
001513  2               
001513  2  A5 64                LDA     ARG2+LO         ; GET DEST OBJECT ID
001515  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT OF SOURCE
001517  2  91 6E                STA     (I),Y           ; AND MOVE IT IN
001519  2               
001519  2  20 42 1D             JSR     OBJLOC          ; GET ADDR OF DEST OBJECT INTO [I]
00151C  2               
00151C  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
00151E  2  B1 6E                LDA     (I),Y           ; GET "FIRST" OF DEST
001520  2  AA                   TAX                     ; SAVE HERE FOR A MOMENT
001521  2               
001521  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ID
001523  2  91 6E                STA     (I),Y           ; MAKE IT "FIRST" OF DEST
001525  2               
001525  2  8A                   TXA                     ; RESTORE "FIRST" OF DEST
001526  2  F0 04                BEQ     ZMVEX           ; SCRAM IF ZERO
001528  2               
001528  2  A0 05                LDY     #5              ; MAKE "FIRST" OF DEST
00152A  2  91 70                STA     (J),Y           ; THE "NEXT" OF SOURCE
00152C  2               
00152C  2               ZMVEX:
00152C  2  60                   RTS
00152D  2               
00152D  2               ; ---
00152D  2               ; GET
00152D  2               ; ---
00152D  2               
00152D  2               ; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
00152D  2               
00152D  2               ZGET:
00152D  2  20 42 15             JSR     WCALC           ; CALC ADDRESS
001530  2  20 1C 1A             JSR     GETBYT          ; GET 1ST BYTE (MSB)
001533  2               
001533  2               DOGET:
001533  2  85 6D                STA     VALUE+HI        ; SAVE MSB
001535  2  20 1C 1A             JSR     GETBYT          ; GET LSB
001538  2  85 6C                STA     VALUE+LO        ; SAVE AND
00153A  2  4C F0 10             JMP     PUTVAL          ; HAND IT OVER
00153D  2               
00153D  2               ; ----
00153D  2               ; GETB
00153D  2               ; ----
00153D  2               
00153D  2               ; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
00153D  2               
00153D  2               ZGETB:
00153D  2  20 46 15             JSR     BCALC
001540  2  F0 F1                BEQ     DOGET           ; [A] = 0, SO CLEAR MSB OF [VALUE]
001542  2               
001542  2               ; --------------------
001542  2               ; CALC TABLE ADDRESSES
001542  2               ; --------------------
001542  2               
001542  2               ; WORD-ALIGNED ENTRY
001542  2               
001542  2               WCALC:
001542  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN FOR
001544  2  26 65                ROL     ARG2+HI         ; WORD ACCESS
001546  2               
001546  2               ; BYTE-ALIGNED ENTRY
001546  2               
001546  2               BCALC:
001546  2  A5 64                LDA     ARG2+LO         ; ADD BASE ADDR OF TABLE
001548  2  18                   CLC                     ; TO ITEM
001549  2  65 62                ADC     ARG1+LO         ; INDEX
00154B  2  85 7C                STA     MPCL
00154D  2               
00154D  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSBS
00154F  2  65 63                ADC     ARG1+HI
001551  2  85 7D                STA     MPCM
001553  2               
001553  2  A9 00                LDA     #0
001555  2  85 7E                STA     MPCH            ; CLEAR TOP BIT
001557  2  85 7F                STA     MPCFLG          ; & INVALIDATE [MPC]
001559  2  60                   RTS
00155A  2               
00155A  2               ; ----
00155A  2               ; GETP
00155A  2               ; ----
00155A  2               
00155A  2               ; RETURN PROPERTY [ARG2] OF OBJECT [ARG1];
00155A  2               ; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
00155A  2               
00155A  2               ZGETP:
00155A  2  20 6B 1D             JSR     PROPB
00155D  2               
00155D  2               GETP1:
00155D  2  20 87 1D             JSR     PROPN
001560  2  C5 64                CMP     ARG2+LO
001562  2  F0 1B                BEQ     GETP3
001564  2  90 06                BCC     GETP2
001566  2               
001566  2  20 94 1D             JSR     PROPNX
001569  2  4C 5D 15             JMP     GETP1           ; TRY AGAIN WITH NEXT PROP
00156C  2               
00156C  2               GETP2:
00156C  2  A5 64                LDA     ARG2+LO         ; GET PROPERTY #
00156E  2  38                   SEC                     ; ZERO-ALIGN IT
00156F  2  E9 01                SBC     #1
001571  2  0A                   ASL     A               ; WORD-ALIGN IT
001572  2  A8                   TAY                     ; USE AS AN INDEX
001573  2  B1 92                LDA     (OBJTAB),Y      ; GET MSB OF PROPERTY
001575  2  85 6D                STA     VALUE+HI
001577  2  C8                   INY
001578  2  B1 92                LDA     (OBJTAB),Y      ; DO SAME WITH LSB
00157A  2  85 6C                STA     VALUE+LO
00157C  2  4C F0 10             JMP     PUTVAL          ; RETURN DEFAULT IN [VALUE]
00157F  2               
00157F  2               GETP3:
00157F  2  20 8C 1D             JSR     PROPL
001582  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST BYTE OF PROP
001583  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
001584  2  F0 09                BEQ     GETPB           ; GET A BYTE PROPERTY
001586  2  C9 01                CMP     #1              ; IF LENGTH = 1
001588  2  F0 0B                BEQ     GETPW           ; GET A WORD PROPERTY
00158A  2               
00158A  2               ; *** ERROR #7: PROPERTY LENGTH ***
00158A  2               
00158A  2  A9 07                LDA     #7
00158C  2  4C EE 1D             JMP     ZERROR
00158F  2               
00158F  2               ; GET A 1-BYTE PROPERTY
00158F  2               
00158F  2               GETPB:
00158F  2  B1 6E                LDA     (I),Y           ; GET LSB INTO [A]
001591  2  A2 00                LDX     #0              ; CLEAR MSB IN [X]
001593  2  F0 06                BEQ     ETPEX
001595  2               
001595  2               ; GET A 2-BYTE PROPERTY
001595  2               
001595  2               GETPW:
001595  2  B1 6E                LDA     (I),Y           ; GET MSB
001597  2  AA                   TAX                     ; INTO [X]
001598  2  C8                   INY                     ; POINT TO LSB
001599  2  B1 6E                LDA     (I),Y           ; GET IT INTO [A]
00159B  2               
00159B  2               ETPEX:
00159B  2  85 6C                STA     VALUE+LO        ; STORE LSB
00159D  2  86 6D                STX     VALUE+HI        ; AND MSB
00159F  2  4C F0 10             JMP     PUTVAL
0015A2  2               
0015A2  2               ; -----
0015A2  2               ; GETPT
0015A2  2               ; -----
0015A2  2               
0015A2  2               ; RETURN POINTER TO PROP TABLE [ARG2]
0015A2  2               ; IN OBJECT [ARG1]
0015A2  2               
0015A2  2               ZGETPT:
0015A2  2  20 6B 1D             JSR     PROPB
0015A5  2               
0015A5  2               GETPT1:
0015A5  2  20 87 1D             JSR     PROPN           ; RETURNS OFFSET IN [Y]
0015A8  2  C5 64                CMP     ARG2+LO
0015AA  2  F0 08                BEQ     GETPT2
0015AC  2  90 1E                BCC     DORET
0015AE  2  20 94 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
0015B1  2  4C A5 15             JMP     GETPT1
0015B4  2               
0015B4  2               GETPT2:
0015B4  2  E6 6E                INC     I+LO
0015B6  2  D0 02                BNE     GETPT3
0015B8  2  E6 6F                INC     I+HI
0015BA  2               
0015BA  2               GETPT3:
0015BA  2  98                   TYA                     ; FETCH OFFSET
0015BB  2  18                   CLC
0015BC  2  65 6E                ADC     I+LO            ; ADD LSB OF TABLE ADDRESS
0015BE  2  85 6C                STA     VALUE+LO
0015C0  2               
0015C0  2  A5 6F                LDA     I+HI            ; AND MSB
0015C2  2  69 00                ADC     #0
0015C4  2  38                   SEC                     ; STRIP OFF
0015C5  2  E5 83                SBC     ZCODE           ; RELATIVE POINTER
0015C7  2  85 6D                STA     VALUE+HI
0015C9  2  4C F0 10             JMP     PUTVAL          ; AND RETURN
0015CC  2               
0015CC  2               DORET:
0015CC  2  4C E8 10             JMP     RET0            ; ELSE RETURN A ZERO
0015CF  2               
0015CF  2               ; -----
0015CF  2               ; NEXTP
0015CF  2               ; -----
0015CF  2               
0015CF  2               ; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [ARG1];
0015CF  2               ; RETURN ZERO IF LAST; RETURN FIRST IF [ARG2]=0; ERROR IF NONE
0015CF  2               
0015CF  2               ZNEXTP:
0015CF  2  20 6B 1D             JSR     PROPB
0015D2  2  A5 64                LDA     ARG2+LO         ; IF [ARG2]=0
0015D4  2  F0 12                BEQ     NXTP3           ; RETURN "FIRST" SLOT
0015D6  2               
0015D6  2               NXTP1:
0015D6  2  20 87 1D             JSR     PROPN           ; FETCH PROPERTY #
0015D9  2  C5 64                CMP     ARG2+LO         ; COMPARE TO TARGET #
0015DB  2  F0 08                BEQ     NXTP2           ; FOUND IT!
0015DD  2  90 ED                BCC     DORET           ; LAST PROP, SO RETURN ZERO
0015DF  2  20 94 1D             JSR     PROPNX          ; ELSE TRY NEXT PROPERTY
0015E2  2  4C D6 15             JMP     NXTP1
0015E5  2               
0015E5  2               NXTP2:
0015E5  2  20 94 1D             JSR     PROPNX          ; POINT TO FOLLOWING PROPERTY
0015E8  2               
0015E8  2               NXTP3:
0015E8  2  20 87 1D             JSR     PROPN           ; GET THE PROPERTY #
0015EB  2  4C EA 10             JMP     PUTBYT          ; AND RETURN IT
0015EE  2               
0015EE  2               ; ---
0015EE  2               ; ADD
0015EE  2               ; ---
0015EE  2               
0015EE  2               ; RETURN [ARG1] + [ARG2]
0015EE  2               
0015EE  2               ZADD:
0015EE  2  A5 62                LDA     ARG1+LO         ; ADD LSBS
0015F0  2  18                   CLC
0015F1  2  65 64                ADC     ARG2+LO
0015F3  2  AA                   TAX                     ; SAVE LSB HERE
0015F4  2  A5 63                LDA     ARG1+HI         ; ADD MSBS
0015F6  2  65 65                ADC     ARG2+HI
0015F8  2  4C 27 14             JMP     VEXIT
0015FB  2               
0015FB  2               ; ---
0015FB  2               ; SUB
0015FB  2               ; ---
0015FB  2               
0015FB  2               ; RETURN [ARG1] - [ARG2]
0015FB  2               
0015FB  2               ZSUB:
0015FB  2  A5 62                LDA     ARG1+LO         ; SUBTRACT LSBS
0015FD  2  38                   SEC
0015FE  2  E5 64                SBC     ARG2+LO
001600  2  AA                   TAX                     ; SAVE LSB HERE
001601  2  A5 63                LDA     ARG1+HI         ; SUBTRACT MSBS
001603  2  E5 65                SBC     ARG2+HI
001605  2  4C 27 14             JMP     VEXIT           ; EXIT WITH [X]=LSB, [A]=MSB
001608  2               
001608  2               ; ---
001608  2               ; MUL
001608  2               ; ---
001608  2               
001608  2               ; RETURN [ARG1] * [ARG2]
001608  2               
001608  2               ZMUL:
001608  2  20 C2 16             JSR     MINIT           ; INIT THINGS
00160B  2               
00160B  2               ZMLOOP:
00160B  2  66 B8                ROR     MTEMP+HI
00160D  2  66 B7                ROR     MTEMP+LO
00160F  2  66 65                ROR     ARG2+HI
001611  2  66 64                ROR     ARG2+LO
001613  2  90 0D                BCC     ZMNEXT
001615  2               
001615  2  A5 62                LDA     ARG1+LO
001617  2  18                   CLC
001618  2  65 B7                ADC     MTEMP+LO
00161A  2  85 B7                STA     MTEMP+LO
00161C  2  A5 63                LDA     ARG1+HI
00161E  2  65 B8                ADC     MTEMP+HI
001620  2  85 B8                STA     MTEMP+HI
001622  2               
001622  2               ZMNEXT:
001622  2  CA                   DEX
001623  2  10 E6                BPL     ZMLOOP
001625  2               
001625  2  A6 64                LDX     ARG2+LO         ; PUT LSB OF PRODUCT
001627  2  A5 65                LDA     ARG2+HI         ; AND MSB
001629  2  4C 27 14             JMP     VEXIT           ; WHERE "VEXIT" EXPECTS THEM
00162C  2               
00162C  2               ; ---
00162C  2               ; DIV
00162C  2               ; ---
00162C  2               
00162C  2               ; RETURN QUOTIENT OF [ARG1] / [ARG2]
00162C  2               
00162C  2               ZDIV:
00162C  2  20 40 16             JSR     DIVIDE
00162F  2  A6 B3                LDX     QUOT+LO
001631  2  A5 B4                LDA     QUOT+HI
001633  2  4C 27 14             JMP     VEXIT
001636  2               
001636  2               ; ---
001636  2               ; MOD
001636  2               ; ---
001636  2               
001636  2               ; RETURN REMAINDER OF [ARG1] / [ARG2]
001636  2               
001636  2               ZMOD:
001636  2  20 40 16             JSR     DIVIDE
001639  2  A6 B5                LDX     REMAIN+LO       ; FETCH THE REMAINDER
00163B  2  A5 B6                LDA     REMAIN+HI       ; IN [REMAIN]
00163D  2  4C 27 14             JMP     VEXIT           ; AND RETURN IT
001640  2               
001640  2               ; ---------------
001640  2               ; SIGNED DIVISION
001640  2               ; ---------------
001640  2               
001640  2               ; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
001640  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
001640  2               
001640  2               DIVIDE:
001640  2  A5 63                LDA     ARG1+HI         ; SIGN OF REMAINDER
001642  2  85 BA                STA     RSIGN           ; IS THE SIGN OF THE DIVIDEND
001644  2  45 65                EOR     ARG2+HI         ; SIGN OF QUOTIENT IS POSITIVE
001646  2  85 B9                STA     QSIGN           ; IF SIGNS OF TERMS ARE THE SAME
001648  2               
001648  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
00164A  2  85 B3                STA     QUOT+LO
00164C  2  A5 63                LDA     ARG1+HI
00164E  2  85 B4                STA     QUOT+HI         ; IF DIVIDEND IS POSITIVE
001650  2  10 03                BPL     ABSDIV          ; MOVE DIVISOR
001652  2  20 7E 16             JSR     ABQUOT          ; ELSE CALC ABS(DIVIDEND) FIRST
001655  2               
001655  2               ABSDIV:
001655  2  A5 64                LDA     ARG2+LO
001657  2  85 B5                STA     REMAIN+LO
001659  2  A5 65                LDA     ARG2+HI
00165B  2  85 B6                STA     REMAIN+HI       ; IF REMAINDER IS POSITIVE
00165D  2  10 03                BPL     GODIV           ; WE'RE READY TO DIVIDE
00165F  2  20 70 16             JSR     ABREM           ; ELSE CALC ABS(DIVISOR)
001662  2               
001662  2               GODIV:
001662  2  20 8C 16             JSR     UDIV            ; DO UNSIGNED DIVIDE
001665  2               
001665  2  A5 B9                LDA     QSIGN           ; SHOULD QUOTIENT BE FLIPPED?
001667  2  10 03                BPL     RFLIP           ; NO, TEST REMAINDER
001669  2  20 7E 16             JSR     ABQUOT          ; ELSE GET ABSOLUTE VALUE
00166C  2               
00166C  2               RFLIP:
00166C  2  A5 BA                LDA     RSIGN           ; SHOULD EMAINDER BE FLIPPED?
00166E  2  10 0D                BPL     DIVEX           ; NO, WE'RE DONE
001670  2               
001670  2               ; ELSE FALL THROUGH ...
001670  2               
001670  2               ; ----------------
001670  2               ; CALC ABS(REMAIN)
001670  2               ; ----------------
001670  2               
001670  2               ABREM:
001670  2  A9 00                LDA     #0
001672  2  38                   SEC
001673  2  E5 B5                SBC     REMAIN+LO
001675  2  85 B5                STA     REMAIN+LO
001677  2  A9 00                LDA     #0
001679  2  E5 B6                SBC     REMAIN+HI
00167B  2  85 B6                STA     REMAIN+HI
00167D  2               
00167D  2               DIVEX:
00167D  2  60                   RTS
00167E  2               
00167E  2               ; --------------
00167E  2               ; CALC ABS(QUOT)
00167E  2               ; --------------
00167E  2               
00167E  2               ABQUOT:
00167E  2  A9 00                LDA     #0
001680  2  38                   SEC
001681  2  E5 B3                SBC     QUOT+LO
001683  2  85 B3                STA     QUOT+LO
001685  2  A9 00                LDA     #0
001687  2  E5 B4                SBC     QUOT+HI
001689  2  85 B4                STA     QUOT+HI
00168B  2  60                   RTS
00168C  2               
00168C  2               ; -----------------
00168C  2               ; UNSIGNED DIVISION
00168C  2               ; -----------------
00168C  2               
00168C  2               ; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
00168C  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
00168C  2               
00168C  2               UDIV:
00168C  2  A5 B5                LDA     REMAIN+LO       ; CHECK [REMAIN]
00168E  2  05 B6                ORA     REMAIN+HI       ; BEFORE PROCEEDING
001690  2  F0 2B                BEQ     DIVERR          ; CAN'T DIVIDE BY ZERO!
001692  2               
001692  2  20 C2 16             JSR     MINIT           ; SET IT ALL UP
001695  2               
001695  2               UDLOOP:
001695  2  26 B3                ROL     QUOT+LO
001697  2  26 B4                ROL     QUOT+HI
001699  2  26 B7                ROL     MTEMP+LO
00169B  2  26 B8                ROL     MTEMP+HI
00169D  2               
00169D  2  A5 B7                LDA     MTEMP+LO
00169F  2  38                   SEC
0016A0  2  E5 B5                SBC     REMAIN+LO
0016A2  2  A8                   TAY                     ; SAVE HERE
0016A3  2  A5 B8                LDA     MTEMP+HI
0016A5  2  E5 B6                SBC     REMAIN+HI
0016A7  2  90 04                BCC     UDNEXT
0016A9  2  84 B7                STY     MTEMP+LO
0016AB  2  85 B8                STA     MTEMP+HI
0016AD  2               
0016AD  2               UDNEXT:
0016AD  2  CA                   DEX
0016AE  2  D0 E5                BNE     UDLOOP
0016B0  2               
0016B0  2  26 B3                ROL     QUOT+LO         ; SHIFT LAST CARRY FOR QUOTIENT
0016B2  2  26 B4                ROL     QUOT+HI
0016B4  2               
0016B4  2  A5 B7                LDA     MTEMP+LO        ; MOVE REMAINDER
0016B6  2  85 B5                STA     REMAIN+LO       ; INTO [REMAIN]
0016B8  2  A5 B8                LDA     MTEMP+HI
0016BA  2  85 B6                STA     REMAIN+HI
0016BC  2  60                   RTS
0016BD  2               
0016BD  2               ; *** ERROR #8: DIVISION BY ZERO ***
0016BD  2               
0016BD  2               DIVERR:
0016BD  2  A9 08                LDA     #8
0016BF  2  4C EE 1D             JMP     ZERROR
0016C2  2               
0016C2  2               ; ---------
0016C2  2               ; MATH INIT
0016C2  2               ; ---------
0016C2  2               
0016C2  2               MINIT:
0016C2  2  A2 10                LDX     #16             ; INIT LOOPING INDEX
0016C4  2  A9 00                LDA     #0
0016C6  2  85 B7                STA     MTEMP+LO        ; CLEAR TEMP
0016C8  2  85 B8                STA     MTEMP+HI        ; REGISTER
0016CA  2  18                   CLC                     ; AND CARRY
0016CB  2  60                   RTS
0016CC  2               
0016CC  1                       .INCLUDE "opsx.asm"
0016CC  2               ;        PAGE
0016CC  2               ;        SBTTL   "--- X-OPS ---"
0016CC  2               
0016CC  2               ; ------
0016CC  2               ; EQUAL?
0016CC  2               ; ------
0016CC  2               
0016CC  2               ; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
0016CC  2               
0016CC  2               ZEQUAL:
0016CC  2  C6 61                DEC     NARGS           ; DOUBLE-CHECK # ARGS
0016CE  2  D0 05                BNE     DOEQ            ; MUST BE AT LEAST TWO, OR ...
0016D0  2               
0016D0  2               ; *** ERROR #9: NOT ENOUGH "EQUAL?" ARGS ***
0016D0  2               
0016D0  2  A9 09                LDA     #9
0016D2  2  4C EE 1D             JMP     ZERROR
0016D5  2               
0016D5  2               DOEQ:
0016D5  2  A5 62                LDA     ARG1+LO         ; FETCH LSB
0016D7  2  A6 63                LDX     ARG1+HI         ; AND MSB OF [ARG1]
0016D9  2               
0016D9  2  C5 64                CMP     ARG2+LO         ; TEST LSB OF [ARG2]
0016DB  2  D0 04                BNE     TRY2            ; NO GOOD, LOOK FOR ANOTHER ARG
0016DD  2  E4 65                CPX     ARG2+HI         ; ELSE TRY MSB OF [ARG2]
0016DF  2  F0 18                BEQ     EQOK            ; MATCHED!
0016E1  2               
0016E1  2               TRY2:
0016E1  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016E3  2  F0 17                BEQ     EQBAD           ; YES, WE FAILED
0016E5  2               
0016E5  2  C5 66                CMP     ARG3+LO         ; TRY LSB OF [ARG3]
0016E7  2  D0 04                BNE     TRY3            ; NO GOOD, LOOK FOR ANOTHER ARG
0016E9  2  E4 67                CPX     ARG3+HI         ; HOW ABOUT MSB OF [ARG3]?
0016EB  2  F0 0C                BEQ     EQOK            ; YAY!
0016ED  2               
0016ED  2               TRY3:
0016ED  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016EF  2  F0 0B                BEQ     EQBAD           ; IF NOT ...
0016F1  2               
0016F1  2  C5 68                CMP     ARG4+LO         ; TRY [ARG4]
0016F3  2  D0 07                BNE     EQBAD           ; SORRY, CHUM
0016F5  2  E4 69                CPX     ARG4+HI         ; MSB MATCHED?
0016F7  2  D0 03                BNE     EQBAD           ; TOO BAD
0016F9  2               
0016F9  2               EQOK:
0016F9  2  4C 38 11             JMP     PREDS           ; FINALLY MATCHED!
0016FC  2               
0016FC  2               EQBAD:
0016FC  2  4C 2C 11             JMP     PREDF           ; FAILURE (SNIFF!)
0016FF  2               
0016FF  2               ; ----
0016FF  2               ; CALL
0016FF  2               ; ----
0016FF  2               
0016FF  2               ; BRANCH TO FUNCTION AT ([ARG1]*2), PASSING
0016FF  2               ; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
0016FF  2               
0016FF  2               ZCALL:
0016FF  2  A5 62                LDA     ARG1+LO
001701  2  05 63                ORA     ARG1+HI         ; IS CALL ADDRESS ZERO?
001703  2  D0 03                BNE     DOCALL          ; NO, CONTINUE
001705  2               
001705  2  4C EA 10             JMP     PUTBYT          ; ELSE RETURN THE ZERO IN [A]
001708  2               
001708  2               DOCALL:
001708  2  A6 75                LDX     OLDZSP          ; SAVE OLD STACK POINTER
00170A  2  A5 76                LDA     ZPCL            ; AND LSB OF [ZPC]
00170C  2  20 CC 10             JSR     PUSHXA          ; ON THE Z-STACK
00170F  2               
00170F  2  A6 77                LDX     ZPCM            ; SAVE MIDDLE 8 BITS
001711  2  A5 78                LDA     ZPCH            ; AND TOP BIT OF [ZPC]
001713  2  20 CC 10             JSR     PUSHXA          ; AS WELL
001716  2               
001716  2               ; FORM 16-BIT ADDRESS FROM [ARG1]
001716  2               
001716  2  A9 00                LDA     #0              ; CLEAR HIGH BIT FOR ROTATE
001718  2  85 79                STA     ZPCFLG          ; AND INVALIDATE [ZPC]
00171A  2               
00171A  2  06 62                ASL     ARG1+LO         ; MULTIPLY [ARG1]
00171C  2  26 63                ROL     ARG1+HI         ; BY TWO
00171E  2  2A                   ROL     A               ; HIGH BIT INTO [A]
00171F  2  85 78                STA     ZPCH            ; NEW HIGH BIT OF [ZPC]
001721  2               
001721  2  A5 63                LDA     ARG1+HI         ; GET NEW LOW BYTES
001723  2  85 77                STA     ZPCM
001725  2  A5 62                LDA     ARG1+LO
001727  2  85 76                STA     ZPCL
001729  2               
001729  2  20 E6 19             JSR     NEXTPC          ; FETCH # LOCALS TO PASS
00172C  2  85 70                STA     J+LO            ; SAVE HERE FOR COUNTING
00172E  2  85 71                STA     J+HI            ; AND HERE FOR LATER REFERENCE
001730  2  F0 2B                BEQ     ZCALL2          ; SKIP IF NO LOCALS
001732  2               
001732  2  A9 00                LDA     #0
001734  2  85 6E                STA     I+LO            ; ELSE INIT STORAGE INDEX
001736  2               
001736  2               ZCALL1:
001736  2  A4 6E                LDY     I+LO
001738  2  BE 00 0D             LDX     LOCALS+LO,Y     ; GET LSB OF LOCAL INTO [X]
00173B  2  B9 01 0D             LDA     LOCALS+HI,Y     ; AND MSB INTO [A]
00173E  2  84 6E                STY     I+LO            ; SAVE THE INDEX
001740  2  20 CC 10             JSR     PUSHXA          ; PUSH LOCAL IN [X/A] ONTO Z-STACK
001743  2               
001743  2  20 E6 19             JSR     NEXTPC          ; GET MSB OF NEW LOCAL
001746  2  85 6F                STA     I+HI            ; SAVE IT HERE
001748  2  20 E6 19             JSR     NEXTPC          ; NOW GET LSB
00174B  2               
00174B  2  A4 6E                LDY     I+LO            ; RESTORE INDEX
00174D  2  99 00 0D             STA     LOCALS+LO,Y     ; STORE LSB INTO [LOCALS]
001750  2  A5 6F                LDA     I+HI            ; RETRIEVE MSB
001752  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE IT INTO [LOCALS]
001755  2               
001755  2  C8                   INY
001756  2  C8                   INY                     ; UPDATE
001757  2  84 6E                STY     I+LO            ; THE STORAGE INDEX
001759  2               
001759  2  C6 70                DEC     J+LO            ; ANY MORE LOCALS?
00175B  2  D0 D9                BNE     ZCALL1          ; YES, KEEP LOOPING
00175D  2               
00175D  2               ; MOVE UP TO 3 ARGUMENTS TO [LOCALS]
00175D  2               
00175D  2               ZCALL2:
00175D  2  C6 61                DEC     NARGS           ; EXTRA ARGS IN THIS CALL?
00175F  2  F0 26                BEQ     ZCALL3          ; NO, CONTINUE
001761  2               
001761  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO LOCAL #1
001763  2  8D 00 0D             STA     LOCALS+LO
001766  2  A5 65                LDA     ARG2+HI
001768  2  8D 01 0D             STA     LOCALS+HI
00176B  2               
00176B  2  C6 61                DEC     NARGS           ; ANY LEFT?
00176D  2  F0 18                BEQ     ZCALL3          ; NO, SCRAM
00176F  2               
00176F  2  A5 66                LDA     ARG3+LO         ; MOVE [ARG3] TO LOCAL #2
001771  2  8D 02 0D             STA     LOCALS+LO+2
001774  2  A5 67                LDA     ARG3+HI
001776  2  8D 03 0D             STA     LOCALS+HI+2
001779  2               
001779  2  C6 61                DEC     NARGS           ; ANY LEFT?
00177B  2  F0 0A                BEQ     ZCALL3          ; NO, EXUENT
00177D  2               
00177D  2  A5 68                LDA     ARG4+LO         ; MOVE [ARG4] TO LOCAL #3
00177F  2  8D 04 0D             STA     LOCALS+LO+4
001782  2  A5 69                LDA     ARG4+HI
001784  2  8D 05 0D             STA     LOCALS+HI+4
001787  2               
001787  2               ZCALL3:
001787  2  A6 71                LDX     J+HI            ; RETRIEVE # LOCALS
001789  2  8A                   TXA                     ; DUPE INTO [A]
00178A  2  49 FF                EOR     #$FF            ; COMPLEMENT FOR ERROR CHECK (BM 11/24/84)
00178C  2  20 CC 10             JSR     PUSHXA          ; PUSH # LOCALS ONTO Z-STACK
00178F  2               
00178F  2  A5 74                LDA     ZSP             ; REMEMBER WHERE
001791  2  85 75                STA     OLDZSP          ; WE CAME FROM
001793  2               
001793  2  60                   RTS                     ; WHEW!
001794  2               
001794  2               ; ---
001794  2               ; PUT
001794  2               ; ---
001794  2               
001794  2               ; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
001794  2               
001794  2               ZPUT:
001794  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN [ARG2]
001796  2  26 65                ROL     ARG2+HI
001798  2               
001798  2  20 AA 17             JSR     PCALC           ; GET ITEM ADDR INTO [I]
00179B  2  A5 67                LDA     ARG3+HI         ; STORE MSB OF [ARG3]
00179D  2  91 6E                STA     (I),Y           ; INTO MSB OF TABLE POSITION
00179F  2  C8                   INY                     ; POINT TO LSB
0017A0  2  D0 03                BNE     PUTLSB          ; BRANCH ALWAYS
0017A2  2               
0017A2  2               ; ----
0017A2  2               ; PUTB
0017A2  2               ; ----
0017A2  2               
0017A2  2               ; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
0017A2  2               
0017A2  2               ZPUTB:
0017A2  2  20 AA 17             JSR     PCALC
0017A5  2               
0017A5  2               ; ENTRY FOR "PUT"
0017A5  2               
0017A5  2               PUTLSB:
0017A5  2  A5 66                LDA     ARG3+LO         ; GET LSB OF [ARG3]
0017A7  2  91 6E                STA     (I),Y           ; STORE IN TABLE AT [Y]
0017A9  2  60                   RTS
0017AA  2               
0017AA  2               ; ---------------------------
0017AA  2               ; CALC ITEM ADDRESS FOR "PUT"
0017AA  2               ; ---------------------------
0017AA  2               
0017AA  2               PCALC:
0017AA  2  A5 64                LDA     ARG2+LO         ; ADD ITEM OFFSET IN [ARG2]
0017AC  2  18                   CLC                     ; TO TABLE ADDR IN [ARG1]
0017AD  2  65 62                ADC     ARG1+LO         ; TO FORM A POINTER
0017AF  2  85 6E                STA     I+LO            ; IN [I]
0017B1  2               
0017B1  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSB
0017B3  2  65 63                ADC     ARG1+HI
0017B5  2  18                   CLC
0017B6  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
0017B8  2  85 6F                STA     I+HI
0017BA  2               
0017BA  2  A0 00                LDY     #0              ; ZERO FOR INDEXING
0017BC  2  60                   RTS
0017BD  2               
0017BD  2               ; ----
0017BD  2               ; PUTP
0017BD  2               ; ----
0017BD  2               
0017BD  2               ; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
0017BD  2               
0017BD  2               ZPUTP:
0017BD  2  20 6B 1D             JSR     PROPB
0017C0  2               
0017C0  2               PUTP1:
0017C0  2  20 87 1D             JSR     PROPN
0017C3  2  C5 64                CMP     ARG2+LO
0017C5  2  F0 08                BEQ     PUTP2
0017C7  2  90 1B                BCC     PNERR           ; ERROR IF LOWER
0017C9  2               
0017C9  2  20 94 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
0017CC  2  4C C0 17             JMP     PUTP1
0017CF  2               
0017CF  2               PUTP2:
0017CF  2  20 8C 1D             JSR     PROPL
0017D2  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST PROPERTY BYTE
0017D3  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
0017D4  2  F0 09                BEQ     PUTP3           ; PUT A BYTE
0017D6  2  C9 01                CMP     #1              ; PUT A WORD IF [A] = 1
0017D8  2  D0 0F                BNE     PLERR           ; ELSE LENGTH IS BAD
0017DA  2               
0017DA  2  A5 67                LDA     ARG3+HI         ; GET MSB OF PROPERTY
0017DC  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017DE  2  C8                   INY                     ; POINT TO LSB SLOT
0017DF  2               
0017DF  2               PUTP3:
0017DF  2  A5 66                LDA     ARG3+LO         ; FETCH LSB
0017E1  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017E3  2  60                   RTS
0017E4  2               
0017E4  2               ; *** ERROR #10: BAD PROPERTY NUMBER ***
0017E4  2               
0017E4  2               PNERR:
0017E4  2  A9 0A                LDA     #10
0017E6  2  4C EE 1D             JMP     ZERROR
0017E9  2               
0017E9  2               ; *** ERROR #11: PUTP PROPERTY LENGTH ***
0017E9  2               
0017E9  2               PLERR:
0017E9  2  A9 0B                LDA     #11
0017EB  2  4C EE 1D             JMP     ZERROR
0017EE  2               
0017EE  2               ; ------
0017EE  2               ; PRINTC
0017EE  2               ; ------
0017EE  2               
0017EE  2               ; PRINT CHAR WITH ASCII VALUE IN [ARG1]
0017EE  2               
0017EE  2               ZPRC:
0017EE  2  A5 62                LDA     ARG1+LO         ; GRAB THE CHAR
0017F0  2  4C CF 1E             JMP     COUT            ; AND SHIP IT OUT
0017F3  2               
0017F3  2               ; ------
0017F3  2               ; PRINTN
0017F3  2               ; ------
0017F3  2               
0017F3  2               ; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
0017F3  2               
0017F3  2               ZPRN:
0017F3  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
0017F5  2  85 B3                STA     QUOT+LO
0017F7  2  A5 63                LDA     ARG1+HI
0017F9  2  85 B4                STA     QUOT+HI
0017FB  2               
0017FB  2               ; PRINT [QUOT]
0017FB  2               
0017FB  2               NUMBER:
0017FB  2  A5 B4                LDA     QUOT+HI         ; IF VALUE IS POSITIVE
0017FD  2  10 08                BPL     DIGCNT          ; CONTINUE
0017FF  2               
0017FF  2  A9 2D                LDA     #$2D            ; ELSE START WITH A MINUS SIGN
001801  2  20 CF 1E             JSR     COUT
001804  2               
001804  2  20 7E 16             JSR     ABQUOT          ; AND CALC ABS([QUOT])
001807  2               
001807  2               ; COUNT # OF DECIMAL DIGITS
001807  2               
001807  2               DIGCNT:
001807  2  A9 00                LDA     #0              ; RESET
001809  2  85 BB                STA     DIGITS          ; DIGIT INDEX
00180B  2               
00180B  2               DGC:
00180B  2  A5 B3                LDA     QUOT+LO         ; IS QUOTIENT
00180D  2  05 B4                ORA     QUOT+HI         ; ZERO YET?
00180F  2  F0 12                BEQ     PRNTN3          ; YES, READY TO PRINT
001811  2               
001811  2  A9 0A                LDA     #10             ; ELSE DIVIDE [QUOT]
001813  2  85 B5                STA     REMAIN+LO       ; BY 10 (LSB)
001815  2  A9 00                LDA     #0
001817  2  85 B6                STA     REMAIN+HI       ; 10 (MSB)
001819  2               
001819  2  20 8C 16             JSR     UDIV            ; UNSIGNED DIVIDE
00181C  2               
00181C  2  A5 B5                LDA     REMAIN+LO       ; FETCH LSB OF REMAINDER (THE DIGIT)
00181E  2  48                   PHA                     ; SAVE IT ON STACK
00181F  2  E6 BB                INC     DIGITS          ; UPDATE DIGIT COUNT
001821  2  D0 E8                BNE     DGC             ; LOOP TILL QUOTIENT=0
001823  2               
001823  2               PRNTN3:
001823  2  A5 BB                LDA     DIGITS          ; IF DIGIT COUNT IS NZ
001825  2  D0 05                BNE     PRNTN4          ; CONTINUE
001827  2               
001827  2  A9 30                LDA     #'0'            ; ELSE PRINT "0"
001829  2  4C CF 1E             JMP     COUT            ; AND RETURN
00182C  2               
00182C  2               PRNTN4:
00182C  2  68                   PLA                     ; PULL A DIGIT OFF THE STACK
00182D  2  18                   CLC
00182E  2  69 30                ADC     #'0'            ; CONVERT TO ASCII
001830  2  20 CF 1E             JSR     COUT            ; AND PRINT IT
001833  2  C6 BB                DEC     DIGITS          ; OUT OF DIGITS YET?
001835  2  D0 F5                BNE     PRNTN4          ; NO, KEEP LOOPING
001837  2  60                   RTS
001838  2               
001838  2               ; ------
001838  2               ; RANDOM
001838  2               ; ------
001838  2               
001838  2               ; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
001838  2               
001838  2               ZRAND:
001838  2  A5 62                LDA     ARG1+LO         ; MAKE [ARG1] THE DIVISOR
00183A  2  85 64                STA     ARG2+LO
00183C  2  A5 63                LDA     ARG1+HI
00183E  2  85 65                STA     ARG2+HI
001840  2               
001840  2  20 5B 1E             JSR     RANDOM          ; GET RANDOM BYTES INTO [A] AND [X]
001843  2  86 62                STX     ARG1+LO         ; MAKE THEM THE DIVIDEND
001845  2  29 7F                AND     #$7F            ; MAKE SURE MSB IS POSITIVE
001847  2  85 63                STA     ARG1+HI
001849  2               
001849  2  20 40 16             JSR     DIVIDE          ; SIGNED DIVIDE, [ARG1] / [ARG2]
00184C  2               
00184C  2  A5 B5                LDA     REMAIN+LO       ; MOVE REMAINDER
00184E  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
001850  2  A5 B6                LDA     REMAIN+HI
001852  2  85 6D                STA     VALUE+HI
001854  2               
001854  2  20 B8 11             JSR     INCVAL          ; INCREMENT [VALUE]
001857  2  4C F0 10             JMP     PUTVAL          ; AND RETURN RESULT
00185A  2               
00185A  2               ; ----
00185A  2               ; PUSH
00185A  2               ; ----
00185A  2               
00185A  2               ; PUSH [ARG1] ONTO THE Z-STACK
00185A  2               
00185A  2               ZPUSH:
00185A  2  A6 62                LDX     ARG1+LO
00185C  2  A5 63                LDA     ARG1+HI
00185E  2  4C CC 10             JMP     PUSHXA
001861  2               
001861  2               ; ---
001861  2               ; POP
001861  2               ; ---
001861  2               
001861  2               ; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
001861  2               
001861  2               ZPOP:
001861  2  20 B2 10             JSR     POPVAL          ; VALUE INTO [VALUE]
001864  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
001866  2  4C DF 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
001869  2               
001869  1                       .INCLUDE "read.asm"
001869  2               ;        PAGE
001869  2               ;        SBTTL   "--- READ HANDLER ---"
001869  2               
001869  2               ; ----
001869  2               ; READ
001869  2               ; ----
001869  2               
001869  2               ; READ LINE INTO TABLE [ARG1]; PARSE INTO TABLE [ARG2]
001869  2               
001869  2               ZREAD:
001869  2  20 7F 1F             JSR     ZUSL            ; UPDATE THE STATUS LINE
00186C  2               
00186C  2  A5 63                LDA     ARG1+HI         ; MAKE THE TABLE ADDRESSES
00186E  2  18                   CLC                     ; ABSOLUTE
00186F  2  65 83                ADC     ZCODE           ; LSBS NEED NOT CHANGE
001871  2  85 63                STA     ARG1+HI
001873  2               
001873  2  A5 65                LDA     ARG2+HI
001875  2  18                   CLC
001876  2  65 83                ADC     ZCODE
001878  2  85 65                STA     ARG2+HI
00187A  2               
00187A  2  20 26 21             JSR     INPUT           ; READ LINE; RETURN LENGTH IN [A]
00187D  2  85 A2                STA     LINLEN          ; SAVE # CHARS IN LINE
00187F  2               
00187F  2  A9 00                LDA     #0
001881  2  85 A3                STA     WRDLEN          ; INIT # CHARS IN WORD COUNTER
001883  2               
001883  2  A0 01                LDY     #1              ; POINT TO "# WORDS READ" SLOT
001885  2  91 64                STA     (ARG2),Y        ; AND CLEAR IT ([A] = 0)
001887  2               
001887  2  84 A0                STY     SOURCE          ; INIT SOURCE TABLE PNTR ([Y] = 1)
001889  2  C8                   INY                     ; = 2
00188A  2  84 A1                STY     RESULT          ; AND RESULT TABLE POINTER
00188C  2               
00188C  2               ; MAIN LOOP STARTS HERE
00188C  2               
00188C  2               READL:
00188C  2  A0 00                LDY     #0              ; POINT TO "MAX WORDS" SLOT
00188E  2  B1 64                LDA     (ARG2),Y        ; AND READ IT
001890  2  F0 04                BEQ     RLERR           ; PATCH IF ZERO
001892  2  C9 3C                CMP     #60             ; OKAY IF < 60
001894  2  90 04                BCC     RL0
001896  2               
001896  2               RLERR:
001896  2  A9 3B                LDA     #59             ; MAXIMUM VALUE IS 59 (BM 5/14/85)
001898  2  91 64                STA     (ARG2),Y
00189A  2               
00189A  2               RL0:
00189A  2  C8                   INY                     ; POINT TO "# WORDS READ" SLOT
00189B  2  D1 64                CMP     (ARG2),Y        ; TOO MANY WORDS?
00189D  2  90 06                BCC     RLEX            ; EXIT IF SO (BM 5/1/85)
00189F  2               
00189F  2               RL1:
00189F  2  A5 A2                LDA     LINLEN
0018A1  2  05 A3                ORA     WRDLEN          ; OUT OF CHARS AND WORDS?
0018A3  2  D0 01                BNE     RL2             ; NOT YET
0018A5  2               RLEX:
0018A5  2  60                   RTS                     ; ELSE EXIT
0018A6  2               
0018A6  2               RL2:
0018A6  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH
0018A8  2  C9 06                CMP     #6              ; 6 CHARS DONE?
0018AA  2  90 03                BCC     RL3             ; NO, KEEP GOING
0018AC  2  20 3D 19             JSR     FLUSHW          ; ELSE FLUSH REMAINDER OF WORD
0018AF  2               
0018AF  2               RL3:
0018AF  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH AGAIN
0018B1  2  D0 24                BNE     READL2          ; CONTINUE IF NOT FIRST CHAR
0018B3  2               
0018B3  2               ; START A NEW WORD
0018B3  2               
0018B3  2  A2 05                LDX     #5              ; CLEAR Z-WORD INPUT BUFFER
0018B5  2               RLL:
0018B5  2  95 94                STA     IN,X            ; [A] = 0
0018B7  2  CA                   DEX
0018B8  2  10 FB                BPL     RLL
0018BA  2               
0018BA  2  20 2F 19             JSR     EFIND           ; GET BASE ADDRESS INTO [ENTRY]
0018BD  2  A5 A0                LDA     SOURCE          ; STORE THE START POS OF THE WORD
0018BF  2  A0 03                LDY     #3              ; INTO THE "WORD START" SLOT
0018C1  2  91 A4                STA     (ENTRY),Y       ; OF THE RESULT TABLE
0018C3  2               
0018C3  2  A8                   TAY
0018C4  2  B1 62                LDA     (ARG1),Y        ; GET A CHAR FROM SOURCE BUFFER
0018C6  2  20 6A 19             JSR     SIB             ; IS IT A SELF-INSERTING BREAK?
0018C9  2  B0 26                BCS     DOSIB           ; YES IF CARRY WAS SET
0018CB  2               
0018CB  2  20 58 19             JSR     NORM            ; IS IT A "NORMAL" BREAK?
0018CE  2  90 07                BCC     READL2          ; NO, CONTINUE
0018D0  2               
0018D0  2  E6 A0                INC     SOURCE          ; ELSE FLUSH THE STRANDED BREAK
0018D2  2  C6 A2                DEC     LINLEN          ; UPDATE # CHARS LEFT IN LINE
0018D4  2  4C 8C 18             JMP     READL           ; AND LOOP
0018D7  2               
0018D7  2               READL2:
0018D7  2  A5 A2                LDA     LINLEN          ; OUT OF CHARS YET?
0018D9  2  F0 1E                BEQ     READL3          ; LOOKS THAT WAY
0018DB  2               
0018DB  2  A4 A0                LDY     SOURCE
0018DD  2  B1 62                LDA     (ARG1),Y        ; ELSE GRAB NEXT CHAR
0018DF  2  20 53 19             JSR     BREAK           ; IS IT A BREAK?
0018E2  2  B0 15                BCS     READL3          ; YES IF CARRY WAS SET
0018E4  2               
0018E4  2  A6 A3                LDX     WRDLEN          ; ELSE STORE THE CHAR
0018E6  2  95 94                STA     IN,X            ; INTO THE INPUT BUFFER
0018E8  2               
0018E8  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018EA  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD
0018EC  2  E6 A0                INC     SOURCE          ; POINT TO NEXT CHAR IN SOURCE
0018EE  2  4C 8C 18             JMP     READL           ; AND LOOP BACK
0018F1  2               
0018F1  2               DOSIB:
0018F1  2  85 94                STA     IN              ; PUT THE BREAK INTO 1ST WORD SLOT
0018F3  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018F5  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD BUFFER
0018F7  2  E6 A0                INC     SOURCE          ; POINT TO NEXT SOURCE CHAR
0018F9  2               
0018F9  2               READL3:
0018F9  2  A5 A3                LDA     WRDLEN          ; ANY CHARS IN WORD YET?
0018FB  2  F0 8F                BEQ     READL           ; APPARENTLY NOT, SO LOOP BACK
0018FD  2               
0018FD  2  20 2F 19             JSR     EFIND           ; GET ENTRY ADDR INTO [ENTRY]
001900  2  A5 A3                LDA     WRDLEN          ; GET ACTUAL LNGTH OF WORD
001902  2  A0 02                LDY     #2              ; STORE IT IN "WORD LENGTH" SLOT
001904  2  91 A4                STA     (ENTRY),Y       ; OF THE CURRENT ENTRY
001906  2               
001906  2  20 53 1C             JSR     CONZST          ; CONVERT ASCII IN [IN] TO Z-STRING
001909  2  20 7C 19             JSR     FINDW           ; AND LOOK IT UP IN VOCABULARY
00190C  2               
00190C  2  A0 01                LDY     #1
00190E  2  B1 64                LDA     (ARG2),Y        ; FETCH THE # WORDS READ
001910  2  18                   CLC
001911  2  69 01                ADC     #1              ; INCREMENT IT
001913  2  91 64                STA     (ARG2),Y        ; AND UPDATE
001915  2               
001915  2  20 2F 19             JSR     EFIND           ; MAKE [ENTRY] POINT TO ENTRY
001918  2               
001918  2  A0 00                LDY     #0
00191A  2  84 A3                STY     WRDLEN          ; CLEAR # CHARS IN WORD
00191C  2  A5 6D                LDA     VALUE+HI        ; GET MSB OF VOCAB ENTRY ADDRESS
00191E  2  91 A4                STA     (ENTRY),Y       ; AND STORE IN 1ST SLOT OF ENTRY
001920  2  C8                   INY
001921  2  A5 6C                LDA     VALUE+LO        ; ALSO STORE LSB IN 2ND SLOT
001923  2  91 A4                STA     (ENTRY),Y
001925  2               
001925  2  A5 A1                LDA     RESULT          ; UPDATE THE
001927  2  18                   CLC                     ; RESULT TABLE POINTER
001928  2  69 04                ADC     #4              ; SO IT POINTS TO THE
00192A  2  85 A1                STA     RESULT          ; NEXT ENTRY
00192C  2               
00192C  2  4C 8C 18             JMP     READL           ; AND LOOP BACK
00192F  2               
00192F  2               ; -----------------------------------
00192F  2               ; FIND BASE ADDR OF RESULT ENTRY SLOT
00192F  2               ; -----------------------------------
00192F  2               
00192F  2               EFIND:
00192F  2  A5 64                LDA     ARG2+LO         ; LSB OF RESULT TABLE BASE
001931  2  18                   CLC
001932  2  65 A1                ADC     RESULT          ; AND CURRENT POINTER
001934  2  85 A4                STA     ENTRY+LO        ; SAVE IN [ENTRY]
001936  2  A5 65                LDA     ARG2+HI         ; ALSO ADD MSB
001938  2  69 00                ADC     #0
00193A  2  85 A5                STA     ENTRY+HI
00193C  2  60                   RTS
00193D  2               
00193D  2               ; ----------
00193D  2               ; FLUSH WORD
00193D  2               ; ----------
00193D  2               
00193D  2               FLUSHW:
00193D  2  A5 A2                LDA     LINLEN          ; ANY CHARS LEFT IN LINE?
00193F  2  F0 11                BEQ     FLEX            ; NO, SCRAM
001941  2               
001941  2  A4 A0                LDY     SOURCE          ; GET CURRENT CHAR POINTER
001943  2  B1 62                LDA     (ARG1),Y        ; AND GRAB A CHAR
001945  2  20 53 19             JSR     BREAK           ; IS IT A BREAK?
001948  2  B0 08                BCS     FLEX            ; EXIT IF SO
00194A  2  C6 A2                DEC     LINLEN          ; ELSE UPDATE CHAR COUNT
00194C  2  E6 A3                INC     WRDLEN          ; AND WORD-CHAR COUNT
00194E  2  E6 A0                INC     SOURCE          ; AND CHAR POINTER
001950  2  D0 EB                BNE     FLUSHW          ; AND LOOP BACK (ALWAYS)
001952  2               
001952  2               FLEX:
001952  2  60                   RTS
001953  2               
001953  2               ; ---------------------------------
001953  2               ; IS CHAR IN [A] ANY TYPE OF BREAK?
001953  2               ; ---------------------------------
001953  2               
001953  2               BREAK:
001953  2  20 6A 19             JSR     SIB             ; CHECK FOR A SIB FIRST
001956  2  B0 22                BCS     FBRK            ; EXIT NOW IF MATCHED
001958  2               
001958  2               ; ELSE FALL THROUGH ...
001958  2               
001958  2               ; --------------------------------
001958  2               ; IS CHAR IN [A] A "NORMAL" BREAK?
001958  2               ; --------------------------------
001958  2               
001958  2               NORM:
001958  2  A2 05                LDX     #NBRKS-1        ; NUMBER OF "NORMAL" BREAKS
00195A  2               NBL:
00195A  2  DD 64 19             CMP     BRKTBL,X        ; MATCHED?
00195D  2  F0 1B                BEQ     FBRK            ; YES, EXIT
00195F  2  CA                   DEX
001960  2  10 F8                BPL     NBL             ; NO, KEEP LOOKING
001962  2  18                   CLC                     ; NO MATCH, CLEAR CARRY
001963  2  60                   RTS                     ; AND RETURN
001964  2               
001964  2               ; ------------------
001964  2               ; NORMAL BREAK CHARS
001964  2               ; ------------------
001964  2               
001964  2               BRKTBL:
001964  2  21 3F 2C 2E          .BYTE   "!?,."          ; IN ORDER OF
001968  2  0D                   .BYTE   EOL             ; ASCENDING FREQUENCY
001969  2  20                   .BYTE   SPACE           ; SPACE CHAR IS TESTED FIRST FOR SPEED
00196A  2               
00196A  2               NBRKS           = *-BRKTBL      ; # NORMAL BREAKS
00196A  2               
00196A  2               ; ---------------------
00196A  2               ; IS CHAR IN [A] A SIB?
00196A  2               ; ---------------------
00196A  2               
00196A  2               SIB:
00196A  2  AA                   TAX                     ; SAVE TEST CHAR
00196B  2  A0 00                LDY     #0              ; 1ST BYTE IN VOCAB TABLE
00196D  2  B1 8E                LDA     (VOCAB),Y       ; HAS # SIBS
00196F  2  A8                   TAY                     ; USE AS AN INDEX
001970  2  8A                   TXA                     ; RESTORE TEST CHAR
001971  2               SBL:
001971  2  D1 8E                CMP     (VOCAB),Y       ; MATCHED?
001973  2  F0 05                BEQ     FBRK            ; YES, REPORT IT
001975  2  88                   DEY
001976  2  D0 F9                BNE     SBL             ; ELSE KEEP LOOPING
001978  2  18                   CLC                     ; NO MATCH, SO
001979  2  60                   RTS                     ; EXIT WITH CARRY CLEAR
00197A  2               
00197A  2               FBRK:
00197A  2  38                   SEC                     ; EXIT WITH CARRY SET
00197B  2  60                   RTS                     ; IF MATCHED WITH A BREAK CHAR
00197C  2               
00197C  2               ; -----------------
00197C  2               ; VOCABULARY SEARCH
00197C  2               ; -----------------
00197C  2               
00197C  2               ; ENTRY: 4-BYTE TARGET Z-WORD IN [OUT]
00197C  2               ; EXIT: ABS ENTRY ADDRESS IN [VALUE] IF FOUND;
00197C  2               ;       OTHERWISE [VALUE] = 0
00197C  2               
00197C  2               FINDW:
00197C  2  A0 00                LDY     #0              ; GET # SIBS
00197E  2  B1 8E                LDA     (VOCAB),Y       ; IN VOCAB TABLE
001980  2  18                   CLC                     ; INCREMENT IT
001981  2  69 01                ADC     #1              ; FOR PROPER ALIGNMENT
001983  2  65 8E                ADC     VOCAB+LO        ; NOW ADD THE BASE ADDR OF THE TABLE
001985  2  85 6C                STA     VALUE+LO        ; TO GET THE ACTUAL BASE ADDR
001987  2  A5 8F                LDA     VOCAB+HI        ; OF THE VOCAB ENTRIES
001989  2  69 00                ADC     #0              ; WHICH IS SAVED
00198B  2  85 6D                STA     VALUE+HI        ; IN [VALUE]
00198D  2               
00198D  2  B1 6C                LDA     (VALUE),Y       ; GET # BYTES PER ENTRY ([Y] = 0)
00198F  2  85 A8                STA     ESIZE           ; SAVE IT HERE
001991  2               
001991  2  20 B8 11             JSR     INCVAL          ; POINT TO NEXT BYTE
001994  2  B1 6C                LDA     (VALUE),Y       ; GET # ENTRIES IN TABLE (MSB)
001996  2  85 A7                STA     NENTS+HI        ; AND STUFF IT IN [NENTS]
001998  2               
001998  2  20 B8 11             JSR     INCVAL          ; NEXT BYTE
00199B  2  B1 6C                LDA     (VALUE),Y       ; DON'T FORGET THE LSB!
00199D  2  85 A6                STA     NENTS+LO
00199F  2               
00199F  2  20 B8 11             JSR     INCVAL          ; [VALUE] NOW POINTS TO 1ST ENTRY
0019A2  2               
0019A2  2               ; BEGIN THE SEARCH!
0019A2  2               
0019A2  2               FWL1:
0019A2  2  A0 00                LDY     #0
0019A4  2  B1 6C                LDA     (VALUE),Y       ; GET 1ST BYTE OF ENTRY
0019A6  2  C5 9A                CMP     OUT             ; MATCHED 1ST BYTE OF TARGET?
0019A8  2  D0 15                BNE     WNEXT           ; NO, SKIP TO NEXT WORD
0019AA  2               
0019AA  2  C8                   INY
0019AB  2  B1 6C                LDA     (VALUE),Y
0019AD  2  C5 9B                CMP     OUT+1           ; 2ND BYTE MATCHED?
0019AF  2  D0 0E                BNE     WNEXT           ; NOPE
0019B1  2               
0019B1  2  C8                   INY
0019B2  2  B1 6C                LDA     (VALUE),Y
0019B4  2  C5 9C                CMP     OUT+2           ; 3RD BYTE?
0019B6  2  D0 07                BNE     WNEXT           ; SORRY ...
0019B8  2               
0019B8  2  C8                   INY
0019B9  2  B1 6C                LDA     (VALUE),Y
0019BB  2  C5 9D                CMP     OUT+3           ; LAST BYTE
0019BD  2  F0 1F                BEQ     FWSUCC          ; FOUND IT!
0019BF  2               
0019BF  2               WNEXT:
0019BF  2  A5 A8                LDA     ESIZE           ; GET ENTRY SIZE
0019C1  2  18                   CLC                     ; AND ADD IT TO ENTRY ADDRESS
0019C2  2  65 6C                ADC     VALUE+LO        ; TO MAKE [VALUE]
0019C4  2  85 6C                STA     VALUE+LO        ; POINT TO THE NEXT ENTRY
0019C6  2  90 02                BCC     WNX
0019C8  2  E6 6D                INC     VALUE+HI
0019CA  2               
0019CA  2               WNX:
0019CA  2  A5 A6                LDA     NENTS+LO        ; DECREMENT THE
0019CC  2  38                   SEC                     ; ENTRY COUNTER
0019CD  2  E9 01                SBC     #1
0019CF  2  85 A6                STA     NENTS+LO
0019D1  2  B0 02                BCS     WNX1
0019D3  2  C6 A7                DEC     NENTS+HI
0019D5  2               
0019D5  2               WNX1:
0019D5  2  05 A7                ORA     NENTS+HI        ; KEEP SEARCHING
0019D7  2  D0 C9                BNE     FWL1            ; UNTIL COUNT IS ZERO
0019D9  2               
0019D9  2  85 6C                STA     VALUE+LO
0019DB  2  85 6D                STA     VALUE+HI
0019DD  2  60                   RTS                     ; THEN RETURN WITH [VALUE] = 0
0019DE  2               
0019DE  2               ; ENTRY MATCHED!
0019DE  2               
0019DE  2               FWSUCC:
0019DE  2  A5 6D                LDA     VALUE+HI        ; CONVERT ABSOLUTE ENTRY ADDRESS
0019E0  2  38                   SEC                     ; IN [VALUE]
0019E1  2  E5 83                SBC     ZCODE           ; TO RELATIVE Z-ADDRESS
0019E3  2  85 6D                STA     VALUE+HI        ; LSB NEEDN'T CHANGE
0019E5  2  60                   RTS
0019E6  2               
0019E6  1               
0019E6  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OP SUPPORT & MEMORY MANAGEMENT"
0019E6  1                       .INCLUDE "paging.asm"
0019E6  2               ;        PAGE
0019E6  2               ;        SBTTL   "--- TIME-STAMP PAGING ROUTINE ---"
0019E6  2               
0019E6  2               ; -------------------------
0019E6  2               ; FETCH NEXT BYTE OF Z-CODE
0019E6  2               ; -------------------------
0019E6  2               
0019E6  2               ; EXIT: BYTE AT [ZPC] IN [A] & [Y]; FLAGS SET
0019E6  2               
0019E6  2               NEXTPC:
0019E6  2  A5 79                LDA     ZPCFLG          ; IS [ZPCPNT] VALID?
0019E8  2  D0 1E                BNE     NPC2            ; YES, GET THE BYTE
0019EA  2               
0019EA  2               ; Z-PAGE HAS CHANGED!
0019EA  2               
0019EA  2  A5 77                LDA     ZPCM            ; GET TOP
0019EC  2  A4 78                LDY     ZPCH            ; 9 BITS OF [ZPC]
0019EE  2  D0 08                BNE     NPC0            ; SWAP PAGE IF TOP BIT IS SET
0019F0  2               
0019F0  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
0019F2  2  B0 04                BCS     NPC0            ; NO, SWAP IT IN
0019F4  2               
0019F4  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
0019F6  2  D0 07                BNE     NPC1            ; AND GIVE IT TO [ZPCPNT]
0019F8  2               
0019F8  2               NPC0:
0019F8  2  A2 00                LDX     #0
0019FA  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
0019FC  2  20 52 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
0019FF  2               
0019FF  2               NPC1:
0019FF  2  85 7B                STA     ZPCPNT+HI       ; SET ABS PAGE ADDRESS
001A01  2  A2 FF                LDX     #$FF
001A03  2  86 79                STX     ZPCFLG          ; VALIDATE [ZPCPNT]
001A05  2  E8                   INX                     ; = 0
001A06  2  86 7A                STX     ZPCPNT+LO       ; CLEAR LSB OF POINTER
001A08  2               
001A08  2               NPC2:
001A08  2  A4 76                LDY     ZPCL            ; FETCH PAGE INDEX
001A0A  2  B1 7A                LDA     (ZPCPNT),Y      ; GET Z-BYTE
001A0C  2               
001A0C  2  E6 76                INC     ZPCL            ; END OF PAGE YET?
001A0E  2  D0 0A                BNE     NPC3            ; NO, EXIT
001A10  2               
001A10  2  A0 00                LDY     #0
001A12  2  84 79                STY     ZPCFLG          ; ELSE INVALIDATE [ZPCPNT]
001A14  2               
001A14  2  E6 77                INC     ZPCM            ; POINT [ZPC] TO
001A16  2  D0 02                BNE     NPC3            ; THE NEXT
001A18  2  E6 78                INC     ZPCH            ; Z-PAGE
001A1A  2               
001A1A  2               NPC3:
001A1A  2  A8                   TAY                     ; SET FLAGS
001A1B  2  60                   RTS                     ; AND RETURN
001A1C  2               
001A1C  2               ; -------------------------------
001A1C  2               ; GET NEXT BYTE OF VIRTUAL MEMORY
001A1C  2               ; -------------------------------
001A1C  2               
001A1C  2               ; EXIT: BYTE AT [MPC] IN [A] & [Y]; FLAGS SET
001A1C  2               
001A1C  2               GETBYT:
001A1C  2  A5 7F                LDA     MPCFLG          ; IS [MPCPNT] VALID?
001A1E  2  D0 1E                BNE     GTBT2           ; YES, GET THE BYTE
001A20  2               
001A20  2               ; Z-PAGE HAS CHANGED!
001A20  2               
001A20  2  A5 7D                LDA     MPCM            ; GET TOP
001A22  2  A4 7E                LDY     MPCH            ; 9 BITS OF [MPC]
001A24  2  D0 08                BNE     GTBT0           ; SWAP PAGE IF TOP BIT IS SET
001A26  2               
001A26  2               PATCH           = *+1           ; PATCH POINT FOR "VERIFY"
001A26  2               
001A26  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
001A28  2  B0 04                BCS     GTBT0           ; NO, SWAP IT IN
001A2A  2               
001A2A  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
001A2C  2  D0 07                BNE     GTBT1           ; AND GIVE IT TO [MPCPNT]
001A2E  2               
001A2E  2               GTBT0:
001A2E  2  A2 00                LDX     #0
001A30  2  86 79                STX     ZPCFLG          ; INVALIDATE [ZPC]
001A32  2  20 52 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
001A35  2               
001A35  2               GTBT1:
001A35  2  85 81                STA     MPCPNT+HI       ; SET ABS PAGE ADDRESS
001A37  2  A2 FF                LDX     #$FF
001A39  2  86 7F                STX     MPCFLG          ; VALIDATE [MPCPNT]
001A3B  2  E8                   INX                     ; = 0
001A3C  2  86 80                STX     MPCPNT+LO       ; CLEAR LSB OF POINTER
001A3E  2               
001A3E  2               GTBT2:
001A3E  2  A4 7C                LDY     MPCL            ; FETCH PAGE INDEX
001A40  2  B1 80                LDA     (MPCPNT),Y      ; GET Z-BYTE
001A42  2               
001A42  2  E6 7C                INC     MPCL            ; END OF PAGE YET?
001A44  2  D0 0A                BNE     GTBT3           ; NO, EXIT
001A46  2               
001A46  2  A0 00                LDY     #0
001A48  2  84 7F                STY     MPCFLG          ; ELSE INVALIDATE [MPCPNT]
001A4A  2               
001A4A  2  E6 7D                INC     MPCM            ; POINT [MPC] TO
001A4C  2  D0 02                BNE     GTBT3           ; THE NEXT
001A4E  2  E6 7E                INC     MPCH            ; Z-PAGE
001A50  2               
001A50  2               GTBT3:
001A50  2  A8                   TAY                     ; SET FLAGS
001A51  2  60                   RTS                     ; AND RETURN
001A52  2               
001A52  2               ; ------------------------
001A52  2               ; LOCATE A SWAPABLE Z-PAGE
001A52  2               ; ------------------------
001A52  2               
001A52  2               ; ENTRY: TARGET Z-PAGE IN [A/Y] (9 BITS)
001A52  2               ; EXIT: ABSOLUTE PAGE IN [A]
001A52  2               
001A52  2               PAGE:
001A52  2  85 88                STA     TARGET+LO       ; SAVE THE
001A54  2  84 89                STY     TARGET+HI       ; TARGET Z-PAGE HERE
001A56  2               
001A56  2               ; IS THIS Z-PAGE ALREADY PAGED IN?
001A56  2               
001A56  2  A2 00                LDX     #0
001A58  2  86 87                STX     ZPAGE           ; START AT BUFFER #0
001A5A  2               
001A5A  2               PG1:
001A5A  2  DD 00 0B             CMP     PTABL,X         ; LSB MATCHED?
001A5D  2  D0 08                BNE     PG2             ; NO, TRY NEXT BUFFER
001A5F  2  98                   TYA                     ; ELSE CHECK
001A60  2  DD A0 0B             CMP     PTABH,X         ; TOP BIT
001A63  2  F0 2B                BEQ     PG4             ; MATCHED! BUFFER IN [ZPAGE]
001A65  2  A5 88                LDA     TARGET+LO       ; ELSE RESTORE LSB
001A67  2               PG2:
001A67  2  E6 87                INC     ZPAGE           ; UPDATE TALLY
001A69  2  E8                   INX
001A6A  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS YET?
001A6C  2  90 EC                BCC     PG1             ; NO, KEEP SEARCHING
001A6E  2               
001A6E  2               ; SWAP IN THE TARGET PAGE
001A6E  2               
001A6E  2               PG3:
001A6E  2  20 CB 1A             JSR     EARLY           ; GET EARLIEST PAGE
001A71  2  A6 8B                LDX     SWAP            ; INTO [SWAP] & [X]
001A73  2  86 87                STX     ZPAGE           ; SAVE FOR LATER
001A75  2               
001A75  2  A5 88                LDA     TARGET+LO       ; ASSIGN THE TARGET PAGE
001A77  2  9D 00 0B             STA     PTABL,X         ; TO THE EARLIEST BUFFER
001A7A  2  85 CD                STA     DBLOCK+LO       ; ALSO GIVE IT TO ZDOS
001A7C  2               
001A7C  2  A5 89                LDA     TARGET+HI       ; SAME FOR TOP BIT
001A7E  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
001A80  2  9D A0 0B             STA     PTABH,X
001A83  2  85 CE                STA     DBLOCK+HI
001A85  2               
001A85  2  8A                   TXA
001A86  2  18                   CLC
001A87  2  65 85                ADC     PAGE0           ; CALC ABS ADDR OF BUFFER
001A89  2  85 D0                STA     DBUFF+HI        ; GIVE IT TO ZDOS
001A8B  2               
001A8B  2  20 5A 22             JSR     GETDSK          ; SWAP IN THE NEW PAGE
001A8E  2  B0 36                BCS     DSKERR          ; ERROR IF CARRY SET
001A90  2               
001A90  2               ; UPDATE THE TIMESTAMP
001A90  2               
001A90  2               PG4:
001A90  2  A4 87                LDY     ZPAGE           ; GET THE BUFFER INDEX
001A92  2  B9 50 0C             LDA     LRUMAP,Y        ; GET THIS BUFFER'S STAMP
001A95  2  C5 8A                CMP     STAMP           ; SAME AS CURRENT STAMP?
001A97  2  F0 27                BEQ     PG8             ; YES, EXIT
001A99  2               
001A99  2  E6 8A                INC     STAMP           ; UPDATE STAMP
001A9B  2  D0 1C                BNE     PG7             ; CONTINUE IF NO OVERFLOW
001A9D  2               
001A9D  2               ; HANDLE STAMP OVERFLOW
001A9D  2               
001A9D  2  20 E5 1A             JSR     EARLY2          ; GET EARLIEST NON-ZERO STAMP INTO [LRU]
001AA0  2               
001AA0  2  A2 00                LDX     #0              ; INIT INDEX
001AA2  2               PG5:
001AA2  2  BD 50 0C             LDA     LRUMAP,X        ; GET A STAMP READING
001AA5  2  F0 06                BEQ     PG6             ; EXIT IF ALREADY ZERO
001AA7  2  38                   SEC                     ; ELSE SUBTRACT OFF
001AA8  2  E5 82                SBC     LRU             ; THE EARLIEST TIMESTAMP
001AAA  2  9D 50 0C             STA     LRUMAP,X        ; AND REPLACE THE STAMP
001AAD  2               PG6:
001AAD  2  E8                   INX
001AAE  2  E4 86                CPX     PMAX            ; END OF SWAPPING SPACE?
001AB0  2  90 F0                BCC     PG5             ; LOOP TILL ALL STAMPS FIXED
001AB2  2               
001AB2  2  A9 00                LDA     #0              ; TURN BACK THE CLOCK
001AB4  2  38                   SEC                     ; TO REFLECT NEW
001AB5  2  E5 82                SBC     LRU             ; STAMP READING
001AB7  2  85 8A                STA     STAMP
001AB9  2               
001AB9  2               PG7:
001AB9  2  A5 8A                LDA     STAMP           ; FETCH STAMP
001ABB  2  A4 87                LDY     ZPAGE           ; AND PAGE INDEX (BM 8/27/85)
001ABD  2  99 50 0C             STA     LRUMAP,Y        ; STAMP TARGET PAGE WITH IT
001AC0  2               
001AC0  2               PG8:
001AC0  2  A5 87                LDA     ZPAGE           ; GET BUFFER INDEX
001AC2  2  18                   CLC                     ; MAKE IT
001AC3  2  65 85                ADC     PAGE0           ; ABSOLUTE
001AC5  2  60                   RTS                     ; AND RETURN IT IN [A]
001AC6  2               
001AC6  2               ; *** ERROR #14: DRIVE ACCESS ***
001AC6  2               
001AC6  2               DSKERR:
001AC6  2  A9 0E                LDA     #14
001AC8  2  4C EE 1D             JMP     ZERROR
001ACB  2               
001ACB  2               ; -------------------------
001ACB  2               ; LOCATE EARLIEST TIMESTAMP
001ACB  2               ; -------------------------
001ACB  2               
001ACB  2               ; EXIT: [LRU] - EARLIEST TIMESTAMP
001ACB  2               ;	[SWAP] = INDEX TO EARLIEST BUFFER
001ACB  2               
001ACB  2               EARLY:
001ACB  2  A2 00                LDX     #0              ; INIT INDEX
001ACD  2  86 8B                STX     SWAP            ; AND [SWAP]
001ACF  2  AD 50 0C             LDA     LRUMAP          ; GET STAMP OF BUFFER #0
001AD2  2  E8                   INX                     ; START COMPARE WITH BUFFER #1
001AD3  2               EAR0:
001AD3  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001AD6  2  90 05                BCC     EAR1            ; NO, TRY NEXT STAMP
001AD8  2  BD 50 0C             LDA     LRUMAP,X        ; ELSE FETCH EARLIER ENTRY
001ADB  2  86 8B                STX     SWAP            ; AND REMEMBER WHERE WE FOUND IT
001ADD  2               EAR1:
001ADD  2  E8                   INX                     ; POINT TO NEXT STAMP
001ADE  2  E4 86                CPX     PMAX            ; OUT OF STAMPS YET?
001AE0  2  90 F1                BCC     EAR0            ; LOOP TILL EMPTY
001AE2  2               
001AE2  2  85 82                STA     LRU             ; SAVE EARLIEST STAMP HERE
001AE4  2  60                   RTS
001AE5  2               
001AE5  2               ; ----------------------------------
001AE5  2               ; LOCATE EARLIEST NON-ZERO TIMESTAMP
001AE5  2               ; (BM/LS 8/27/85)
001AE5  2               ; ----------------------------------
001AE5  2               
001AE5  2               EARLY2:
001AE5  2  A2 00                LDX     #0
001AE7  2  86 8B                STX     SWAP            ; INIT INDEX
001AE9  2               
001AE9  2               E2A:
001AE9  2  BD 50 0C             LDA     LRUMAP,X        ; GET STAMP OF 1ST BUFFER
001AEC  2  D0 07                BNE     E2B             ; NON-ZERO, SO IT'S OKAY
001AEE  2  E8                   INX                     ; ELSE SKIP TO NEXT BUFFER
001AEF  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001AF1  2  90 F6                BCC     E2A             ; NO, KEEP LOOKING
001AF3  2  B0 13                BCS     E2E             ; ELSE WE MUST USE 0
001AF5  2               
001AF5  2               E2B:
001AF5  2  E8                   INX                     ; START COMPARE WITH NEXT BUFFER
001AF6  2               
001AF6  2               E2C:
001AF6  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001AF9  2  90 08                BCC     E2D             ; IF SMALLER, TRY NEXT STAMP
001AFB  2  BC 50 0C             LDY     LRUMAP,X        ; IS TEST STAMP 0?
001AFE  2  F0 03                BEQ     E2D             ; YES, USE OLD
001B00  2  98                   TYA                     ; ELSE USE NEW
001B01  2  86 8B                STX     SWAP            ; UPDATE BUFFER INDEX
001B03  2               
001B03  2               E2D:
001B03  2  E8                   INX                     ; POINT TO NEXT BUFFER
001B04  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001B06  2  90 EE                BCC     E2C             ; NO, LOOP TILL EMPTY
001B08  2               
001B08  2               E2E:
001B08  2  85 82                STA     LRU             ; [A] HAS EARLIEST STAMP
001B0A  2  60                   RTS
001B0B  2               
001B0B  2               ; -------------------------
001B0B  2               ; POINT [MPC] TO V-ADDR [I]
001B0B  2               ; -------------------------
001B0B  2               
001B0B  2               SETWRD:
001B0B  2  A5 6E                LDA     I+LO
001B0D  2  85 7C                STA     MPCL
001B0F  2  A5 6F                LDA     I+HI
001B11  2  85 7D                STA     MPCM
001B13  2               
001B13  2  A9 00                LDA     #0
001B15  2  85 7E                STA     MPCH            ; ZERO TOP BIT
001B17  2  85 7F                STA     MPCFLG          ; INVALIDATE [MPC]
001B19  2  60                   RTS
001B1A  2               
001B1A  2               ; ----------------------------
001B1A  2               ; GET Z-WORD AT [MPC] INTO [I]
001B1A  2               ; ----------------------------
001B1A  2               
001B1A  2               GETWRD:
001B1A  2  20 1C 1A             JSR     GETBYT
001B1D  2  85 6F                STA     I+HI
001B1F  2  20 1C 1A             JSR     GETBYT
001B22  2  85 6E                STA     I+LO
001B24  2  60                   RTS
001B25  2               
001B25  1                       .INCLUDE "zstring.asm"
001B25  2               ;        PAGE
001B25  2               ;        SBTTL   "--- Z-STRING HANDLERS ---"
001B25  2               
001B25  2               ; -----------------------
001B25  2               ; POINT TO ZSTRING IN [I]
001B25  2               ; -----------------------
001B25  2               
001B25  2               SETSTR:
001B25  2  A5 6E                LDA     I+LO            ; WORD-ALIGN THE ADDRESS
001B27  2  0A                   ASL     A
001B28  2  85 7C                STA     MPCL
001B2A  2  A5 6F                LDA     I+HI
001B2C  2  2A                   ROL     A
001B2D  2  85 7D                STA     MPCM
001B2F  2  A9 00                LDA     #0
001B31  2  85 7F                STA     MPCFLG          ; [MPC] IS CHANGING!
001B33  2  2A                   ROL     A
001B34  2  85 7E                STA     MPCH
001B36  2               
001B36  2               ZSTEX:
001B36  2  60                   RTS
001B37  2               
001B37  2               ; -----------------------
001B37  2               ; PRINT Z-STRING AT [MPC]
001B37  2               ; -----------------------
001B37  2               
001B37  2               PZSTR:
001B37  2  A2 00                LDX     #0
001B39  2  86 A9                STX     PSET            ; ASSUME PERMANENT CHARSET
001B3B  2  86 AD                STX     ZFLAG           ; CLEAR BYTE FLAG
001B3D  2  CA                   DEX                     ; = $FF
001B3E  2  86 AA                STX     TSET            ; NO TEMPSET ACTIVE
001B40  2               
001B40  2               PZTOP:
001B40  2  20 0B 1C             JSR     GETZCH          ; GET A Z-CHAR
001B43  2  B0 F1                BCS     ZSTEX           ; END OF STRING IF CARRY IS SET
001B45  2               
001B45  2  85 AB                STA     ZCHAR           ; ELSE SAVE CHAR HERE
001B47  2  AA                   TAX                     ; SET FLAGS
001B48  2  F0 41                BEQ     BLANK           ; PRINT SPACE IF CHAR = 0
001B4A  2               
001B4A  2  C9 04                CMP     #4              ; IS THIS AN F-WORD?
001B4C  2  90 5B                BCC     DOFREQ          ; APPARENTLY SO
001B4E  2               
001B4E  2  C9 06                CMP     #6              ; PERHAPS A SHIFT CODE?
001B50  2  90 3D                BCC     NEWSET          ; YES, CHANGE CHARSETS
001B52  2               
001B52  2  20 FF 1B             JSR     GETSET          ; ELSE GET CHARSET
001B55  2  AA                   TAX                     ; SET FLAGS
001B56  2  D0 0B                BNE     SET1            ; SKIP IF NOT CHARSET #0
001B58  2               
001B58  2               ; PRINT A LOWER-CASE CHAR (CHARSET #0)
001B58  2               
001B58  2  A9 5B                LDA     #$61-6          ; ASCII "a" MINUS Z-OFFSET
001B5A  2               
001B5A  2               TOASC:
001B5A  2  18                   CLC
001B5B  2  65 AB                ADC     ZCHAR           ; ADD Z-CHAR INDEX
001B5D  2               
001B5D  2               SHOVE:
001B5D  2  20 CF 1E             JSR     COUT            ; SHOW THE CHAR
001B60  2  4C 40 1B             JMP     PZTOP           ; AND GRAB NEXT CHAR
001B63  2               
001B63  2               ; PRINT AN UPPER-CASE CHAR (CHARSET #1)
001B63  2               
001B63  2               SET1:
001B63  2  C9 01                CMP     #1              ; MAKE SURE IT'S SET #1
001B65  2  D0 04                BNE     SET2            ; ELSE MUST BE SET #2
001B67  2               
001B67  2  A9 3B                LDA     #$41-6          ; ASCII "A" MINUS Z-OFFSET
001B69  2  D0 EF                BNE     TOASC           ; SAME AS SET #0
001B6B  2               
001B6B  2               ; PRINT FROM CHARSET #2
001B6B  2               
001B6B  2               SET2:
001B6B  2  A5 AB                LDA     ZCHAR           ; RETRIEVE THE Z-CHAR
001B6D  2  38                   SEC
001B6E  2  E9 06                SBC     #6              ; ZERO-ALIGN IT
001B70  2  F0 07                BEQ     DIRECT          ; IF ZERO, IT'S A "DIRECT" ASCII
001B72  2               
001B72  2  AA                   TAX                     ; OTHERWISE USE CODE AS AN INDEX
001B73  2  BD 28 1D             LDA     CHRTBL,X        ; INTO THE CHARSET TABLE
001B76  2  4C 5D 1B             JMP     SHOVE           ; AND PRINT THE CHAR
001B79  2               
001B79  2               ; DECODE A "DIRECT" ASCII CHAR
001B79  2               
001B79  2               DIRECT:
001B79  2  20 0B 1C             JSR     GETZCH          ; FETCH NEXT Z-CHAR
001B7C  2  0A                   ASL     A
001B7D  2  0A                   ASL     A
001B7E  2  0A                   ASL     A
001B7F  2  0A                   ASL     A
001B80  2  0A                   ASL     A               ; SHIFT INTO POSITION
001B81  2  85 AB                STA     ZCHAR           ; AND SAVE HERE
001B83  2  20 0B 1C             JSR     GETZCH          ; GRAB YET ANOTHER Z-CHAR
001B86  2  05 AB                ORA     ZCHAR           ; SUPERIMPOSE THE 2ND BYTE
001B88  2  4C 5D 1B             JMP     SHOVE           ; AND PRINT THE RESULT
001B8B  2               
001B8B  2               ; PRINT A SPACE
001B8B  2               
001B8B  2               BLANK:
001B8B  2  A9 20                LDA     #SPACE          ; ASCII SPACE CHAR
001B8D  2  D0 CE                BNE     SHOVE
001B8F  2               
001B8F  2               ; CHANGE CHARSET
001B8F  2               
001B8F  2               NEWSET:
001B8F  2  38                   SEC                     ; CONVERT THE SHIFT CODE
001B90  2  E9 03                SBC     #3              ; TO 1 OR 2
001B92  2  A8                   TAY
001B93  2  20 FF 1B             JSR     GETSET          ; IS MODE TEMPORARY?
001B96  2  D0 05                BNE     TOPERM          ; YES, DO A PERMSHIFT
001B98  2  84 AA                STY     TSET            ; ELSE JUST A TEMPSHIFT
001B9A  2  4C 40 1B             JMP     PZTOP           ; AND CONTINUE
001B9D  2               
001B9D  2               TOPERM:
001B9D  2  84 A9                STY     PSET            ; SET PERM CHARSET
001B9F  2  C5 A9                CMP     PSET            ; SAME AS BEFORE?
001BA1  2  F0 9D                BEQ     PZTOP           ; YES, CONTINUE
001BA3  2  A9 00                LDA     #0
001BA5  2  85 A9                STA     PSET            ; ELSE RESET CHARSET
001BA7  2  F0 97                BEQ     PZTOP           ; BEFORE LOOPING BACK
001BA9  2               
001BA9  2               ; PRINT AN F-WORD
001BA9  2               
001BA9  2               DOFREQ:
001BA9  2  38                   SEC
001BAA  2  E9 01                SBC     #1              ; ZERO-ALIGN THE CODE
001BAC  2  0A                   ASL     A               ; AND MULTIPLY TIMES 64
001BAD  2  0A                   ASL     A               ; TO OBTAIN THE SEGMENT OFFSET
001BAE  2  0A                   ASL     A               ; INTO THE F-WORDS TABLE
001BAF  2  0A                   ASL     A
001BB0  2  0A                   ASL     A
001BB1  2  0A                   ASL     A
001BB2  2  85 AC                STA     OFFSET          ; SAVE OFFSET FOR LATER
001BB4  2               
001BB4  2  20 0B 1C             JSR     GETZCH          ; NOW GET THE F-WORD POINTER
001BB7  2  0A                   ASL     A               ; WORD-ALIGN IT
001BB8  2  18                   CLC                     ; AND
001BB9  2  65 AC                ADC     OFFSET          ; ADD THE SEGMENT OFFSET
001BBB  2  A8                   TAY                     ; TO GET THE OFFSET OF THE F-WORD
001BBC  2  B1 90                LDA     (FWORDS),Y      ; FROM THE START OF THE F-WORDS TABLE
001BBE  2  85 6F                STA     I+HI            ; SAVE MSB OF F-WORD ADDRESS
001BC0  2  C8                   INY
001BC1  2  B1 90                LDA     (FWORDS),Y      ; ALSO SAVE LSB
001BC3  2  85 6E                STA     I+LO            ; Z-ADDRESS OF F-WORD IS IN [I]
001BC5  2               
001BC5  2               ; SAVE THE STATE OF CURRENT Z-STRING
001BC5  2               
001BC5  2  A5 7E                LDA     MPCH
001BC7  2  48                   PHA
001BC8  2  A5 7D                LDA     MPCM
001BCA  2  48                   PHA
001BCB  2  A5 7C                LDA     MPCL
001BCD  2  48                   PHA
001BCE  2  A5 A9                LDA     PSET
001BD0  2  48                   PHA
001BD1  2  A5 AD                LDA     ZFLAG
001BD3  2  48                   PHA
001BD4  2  A5 AF                LDA     ZWORD+HI
001BD6  2  48                   PHA
001BD7  2  A5 AE                LDA     ZWORD+LO
001BD9  2  48                   PHA
001BDA  2               
001BDA  2  20 25 1B             JSR     SETSTR          ; PRINT THE Z-STRING
001BDD  2  20 37 1B             JSR     PZSTR           ; IN [I]
001BE0  2               
001BE0  2               ; RESTORE OLD Z-STRING
001BE0  2               
001BE0  2  68                   PLA
001BE1  2  85 AE                STA     ZWORD+LO
001BE3  2  68                   PLA
001BE4  2  85 AF                STA     ZWORD+HI
001BE6  2  68                   PLA
001BE7  2  85 AD                STA     ZFLAG
001BE9  2  68                   PLA
001BEA  2  85 A9                STA     PSET
001BEC  2  68                   PLA
001BED  2  85 7C                STA     MPCL
001BEF  2  68                   PLA
001BF0  2  85 7D                STA     MPCM
001BF2  2  68                   PLA
001BF3  2  85 7E                STA     MPCH
001BF5  2               
001BF5  2  A2 FF                LDX     #$FF
001BF7  2  86 AA                STX     TSET            ; DISABLE TEMP CHARSET
001BF9  2  E8                   INX                     ; = 0
001BFA  2  86 7F                STX     MPCFLG          ; [MPC] HAS CHANGED
001BFC  2  4C 40 1B             JMP     PZTOP           ; CONTINUE INNOCENTLY
001BFF  2               
001BFF  2               ; ----------------------
001BFF  2               ; RETURN CURRENT CHARSET
001BFF  2               ; ----------------------
001BFF  2               
001BFF  2               GETSET:
001BFF  2  A5 AA                LDA     TSET
001C01  2  10 03                BPL     GS
001C03  2  A5 A9                LDA     PSET
001C05  2  60                   RTS
001C06  2               
001C06  2               GS:
001C06  2  A0 FF                LDY     #$FF
001C08  2  84 AA                STY     TSET
001C0A  2  60                   RTS
001C0B  2               
001C0B  2               ; -----------------
001C0B  2               ; FETCH NEXT Z-CHAR
001C0B  2               ; -----------------
001C0B  2               
001C0B  2               GETZCH:
001C0B  2  A5 AD                LDA     ZFLAG           ; WHICH BYTE IS THIS?
001C0D  2  10 02                BPL     GTZ0            ; $FF = LAST
001C0F  2  38                   SEC                     ; SET CARRY TO INDICATE
001C10  2  60                   RTS                     ; NO MORE CHARS
001C11  2               
001C11  2               GTZ0:
001C11  2  D0 13                BNE     GETZ1           ; NOT FIRST CHAR, EITHER
001C13  2               
001C13  2               ; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
001C13  2               
001C13  2  E6 AD                INC     ZFLAG           ; UPDATE CHAR COUNT
001C15  2               
001C15  2  20 1C 1A             JSR     GETBYT          ; GET TRIPLET AT [MPC]
001C18  2  85 AF                STA     ZWORD+HI        ; INTO [ZWORD]
001C1A  2  20 1C 1A             JSR     GETBYT
001C1D  2  85 AE                STA     ZWORD+LO
001C1F  2               
001C1F  2  A5 AF                LDA     ZWORD+HI
001C21  2  4A                   LSR     A
001C22  2  4A                   LSR     A               ; SHIFT 1ST CHAR INTO PLACE
001C23  2  4C 4F 1C             JMP     GTEXIT          ; AND RETURN IT
001C26  2               
001C26  2               GETZ1:
001C26  2  38                   SEC
001C27  2  E9 01                SBC     #1
001C29  2  D0 16                BNE     GETZ2           ; LAST CHAR IN TRIPLET IF ZERO
001C2B  2  A9 02                LDA     #2              ; ELSE
001C2D  2  85 AD                STA     ZFLAG           ; RESET CHAR INDEX
001C2F  2               
001C2F  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001C31  2  85 6E                STA     I+LO            ; MOVE HERE FOR SHIFTING
001C33  2  A5 AF                LDA     ZWORD+HI        ; GET TOP HALF
001C35  2               
001C35  2  06 6E                ASL     I+LO            ; SHIFT THE TOP 3 BITS OF LOWER HALF
001C37  2  2A                   ROL     A               ; INTO THE BOTTOM OF THE TOP HALF
001C38  2  06 6E                ASL     I+LO
001C3A  2  2A                   ROL     A
001C3B  2  06 6E                ASL     I+LO
001C3D  2  2A                   ROL     A
001C3E  2  4C 4F 1C             JMP     GTEXIT
001C41  2               
001C41  2               GETZ2:
001C41  2  A9 00                LDA     #0              ; SET FLAG TO INDICATE
001C43  2  85 AD                STA     ZFLAG           ; END OF TRIPLET
001C45  2               
001C45  2  A5 AF                LDA     ZWORD+HI        ; TEST TOP HALF OF TRIPLET
001C47  2  10 04                BPL     GETZ3           ; CONTINUE IF NOT END OF STRING
001C49  2  A9 FF                LDA     #$FF            ; ELSE
001C4B  2  85 AD                STA     ZFLAG           ; INDICATE LAST TRIPLET IN STRING
001C4D  2               
001C4D  2               GETZ3:
001C4D  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001C4F  2               
001C4F  2               GTEXIT:
001C4F  2  29 1F                AND     #%00011111      ; MASK OUT GARBAGE BITS
001C51  2  18                   CLC
001C52  2  60                   RTS
001C53  2               
001C53  2               ; ---------------------------------
001C53  2               ; CONVERT [IN] TO Z-STRING IN [OUT]
001C53  2               ; ---------------------------------
001C53  2               
001C53  2               CONZST:
001C53  2  A9 05                LDA     #$05            ; FILL OUTPUT BUFFER
001C55  2  AA                   TAX                     ; WITH PAD CHARS ($05)
001C56  2               CZSL:
001C56  2  95 9A                STA     OUT,X
001C58  2  CA                   DEX
001C59  2  10 FB                BPL     CZSL
001C5B  2               
001C5B  2  A9 06                LDA     #6              ; INIT
001C5D  2  85 B0                STA     CONCNT          ; CHAR COUNT
001C5F  2               
001C5F  2  A9 00                LDA     #0              ; CLEAR
001C61  2  85 B1                STA     CONIN           ; SOURCE AND
001C63  2  85 B2                STA     CONOUT          ; OUTPUT INDEXES
001C65  2               
001C65  2               CONTOP:
001C65  2  A6 B1                LDX     CONIN           ; FETCH SOURCE INDEX
001C67  2  E6 B1                INC     CONIN           ; AND UPDATE
001C69  2  B5 94                LDA     IN,X            ; GRAB AN ASCII CHAR
001C6B  2  85 AB                STA     ZCHAR           ; SAVE IT HERE
001C6D  2  D0 04                BNE     NEXTZ           ; CONTINUE IF CHAR WAS NZ
001C6F  2               
001C6F  2  A9 05                LDA     #5              ; ELSE SHIP OUT
001C71  2  D0 2C                BNE     CSHIP           ; A PAD CHAR
001C73  2               
001C73  2               NEXTZ:
001C73  2  A5 AB                LDA     ZCHAR
001C75  2  20 E9 1C             JSR     SAYSET          ; WHICH CHARSET TO USE?
001C78  2  F0 20                BEQ     CSET0           ; LOWER-CASE IF ZERO
001C7A  2               
001C7A  2  18                   CLC                     ; ELSE DO A TEMP-SHIFT
001C7B  2  69 03                ADC     #3              ; 4 = CHARSET 1, 5 = CHARSET 2
001C7D  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001C7F  2  95 9A                STA     OUT,X           ; SEND THE SHIFT CHAR
001C81  2               
001C81  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001C83  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001C85  2  D0 03                BNE     CTEST           ; IF OUT OF CHARS
001C87  2  4C 02 1D             JMP     ZCRUSH          ; CRUSH 'EM!
001C8A  2               
001C8A  2               CTEST:
001C8A  2  A5 AB                LDA     ZCHAR           ; TEST CHAR AGAIN
001C8C  2  20 E9 1C             JSR     SAYSET
001C8F  2  C9 02                CMP     #2
001C91  2  F0 19                BEQ     CSET2           ; CHARSET #2
001C93  2               
001C93  2               ; HANDLE CHARSET #1 (UPPER CASE ALPHA)
001C93  2               
001C93  2  A5 AB                LDA     ZCHAR
001C95  2  38                   SEC
001C96  2  E9 3B                SBC     #$41-6          ; CONVERT TO Z-CHAR
001C98  2  10 05                BPL     CSHIP           ; AND SEND TO OUTPUT
001C9A  2               
001C9A  2               ; HANDLE CHARSET #0 (LOWER CASE ALPHA)
001C9A  2               
001C9A  2               CSET0:
001C9A  2  A5 AB                LDA     ZCHAR
001C9C  2  38                   SEC
001C9D  2  E9 5B                SBC     #$61-6          ; CONVERT TO Z-CHAR
001C9F  2               
001C9F  2               ; SHIP Z-CHAR TO OUTPUT BUFFER
001C9F  2               
001C9F  2               CSHIP:
001C9F  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001CA1  2  95 9A                STA     OUT,X
001CA3  2               
001CA3  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001CA5  2  C6 B0                DEC     CONCNT          ; DONE 6 CHARS YET?
001CA7  2  D0 BC                BNE     CONTOP          ; NO, LOOP BACK
001CA9  2  4C 02 1D             JMP     ZCRUSH          ; ELSE CRUSH
001CAC  2               
001CAC  2               ; HANDLE CHARSET #2 (MISCELLANEOUS)
001CAC  2               
001CAC  2               CSET2:
001CAC  2  A5 AB                LDA     ZCHAR           ; GRAB CHAR
001CAE  2  20 D9 1C             JSR     CTABLE          ; IS IT IN CHARSET #3 TABLE?
001CB1  2  D0 EC                BNE     CSHIP           ; YES, SEND IT TO OUTPUT
001CB3  2               
001CB3  2               ; SEND A "DIRECT" ASCII CHAR
001CB3  2               
001CB3  2  A9 06                LDA     #6              ; ASCII ALERT!
001CB5  2  A6 B2                LDX     CONOUT
001CB7  2  95 9A                STA     OUT,X
001CB9  2               
001CB9  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001CBB  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001CBD  2  F0 43                BEQ     ZCRUSH          ; BUFFER FULL!
001CBF  2               
001CBF  2               ; SEND 1ST HALF OF "DIRECT"
001CBF  2               
001CBF  2  A5 AB                LDA     ZCHAR
001CC1  2  4A                   LSR     A
001CC2  2  4A                   LSR     A
001CC3  2  4A                   LSR     A
001CC4  2  4A                   LSR     A
001CC5  2  4A                   LSR     A
001CC6  2  29 03                AND     #%00000011      ; MASK GARBAGE
001CC8  2  A6 B2                LDX     CONOUT
001CCA  2  95 9A                STA     OUT,X
001CCC  2               
001CCC  2  E6 B2                INC     CONOUT
001CCE  2  C6 B0                DEC     CONCNT
001CD0  2  F0 30                BEQ     ZCRUSH          ; BUFFER FULL!
001CD2  2               
001CD2  2               ; SEND 2ND HALF OF "DIRECT"
001CD2  2               
001CD2  2  A5 AB                LDA     ZCHAR           ; GET CHAR YET AGAIN
001CD4  2  29 1F                AND     #%00011111      ; MASK JUNK
001CD6  2  4C 9F 1C             JMP     CSHIP           ; AND SHIP IT OUT
001CD9  2               
001CD9  2               ; ---------------------
001CD9  2               ; IS [A] IN CHARSET #3?
001CD9  2               ; ---------------------
001CD9  2               
001CD9  2               ; EXIT: [A] = CHAR CODE IF FOUND, Z-FLAG CLEARED
001CD9  2               ;       Z-FLAG SET IF NOT FOUND
001CD9  2               
001CD9  2               CTABLE:
001CD9  2  A2 19                LDX     #25
001CDB  2               CNL:
001CDB  2  DD 28 1D             CMP     CHRTBL,X
001CDE  2  F0 04                BEQ     CNOK
001CE0  2  CA                   DEX
001CE1  2  D0 F8                BNE     CNL
001CE3  2  60                   RTS                     ; Z-FLAG SET IF NO MATCH
001CE4  2               
001CE4  2               CNOK:
001CE4  2  8A                   TXA                     ; CHAR CODE IS INDEX
001CE5  2  18                   CLC
001CE6  2  69 06                ADC     #6              ; PLUS 6
001CE8  2  60                   RTS
001CE9  2               
001CE9  2               ; -----------------------------
001CE9  2               ; RETURN CHARSET OF CHAR IN [A]
001CE9  2               ; -----------------------------
001CE9  2               
001CE9  2               SAYSET:
001CE9  2  C9 61                CMP     #'a'
001CEB  2  90 07                BCC     SAY1
001CED  2  C9 7B                CMP     #'z'+1
001CEF  2  B0 03                BCS     SAY1
001CF1  2  A9 00                LDA     #0              ; IT'S CHARSET #0
001CF3  2  60                   RTS
001CF4  2               
001CF4  2               SAY1:
001CF4  2  C9 41                CMP     #'A'
001CF6  2  90 07                BCC     SAY2
001CF8  2  C9 5B                CMP     #'Z'+1
001CFA  2  B0 03                BCS     SAY2
001CFC  2  A9 01                LDA     #1              ; IT'S CHARSET #1
001CFE  2  60                   RTS
001CFF  2               
001CFF  2               SAY2:
001CFF  2  A9 02                LDA     #2              ; IT'S CHARSET #2
001D01  2  60                   RTS
001D02  2               
001D02  2               ; ----------------------
001D02  2               ; CRUSH Z-CHARS IN [OUT]
001D02  2               ; ----------------------
001D02  2               
001D02  2               ZCRUSH:
001D02  2  A5 9B                LDA     OUT+1           ; GET 2ND Z-CHAR
001D04  2  0A                   ASL     A               ; SHIFT BITS INTO POSITION
001D05  2  0A                   ASL     A
001D06  2  0A                   ASL     A
001D07  2  0A                   ASL     A
001D08  2  26 9A                ROL     OUT             ; ALONG WITH 1ST Z-CHAR
001D0A  2  0A                   ASL     A
001D0B  2  26 9A                ROL     OUT
001D0D  2  05 9C                ORA     OUT+2           ; SUPERIMPOSE 3RD Z-CHAR
001D0F  2  85 9B                STA     OUT+1
001D11  2               
001D11  2  A5 9E                LDA     OUT+4           ; GET 5TH Z-CHAR
001D13  2  0A                   ASL     A               ; SHIFT BITS
001D14  2  0A                   ASL     A
001D15  2  0A                   ASL     A
001D16  2  0A                   ASL     A
001D17  2  26 9D                ROL     OUT+3           ; ALONG WITH 4TH Z-CHAR
001D19  2  0A                   ASL     A
001D1A  2  26 9D                ROL     OUT+3
001D1C  2  05 9F                ORA     OUT+5           ; SUPERIMPOSE 6TH Z-CHAR
001D1E  2  AA                   TAX                     ; SAVE HERE
001D1F  2  A5 9D                LDA     OUT+3           ; GRAB 4TH Z-CHAR
001D21  2  09 80                ORA     #%10000000      ; SET HIGH BIT
001D23  2  85 9C                STA     OUT+2           ; MOVE CRUSHED Z-WORD
001D25  2  86 9D                STX     OUT+3           ; INTO PLACE
001D27  2  60                   RTS
001D28  2               
001D28  2               ; -----------------------
001D28  2               ; CHARSET #2 DECODE TABLE
001D28  2               ; -----------------------
001D28  2               
001D28  2               CHRTBL:
001D28  2  00                   .BYTE   0               ; DUMMY BYTE FOR "DIRECT"
001D29  2  0D                   .BYTE   $0D             ; EOL
001D2A  2  30 31 32 33          .BYTE   "0123456789.,!?_#"
001D2E  2  34 35 36 37  
001D32  2  38 39 2E 2C  
001D3A  2  27                   .BYTE   $27             ; SINGLE QUOTE
001D3B  2  22                   .BYTE   $22             ; DOUBLE QUOTE
001D3C  2  2F 5C 2D 3A          .BYTE   "/\-:()"
001D40  2  28 29        
001D42  2               
001D42  1                       .INCLUDE "objects.asm"
001D42  2               ;        PAGE
001D42  2               ;        SBTTL   "--- OBJECT & PROPERTY HANDLERS ---"
001D42  2               
001D42  2               ; ----------------------------------
001D42  2               ; GET ABSOLUTE ADDRESS OF OBJECT [A]
001D42  2               ; ----------------------------------
001D42  2               
001D42  2               ; EXIT: ADDRESS IN [I]
001D42  2               
001D42  2               OBJLOC:
001D42  2  85 6E                STA     I+LO            ; SAVE LSB FOR ADDING
001D44  2               
001D44  2  A2 00                LDX     #0              ; CLEAR MSB
001D46  2  86 6F                STX     I+HI            ; FOR SHIFTING
001D48  2               
001D48  2  0A                   ASL     A               ; MULTIPLY BY 8
001D49  2  26 6F                ROL     I+HI
001D4B  2  0A                   ASL     A
001D4C  2  26 6F                ROL     I+HI
001D4E  2  0A                   ASL     A
001D4F  2  26 6F                ROL     I+HI
001D51  2               
001D51  2  18                   CLC                     ; ADD TO ITSELF
001D52  2  65 6E                ADC     I+LO            ; TO GET TIMES 9
001D54  2  90 02                BCC     OBJ1
001D56  2  E6 6F                INC     I+HI
001D58  2               
001D58  2               OBJ1:
001D58  2  18                   CLC
001D59  2  69 35                ADC     #53             ; NOW ADD 53
001D5B  2  90 02                BCC     OBJ2            ; (THE OBJECT TABLE OFFSET)
001D5D  2  E6 6F                INC     I+HI
001D5F  2               
001D5F  2               OBJ2:
001D5F  2  18                   CLC                     ; NEXT ADD THE ABS ADDR
001D60  2  65 92                ADC     OBJTAB+LO       ; OF THE OBJECT TABLE
001D62  2  85 6E                STA     I+LO
001D64  2               
001D64  2  A5 6F                LDA     I+HI
001D66  2  65 93                ADC     OBJTAB+HI
001D68  2  85 6F                STA     I+HI
001D6A  2  60                   RTS
001D6B  2               
001D6B  2               ; -----------------------------
001D6B  2               ; GET ADDRESS OF PROPERTY TABLE
001D6B  2               ; -----------------------------
001D6B  2               
001D6B  2               ; EXIT: [I] HAS ABSOLUTE ADDR OF PROPERTY TABLE
001D6B  2               ;       [Y] HAS OFFSET TO START OF PROP IDS
001D6B  2               
001D6B  2               PROPB:
001D6B  2  A5 62                LDA     ARG1+LO
001D6D  2  20 42 1D             JSR     OBJLOC
001D70  2  A0 07                LDY     #7
001D72  2  B1 6E                LDA     (I),Y           ; GET MSB OF P-TABLE ADDRESS
001D74  2  18                   CLC
001D75  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
001D77  2  AA                   TAX                     ; AND SAVE HERE
001D78  2  C8                   INY
001D79  2  B1 6E                LDA     (I),Y           ; NOW GET LSB
001D7B  2  85 6E                STA     I+LO
001D7D  2  86 6F                STX     I+HI            ; [I] NOW POINTS TO PROP TABLE
001D7F  2               
001D7F  2  A0 00                LDY     #0
001D81  2  B1 6E                LDA     (I),Y           ; GET LENGTH OF SHORT DESC
001D83  2  0A                   ASL     A               ; WORD-ALIGN IT
001D84  2  A8                   TAY                     ; EXPECTED HERE
001D85  2  C8                   INY                     ; POINT JUST PAST THE DESCRIPTION
001D86  2  60                   RTS
001D87  2               
001D87  2               ; -------------------
001D87  2               ; FETCH A PROPERTY ID
001D87  2               ; -------------------
001D87  2               
001D87  2               ; ENTRY: LIKE "PROPB" EXIT
001D87  2               
001D87  2               PROPN:
001D87  2  B1 6E                LDA     (I),Y
001D89  2  29 1F                AND     #%00011111      ; MASK OUT LENGTH BITS
001D8B  2  60                   RTS
001D8C  2               
001D8C  2               ; -------------------------------
001D8C  2               ; FETCH # BYTES IN PROPERTY VALUE
001D8C  2               ; -------------------------------
001D8C  2               
001D8C  2               ; ENTRY: LIKE "PROPB" EXIT
001D8C  2               
001D8C  2               PROPL:
001D8C  2  B1 6E                LDA     (I),Y
001D8E  2  4A                   LSR     A               ; LENGTH IS IN
001D8F  2  4A                   LSR     A               ; BITS 7-5
001D90  2  4A                   LSR     A               ; SO SHIFT INTO PLACE
001D91  2  4A                   LSR     A
001D92  2  4A                   LSR     A
001D93  2  60                   RTS
001D94  2               
001D94  2               ; ----------------------
001D94  2               ; POINT TO NEXT PROPERTY
001D94  2               ; ----------------------
001D94  2               
001D94  2               ; ENTRY: LIKE "PROPB" EXIT
001D94  2               
001D94  2               PROPNX:
001D94  2  20 8C 1D             JSR     PROPL           ; GET LENGTH OF CURRENT PROP
001D97  2  AA                   TAX                     ; SAVE HERE
001D98  2               
001D98  2               PPX:
001D98  2  C8                   INY                     ; LOOP UNTIL
001D99  2  CA                   DEX                     ; [Y] POINTS TO
001D9A  2  10 FC                BPL     PPX             ; START OF NEXT PROP
001D9C  2  C8                   INY                     ; CORRECT ALIGNMENT
001D9D  2  60                   RTS
001D9E  2               
001D9E  2               ; ----------------
001D9E  2               ; GET OBJECT FLAGS
001D9E  2               ; ----------------
001D9E  2               
001D9E  2               ; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
001D9E  2               ; EXIT: FLAG WORD IN [K], BIT ID IN [J],
001D9E  2               ;       FLAG WORD ADDRESS IN [I]
001D9E  2               
001D9E  2               FLAGSU:
001D9E  2  A5 62                LDA     ARG1+LO
001DA0  2  20 42 1D             JSR     OBJLOC          ; GET OBJECT ADDR IN [I]
001DA3  2               
001DA3  2  A5 64                LDA     ARG2+LO         ; LOOK AT FLAG ID
001DA5  2  C9 10                CMP     #$10            ; FIRST SET OF FLAGS?
001DA7  2  90 0F                BCC     FLS1            ; YES, ADDR IN [I] IS CORRECT
001DA9  2               
001DA9  2  E9 10                SBC     #16             ; ELSE ZERO-ALIGN FLAG INDEX
001DAB  2  AA                   TAX                     ; SAVE IT HERE
001DAC  2               
001DAC  2  A5 6E                LDA     I+LO            ; ADD 2 TO ADDRESS IN [I]
001DAE  2  18                   CLC                     ; TO POINT TO ADDRESS OF
001DAF  2  69 02                ADC     #2              ; 2ND FLAG WORD
001DB1  2  85 6E                STA     I+LO
001DB3  2  90 02                BCC     FLS0
001DB5  2  E6 6F                INC     I+HI
001DB7  2               
001DB7  2               FLS0:
001DB7  2  8A                   TXA                     ; RESTORE INDEX
001DB8  2               
001DB8  2               FLS1:
001DB8  2  85 72                STA     K+LO            ; SAVE FLAG ID HERE
001DBA  2               
001DBA  2  A2 01                LDX     #1              ; INIT THE
001DBC  2  86 70                STX     J+LO            ; FLAG WORD TO
001DBE  2  CA                   DEX                     ; $0001
001DBF  2  86 71                STX     J+HI
001DC1  2               
001DC1  2  A9 0F                LDA     #15             ; SUBTRACT THE BIT POSITION
001DC3  2  38                   SEC                     ; FROM 15
001DC4  2  E5 72                SBC     K+LO            ; TO GET THE SHIFT LOOP
001DC6  2  AA                   TAX                     ; INDEX
001DC7  2  F0 07                BEQ     FLS2            ; EXIT NOW IF NO SHIFT NEEDED
001DC9  2               
001DC9  2               FLSL:
001DC9  2  06 70                ASL     J+LO            ; SHIFT THE BIT
001DCB  2  26 71                ROL     J+HI            ; INTO POSITION
001DCD  2  CA                   DEX
001DCE  2  D0 F9                BNE     FLSL
001DD0  2               
001DD0  2               FLS2:
001DD0  2  A0 00                LDY     #0              ; MOVE THE FLAG WORD
001DD2  2  B1 6E                LDA     (I),Y           ; INTO [J]
001DD4  2  85 73                STA     K+HI            ; FIRST THE MSB
001DD6  2  C8                   INY
001DD7  2  B1 6E                LDA     (I),Y
001DD9  2  85 72                STA     K+LO            ; THEN THE LSB
001DDB  2  60                   RTS
001DDC  2               
001DDC  1               
001DDC  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT I/O"
001DDC  1                       .INCLUDE "io.asm"
001DDC  2               ;        PAGE
001DDC  2               ;        SBTTL   "--- GAME I/O: DOS/65 ---"
001DDC  2               
001DDC  2               ; --------------
001DDC  2               ; INTERNAL ERROR
001DDC  2               ; --------------
001DDC  2               
001DDC  2               ; ENTRY: ERROR CODE IN [A]
001DDC  2               
001DDC  2               ERRM:
001DDC  2  49 6E 74 65          .BYTE   "Internal error "
001DE0  2  72 6E 61 6C  
001DE4  2  20 65 72 72  
001DEB  2               ENUMB:
001DEB  2  30 30 2E             .BYTE   "00."
001DEE  2               ERRML           = *-ERRM
001DEE  2               
001DEE  2               ZERROR:
001DEE  2  A0 01                LDY     #1              ; CONVERT ERROR BYTE IN [A]
001DF0  2               ECON:
001DF0  2  20 E2 26             JSR     DIV10           ; TO ASCII DECIMAL IN [ENUMB]
001DF3  2  09 30                ORA     #'0'
001DF5  2  99 EB 1D             STA     ENUMB,Y
001DF8  2  8A                   TXA
001DF9  2  88                   DEY
001DFA  2  10 F4                BPL     ECON
001DFC  2               
001DFC  2  20 0D 1F             JSR     ZCRLF           ; CLEAR BUFFER
001DFF  2  A9 00                LDA     #0
001E01  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001E03  2               
001E03  2  A2 DC                LDX     #<ERRM
001E05  2  A9 1D                LDA     #>ERRM
001E07  2  A0 12                LDY     #ERRML
001E09  2  20 7C 21             JSR     DLINE
001E0C  2               
001E0C  2               ; FALL THROUGH ...
001E0C  2               
001E0C  2               ; ----
001E0C  2               ; QUIT
001E0C  2               ; ----
001E0C  2               
001E0C  2               ZQUIT:
001E0C  2  20 0D 1F             JSR     ZCRLF           ; FLUSH BUFFER
001E0F  2               
001E0F  2  A2 1D                LDX     #<TOQ
001E11  2  A9 1E                LDA     #>TOQ
001E13  2  A0 10                LDY     #TOQL
001E15  2  20 7C 21             JSR     DLINE           ; "END OF STORY"
001E18  2  A2 00                LDX     #0
001E1A  2  4C 03 01             JMP     PEM
001E1D  2               
001E1D  2               TOQ:
001E1D  2  45 6E 64 20          .BYTE   "End of session."
001E21  2  6F 66 20 73  
001E25  2  65 73 73 69  
001E2C  2  0D                   .BYTE   EOL
001E2D  2               TOQL            = *-TOQ
001E2D  2               
001E2D  2               ; -------
001E2D  2               ; RESTART
001E2D  2               ; -------
001E2D  2               
001E2D  2               ZSTART:
001E2D  2  20 0D 1F             JSR     ZCRLF
001E30  2               
001E30  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; SAVE SCRIPT STATE
001E33  2  29 01                AND     #%00000001      ; FOR LATER
001E35  2  8D 91 21             STA     SFLAG           ; (BM 5/14/85)
001E38  2               
001E38  2  4C 5B 0E             JMP     WARM1           ; AND DO A WARMSTART
001E3B  2               
001E3B  2               ; --------------------
001E3B  2               ; PRINT VERSION NUMBER
001E3B  2               ; --------------------
001E3B  2               
001E3B  2               VERS:
001E3B  2  44 4F 53 2F          .BYTE   "DOS/65 Version F"
001E3F  2  36 35 20 56  
001E43  2  65 72 73 69  
001E4B  2  0D                   .BYTE   EOL
001E4C  2               VERSL           = *-VERS
001E4C  2               
001E4C  2               VERNUM:
001E4C  2  20 0D 1F             JSR     ZCRLF
001E4F  2               
001E4F  2  A2 3B                LDX     #<VERS
001E51  2  A9 1E                LDA     #>VERS
001E53  2  A0 11                LDY     #VERSL
001E55  2  4C 7C 21             JMP     DLINE
001E58  2               
001E58  2               ; --------------------------
001E58  2               ; RETURN TOP RAM PAGE IN [A]
001E58  2               ; --------------------------
001E58  2               
001E58  2               MEMTOP:
001E58  2  A9 CF                LDA     #$CF            ; IT'S A GIVEN
001E5A  2  60                   RTS
001E5B  2               
001E5B  2               ; --------------------------------
001E5B  2               ; RETURN RANDOM BYTES IN [A] & [X]
001E5B  2               ; --------------------------------
001E5B  2               RANDOM:
001E5B  2  18                   CLC
001E5C  2  A9 41                LDA     #$41
001E5E  2  6D C5 1E             ADC     state+0
001E61  2  8D C5 1E             STA     state+0
001E64  2  6D C6 1E             ADC     state+1
001E67  2  8D C6 1E             STA     state+1
001E6A  2  6D C7 1E             ADC     state+2
001E6D  2  8D C7 1E             STA     state+2
001E70  2  6D C8 1E             ADC     state+3
001E73  2  8D C8 1E             STA     state+3
001E76  2  6D C9 1E             ADC     state+4
001E79  2  0A                   ASL
001E7A  2  6D C8 1E             ADC     state+3
001E7D  2  8D C9 1E             STA     state+4
001E80  2  4D C7 1E             EOR     state+2
001E83  2  AA                   TAX
001E84  2  18                   CLC
001E85  2  A9 41                LDA     #$41
001E87  2  6D CA 1E             ADC     state1+0
001E8A  2  8D CA 1E             STA     state1+0
001E8D  2  6D CB 1E             ADC     state1+1
001E90  2  8D CB 1E             STA     state1+1
001E93  2  6D CC 1E             ADC     state1+2
001E96  2  8D CC 1E             STA     state1+2
001E99  2  6D CD 1E             ADC     state1+3
001E9C  2  8D CD 1E             STA     state1+3
001E9F  2  6D CE 1E             ADC     state1+4
001EA2  2  0A                   ASL
001EA3  2  6D CD 1E             ADC     state1+3
001EA6  2  8D CE 1E             STA     state1+4
001EA9  2  4D CC 1E             EOR     state1+2
001EAC  2               
001EAC  2  8D CA 1E             STA     state1
001EAF  2  EE C5 1E             INC     state
001EB2  2  EE CB 1E             INC     state1+1
001EB5  2  8E C6 1E             STX     state+1
001EB8  2  EE CC 1E             INC     state1+2
001EBB  2  EE CD 1E             INC     state1+3
001EBE  2  EE C8 1E             INC     state+3
001EC1  2  EE C9 1E             INC     state+4
001EC4  2  60                   RTS
001EC5  2               ; RANDOM SEEDS
001EC5  2               state:
001EC5  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001EC9  2  00           
001ECA  2               state1:
001ECA  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001ECE  2  00           
001ECF  2               
001ECF  2               
001ECF  2               
001ECF  2               ; -------------------
001ECF  2               ; Z-PRINT A CHARACTER
001ECF  2               ; -------------------
001ECF  2               
001ECF  2               ; ENTRY: ASCII CHAR IN [A]
001ECF  2               
001ECF  2               COUT:
001ECF  2  C9 0D                CMP     #EOL            ; IF EOL,
001ED1  2  F0 3A                BEQ     ZCRLF           ; DO IT!
001ED3  2  C9 20                CMP     #SPACE          ; IGNORE ALL OTHER
001ED5  2  90 0B                BCC     CEX             ; CONTROLS
001ED7  2               
001ED7  2  A6 BD                LDX     LENGTH          ; ELSE GET LINE POINTER
001ED9  2  9D 40 07             STA     LBUFF,X         ; ADD CHAR TO BUFFER
001EDC  2  E0 4F                CPX     #XSIZE          ; END OF LINE?
001EDE  2  B0 03                BCS     FLUSH           ; YES, FLUSH THE LINE
001EE0  2  E6 BD                INC     LENGTH          ; ELSE UPDATE POINTER
001EE2  2               
001EE2  2               CEX:
001EE2  2  60                   RTS
001EE3  2               
001EE3  2               ; -------------------
001EE3  2               ; FLUSH OUTPUT BUFFER
001EE3  2               ; -------------------
001EE3  2               
001EE3  2               ; ENTRY: LENGTH OF BUFFER IN [X]
001EE3  2               
001EE3  2               FLUSH:
001EE3  2  A9 20                LDA     #SPACE
001EE5  2               
001EE5  2               FL0:
001EE5  2  DD 40 07             CMP     LBUFF,X         ; FIND LAST SPACE CHAR
001EE8  2  F0 05                BEQ     FL1             ; IN THE LINE
001EEA  2  CA                   DEX
001EEB  2  D0 F8                BNE     FL0             ; IF NONE FOUND,
001EED  2  A2 4F                LDX     #XSIZE          ; FLUSH ENTIRE LINE
001EEF  2               
001EEF  2               FL1:
001EEF  2  86 BE                STX     OLDLEN          ; SAVE OLD LINE POS HERE
001EF1  2  86 BD                STX     LENGTH          ; MAKE IT THE NEW LINE LENGTH
001EF3  2               
001EF3  2  20 0D 1F             JSR     ZCRLF           ; PRINT LINE UP TO LAST SPACE
001EF6  2               
001EF6  2               ; START NEW LINE WITH REMAINDER OF OLD
001EF6  2               
001EF6  2  A6 BE                LDX     OLDLEN          ; GET OLD LINE POS
001EF8  2  A0 00                LDY     #0              ; START NEW LINE AT BEGINNING
001EFA  2               FL2:
001EFA  2  E8                   INX
001EFB  2  E0 4F                CPX     #XSIZE          ; CONTINUE IF
001EFD  2  90 05                BCC     FL3             ; INSIDE OR
001EFF  2  F0 03                BEQ     FL3             ; AT END OF LINE
001F01  2  84 BD                STY     LENGTH          ; ELSE SET NEW LINE LENGTH
001F03  2  60                   RTS
001F04  2               
001F04  2               FL3:
001F04  2  BD 40 07             LDA     LBUFF,X         ; GET CHAR FROM OLD LINE
001F07  2  99 40 07             STA     LBUFF,Y         ; MOVE TO START OF NEW LINE
001F0A  2  C8                   INY                     ; UPDATE LENGTH OF NEW LINE
001F0B  2  D0 ED                BNE     FL2
001F0D  2               
001F0D  2               ; ---------------
001F0D  2               ; CARRIAGE RETURN
001F0D  2               ; ---------------
001F0D  2               
001F0D  2               ZCRLF:
001F0D  2  E6 C2                INC     LINCNT          ; NEW LINE GOING OUT
001F0F  2  A5 C2                LDA     LINCNT          ; IS IT TIME TO
001F11  2  C5 C3                CMP     LMAX            ; PRINT "MORE" YET?
001F13  2  90 22                BCC     CR1             ; NO, CONTINUE
001F15  2               
001F15  2               ; SCREEN FULL; PRINT "MORE"
001F15  2               
001F15  2  20 7F 1F             JSR     ZUSL            ; UPDATE STATUS LINE
001F18  2               
001F18  2  A9 00                LDA     #0
001F1A  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
001F1C  2  20 30 22             JSR     BOLD
001F1F  2  A2 5A                LDX     #<MORE
001F21  2  A9 1F                LDA     #>MORE
001F23  2  A0 06                LDY     #MOREL
001F25  2  20 7C 21             JSR     DLINE           ; PRINT "MORE" DIRECTLY
001F28  2  20 3E 22             JSR     UNBOLD
001F2B  2               ZCR0:
001F2B  2  20 C5 20             JSR     GETKEY          ; GET KEYPRESS
001F2E  2  A2 60                LDX     #<MCLR
001F30  2  A9 1F                LDA     #>MCLR
001F32  2  A0 12                LDY     #MCLRL
001F34  2  20 7C 21             JSR     DLINE           ; RUB OUT "MORE"
001F37  2               
001F37  2               CR1:
001F37  2  A6 BD                LDX     LENGTH
001F39  2  A9 0D                LDA     #EOL            ; INSTALL EOL AT
001F3B  2  9D 40 07             STA     LBUFF,X         ; END OF CURRENT LINE
001F3E  2  E6 BD                INC     LENGTH          ; UPDATE LINE LENGTH
001F40  2               
001F40  2               LINOUT:
001F40  2  A4 BD                LDY     LENGTH          ; IF BUFFER EMPTY,
001F42  2  F0 11                BEQ     LINEX           ; DON'T PRINT ANYTHING
001F44  2               
001F44  2  84 CC                STY     PRLEN           ; SAVE LENGTH HERE FOR "PPRINT"
001F46  2  A2 00                LDX     #0              ; SEND CONTENTS OF [LBUFF]
001F48  2               LOUT:
001F48  2  BD 40 07             LDA     LBUFF,X         ; TO SCREEN
001F4B  2  20 03 21             JSR     CHAR
001F4E  2  E8                   INX
001F4F  2  88                   DEY
001F50  2  D0 F6                BNE     LOUT
001F52  2               
001F52  2  20 92 21             JSR     PPRINT          ; PRINT [LBUFF] IF ENABLED
001F55  2               
001F55  2               LINEX:
001F55  2  A9 00                LDA     #0              ; RESET LINE LENGTH
001F57  2  85 BD                STA     LENGTH          ; TO ZERO
001F59  2  60                   RTS                     ; AND RETURN
001F5A  2               
001F5A  2               MORE:
001F5A  2  5B 4D 4F 52          .BYTE   "[MORE]"
001F5E  2  45 5D        
001F60  2               MOREL           = *-MORE
001F60  2               
001F60  2               MCLR:
001F60  2  08 08 08 08          .BYTE   08,08,08,08,08,08,"      ",08,08,08,08,08,08
001F64  2  08 08 20 20  
001F68  2  20 20 20 20  
001F72  2               MCLRL           = *-MCLR
001F72  2               
001F72  2               ; ----------------------
001F72  2               ; UPDATE THE STATUS LINE
001F72  2               ; ----------------------
001F72  2               
001F72  2               SCORE:
001F72  2  53 63 6F 72          .BYTE   "Score: "
001F76  2  65 3A 20     
001F79  2               SCOREL          = *-SCORE
001F79  2               
001F79  2               CLOCK:
001F79  2  54 69 6D 65          .BYTE   "Time: "
001F7D  2  3A 20        
001F7F  2               CLOCKL          = *-CLOCK
001F7F  2               
001F7F  2               
001F7F  2               ZUSL:
001F7F  2  A5 BD                LDA     LENGTH          ; SAVE ALL
001F81  2  48                   PHA                     ; STRING-PRINTING
001F82  2  A5 7E                LDA     MPCH            ; VARIABLES
001F84  2  48                   PHA
001F85  2  A5 7D                LDA     MPCM
001F87  2  48                   PHA
001F88  2  A5 7C                LDA     MPCL
001F8A  2  48                   PHA
001F8B  2  A5 AA                LDA     TSET
001F8D  2  48                   PHA
001F8E  2  A5 A9                LDA     PSET
001F90  2  48                   PHA
001F91  2  A5 AF                LDA     ZWORD+HI
001F93  2  48                   PHA
001F94  2  A5 AE                LDA     ZWORD+LO
001F96  2  48                   PHA
001F97  2  A5 AD                LDA     ZFLAG
001F99  2  48                   PHA
001F9A  2  A5 BB                LDA     DIGITS
001F9C  2  48                   PHA
001F9D  2               
001F9D  2  A2 4F                LDX     #XSIZE
001F9F  2               USL0:
001F9F  2  BD 40 07             LDA     LBUFF,X         ; MOVE CONTENTS OF [LBUFF]
001FA2  2  9D 20 0D             STA     BUFSAV,X        ; TO [BUFSAV]
001FA5  2  A9 20                LDA     #SPACE          ; CLEAR
001FA7  2  9D 40 07             STA     LBUFF,X         ; [LBUFF] WITH SPACES
001FAA  2  CA                   DEX
001FAB  2  10 F2                BPL     USL0
001FAD  2               
001FAD  2  A9 00                LDA     #0
001FAF  2  85 BD                STA     LENGTH          ; RESET LINE LENGTH
001FB1  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001FB3  2  20 4C 22             JSR     REVERSE
001FB6  2  A2 00                LDX     #0
001FB8  2  A0 00                LDY     #0
001FBA  2  20 CD 21             JSR     PLOT
001FBD  2               ;
001FBD  2               ; PRINT ROOM DESCRIPTION
001FBD  2               ;
001FBD  2  A9 10                LDA     #16             ; GLOBAL VAR #16 (ROOM ID)
001FBF  2  20 A5 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001FC2  2  A5 6C                LDA     VALUE+LO
001FC4  2  20 9F 13             JSR     PRNTDC          ; PRINT SHORT ROOM DESCRIPTION
001FC7  2               
001FC7  2  A9 18                LDA     #24             ; MOVE LINE INDEX UP
001FC9  2  85 BD                STA     LENGTH          ; TO TIME/SCORE POSITION
001FCB  2               
001FCB  2  A9 11                LDA     #17             ; GLOBAL VAR #17 (SCORE/HOURS)
001FCD  2  20 A5 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001FD0  2               
001FD0  2  A5 BC                LDA     TIMEFL          ; GET MODE FLAG
001FD2  2  D0 32                BNE     DOTIME          ; USE TIME MODE IF NON-ZERO
001FD4  2               ;
001FD4  2               ; PRINT "SCORE"
001FD4  2               ;
001FD4  2  A9 53                LDA     #'S'
001FD6  2  20 CF 1E             JSR     COUT
001FD9  2  A9 63                LDA     #'c'
001FDB  2  20 CF 1E             JSR     COUT
001FDE  2  A9 6F                LDA     #'o'
001FE0  2  20 CF 1E             JSR     COUT
001FE3  2  A9 72                LDA     #'r'
001FE5  2  20 CF 1E             JSR     COUT
001FE8  2  A9 65                LDA     #'e'
001FEA  2  20 CF 1E             JSR     COUT
001FED  2  A9 3A                LDA     #':'
001FEF  2  20 CF 1E             JSR     COUT
001FF2  2  A9 20                LDA     #SPACE
001FF4  2  20 CF 1E             JSR     COUT
001FF7  2               
001FF7  2  A5 6C                LDA     VALUE+LO        ; MOVE SCORE VALUE
001FF9  2  85 B3                STA     QUOT+LO         ; INTO [QUOT]
001FFB  2  A5 6D                LDA     VALUE+HI        ; FOR PRINTING
001FFD  2  85 B4                STA     QUOT+HI
001FFF  2  20 FB 17             JSR     NUMBER          ; PRINT SCORE VALUE IN DECIMAL
002002  2               ;
002002  2  A9 2F                LDA     #'/'            ; PRINT A SLASH
002004  2  D0 35                BNE     MOVMIN          ; BRANCH ALWAYS
002006  2               
002006  2               ; PRINT "TIME"
002006  2               
002006  2               DOTIME:
002006  2  A9 54                LDA     #'T'
002008  2  20 CF 1E             JSR     COUT
00200B  2  A9 69                LDA     #'i'
00200D  2  20 CF 1E             JSR     COUT
002010  2  A9 6D                LDA     #'m'
002012  2  20 CF 1E             JSR     COUT
002015  2  A9 65                LDA     #'e'
002017  2  20 CF 1E             JSR     COUT
00201A  2  A9 3A                LDA     #':'
00201C  2  20 CF 1E             JSR     COUT
00201F  2  A9 20                LDA     #SPACE
002021  2  20 CF 1E             JSR     COUT
002024  2               ;
002024  2  A5 6C                LDA     VALUE+LO        ; 00 IS REALLY 24
002026  2  D0 02                BNE     DT0
002028  2  A9 18                LDA     #24
00202A  2               DT0:
00202A  2  C9 0D                CMP     #13             ; IS HOURS > 12,
00202C  2  90 02                BCC     DT1
00202E  2  E9 0C                SBC     #12             ; CONVERT TO 1-12
002030  2               DT1:
002030  2  85 B3                STA     QUOT+LO         ; MOVE FOR PRINTING
002032  2  A9 00                LDA     #0
002034  2  85 B4                STA     QUOT+HI         ; CLEAR MSB
002036  2  20 FB 17             JSR     NUMBER
002039  2               
002039  2  A9 3A                LDA     #':'            ; COLON
00203B  2               MOVMIN:
00203B  2  20 CF 1E             JSR     COUT            ; PRINT SLASH OR COLON
00203E  2               
00203E  2  A9 12                LDA     #18             ; GLOBAL VAR #18 (MOVES/MINUTES)
002040  2  20 A5 10             JSR     GETVRG          ; GET IT INTO [VALUE]
002043  2  A5 6C                LDA     VALUE+LO        ; MOVE TO [QUOT]
002045  2  85 B3                STA     QUOT+LO         ; FOR EVENTUAL PRINTING
002047  2  A5 6D                LDA     VALUE+HI
002049  2  85 B4                STA     QUOT+HI
00204B  2               
00204B  2  A5 BC                LDA     TIMEFL          ; WHICH MODE?
00204D  2  D0 06                BNE     DOMINS          ; TIME IF NZ
00204F  2               ;
00204F  2               ; PRINT NUMBER OF MOVES
00204F  2               ;
00204F  2  20 FB 17             JSR     NUMBER          ; SHOW # MOVES
002052  2  4C 81 20             JMP     STATEX          ; ALL DONE
002055  2               ;
002055  2               ; PRINT MINUTES
002055  2               ;
002055  2               DOMINS:
002055  2  A5 6C                LDA     VALUE+LO        ; CHECK MINUTES
002057  2  C9 0A                CMP     #10             ; IF MORE THAN TEN
002059  2  B0 05                BCS     DOM0            ; CONTINUE
00205B  2               
00205B  2  A9 30                LDA     #'0'            ; ELSE PRINT A
00205D  2  20 CF 1E             JSR     COUT            ; PADDING "0" FIRST
002060  2               
002060  2               DOM0:
002060  2  20 FB 17             JSR     NUMBER          ; SHOW MINUTES
002063  2               
002063  2  A9 20                LDA     #SPACE
002065  2  20 CF 1E             JSR     COUT            ; SEPARATE THINGS
002068  2               ;
002068  2  A9 11                LDA     #17             ; CHECK "HOURS" AGAIN
00206A  2  20 A5 10             JSR     GETVRG
00206D  2  A5 6C                LDA     VALUE+LO
00206F  2  C9 0C                CMP     #12             ; PAST NOON?
002071  2  B0 04                BCS     DOPM            ; YES, PRINT "PM"
002073  2               
002073  2  A9 41                LDA     #'A'            ; ELSE PRINT "AM"
002075  2  D0 02                BNE     DOXM            ; BRANCH ALWAYS
002077  2               
002077  2               DOPM:
002077  2  A9 50                LDA     #'P'
002079  2               
002079  2               DOXM:
002079  2  20 CF 1E             JSR     COUT
00207C  2  A9 4D                LDA     #'M'
00207E  2  20 CF 1E             JSR     COUT
002081  2               ;
002081  2               ; STATUS LINE READY
002081  2               ;
002081  2               STATEX:
002081  2  A9 4F                LDA     #XSIZE          ; PRINT THE ENTIRE
002083  2  85 BD                STA     LENGTH          ; STATUS LINE
002085  2  20 37 1F             JSR     CR1
002088  2               
002088  2  A2 4F                LDX     #XSIZE          ; RESTORE OLD [LBUFF]
00208A  2               USLX:
00208A  2  BD 20 0D             LDA     BUFSAV,X
00208D  2  9D 40 07             STA     LBUFF,X
002090  2  CA                   DEX
002091  2  10 F7                BPL     USLX
002093  2               
002093  2  68                   PLA                     ; RESTORE ALL
002094  2  85 BB                STA     DIGITS          ; SAVED VARIABLES
002096  2  68                   PLA
002097  2  85 AD                STA     ZFLAG
002099  2  68                   PLA
00209A  2  85 AE                STA     ZWORD+LO
00209C  2  68                   PLA
00209D  2  85 AF                STA     ZWORD+HI
00209F  2  68                   PLA
0020A0  2  85 A9                STA     PSET
0020A2  2  68                   PLA
0020A3  2  85 AA                STA     TSET
0020A5  2  68                   PLA
0020A6  2  85 7C                STA     MPCL
0020A8  2  68                   PLA
0020A9  2  85 7D                STA     MPCM
0020AB  2  68                   PLA
0020AC  2  85 7E                STA     MPCH
0020AE  2  68                   PLA
0020AF  2  85 BD                STA     LENGTH
0020B1  2               
0020B1  2  A2 00                LDX     #0              ; RESTORE CURSOR
0020B3  2  A0 18                LDY     #YSIZE
0020B5  2  18                   CLC
0020B6  2  20 CD 21             JSR     PLOT
0020B9  2               ;
0020B9  2  A2 FF                LDX     #$FF
0020BB  2  86 BF                STX     SCRIPT          ; RE-ENABLE SCRIPTING
0020BD  2  E8                   INX                     ; = 0
0020BE  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
0020C0  2  E8                   INX                     ; = 1
0020C1  2  20 3E 22             JSR     UNBOLD
0020C4  2  60                   RTS
0020C5  2               
0020C5  1                       .INCLUDE "machine.asm"
0020C5  2               ;        PAGE
0020C5  2               ;        SBTTL   "--- MACHINE-DEPENDENT I/O: DOS/65 ---"
0020C5  2               
0020C5  2               ; ----------------------------
0020C5  2               ; FETCH ASCII KEYCODE INTO [A]
0020C5  2               ; ----------------------------
0020C5  2               
0020C5  2               ; EXIT: ASCII IN [A] & [IOCHAR]
0020C5  2               
0020C5  2               GETKEY:
0020C5  2  8A                   TXA                     ; SAVE [X] & [Y]
0020C6  2  48                   PHA
0020C7  2  98                   TYA
0020C8  2  48                   PHA
0020C9  2               GKEY1:
0020C9  2  A2 06                LDX     #6              ;  GET KEY INTO [A]
0020CB  2  20 03 01             JSR     PEM             ;
0020CE  2  C9 00                CMP     #$00
0020D0  2  F0 F7                BEQ     GKEY1           ; NOT IF CODE WAS ZERO
0020D2  2               
0020D2  2  C9 0D                CMP     #EOL            ; EOL?
0020D4  2  F0 24                BEQ     GOODKEY
0020D6  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
0020D8  2  F0 20                BEQ     GOODKEY
0020DA  2  C9 20                CMP     #SPACE          ; ANYTHING ELSE < "SPACE"
0020DC  2  90 16                BCC     BADKEY          ; IS BAD
0020DE  2               
0020DE  2  C9 7B                CMP     #'z'+1
0020E0  2  B0 12                BCS     BADKEY
0020E2  2  C9 61                CMP     #'a'
0020E4  2  B0 14                BCS     GOODKEY
0020E6  2               
0020E6  2  C9 41                CMP     #'A'            ; TO ASCII LOWER CASE
0020E8  2  90 10                BCC     GOODKEY
0020EA  2  C9 5B                CMP     #'Z'+1
0020EC  2  B0 06                BCS     BADKEY
0020EE  2  18                   CLC
0020EF  2  69 20                ADC     #$20
0020F1  2  4C FA 20             JMP     GOODKEY
0020F4  2               
0020F4  2               BADKEY:
0020F4  2  20 C5 21             JSR     BOOP            ; REJECT BAD KEYPRESS
0020F7  2  4C C9 20             JMP     GKEY1           ; AND TRY AGAIN
0020FA  2               
0020FA  2               GOODKEY:
0020FA  2  85 C4                STA     IOCHAR          ; SAVE KEYCODE HERE
0020FC  2  68                   PLA                     ; RESTORE [X] & [Y]
0020FD  2  A8                   TAY
0020FE  2  68                   PLA
0020FF  2  AA                   TAX
002100  2  A5 C4                LDA     IOCHAR          ; GET KEYCODE HERE
002102  2               
002102  2  60                   RTS
002103  2               
002103  2               ; -------------------------
002103  2               ; OUTPUT AN ASCII CHARACTER
002103  2               ; -------------------------
002103  2               CHAR:
002103  2               LETTER:
002103  2  85 C4                STA     IOCHAR          ; SAVE HERE
002105  2  48                   PHA                     ; SAVE [A]
002106  2  8A                   TXA                     ; SAVE [X] & [Y]
002107  2  48                   PHA
002108  2  98                   TYA
002109  2  48                   PHA
00210A  2  A5 C4                LDA     IOCHAR
00210C  2  C9 0D                CMP     #13
00210E  2  D0 0B                BNE     :+
002110  2  E6 C2                INC     LINCNT
002112  2  A9 0A                LDA     #10             ;  IS A CR, SO ADD A LF
002114  2  A2 02                LDX     #2              ;
002116  2  20 03 01             JSR     PEM             ;
002119  2  A9 0D                LDA     #13
00211B  2               :
00211B  2  A2 02                LDX     #2              ;  OUTPUT CHAR FROM [A]
00211D  2  20 03 01             JSR     PEM             ;
002120  2               
002120  2  68                   PLA                     ; RESTORE [X] & [Y]
002121  2  A8                   TAY
002122  2  68                   PLA
002123  2  AA                   TAX
002124  2  68                   PLA
002125  2  60                   RTS
002126  2               
002126  2               
002126  2               
002126  2               ; ---------------------
002126  2               ; FETCH A LINE OF INPUT
002126  2               ; ---------------------
002126  2               
002126  2               ; ENTRY: ABS ADDR OF READ BUFFER IN [ARG1]
002126  2               ; EXIT: # CHARS READ IN [A]
002126  2               
002126  2               INPUT:
002126  2  20 40 1F             JSR     LINOUT          ; FLUSH [LBUFF]
002129  2               
002129  2  20 3D 23             JSR     CURSON          ; ACTIVATE CURSOR, CLEAR KEY QUEUE
00212C  2               
00212C  2  A0 00                LDY     #0
00212E  2  84 C2                STY     LINCNT          ; RESET LINE COUNT
002130  2               
002130  2               INLOOP:
002130  2  20 C5 20             JSR     GETKEY          ; GET ASCII INTO [A] AND [IOCHAR]
002133  2               
002133  2  C9 0D                CMP     #EOL            ; EOL?
002135  2  F0 2A                BEQ     ENDLIN          ; LINE DONE IF SO
002137  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
002139  2  F0 1C                BEQ     BACKUP          ; SPECIAL HANDLING
00213B  2               
00213B  2  99 40 07             STA     LBUFF,Y         ; ELSE ADD CHAR TO INPUT BUFFER
00213E  2  C8                   INY                     ; NEXT POSITION IN LINE
00213F  2               
00213F  2               SHOWIT:
00213F  2  20 03 21             JSR     CHAR            ; SEND TO SCREEN
002142  2               
002142  2  C0 4D                CPY     #77             ; 2 SCREEN LINES FULL?
002144  2  90 EA                BCC     INLOOP          ; NO, GET ANOTHER CHAR
002146  2               
002146  2               ; HANDLE LINE OVERFLOW
002146  2               
002146  2               NOMORE:
002146  2  20 C5 20             JSR     GETKEY
002149  2  C9 0D                CMP     #EOL            ; IF EOL,
00214B  2  F0 14                BEQ     ENDLIN          ; WRAP UP THE LINE
00214D  2  C9 08                CMP     #BACKSP         ; BACKSPACE
00214F  2  F0 06                BEQ     BACKUP          ; IS OKAY TOO
002151  2  20 C5 21             JSR     BOOP            ; ELSE COMPLAIN
002154  2  4C 46 21             JMP     NOMORE          ; AND INSIST
002157  2               
002157  2               ; HANDLE BACKSPACE
002157  2               
002157  2               BACKUP:
002157  2  88                   DEY                     ; BACK UP THE POINTER
002158  2  10 E5                BPL     SHOWIT          ; SEND BS IF NOT START OF LINE
00215A  2  20 C5 21             JSR     BOOP            ; ELSE SCREAM WITH PAIN
00215D  2  A0 00                LDY     #0              ; RESET POINTER
00215F  2  F0 CF                BEQ     INLOOP          ; AND WAIT FOR SOMETHING BETTER
002161  2               
002161  2               ; HANDLE END OF LINE
002161  2               
002161  2               ENDLIN:
002161  2  99 40 07             STA     LBUFF,Y         ; SHIP EOL TO BUFFER
002164  2  C8                   INY                     ; UPDATE INDEX
002165  2  84 A2                STY     LINLEN          ; SAVE HERE FOR "READ"
002167  2  84 CC                STY     PRLEN           ; AND HERE FOR "PPRINT"
002169  2  A2 00                LDX     #0
00216B  2  20 03 21             JSR     CHAR            ; AND SEND EOL TO SCREEN
00216E  2               
00216E  2               ; MOVE [LBUFF] TO [ARG1] W/LC CONVERSION
00216E  2               
00216E  2               LEX1:
00216E  2  B9 3F 07             LDA     LBUFF-1,Y       ; GET A CHAR FROM [LBUFF]
002171  2  91 62                STA     (ARG1),Y        ; MOVE CHAR TO INPUT BUFFER AT [ARG1]
002173  2  88                   DEY                     ; LOOP TILL
002174  2  D0 F8                BNE     LEX1            ; ALL CHARS MOVED ("BNE" 8/14/85 BM)
002176  2               
002176  2  20 92 21             JSR     PPRINT          ; SCRIPT [LBUFF] IF ENABLED
002179  2               
002179  2  A5 A2                LDA     LINLEN          ; RESTORE # CHARS
00217B  2  60                   RTS                     ; INTO [A]
00217C  2               
00217C  2               ; -----------------------
00217C  2               ; DIRECT PRINT LINE [X/A]
00217C  2               ; -----------------------
00217C  2               
00217C  2               ; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
00217C  2               ;        STRING LENGTH IN [Y]
00217C  2               
00217C  2               DLINE:
00217C  2  8E 85 21             STX     STRING+LO       ; DROP STRING ADDRESS
00217F  2  8D 86 21             STA     STRING+HI       ; INTO DUMMY BYTES
002182  2               
002182  2  A2 00                LDX     #0              ; INIT CHAR-FETCH INDEX
002184  2               
002184  2               DOUT:
002184  2  BD                   .BYTE   $BD             ; 6502 "LDA nnnn,X" OPCODE
002185  2               STRING:
002185  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
002187  2  20 03 21             JSR     CHAR
00218A  2  E8                   INX
00218B  2  88                   DEY                     ; LOOP TILL
00218C  2  C0 00                CPY     #$00
00218E  2  D0 F4                BNE     DOUT            ; NOT OUT OF CHARS
002190  2  60                   RTS
002191  2               
002191  2               ; -----------------------
002191  2               ; SEND [LBUFF] TO PRINTER
002191  2               ; -----------------------
002191  2               
002191  2               ; ENTRY: LENTH OF LINE IN [PRLEN]
002191  2               ; NOW WITH IMPROVED ERROR PROTECTION! (BM 11/24/84)
002191  2               
002191  2               SFLAG:
002191  2  00                   .BYTE   0               ; PREVIOUS SCRIPT MODE (BM 5/14/85)
002192  2               
002192  2               PPRINT:
002192  2  A5 BF                LDA     SCRIPT          ; SCRIPTING INTERNALLY ENABLED?
002194  2  F0 2C                BEQ     PEX             ; NO, SCRAM IMMEDIATELY
002196  2               
002196  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; CHECK SCRIPT FLAG
002199  2  29 01                AND     #%00000001      ; SCRIPTING ON?
00219B  2  F0 1B                BEQ     PP3             ; NO, CHECK FOR "UNSCRIPT"
00219D  2               
00219D  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
00219F  2  30 21                BMI     PEX             ; CAN'T OPEN IF NEGATIVE
0021A1  2  D0 04                BNE     PP1             ; ALREADY OPEN, SCRIPT THE LINE
0021A3  2               
0021A3  2               ; OPEN THE PRINTER FOR OUTPUT
0021A3  2  A2 01                LDX     #1
0021A5  2  86 CB                STX     PSTAT           ; SET STATUS TO "PRINTER OPENED" (1)
0021A7  2               
0021A7  2               PP1:
0021A7  2  A0 00                LDY     #0              ; INIT INDEX
0021A9  2               PP2:
0021A9  2               
0021A9  2  B9 40 07             LDA     LBUFF,Y
0021AC  2  A2 05                LDX     #5              ;  OUTPUT CHAR FROM [A] TO PRINTER (LST)
0021AE  2  20 03 01             JSR     PEM             ;
0021B1  2  C8                   INY
0021B2  2  C6 CC                DEC     PRLEN
0021B4  2  D0 F3                BNE     PP2
0021B6  2  F0 0A                BEQ     PEX             ; RESET & RETURN
0021B8  2               
0021B8  2               ; CHECK FOR "UNSCRIPT"
0021B8  2               
0021B8  2               PP3:
0021B8  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
0021BA  2  F0 06                BEQ     PEX             ; EXIT IF PRINTER WAS OFF
0021BC  2  30 04                BMI     PEX             ; OR UNOPENABLE
0021BE  2               
0021BE  2               PCLOSE:
0021BE  2  A9 00                LDA     #0              ; RESET PRINTER STATUS FLAG
0021C0  2  85 CB                STA     PSTAT           ; TO "CLOSED"
0021C2  2               
0021C2  2               PEX:
0021C2  2  60                   RTS
0021C3  2               
0021C3  2               ; ------------
0021C3  2               ; SPLIT SCREEN
0021C3  2               ; ------------
0021C3  2               ; NO SPLIT SCREEN IN DOS/65
0021C3  2               ZSPLIT:
0021C3  2               OFFSPL:
0021C3  2  60                   RTS
0021C4  2               
0021C4  2               ; ------
0021C4  2               ; SCREEN
0021C4  2               ; ------
0021C4  2               
0021C4  2               ; GO TO TOP WINDOW IF [A] = 0
0021C4  2               ; GO TO BOTTOM IF [A] = 1
0021C4  2               ; IGNORE IF SPLIT NOT ENABLED OR [A] <> 0 OR 1
0021C4  2               ZSCRN:
0021C4  2               ; SET TO TOP WINDOW
0021C4  2               TOTOP:
0021C4  2               ; SET TO BOTTOM WINDOW
0021C4  2               TOBOT:
0021C4  2               DOSCRN:
0021C4  2  60                   RTS
0021C5  2               
0021C5  2               ; ---------
0021C5  2               ; RAZZ USER
0021C5  2               ; ---------
0021C5  2               
0021C5  2               BOOP:
0021C5  2  A9 07                LDA     #7
0021C7  2  A2 02                LDX     #2
0021C9  2  20 03 01             JSR     PEM
0021CC  2  60                   RTS
0021CD  2               
0021CD  2               
0021CD  2               PLOT:
0021CD  2               ; ENTRY: [X] = X COORD
0021CD  2               ;        [Y] = Y COORD
0021CD  2               ; Convert X coordinate to 2 ASCII digits in PLOTCOLVAL
0021CD  2  8A                   TXA                     ; Get X value
0021CE  2  A2 01                LDX     #1              ; Start with ones digit
0021D0  2               ; Divide by 10 repeatedly to get digits
0021D0  2               :
0021D0  2  C9 0A                CMP     #10
0021D2  2  90 06                BCC     :+              ; Branch if < 10
0021D4  2  E9 0A                SBC     #10
0021D6  2  E8                   INX                     ; Count number of 10s
0021D7  2  4C D0 21             JMP     :-
0021DA  2               :
0021DA  2  18                   CLC
0021DB  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
0021DD  2  8D 11 22             STA     PLOTCOLVAL+1    ; Store ones digit
0021E0  2               
0021E0  2  8A                   TXA                     ; Get tens digit count
0021E1  2  18                   CLC
0021E2  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021E4  2  8D 10 22             STA     PLOTCOLVAL      ; Store tens digit
0021E7  2               ; Convert Y coordinate to 2 ASCII digits in PLOTROWVAL
0021E7  2  98                   TYA                     ; Get Y value
0021E8  2  A2 01                LDX     #1              ; Start with ones digit
0021EA  2               ; Divide by 10 repeatedly to get digits
0021EA  2               :
0021EA  2  C9 0A                CMP     #10
0021EC  2  90 06                BCC     :+              ; Branch if < 10
0021EE  2  E9 0A                SBC     #10
0021F0  2  E8                   INX                     ; Count number of 10s
0021F1  2  4C EA 21             JMP     :-
0021F4  2               :
0021F4  2  18                   CLC
0021F5  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
0021F7  2  8D 0E 22             STA     PLOTROWVAL+1    ; Store ones digit
0021FA  2               
0021FA  2  8A                   TXA                     ; Get tens digit count
0021FB  2  18                   CLC
0021FC  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021FE  2  8D 0D 22             STA     PLOTROWVAL      ; Store tens digit
002201  2               ;
002201  2  A2 0B                LDX     #<PLOTSTRING
002203  2  A9 22                LDA     #>PLOTSTRING
002205  2  A0 08                LDY     #8
002207  2  20 7C 21             JSR     DLINE
00220A  2  60                   RTS
00220B  2               PLOTSTRING:
00220B  2  1B 5B                .BYTE   27,"["
00220D  2               PLOTROWVAL:
00220D  2  30 30                .BYTE   "00"
00220F  2  3B                   .BYTE   ";"
002210  2               PLOTCOLVAL:
002210  2  30 30                .BYTE   "00"
002212  2  48                   .BYTE   "H"
002213  2               
002213  2               ; ------------------------
002213  2               ; CLEAR SCREEN
002213  2               ; ------------------------
002213  2               
002213  2               CLS:
002213  2  A9 14                LDA     #20
002215  2  85 C3                STA     LMAX
002217  2  A2 2C                LDX     #<CLSSTRING
002219  2  A9 22                LDA     #>CLSSTRING
00221B  2  A0 04                LDY     #4
00221D  2  20 7C 21             JSR     DLINE
002220  2  A9 00                LDA     #0
002222  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
002224  2  A2 00                LDX     #0
002226  2  A0 18                LDY     #YSIZE
002228  2  20 CD 21             JSR     PLOT
00222B  2  60                   RTS
00222C  2               CLSSTRING:
00222C  2  1B 5B 32 4A          .BYTE   27,"[2J"
002230  2               
002230  2               BOLD:
002230  2  A2 3A                LDX     #<BOLDSTRING
002232  2  A9 22                LDA     #>BOLDSTRING
002234  2  A0 04                LDY     #4
002236  2  20 7C 21             JSR     DLINE
002239  2  60                   RTS
00223A  2               BOLDSTRING:
00223A  2  1B 5B 31 6D          .BYTE   27,"[1m"
00223E  2               
00223E  2               UNBOLD:
00223E  2  A2 48                LDX     #<UNBOLDSTRING
002240  2  A9 22                LDA     #>UNBOLDSTRING
002242  2  A0 04                LDY     #4
002244  2  20 7C 21             JSR     DLINE
002247  2  60                   RTS
002248  2               UNBOLDSTRING:
002248  2  1B 5B 30 6D          .BYTE   27,"[0m"
00224C  2               
00224C  2               REVERSE:
00224C  2  A2 56                LDX     #<REVERSESTRING
00224E  2  A9 22                LDA     #>REVERSESTRING
002250  2  A0 04                LDY     #4
002252  2  20 7C 21             JSR     DLINE
002255  2  60                   RTS
002256  2               REVERSESTRING:
002256  2  1B 5B 37 6D          .BYTE   27,"[7m"
00225A  2               
00225A  1                       .INCLUDE "zdos.asm"
00225A  2               ;        PAGE
00225A  2               ;        SBTTL   "--- Z-DOS: DOS/65 ---"
00225A  2               
00225A  2               ; ---------------------
00225A  2               ; GET Z-BLOCK FROM DISK
00225A  2               ; ---------------------
00225A  2               
00225A  2               ; ENTRY: Z-BLOCK # IN [BLOCK]
00225A  2               ;        TARGET PAGE IN [DBUFF+HI]
00225A  2               GETDSK:
00225A  2  D8                   CLD
00225B  2  18                   CLC
00225C  2               
00225C  2  A5 CD                LDA     DBLOCK+LO       ; Load low byte of DBLOCK
00225E  2  0A                   ASL     A               ; Multiply by 2
00225F  2  8D 71 25             STA     D65BLOCK+LO     ; Store low byte
002262  2  A5 CE                LDA     DBLOCK+HI       ; Load high byte of DBLOCK
002264  2  2A                   ROL     A               ; Rotate left (gets carry from previous ASL)
002265  2  8D 72 25             STA     D65BLOCK+HI     ; Store high byte
002268  2               
002268  2               ; read 256 byte block (zblock should be file block*2)
002268  2               ; EXTENT = INTEGER.PART.OF(n/128)
002268  2               ; 16 bit shift x6
002268  2  AD 71 25             LDA     D65BLOCK+LO     ; CALCULATE EXTENT
00226B  2  0A                   ASL     A
00226C  2  85 DE                STA     DTEMP+LO
00226E  2  AD 72 25             LDA     D65BLOCK+HI
002271  2  2A                   ROL     A
002272  2  8D 3B 25             STA     GAMEFCB+12      ; = EXTENT (MAGIC!)
002275  2               
002275  2  AD 71 25             LDA     D65BLOCK+LO     ; CALCULATE RECORD = n-(EXTENT*128)
002278  2  29 7F                AND     #$7F
00227A  2  8D 4F 25             STA     GAMEFCB+32      ; Store Record Number into FCB (Also Magic!)
00227D  2               
00227D  2  A9 2F                LDA     #<GAMEFCB       ; Open Extent
00227F  2  A0 25                LDY     #>GAMEFCB
002281  2  A2 0F                LDX     #15
002283  2  20 03 01             JSR     PEM
002286  2  C9 FF                CMP     #$FF
002288  2  F0 48                BEQ     GETDSKERR
00228A  2               
00228A  2  A9 00                LDA     #0              ; Set Buffer Address
00228C  2  A4 D0                LDY     DBUFF+HI
00228E  2  A2 1A                LDX     #26
002290  2  20 03 01             JSR     PEM
002293  2               
002293  2  A9 2F                LDA     #<GAMEFCB       ; Read First sector (128 bytes)
002295  2  A0 25                LDY     #>GAMEFCB
002297  2  A2 14                LDX     #20
002299  2  20 03 01             JSR     PEM
00229C  2  C9 FF                CMP     #$FF
00229E  2  F0 32                BEQ     GETDSKERR
0022A0  2               
0022A0  2  A9 80                LDA     #$80            ; Set Buffer Address
0022A2  2  A4 D0                LDY     DBUFF+HI
0022A4  2  A2 1A                LDX     #26
0022A6  2  20 03 01             JSR     PEM
0022A9  2               
0022A9  2  A9 2F                LDA     #<GAMEFCB       ; Read Second sector (128 bytes)
0022AB  2  A0 25                LDY     #>GAMEFCB
0022AD  2  A2 14                LDX     #20
0022AF  2  20 03 01             JSR     PEM
0022B2  2  C9 FF                CMP     #$FF
0022B4  2  F0 1C                BEQ     GETDSKERR
0022B6  2               
0022B6  2  A9 71                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
0022B8  2  A0 25                LDY     #>SPAREBYTES
0022BA  2  A2 1A                LDX     #26
0022BC  2  20 03 01             JSR     PEM
0022BF  2               
0022BF  2  A9 2F                LDA     #<GAMEFCB       ; Close Extent
0022C1  2  A0 25                LDY     #>GAMEFCB
0022C3  2  A2 10                LDX     #16
0022C5  2  20 03 01             JSR     PEM
0022C8  2               
0022C8  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
0022CA  2  E6 CD                INC     DBLOCK+LO       ; POINT TO NEXT
0022CC  2  D0 02                BNE     :+              ; Z-BLOCK
0022CE  2  E6 CE                INC     DBLOCK+HI
0022D0  2               :
0022D0  2  18                   CLC
0022D1  2  60                   RTS
0022D2  2               GETDSKERR:
0022D2  2  A9 0E                LDA     #14
0022D4  2  4C EE 1D             JMP     ZERROR
0022D7  2               
0022D7  2               
0022D7  2               ; ENTRY FOR "RESTORE" ([TRACK], [SECTOR] & [DRIVE] PRE-ASSIGNED)
0022D7  2               
0022D7  2               GETRES:
0022D7  2               
0022D7  2  A9 00                LDA     #0              ; Set Buffer Address
0022D9  2  A4 D0                LDY     DBUFF+HI
0022DB  2  A2 1A                LDX     #26
0022DD  2  20 03 01             JSR     PEM
0022E0  2               
0022E0  2  A9 50                LDA     #<SAVEFCB       ; READ Record
0022E2  2  A0 25                LDY     #>SAVEFCB
0022E4  2  A2 14                LDX     #20
0022E6  2  20 03 01             JSR     PEM
0022E9  2               
0022E9  2  A9 80                LDA     #$80            ; Set Buffer Address
0022EB  2  A4 D0                LDY     DBUFF+HI
0022ED  2  A2 1A                LDX     #26
0022EF  2  20 03 01             JSR     PEM
0022F2  2               
0022F2  2  A9 50                LDA     #<SAVEFCB       ; READ Record
0022F4  2  A0 25                LDY     #>SAVEFCB
0022F6  2  A2 14                LDX     #20
0022F8  2  20 03 01             JSR     PEM
0022FB  2               
0022FB  2  C9 FF                CMP     #$FF
0022FD  2  F0 2E                BEQ     WRTERR
0022FF  2  4C 2A 23             JMP     NXTSEC          ; POINT TO NEXT SECTOR & PAGE
002302  2               
002302  2               ; --------------------
002302  2               ; PUT [DBLOCK] TO DISK
002302  2               ; --------------------
002302  2               
002302  2               ;        PAGE TO WRITE IN [DBUFF]
002302  2               
002302  2               PUTDSK:
002302  2               
002302  2  A9 00                LDA     #0              ; Set Buffer Address
002304  2  A4 D0                LDY     DBUFF+HI
002306  2  A2 1A                LDX     #26
002308  2  20 03 01             JSR     PEM
00230B  2               
00230B  2  A9 50                LDA     #<SAVEFCB       ; Write Record
00230D  2  A0 25                LDY     #>SAVEFCB
00230F  2  A2 15                LDX     #21
002311  2  20 03 01             JSR     PEM
002314  2               
002314  2  A9 80                LDA     #$80            ; Set Buffer Address
002316  2  A4 D0                LDY     DBUFF+HI
002318  2  A2 1A                LDX     #26
00231A  2  20 03 01             JSR     PEM
00231D  2               
00231D  2  A9 50                LDA     #<SAVEFCB       ; Write Record
00231F  2  A0 25                LDY     #>SAVEFCB
002321  2  A2 15                LDX     #21
002323  2  20 03 01             JSR     PEM
002326  2               
002326  2  C9 FF                CMP     #$FF
002328  2  F0 03                BEQ     WRTERR
00232A  2               NXTSEC:
00232A  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
00232C  2  60                   RTS
00232D  2               WRTERR:
00232D  2  38                   SEC
00232E  2  60                   RTS
00232F  2               
00232F  2               
00232F  2               DSXERR:
00232F  2  A9 0E                LDA     #14
002331  2               
002331  2               QERR:
002331  2  4C EE 1D             JMP     ZERROR
002334  2               
002334  2               ; -----------------------------
002334  2               ; SET UP SAVE & RESTORE SCREENS
002334  2               ; -----------------------------
002334  2               
002334  2               SAVRES:
002334  2  20 0D 1F             JSR     ZCRLF           ; CLEAR THE BUFFER
002337  2  A2 00                LDX     #0
002339  2  86 BF                STX     SCRIPT          ; DISABLE SCRIPTING
00233B  2  18                   CLC
00233C  2  60                   RTS
00233D  2               
00233D  2               
00233D  2               
00233D  2               ; FALL THROUGH ...
00233D  2               
00233D  2               ; --------------------------------
00233D  2               ; ACTIVATE CURSOR, CLEAR KEY QUEUE
00233D  2               ; --------------------------------
00233D  2               
00233D  2               CURSON:
00233D  2  60                   RTS
00233E  2               
00233E  2               ; -----------------------------
00233E  2               ; GET SAVE & RESTORE PARAMETERS
00233E  2               ; -----------------------------
00233E  2               
00233E  2               FILENAME:
00233E  2  0D                   .BYTE   EOL
00233F  2  46 69 6C 65          .BYTE   "File Name:"
002343  2  20 4E 61 6D  
002347  2  65 3A        
002349  2               FILENAMEL       = *-FILENAME
002349  2               
002349  2               NO:
002349  2  4E 6F                .BYTE   "No"
00234B  2               NOL             = *-NO
00234B  2               
00234B  2               YES:
00234B  2  59 65 73             .BYTE   "Yes"
00234E  2               YESL            = *-YES
00234E  2               
00234E  2               
00234E  2               
00234E  2               
00234E  2               ALLSET:
00234E  2  A2 4B                LDX     #<YES           ; PRINT "YES"
002350  2  A9 23                LDA     #>YES
002352  2  A0 03                LDY     #YESL
002354  2  20 7C 21             JSR     DLINE
002357  2               
002357  2               
002357  2               ; ---------------------
002357  2               ; "PRESS RETURN" PROMPT
002357  2               ; ---------------------
002357  2               
002357  2               RETURN:
002357  2  A2 71                LDX     #<RTN
002359  2  A9 23                LDA     #>RTN
00235B  2  A0 1E                LDY     #RTNL
00235D  2  20 7C 21             JSR     DLINE           ; SHOW PROMPT
002360  2               
002360  2               ; ENTRY FOR QUIT/RESTART
002360  2               
002360  2               GETRET:
002360  2  20 3D 23             JSR     CURSON          ; ENABLE CURSOR
002363  2               
002363  2               GTRT:
002363  2  20 C5 20             JSR     GETKEY          ; WAIT FOR [RETURN]
002366  2  C9 0D                CMP     #EOL
002368  2  F0 06                BEQ     RETEX
00236A  2  20 C5 21             JSR     BOOP            ; ACCEPT NO
00236D  2  4C 63 23             JMP     GTRT            ; SUBSTITUTES!
002370  2               
002370  2               RETEX:
002370  2  60                   RTS
002371  2               
002371  2               RTN:
002371  2  0D                   .BYTE   EOL
002372  2  50 72 65 73          .BYTE   "Press [RETURN] to continue."
002376  2  73 20 5B 52  
00237A  2  45 54 55 52  
00238D  2  0D                   .BYTE   EOL
00238E  2  3E                   .BYTE   ">"
00238F  2               RTNL            = *-RTN
00238F  2               
00238F  2               
00238F  2               ; -------------------------
00238F  2               ; SET UP PHONEY STATUS LINE
00238F  2               ; -------------------------
00238F  2               
00238F  2               ; ENTRY: TEXT SET UP FOR "DLINE"
00238F  2               
00238F  2               SROOM:
00238F  2  60                   RTS
002390  2               
002390  2               ; ---------
002390  2               ; SAVE GAME
002390  2               ; ---------
002390  2               
002390  2               
002390  2               
002390  2               ZSAVE:
002390  2  20 A6 24             JSR     GETFILENAME
002393  2  A9 50                LDA     #<SAVEFCB       ; Open Extent
002395  2  A0 25                LDY     #>SAVEFCB
002397  2  A2 16                LDX     #22
002399  2  20 03 01             JSR     PEM
00239C  2  C9 FF                CMP     #$FF
00239E  2  F0 03                BEQ     BADSAV
0023A0  2               
0023A0  2  4C A6 23             JMP     DOSAVE          ; ERROR IF CARRY SET
0023A3  2               
0023A3  2               BADSAV:
0023A3  2  4C 2C 11             JMP     PREDF           ; PREDICATE FAILS
0023A6  2               
0023A6  2               DOSAVE:
0023A6  2               
0023A6  2               ; SAVE GAME PARAMETERS IN [BUFSAV]
0023A6  2               
0023A6  2  AD 02 2B             LDA     ZBEGIN+ZID      ; MOVE GAME ID
0023A9  2  8D 20 0D             STA     BUFSAV+0        ; INTO 1ST 2 BYTES
0023AC  2  AD 03 2B             LDA     ZBEGIN+ZID+1    ; OF THE AUX LINE BUFFER
0023AF  2  8D 21 0D             STA     BUFSAV+1
0023B2  2               
0023B2  2  A5 74                LDA     ZSP             ; MOVE [ZSP]
0023B4  2  8D 22 0D             STA     BUFSAV+2        ; TO 3RD BYTE
0023B7  2  A5 75                LDA     OLDZSP          ; MOVE [OLDZSP]
0023B9  2  8D 23 0D             STA     BUFSAV+3        ; TO 4TH
0023BC  2               
0023BC  2  A2 02                LDX     #2              ; MOVE CONTENTS OF [ZPC]
0023BE  2               ZPCSAV:
0023BE  2  B5 76                LDA     ZPC,X           ; TO BYTES 5-7
0023C0  2  9D 24 0D             STA     BUFSAV+4,X      ; OF [BUFSAV]
0023C3  2  CA                   DEX
0023C4  2  10 F8                BPL     ZPCSAV
0023C6  2               
0023C6  2               ; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
0023C6  2               
0023C6  2  A9 0D                LDA     #>LOCALS
0023C8  2  85 D0                STA     DBUFF+HI        ; POINT TO THE PAGE
0023CA  2  20 02 23             JSR     PUTDSK          ; AND WRITE IT OUT
0023CD  2  B0 D4                BCS     BADSAV          ; CATCH WRITE ERROR HERE
0023CF  2               
0023CF  2               ; WRITE CONTENTS OF Z-STACK TO DISK
0023CF  2               
0023CF  2  A9 09                LDA     #>ZSTAKL        ; POINT TO 1ST PAGE
0023D1  2  85 D0                STA     DBUFF+HI
0023D3  2  20 02 23             JSR     PUTDSK          ; WRITE 1ST AND
0023D6  2  B0 CB                BCS     BADSAV
0023D8  2  20 02 23             JSR     PUTDSK          ; 2ND PAGE OF Z-STACK
0023DB  2  B0 C6                BCS     BADSAV
0023DD  2               
0023DD  2               ; WRITE ENTIRE GAME PRELOAD TO DISK
0023DD  2               
0023DD  2  A5 83                LDA     ZCODE           ; POINT TO 1ST PAGE
0023DF  2  85 D0                STA     DBUFF+HI        ; OF PRELOAD
0023E1  2               
0023E1  2  AE 0E 2B             LDX     ZBEGIN+ZPURBT   ; GET # IMPURE PAGES
0023E4  2  E8                   INX                     ; USE FOR INDEXING
0023E5  2  86 6E                STX     I+LO
0023E7  2               
0023E7  2               LSAVE:
0023E7  2  20 02 23             JSR     PUTDSK
0023EA  2  B0 B7                BCS     BADSAV
0023EC  2  C6 6E                DEC     I+LO
0023EE  2  D0 F7                BNE     LSAVE
0023F0  2               
0023F0  2  A9 71                LDA     #<SPAREBYTES    ; Set Buffer Address
0023F2  2  A0 25                LDY     #>SPAREBYTES
0023F4  2  A2 1A                LDX     #26
0023F6  2  20 03 01             JSR     PEM
0023F9  2               
0023F9  2  A9 50                LDA     #<SAVEFCB       ; Close
0023FB  2  A0 25                LDY     #>SAVEFCB
0023FD  2  A2 10                LDX     #16
0023FF  2  20 03 01             JSR     PEM
002402  2  4C 38 11             JMP     PREDS           ; ELSE PREDICATE SUCCEEDS
002405  2               
002405  2               ; ------------
002405  2               ; RESTORE GAME
002405  2               ; ------------
002405  2               
002405  2               ZREST:
002405  2  20 A6 24             JSR     GETFILENAME
002408  2  A9 50                LDA     #<SAVEFCB       ; Open Extent
00240A  2  A0 25                LDY     #>SAVEFCB
00240C  2  A2 0F                LDX     #15
00240E  2  20 03 01             JSR     PEM
002411  2  C9 FF                CMP     #$FF
002413  2  F0 30                BEQ     BADRES
002415  2               
002415  2  4C 18 24             JMP     DOREST          ; ERROR IF CARRY SET
002418  2               
002418  2               DOREST:
002418  2               ; SAVE LOCALS IN CASE OF ERROR
002418  2  A2 1F                LDX     #31
00241A  2               LOCSAV:
00241A  2  BD 00 0D             LDA     LOCALS,X        ; COPY ALL LOCALS
00241D  2  9D 71 25             STA     SPAREBYTES,X    ; TO BOTTOM OF MACHINE STACK
002420  2  CA                   DEX
002421  2  10 F7                BPL     LOCSAV
002423  2               
002423  2  A9 0D                LDA     #>LOCALS
002425  2  85 D0                STA     DBUFF+HI
002427  2  20 D7 22             JSR     GETRES          ; RETRIEVE 1ST BLOCK OF PRELOAD
00242A  2               
00242A  2  AD 20 0D             LDA     BUFSAV+0        ; DOES 1ST BYTE OF SAVED GAME ID
00242D  2  CD 02 2B             CMP     ZBEGIN+ZID      ; MATCH THE CURRENT ID?
002430  2  D0 08                BNE     WRONG           ; WRONG DISK IF NOT
002432  2               
002432  2  AD 21 0D             LDA     BUFSAV+1        ; WHAT ABOUT THE 2ND BYTE?
002435  2  CD 03 2B             CMP     ZBEGIN+ZID+1
002438  2  F0 0E                BEQ     RIGHT           ; CONTINUE IF BOTH BYTES MATCH
00243A  2               
00243A  2               ; HANDLE INCORRECT SAVE DISK
00243A  2               
00243A  2               WRONG:
00243A  2  A2 1F                LDX     #31             ; RESTORE ALL SAVED LOCALS
00243C  2               WR0:
00243C  2  BD 71 25             LDA     SPAREBYTES,X
00243F  2  9D 00 0D             STA     LOCALS,X
002442  2  CA                   DEX
002443  2  10 F7                BPL     WR0
002445  2               
002445  2               BADRES:
002445  2  4C 2C 11             JMP     PREDF           ; PREDICATE FAILS
002448  2               
002448  2               ; CONTINUE RESTORE
002448  2               
002448  2               RIGHT:
002448  2  AD 10 2B             LDA     ZBEGIN+ZSCRIP   ; SAVE BOTH FLAG BYTES
00244B  2  85 6E                STA     I+LO
00244D  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1
002450  2  85 6F                STA     I+HI
002452  2               
002452  2  A9 09                LDA     #>ZSTAKL        ; RETRIEVE OLD CONTENTS OF
002454  2  85 D0                STA     DBUFF+HI        ; Z-STACK
002456  2  20 D7 22             JSR     GETRES          ; GET 1ST BLOCK OF Z-STACK
002459  2  20 D7 22             JSR     GETRES          ; AND 2ND BLOCK
00245C  2               
00245C  2  A5 83                LDA     ZCODE
00245E  2  85 D0                STA     DBUFF+HI
002460  2  20 D7 22             JSR     GETRES          ; GET 1ST BLOCK OF PRELOAD
002463  2               
002463  2  A5 6E                LDA     I+LO            ; RESTORE THE STATE
002465  2  8D 10 2B             STA     ZBEGIN+ZSCRIP   ; OF THE FLAG WORD
002468  2  A5 6F                LDA     I+HI
00246A  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1
00246D  2               
00246D  2  AD 0E 2B             LDA     ZBEGIN+ZPURBT   ; GET # PAGES TO LOAD
002470  2  85 6E                STA     I+LO
002472  2               
002472  2               LREST:
002472  2  20 D7 22             JSR     GETRES          ; FETCH THE REMAINDER
002475  2  C6 6E                DEC     I+LO            ; OF THE PRELOAD
002477  2  D0 F9                BNE     LREST
002479  2               
002479  2  A9 71                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
00247B  2  A0 25                LDY     #>SPAREBYTES
00247D  2  A2 1A                LDX     #26
00247F  2  20 03 01             JSR     PEM
002482  2               
002482  2  A9 50                LDA     #<SAVEFCB       ; Close Extent
002484  2  A0 25                LDY     #>SAVEFCB
002486  2  A2 10                LDX     #16
002488  2  20 03 01             JSR     PEM
00248B  2               
00248B  2               
00248B  2               ; RESTORE THE STATE OF THE SAVED GAME
00248B  2               
00248B  2  AD 22 0D             LDA     BUFSAV+2        ; RESTORE THE [ZSP]
00248E  2  85 74                STA     ZSP
002490  2  AD 23 0D             LDA     BUFSAV+3        ; AND THE [OLDZSP]
002493  2  85 75                STA     OLDZSP
002495  2               
002495  2  A2 02                LDX     #2              ; RESTORE THE [ZPC]
002497  2               RESZPC:
002497  2  BD 24 0D             LDA     BUFSAV+4,X
00249A  2  95 76                STA     ZPC,X
00249C  2  CA                   DEX
00249D  2  10 F8                BPL     RESZPC
00249F  2               
00249F  2  A9 00                LDA     #FALSE
0024A1  2  85 79                STA     ZPCFLG          ; INVALIDATE [ZPC]
0024A3  2  4C 38 11             JMP     PREDS           ; PREDICATE SUCCEEDS
0024A6  2               
0024A6  2               
0024A6  2               GETFILENAME:
0024A6  2               ; get filename and place in FCB
0024A6  2               ; then open file for write/create
0024A6  2  20 34 23             JSR     SAVRES          ; SET UP SCREEN
0024A9  2  A2 3E                LDX     #<FILENAME
0024AB  2  A9 23                LDA     #>FILENAME
0024AD  2  A0 0B                LDY     #FILENAMEL
0024AF  2  20 7C 21             JSR     DLINE           ; "FILENAME ..."
0024B2  2               
0024B2  2  A9 20                LDA     #' '
0024B4  2  8D 51 25             STA     SAVEFCB+1
0024B7  2  8D 52 25             STA     SAVEFCB+2
0024BA  2  8D 53 25             STA     SAVEFCB+3
0024BD  2  8D 54 25             STA     SAVEFCB+4
0024C0  2  8D 55 25             STA     SAVEFCB+5
0024C3  2  8D 56 25             STA     SAVEFCB+6
0024C6  2  8D 57 25             STA     SAVEFCB+7
0024C9  2  8D 58 25             STA     SAVEFCB+8
0024CC  2               
0024CC  2  A9 71                LDA     #<SPAREBYTES
0024CE  2  85 62                STA     ARG1
0024D0  2  A9 25                LDA     #>SPAREBYTES
0024D2  2  85 63                STA     ARG1+1
0024D4  2  20 26 21             JSR     INPUT
0024D7  2  C9 0A                CMP     #10
0024D9  2  90 02                BCC     :+
0024DB  2  A9 09                LDA     #9
0024DD  2               :
0024DD  2  AA                   TAX
0024DE  2  CA                   DEX
0024DF  2               GFNLOOP:
0024DF  2  BD 71 25             LDA     SPAREBYTES,X
0024E2  2               
0024E2  2  C9 30                CMP     #'0'
0024E4  2  B0 05                BCS     :+
0024E6  2  A9 5F                LDA     #'_'
0024E8  2  4C 11 25             JMP     GFNOK
0024EB  2               :
0024EB  2  C9 3A                CMP     #':'
0024ED  2  90 22                BCC     GFNOK
0024EF  2  C9 41                CMP     #'A'
0024F1  2  B0 05                BCS     :+
0024F3  2  A9 5F                LDA     #'_'
0024F5  2  4C 11 25             JMP     GFNOK
0024F8  2               :
0024F8  2  C9 5B                CMP     #'Z'+1
0024FA  2  90 15                BCC     GFNOK
0024FC  2  C9 61                CMP     #'a'
0024FE  2  B0 05                BCS     :+
002500  2  A9 5F                LDA     #'_'
002502  2  4C 11 25             JMP     GFNOK
002505  2               :
002505  2  C9 7B                CMP     #'z'+1
002507  2  90 05                BCC     :+
002509  2  A9 5F                LDA     #'_'
00250B  2  4C 11 25             JMP     GFNOK
00250E  2               :
00250E  2  38                   SEC
00250F  2  E9 20                SBC     #$20
002511  2               GFNOK:
002511  2  9D 50 25             STA     SAVEFCB,X
002514  2  CA                   DEX
002515  2  10 C8                BPL     GFNLOOP
002517  2               
002517  2  A9 00                LDA     #0
002519  2  8D 50 25             STA     SAVEFCB+0
00251C  2  8D 5C 25             STA     SAVEFCB+12
00251F  2  A9 53                LDA     #'S'
002521  2  8D 59 25             STA     SAVEFCB+9
002524  2  A9 41                LDA     #'A'
002526  2  8D 5A 25             STA     SAVEFCB+10
002529  2  A9 56                LDA     #'V'
00252B  2  8D 5B 25             STA     SAVEFCB+11
00252E  2  60                   RTS
00252F  2               
00252F  2               
00252F  2               
00252F  2               GAMEFCB:
00252F  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002533  2  00 00 00 00  
002537  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
00253B  2  00 00 00 00  
00253F  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002543  2  00 00 00 00  
002547  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
00254B  2  00 00 00 00  
00254F  2  00                   .BYTE   00
002550  2               
002550  2               SAVEFCB:
002550  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002554  2  00 00 00 00  
002558  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
00255C  2  00 00 00 00  
002560  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002564  2  00 00 00 00  
002568  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
00256C  2  00 00 00 00  
002570  2  00                   .BYTE   00
002571  2               
002571  2               SPAREBYTES:
002571  2               D65BLOCK:
002571  2  xx xx xx xx          .RES    256
002575  2  xx xx xx xx  
002579  2  xx xx xx xx  
002671  2               
002671  1                       .INCLUDE "disk.asm"
002671  2               ;        PAGE
002671  2               ;        SBTTL   "--- DISK ACCESS: DOS/65 ---"
002671  2               
002671  2               ; --------------
002671  2               ; OPEN DRIVE [A]
002671  2               ; WILL OPEN FILE SPECIFIED IN COMMAND LINE
002671  2               ; --------------
002671  2               DOPEN:
002671  2  A2 0C                LDX     #12
002673  2               :
002673  2  CA                   DEX
002674  2  BD 07 01             LDA     DFLFCB,X
002677  2  9D 2F 25             STA     GAMEFCB,X
00267A  2  E0 00                CPX     #00
00267C  2  D0 F5                BNE     :-
00267E  2               
00267E  2  A9 2F                LDA     #<GAMEFCB       ; Open Extent
002680  2  A0 25                LDY     #>GAMEFCB
002682  2  A2 0F                LDX     #15
002684  2  20 03 01             JSR     PEM
002687  2  C9 FF                CMP     #$FF
002689  2  F0 13                BEQ     OPENDSKERR
00268B  2               
00268B  2  A9 71                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
00268D  2  A0 25                LDY     #>SPAREBYTES
00268F  2  A2 1A                LDX     #26
002691  2  20 03 01             JSR     PEM
002694  2               
002694  2  A9 2F                LDA     #<GAMEFCB       ; Close Extent
002696  2  A0 25                LDY     #>GAMEFCB
002698  2  A2 10                LDX     #16
00269A  2  20 03 01             JSR     PEM
00269D  2  60                   RTS
00269E  2               
00269E  2               OPENDSKERR:
00269E  2               
00269E  2  A2 AC                LDX     #<OPENERR
0026A0  2  A9 26                LDA     #>OPENERR
0026A2  2  A0 35                LDY     #OPENERRL
0026A4  2  20 7C 21             JSR     DLINE
0026A7  2               
0026A7  2  A9 0E                LDA     #14
0026A9  2  4C EE 1D             JMP     ZERROR
0026AC  2               
0026AC  2               OPENERR:
0026AC  2  0D 0D 0D 0D          .BYTE   EOL,EOL,EOL,EOL
0026B0  2  55 6E 61 62          .BYTE   "Unable to open game file."
0026B4  2  6C 65 20 74  
0026B8  2  6F 20 6F 70  
0026C9  2  0D                   .BYTE   EOL
0026CA  2  55 53 41 47          .BYTE   "USAGE:  ZIP <GAMEFILE>"
0026CE  2  45 3A 20 20  
0026D2  2  5A 49 50 20  
0026E0  2  0D                   .BYTE   EOL
0026E1  2               OPENERRL        = *-OPENERR
0026E1  2               
0026E1  2               ; -------------------
0026E1  2               ; CLOSE CURRENT DRIVE
0026E1  2               ; -------------------
0026E1  2               
0026E1  2               DCLOSE:
0026E1  2  60                   RTS
0026E2  2               
0026E2  2               ; FALL THROUGH ...
0026E2  2               
0026E2  2               
0026E2  2               ; ----------------
0026E2  2               ; DIVIDE [A] BY 10
0026E2  2               ; ----------------
0026E2  2               
0026E2  2               ; EXIT: QUOTIENT IN [X], REMAINDER IN [A]
0026E2  2               
0026E2  2               DIV10:
0026E2  2  A2 00                LDX     #0              ; START WITH ZERO QUOTIENT
0026E4  2               
0026E4  2               D10L:
0026E4  2  C9 0A                CMP     #10             ; IF DIVISOR < 10,
0026E6  2  90 05                BCC     D10EX           ; WE'RE DONE
0026E8  2  E9 0A                SBC     #10             ; ELSE SUBTRACT ANOTHER 10
0026EA  2  E8                   INX                     ; UPDATE QUOTIENT
0026EB  2  D0 F7                BNE     D10L            ; BRANCH ALWAYS
0026ED  2               
0026ED  2               D10EX:
0026ED  2  60                   RTS
0026EE  2               
0026EE  1               
0026EE  1                       .IFDEF  DEBUG
0026EE  1                       .INCLUDE "bugger.asm"
0026EE  1                       .ENDIF
0026EE  1               
0026EE  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC."
0026EE  1                       .END
