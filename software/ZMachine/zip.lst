ca65 V2.18 - Ubuntu 2.19-1
Main file   : zip.asm
Current file: zip.asm

000000r 1               ; TITLE   "ZIP/6502-C INFOCOM, INC. --- EQUATES"
000000r 1               ; --------------------------
000000r 1               ; ZIP/6502 2.0 VERSION F
000000r 1               ; Z-CODE INTERPRETER PROGRAM
000000r 1               ; FOR DUODYNE DOS/65 65816
000000r 1               ; --------------------------
000000r 1               ; INFOCOM, INC.
000000r 1               ; 55 WHEELER STREET
000000r 1               ; CAMBRIDGE, MA 02136
000000r 1               ; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
000000r 1               
000000r 1               MSTART          = $0800         ; START OF FREE PROGRAM RAM
000000r 1               ZEROPG          = $60           ; START OF FREE Z-PAGE RAM
000000r 1               ZPGTOP          = $DF           ; END OF FREE Z-PAGE RAM
000000r 1               
000000r 1               ;DEBUG           = 0             ; ASSEMBLY FLAG FOR DEBUGGER
000000r 1               
000000r 1               ; -----------
000000r 1               ; ERROR CODES
000000r 1               ; -----------
000000r 1               ; 00 -- INSUFFICIENT RAM
000000r 1               ; 01 -- ILLEGAL X-OP
000000r 1               ; 02 -- ILLEGAL 0-OP
000000r 1               ; 03 -- ILLEGAL 1-OP
000000r 1               ; 04 -- ILLEGAL 2-OP
000000r 1               ; 05 -- Z-STACK UNDERFLOW
000000r 1               ; 06 -- Z-STACK OVERFLOW
000000r 1               ; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
000000r 1               ; 08 -- DIVISION BY ZERO
000000r 1               ; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
000000r 1               ; 10 -- ILLEGAL PROPERTY ID (PUTP)
000000r 1               ; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
000000r 1               ; 12 -- DISK ADDRESS OUT OF RANGE
000000r 1               ; 13 -- PARSER OVERFLOW
000000r 1               ; 14 -- DRIVE ACCESS
000000r 1               ; 15 -- Z-STACK DESTROYED
000000r 1               
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 00 0E             JMP     COLD
000803  1                       .INCLUDE "eq.asm"
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- MEMORY ORGANIZATION ---"
000803  2               
000803  2               TRUE	=	$FF
000803  2               FALSE	=	0
000803  2               LO	=	0
000803  2               HI	=	1
000803  2               
000803  2               IOBUFF	=	MSTART		; 256-BYTE DISK BUFFER
000803  2               ZSTAKL	=	MSTART+$100	; Z-STACK LSBS
000803  2               ZSTAKH	=	MSTART+$200	; Z-STACK MSBS
000803  2               PTABL	=	MSTART+$300	; PAGING TABLE LSBS ($A0 BYTES)
000803  2               PTABH	=	MSTART+$3A0	; PAGING TABLE MSBS ($A0 BYTES)
000803  2               LRUMAP	=	MSTART+$450	; TIMESTAMP MAP ($A0 BYTES) (BM 11/24/84)
000803  2               LOCALS  =     MSTART+$500     ; LOCAL VARIABLE STORAGE (32 BYTES)
000803  2               BUFSAV  =     MSTART+$520     ; I/O AUX BUFFER (80 BYTES)
000803  2               
000803  2               ZIP	=	MSTART+$600	; START OF EXECUTABLE CODE
000803  2               ZBEGIN	=	ZIP+$1D00	; START OF Z-CODE
000803  2               
000803  2               	; ---------------------
000803  2               	; Z-CODE HEADER OFFSETS
000803  2               	; ---------------------
000803  2               
000803  2               ZVERS	=	0		; VERSION BYTE
000803  2               ZMODE	=	1		; MODE SELECT BYTE
000803  2               ZID	=	2		; GAME ID WORD
000803  2               ZENDLD	=	4		; START OF NON-PRELOADED Z-CODE
000803  2               ZGO	=	6		; EXECUTION ADDRESS
000803  2               ZVOCAB	=	8		; START OF VOCABULARY TABLE
000803  2               ZOBJEC	=	10		; START OF OBJECT TABLE
000803  2               ZGLOBA	=	12		; START OF GLOBAL VARIABLE TABLE
000803  2               ZPURBT	=	14		; START OF "PURE" Z-CODE
000803  2               ZSCRIP	=	16		; FLAG WORD
000803  2               ZSERIA	=	18		; 3-WORD ASCII SERIAL NUMBER
000803  2               ZFWORD	=	24		; START OF FWORDS TABLE
000803  2               ZLENTH	=	26		; LENGTH OF Z-PROGRAM IN WORDS
000803  2               ZCHKSM	=	28		; Z-CODE CHECKSUM WORD
000803  2               
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- ZIP Z-PAGE VARIABLES ---"
000803  2               
000803  2               OPCODE	=	ZEROPG		; (BYTE) CURRENT OPCODE
000803  2               NARGS	=	OPCODE+1	; (BYTE) # ARGUMENTS
000803  2               ARG1	=	OPCODE+2	; (WORD) ARGUMENT #1
000803  2               ARG2	=	OPCODE+4	; (WORD) ARGUMENT #2
000803  2               ARG3	=	OPCODE+6	; (WORD) ARGUMENT #3
000803  2               ARG4	=	OPCODE+8	; (WORD) ARGUMENT #4
000803  2               ABYTE	=	OPCODE+10	; (BYTE) X-OP ARGUMENT BYTE
000803  2               ADEX	=	OPCODE+11	; (BYTE) X-OP ARGUMENT INDEX
000803  2               
000803  2               VALUE	=	OPCODE+12	; (WORD) VALUE RETURN REGISTER
000803  2               I	=	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
000803  2               J	=	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
000803  2               K	=	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
000803  2               
000803  2               ZSP	=	VALUE+8		; (BYTE) Z-STACK POINTER
000803  2               OLDZSP	=	ZSP+1		; (BYTE) OLD Z-STACK POINTER
000803  2               
000803  2               ZPC	=	ZSP+2		; (3 BYTES) ZIP PROGRAM COUNTER
000803  2               ZPCL	=	ZPC		; (BYTE) LOW 8 BITS OF [ZPC]
000803  2               ZPCM	=	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
000803  2               ZPCH	=	ZPC+2		; (BYTE) HIGH BIT OF [ZPC]
000803  2               ZPCFLG	=	ZPC+3		; (BYTE) FLAG: "TRUE" IF [ZPCPNT] VALID
000803  2               ZPCPNT	=	ZPC+4		; (WORD) ABS POINTER TO CURRENT Z-PAGE
000803  2               
000803  2               MPC	=	ZPC+6		; (3 BYTES) MEMORY PROGRAM COUNTER
000803  2               MPCL	=	MPC		; (BYTE) LOW 8 BITS OF [MPC]
000803  2               MPCM	=	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
000803  2               MPCH	=	MPC+2		; (BYTE) HIGH BIT OF [MPC]
000803  2               MPCFLG	=	MPC+3		; (BYTE) FLAG: "TRUE" IF [MPCPNT] VALID
000803  2               MPCPNT	=	MPC+4		; (WORD) ABS POINTER TO CURRENT M-PAGE
000803  2               
000803  2               LRU	=	MPC+6		; (BYTE) PAGING INDEX
000803  2               ZCODE	=	LRU+1		; (BYTE) 1ST ABSOLUTE PAGE OF PRELOAD
000803  2               ZPURE	=	LRU+2		; (BYTE) 1ST VIRTUAL PAGE OF "PURE" Z-CODE
000803  2               PAGE0	=	LRU+3		; (BYTE) 1ST PAGE OF ACTUAL SWAPPING SPACE
000803  2               PMAX	=	LRU+4		; (BYTE) MAXIMUM # OF SWAPPING PAGES
000803  2               ZPAGE	=	LRU+5		; (BYTE) CURRENT SWAPPING PAGE
000803  2               TARGET	=	LRU+6		; (WORD) TARGET PAGE FOR SWAPPING
000803  2               STAMP	=	LRU+8		; (BYTE) CURRENT TIMESTAMP (BM 11/24/84)
000803  2               SWAP	=	LRU+9		; (BYTE) EARLIEST PAGE (BM 11/24/84)
000803  2               
000803  2               GLOBAL	=	LRU+10		; (WORD) GLOBAL VARIABLE POINTER
000803  2               VOCAB	=	GLOBAL+2	; (WORD) VOCAB TABLE POINTER
000803  2               FWORDS	=	GLOBAL+4	; (WORD) F-WORDS TABLE POINTER
000803  2               OBJTAB	=	GLOBAL+6	; (WORD) OBJECT TABLE POINTER
000803  2               
000803  2               	; Z-STRING MANIPULATION VARIABLES
000803  2               
000803  2               IN	=	GLOBAL+8	; (6 BYTES) INPUT BUFFER
000803  2               OUT	=	IN+6		; (6 BYTES) OUTPUT BUFFER
000803  2               
000803  2               SOURCE	=	OUT+6		; (BYTE) SOURCE BUFFER POINTER
000803  2               RESULT	=	SOURCE+1	; (BYTE) RESULT TABLE POINTER
000803  2               LINLEN	=	SOURCE+2	; (BYTE) LENGTH OF CURRENT LINE
000803  2               WRDLEN	=	SOURCE+3	; (BYTE) LENGTH OF CURRENT WORD
000803  2               ENTRY	=	SOURCE+4	; (WORD) ADDR OF CURRENT RESULT ENTRY
000803  2               NENTS	=	SOURCE+6	; (WORD) # ENTRIES IN VOCAB TABLE
000803  2               ESIZE	=	SOURCE+8	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
000803  2               PSET	=	SOURCE+9	; (BYTE) PERMANENT CHARSET
000803  2               TSET	=	SOURCE+10	; (BYTE) TEMPORARY CHARSET
000803  2               ZCHAR	=	SOURCE+11	; (BYTE) CURRENT Z-CHAR
000803  2               OFFSET	=	SOURCE+12	; (BYTE) F-WORD TABLE OFFSET
000803  2               ZFLAG	=	SOURCE+13	; (BYTE) Z-WORD ACCESS FLAG
000803  2               ZWORD	=	SOURCE+14	; (WORD) CURRENT Z-WORD
000803  2               CONCNT	=	SOURCE+16	; (BYTE) Z-STRING SOURCE COUNTER
000803  2               CONIN	=	SOURCE+17	; (BYTE) CONVERSION SOURCE INDEX
000803  2               CONOUT	=	SOURCE+18	; (BYTE) CONVERSION DEST INDEX
000803  2               
000803  2               QUOT	=	SOURCE+19	; (WORD) QUOTIENT FOR DIVISION
000803  2               REMAIN	=	QUOT+2		; (WORD) REMAINDER FOR DIVISION
000803  2               MTEMP	=	QUOT+4		; (WORD) MATH TEMPORARY REGISTER
000803  2               QSIGN	=	QUOT+6		; (BYTE) SIGN OF QUOTIENT
000803  2               RSIGN	=	QUOT+7		; (BYTE) SIGN OF REMAINDER
000803  2               DIGITS	=	QUOT+8		; (BYTE) DIGIT COUNT FOR "PRINTN"
000803  2               
000803  2               TIMEFL	=	QUOT+9		; (BYTE) "TRUE" IF TIME MODE
000803  2               LENGTH	=	TIMEFL+1	; (BYTE) LENGTH OF LINE IN [LINBUF]
000803  2               OLDLEN	=	TIMEFL+2	; (BYTE) OLD LINE LENGTH
000803  2               SCRIPT	=	TIMEFL+3	; (BYTE) SCRIPT ENABLE FLAG
000803  2               OLDX	=	TIMEFL+4	; (BYTE) OLD CURSOR X
000803  2               OLDY	=	TIMEFL+5	; (BYTE) OLD CURSOR Y
000803  2               LINCNT	=	TIMEFL+6	; (BYTE) LINE COUNTER
000803  2               LMAX	=	TIMEFL+7	; (BYTE) MAX # LINES/SCREEN
000803  2               
000803  2               IOCHAR	=	TIMEFL+8	; (BYTE) CHARACTER BUFFER
000803  2               SLINE	=	IOCHAR+1	; (BYTE) BORDERLINE FOR SPLIT
000803  2               SPSTAT	=	IOCHAR+2	; (BYTE) SPLIT SCREEN STATUS FLAG
000803  2               LFROM	=	IOCHAR+3	; (WORD) "FROM" LINE ADDRESS
000803  2               LTO	=	IOCHAR+5	; (WORD) "TO" LINE ADDRESS
000803  2               PSTAT	=	IOCHAR+7	; (BYTE) PRINTER STATUS FLAG
000803  2               PRLEN	=	IOCHAR+8	; (BYTE) SCRIPT LINE LENGTH
000803  2               
000803  2               DBLOCK	=	IOCHAR+9	; (WORD) Z-BLOCK TO READ
000803  2               DBUFF	=	DBLOCK+2	; (WORD) RAM PAGE TO ACCESS (LSB = 0)
000803  2               ;TRACK	=	DBLOCK+4	; (BYTE) TARGET TRACK
000803  2               ;SECTOR	=	DBLOCK+5	; (BYTE) TARGET SECTOR
000803  2               GPOSIT	=	DBLOCK+6	; (BYTE) DEFAULT SAVE POSITION
000803  2               GDRIVE	=	DBLOCK+7	; (BYTE) DEFAULT SAVE DRIVE
000803  2               TPOSIT	=	DBLOCK+8	; (BYTE) TEMP SAVE POSITION
000803  2               TDRIVE	=	DBLOCK+9	; (BYTE) TEMP SAVE DRIVE
000803  2               
000803  2               BLINK	=	DBLOCK+11	; (WORD) CURSOR BLINK TIMER
000803  2               
000803  2               ;DVD	=	DBLOCK+13	; (WORD) DISK DIVIDEND
000803  2               ;DSOR	=	DBLOCK+15	; (WORD) DISK DIVISOR
000803  2               DTEMP	=	DBLOCK+17	; (WORD) DISK TEMP VARIABLE
000803  2               
000803  1                       .SEGMENT "ZIP"
000803  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT INIT"
000803  1                       .INCLUDE "hardeq.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- HARDWARE EQUATES: DOS/65 ---"
000803  2               
000803  2               ; ---------
000803  2               ; CONSTANTS
000803  2               ; ---------
000803  2               
000803  2               XSIZE           = 79            ; X-SIZE OF SCREEN
000803  2               YSIZE           = 24            ; Y-SIZE OF SCREEN
000803  2               
000803  2               EOL             = $0D           ; EOL CHAR
000803  2               SPACE           = $20           ; SPACE CHAR
000803  2               BACKSP          = $08           ; BACKSPACE
000803  2               
000803  2               DFLFCB          = $107          ;DEFAULT FCB
000803  2               PEM             = $103          ;PEM ENTRY
000803  2               BOOT            = $100          ;WARM BOOT
000803  2               CCMLNG          = 2048          ;CCM LENGTH
000803  2               
000803  2               ; ---------
000803  2               ; ZERO-PAGE
000803  2               ; ---------
000803  2               
000803  2               
000803  2               ; -----------
000803  2               ; PAGES 2 & 3
000803  2               ; -----------
000803  2               
000803  2               LBUFF           = $0700         ; 89-BYTE LINE BUFFER
000803  2               
000803  1                       .INCLUDE "cold.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- MACHINE COLDSTART: DOS/65 ---"
000803  2               
000803  2               
000803  2               ; ---------
000803  2               ; COLDSTART
000803  2               ; ---------
000803  2                       .ORG    ZIP
000E00  2               
000E00  2               
000E00  2               COLD:
000E00  2  A9 00                LDA     #0
000E02  2  8D 52 21             STA     SFLAG           ; NO PREVIOUS SCRIPTING (BM 5/14/85)
000E05  2  4C 21 0E             JMP     WARM1
000E08  2               
000E08  2               ; ---------------
000E08  2               ; WARMSTART ENTRY
000E08  2               ; ---------------
000E08  2               
000E08  2               SLOAD:
000E08  2  54 68 65 20          .BYTE   "The story is loading ..."
000E0C  2  73 74 6F 72  
000E10  2  79 20 69 73  
000E20  2  0D                   .BYTE   EOL
000E21  2               SLOADL          = *-SLOAD
000E21  2               
000E21  2               WARM1:
000E21  2  D8                   CLD
000E22  2               ;  LDX     #$FF  (Dont do this for Duodyne . . . . .)
000E22  2               ;  TXS                     ; RESET MACHINE STACK
000E22  2               
000E22  2  20 D4 21             JSR     CLS             ; CLEAR SCREEN, ETC.
000E25  2               
000E25  2  A0 08                LDY     #8              ; POSITION "STORY LOADING" MESSAGE
000E27  2  A2 0B                LDX     #11             ; AT (8,11)
000E29  2  18                   CLC
000E2A  2  20 8E 21             JSR     PLOT
000E2D  2               
000E2D  2  A2 08                LDX     #<SLOAD
000E2F  2  A9 0E                LDA     #>SLOAD
000E31  2  A0 19                LDY     #SLOADL
000E33  2  20 3F 21             JSR     DLINE           ; "THE STORY IS LOADING ..."
000E36  2  20 03 26             JSR     DOPEN           ; AND OPEN THE STORY
000E39  2               
000E39  2               
000E39  2               ; FALL THROUGH TO ZIP WARMSTART AT "WARM2"
000E39  2               
000E39  1               
000E39  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- INIT & MAINLINE"
000E39  1                       .INCLUDE "warm.asm"
000E39  2               ;        PAGE
000E39  2               ;        SBTTL   "--- WARMSTART ROUTINE ---"
000E39  2               
000E39  2               ; -------------
000E39  2               ; ZIP WARMSTART
000E39  2               ; -------------
000E39  2               
000E39  2               WARM2:
000E39  2               
000E39  2               ; PROBABLY NOT THE BEST WAY TO DO THIS
000E39  2               ; I NEED TO USE THE CLOCK TO SEED THE RNG
000E39  2  A5 44                LDA     $44
000E3B  2  8D 88 1E             STA     state+0
000E3E  2  A5 46                LDA     $46
000E40  2  8D 8D 1E             STA     state1+0
000E43  2  A5 3B                LDA     $3B
000E45  2  8D 89 1E             STA     state+1
000E48  2  A5 3D                LDA     $3D
000E4A  2  8D 8E 1E             STA     state1+1
000E4D  2  AD 35 06             LDA     $0635
000E50  2  8D 8A 1E             STA     state+2
000E53  2  8D 8F 1E             STA     state1+2
000E56  2  08                   PHP
000E57  2  68                   PLA
000E58  2  8D 8B 1E             STA     state+3
000E5B  2  BA                   TSX
000E5C  2  8E 90 1E             STX     state1+3
000E5F  2  AD 00 04             LDA     $0400
000E62  2  8D 8C 1E             STA     state+4
000E65  2  AD 01 04             LDA     $0401
000E68  2  8D 91 1E             STA     state1+4
000E6B  2               
000E6B  2               
000E6B  2  A9 00                LDA     #0              ; CLEAR ALL Z-PAGE VARIABLES
000E6D  2  A2 60                LDX     #ZEROPG
000E6F  2               ST0:
000E6F  2  95 00                STA     0,X
000E71  2  E8                   INX
000E72  2  E0 DF                CPX     #ZPGTOP
000E74  2  90 F9                BCC     ST0
000E76  2               
000E76  2               ; INIT THE PAGING TABLES
000E76  2               
000E76  2  AA                   TAX                     ; = 0
000E77  2  A9 FF                LDA     #$FF
000E79  2               ST1A:
000E79  2  9D 00 0B             STA     PTABL,X
000E7C  2  9D A0 0B             STA     PTABH,X
000E7F  2  E8                   INX
000E80  2  E0 A0                CPX     #$A0
000E82  2  90 F5                BCC     ST1A
000E84  2               
000E84  2               ; INIT THE TIMESTAMP MAP (BM 11/24/84)\
000E84  2               
000E84  2  A9 00                LDA     #0
000E86  2  AA                   TAX
000E87  2               ST1B:
000E87  2  9D 50 0C             STA     LRUMAP,X
000E8A  2  E8                   INX
000E8B  2  E0 A0                CPX     #$A0
000E8D  2  90 F8                BCC     ST1B
000E8F  2               
000E8F  2  E6 74                INC     ZSP             ; INIT Z-STACK POINTERS
000E91  2  E6 75                INC     OLDZSP          ; TO "1"
000E93  2  E6 8A                INC     STAMP           ; INIT TIMESTAMP (BM 11/24/84)
000E95  2               
000E95  2               ; GRAB THE FIRST BLOCK OF PRELOAD
000E95  2               
000E95  2  A9 2B                LDA     #>ZBEGIN        ; MSB OF PRELOAD START ADDRESS
000E97  2  85 83                STA     ZCODE           ; FREEZE IT HERE
000E99  2  85 D0                STA     DBUFF+HI        ; LSB IS ALWAYS ZERO
000E9B  2  20 1B 22             JSR     GETDSK          ; [DBLOCK] SET TO Z-BLOCK 0
000E9E  2               
000E9E  2               ; EXTRACT GAME DATA FROM Z-CODE HEADER
000E9E  2               
000E9E  2  AE 04 2B             LDX     ZBEGIN+ZENDLD   ; MSB OF ENDLOAD POINTER
000EA1  2  E8                   INX                     ; ADD 1 TO GET
000EA2  2  86 84                STX     ZPURE           ; 1ST "PURE" PAGE OF Z-CODE
000EA4  2               
000EA4  2  8A                   TXA                     ; ADD START PAGE OF PRELOAD
000EA5  2  18                   CLC                     ; TO CALC ABSOLUTE START ADDRESS
000EA6  2  65 83                ADC     ZCODE           ; OF PAGING SPACE
000EA8  2  85 85                STA     PAGE0
000EAA  2               
000EAA  2  20 1B 1E             JSR     MEMTOP          ; RETURNS TOP RAM PAGE IN [A]
000EAD  2  38                   SEC
000EAE  2  E5 85                SBC     PAGE0           ; SUBTRACT ADDRESS OF PAGING SPACE
000EB0  2  F0 02                BEQ     NORAM
000EB2  2  B0 05                BCS     SETNP           ; ERROR IF NOT ENOUGH RAM
000EB4  2               
000EB4  2               ; *** ERROR #0 -- INSUFFICIENT RAM ***
000EB4  2               
000EB4  2               NORAM:
000EB4  2  A9 00                LDA     #0
000EB6  2  4C B1 1D             JMP     ZERROR
000EB9  2               
000EB9  2               SETNP:
000EB9  2  C9 A0                CMP     #$A0            ; DON'T ALLOW MORE THAN $A0 PAGES
000EBB  2  90 02                BCC     SETA0
000EBD  2  A9 A0                LDA     #$A0
000EBF  2               SETA0:
000EBF  2  85 86                STA     PMAX            ; SET # SWAPPING PAGES
000EC1  2               
000EC1  2  AD 01 2B             LDA     ZBEGIN+ZMODE
000EC4  2  09 20                ORA     #%00100000      ; ENABLE SPLIT-SCREEN
000EC6  2  8D 01 2B             STA     ZBEGIN+ZMODE
000EC9  2               
000EC9  2  29 02                AND     #%00000010      ; ISOLATE STATUS-FORMAT BIT
000ECB  2  85 BC                STA     TIMEFL          ; 0=SCORE, NZ=TIME
000ECD  2               
000ECD  2  AD 0C 2B             LDA     ZBEGIN+ZGLOBA   ; GET MSB OF GLOBAL TABLE ADDR
000ED0  2  18                   CLC                     ; CONVERT TO
000ED1  2  65 83                ADC     ZCODE           ; ABSOLUTE ADDRESS
000ED3  2  85 8D                STA     GLOBAL+HI
000ED5  2  AD 0D 2B             LDA     ZBEGIN+ZGLOBA+1 ; LSB NEEDN'T CHANGE
000ED8  2  85 8C                STA     GLOBAL+LO
000EDA  2               
000EDA  2  AD 18 2B             LDA     ZBEGIN+ZFWORD   ; DO SAME FOR FWORDS TABLE
000EDD  2  18                   CLC
000EDE  2  65 83                ADC     ZCODE
000EE0  2  85 91                STA     FWORDS+HI
000EE2  2  AD 19 2B             LDA     ZBEGIN+ZFWORD+1 ; NO CHANGE FOR LSB
000EE5  2  85 90                STA     FWORDS+LO
000EE7  2               
000EE7  2  AD 08 2B             LDA     ZBEGIN+ZVOCAB   ; NOW DO VOCABULARY TABLE
000EEA  2  18                   CLC
000EEB  2  65 83                ADC     ZCODE
000EED  2  85 8F                STA     VOCAB+HI
000EEF  2  AD 09 2B             LDA     ZBEGIN+ZVOCAB+1 ; LSB SAME
000EF2  2  85 8E                STA     VOCAB+LO
000EF4  2               
000EF4  2  AD 0A 2B             LDA     ZBEGIN+ZOBJEC   ; NOT TO MENTION
000EF7  2  18                   CLC                     ; THE OBJECT TABLE
000EF8  2  65 83                ADC     ZCODE
000EFA  2  85 93                STA     OBJTAB+HI
000EFC  2  AD 0B 2B             LDA     ZBEGIN+ZOBJEC+1 ; LSB SAME
000EFF  2  85 92                STA     OBJTAB+LO
000F01  2               
000F01  2               ; FETCH THE REST OF THE PRELOAD
000F01  2               
000F01  2               LDPRE:
000F01  2  A5 CD                LDA     DBLOCK+LO       ; CHECK CURRENT BLOCK #
000F03  2  C5 84                CMP     ZPURE           ; LOADED LAST PRELOAD PAGE YET?
000F05  2  B0 06                BCS     WARMEX          ; YES, TIME TO PLAY!
000F07  2  20 1B 22             JSR     GETDSK          ; ELSE GRAB NEXT Z-BLOCK
000F0A  2  4C 01 0F             JMP     LDPRE
000F0D  2               
000F0D  2               WARMEX:
000F0D  2  AD 06 2B             LDA     ZBEGIN+ZGO      ; GET START ADDRESS OF Z-CODE
000F10  2  85 77                STA     ZPCM            ; MSB
000F12  2  AD 07 2B             LDA     ZBEGIN+ZGO+1    ; AND LSB
000F15  2  85 76                STA     ZPCL            ; HIGH BIT ALREADY ZEROED
000F17  2               
000F17  2  E6 BF                INC     SCRIPT          ; ENABLE SCRIPTING
000F19  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; STUFF IN THE
000F1C  2  0D 52 21             ORA     SFLAG           ; PREVIOUS SCRIPT MODE
000F1F  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1 ; (BM 5/14/85)
000F22  2               
000F22  2  20 D4 21             JSR     CLS             ; CLEAR SCREEN, DISABLE SPLIT
000F25  2               
000F25  2               ; ... AND FALL INTO MAIN LOOP
000F25  2               
000F25  1                       .INCLUDE "main.asm"
000F25  2               ;        PAGE
000F25  2               ;        SBTTL   "--- MAIN LOOP ---"
000F25  2               
000F25  2               MLOOP:
000F25  2  A9 00                LDA     #0
000F27  2  85 61                STA     NARGS           ; RESET # ARGUMENTS
000F29  2  20 A9 19             JSR     NEXTPC          ; GET NEXT INSTRUCTION INTO [A]
000F2C  2  85 60                STA     OPCODE          ; SAVE IT HERE
000F2E  2               
000F2E  2                       .IFDEF  DEBUG
000F2E  2                       STA     MBYTE
000F2E  2                       LDA     #0              ; BREAKPOINT #0
000F2E  2                       JSR     DOBUG
000F2E  2                       LDA     MBYTE
000F2E  2                       .ENDIF
000F2E  2               
000F2E  2               ; DECODE AN OPCODE
000F2E  2               
000F2E  2  AA                   TAX                     ; SET FLAGS
000F2F  2  30 03                BMI     DC0             ; IF POSITIVE,
000F31  2  4C EF 0F             JMP     OP2             ; IT'S A 2-OP
000F34  2               
000F34  2               DC0:
000F34  2  C9 B0                CMP     #$B0
000F36  2  B0 03                BCS     DC1
000F38  2  4C C0 0F             JMP     OP1             ; OR MAYBE A 1-OP
000F3B  2               
000F3B  2               DC1:
000F3B  2  C9 C0                CMP     #$C0
000F3D  2  B0 03                BCS     OPEXT
000F3F  2  4C B1 0F             JMP     OP0             ; PERHAPS A 0-OP
000F42  2               
000F42  2               ; --------------
000F42  2               ; HANDLE AN X-OP
000F42  2               ; --------------
000F42  2               
000F42  2               OPEXT:
000F42  2  20 A9 19             JSR     NEXTPC          ; GRAB THE ARGUMENT ID BYTE
000F45  2  85 6A                STA     ABYTE           ; HOLD IT HERE
000F47  2               
000F47  2  A2 00                LDX     #0
000F49  2  86 6B                STX     ADEX            ; INIT ARGUMENT INDEX
000F4B  2  F0 06                BEQ     OPX1            ; JUMP TO TOP OF LOOP
000F4D  2               
000F4D  2               OPX0:
000F4D  2  A5 6A                LDA     ABYTE           ; GET ARG BYTE
000F4F  2  0A                   ASL     A               ; SHIFT NEXT 2 ARG BITS
000F50  2  0A                   ASL     A               ; INTO BITS 7 & 6
000F51  2  85 6A                STA     ABYTE           ; HOLD FOR LATER
000F53  2               
000F53  2               OPX1:
000F53  2  29 C0                AND     #%11000000      ; MASK OUT GARBAGE BITS
000F55  2  D0 06                BNE     OPX2
000F57  2  20 3B 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
000F5A  2  4C 6E 0F             JMP     OPXNXT
000F5D  2               
000F5D  2               OPX2:
000F5D  2  C9 40                CMP     #%01000000      ; IS IT A SHORT IMMEDIATE?
000F5F  2  D0 06                BNE     OPX3            ; NO, KEEP GUESSING
000F61  2  20 37 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
000F64  2  4C 6E 0F             JMP     OPXNXT
000F67  2               
000F67  2               OPX3:
000F67  2  C9 80                CMP     #%10000000      ; LAST TEST
000F69  2  D0 17                BNE     OPX4            ; 11 = NO MORE ARGUMENTS
000F6B  2  20 4F 10             JSR     GETVAR          ; 10 = VARIABLE
000F6E  2               
000F6E  2               OPXNXT:
000F6E  2  A6 6B                LDX     ADEX            ; RETRIEVE ARGUMENT INDEX
000F70  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB OF VALUE
000F72  2  95 62                STA     ARG1+LO,X       ; STORE IN ARGUMENT TABLE
000F74  2  A5 6D                LDA     VALUE+HI        ; GRAB MSB OF VALUE
000F76  2  95 63                STA     ARG1+HI,X       ; STORE THAT, TOO
000F78  2               
000F78  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNTER
000F7A  2               
000F7A  2  E8                   INX
000F7B  2  E8                   INX
000F7C  2  86 6B                STX     ADEX            ; UPDATE INDEX
000F7E  2  E0 08                CPX     #8              ; DONE 4 ARGUMENTS YET?
000F80  2  90 CB                BCC     OPX0            ; NO, GET SOME MORE
000F82  2               
000F82  2               ; ALL X-OP ARGUMENTS READY
000F82  2               
000F82  2               OPX4:
000F82  2  A5 60                LDA     OPCODE          ; IS THIS
000F84  2  C9 E0                CMP     #$E0            ; AN EXTENDED 2-OP?
000F86  2  B0 03                BCS     DOXOP           ; NO, IT'S A REAL X-OP
000F88  2  4C 18 10             JMP     OP2EX           ; ELSE TREAT IT LIKE A 2-OP
000F8B  2               
000F8B  2               DOXOP:
000F8B  2  A2 F9                LDX     #<OPTX          ; GET ADDR OF X-OP TABLE
000F8D  2  A0 11                LDY     #>OPTX          ; INTO [X/Y]
000F8F  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
000F91  2  C9 0C                CMP     #NOPSX          ; IS IT A LEGAL X-OP?
000F93  2  90 05                BCC     DODIS           ; YUP; TIME TO DISPATCH IT
000F95  2               
000F95  2               ; *** ERROR #1 -- ILLEGAL X-OP ***
000F95  2               
000F95  2  A9 01                LDA     #1
000F97  2  4C B1 1D             JMP     ZERROR
000F9A  2               
000F9A  2               ; ---------------
000F9A  2               ; OPCODE DISPATCH
000F9A  2               ; ---------------
000F9A  2               
000F9A  2               ; ENTRY: MASKED OPCODE INDEX IN [A]
000F9A  2               ;        OP-TABLE ADDR IN X/Y (LSB/MSB)
000F9A  2               
000F9A  2               DODIS:
000F9A  2  86 6E                STX     I+LO            ; SAVE TABLE ADDRESS
000F9C  2  84 6F                STY     I+HI            ; IN A POINTER
000F9E  2               
000F9E  2  0A                   ASL     A               ; WORD-ALIGN THE OP INDEX
000F9F  2  A8                   TAY
000FA0  2  B1 6E                LDA     (I),Y           ; GET LSB OF DISPATCH ADDRESS
000FA2  2  8D AC 0F             STA     GO+LO           ; INSTALL AS JSR OPERAND
000FA5  2  C8                   INY
000FA6  2  B1 6E                LDA     (I),Y           ; SAME WITH MSB
000FA8  2  8D AD 0F             STA     GO+HI
000FAB  2               
000FAB  2  20                   .BYTE   $20             ; 6502 "JSR" OPCODE
000FAC  2               GO:
000FAC  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
000FAE  2               
000FAE  2  4C 25 0F             JMP     MLOOP           ; GO BACK FOR ANOTHER OPCODE
000FB1  2               
000FB1  2               ; -------------
000FB1  2               ; HANDLE A 0-OP
000FB1  2               ; -------------
000FB1  2               
000FB1  2               OP0:
000FB1  2  A2 8B                LDX     #<OPT0          ; GET 0-OP TABLE ADDR
000FB3  2  A0 11                LDY     #>OPT0          ; INTO [X/Y]
000FB5  2  29 0F                AND     #%00001111      ; ISOLATE 0-OP ID BITS
000FB7  2  C9 0E                CMP     #NOPS0          ; OUT OF RANGE?
000FB9  2  90 DF                BCC     DODIS           ; NO, DISPATCH IT
000FBB  2               
000FBB  2               ; *** ERROR #2 -- ILLEGAL 0-OP ***
000FBB  2               
000FBB  2  A9 02                LDA     #2
000FBD  2  4C B1 1D             JMP     ZERROR
000FC0  2               
000FC0  2               ; -------------
000FC0  2               ; HANDLE A 1-OP
000FC0  2               ; -------------
000FC0  2               
000FC0  2               OP1:
000FC0  2  29 30                AND     #%00110000      ; ISOLATE ARGUMENT BITS
000FC2  2  D0 06                BNE     OP1A
000FC4  2  20 3B 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
000FC7  2  4C DB 0F             JMP     OP1EX
000FCA  2               
000FCA  2               OP1A:
000FCA  2  C9 10                CMP     #%00010000      ; TEST AGAIN
000FCC  2  D0 06                BNE     OP1B
000FCE  2  20 37 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
000FD1  2  4C DB 0F             JMP     OP1EX
000FD4  2               
000FD4  2               OP1B:
000FD4  2  C9 20                CMP     #%00100000      ; ONE MORE TEST
000FD6  2  D0 12                BNE     BADOP1          ; UNDEFINED STATE!
000FD8  2  20 4F 10             JSR     GETVAR          ; 10 = VARIABLE
000FDB  2               
000FDB  2               OP1EX:
000FDB  2  20 2C 10             JSR     V2A1            ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
000FDE  2  A2 A7                LDX     #<OPT1          ; GET ADDR OF 1-OP TABLE
000FE0  2  A0 11                LDY     #>OPT1          ; INTO [X/Y]
000FE2  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE
000FE4  2  29 0F                AND     #%00001111      ; ISOLATE OP ID BITS
000FE6  2  C9 10                CMP     #NOPS1          ; IF WITHIN RANGE,
000FE8  2  90 B0                BCC     DODIS           ; EXECUTE THE 1-OP
000FEA  2               
000FEA  2               ; *** ERROR #3 -- ILLEGAL 1-OP ***
000FEA  2               
000FEA  2               BADOP1:
000FEA  2  A9 03                LDA     #3
000FEC  2  4C B1 1D             JMP     ZERROR
000FEF  2               
000FEF  2               ; -------------
000FEF  2               ; HANDLE A 2-OP
000FEF  2               ; -------------
000FEF  2               
000FEF  2               OP2:
000FEF  2  29 40                AND     #%01000000      ; ISOLATE 1ST ARG BIT
000FF1  2  D0 06                BNE     OP2A
000FF3  2  20 37 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
000FF6  2  4C FC 0F             JMP     OP2B
000FF9  2               OP2A:
000FF9  2  20 4F 10             JSR     GETVAR          ; 1 = VARIABLE
000FFC  2               OP2B:
000FFC  2  20 2C 10             JSR     V2A1            ; [VALUE] TO [ARG1], UPDATE [NARGS]
000FFF  2               
000FFF  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
001001  2  29 20                AND     #%00100000      ; ISOLATE 2ND ARG BIT
001003  2  D0 06                BNE     OP2C
001005  2  20 37 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
001008  2  4C 0E 10             JMP     OP2D
00100B  2               OP2C:
00100B  2  20 4F 10             JSR     GETVAR          ; 1 = VARIABLE
00100E  2               OP2D:
00100E  2  A5 6C                LDA     VALUE+LO        ; MOVE 2ND [VALUE]
001010  2  85 64                STA     ARG2+LO         ; INTO [ARG2]
001012  2  A5 6D                LDA     VALUE+HI
001014  2  85 65                STA     ARG2+HI
001016  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNT
001018  2               
001018  2               ; EXECUTE A 2-OP OR EXTENDED 2-OP
001018  2               
001018  2               OP2EX:
001018  2  A2 C7                LDX     #<OPT2          ; LSB OF DISPATCH TABLE
00101A  2  A0 11                LDY     #>OPT2          ; MSB
00101C  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
00101E  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
001020  2  C9 19                CMP     #NOPS2
001022  2  B0 03                BCS     BADOP2          ; ERROR IF OUT OF RANGE
001024  2  4C 9A 0F             JMP     DODIS           ; ELSE DISPATCH
001027  2               
001027  2               ; *** ERROR #4 -- ILLEGAL 2-OP ****
001027  2               
001027  2               BADOP2:
001027  2  A9 04                LDA     #4
001029  2  4C B1 1D             JMP     ZERROR
00102C  2               
00102C  2               ; --------------------------------------
00102C  2               ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
00102C  2               ; --------------------------------------
00102C  2               
00102C  2               V2A1:
00102C  2  A5 6C                LDA     VALUE+LO
00102E  2  85 62                STA     ARG1+LO
001030  2  A5 6D                LDA     VALUE+HI
001032  2  85 63                STA     ARG1+HI
001034  2  E6 61                INC     NARGS
001036  2  60                   RTS
001037  2               
001037  1                       .INCLUDE "subs.asm"
001037  2               ;        PAGE
001037  2               ;        SBTTL   "--- OPCODE SUPPORT SUBROUTINES ---"
001037  2               
001037  2               ; -----------------------
001037  2               ; FETCH A SHORT IMMEDIATE
001037  2               ; -----------------------
001037  2               
001037  2               GETSHT:
001037  2  A9 00                LDA     #0              ; MSB IS ZERO
001039  2  F0 03                BEQ     GETV            ; FETCH LSB FROM Z-CODE
00103B  2               
00103B  2               ; ----------------------
00103B  2               ; FETCH A LONG IMMEDIATE
00103B  2               ; ----------------------
00103B  2               
00103B  2               GETLNG:
00103B  2  20 A9 19             JSR     NEXTPC          ; GRAB MSB
00103E  2               
00103E  2               GETV:
00103E  2  85 6D                STA     VALUE+HI
001040  2  20 A9 19             JSR     NEXTPC          ; GRAB LSB
001043  2  85 6C                STA     VALUE+LO
001045  2  60                   RTS
001046  2               
001046  2               ; ----------------
001046  2               ; FETCH A VARIABLE
001046  2               ; ----------------
001046  2               
001046  2               ; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
001046  2               
001046  2               VARGET:
001046  2  AA                   TAX                     ; IF NON-ZERO,
001047  2  D0 0B                BNE     GETVR1          ; ACCESS A VARIABLE
001049  2               
001049  2  20 75 10             JSR     POPVAL          ; ELSE PULL VAR OFF Z-STACK
00104C  2  4C 8B 10             JMP     PSHVAL          ; WITHOUT ALTERING STACK
00104F  2               
00104F  2               ; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
00104F  2               
00104F  2               GETVAR:
00104F  2  20 A9 19             JSR     NEXTPC          ; GRAB VAR-TYPE BYTE
001052  2  F0 21                BEQ     POPVAL          ; VALUE IS ON Z-STACK
001054  2               
001054  2               ; IS VARIABLE LOCAL OR GLOBAL?
001054  2               
001054  2               GETVR1:
001054  2  C9 10                CMP     #$10            ; IF >= 16,
001056  2  B0 10                BCS     GETVRG          ; IT'S GLOBAL
001058  2               
001058  2               ; HANDLE A LOCAL VARIABLE
001058  2               
001058  2               GETVRL:
001058  2  38                   SEC
001059  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
00105B  2  0A                   ASL     A               ; WORD INDEX
00105C  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
00105D  2               
00105D  2  BD 00 0D             LDA     LOCALS+LO,X     ; GRAB LSB
001060  2  85 6C                STA     VALUE+LO
001062  2  BD 01 0D             LDA     LOCALS+HI,X     ; AND MSB
001065  2  85 6D                STA     VALUE+HI
001067  2  60                   RTS
001068  2               
001068  2               ; HANDLE A GLOBAL VARIABLE
001068  2               
001068  2               GETVRG:
001068  2  20 D9 10             JSR     GVCALC          ; GET ADDRESS OF GLOBAL INTO [I]
00106B  2  B1 6E                LDA     (I),Y           ; MSB OF GLOBAL ([Y] = 0)
00106D  2  85 6D                STA     VALUE+HI
00106F  2  C8                   INY                     ; = 1
001070  2  B1 6E                LDA     (I),Y           ; LSB OF GLOBAL
001072  2  85 6C                STA     VALUE+LO        ; SAVE IT
001074  2  60                   RTS                     ; AND WE'RE DONE
001075  2               
001075  2               ; ----------------------------------
001075  2               ; POP Z-STACK INTO [VALUE] AND [X/A]
001075  2               ; ----------------------------------
001075  2               
001075  2               POPVAL:
001075  2  C6 74                DEC     ZSP
001077  2  F0 0D                BEQ     UNDER           ; UNDERFLOW IF ZERO!
001079  2               
001079  2  A4 74                LDY     ZSP             ; READ STACK POINTER
00107B  2  BE 00 09             LDX     ZSTAKL,Y        ; GRAB LSB OF STACK VALUE
00107E  2  86 6C                STX     VALUE+LO        ; GIVE TO [VALUE]
001080  2  B9 00 0A             LDA     ZSTAKH,Y        ; ALSO GRAB MSB
001083  2  85 6D                STA     VALUE+HI        ; A SIMILAR FATE
001085  2  60                   RTS
001086  2               
001086  2               ; *** ERROR #5 -- Z-STACK UNDERFLOW ***
001086  2               
001086  2               UNDER:
001086  2  A9 05                LDA     #5
001088  2  4C B1 1D             JMP     ZERROR
00108B  2               
00108B  2               ; -----------------------
00108B  2               ; PUSH [VALUE] TO Z-STACK
00108B  2               ; -----------------------
00108B  2               
00108B  2               PSHVAL:
00108B  2  A6 6C                LDX     VALUE+LO
00108D  2  A5 6D                LDA     VALUE+HI
00108F  2               
00108F  2               ; ---------------------
00108F  2               ; PUSH [X/A] TO Z-STACK
00108F  2               ; ---------------------
00108F  2               
00108F  2               PUSHXA:
00108F  2  A4 74                LDY     ZSP             ; READ STACK POINTER
001091  2  99 00 0A             STA     ZSTAKH,Y        ; PUSH MSB IN [A]
001094  2  8A                   TXA
001095  2  99 00 09             STA     ZSTAKL,Y        ; AND LSB IN [X]
001098  2               
001098  2  E6 74                INC     ZSP             ; UPDATE Z-STACK POINTER
00109A  2  F0 01                BEQ     OVER            ; OVERFLOW IF ZEROED!
00109C  2  60                   RTS
00109D  2               
00109D  2               ; *** ERROR #6 -- Z-STACK OVERFLOW ***
00109D  2               
00109D  2               OVER:
00109D  2  A9 06                LDA     #6
00109F  2  4C B1 1D             JMP     ZERROR
0010A2  2               
0010A2  2               ; --------------
0010A2  2               ; RETURN A VALUE
0010A2  2               ; --------------
0010A2  2               
0010A2  2               ; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
0010A2  2               
0010A2  2               VARPUT:
0010A2  2  AA                   TAX                     ; IF ZERO,
0010A3  2  D0 13                BNE     PUTVR1
0010A5  2               
0010A5  2  C6 74                DEC     ZSP             ; FLUSH TOP WORD OFF STACK
0010A7  2  D0 E2                BNE     PSHVAL          ; AND REPLACE WITH [VALUE]
0010A9  2  F0 DB                BEQ     UNDER           ; ERROR IF [ZSP] BECAME ZERO!
0010AB  2               
0010AB  2               ; RETURN A ZERO
0010AB  2               
0010AB  2               RET0:
0010AB  2  A9 00                LDA     #0
0010AD  2               
0010AD  2               ; RETURN BYTE IN [A]
0010AD  2               
0010AD  2               PUTBYT:
0010AD  2  85 6C                STA     VALUE+LO
0010AF  2  A9 00                LDA     #0
0010B1  2  85 6D                STA     VALUE+HI        ; CLEAR MSB
0010B3  2               
0010B3  2               ; RETURN [VALUE]
0010B3  2               
0010B3  2               PUTVAL:
0010B3  2  20 A9 19             JSR     NEXTPC          ; GET VARIABLE ID BYTE
0010B6  2  F0 D3                BEQ     PSHVAL          ; [VALUE] GOES TO Z-STACK
0010B8  2               
0010B8  2               ; LOCAL OR GLOBAL VARIABLE?
0010B8  2               
0010B8  2               PUTVR1:
0010B8  2  C9 10                CMP     #$10            ; IF >= 16,
0010BA  2  B0 10                BCS     PUTVLG          ; IT'S GLOBAL
0010BC  2               
0010BC  2               ; PUT A LOCAL VARIABLE
0010BC  2               
0010BC  2               PUTVLL:
0010BC  2  38                   SEC
0010BD  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
0010BF  2  0A                   ASL     A               ; WORD INDEX
0010C0  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
0010C1  2               
0010C1  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB
0010C3  2  9D 00 0D             STA     LOCALS+LO,X     ; SAVE IN LOCAL TABLE
0010C6  2  A5 6D                LDA     VALUE+HI        ; DO SAME TO
0010C8  2  9D 01 0D             STA     LOCALS+HI,X     ; MSB
0010CB  2  60                   RTS
0010CC  2               
0010CC  2               ; RETURN A GLOBAL VARIABLE
0010CC  2               
0010CC  2               PUTVLG:
0010CC  2  20 D9 10             JSR     GVCALC
0010CF  2  A5 6D                LDA     VALUE+HI        ; GET MSB
0010D1  2  91 6E                STA     (I),Y           ; STORE AS 1ST BYTE ([Y] = 0)
0010D3  2  C8                   INY                     ; = 1
0010D4  2  A5 6C                LDA     VALUE+LO        ; NOW GET LSB
0010D6  2  91 6E                STA     (I),Y           ; STORE AS 2ND BYTE
0010D8  2  60                   RTS
0010D9  2               
0010D9  2               ; -----------------------
0010D9  2               ; CALC GLOBAL WORD OFFSET
0010D9  2               ; -----------------------
0010D9  2               
0010D9  2               ; ENTRY: VAR-ID BYTE (16-255) IN [A]
0010D9  2               ; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [I]
0010D9  2               ;       [Y] = 0 FOR INDEXING
0010D9  2               
0010D9  2               GVCALC:
0010D9  2  38                   SEC
0010DA  2  E9 10                SBC     #$10            ; FORM A ZERO-ALIGNED INDEX
0010DC  2  A0 00                LDY     #0              ; MAKE SURE MSB OF OFFSET AND [Y]
0010DE  2  84 6F                STY     I+HI            ; ARE CLEARED
0010E0  2               
0010E0  2  0A                   ASL     A               ; MULTIPLY OFFSET BY 2
0010E1  2  26 6F                ROL     I+HI            ; TO WORD-ALIGN IT
0010E3  2               
0010E3  2  18                   CLC                     ; ADD OFFSET TO ADDR OF GLOBAL TABLE
0010E4  2  65 8C                ADC     GLOBAL+LO       ; TO FORM THE ABSOLUTE
0010E6  2  85 6E                STA     I+LO            ; ADDRESS OF THE
0010E8  2  A5 6F                LDA     I+HI            ; DESIRED GLOBAL VARIABLE
0010EA  2  65 8D                ADC     GLOBAL+HI       ; STORE ADDRESS BACK IN [VAL]
0010EC  2  85 6F                STA     I+HI            ; AS A POINTER
0010EE  2               
0010EE  2               WCEX:
0010EE  2  60                   RTS
0010EF  2               
0010EF  2               ; ---------------
0010EF  2               ; PREDICATE FAILS
0010EF  2               ; ---------------
0010EF  2               
0010EF  2               PREDF:
0010EF  2  20 A9 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
0010F2  2  10 0C                BPL     PREDB           ; DO BRANCH IF BIT 7 OFF
0010F4  2               
0010F4  2               ; -----------------------
0010F4  2               ; IGNORE PREDICATE BRANCH
0010F4  2               ; -----------------------
0010F4  2               
0010F4  2               ; ENTRY: 1ST BRANCH BYTE IN [A]
0010F4  2               
0010F4  2               PREDNB:
0010F4  2  29 40                AND     #%01000000      ; TEST BIT 6
0010F6  2  D0 F6                BNE     WCEX            ; SHORT BRANCH IF SET
0010F8  2  4C A9 19             JMP     NEXTPC          ; ELSE SKIP OVER 2ND BRANCH BYTE
0010FB  2               
0010FB  2               ; ------------------
0010FB  2               ; PREDICATE SUCCEEDS
0010FB  2               ; ------------------
0010FB  2               
0010FB  2               PREDS:
0010FB  2  20 A9 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
0010FE  2  10 F4                BPL     PREDNB          ; DON'T BRANCH IF BIT 7 CLEAR
001100  2               
001100  2               ; --------------------------
001100  2               ; PERFORM A PREDICATE BRANCH
001100  2               ; --------------------------
001100  2               
001100  2               ; ENTRY: 1ST PRED BYTE IN [A]
001100  2               
001100  2               PREDB:
001100  2  AA                   TAX                     ; SAVE HERE
001101  2  29 40                AND     #%01000000      ; LONG OR SHORT BRANCH?
001103  2  F0 0B                BEQ     PREDLB          ; LONG IF BIT 6 IS CLEAR
001105  2               
001105  2               ; HANDLE A SHORT BRANCH
001105  2               
001105  2  8A                   TXA                     ; RESTORE PRED BYTE
001106  2  29 3F                AND     #%00111111      ; FORM SHORT OFFSET
001108  2  85 6C                STA     VALUE+LO        ; USE AS LSB OF BRANCH OFFSET
00110A  2  A9 00                LDA     #0
00110C  2  85 6D                STA     VALUE+HI        ; MSB OF OFFSET IS ZERO
00110E  2  F0 13                BEQ     PREDB1          ; DO THE BRANCH
001110  2               
001110  2               ; HANDLE A LONG BRANCH
001110  2               
001110  2               PREDLB:
001110  2  8A                   TXA                     ; RESTORE 1ST PRED BYTE
001111  2  29 3F                AND     #%00111111      ; FORM MSB OF OFFSET
001113  2               
001113  2  AA                   TAX                     ; SAVE HERE FOR REFERENCE
001114  2               
001114  2  29 20                AND     #%00100000      ; CHECK SIGN OF 14-BIT VALUE
001116  2  F0 04                BEQ     DOB2            ; POSITIVE IF ZERO, SO USE [X]
001118  2               
001118  2  8A                   TXA                     ; ELSE RESTORE BYTE
001119  2  09 E0                ORA     #%11100000      ; EXTEND THE SIGN BIT
00111B  2  AA                   TAX                     ; BACK HERE FOR STORAGE
00111C  2               
00111C  2               DOB2:
00111C  2  86 6D                STX     VALUE+HI
00111E  2  20 A9 19             JSR     NEXTPC          ; FETCH LSB OF 14-BIT OFFSET
001121  2  85 6C                STA     VALUE+LO
001123  2               
001123  2               ; BRANCH TO Z-ADDRESS IN [VALUE]
001123  2               
001123  2               PREDB1:
001123  2  A5 6D                LDA     VALUE+HI        ; CHECK MSB OF OFFSET
001125  2  D0 0E                BNE     PREDB3          ; DO BRANCH IF NZ
001127  2               
001127  2  A5 6C                LDA     VALUE+LO        ; IF LSB IS NON-ZERO,
001129  2  D0 03                BNE     PREDB2          ; MAKE SURE IT ISN'T 1
00112B  2  4C 1C 12             JMP     ZRFALS          ; ELSE DO AN "RFALSE"
00112E  2               
00112E  2               PREDB2:
00112E  2  C9 01                CMP     #1              ; IF OFFSET = 1
001130  2  D0 03                BNE     PREDB3
001132  2  4C 11 12             JMP     ZRTRUE          ; DO AN "RTRUE"
001135  2               
001135  2               ; ENTRY POINT FOR "JUMP"
001135  2               
001135  2               PREDB3:
001135  2  20 6F 11             JSR     DECVAL          ; SUBTRACT 2 FROM THE OFFSET
001138  2  20 6F 11             JSR     DECVAL          ; IN [VALUE]
00113B  2               
00113B  2  A9 00                LDA     #0              ; CLEAR THE MSB
00113D  2  85 6F                STA     I+HI            ; OF [I]
00113F  2               
00113F  2  A5 6D                LDA     VALUE+HI        ; MAKE MSB OF OFFSET
001141  2  85 6E                STA     I+LO            ; THE LSB OF [I]
001143  2  0A                   ASL     A               ; EXTEND THE SIGN OF OFFSET
001144  2  26 6F                ROL     I+HI            ; INTO MSB OF [I]
001146  2               
001146  2  A5 6C                LDA     VALUE+LO        ; GET LSB OF OFFSET
001148  2  18                   CLC
001149  2  65 76                ADC     ZPCL            ; ADD LOW 8 BITS OF ZPC
00114B  2  90 06                BCC     PREDB5          ; IF OVERFLOWED,
00114D  2               
00114D  2  E6 6E                INC     I+LO            ; UPDATE UPPER 9 BITS
00114F  2  D0 02                BNE     PREDB5
001151  2  E6 6F                INC     I+HI
001153  2               
001153  2               PREDB5:
001153  2  85 76                STA     ZPCL            ; UPDATE ZPC
001155  2               
001155  2  A5 6E                LDA     I+LO            ; IF UPPER 9 BITS ARE ZERO,
001157  2  05 6F                ORA     I+HI            ; NO NEED TO CHANGE PAGES
001159  2  F0 13                BEQ     ZNOOP
00115B  2               
00115B  2  A5 6E                LDA     I+LO            ; ELSE CALC NEW UPPER BITS
00115D  2  18                   CLC
00115E  2  65 77                ADC     ZPCM
001160  2  85 77                STA     ZPCM
001162  2               
001162  2  A5 6F                LDA     I+HI
001164  2  65 78                ADC     ZPCH
001166  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
001168  2  85 78                STA     ZPCH
00116A  2               
00116A  2  A9 00                LDA     #0
00116C  2  85 79                STA     ZPCFLG          ; [ZPC] NO LONGER VALID
00116E  2               
00116E  2               ; FALL THROUGH ...
00116E  2               
00116E  2               ; ----
00116E  2               ; NOOP
00116E  2               ; ----
00116E  2               
00116E  2               ZNOOP:
00116E  2  60                   RTS
00116F  2               
00116F  2               ; -----------------
00116F  2               ; DECREMENT [VALUE]
00116F  2               ; -----------------
00116F  2               
00116F  2               DECVAL:
00116F  2  A5 6C                LDA     VALUE+LO
001171  2  38                   SEC
001172  2  E9 01                SBC     #1
001174  2  85 6C                STA     VALUE+LO
001176  2  B0 02                BCS     DVX
001178  2  C6 6D                DEC     VALUE+HI
00117A  2               DVX:
00117A  2  60                   RTS
00117B  2               
00117B  2               ; -----------------
00117B  2               ; INCREMENT [VALUE]
00117B  2               ; -----------------
00117B  2               
00117B  2               INCVAL:
00117B  2  E6 6C                INC     VALUE+LO
00117D  2  D0 02                BNE     IVX
00117F  2  E6 6D                INC     VALUE+HI
001181  2               IVX:
001181  2  60                   RTS
001182  2               
001182  2               ; ----------------------
001182  2               ; MOVE [ARG1] TO [VALUE]
001182  2               ; ----------------------
001182  2               
001182  2               A12VAL:
001182  2  A5 62                LDA     ARG1+LO
001184  2  85 6C                STA     VALUE+LO
001186  2  A5 63                LDA     ARG1+HI
001188  2  85 6D                STA     VALUE+HI
00118A  2  60                   RTS
00118B  2               
00118B  1                       .INCLUDE "dispatch.asm"
00118B  2               ;        PAGE
00118B  2               ;        SBTTL   "--- OPCODE DISPATCH TABLES ---"
00118B  2               
00118B  2               ; 0-OPS
00118B  2               
00118B  2               OPT0:
00118B  2  11 12                .WORD   ZRTRUE          ; 0
00118D  2  1C 12                .WORD   ZRFALS          ; 1
00118F  2  20 12                .WORD   ZPRI            ; 2
001191  2  3D 12                .WORD   ZPRR            ; 3
001193  2  6E 11                .WORD   ZNOOP           ; 4
001195  2  14 23                .WORD   ZSAVE           ; 5
001197  2  30 24                .WORD   ZREST           ; 6
001199  2  F0 1D                .WORD   ZSTART          ; 7
00119B  2  46 12                .WORD   ZRSTAK          ; 8
00119D  2  75 10                .WORD   POPVAL          ; 9
00119F  2  CF 1D                .WORD   ZQUIT           ; 10
0011A1  2  D0 1E                .WORD   ZCRLF           ; 11
0011A3  2  42 1F                .WORD   ZUSL            ; 12
0011A5  2  4C 12                .WORD   ZVER            ; 13
0011A7  2               
0011A7  2               NOPS0           = 14            ; NUMBER OF 0-OPS
0011A7  2               
0011A7  2               ; 1-OPS
0011A7  2               
0011A7  2               OPT1:
0011A7  2  AA 12                .WORD   ZZERO           ; 0
0011A9  2  B3 12                .WORD   ZNEXT           ; 1
0011AB  2  BC 12                .WORD   ZFIRST          ; 2
0011AD  2  CF 12                .WORD   ZLOC            ; 3
0011AF  2  DB 12                .WORD   ZPTSIZ          ; 4
0011B1  2  F8 12                .WORD   ZINC            ; 5
0011B3  2  03 13                .WORD   ZDEC            ; 6
0011B5  2  10 13                .WORD   ZPRB            ; 7
0011B7  2  EA 0F                .WORD   BADOP1          ; 8 (UNDEFINED)
0011B9  2  1E 13                .WORD   ZREMOV          ; 9
0011BB  2  60 13                .WORD   ZPRD            ; 10
0011BD  2  7D 13                .WORD   ZRET            ; 11
0011BF  2  C5 13                .WORD   ZJUMP           ; 12
0011C1  2  CB 13                .WORD   ZPRINT          ; 13
0011C3  2  D9 13                .WORD   ZVALUE          ; 14
0011C5  2  E1 13                .WORD   ZBCOM           ; 15
0011C7  2               
0011C7  2               NOPS1           = 16            ; NUMBER OF 1-OPS
0011C7  2               
0011C7  2               ; 2-OPS
0011C7  2               
0011C7  2               OPT2:
0011C7  2  27 10                .WORD   BADOP2          ; 0 (UNDEFINED)
0011C9  2  8F 16                .WORD   ZEQUAL          ; 1
0011CB  2  F1 13                .WORD   ZLESS           ; 2
0011CD  2  05 14                .WORD   ZGRTR           ; 3
0011CF  2  F7 13                .WORD   ZDLESS          ; 4
0011D1  2  10 14                .WORD   ZIGRTR          ; 5
0011D3  2  40 14                .WORD   ZIN             ; 6
0011D5  2  50 14                .WORD   ZBTST           ; 7
0011D7  2  63 14                .WORD   ZBOR            ; 8
0011D9  2  6F 14                .WORD   ZBAND           ; 9
0011DB  2  7B 14                .WORD   ZFSETP          ; 10
0011DD  2  8F 14                .WORD   ZFSET           ; 11
0011DF  2  A2 14                .WORD   ZFCLR           ; 12
0011E1  2  B9 14                .WORD   ZSET            ; 13
0011E3  2  C6 14                .WORD   ZMOVE           ; 14
0011E5  2  F0 14                .WORD   ZGET            ; 15
0011E7  2  00 15                .WORD   ZGETB           ; 16
0011E9  2  1D 15                .WORD   ZGETP           ; 17
0011EB  2  65 15                .WORD   ZGETPT          ; 18
0011ED  2  92 15                .WORD   ZNEXTP          ; 19
0011EF  2  B1 15                .WORD   ZADD            ; 20
0011F1  2  BE 15                .WORD   ZSUB            ; 21
0011F3  2  CB 15                .WORD   ZMUL            ; 22
0011F5  2  EF 15                .WORD   ZDIV            ; 23
0011F7  2  F9 15                .WORD   ZMOD            ; 24
0011F9  2               
0011F9  2               NOPS2           = 25            ; NUMBER OF 2-OPS
0011F9  2               
0011F9  2               ; X-OPS
0011F9  2               
0011F9  2               OPTX:
0011F9  2  C2 16                .WORD   ZCALL           ; 0
0011FB  2  57 17                .WORD   ZPUT            ; 1
0011FD  2  65 17                .WORD   ZPUTB           ; 2
0011FF  2  80 17                .WORD   ZPUTP           ; 3
001201  2  2C 18                .WORD   ZREAD           ; 4
001203  2  B1 17                .WORD   ZPRC            ; 5
001205  2  B6 17                .WORD   ZPRN            ; 6
001207  2  FB 17                .WORD   ZRAND           ; 7
001209  2  1D 18                .WORD   ZPUSH           ; 8
00120B  2  24 18                .WORD   ZPOP            ; 9
00120D  2  84 21                .WORD   ZSPLIT          ; 10
00120F  2  85 21                .WORD   ZSCRN           ; 11
001211  2               
001211  2               NOPSX           = 12            ; NUMBER OF X-OPS
001211  2               
001211  1               
001211  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OPCODE EXECUTORS"
001211  1                       .INCLUDE "ops0.asm"
001211  2               ;        PAGE
001211  2               ;        SBTTL   "--- 0-OPS ---"
001211  2               
001211  2               ; -----
001211  2               ; RTRUE
001211  2               ; -----
001211  2               
001211  2               ; SIMULATE A "RETURN 1"
001211  2               
001211  2               ZRTRUE:
001211  2  A2 01                LDX     #1
001213  2               
001213  2               ZRT0:
001213  2  A9 00                LDA     #0
001215  2               
001215  2               ZRT1:
001215  2  86 62                STX     ARG1+LO         ; GIVE TO
001217  2  85 63                STA     ARG1+HI         ; [ARG1]
001219  2  4C 7D 13             JMP     ZRET            ; AND DO THE RETURN
00121C  2               
00121C  2               ; ------
00121C  2               ; RFALSE
00121C  2               ; ------
00121C  2               
00121C  2               ; SIMULATE A "RETURN 0"
00121C  2               
00121C  2               ZRFALS:
00121C  2  A2 00                LDX     #0
00121E  2  F0 F3                BEQ     ZRT0
001220  2               
001220  2               ; ------
001220  2               ; PRINTI
001220  2               ; ------
001220  2               
001220  2               ; PRINT Z-STRING FOLLOWING THE OPCODE
001220  2               
001220  2               ZPRI:
001220  2  A5 78                LDA     ZPCH            ; MOVE [ZPC] INTO [MPC]
001222  2  85 7E                STA     MPCH
001224  2  A5 77                LDA     ZPCM
001226  2  85 7D                STA     MPCM
001228  2  A5 76                LDA     ZPCL
00122A  2  85 7C                STA     MPCL
00122C  2               
00122C  2  A9 00                LDA     #0
00122E  2  85 7F                STA     MPCFLG          ; [MPC] NO LONGER VALID
001230  2               
001230  2  20 FA 1A             JSR     PZSTR           ; PRINT THE Z-STRING AT [MPC]
001233  2               
001233  2  A2 05                LDX     #5              ; COPY STATE OF [MPC]
001235  2               PRIL:
001235  2  B5 7C                LDA     MPC,X           ; INTO [ZPC]
001237  2  95 76                STA     ZPC,X
001239  2  CA                   DEX
00123A  2  10 F9                BPL     PRIL
00123C  2  60                   RTS
00123D  2               
00123D  2               ; ------
00123D  2               ; PRINTR
00123D  2               ; ------
00123D  2               
00123D  2               ; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
00123D  2               
00123D  2               ZPRR:
00123D  2  20 20 12             JSR     ZPRI
001240  2  20 D0 1E             JSR     ZCRLF
001243  2  4C 11 12             JMP     ZRTRUE
001246  2               
001246  2               ; ------
001246  2               ; RSTACK
001246  2               ; ------
001246  2               
001246  2               ; "RETURN" WITH VALUE ON STACK
001246  2               
001246  2               ZRSTAK:
001246  2  20 75 10             JSR     POPVAL          ; GET VALUE INTO [X/A]
001249  2  4C 15 12             JMP     ZRT1            ; AND GIVE IT TO "RETURN"
00124C  2               
00124C  2               ; ------
00124C  2               ; VERIFY
00124C  2               ; ------
00124C  2               
00124C  2               ; VERIFY GAME CODE ON DISK
00124C  2               
00124C  2               ZVER:
00124C  2  20 0F 1E             JSR     VERNUM          ; DISPLAY ZIP VERSION NUMBER
00124F  2               
00124F  2  A2 03                LDX     #3
001251  2  A9 00                LDA     #0
001253  2               ZVR:
001253  2  95 70                STA     J+LO,X          ; CLEAR [J], [K]
001255  2  95 7C                STA     MPC,X           ; [MPC] AND [MPCFLG]
001257  2  CA                   DEX
001258  2  10 F9                BPL     ZVR
00125A  2               
00125A  2  A9 40                LDA     #64             ; POINT [MPC] TO Z-ADDRESS $00040
00125C  2  85 7C                STA     MPCL            ; 1ST 64 BYTES AREN'T CHECKED
00125E  2               
00125E  2  AD 1A 2B             LDA     ZBEGIN+ZLENTH   ; GET LENGTH OF Z-CODE
001261  2  85 6F                STA     I+HI            ; IN WORDS
001263  2  AD 1B 2B             LDA     ZBEGIN+ZLENTH+1 ; FIRST MSB
001266  2  85 6E                STA     I+LO            ; THEN LSB
001268  2               
001268  2  06 6E                ASL     I+LO            ; CONVERT Z-CODE LENGTH
00126A  2  26 6F                ROL     I+HI            ; TO # BYTES
00126C  2  26 72                ROL     K+LO            ; TOP BIT IN [K+LO]
00126E  2               
00126E  2  A9 73                LDA     #K+HI           ; PATCH THE "GETBYT" ROUTINE
001270  2  8D EA 19             STA     PATCH           ; TO USE [K+HI]=0 INSTEAD OF [ZPURE]
001273  2               
001273  2               VSUM:
001273  2  20 DF 19             JSR     GETBYT          ; GET A Z-BYTE INTO [A]
001276  2  18                   CLC
001277  2  65 70                ADC     J+LO            ; ADD IT TO SUM
001279  2  85 70                STA     J+LO            ; IN [J]
00127B  2  90 02                BCC     VSUM0
00127D  2  E6 71                INC     J+HI
00127F  2               
00127F  2               VSUM0:
00127F  2  A5 7C                LDA     MPCL            ; END OF Z-CODE YET?
001281  2  C5 6E                CMP     I+LO            ; CHECK LSB
001283  2  D0 EE                BNE     VSUM
001285  2               
001285  2  A5 7D                LDA     MPCM            ; MIDDLE BYTE
001287  2  C5 6F                CMP     I+HI
001289  2  D0 E8                BNE     VSUM
00128B  2               
00128B  2  A5 7E                LDA     MPCH            ; AND HIGH BIT
00128D  2  C5 72                CMP     K+LO
00128F  2  D0 E2                BNE     VSUM
001291  2               
001291  2  A9 84                LDA     #ZPURE          ; UNPATCH "GETBYT"
001293  2  8D EA 19             STA     PATCH
001296  2               
001296  2  AD 1D 2B             LDA     ZBEGIN+ZCHKSM+1 ; GET LSB OF CHECKSUM
001299  2  C5 70                CMP     J+LO            ; DOES IT MATCH?
00129B  2  D0 0A                BNE     BADVER          ; NO, PREDICATE FAILS
00129D  2               
00129D  2  AD 1C 2B             LDA     ZBEGIN+ZCHKSM   ; ELSE CHECK MSB
0012A0  2  C5 71                CMP     J+HI            ; LOOK GOOD?
0012A2  2  D0 03                BNE     BADVER          ; IF MATCHED,
0012A4  2  4C FB 10             JMP     PREDS           ; GAME IS OKAY
0012A7  2               
0012A7  2               BADVER:
0012A7  2  4C EF 10             JMP     PREDF
0012AA  2               
0012AA  1                       .INCLUDE "ops1.asm"
0012AA  2               ;        PAGE
0012AA  2               ;        SBTTL   "--- 1-OPS ---"
0012AA  2               
0012AA  2               ; -----
0012AA  2               ; ZERO?
0012AA  2               ; -----
0012AA  2               
0012AA  2               ; [ARG1] = 0?
0012AA  2               
0012AA  2               ZZERO:
0012AA  2  A5 62                LDA     ARG1+LO
0012AC  2  05 63                ORA     ARG1+HI
0012AE  2  F0 1C                BEQ     PFINE
0012B0  2               
0012B0  2               PYUCK:
0012B0  2  4C EF 10             JMP     PREDF
0012B3  2               
0012B3  2               ; -----
0012B3  2               ; NEXT?
0012B3  2               ; -----
0012B3  2               
0012B3  2               ; RETURN "NEXT" POINTER IN OBJECT [ARG1];
0012B3  2               ; FAIL IF LAST AND RETURN ZERO
0012B3  2               
0012B3  2               ZNEXT:
0012B3  2  A5 62                LDA     ARG1+LO
0012B5  2  20 05 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012B8  2  A0 05                LDY     #5              ; POINT TO "NEXT" SLOT
0012BA  2  D0 07                BNE     FIRST1
0012BC  2               
0012BC  2               ; ------
0012BC  2               ; FIRST?
0012BC  2               ; ------
0012BC  2               
0012BC  2               ; RETURN "FIRST" POINTER IN OBJECT [ARG1];
0012BC  2               ; FAIL IF LAST AND RETURN ZERO
0012BC  2               
0012BC  2               ZFIRST:
0012BC  2  A5 62                LDA     ARG1+LO
0012BE  2  20 05 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012C1  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
0012C3  2               
0012C3  2               FIRST1:
0012C3  2  B1 6E                LDA     (I),Y           ; GET CONTENTS OF SLOT
0012C5  2  20 AD 10             JSR     PUTBYT          ; PASS IT TO VARIABLE
0012C8  2               
0012C8  2  A5 6C                LDA     VALUE+LO        ; EXAMINE THE VALUE JUST "PUT"
0012CA  2  F0 E4                BEQ     PYUCK           ; FAIL IF IT WAS ZERO
0012CC  2               
0012CC  2               PFINE:
0012CC  2  4C FB 10             JMP     PREDS           ; ELSE REJOICE
0012CF  2               
0012CF  2               ; ---
0012CF  2               ; LOC
0012CF  2               ; ---
0012CF  2               
0012CF  2               ; RETURN THE OBJECT CONTAINING OBJECT [ARG1];
0012CF  2               ; RETURN ZERO IF NONE
0012CF  2               
0012CF  2               ZLOC:
0012CF  2  A5 62                LDA     ARG1+LO
0012D1  2  20 05 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
0012D4  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
0012D6  2  B1 6E                LDA     (I),Y           ; GET THE BYTE
0012D8  2  4C AD 10             JMP     PUTBYT          ; AND SHIP IT OUT
0012DB  2               
0012DB  2               ; ------
0012DB  2               ; PTSIZE
0012DB  2               ; ------
0012DB  2               
0012DB  2               ; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
0012DB  2               
0012DB  2               ZPTSIZ:
0012DB  2  A5 63                LDA     ARG1+HI         ; MOVE ABS ADDR OF
0012DD  2  18                   CLC                     ; THE PROP TABLE
0012DE  2  65 83                ADC     ZCODE           ; INTO [I]
0012E0  2  85 6F                STA     I+HI
0012E2  2               
0012E2  2  A5 62                LDA     ARG1+LO         ; DECREMENT THE
0012E4  2  38                   SEC                     ; ADDRESS
0012E5  2  E9 01                SBC     #1              ; WHILE MOVING LSB
0012E7  2  85 6E                STA     I+LO
0012E9  2  B0 02                BCS     PTZ0
0012EB  2  C6 6F                DEC     I+HI
0012ED  2               
0012ED  2               PTZ0:
0012ED  2  A0 00                LDY     #0              ; GET THE LENGTH
0012EF  2  20 4F 1D             JSR     PROPL           ; OF PROPERTY AT [I] INTO [A]
0012F2  2               
0012F2  2  18                   CLC
0012F3  2  69 01                ADC     #1              ; INCREMENT RESULT
0012F5  2  4C AD 10             JMP     PUTBYT          ; AND RETURN IT
0012F8  2               
0012F8  2               ; ---
0012F8  2               ; INC
0012F8  2               ; ---
0012F8  2               
0012F8  2               ; INCREMENT VARIABLE [ARG1]
0012F8  2               
0012F8  2               ZINC:
0012F8  2  A5 62                LDA     ARG1+LO
0012FA  2  20 46 10             JSR     VARGET          ; FETCH VARIABLE INTO [VALUE]
0012FD  2  20 7B 11             JSR     INCVAL          ; INCREMENT IT
001300  2  4C 0B 13             JMP     ZD0
001303  2               
001303  2               ; ---
001303  2               ; DEC
001303  2               ; ---
001303  2               
001303  2               ; DECREMENT VARIABLE [ARG1]
001303  2               
001303  2               ZDEC:
001303  2  A5 62                LDA     ARG1+LO
001305  2  20 46 10             JSR     VARGET          ; FETCH VAR INTO [VALUE]
001308  2  20 6F 11             JSR     DECVAL          ; DECREMENT IT
00130B  2               
00130B  2               ZD0:
00130B  2  A5 62                LDA     ARG1+LO         ; PUT RESULT BACK
00130D  2  4C A2 10             JMP     VARPUT          ; INTO THE SAME VARIABLE
001310  2               
001310  2               ; ------
001310  2               ; PRINTB
001310  2               ; ------
001310  2               
001310  2               ; PRINT Z-STRING AT [ARG1]
001310  2               
001310  2               ZPRB:
001310  2  A5 62                LDA     ARG1+LO
001312  2  85 6E                STA     I+LO
001314  2  A5 63                LDA     ARG1+HI
001316  2  85 6F                STA     I+HI
001318  2               
001318  2  20 CE 1A             JSR     SETWRD          ; MOVE Z-ADDR TO [MPC]
00131B  2  4C FA 1A             JMP     PZSTR           ; AND PRINT
00131E  2               
00131E  2               ; ------
00131E  2               ; REMOVE
00131E  2               ; ------
00131E  2               
00131E  2               ; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
00131E  2               
00131E  2               ZREMOV:
00131E  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ADDR
001320  2  20 05 1D             JSR     OBJLOC          ; INTO [I]
001323  2               
001323  2  A5 6E                LDA     I+LO            ; COPY THE SOURCE ADDR
001325  2  85 70                STA     J+LO            ; INTO [J]
001327  2  A5 6F                LDA     I+HI            ; FOR LATER REFERENCE
001329  2  85 71                STA     J+HI
00132B  2               
00132B  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
00132D  2  B1 6E                LDA     (I),Y           ; GET THE DATA
00132F  2  F0 2E                BEQ     REMVEX          ; SCRAM IF NO OBJECT
001331  2               
001331  2  20 05 1D             JSR     OBJLOC          ; ELSE GET ADDR OF OBJECT [A] INTO [I]
001334  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
001336  2  B1 6E                LDA     (I),Y           ; GRAB DATA
001338  2  C5 62                CMP     ARG1+LO         ; IS THIS THE FIRST?
00133A  2  D0 09                BNE     REMVC1          ; NO, KEEP SEARCHING
00133C  2               
00133C  2  A0 05                LDY     #5              ; ELSE COPY SOURCE'S "NEXT" SLOT
00133E  2  B1 70                LDA     (J),Y
001340  2  C8                   INY                     ; INTO DEST'S "FIRST" SLOT ([Y] = 6)
001341  2  91 6E                STA     (I),Y
001343  2  D0 11                BNE     REMVC2          ; BRANCH ALWAYS
001345  2               
001345  2               REMVC1:
001345  2  20 05 1D             JSR     OBJLOC
001348  2  A0 05                LDY     #5              ; GET "NEXT"
00134A  2  B1 6E                LDA     (I),Y
00134C  2  C5 62                CMP     ARG1+LO         ; FOUND IT?
00134E  2  D0 F5                BNE     REMVC1          ; NO, KEEP TRYING
001350  2               
001350  2  A0 05                LDY     #5              ; WHEN FOUND
001352  2  B1 70                LDA     (J),Y           ; MOVE "NEXT" SLOT OF SOURCE
001354  2  91 6E                STA     (I),Y           ; TO "NEXT" SLOT OF DEST
001356  2               
001356  2               REMVC2:
001356  2  A9 00                LDA     #0
001358  2  A0 04                LDY     #4              ; CLEAR "LOC"
00135A  2  91 70                STA     (J),Y
00135C  2  C8                   INY                     ; AND "NEXT" SLOTS ([Y] = 5)
00135D  2  91 70                STA     (J),Y           ; OF SOURCE OBJECT
00135F  2               
00135F  2               REMVEX:
00135F  2  60                   RTS
001360  2               
001360  2               ; ------
001360  2               ; PRINTD
001360  2               ; ------
001360  2               
001360  2               ; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
001360  2               
001360  2               ZPRD:
001360  2  A5 62                LDA     ARG1+LO
001362  2               
001362  2               ; ENTRY POINT FOR "USL"
001362  2               
001362  2               PRNTDC:
001362  2  20 05 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
001365  2  A0 07                LDY     #7              ; GET PROP TABLE POINTER
001367  2  B1 6E                LDA     (I),Y           ; FETCH MSB
001369  2  AA                   TAX                     ; SAVE IT HERE
00136A  2  C8                   INY
00136B  2  B1 6E                LDA     (I),Y           ; FETCH LSB
00136D  2  85 6E                STA     I+LO            ; STORE LSB
00136F  2  86 6F                STX     I+HI            ; AND MSB
001371  2               
001371  2  E6 6E                INC     I+LO            ; POINT PAST THE
001373  2  D0 02                BNE     PDC0            ; LENGTH BYTE
001375  2  E6 6F                INC     I+HI
001377  2               
001377  2               PDC0:
001377  2  20 CE 1A             JSR     SETWRD          ; CALC Z-STRING ADDR
00137A  2  4C FA 1A             JMP     PZSTR           ; AND PRINT IT
00137D  2               
00137D  2               ; ------
00137D  2               ; RETURN
00137D  2               ; ------
00137D  2               
00137D  2               ; RETURN FROM "CALL" WITH VALUE [ARG1]
00137D  2               
00137D  2               ZRET:
00137D  2  A5 75                LDA     OLDZSP          ; RE-SYNC THE
00137F  2  85 74                STA     ZSP             ; Z-STACK POINTER
001381  2               
001381  2  20 75 10             JSR     POPVAL          ; POP # LOCALS INTO [X/A]
001384  2  86 6F                STX     I+HI            ; SAVE HERE
001386  2               
001386  2               ; MAKE SURE [X] WAS COMPLEMENT OF [A] (BM 11/24/84)
001386  2               
001386  2  49 FF                EOR     #$FF            ; COMPLEMENT [A]
001388  2  C5 6F                CMP     I+HI            ; MATCHED?
00138A  2  D0 34                BNE     STKERR          ; ERROR IF NOT
00138C  2               
00138C  2  8A                   TXA                     ; SET FLAGS; ANY LOCALS?
00138D  2  F0 19                BEQ     RET2            ; SKIP IF NOT
00138F  2               
00138F  2               ; RESTORE PUSHED LOCALS
00138F  2               
00138F  2  CA                   DEX                     ; ZERO-ALIGN
001390  2  8A                   TXA                     ; AND
001391  2  0A                   ASL     A               ; WORD-ALIGN # LOCALS
001392  2  85 6E                STA     I+LO            ; FOR USE AS A STORAGE INDEX
001394  2               
001394  2               RET1:
001394  2  20 75 10             JSR     POPVAL          ; POP A LOCAL INTO [X/A]
001397  2               
001397  2  A4 6E                LDY     I+LO            ; RETRIEVE STORAGE INDEX
001399  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE MSB OF LOCAL
00139C  2  8A                   TXA                     ; MOVE LSB
00139D  2  99 00 0D             STA     LOCALS+LO,Y     ; AND STORE THAT TOO
0013A0  2               
0013A0  2  C6 6E                DEC     I+LO
0013A2  2  C6 6E                DEC     I+LO            ; UPDATE STORAGE INDEX
0013A4  2               
0013A4  2  C6 6F                DEC     I+HI            ; AND LOCALS COUNT
0013A6  2  D0 EC                BNE     RET1            ; POP TILL NO MORE LOCALS
0013A8  2               
0013A8  2               ; RESTORE OTHER VARIABLES
0013A8  2               
0013A8  2               RET2:
0013A8  2  20 75 10             JSR     POPVAL          ; POP [ZPCH] AND [ZPCM]
0013AB  2  86 77                STX     ZPCM
0013AD  2  85 78                STA     ZPCH
0013AF  2               
0013AF  2  20 75 10             JSR     POPVAL          ; POP AND RESTORE
0013B2  2  86 75                STX     OLDZSP
0013B4  2  85 76                STA     ZPCL
0013B6  2               
0013B6  2  A9 00                LDA     #0
0013B8  2  85 79                STA     ZPCFLG          ; ZPC CHANGED!
0013BA  2               
0013BA  2  20 82 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
0013BD  2  4C B3 10             JMP     PUTVAL          ; AND RETURN IT
0013C0  2               
0013C0  2               ; *** ERROR #15: Z-STACK DESTROYED ***
0013C0  2               
0013C0  2               STKERR:
0013C0  2  A9 0F                LDA     #15             ; (BM 11/24/84)
0013C2  2  4C B1 1D             JMP     ZERROR
0013C5  2               
0013C5  2               ; ----
0013C5  2               ; JUMP
0013C5  2               ; ----
0013C5  2               
0013C5  2               ; JUMP TO Z-LOCATION IN [ARG1]
0013C5  2               
0013C5  2               ZJUMP:
0013C5  2  20 82 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
0013C8  2  4C 35 11             JMP     PREDB3          ; A BRANCH THAT ALWAYS SUCCEEDS
0013CB  2               
0013CB  2               ; -----
0013CB  2               ; PRINT
0013CB  2               ; -----
0013CB  2               
0013CB  2               ; PRINT Z-STRING AT WORD POINTER [ARG1]
0013CB  2               
0013CB  2               ZPRINT:
0013CB  2  A5 62                LDA     ARG1+LO
0013CD  2  85 6E                STA     I+LO
0013CF  2  A5 63                LDA     ARG1+HI
0013D1  2  85 6F                STA     I+HI
0013D3  2               
0013D3  2  20 E8 1A             JSR     SETSTR          ; CALC STRING ADDRESS
0013D6  2  4C FA 1A             JMP     PZSTR           ; AND PRINT IT
0013D9  2               
0013D9  2               ; -----
0013D9  2               ; VALUE
0013D9  2               ; -----
0013D9  2               
0013D9  2               ; RETURN VALUE OF VARIABLE [ARG1]
0013D9  2               
0013D9  2               ZVALUE:
0013D9  2  A5 62                LDA     ARG1+LO
0013DB  2  20 46 10             JSR     VARGET          ; GET THE VALUE
0013DE  2  4C B3 10             JMP     PUTVAL          ; EASY ENOUGH
0013E1  2               
0013E1  2               ; ----
0013E1  2               ; BCOM
0013E1  2               ; ----
0013E1  2               
0013E1  2               ; COMPLEMENT [ARG1]
0013E1  2               
0013E1  2               ZBCOM:
0013E1  2  A5 62                LDA     ARG1+LO
0013E3  2  49 FF                EOR     #$FF
0013E5  2  AA                   TAX
0013E6  2  A5 63                LDA     ARG1+HI
0013E8  2  49 FF                EOR     #$FF
0013EA  2               
0013EA  2               ; FALL THROUGH ...
0013EA  2               
0013EA  2               ; ---------------------
0013EA  2               ; RETURN VALUE IN [X/A]
0013EA  2               ; ---------------------
0013EA  2               
0013EA  2               VEXIT:
0013EA  2  86 6C                STX     VALUE+LO
0013EC  2  85 6D                STA     VALUE+HI
0013EE  2  4C B3 10             JMP     PUTVAL
0013F1  2               
0013F1  1                       .INCLUDE "ops2.asm"
0013F1  2               ;        PAGE
0013F1  2               ;        SBTTL   "--- 2-OPS ---"
0013F1  2               
0013F1  2               ; -----
0013F1  2               ; LESS?
0013F1  2               ; -----
0013F1  2               
0013F1  2               ; [ARG1] < [ARG2]?
0013F1  2               
0013F1  2               ZLESS:
0013F1  2  20 82 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
0013F4  2  4C FA 13             JMP     DLS0            ; MOVE [ARG2] TO [I] & COMPARE
0013F7  2               
0013F7  2               ; ------
0013F7  2               ; DLESS?
0013F7  2               ; ------
0013F7  2               
0013F7  2               ; DECREMENT [ARG1]; SUCCEED IF < [ARG2]
0013F7  2               
0013F7  2               ZDLESS:
0013F7  2  20 03 13             JSR     ZDEC            ; MOVES ([ARG1]-1) TO [VALUE]
0013FA  2               
0013FA  2               DLS0:
0013FA  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [I]
0013FC  2  85 6E                STA     I+LO
0013FE  2  A5 65                LDA     ARG2+HI
001400  2  85 6F                STA     I+HI
001402  2               
001402  2  4C 23 14             JMP     COMPAR          ; COMPARE & RETURN
001405  2               
001405  2               ; -----
001405  2               ; GRTR?
001405  2               ; -----
001405  2               
001405  2               ; [ARG1] > [ARG2]?
001405  2               
001405  2               ZGRTR:
001405  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [I]
001407  2  85 6E                STA     I+LO
001409  2  A5 63                LDA     ARG1+HI
00140B  2  85 6F                STA     I+HI
00140D  2               
00140D  2  4C 1B 14             JMP     A2VAL           ; MOVE [ARG2] TO [VALUE] & COMPARE
001410  2               
001410  2               ; ------
001410  2               ; IGRTR?
001410  2               ; ------
001410  2               
001410  2               ; INCREMENT [ARG1]; SUCCEED IF GREATER THAN [ARG2]
001410  2               
001410  2               ZIGRTR:
001410  2  20 F8 12             JSR     ZINC            ; GET ([ARG1]+1) INTO [VALUE]
001413  2               
001413  2  A5 6C                LDA     VALUE+LO        ; MOVE [VALUE] TO [I]
001415  2  85 6E                STA     I+LO
001417  2  A5 6D                LDA     VALUE+HI
001419  2  85 6F                STA     I+HI
00141B  2               
00141B  2               A2VAL:
00141B  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [VALUE]
00141D  2  85 6C                STA     VALUE+LO
00141F  2  A5 65                LDA     ARG2+HI
001421  2  85 6D                STA     VALUE+HI
001423  2               
001423  2               COMPAR:
001423  2  20 2A 14             JSR     SCOMP           ; COMPARE [VALUE] AND [I]
001426  2  90 38                BCC     PGOOD
001428  2  B0 23                BCS     PBAD
00142A  2               
00142A  2               ; -----------------
00142A  2               ; SIGNED COMPARISON
00142A  2               ; -----------------
00142A  2               
00142A  2               ; ENTRY: VALUES IN [VALUE] AND [I]
00142A  2               
00142A  2               SCOMP:
00142A  2  A5 6F                LDA     I+HI
00142C  2  45 6D                EOR     VALUE+HI
00142E  2  10 05                BPL     SCMP
001430  2  A5 6F                LDA     I+HI
001432  2  C5 6D                CMP     VALUE+HI
001434  2  60                   RTS
001435  2               
001435  2               SCMP:
001435  2  A5 6D                LDA     VALUE+HI
001437  2  C5 6F                CMP     I+HI
001439  2  D0 04                BNE     SCEX
00143B  2  A5 6C                LDA     VALUE+LO
00143D  2  C5 6E                CMP     I+LO
00143F  2               SCEX:
00143F  2  60                   RTS
001440  2               
001440  2               ; ---
001440  2               ; IN?
001440  2               ; ---
001440  2               
001440  2               ; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
001440  2               
001440  2               ZIN:
001440  2  A5 62                LDA     ARG1+LO
001442  2  20 05 1D             JSR     OBJLOC          ; GET ADDR OF TARGET OBJECT INTO [I]
001445  2               
001445  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001447  2  B1 6E                LDA     (I),Y           ; GET DATA
001449  2  C5 64                CMP     ARG2+LO         ; IS IT THERE?
00144B  2  F0 13                BEQ     PGOOD           ; YES, SUCCEED
00144D  2               
00144D  2               PBAD:
00144D  2  4C EF 10             JMP     PREDF           ; TOO BAD, CHUM ...
001450  2               
001450  2               ; ----
001450  2               ; BTST
001450  2               ; ----
001450  2               
001450  2               ; IS EVERY "ON" BIT IN [ARG1]
001450  2               ; ALSO "ON" IN [ARG2]?
001450  2               
001450  2               ZBTST:
001450  2  A5 64                LDA     ARG2+LO         ; FIRST CHECK LSBS
001452  2  25 62                AND     ARG1+LO
001454  2  C5 64                CMP     ARG2+LO         ; LSBS MATCH?
001456  2  D0 F5                BNE     PBAD            ; NO, EXIT NOW
001458  2               
001458  2  A5 65                LDA     ARG2+HI         ; ELSE CHECK MSBS
00145A  2  25 63                AND     ARG1+HI
00145C  2  C5 65                CMP     ARG2+HI         ; MATCHED?
00145E  2  D0 ED                BNE     PBAD            ; SORRY ...
001460  2               
001460  2               PGOOD:
001460  2  4C FB 10             JMP     PREDS
001463  2               
001463  2               ; ---
001463  2               ; BOR
001463  2               ; ---
001463  2               
001463  2               ; RETURN [ARG1] "OR" [ARG2]
001463  2               
001463  2               ZBOR:
001463  2  A5 62                LDA     ARG1+LO
001465  2  05 64                ORA     ARG2+LO
001467  2  AA                   TAX
001468  2  A5 63                LDA     ARG1+HI
00146A  2  05 65                ORA     ARG2+HI
00146C  2  4C EA 13             JMP     VEXIT
00146F  2               
00146F  2               ; ----
00146F  2               ; BAND
00146F  2               ; ----
00146F  2               
00146F  2               ; RETURN [ARG1] "AND" [ARG2]
00146F  2               
00146F  2               ZBAND:
00146F  2  A5 62                LDA     ARG1+LO
001471  2  25 64                AND     ARG2+LO
001473  2  AA                   TAX
001474  2  A5 63                LDA     ARG1+HI
001476  2  25 65                AND     ARG2+HI
001478  2  4C EA 13             JMP     VEXIT
00147B  2               
00147B  2               ; -----
00147B  2               ; FSET?
00147B  2               ; -----
00147B  2               
00147B  2               ; IS FLAG [ARG1] SET IN OBJECT [ARG2]?
00147B  2               
00147B  2               ZFSETP:
00147B  2  20 61 1D             JSR     FLAGSU          ; GET BITS INTO [K] AND [J]
00147E  2  A5 73                LDA     K+HI            ; DO MSBS
001480  2  25 71                AND     J+HI
001482  2  85 73                STA     K+HI
001484  2               
001484  2  A5 72                LDA     K+LO            ; DO LSBS
001486  2  25 70                AND     J+LO
001488  2               
001488  2  05 73                ORA     K+HI            ; ANY BITS ON?
00148A  2  D0 D4                BNE     PGOOD           ; TARGET BIT MUST BE ON
00148C  2  4C EF 10             JMP     PREDF
00148F  2               
00148F  2               ; ----
00148F  2               ; FSET
00148F  2               ; ----
00148F  2               
00148F  2               ; SET FLAG [ARG2] IN OBJECT [ARG1]
00148F  2               
00148F  2               ZFSET:
00148F  2  20 61 1D             JSR     FLAGSU          ; GET BITS INTO [K] & [J], ADDR IN [I]
001492  2               
001492  2  A0 00                LDY     #0
001494  2  A5 73                LDA     K+HI            ; FIRST DO MSBS
001496  2  05 71                ORA     J+HI
001498  2  91 6E                STA     (I),Y
00149A  2               
00149A  2  C8                   INY
00149B  2  A5 72                LDA     K+LO            ; THEN LSBS
00149D  2  05 70                ORA     J+LO
00149F  2  91 6E                STA     (I),Y
0014A1  2  60                   RTS
0014A2  2               
0014A2  2               ; ------
0014A2  2               ; FCLEAR
0014A2  2               ; ------
0014A2  2               
0014A2  2               ; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
0014A2  2               
0014A2  2               ZFCLR:
0014A2  2  20 61 1D             JSR     FLAGSU          ; GETS BITS INTO [J] & [K], ADDR IN [I]
0014A5  2               
0014A5  2  A0 00                LDY     #0
0014A7  2  A5 71                LDA     J+HI            ; FETCH MSB
0014A9  2  49 FF                EOR     #$FF            ; COMPLEMENT IT
0014AB  2  25 73                AND     K+HI            ; RUB OUT FLAG
0014AD  2  91 6E                STA     (I),Y
0014AF  2               
0014AF  2  C8                   INY
0014B0  2  A5 70                LDA     J+LO            ; SAME FOR LSB
0014B2  2  49 FF                EOR     #$FF
0014B4  2  25 72                AND     K+LO
0014B6  2  91 6E                STA     (I),Y
0014B8  2  60                   RTS
0014B9  2               
0014B9  2               ; ---
0014B9  2               ; SET
0014B9  2               ; ---
0014B9  2               
0014B9  2               ; SET VARIABLE [ARG1] EQUAL TO [ARG2]
0014B9  2               
0014B9  2               ZSET:
0014B9  2  A5 64                LDA     ARG2+LO         ; MOVE THE VALUE
0014BB  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
0014BD  2  A5 65                LDA     ARG2+HI
0014BF  2  85 6D                STA     VALUE+HI
0014C1  2               
0014C1  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
0014C3  2  4C A2 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
0014C6  2               
0014C6  2               ; ----
0014C6  2               ; MOVE
0014C6  2               ; ----
0014C6  2               
0014C6  2               ; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
0014C6  2               
0014C6  2               ZMOVE:
0014C6  2  20 1E 13             JSR     ZREMOV          ; REMOVE FIRST
0014C9  2               
0014C9  2  A5 62                LDA     ARG1+LO
0014CB  2  20 05 1D             JSR     OBJLOC          ; GET SOURCE OBJECT ADDR INTO [I]
0014CE  2               
0014CE  2  A5 6E                LDA     I+LO            ; COPY SOURCE ADDRESS
0014D0  2  85 70                STA     J+LO            ; INTO [J]
0014D2  2  A5 6F                LDA     I+HI
0014D4  2  85 71                STA     J+HI
0014D6  2               
0014D6  2  A5 64                LDA     ARG2+LO         ; GET DEST OBJECT ID
0014D8  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT OF SOURCE
0014DA  2  91 6E                STA     (I),Y           ; AND MOVE IT IN
0014DC  2               
0014DC  2  20 05 1D             JSR     OBJLOC          ; GET ADDR OF DEST OBJECT INTO [I]
0014DF  2               
0014DF  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
0014E1  2  B1 6E                LDA     (I),Y           ; GET "FIRST" OF DEST
0014E3  2  AA                   TAX                     ; SAVE HERE FOR A MOMENT
0014E4  2               
0014E4  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ID
0014E6  2  91 6E                STA     (I),Y           ; MAKE IT "FIRST" OF DEST
0014E8  2               
0014E8  2  8A                   TXA                     ; RESTORE "FIRST" OF DEST
0014E9  2  F0 04                BEQ     ZMVEX           ; SCRAM IF ZERO
0014EB  2               
0014EB  2  A0 05                LDY     #5              ; MAKE "FIRST" OF DEST
0014ED  2  91 70                STA     (J),Y           ; THE "NEXT" OF SOURCE
0014EF  2               
0014EF  2               ZMVEX:
0014EF  2  60                   RTS
0014F0  2               
0014F0  2               ; ---
0014F0  2               ; GET
0014F0  2               ; ---
0014F0  2               
0014F0  2               ; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
0014F0  2               
0014F0  2               ZGET:
0014F0  2  20 05 15             JSR     WCALC           ; CALC ADDRESS
0014F3  2  20 DF 19             JSR     GETBYT          ; GET 1ST BYTE (MSB)
0014F6  2               
0014F6  2               DOGET:
0014F6  2  85 6D                STA     VALUE+HI        ; SAVE MSB
0014F8  2  20 DF 19             JSR     GETBYT          ; GET LSB
0014FB  2  85 6C                STA     VALUE+LO        ; SAVE AND
0014FD  2  4C B3 10             JMP     PUTVAL          ; HAND IT OVER
001500  2               
001500  2               ; ----
001500  2               ; GETB
001500  2               ; ----
001500  2               
001500  2               ; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
001500  2               
001500  2               ZGETB:
001500  2  20 09 15             JSR     BCALC
001503  2  F0 F1                BEQ     DOGET           ; [A] = 0, SO CLEAR MSB OF [VALUE]
001505  2               
001505  2               ; --------------------
001505  2               ; CALC TABLE ADDRESSES
001505  2               ; --------------------
001505  2               
001505  2               ; WORD-ALIGNED ENTRY
001505  2               
001505  2               WCALC:
001505  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN FOR
001507  2  26 65                ROL     ARG2+HI         ; WORD ACCESS
001509  2               
001509  2               ; BYTE-ALIGNED ENTRY
001509  2               
001509  2               BCALC:
001509  2  A5 64                LDA     ARG2+LO         ; ADD BASE ADDR OF TABLE
00150B  2  18                   CLC                     ; TO ITEM
00150C  2  65 62                ADC     ARG1+LO         ; INDEX
00150E  2  85 7C                STA     MPCL
001510  2               
001510  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSBS
001512  2  65 63                ADC     ARG1+HI
001514  2  85 7D                STA     MPCM
001516  2               
001516  2  A9 00                LDA     #0
001518  2  85 7E                STA     MPCH            ; CLEAR TOP BIT
00151A  2  85 7F                STA     MPCFLG          ; & INVALIDATE [MPC]
00151C  2  60                   RTS
00151D  2               
00151D  2               ; ----
00151D  2               ; GETP
00151D  2               ; ----
00151D  2               
00151D  2               ; RETURN PROPERTY [ARG2] OF OBJECT [ARG1];
00151D  2               ; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
00151D  2               
00151D  2               ZGETP:
00151D  2  20 2E 1D             JSR     PROPB
001520  2               
001520  2               GETP1:
001520  2  20 4A 1D             JSR     PROPN
001523  2  C5 64                CMP     ARG2+LO
001525  2  F0 1B                BEQ     GETP3
001527  2  90 06                BCC     GETP2
001529  2               
001529  2  20 57 1D             JSR     PROPNX
00152C  2  4C 20 15             JMP     GETP1           ; TRY AGAIN WITH NEXT PROP
00152F  2               
00152F  2               GETP2:
00152F  2  A5 64                LDA     ARG2+LO         ; GET PROPERTY #
001531  2  38                   SEC                     ; ZERO-ALIGN IT
001532  2  E9 01                SBC     #1
001534  2  0A                   ASL     A               ; WORD-ALIGN IT
001535  2  A8                   TAY                     ; USE AS AN INDEX
001536  2  B1 92                LDA     (OBJTAB),Y      ; GET MSB OF PROPERTY
001538  2  85 6D                STA     VALUE+HI
00153A  2  C8                   INY
00153B  2  B1 92                LDA     (OBJTAB),Y      ; DO SAME WITH LSB
00153D  2  85 6C                STA     VALUE+LO
00153F  2  4C B3 10             JMP     PUTVAL          ; RETURN DEFAULT IN [VALUE]
001542  2               
001542  2               GETP3:
001542  2  20 4F 1D             JSR     PROPL
001545  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST BYTE OF PROP
001546  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
001547  2  F0 09                BEQ     GETPB           ; GET A BYTE PROPERTY
001549  2  C9 01                CMP     #1              ; IF LENGTH = 1
00154B  2  F0 0B                BEQ     GETPW           ; GET A WORD PROPERTY
00154D  2               
00154D  2               ; *** ERROR #7: PROPERTY LENGTH ***
00154D  2               
00154D  2  A9 07                LDA     #7
00154F  2  4C B1 1D             JMP     ZERROR
001552  2               
001552  2               ; GET A 1-BYTE PROPERTY
001552  2               
001552  2               GETPB:
001552  2  B1 6E                LDA     (I),Y           ; GET LSB INTO [A]
001554  2  A2 00                LDX     #0              ; CLEAR MSB IN [X]
001556  2  F0 06                BEQ     ETPEX
001558  2               
001558  2               ; GET A 2-BYTE PROPERTY
001558  2               
001558  2               GETPW:
001558  2  B1 6E                LDA     (I),Y           ; GET MSB
00155A  2  AA                   TAX                     ; INTO [X]
00155B  2  C8                   INY                     ; POINT TO LSB
00155C  2  B1 6E                LDA     (I),Y           ; GET IT INTO [A]
00155E  2               
00155E  2               ETPEX:
00155E  2  85 6C                STA     VALUE+LO        ; STORE LSB
001560  2  86 6D                STX     VALUE+HI        ; AND MSB
001562  2  4C B3 10             JMP     PUTVAL
001565  2               
001565  2               ; -----
001565  2               ; GETPT
001565  2               ; -----
001565  2               
001565  2               ; RETURN POINTER TO PROP TABLE [ARG2]
001565  2               ; IN OBJECT [ARG1]
001565  2               
001565  2               ZGETPT:
001565  2  20 2E 1D             JSR     PROPB
001568  2               
001568  2               GETPT1:
001568  2  20 4A 1D             JSR     PROPN           ; RETURNS OFFSET IN [Y]
00156B  2  C5 64                CMP     ARG2+LO
00156D  2  F0 08                BEQ     GETPT2
00156F  2  90 1E                BCC     DORET
001571  2  20 57 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
001574  2  4C 68 15             JMP     GETPT1
001577  2               
001577  2               GETPT2:
001577  2  E6 6E                INC     I+LO
001579  2  D0 02                BNE     GETPT3
00157B  2  E6 6F                INC     I+HI
00157D  2               
00157D  2               GETPT3:
00157D  2  98                   TYA                     ; FETCH OFFSET
00157E  2  18                   CLC
00157F  2  65 6E                ADC     I+LO            ; ADD LSB OF TABLE ADDRESS
001581  2  85 6C                STA     VALUE+LO
001583  2               
001583  2  A5 6F                LDA     I+HI            ; AND MSB
001585  2  69 00                ADC     #0
001587  2  38                   SEC                     ; STRIP OFF
001588  2  E5 83                SBC     ZCODE           ; RELATIVE POINTER
00158A  2  85 6D                STA     VALUE+HI
00158C  2  4C B3 10             JMP     PUTVAL          ; AND RETURN
00158F  2               
00158F  2               DORET:
00158F  2  4C AB 10             JMP     RET0            ; ELSE RETURN A ZERO
001592  2               
001592  2               ; -----
001592  2               ; NEXTP
001592  2               ; -----
001592  2               
001592  2               ; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [ARG1];
001592  2               ; RETURN ZERO IF LAST; RETURN FIRST IF [ARG2]=0; ERROR IF NONE
001592  2               
001592  2               ZNEXTP:
001592  2  20 2E 1D             JSR     PROPB
001595  2  A5 64                LDA     ARG2+LO         ; IF [ARG2]=0
001597  2  F0 12                BEQ     NXTP3           ; RETURN "FIRST" SLOT
001599  2               
001599  2               NXTP1:
001599  2  20 4A 1D             JSR     PROPN           ; FETCH PROPERTY #
00159C  2  C5 64                CMP     ARG2+LO         ; COMPARE TO TARGET #
00159E  2  F0 08                BEQ     NXTP2           ; FOUND IT!
0015A0  2  90 ED                BCC     DORET           ; LAST PROP, SO RETURN ZERO
0015A2  2  20 57 1D             JSR     PROPNX          ; ELSE TRY NEXT PROPERTY
0015A5  2  4C 99 15             JMP     NXTP1
0015A8  2               
0015A8  2               NXTP2:
0015A8  2  20 57 1D             JSR     PROPNX          ; POINT TO FOLLOWING PROPERTY
0015AB  2               
0015AB  2               NXTP3:
0015AB  2  20 4A 1D             JSR     PROPN           ; GET THE PROPERTY #
0015AE  2  4C AD 10             JMP     PUTBYT          ; AND RETURN IT
0015B1  2               
0015B1  2               ; ---
0015B1  2               ; ADD
0015B1  2               ; ---
0015B1  2               
0015B1  2               ; RETURN [ARG1] + [ARG2]
0015B1  2               
0015B1  2               ZADD:
0015B1  2  A5 62                LDA     ARG1+LO         ; ADD LSBS
0015B3  2  18                   CLC
0015B4  2  65 64                ADC     ARG2+LO
0015B6  2  AA                   TAX                     ; SAVE LSB HERE
0015B7  2  A5 63                LDA     ARG1+HI         ; ADD MSBS
0015B9  2  65 65                ADC     ARG2+HI
0015BB  2  4C EA 13             JMP     VEXIT
0015BE  2               
0015BE  2               ; ---
0015BE  2               ; SUB
0015BE  2               ; ---
0015BE  2               
0015BE  2               ; RETURN [ARG1] - [ARG2]
0015BE  2               
0015BE  2               ZSUB:
0015BE  2  A5 62                LDA     ARG1+LO         ; SUBTRACT LSBS
0015C0  2  38                   SEC
0015C1  2  E5 64                SBC     ARG2+LO
0015C3  2  AA                   TAX                     ; SAVE LSB HERE
0015C4  2  A5 63                LDA     ARG1+HI         ; SUBTRACT MSBS
0015C6  2  E5 65                SBC     ARG2+HI
0015C8  2  4C EA 13             JMP     VEXIT           ; EXIT WITH [X]=LSB, [A]=MSB
0015CB  2               
0015CB  2               ; ---
0015CB  2               ; MUL
0015CB  2               ; ---
0015CB  2               
0015CB  2               ; RETURN [ARG1] * [ARG2]
0015CB  2               
0015CB  2               ZMUL:
0015CB  2  20 85 16             JSR     MINIT           ; INIT THINGS
0015CE  2               
0015CE  2               ZMLOOP:
0015CE  2  66 B8                ROR     MTEMP+HI
0015D0  2  66 B7                ROR     MTEMP+LO
0015D2  2  66 65                ROR     ARG2+HI
0015D4  2  66 64                ROR     ARG2+LO
0015D6  2  90 0D                BCC     ZMNEXT
0015D8  2               
0015D8  2  A5 62                LDA     ARG1+LO
0015DA  2  18                   CLC
0015DB  2  65 B7                ADC     MTEMP+LO
0015DD  2  85 B7                STA     MTEMP+LO
0015DF  2  A5 63                LDA     ARG1+HI
0015E1  2  65 B8                ADC     MTEMP+HI
0015E3  2  85 B8                STA     MTEMP+HI
0015E5  2               
0015E5  2               ZMNEXT:
0015E5  2  CA                   DEX
0015E6  2  10 E6                BPL     ZMLOOP
0015E8  2               
0015E8  2  A6 64                LDX     ARG2+LO         ; PUT LSB OF PRODUCT
0015EA  2  A5 65                LDA     ARG2+HI         ; AND MSB
0015EC  2  4C EA 13             JMP     VEXIT           ; WHERE "VEXIT" EXPECTS THEM
0015EF  2               
0015EF  2               ; ---
0015EF  2               ; DIV
0015EF  2               ; ---
0015EF  2               
0015EF  2               ; RETURN QUOTIENT OF [ARG1] / [ARG2]
0015EF  2               
0015EF  2               ZDIV:
0015EF  2  20 03 16             JSR     DIVIDE
0015F2  2  A6 B3                LDX     QUOT+LO
0015F4  2  A5 B4                LDA     QUOT+HI
0015F6  2  4C EA 13             JMP     VEXIT
0015F9  2               
0015F9  2               ; ---
0015F9  2               ; MOD
0015F9  2               ; ---
0015F9  2               
0015F9  2               ; RETURN REMAINDER OF [ARG1] / [ARG2]
0015F9  2               
0015F9  2               ZMOD:
0015F9  2  20 03 16             JSR     DIVIDE
0015FC  2  A6 B5                LDX     REMAIN+LO       ; FETCH THE REMAINDER
0015FE  2  A5 B6                LDA     REMAIN+HI       ; IN [REMAIN]
001600  2  4C EA 13             JMP     VEXIT           ; AND RETURN IT
001603  2               
001603  2               ; ---------------
001603  2               ; SIGNED DIVISION
001603  2               ; ---------------
001603  2               
001603  2               ; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
001603  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
001603  2               
001603  2               DIVIDE:
001603  2  A5 63                LDA     ARG1+HI         ; SIGN OF REMAINDER
001605  2  85 BA                STA     RSIGN           ; IS THE SIGN OF THE DIVIDEND
001607  2  45 65                EOR     ARG2+HI         ; SIGN OF QUOTIENT IS POSITIVE
001609  2  85 B9                STA     QSIGN           ; IF SIGNS OF TERMS ARE THE SAME
00160B  2               
00160B  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
00160D  2  85 B3                STA     QUOT+LO
00160F  2  A5 63                LDA     ARG1+HI
001611  2  85 B4                STA     QUOT+HI         ; IF DIVIDEND IS POSITIVE
001613  2  10 03                BPL     ABSDIV          ; MOVE DIVISOR
001615  2  20 41 16             JSR     ABQUOT          ; ELSE CALC ABS(DIVIDEND) FIRST
001618  2               
001618  2               ABSDIV:
001618  2  A5 64                LDA     ARG2+LO
00161A  2  85 B5                STA     REMAIN+LO
00161C  2  A5 65                LDA     ARG2+HI
00161E  2  85 B6                STA     REMAIN+HI       ; IF REMAINDER IS POSITIVE
001620  2  10 03                BPL     GODIV           ; WE'RE READY TO DIVIDE
001622  2  20 33 16             JSR     ABREM           ; ELSE CALC ABS(DIVISOR)
001625  2               
001625  2               GODIV:
001625  2  20 4F 16             JSR     UDIV            ; DO UNSIGNED DIVIDE
001628  2               
001628  2  A5 B9                LDA     QSIGN           ; SHOULD QUOTIENT BE FLIPPED?
00162A  2  10 03                BPL     RFLIP           ; NO, TEST REMAINDER
00162C  2  20 41 16             JSR     ABQUOT          ; ELSE GET ABSOLUTE VALUE
00162F  2               
00162F  2               RFLIP:
00162F  2  A5 BA                LDA     RSIGN           ; SHOULD EMAINDER BE FLIPPED?
001631  2  10 0D                BPL     DIVEX           ; NO, WE'RE DONE
001633  2               
001633  2               ; ELSE FALL THROUGH ...
001633  2               
001633  2               ; ----------------
001633  2               ; CALC ABS(REMAIN)
001633  2               ; ----------------
001633  2               
001633  2               ABREM:
001633  2  A9 00                LDA     #0
001635  2  38                   SEC
001636  2  E5 B5                SBC     REMAIN+LO
001638  2  85 B5                STA     REMAIN+LO
00163A  2  A9 00                LDA     #0
00163C  2  E5 B6                SBC     REMAIN+HI
00163E  2  85 B6                STA     REMAIN+HI
001640  2               
001640  2               DIVEX:
001640  2  60                   RTS
001641  2               
001641  2               ; --------------
001641  2               ; CALC ABS(QUOT)
001641  2               ; --------------
001641  2               
001641  2               ABQUOT:
001641  2  A9 00                LDA     #0
001643  2  38                   SEC
001644  2  E5 B3                SBC     QUOT+LO
001646  2  85 B3                STA     QUOT+LO
001648  2  A9 00                LDA     #0
00164A  2  E5 B4                SBC     QUOT+HI
00164C  2  85 B4                STA     QUOT+HI
00164E  2  60                   RTS
00164F  2               
00164F  2               ; -----------------
00164F  2               ; UNSIGNED DIVISION
00164F  2               ; -----------------
00164F  2               
00164F  2               ; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
00164F  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
00164F  2               
00164F  2               UDIV:
00164F  2  A5 B5                LDA     REMAIN+LO       ; CHECK [REMAIN]
001651  2  05 B6                ORA     REMAIN+HI       ; BEFORE PROCEEDING
001653  2  F0 2B                BEQ     DIVERR          ; CAN'T DIVIDE BY ZERO!
001655  2               
001655  2  20 85 16             JSR     MINIT           ; SET IT ALL UP
001658  2               
001658  2               UDLOOP:
001658  2  26 B3                ROL     QUOT+LO
00165A  2  26 B4                ROL     QUOT+HI
00165C  2  26 B7                ROL     MTEMP+LO
00165E  2  26 B8                ROL     MTEMP+HI
001660  2               
001660  2  A5 B7                LDA     MTEMP+LO
001662  2  38                   SEC
001663  2  E5 B5                SBC     REMAIN+LO
001665  2  A8                   TAY                     ; SAVE HERE
001666  2  A5 B8                LDA     MTEMP+HI
001668  2  E5 B6                SBC     REMAIN+HI
00166A  2  90 04                BCC     UDNEXT
00166C  2  84 B7                STY     MTEMP+LO
00166E  2  85 B8                STA     MTEMP+HI
001670  2               
001670  2               UDNEXT:
001670  2  CA                   DEX
001671  2  D0 E5                BNE     UDLOOP
001673  2               
001673  2  26 B3                ROL     QUOT+LO         ; SHIFT LAST CARRY FOR QUOTIENT
001675  2  26 B4                ROL     QUOT+HI
001677  2               
001677  2  A5 B7                LDA     MTEMP+LO        ; MOVE REMAINDER
001679  2  85 B5                STA     REMAIN+LO       ; INTO [REMAIN]
00167B  2  A5 B8                LDA     MTEMP+HI
00167D  2  85 B6                STA     REMAIN+HI
00167F  2  60                   RTS
001680  2               
001680  2               ; *** ERROR #8: DIVISION BY ZERO ***
001680  2               
001680  2               DIVERR:
001680  2  A9 08                LDA     #8
001682  2  4C B1 1D             JMP     ZERROR
001685  2               
001685  2               ; ---------
001685  2               ; MATH INIT
001685  2               ; ---------
001685  2               
001685  2               MINIT:
001685  2  A2 10                LDX     #16             ; INIT LOOPING INDEX
001687  2  A9 00                LDA     #0
001689  2  85 B7                STA     MTEMP+LO        ; CLEAR TEMP
00168B  2  85 B8                STA     MTEMP+HI        ; REGISTER
00168D  2  18                   CLC                     ; AND CARRY
00168E  2  60                   RTS
00168F  2               
00168F  1                       .INCLUDE "opsx.asm"
00168F  2               ;        PAGE
00168F  2               ;        SBTTL   "--- X-OPS ---"
00168F  2               
00168F  2               ; ------
00168F  2               ; EQUAL?
00168F  2               ; ------
00168F  2               
00168F  2               ; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
00168F  2               
00168F  2               ZEQUAL:
00168F  2  C6 61                DEC     NARGS           ; DOUBLE-CHECK # ARGS
001691  2  D0 05                BNE     DOEQ            ; MUST BE AT LEAST TWO, OR ...
001693  2               
001693  2               ; *** ERROR #9: NOT ENOUGH "EQUAL?" ARGS ***
001693  2               
001693  2  A9 09                LDA     #9
001695  2  4C B1 1D             JMP     ZERROR
001698  2               
001698  2               DOEQ:
001698  2  A5 62                LDA     ARG1+LO         ; FETCH LSB
00169A  2  A6 63                LDX     ARG1+HI         ; AND MSB OF [ARG1]
00169C  2               
00169C  2  C5 64                CMP     ARG2+LO         ; TEST LSB OF [ARG2]
00169E  2  D0 04                BNE     TRY2            ; NO GOOD, LOOK FOR ANOTHER ARG
0016A0  2  E4 65                CPX     ARG2+HI         ; ELSE TRY MSB OF [ARG2]
0016A2  2  F0 18                BEQ     EQOK            ; MATCHED!
0016A4  2               
0016A4  2               TRY2:
0016A4  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016A6  2  F0 17                BEQ     EQBAD           ; YES, WE FAILED
0016A8  2               
0016A8  2  C5 66                CMP     ARG3+LO         ; TRY LSB OF [ARG3]
0016AA  2  D0 04                BNE     TRY3            ; NO GOOD, LOOK FOR ANOTHER ARG
0016AC  2  E4 67                CPX     ARG3+HI         ; HOW ABOUT MSB OF [ARG3]?
0016AE  2  F0 0C                BEQ     EQOK            ; YAY!
0016B0  2               
0016B0  2               TRY3:
0016B0  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016B2  2  F0 0B                BEQ     EQBAD           ; IF NOT ...
0016B4  2               
0016B4  2  C5 68                CMP     ARG4+LO         ; TRY [ARG4]
0016B6  2  D0 07                BNE     EQBAD           ; SORRY, CHUM
0016B8  2  E4 69                CPX     ARG4+HI         ; MSB MATCHED?
0016BA  2  D0 03                BNE     EQBAD           ; TOO BAD
0016BC  2               
0016BC  2               EQOK:
0016BC  2  4C FB 10             JMP     PREDS           ; FINALLY MATCHED!
0016BF  2               
0016BF  2               EQBAD:
0016BF  2  4C EF 10             JMP     PREDF           ; FAILURE (SNIFF!)
0016C2  2               
0016C2  2               ; ----
0016C2  2               ; CALL
0016C2  2               ; ----
0016C2  2               
0016C2  2               ; BRANCH TO FUNCTION AT ([ARG1]*2), PASSING
0016C2  2               ; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
0016C2  2               
0016C2  2               ZCALL:
0016C2  2  A5 62                LDA     ARG1+LO
0016C4  2  05 63                ORA     ARG1+HI         ; IS CALL ADDRESS ZERO?
0016C6  2  D0 03                BNE     DOCALL          ; NO, CONTINUE
0016C8  2               
0016C8  2  4C AD 10             JMP     PUTBYT          ; ELSE RETURN THE ZERO IN [A]
0016CB  2               
0016CB  2               DOCALL:
0016CB  2  A6 75                LDX     OLDZSP          ; SAVE OLD STACK POINTER
0016CD  2  A5 76                LDA     ZPCL            ; AND LSB OF [ZPC]
0016CF  2  20 8F 10             JSR     PUSHXA          ; ON THE Z-STACK
0016D2  2               
0016D2  2  A6 77                LDX     ZPCM            ; SAVE MIDDLE 8 BITS
0016D4  2  A5 78                LDA     ZPCH            ; AND TOP BIT OF [ZPC]
0016D6  2  20 8F 10             JSR     PUSHXA          ; AS WELL
0016D9  2               
0016D9  2               ; FORM 16-BIT ADDRESS FROM [ARG1]
0016D9  2               
0016D9  2  A9 00                LDA     #0              ; CLEAR HIGH BIT FOR ROTATE
0016DB  2  85 79                STA     ZPCFLG          ; AND INVALIDATE [ZPC]
0016DD  2               
0016DD  2  06 62                ASL     ARG1+LO         ; MULTIPLY [ARG1]
0016DF  2  26 63                ROL     ARG1+HI         ; BY TWO
0016E1  2  2A                   ROL     A               ; HIGH BIT INTO [A]
0016E2  2  85 78                STA     ZPCH            ; NEW HIGH BIT OF [ZPC]
0016E4  2               
0016E4  2  A5 63                LDA     ARG1+HI         ; GET NEW LOW BYTES
0016E6  2  85 77                STA     ZPCM
0016E8  2  A5 62                LDA     ARG1+LO
0016EA  2  85 76                STA     ZPCL
0016EC  2               
0016EC  2  20 A9 19             JSR     NEXTPC          ; FETCH # LOCALS TO PASS
0016EF  2  85 70                STA     J+LO            ; SAVE HERE FOR COUNTING
0016F1  2  85 71                STA     J+HI            ; AND HERE FOR LATER REFERENCE
0016F3  2  F0 2B                BEQ     ZCALL2          ; SKIP IF NO LOCALS
0016F5  2               
0016F5  2  A9 00                LDA     #0
0016F7  2  85 6E                STA     I+LO            ; ELSE INIT STORAGE INDEX
0016F9  2               
0016F9  2               ZCALL1:
0016F9  2  A4 6E                LDY     I+LO
0016FB  2  BE 00 0D             LDX     LOCALS+LO,Y     ; GET LSB OF LOCAL INTO [X]
0016FE  2  B9 01 0D             LDA     LOCALS+HI,Y     ; AND MSB INTO [A]
001701  2  84 6E                STY     I+LO            ; SAVE THE INDEX
001703  2  20 8F 10             JSR     PUSHXA          ; PUSH LOCAL IN [X/A] ONTO Z-STACK
001706  2               
001706  2  20 A9 19             JSR     NEXTPC          ; GET MSB OF NEW LOCAL
001709  2  85 6F                STA     I+HI            ; SAVE IT HERE
00170B  2  20 A9 19             JSR     NEXTPC          ; NOW GET LSB
00170E  2               
00170E  2  A4 6E                LDY     I+LO            ; RESTORE INDEX
001710  2  99 00 0D             STA     LOCALS+LO,Y     ; STORE LSB INTO [LOCALS]
001713  2  A5 6F                LDA     I+HI            ; RETRIEVE MSB
001715  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE IT INTO [LOCALS]
001718  2               
001718  2  C8                   INY
001719  2  C8                   INY                     ; UPDATE
00171A  2  84 6E                STY     I+LO            ; THE STORAGE INDEX
00171C  2               
00171C  2  C6 70                DEC     J+LO            ; ANY MORE LOCALS?
00171E  2  D0 D9                BNE     ZCALL1          ; YES, KEEP LOOPING
001720  2               
001720  2               ; MOVE UP TO 3 ARGUMENTS TO [LOCALS]
001720  2               
001720  2               ZCALL2:
001720  2  C6 61                DEC     NARGS           ; EXTRA ARGS IN THIS CALL?
001722  2  F0 26                BEQ     ZCALL3          ; NO, CONTINUE
001724  2               
001724  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO LOCAL #1
001726  2  8D 00 0D             STA     LOCALS+LO
001729  2  A5 65                LDA     ARG2+HI
00172B  2  8D 01 0D             STA     LOCALS+HI
00172E  2               
00172E  2  C6 61                DEC     NARGS           ; ANY LEFT?
001730  2  F0 18                BEQ     ZCALL3          ; NO, SCRAM
001732  2               
001732  2  A5 66                LDA     ARG3+LO         ; MOVE [ARG3] TO LOCAL #2
001734  2  8D 02 0D             STA     LOCALS+LO+2
001737  2  A5 67                LDA     ARG3+HI
001739  2  8D 03 0D             STA     LOCALS+HI+2
00173C  2               
00173C  2  C6 61                DEC     NARGS           ; ANY LEFT?
00173E  2  F0 0A                BEQ     ZCALL3          ; NO, EXUENT
001740  2               
001740  2  A5 68                LDA     ARG4+LO         ; MOVE [ARG4] TO LOCAL #3
001742  2  8D 04 0D             STA     LOCALS+LO+4
001745  2  A5 69                LDA     ARG4+HI
001747  2  8D 05 0D             STA     LOCALS+HI+4
00174A  2               
00174A  2               ZCALL3:
00174A  2  A6 71                LDX     J+HI            ; RETRIEVE # LOCALS
00174C  2  8A                   TXA                     ; DUPE INTO [A]
00174D  2  49 FF                EOR     #$FF            ; COMPLEMENT FOR ERROR CHECK (BM 11/24/84)
00174F  2  20 8F 10             JSR     PUSHXA          ; PUSH # LOCALS ONTO Z-STACK
001752  2               
001752  2  A5 74                LDA     ZSP             ; REMEMBER WHERE
001754  2  85 75                STA     OLDZSP          ; WE CAME FROM
001756  2               
001756  2  60                   RTS                     ; WHEW!
001757  2               
001757  2               ; ---
001757  2               ; PUT
001757  2               ; ---
001757  2               
001757  2               ; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
001757  2               
001757  2               ZPUT:
001757  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN [ARG2]
001759  2  26 65                ROL     ARG2+HI
00175B  2               
00175B  2  20 6D 17             JSR     PCALC           ; GET ITEM ADDR INTO [I]
00175E  2  A5 67                LDA     ARG3+HI         ; STORE MSB OF [ARG3]
001760  2  91 6E                STA     (I),Y           ; INTO MSB OF TABLE POSITION
001762  2  C8                   INY                     ; POINT TO LSB
001763  2  D0 03                BNE     PUTLSB          ; BRANCH ALWAYS
001765  2               
001765  2               ; ----
001765  2               ; PUTB
001765  2               ; ----
001765  2               
001765  2               ; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
001765  2               
001765  2               ZPUTB:
001765  2  20 6D 17             JSR     PCALC
001768  2               
001768  2               ; ENTRY FOR "PUT"
001768  2               
001768  2               PUTLSB:
001768  2  A5 66                LDA     ARG3+LO         ; GET LSB OF [ARG3]
00176A  2  91 6E                STA     (I),Y           ; STORE IN TABLE AT [Y]
00176C  2  60                   RTS
00176D  2               
00176D  2               ; ---------------------------
00176D  2               ; CALC ITEM ADDRESS FOR "PUT"
00176D  2               ; ---------------------------
00176D  2               
00176D  2               PCALC:
00176D  2  A5 64                LDA     ARG2+LO         ; ADD ITEM OFFSET IN [ARG2]
00176F  2  18                   CLC                     ; TO TABLE ADDR IN [ARG1]
001770  2  65 62                ADC     ARG1+LO         ; TO FORM A POINTER
001772  2  85 6E                STA     I+LO            ; IN [I]
001774  2               
001774  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSB
001776  2  65 63                ADC     ARG1+HI
001778  2  18                   CLC
001779  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
00177B  2  85 6F                STA     I+HI
00177D  2               
00177D  2  A0 00                LDY     #0              ; ZERO FOR INDEXING
00177F  2  60                   RTS
001780  2               
001780  2               ; ----
001780  2               ; PUTP
001780  2               ; ----
001780  2               
001780  2               ; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
001780  2               
001780  2               ZPUTP:
001780  2  20 2E 1D             JSR     PROPB
001783  2               
001783  2               PUTP1:
001783  2  20 4A 1D             JSR     PROPN
001786  2  C5 64                CMP     ARG2+LO
001788  2  F0 08                BEQ     PUTP2
00178A  2  90 1B                BCC     PNERR           ; ERROR IF LOWER
00178C  2               
00178C  2  20 57 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
00178F  2  4C 83 17             JMP     PUTP1
001792  2               
001792  2               PUTP2:
001792  2  20 4F 1D             JSR     PROPL
001795  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST PROPERTY BYTE
001796  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
001797  2  F0 09                BEQ     PUTP3           ; PUT A BYTE
001799  2  C9 01                CMP     #1              ; PUT A WORD IF [A] = 1
00179B  2  D0 0F                BNE     PLERR           ; ELSE LENGTH IS BAD
00179D  2               
00179D  2  A5 67                LDA     ARG3+HI         ; GET MSB OF PROPERTY
00179F  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017A1  2  C8                   INY                     ; POINT TO LSB SLOT
0017A2  2               
0017A2  2               PUTP3:
0017A2  2  A5 66                LDA     ARG3+LO         ; FETCH LSB
0017A4  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017A6  2  60                   RTS
0017A7  2               
0017A7  2               ; *** ERROR #10: BAD PROPERTY NUMBER ***
0017A7  2               
0017A7  2               PNERR:
0017A7  2  A9 0A                LDA     #10
0017A9  2  4C B1 1D             JMP     ZERROR
0017AC  2               
0017AC  2               ; *** ERROR #11: PUTP PROPERTY LENGTH ***
0017AC  2               
0017AC  2               PLERR:
0017AC  2  A9 0B                LDA     #11
0017AE  2  4C B1 1D             JMP     ZERROR
0017B1  2               
0017B1  2               ; ------
0017B1  2               ; PRINTC
0017B1  2               ; ------
0017B1  2               
0017B1  2               ; PRINT CHAR WITH ASCII VALUE IN [ARG1]
0017B1  2               
0017B1  2               ZPRC:
0017B1  2  A5 62                LDA     ARG1+LO         ; GRAB THE CHAR
0017B3  2  4C 92 1E             JMP     COUT            ; AND SHIP IT OUT
0017B6  2               
0017B6  2               ; ------
0017B6  2               ; PRINTN
0017B6  2               ; ------
0017B6  2               
0017B6  2               ; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
0017B6  2               
0017B6  2               ZPRN:
0017B6  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
0017B8  2  85 B3                STA     QUOT+LO
0017BA  2  A5 63                LDA     ARG1+HI
0017BC  2  85 B4                STA     QUOT+HI
0017BE  2               
0017BE  2               ; PRINT [QUOT]
0017BE  2               
0017BE  2               NUMBER:
0017BE  2  A5 B4                LDA     QUOT+HI         ; IF VALUE IS POSITIVE
0017C0  2  10 08                BPL     DIGCNT          ; CONTINUE
0017C2  2               
0017C2  2  A9 2D                LDA     #$2D            ; ELSE START WITH A MINUS SIGN
0017C4  2  20 92 1E             JSR     COUT
0017C7  2               
0017C7  2  20 41 16             JSR     ABQUOT          ; AND CALC ABS([QUOT])
0017CA  2               
0017CA  2               ; COUNT # OF DECIMAL DIGITS
0017CA  2               
0017CA  2               DIGCNT:
0017CA  2  A9 00                LDA     #0              ; RESET
0017CC  2  85 BB                STA     DIGITS          ; DIGIT INDEX
0017CE  2               
0017CE  2               DGC:
0017CE  2  A5 B3                LDA     QUOT+LO         ; IS QUOTIENT
0017D0  2  05 B4                ORA     QUOT+HI         ; ZERO YET?
0017D2  2  F0 12                BEQ     PRNTN3          ; YES, READY TO PRINT
0017D4  2               
0017D4  2  A9 0A                LDA     #10             ; ELSE DIVIDE [QUOT]
0017D6  2  85 B5                STA     REMAIN+LO       ; BY 10 (LSB)
0017D8  2  A9 00                LDA     #0
0017DA  2  85 B6                STA     REMAIN+HI       ; 10 (MSB)
0017DC  2               
0017DC  2  20 4F 16             JSR     UDIV            ; UNSIGNED DIVIDE
0017DF  2               
0017DF  2  A5 B5                LDA     REMAIN+LO       ; FETCH LSB OF REMAINDER (THE DIGIT)
0017E1  2  48                   PHA                     ; SAVE IT ON STACK
0017E2  2  E6 BB                INC     DIGITS          ; UPDATE DIGIT COUNT
0017E4  2  D0 E8                BNE     DGC             ; LOOP TILL QUOTIENT=0
0017E6  2               
0017E6  2               PRNTN3:
0017E6  2  A5 BB                LDA     DIGITS          ; IF DIGIT COUNT IS NZ
0017E8  2  D0 05                BNE     PRNTN4          ; CONTINUE
0017EA  2               
0017EA  2  A9 30                LDA     #'0'            ; ELSE PRINT "0"
0017EC  2  4C 92 1E             JMP     COUT            ; AND RETURN
0017EF  2               
0017EF  2               PRNTN4:
0017EF  2  68                   PLA                     ; PULL A DIGIT OFF THE STACK
0017F0  2  18                   CLC
0017F1  2  69 30                ADC     #'0'            ; CONVERT TO ASCII
0017F3  2  20 92 1E             JSR     COUT            ; AND PRINT IT
0017F6  2  C6 BB                DEC     DIGITS          ; OUT OF DIGITS YET?
0017F8  2  D0 F5                BNE     PRNTN4          ; NO, KEEP LOOPING
0017FA  2  60                   RTS
0017FB  2               
0017FB  2               ; ------
0017FB  2               ; RANDOM
0017FB  2               ; ------
0017FB  2               
0017FB  2               ; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
0017FB  2               
0017FB  2               ZRAND:
0017FB  2  A5 62                LDA     ARG1+LO         ; MAKE [ARG1] THE DIVISOR
0017FD  2  85 64                STA     ARG2+LO
0017FF  2  A5 63                LDA     ARG1+HI
001801  2  85 65                STA     ARG2+HI
001803  2               
001803  2  20 1E 1E             JSR     RANDOM          ; GET RANDOM BYTES INTO [A] AND [X]
001806  2  86 62                STX     ARG1+LO         ; MAKE THEM THE DIVIDEND
001808  2  29 7F                AND     #$7F            ; MAKE SURE MSB IS POSITIVE
00180A  2  85 63                STA     ARG1+HI
00180C  2               
00180C  2  20 03 16             JSR     DIVIDE          ; SIGNED DIVIDE, [ARG1] / [ARG2]
00180F  2               
00180F  2  A5 B5                LDA     REMAIN+LO       ; MOVE REMAINDER
001811  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
001813  2  A5 B6                LDA     REMAIN+HI
001815  2  85 6D                STA     VALUE+HI
001817  2               
001817  2  20 7B 11             JSR     INCVAL          ; INCREMENT [VALUE]
00181A  2  4C B3 10             JMP     PUTVAL          ; AND RETURN RESULT
00181D  2               
00181D  2               ; ----
00181D  2               ; PUSH
00181D  2               ; ----
00181D  2               
00181D  2               ; PUSH [ARG1] ONTO THE Z-STACK
00181D  2               
00181D  2               ZPUSH:
00181D  2  A6 62                LDX     ARG1+LO
00181F  2  A5 63                LDA     ARG1+HI
001821  2  4C 8F 10             JMP     PUSHXA
001824  2               
001824  2               ; ---
001824  2               ; POP
001824  2               ; ---
001824  2               
001824  2               ; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
001824  2               
001824  2               ZPOP:
001824  2  20 75 10             JSR     POPVAL          ; VALUE INTO [VALUE]
001827  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
001829  2  4C A2 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
00182C  2               
00182C  1                       .INCLUDE "read.asm"
00182C  2               ;        PAGE
00182C  2               ;        SBTTL   "--- READ HANDLER ---"
00182C  2               
00182C  2               ; ----
00182C  2               ; READ
00182C  2               ; ----
00182C  2               
00182C  2               ; READ LINE INTO TABLE [ARG1]; PARSE INTO TABLE [ARG2]
00182C  2               
00182C  2               ZREAD:
00182C  2  20 42 1F             JSR     ZUSL            ; UPDATE THE STATUS LINE
00182F  2               
00182F  2  A5 63                LDA     ARG1+HI         ; MAKE THE TABLE ADDRESSES
001831  2  18                   CLC                     ; ABSOLUTE
001832  2  65 83                ADC     ZCODE           ; LSBS NEED NOT CHANGE
001834  2  85 63                STA     ARG1+HI
001836  2               
001836  2  A5 65                LDA     ARG2+HI
001838  2  18                   CLC
001839  2  65 83                ADC     ZCODE
00183B  2  85 65                STA     ARG2+HI
00183D  2               
00183D  2  20 E9 20             JSR     INPUT           ; READ LINE; RETURN LENGTH IN [A]
001840  2  85 A2                STA     LINLEN          ; SAVE # CHARS IN LINE
001842  2               
001842  2  A9 00                LDA     #0
001844  2  85 A3                STA     WRDLEN          ; INIT # CHARS IN WORD COUNTER
001846  2               
001846  2  A0 01                LDY     #1              ; POINT TO "# WORDS READ" SLOT
001848  2  91 64                STA     (ARG2),Y        ; AND CLEAR IT ([A] = 0)
00184A  2               
00184A  2  84 A0                STY     SOURCE          ; INIT SOURCE TABLE PNTR ([Y] = 1)
00184C  2  C8                   INY                     ; = 2
00184D  2  84 A1                STY     RESULT          ; AND RESULT TABLE POINTER
00184F  2               
00184F  2               ; MAIN LOOP STARTS HERE
00184F  2               
00184F  2               READL:
00184F  2  A0 00                LDY     #0              ; POINT TO "MAX WORDS" SLOT
001851  2  B1 64                LDA     (ARG2),Y        ; AND READ IT
001853  2  F0 04                BEQ     RLERR           ; PATCH IF ZERO
001855  2  C9 3C                CMP     #60             ; OKAY IF < 60
001857  2  90 04                BCC     RL0
001859  2               
001859  2               RLERR:
001859  2  A9 3B                LDA     #59             ; MAXIMUM VALUE IS 59 (BM 5/14/85)
00185B  2  91 64                STA     (ARG2),Y
00185D  2               
00185D  2               RL0:
00185D  2  C8                   INY                     ; POINT TO "# WORDS READ" SLOT
00185E  2  D1 64                CMP     (ARG2),Y        ; TOO MANY WORDS?
001860  2  90 06                BCC     RLEX            ; EXIT IF SO (BM 5/1/85)
001862  2               
001862  2               RL1:
001862  2  A5 A2                LDA     LINLEN
001864  2  05 A3                ORA     WRDLEN          ; OUT OF CHARS AND WORDS?
001866  2  D0 01                BNE     RL2             ; NOT YET
001868  2               RLEX:
001868  2  60                   RTS                     ; ELSE EXIT
001869  2               
001869  2               RL2:
001869  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH
00186B  2  C9 06                CMP     #6              ; 6 CHARS DONE?
00186D  2  90 03                BCC     RL3             ; NO, KEEP GOING
00186F  2  20 00 19             JSR     FLUSHW          ; ELSE FLUSH REMAINDER OF WORD
001872  2               
001872  2               RL3:
001872  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH AGAIN
001874  2  D0 24                BNE     READL2          ; CONTINUE IF NOT FIRST CHAR
001876  2               
001876  2               ; START A NEW WORD
001876  2               
001876  2  A2 05                LDX     #5              ; CLEAR Z-WORD INPUT BUFFER
001878  2               RLL:
001878  2  95 94                STA     IN,X            ; [A] = 0
00187A  2  CA                   DEX
00187B  2  10 FB                BPL     RLL
00187D  2               
00187D  2  20 F2 18             JSR     EFIND           ; GET BASE ADDRESS INTO [ENTRY]
001880  2  A5 A0                LDA     SOURCE          ; STORE THE START POS OF THE WORD
001882  2  A0 03                LDY     #3              ; INTO THE "WORD START" SLOT
001884  2  91 A4                STA     (ENTRY),Y       ; OF THE RESULT TABLE
001886  2               
001886  2  A8                   TAY
001887  2  B1 62                LDA     (ARG1),Y        ; GET A CHAR FROM SOURCE BUFFER
001889  2  20 2D 19             JSR     SIB             ; IS IT A SELF-INSERTING BREAK?
00188C  2  B0 26                BCS     DOSIB           ; YES IF CARRY WAS SET
00188E  2               
00188E  2  20 1B 19             JSR     NORM            ; IS IT A "NORMAL" BREAK?
001891  2  90 07                BCC     READL2          ; NO, CONTINUE
001893  2               
001893  2  E6 A0                INC     SOURCE          ; ELSE FLUSH THE STRANDED BREAK
001895  2  C6 A2                DEC     LINLEN          ; UPDATE # CHARS LEFT IN LINE
001897  2  4C 4F 18             JMP     READL           ; AND LOOP
00189A  2               
00189A  2               READL2:
00189A  2  A5 A2                LDA     LINLEN          ; OUT OF CHARS YET?
00189C  2  F0 1E                BEQ     READL3          ; LOOKS THAT WAY
00189E  2               
00189E  2  A4 A0                LDY     SOURCE
0018A0  2  B1 62                LDA     (ARG1),Y        ; ELSE GRAB NEXT CHAR
0018A2  2  20 16 19             JSR     BREAK           ; IS IT A BREAK?
0018A5  2  B0 15                BCS     READL3          ; YES IF CARRY WAS SET
0018A7  2               
0018A7  2  A6 A3                LDX     WRDLEN          ; ELSE STORE THE CHAR
0018A9  2  95 94                STA     IN,X            ; INTO THE INPUT BUFFER
0018AB  2               
0018AB  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018AD  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD
0018AF  2  E6 A0                INC     SOURCE          ; POINT TO NEXT CHAR IN SOURCE
0018B1  2  4C 4F 18             JMP     READL           ; AND LOOP BACK
0018B4  2               
0018B4  2               DOSIB:
0018B4  2  85 94                STA     IN              ; PUT THE BREAK INTO 1ST WORD SLOT
0018B6  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018B8  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD BUFFER
0018BA  2  E6 A0                INC     SOURCE          ; POINT TO NEXT SOURCE CHAR
0018BC  2               
0018BC  2               READL3:
0018BC  2  A5 A3                LDA     WRDLEN          ; ANY CHARS IN WORD YET?
0018BE  2  F0 8F                BEQ     READL           ; APPARENTLY NOT, SO LOOP BACK
0018C0  2               
0018C0  2  20 F2 18             JSR     EFIND           ; GET ENTRY ADDR INTO [ENTRY]
0018C3  2  A5 A3                LDA     WRDLEN          ; GET ACTUAL LNGTH OF WORD
0018C5  2  A0 02                LDY     #2              ; STORE IT IN "WORD LENGTH" SLOT
0018C7  2  91 A4                STA     (ENTRY),Y       ; OF THE CURRENT ENTRY
0018C9  2               
0018C9  2  20 16 1C             JSR     CONZST          ; CONVERT ASCII IN [IN] TO Z-STRING
0018CC  2  20 3F 19             JSR     FINDW           ; AND LOOK IT UP IN VOCABULARY
0018CF  2               
0018CF  2  A0 01                LDY     #1
0018D1  2  B1 64                LDA     (ARG2),Y        ; FETCH THE # WORDS READ
0018D3  2  18                   CLC
0018D4  2  69 01                ADC     #1              ; INCREMENT IT
0018D6  2  91 64                STA     (ARG2),Y        ; AND UPDATE
0018D8  2               
0018D8  2  20 F2 18             JSR     EFIND           ; MAKE [ENTRY] POINT TO ENTRY
0018DB  2               
0018DB  2  A0 00                LDY     #0
0018DD  2  84 A3                STY     WRDLEN          ; CLEAR # CHARS IN WORD
0018DF  2  A5 6D                LDA     VALUE+HI        ; GET MSB OF VOCAB ENTRY ADDRESS
0018E1  2  91 A4                STA     (ENTRY),Y       ; AND STORE IN 1ST SLOT OF ENTRY
0018E3  2  C8                   INY
0018E4  2  A5 6C                LDA     VALUE+LO        ; ALSO STORE LSB IN 2ND SLOT
0018E6  2  91 A4                STA     (ENTRY),Y
0018E8  2               
0018E8  2  A5 A1                LDA     RESULT          ; UPDATE THE
0018EA  2  18                   CLC                     ; RESULT TABLE POINTER
0018EB  2  69 04                ADC     #4              ; SO IT POINTS TO THE
0018ED  2  85 A1                STA     RESULT          ; NEXT ENTRY
0018EF  2               
0018EF  2  4C 4F 18             JMP     READL           ; AND LOOP BACK
0018F2  2               
0018F2  2               ; -----------------------------------
0018F2  2               ; FIND BASE ADDR OF RESULT ENTRY SLOT
0018F2  2               ; -----------------------------------
0018F2  2               
0018F2  2               EFIND:
0018F2  2  A5 64                LDA     ARG2+LO         ; LSB OF RESULT TABLE BASE
0018F4  2  18                   CLC
0018F5  2  65 A1                ADC     RESULT          ; AND CURRENT POINTER
0018F7  2  85 A4                STA     ENTRY+LO        ; SAVE IN [ENTRY]
0018F9  2  A5 65                LDA     ARG2+HI         ; ALSO ADD MSB
0018FB  2  69 00                ADC     #0
0018FD  2  85 A5                STA     ENTRY+HI
0018FF  2  60                   RTS
001900  2               
001900  2               ; ----------
001900  2               ; FLUSH WORD
001900  2               ; ----------
001900  2               
001900  2               FLUSHW:
001900  2  A5 A2                LDA     LINLEN          ; ANY CHARS LEFT IN LINE?
001902  2  F0 11                BEQ     FLEX            ; NO, SCRAM
001904  2               
001904  2  A4 A0                LDY     SOURCE          ; GET CURRENT CHAR POINTER
001906  2  B1 62                LDA     (ARG1),Y        ; AND GRAB A CHAR
001908  2  20 16 19             JSR     BREAK           ; IS IT A BREAK?
00190B  2  B0 08                BCS     FLEX            ; EXIT IF SO
00190D  2  C6 A2                DEC     LINLEN          ; ELSE UPDATE CHAR COUNT
00190F  2  E6 A3                INC     WRDLEN          ; AND WORD-CHAR COUNT
001911  2  E6 A0                INC     SOURCE          ; AND CHAR POINTER
001913  2  D0 EB                BNE     FLUSHW          ; AND LOOP BACK (ALWAYS)
001915  2               
001915  2               FLEX:
001915  2  60                   RTS
001916  2               
001916  2               ; ---------------------------------
001916  2               ; IS CHAR IN [A] ANY TYPE OF BREAK?
001916  2               ; ---------------------------------
001916  2               
001916  2               BREAK:
001916  2  20 2D 19             JSR     SIB             ; CHECK FOR A SIB FIRST
001919  2  B0 22                BCS     FBRK            ; EXIT NOW IF MATCHED
00191B  2               
00191B  2               ; ELSE FALL THROUGH ...
00191B  2               
00191B  2               ; --------------------------------
00191B  2               ; IS CHAR IN [A] A "NORMAL" BREAK?
00191B  2               ; --------------------------------
00191B  2               
00191B  2               NORM:
00191B  2  A2 05                LDX     #NBRKS-1        ; NUMBER OF "NORMAL" BREAKS
00191D  2               NBL:
00191D  2  DD 27 19             CMP     BRKTBL,X        ; MATCHED?
001920  2  F0 1B                BEQ     FBRK            ; YES, EXIT
001922  2  CA                   DEX
001923  2  10 F8                BPL     NBL             ; NO, KEEP LOOKING
001925  2  18                   CLC                     ; NO MATCH, CLEAR CARRY
001926  2  60                   RTS                     ; AND RETURN
001927  2               
001927  2               ; ------------------
001927  2               ; NORMAL BREAK CHARS
001927  2               ; ------------------
001927  2               
001927  2               BRKTBL:
001927  2  21 3F 2C 2E          .BYTE   "!?,."          ; IN ORDER OF
00192B  2  0D                   .BYTE   EOL             ; ASCENDING FREQUENCY
00192C  2  20                   .BYTE   SPACE           ; SPACE CHAR IS TESTED FIRST FOR SPEED
00192D  2               
00192D  2               NBRKS           = *-BRKTBL      ; # NORMAL BREAKS
00192D  2               
00192D  2               ; ---------------------
00192D  2               ; IS CHAR IN [A] A SIB?
00192D  2               ; ---------------------
00192D  2               
00192D  2               SIB:
00192D  2  AA                   TAX                     ; SAVE TEST CHAR
00192E  2  A0 00                LDY     #0              ; 1ST BYTE IN VOCAB TABLE
001930  2  B1 8E                LDA     (VOCAB),Y       ; HAS # SIBS
001932  2  A8                   TAY                     ; USE AS AN INDEX
001933  2  8A                   TXA                     ; RESTORE TEST CHAR
001934  2               SBL:
001934  2  D1 8E                CMP     (VOCAB),Y       ; MATCHED?
001936  2  F0 05                BEQ     FBRK            ; YES, REPORT IT
001938  2  88                   DEY
001939  2  D0 F9                BNE     SBL             ; ELSE KEEP LOOPING
00193B  2  18                   CLC                     ; NO MATCH, SO
00193C  2  60                   RTS                     ; EXIT WITH CARRY CLEAR
00193D  2               
00193D  2               FBRK:
00193D  2  38                   SEC                     ; EXIT WITH CARRY SET
00193E  2  60                   RTS                     ; IF MATCHED WITH A BREAK CHAR
00193F  2               
00193F  2               ; -----------------
00193F  2               ; VOCABULARY SEARCH
00193F  2               ; -----------------
00193F  2               
00193F  2               ; ENTRY: 4-BYTE TARGET Z-WORD IN [OUT]
00193F  2               ; EXIT: ABS ENTRY ADDRESS IN [VALUE] IF FOUND;
00193F  2               ;       OTHERWISE [VALUE] = 0
00193F  2               
00193F  2               FINDW:
00193F  2  A0 00                LDY     #0              ; GET # SIBS
001941  2  B1 8E                LDA     (VOCAB),Y       ; IN VOCAB TABLE
001943  2  18                   CLC                     ; INCREMENT IT
001944  2  69 01                ADC     #1              ; FOR PROPER ALIGNMENT
001946  2  65 8E                ADC     VOCAB+LO        ; NOW ADD THE BASE ADDR OF THE TABLE
001948  2  85 6C                STA     VALUE+LO        ; TO GET THE ACTUAL BASE ADDR
00194A  2  A5 8F                LDA     VOCAB+HI        ; OF THE VOCAB ENTRIES
00194C  2  69 00                ADC     #0              ; WHICH IS SAVED
00194E  2  85 6D                STA     VALUE+HI        ; IN [VALUE]
001950  2               
001950  2  B1 6C                LDA     (VALUE),Y       ; GET # BYTES PER ENTRY ([Y] = 0)
001952  2  85 A8                STA     ESIZE           ; SAVE IT HERE
001954  2               
001954  2  20 7B 11             JSR     INCVAL          ; POINT TO NEXT BYTE
001957  2  B1 6C                LDA     (VALUE),Y       ; GET # ENTRIES IN TABLE (MSB)
001959  2  85 A7                STA     NENTS+HI        ; AND STUFF IT IN [NENTS]
00195B  2               
00195B  2  20 7B 11             JSR     INCVAL          ; NEXT BYTE
00195E  2  B1 6C                LDA     (VALUE),Y       ; DON'T FORGET THE LSB!
001960  2  85 A6                STA     NENTS+LO
001962  2               
001962  2  20 7B 11             JSR     INCVAL          ; [VALUE] NOW POINTS TO 1ST ENTRY
001965  2               
001965  2               ; BEGIN THE SEARCH!
001965  2               
001965  2               FWL1:
001965  2  A0 00                LDY     #0
001967  2  B1 6C                LDA     (VALUE),Y       ; GET 1ST BYTE OF ENTRY
001969  2  C5 9A                CMP     OUT             ; MATCHED 1ST BYTE OF TARGET?
00196B  2  D0 15                BNE     WNEXT           ; NO, SKIP TO NEXT WORD
00196D  2               
00196D  2  C8                   INY
00196E  2  B1 6C                LDA     (VALUE),Y
001970  2  C5 9B                CMP     OUT+1           ; 2ND BYTE MATCHED?
001972  2  D0 0E                BNE     WNEXT           ; NOPE
001974  2               
001974  2  C8                   INY
001975  2  B1 6C                LDA     (VALUE),Y
001977  2  C5 9C                CMP     OUT+2           ; 3RD BYTE?
001979  2  D0 07                BNE     WNEXT           ; SORRY ...
00197B  2               
00197B  2  C8                   INY
00197C  2  B1 6C                LDA     (VALUE),Y
00197E  2  C5 9D                CMP     OUT+3           ; LAST BYTE
001980  2  F0 1F                BEQ     FWSUCC          ; FOUND IT!
001982  2               
001982  2               WNEXT:
001982  2  A5 A8                LDA     ESIZE           ; GET ENTRY SIZE
001984  2  18                   CLC                     ; AND ADD IT TO ENTRY ADDRESS
001985  2  65 6C                ADC     VALUE+LO        ; TO MAKE [VALUE]
001987  2  85 6C                STA     VALUE+LO        ; POINT TO THE NEXT ENTRY
001989  2  90 02                BCC     WNX
00198B  2  E6 6D                INC     VALUE+HI
00198D  2               
00198D  2               WNX:
00198D  2  A5 A6                LDA     NENTS+LO        ; DECREMENT THE
00198F  2  38                   SEC                     ; ENTRY COUNTER
001990  2  E9 01                SBC     #1
001992  2  85 A6                STA     NENTS+LO
001994  2  B0 02                BCS     WNX1
001996  2  C6 A7                DEC     NENTS+HI
001998  2               
001998  2               WNX1:
001998  2  05 A7                ORA     NENTS+HI        ; KEEP SEARCHING
00199A  2  D0 C9                BNE     FWL1            ; UNTIL COUNT IS ZERO
00199C  2               
00199C  2  85 6C                STA     VALUE+LO
00199E  2  85 6D                STA     VALUE+HI
0019A0  2  60                   RTS                     ; THEN RETURN WITH [VALUE] = 0
0019A1  2               
0019A1  2               ; ENTRY MATCHED!
0019A1  2               
0019A1  2               FWSUCC:
0019A1  2  A5 6D                LDA     VALUE+HI        ; CONVERT ABSOLUTE ENTRY ADDRESS
0019A3  2  38                   SEC                     ; IN [VALUE]
0019A4  2  E5 83                SBC     ZCODE           ; TO RELATIVE Z-ADDRESS
0019A6  2  85 6D                STA     VALUE+HI        ; LSB NEEDN'T CHANGE
0019A8  2  60                   RTS
0019A9  2               
0019A9  1               
0019A9  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OP SUPPORT & MEMORY MANAGEMENT"
0019A9  1                       .INCLUDE "paging.asm"
0019A9  2               ;        PAGE
0019A9  2               ;        SBTTL   "--- TIME-STAMP PAGING ROUTINE ---"
0019A9  2               
0019A9  2               ; -------------------------
0019A9  2               ; FETCH NEXT BYTE OF Z-CODE
0019A9  2               ; -------------------------
0019A9  2               
0019A9  2               ; EXIT: BYTE AT [ZPC] IN [A] & [Y]; FLAGS SET
0019A9  2               
0019A9  2               NEXTPC:
0019A9  2  A5 79                LDA     ZPCFLG          ; IS [ZPCPNT] VALID?
0019AB  2  D0 1E                BNE     NPC2            ; YES, GET THE BYTE
0019AD  2               
0019AD  2               ; Z-PAGE HAS CHANGED!
0019AD  2               
0019AD  2  A5 77                LDA     ZPCM            ; GET TOP
0019AF  2  A4 78                LDY     ZPCH            ; 9 BITS OF [ZPC]
0019B1  2  D0 08                BNE     NPC0            ; SWAP PAGE IF TOP BIT IS SET
0019B3  2               
0019B3  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
0019B5  2  B0 04                BCS     NPC0            ; NO, SWAP IT IN
0019B7  2               
0019B7  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
0019B9  2  D0 07                BNE     NPC1            ; AND GIVE IT TO [ZPCPNT]
0019BB  2               
0019BB  2               NPC0:
0019BB  2  A2 00                LDX     #0
0019BD  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
0019BF  2  20 15 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
0019C2  2               
0019C2  2               NPC1:
0019C2  2  85 7B                STA     ZPCPNT+HI       ; SET ABS PAGE ADDRESS
0019C4  2  A2 FF                LDX     #$FF
0019C6  2  86 79                STX     ZPCFLG          ; VALIDATE [ZPCPNT]
0019C8  2  E8                   INX                     ; = 0
0019C9  2  86 7A                STX     ZPCPNT+LO       ; CLEAR LSB OF POINTER
0019CB  2               
0019CB  2               NPC2:
0019CB  2  A4 76                LDY     ZPCL            ; FETCH PAGE INDEX
0019CD  2  B1 7A                LDA     (ZPCPNT),Y      ; GET Z-BYTE
0019CF  2               
0019CF  2  E6 76                INC     ZPCL            ; END OF PAGE YET?
0019D1  2  D0 0A                BNE     NPC3            ; NO, EXIT
0019D3  2               
0019D3  2  A0 00                LDY     #0
0019D5  2  84 79                STY     ZPCFLG          ; ELSE INVALIDATE [ZPCPNT]
0019D7  2               
0019D7  2  E6 77                INC     ZPCM            ; POINT [ZPC] TO
0019D9  2  D0 02                BNE     NPC3            ; THE NEXT
0019DB  2  E6 78                INC     ZPCH            ; Z-PAGE
0019DD  2               
0019DD  2               NPC3:
0019DD  2  A8                   TAY                     ; SET FLAGS
0019DE  2  60                   RTS                     ; AND RETURN
0019DF  2               
0019DF  2               ; -------------------------------
0019DF  2               ; GET NEXT BYTE OF VIRTUAL MEMORY
0019DF  2               ; -------------------------------
0019DF  2               
0019DF  2               ; EXIT: BYTE AT [MPC] IN [A] & [Y]; FLAGS SET
0019DF  2               
0019DF  2               GETBYT:
0019DF  2  A5 7F                LDA     MPCFLG          ; IS [MPCPNT] VALID?
0019E1  2  D0 1E                BNE     GTBT2           ; YES, GET THE BYTE
0019E3  2               
0019E3  2               ; Z-PAGE HAS CHANGED!
0019E3  2               
0019E3  2  A5 7D                LDA     MPCM            ; GET TOP
0019E5  2  A4 7E                LDY     MPCH            ; 9 BITS OF [MPC]
0019E7  2  D0 08                BNE     GTBT0           ; SWAP PAGE IF TOP BIT IS SET
0019E9  2               
0019E9  2               PATCH           = *+1           ; PATCH POINT FOR "VERIFY"
0019E9  2               
0019E9  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
0019EB  2  B0 04                BCS     GTBT0           ; NO, SWAP IT IN
0019ED  2               
0019ED  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
0019EF  2  D0 07                BNE     GTBT1           ; AND GIVE IT TO [MPCPNT]
0019F1  2               
0019F1  2               GTBT0:
0019F1  2  A2 00                LDX     #0
0019F3  2  86 79                STX     ZPCFLG          ; INVALIDATE [ZPC]
0019F5  2  20 15 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
0019F8  2               
0019F8  2               GTBT1:
0019F8  2  85 81                STA     MPCPNT+HI       ; SET ABS PAGE ADDRESS
0019FA  2  A2 FF                LDX     #$FF
0019FC  2  86 7F                STX     MPCFLG          ; VALIDATE [MPCPNT]
0019FE  2  E8                   INX                     ; = 0
0019FF  2  86 80                STX     MPCPNT+LO       ; CLEAR LSB OF POINTER
001A01  2               
001A01  2               GTBT2:
001A01  2  A4 7C                LDY     MPCL            ; FETCH PAGE INDEX
001A03  2  B1 80                LDA     (MPCPNT),Y      ; GET Z-BYTE
001A05  2               
001A05  2  E6 7C                INC     MPCL            ; END OF PAGE YET?
001A07  2  D0 0A                BNE     GTBT3           ; NO, EXIT
001A09  2               
001A09  2  A0 00                LDY     #0
001A0B  2  84 7F                STY     MPCFLG          ; ELSE INVALIDATE [MPCPNT]
001A0D  2               
001A0D  2  E6 7D                INC     MPCM            ; POINT [MPC] TO
001A0F  2  D0 02                BNE     GTBT3           ; THE NEXT
001A11  2  E6 7E                INC     MPCH            ; Z-PAGE
001A13  2               
001A13  2               GTBT3:
001A13  2  A8                   TAY                     ; SET FLAGS
001A14  2  60                   RTS                     ; AND RETURN
001A15  2               
001A15  2               ; ------------------------
001A15  2               ; LOCATE A SWAPABLE Z-PAGE
001A15  2               ; ------------------------
001A15  2               
001A15  2               ; ENTRY: TARGET Z-PAGE IN [A/Y] (9 BITS)
001A15  2               ; EXIT: ABSOLUTE PAGE IN [A]
001A15  2               
001A15  2               PAGE:
001A15  2  85 88                STA     TARGET+LO       ; SAVE THE
001A17  2  84 89                STY     TARGET+HI       ; TARGET Z-PAGE HERE
001A19  2               
001A19  2               ; IS THIS Z-PAGE ALREADY PAGED IN?
001A19  2               
001A19  2  A2 00                LDX     #0
001A1B  2  86 87                STX     ZPAGE           ; START AT BUFFER #0
001A1D  2               
001A1D  2               PG1:
001A1D  2  DD 00 0B             CMP     PTABL,X         ; LSB MATCHED?
001A20  2  D0 08                BNE     PG2             ; NO, TRY NEXT BUFFER
001A22  2  98                   TYA                     ; ELSE CHECK
001A23  2  DD A0 0B             CMP     PTABH,X         ; TOP BIT
001A26  2  F0 2B                BEQ     PG4             ; MATCHED! BUFFER IN [ZPAGE]
001A28  2  A5 88                LDA     TARGET+LO       ; ELSE RESTORE LSB
001A2A  2               PG2:
001A2A  2  E6 87                INC     ZPAGE           ; UPDATE TALLY
001A2C  2  E8                   INX
001A2D  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS YET?
001A2F  2  90 EC                BCC     PG1             ; NO, KEEP SEARCHING
001A31  2               
001A31  2               ; SWAP IN THE TARGET PAGE
001A31  2               
001A31  2               PG3:
001A31  2  20 8E 1A             JSR     EARLY           ; GET EARLIEST PAGE
001A34  2  A6 8B                LDX     SWAP            ; INTO [SWAP] & [X]
001A36  2  86 87                STX     ZPAGE           ; SAVE FOR LATER
001A38  2               
001A38  2  A5 88                LDA     TARGET+LO       ; ASSIGN THE TARGET PAGE
001A3A  2  9D 00 0B             STA     PTABL,X         ; TO THE EARLIEST BUFFER
001A3D  2  85 CD                STA     DBLOCK+LO       ; ALSO GIVE IT TO ZDOS
001A3F  2               
001A3F  2  A5 89                LDA     TARGET+HI       ; SAME FOR TOP BIT
001A41  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
001A43  2  9D A0 0B             STA     PTABH,X
001A46  2  85 CE                STA     DBLOCK+HI
001A48  2               
001A48  2  8A                   TXA
001A49  2  18                   CLC
001A4A  2  65 85                ADC     PAGE0           ; CALC ABS ADDR OF BUFFER
001A4C  2  85 D0                STA     DBUFF+HI        ; GIVE IT TO ZDOS
001A4E  2               
001A4E  2  20 1B 22             JSR     GETDSK          ; SWAP IN THE NEW PAGE
001A51  2  B0 36                BCS     DSKERR          ; ERROR IF CARRY SET
001A53  2               
001A53  2               ; UPDATE THE TIMESTAMP
001A53  2               
001A53  2               PG4:
001A53  2  A4 87                LDY     ZPAGE           ; GET THE BUFFER INDEX
001A55  2  B9 50 0C             LDA     LRUMAP,Y        ; GET THIS BUFFER'S STAMP
001A58  2  C5 8A                CMP     STAMP           ; SAME AS CURRENT STAMP?
001A5A  2  F0 27                BEQ     PG8             ; YES, EXIT
001A5C  2               
001A5C  2  E6 8A                INC     STAMP           ; UPDATE STAMP
001A5E  2  D0 1C                BNE     PG7             ; CONTINUE IF NO OVERFLOW
001A60  2               
001A60  2               ; HANDLE STAMP OVERFLOW
001A60  2               
001A60  2  20 A8 1A             JSR     EARLY2          ; GET EARLIEST NON-ZERO STAMP INTO [LRU]
001A63  2               
001A63  2  A2 00                LDX     #0              ; INIT INDEX
001A65  2               PG5:
001A65  2  BD 50 0C             LDA     LRUMAP,X        ; GET A STAMP READING
001A68  2  F0 06                BEQ     PG6             ; EXIT IF ALREADY ZERO
001A6A  2  38                   SEC                     ; ELSE SUBTRACT OFF
001A6B  2  E5 82                SBC     LRU             ; THE EARLIEST TIMESTAMP
001A6D  2  9D 50 0C             STA     LRUMAP,X        ; AND REPLACE THE STAMP
001A70  2               PG6:
001A70  2  E8                   INX
001A71  2  E4 86                CPX     PMAX            ; END OF SWAPPING SPACE?
001A73  2  90 F0                BCC     PG5             ; LOOP TILL ALL STAMPS FIXED
001A75  2               
001A75  2  A9 00                LDA     #0              ; TURN BACK THE CLOCK
001A77  2  38                   SEC                     ; TO REFLECT NEW
001A78  2  E5 82                SBC     LRU             ; STAMP READING
001A7A  2  85 8A                STA     STAMP
001A7C  2               
001A7C  2               PG7:
001A7C  2  A5 8A                LDA     STAMP           ; FETCH STAMP
001A7E  2  A4 87                LDY     ZPAGE           ; AND PAGE INDEX (BM 8/27/85)
001A80  2  99 50 0C             STA     LRUMAP,Y        ; STAMP TARGET PAGE WITH IT
001A83  2               
001A83  2               PG8:
001A83  2  A5 87                LDA     ZPAGE           ; GET BUFFER INDEX
001A85  2  18                   CLC                     ; MAKE IT
001A86  2  65 85                ADC     PAGE0           ; ABSOLUTE
001A88  2  60                   RTS                     ; AND RETURN IT IN [A]
001A89  2               
001A89  2               ; *** ERROR #14: DRIVE ACCESS ***
001A89  2               
001A89  2               DSKERR:
001A89  2  A9 0E                LDA     #14
001A8B  2  4C B1 1D             JMP     ZERROR
001A8E  2               
001A8E  2               ; -------------------------
001A8E  2               ; LOCATE EARLIEST TIMESTAMP
001A8E  2               ; -------------------------
001A8E  2               
001A8E  2               ; EXIT: [LRU] - EARLIEST TIMESTAMP
001A8E  2               ;	[SWAP] = INDEX TO EARLIEST BUFFER
001A8E  2               
001A8E  2               EARLY:
001A8E  2  A2 00                LDX     #0              ; INIT INDEX
001A90  2  86 8B                STX     SWAP            ; AND [SWAP]
001A92  2  AD 50 0C             LDA     LRUMAP          ; GET STAMP OF BUFFER #0
001A95  2  E8                   INX                     ; START COMPARE WITH BUFFER #1
001A96  2               EAR0:
001A96  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001A99  2  90 05                BCC     EAR1            ; NO, TRY NEXT STAMP
001A9B  2  BD 50 0C             LDA     LRUMAP,X        ; ELSE FETCH EARLIER ENTRY
001A9E  2  86 8B                STX     SWAP            ; AND REMEMBER WHERE WE FOUND IT
001AA0  2               EAR1:
001AA0  2  E8                   INX                     ; POINT TO NEXT STAMP
001AA1  2  E4 86                CPX     PMAX            ; OUT OF STAMPS YET?
001AA3  2  90 F1                BCC     EAR0            ; LOOP TILL EMPTY
001AA5  2               
001AA5  2  85 82                STA     LRU             ; SAVE EARLIEST STAMP HERE
001AA7  2  60                   RTS
001AA8  2               
001AA8  2               ; ----------------------------------
001AA8  2               ; LOCATE EARLIEST NON-ZERO TIMESTAMP
001AA8  2               ; (BM/LS 8/27/85)
001AA8  2               ; ----------------------------------
001AA8  2               
001AA8  2               EARLY2:
001AA8  2  A2 00                LDX     #0
001AAA  2  86 8B                STX     SWAP            ; INIT INDEX
001AAC  2               
001AAC  2               E2A:
001AAC  2  BD 50 0C             LDA     LRUMAP,X        ; GET STAMP OF 1ST BUFFER
001AAF  2  D0 07                BNE     E2B             ; NON-ZERO, SO IT'S OKAY
001AB1  2  E8                   INX                     ; ELSE SKIP TO NEXT BUFFER
001AB2  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001AB4  2  90 F6                BCC     E2A             ; NO, KEEP LOOKING
001AB6  2  B0 13                BCS     E2E             ; ELSE WE MUST USE 0
001AB8  2               
001AB8  2               E2B:
001AB8  2  E8                   INX                     ; START COMPARE WITH NEXT BUFFER
001AB9  2               
001AB9  2               E2C:
001AB9  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001ABC  2  90 08                BCC     E2D             ; IF SMALLER, TRY NEXT STAMP
001ABE  2  BC 50 0C             LDY     LRUMAP,X        ; IS TEST STAMP 0?
001AC1  2  F0 03                BEQ     E2D             ; YES, USE OLD
001AC3  2  98                   TYA                     ; ELSE USE NEW
001AC4  2  86 8B                STX     SWAP            ; UPDATE BUFFER INDEX
001AC6  2               
001AC6  2               E2D:
001AC6  2  E8                   INX                     ; POINT TO NEXT BUFFER
001AC7  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001AC9  2  90 EE                BCC     E2C             ; NO, LOOP TILL EMPTY
001ACB  2               
001ACB  2               E2E:
001ACB  2  85 82                STA     LRU             ; [A] HAS EARLIEST STAMP
001ACD  2  60                   RTS
001ACE  2               
001ACE  2               ; -------------------------
001ACE  2               ; POINT [MPC] TO V-ADDR [I]
001ACE  2               ; -------------------------
001ACE  2               
001ACE  2               SETWRD:
001ACE  2  A5 6E                LDA     I+LO
001AD0  2  85 7C                STA     MPCL
001AD2  2  A5 6F                LDA     I+HI
001AD4  2  85 7D                STA     MPCM
001AD6  2               
001AD6  2  A9 00                LDA     #0
001AD8  2  85 7E                STA     MPCH            ; ZERO TOP BIT
001ADA  2  85 7F                STA     MPCFLG          ; INVALIDATE [MPC]
001ADC  2  60                   RTS
001ADD  2               
001ADD  2               ; ----------------------------
001ADD  2               ; GET Z-WORD AT [MPC] INTO [I]
001ADD  2               ; ----------------------------
001ADD  2               
001ADD  2               GETWRD:
001ADD  2  20 DF 19             JSR     GETBYT
001AE0  2  85 6F                STA     I+HI
001AE2  2  20 DF 19             JSR     GETBYT
001AE5  2  85 6E                STA     I+LO
001AE7  2  60                   RTS
001AE8  2               
001AE8  1                       .INCLUDE "zstring.asm"
001AE8  2               ;        PAGE
001AE8  2               ;        SBTTL   "--- Z-STRING HANDLERS ---"
001AE8  2               
001AE8  2               ; -----------------------
001AE8  2               ; POINT TO ZSTRING IN [I]
001AE8  2               ; -----------------------
001AE8  2               
001AE8  2               SETSTR:
001AE8  2  A5 6E                LDA     I+LO            ; WORD-ALIGN THE ADDRESS
001AEA  2  0A                   ASL     A
001AEB  2  85 7C                STA     MPCL
001AED  2  A5 6F                LDA     I+HI
001AEF  2  2A                   ROL     A
001AF0  2  85 7D                STA     MPCM
001AF2  2  A9 00                LDA     #0
001AF4  2  85 7F                STA     MPCFLG          ; [MPC] IS CHANGING!
001AF6  2  2A                   ROL     A
001AF7  2  85 7E                STA     MPCH
001AF9  2               
001AF9  2               ZSTEX:
001AF9  2  60                   RTS
001AFA  2               
001AFA  2               ; -----------------------
001AFA  2               ; PRINT Z-STRING AT [MPC]
001AFA  2               ; -----------------------
001AFA  2               
001AFA  2               PZSTR:
001AFA  2  A2 00                LDX     #0
001AFC  2  86 A9                STX     PSET            ; ASSUME PERMANENT CHARSET
001AFE  2  86 AD                STX     ZFLAG           ; CLEAR BYTE FLAG
001B00  2  CA                   DEX                     ; = $FF
001B01  2  86 AA                STX     TSET            ; NO TEMPSET ACTIVE
001B03  2               
001B03  2               PZTOP:
001B03  2  20 CE 1B             JSR     GETZCH          ; GET A Z-CHAR
001B06  2  B0 F1                BCS     ZSTEX           ; END OF STRING IF CARRY IS SET
001B08  2               
001B08  2  85 AB                STA     ZCHAR           ; ELSE SAVE CHAR HERE
001B0A  2  AA                   TAX                     ; SET FLAGS
001B0B  2  F0 41                BEQ     BLANK           ; PRINT SPACE IF CHAR = 0
001B0D  2               
001B0D  2  C9 04                CMP     #4              ; IS THIS AN F-WORD?
001B0F  2  90 5B                BCC     DOFREQ          ; APPARENTLY SO
001B11  2               
001B11  2  C9 06                CMP     #6              ; PERHAPS A SHIFT CODE?
001B13  2  90 3D                BCC     NEWSET          ; YES, CHANGE CHARSETS
001B15  2               
001B15  2  20 C2 1B             JSR     GETSET          ; ELSE GET CHARSET
001B18  2  AA                   TAX                     ; SET FLAGS
001B19  2  D0 0B                BNE     SET1            ; SKIP IF NOT CHARSET #0
001B1B  2               
001B1B  2               ; PRINT A LOWER-CASE CHAR (CHARSET #0)
001B1B  2               
001B1B  2  A9 5B                LDA     #$61-6          ; ASCII "a" MINUS Z-OFFSET
001B1D  2               
001B1D  2               TOASC:
001B1D  2  18                   CLC
001B1E  2  65 AB                ADC     ZCHAR           ; ADD Z-CHAR INDEX
001B20  2               
001B20  2               SHOVE:
001B20  2  20 92 1E             JSR     COUT            ; SHOW THE CHAR
001B23  2  4C 03 1B             JMP     PZTOP           ; AND GRAB NEXT CHAR
001B26  2               
001B26  2               ; PRINT AN UPPER-CASE CHAR (CHARSET #1)
001B26  2               
001B26  2               SET1:
001B26  2  C9 01                CMP     #1              ; MAKE SURE IT'S SET #1
001B28  2  D0 04                BNE     SET2            ; ELSE MUST BE SET #2
001B2A  2               
001B2A  2  A9 3B                LDA     #$41-6          ; ASCII "A" MINUS Z-OFFSET
001B2C  2  D0 EF                BNE     TOASC           ; SAME AS SET #0
001B2E  2               
001B2E  2               ; PRINT FROM CHARSET #2
001B2E  2               
001B2E  2               SET2:
001B2E  2  A5 AB                LDA     ZCHAR           ; RETRIEVE THE Z-CHAR
001B30  2  38                   SEC
001B31  2  E9 06                SBC     #6              ; ZERO-ALIGN IT
001B33  2  F0 07                BEQ     DIRECT          ; IF ZERO, IT'S A "DIRECT" ASCII
001B35  2               
001B35  2  AA                   TAX                     ; OTHERWISE USE CODE AS AN INDEX
001B36  2  BD EB 1C             LDA     CHRTBL,X        ; INTO THE CHARSET TABLE
001B39  2  4C 20 1B             JMP     SHOVE           ; AND PRINT THE CHAR
001B3C  2               
001B3C  2               ; DECODE A "DIRECT" ASCII CHAR
001B3C  2               
001B3C  2               DIRECT:
001B3C  2  20 CE 1B             JSR     GETZCH          ; FETCH NEXT Z-CHAR
001B3F  2  0A                   ASL     A
001B40  2  0A                   ASL     A
001B41  2  0A                   ASL     A
001B42  2  0A                   ASL     A
001B43  2  0A                   ASL     A               ; SHIFT INTO POSITION
001B44  2  85 AB                STA     ZCHAR           ; AND SAVE HERE
001B46  2  20 CE 1B             JSR     GETZCH          ; GRAB YET ANOTHER Z-CHAR
001B49  2  05 AB                ORA     ZCHAR           ; SUPERIMPOSE THE 2ND BYTE
001B4B  2  4C 20 1B             JMP     SHOVE           ; AND PRINT THE RESULT
001B4E  2               
001B4E  2               ; PRINT A SPACE
001B4E  2               
001B4E  2               BLANK:
001B4E  2  A9 20                LDA     #SPACE          ; ASCII SPACE CHAR
001B50  2  D0 CE                BNE     SHOVE
001B52  2               
001B52  2               ; CHANGE CHARSET
001B52  2               
001B52  2               NEWSET:
001B52  2  38                   SEC                     ; CONVERT THE SHIFT CODE
001B53  2  E9 03                SBC     #3              ; TO 1 OR 2
001B55  2  A8                   TAY
001B56  2  20 C2 1B             JSR     GETSET          ; IS MODE TEMPORARY?
001B59  2  D0 05                BNE     TOPERM          ; YES, DO A PERMSHIFT
001B5B  2  84 AA                STY     TSET            ; ELSE JUST A TEMPSHIFT
001B5D  2  4C 03 1B             JMP     PZTOP           ; AND CONTINUE
001B60  2               
001B60  2               TOPERM:
001B60  2  84 A9                STY     PSET            ; SET PERM CHARSET
001B62  2  C5 A9                CMP     PSET            ; SAME AS BEFORE?
001B64  2  F0 9D                BEQ     PZTOP           ; YES, CONTINUE
001B66  2  A9 00                LDA     #0
001B68  2  85 A9                STA     PSET            ; ELSE RESET CHARSET
001B6A  2  F0 97                BEQ     PZTOP           ; BEFORE LOOPING BACK
001B6C  2               
001B6C  2               ; PRINT AN F-WORD
001B6C  2               
001B6C  2               DOFREQ:
001B6C  2  38                   SEC
001B6D  2  E9 01                SBC     #1              ; ZERO-ALIGN THE CODE
001B6F  2  0A                   ASL     A               ; AND MULTIPLY TIMES 64
001B70  2  0A                   ASL     A               ; TO OBTAIN THE SEGMENT OFFSET
001B71  2  0A                   ASL     A               ; INTO THE F-WORDS TABLE
001B72  2  0A                   ASL     A
001B73  2  0A                   ASL     A
001B74  2  0A                   ASL     A
001B75  2  85 AC                STA     OFFSET          ; SAVE OFFSET FOR LATER
001B77  2               
001B77  2  20 CE 1B             JSR     GETZCH          ; NOW GET THE F-WORD POINTER
001B7A  2  0A                   ASL     A               ; WORD-ALIGN IT
001B7B  2  18                   CLC                     ; AND
001B7C  2  65 AC                ADC     OFFSET          ; ADD THE SEGMENT OFFSET
001B7E  2  A8                   TAY                     ; TO GET THE OFFSET OF THE F-WORD
001B7F  2  B1 90                LDA     (FWORDS),Y      ; FROM THE START OF THE F-WORDS TABLE
001B81  2  85 6F                STA     I+HI            ; SAVE MSB OF F-WORD ADDRESS
001B83  2  C8                   INY
001B84  2  B1 90                LDA     (FWORDS),Y      ; ALSO SAVE LSB
001B86  2  85 6E                STA     I+LO            ; Z-ADDRESS OF F-WORD IS IN [I]
001B88  2               
001B88  2               ; SAVE THE STATE OF CURRENT Z-STRING
001B88  2               
001B88  2  A5 7E                LDA     MPCH
001B8A  2  48                   PHA
001B8B  2  A5 7D                LDA     MPCM
001B8D  2  48                   PHA
001B8E  2  A5 7C                LDA     MPCL
001B90  2  48                   PHA
001B91  2  A5 A9                LDA     PSET
001B93  2  48                   PHA
001B94  2  A5 AD                LDA     ZFLAG
001B96  2  48                   PHA
001B97  2  A5 AF                LDA     ZWORD+HI
001B99  2  48                   PHA
001B9A  2  A5 AE                LDA     ZWORD+LO
001B9C  2  48                   PHA
001B9D  2               
001B9D  2  20 E8 1A             JSR     SETSTR          ; PRINT THE Z-STRING
001BA0  2  20 FA 1A             JSR     PZSTR           ; IN [I]
001BA3  2               
001BA3  2               ; RESTORE OLD Z-STRING
001BA3  2               
001BA3  2  68                   PLA
001BA4  2  85 AE                STA     ZWORD+LO
001BA6  2  68                   PLA
001BA7  2  85 AF                STA     ZWORD+HI
001BA9  2  68                   PLA
001BAA  2  85 AD                STA     ZFLAG
001BAC  2  68                   PLA
001BAD  2  85 A9                STA     PSET
001BAF  2  68                   PLA
001BB0  2  85 7C                STA     MPCL
001BB2  2  68                   PLA
001BB3  2  85 7D                STA     MPCM
001BB5  2  68                   PLA
001BB6  2  85 7E                STA     MPCH
001BB8  2               
001BB8  2  A2 FF                LDX     #$FF
001BBA  2  86 AA                STX     TSET            ; DISABLE TEMP CHARSET
001BBC  2  E8                   INX                     ; = 0
001BBD  2  86 7F                STX     MPCFLG          ; [MPC] HAS CHANGED
001BBF  2  4C 03 1B             JMP     PZTOP           ; CONTINUE INNOCENTLY
001BC2  2               
001BC2  2               ; ----------------------
001BC2  2               ; RETURN CURRENT CHARSET
001BC2  2               ; ----------------------
001BC2  2               
001BC2  2               GETSET:
001BC2  2  A5 AA                LDA     TSET
001BC4  2  10 03                BPL     GS
001BC6  2  A5 A9                LDA     PSET
001BC8  2  60                   RTS
001BC9  2               
001BC9  2               GS:
001BC9  2  A0 FF                LDY     #$FF
001BCB  2  84 AA                STY     TSET
001BCD  2  60                   RTS
001BCE  2               
001BCE  2               ; -----------------
001BCE  2               ; FETCH NEXT Z-CHAR
001BCE  2               ; -----------------
001BCE  2               
001BCE  2               GETZCH:
001BCE  2  A5 AD                LDA     ZFLAG           ; WHICH BYTE IS THIS?
001BD0  2  10 02                BPL     GTZ0            ; $FF = LAST
001BD2  2  38                   SEC                     ; SET CARRY TO INDICATE
001BD3  2  60                   RTS                     ; NO MORE CHARS
001BD4  2               
001BD4  2               GTZ0:
001BD4  2  D0 13                BNE     GETZ1           ; NOT FIRST CHAR, EITHER
001BD6  2               
001BD6  2               ; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
001BD6  2               
001BD6  2  E6 AD                INC     ZFLAG           ; UPDATE CHAR COUNT
001BD8  2               
001BD8  2  20 DF 19             JSR     GETBYT          ; GET TRIPLET AT [MPC]
001BDB  2  85 AF                STA     ZWORD+HI        ; INTO [ZWORD]
001BDD  2  20 DF 19             JSR     GETBYT
001BE0  2  85 AE                STA     ZWORD+LO
001BE2  2               
001BE2  2  A5 AF                LDA     ZWORD+HI
001BE4  2  4A                   LSR     A
001BE5  2  4A                   LSR     A               ; SHIFT 1ST CHAR INTO PLACE
001BE6  2  4C 12 1C             JMP     GTEXIT          ; AND RETURN IT
001BE9  2               
001BE9  2               GETZ1:
001BE9  2  38                   SEC
001BEA  2  E9 01                SBC     #1
001BEC  2  D0 16                BNE     GETZ2           ; LAST CHAR IN TRIPLET IF ZERO
001BEE  2  A9 02                LDA     #2              ; ELSE
001BF0  2  85 AD                STA     ZFLAG           ; RESET CHAR INDEX
001BF2  2               
001BF2  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001BF4  2  85 6E                STA     I+LO            ; MOVE HERE FOR SHIFTING
001BF6  2  A5 AF                LDA     ZWORD+HI        ; GET TOP HALF
001BF8  2               
001BF8  2  06 6E                ASL     I+LO            ; SHIFT THE TOP 3 BITS OF LOWER HALF
001BFA  2  2A                   ROL     A               ; INTO THE BOTTOM OF THE TOP HALF
001BFB  2  06 6E                ASL     I+LO
001BFD  2  2A                   ROL     A
001BFE  2  06 6E                ASL     I+LO
001C00  2  2A                   ROL     A
001C01  2  4C 12 1C             JMP     GTEXIT
001C04  2               
001C04  2               GETZ2:
001C04  2  A9 00                LDA     #0              ; SET FLAG TO INDICATE
001C06  2  85 AD                STA     ZFLAG           ; END OF TRIPLET
001C08  2               
001C08  2  A5 AF                LDA     ZWORD+HI        ; TEST TOP HALF OF TRIPLET
001C0A  2  10 04                BPL     GETZ3           ; CONTINUE IF NOT END OF STRING
001C0C  2  A9 FF                LDA     #$FF            ; ELSE
001C0E  2  85 AD                STA     ZFLAG           ; INDICATE LAST TRIPLET IN STRING
001C10  2               
001C10  2               GETZ3:
001C10  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001C12  2               
001C12  2               GTEXIT:
001C12  2  29 1F                AND     #%00011111      ; MASK OUT GARBAGE BITS
001C14  2  18                   CLC
001C15  2  60                   RTS
001C16  2               
001C16  2               ; ---------------------------------
001C16  2               ; CONVERT [IN] TO Z-STRING IN [OUT]
001C16  2               ; ---------------------------------
001C16  2               
001C16  2               CONZST:
001C16  2  A9 05                LDA     #$05            ; FILL OUTPUT BUFFER
001C18  2  AA                   TAX                     ; WITH PAD CHARS ($05)
001C19  2               CZSL:
001C19  2  95 9A                STA     OUT,X
001C1B  2  CA                   DEX
001C1C  2  10 FB                BPL     CZSL
001C1E  2               
001C1E  2  A9 06                LDA     #6              ; INIT
001C20  2  85 B0                STA     CONCNT          ; CHAR COUNT
001C22  2               
001C22  2  A9 00                LDA     #0              ; CLEAR
001C24  2  85 B1                STA     CONIN           ; SOURCE AND
001C26  2  85 B2                STA     CONOUT          ; OUTPUT INDEXES
001C28  2               
001C28  2               CONTOP:
001C28  2  A6 B1                LDX     CONIN           ; FETCH SOURCE INDEX
001C2A  2  E6 B1                INC     CONIN           ; AND UPDATE
001C2C  2  B5 94                LDA     IN,X            ; GRAB AN ASCII CHAR
001C2E  2  85 AB                STA     ZCHAR           ; SAVE IT HERE
001C30  2  D0 04                BNE     NEXTZ           ; CONTINUE IF CHAR WAS NZ
001C32  2               
001C32  2  A9 05                LDA     #5              ; ELSE SHIP OUT
001C34  2  D0 2C                BNE     CSHIP           ; A PAD CHAR
001C36  2               
001C36  2               NEXTZ:
001C36  2  A5 AB                LDA     ZCHAR
001C38  2  20 AC 1C             JSR     SAYSET          ; WHICH CHARSET TO USE?
001C3B  2  F0 20                BEQ     CSET0           ; LOWER-CASE IF ZERO
001C3D  2               
001C3D  2  18                   CLC                     ; ELSE DO A TEMP-SHIFT
001C3E  2  69 03                ADC     #3              ; 4 = CHARSET 1, 5 = CHARSET 2
001C40  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001C42  2  95 9A                STA     OUT,X           ; SEND THE SHIFT CHAR
001C44  2               
001C44  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001C46  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001C48  2  D0 03                BNE     CTEST           ; IF OUT OF CHARS
001C4A  2  4C C5 1C             JMP     ZCRUSH          ; CRUSH 'EM!
001C4D  2               
001C4D  2               CTEST:
001C4D  2  A5 AB                LDA     ZCHAR           ; TEST CHAR AGAIN
001C4F  2  20 AC 1C             JSR     SAYSET
001C52  2  C9 02                CMP     #2
001C54  2  F0 19                BEQ     CSET2           ; CHARSET #2
001C56  2               
001C56  2               ; HANDLE CHARSET #1 (UPPER CASE ALPHA)
001C56  2               
001C56  2  A5 AB                LDA     ZCHAR
001C58  2  38                   SEC
001C59  2  E9 3B                SBC     #$41-6          ; CONVERT TO Z-CHAR
001C5B  2  10 05                BPL     CSHIP           ; AND SEND TO OUTPUT
001C5D  2               
001C5D  2               ; HANDLE CHARSET #0 (LOWER CASE ALPHA)
001C5D  2               
001C5D  2               CSET0:
001C5D  2  A5 AB                LDA     ZCHAR
001C5F  2  38                   SEC
001C60  2  E9 5B                SBC     #$61-6          ; CONVERT TO Z-CHAR
001C62  2               
001C62  2               ; SHIP Z-CHAR TO OUTPUT BUFFER
001C62  2               
001C62  2               CSHIP:
001C62  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001C64  2  95 9A                STA     OUT,X
001C66  2               
001C66  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001C68  2  C6 B0                DEC     CONCNT          ; DONE 6 CHARS YET?
001C6A  2  D0 BC                BNE     CONTOP          ; NO, LOOP BACK
001C6C  2  4C C5 1C             JMP     ZCRUSH          ; ELSE CRUSH
001C6F  2               
001C6F  2               ; HANDLE CHARSET #2 (MISCELLANEOUS)
001C6F  2               
001C6F  2               CSET2:
001C6F  2  A5 AB                LDA     ZCHAR           ; GRAB CHAR
001C71  2  20 9C 1C             JSR     CTABLE          ; IS IT IN CHARSET #3 TABLE?
001C74  2  D0 EC                BNE     CSHIP           ; YES, SEND IT TO OUTPUT
001C76  2               
001C76  2               ; SEND A "DIRECT" ASCII CHAR
001C76  2               
001C76  2  A9 06                LDA     #6              ; ASCII ALERT!
001C78  2  A6 B2                LDX     CONOUT
001C7A  2  95 9A                STA     OUT,X
001C7C  2               
001C7C  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001C7E  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001C80  2  F0 43                BEQ     ZCRUSH          ; BUFFER FULL!
001C82  2               
001C82  2               ; SEND 1ST HALF OF "DIRECT"
001C82  2               
001C82  2  A5 AB                LDA     ZCHAR
001C84  2  4A                   LSR     A
001C85  2  4A                   LSR     A
001C86  2  4A                   LSR     A
001C87  2  4A                   LSR     A
001C88  2  4A                   LSR     A
001C89  2  29 03                AND     #%00000011      ; MASK GARBAGE
001C8B  2  A6 B2                LDX     CONOUT
001C8D  2  95 9A                STA     OUT,X
001C8F  2               
001C8F  2  E6 B2                INC     CONOUT
001C91  2  C6 B0                DEC     CONCNT
001C93  2  F0 30                BEQ     ZCRUSH          ; BUFFER FULL!
001C95  2               
001C95  2               ; SEND 2ND HALF OF "DIRECT"
001C95  2               
001C95  2  A5 AB                LDA     ZCHAR           ; GET CHAR YET AGAIN
001C97  2  29 1F                AND     #%00011111      ; MASK JUNK
001C99  2  4C 62 1C             JMP     CSHIP           ; AND SHIP IT OUT
001C9C  2               
001C9C  2               ; ---------------------
001C9C  2               ; IS [A] IN CHARSET #3?
001C9C  2               ; ---------------------
001C9C  2               
001C9C  2               ; EXIT: [A] = CHAR CODE IF FOUND, Z-FLAG CLEARED
001C9C  2               ;       Z-FLAG SET IF NOT FOUND
001C9C  2               
001C9C  2               CTABLE:
001C9C  2  A2 19                LDX     #25
001C9E  2               CNL:
001C9E  2  DD EB 1C             CMP     CHRTBL,X
001CA1  2  F0 04                BEQ     CNOK
001CA3  2  CA                   DEX
001CA4  2  D0 F8                BNE     CNL
001CA6  2  60                   RTS                     ; Z-FLAG SET IF NO MATCH
001CA7  2               
001CA7  2               CNOK:
001CA7  2  8A                   TXA                     ; CHAR CODE IS INDEX
001CA8  2  18                   CLC
001CA9  2  69 06                ADC     #6              ; PLUS 6
001CAB  2  60                   RTS
001CAC  2               
001CAC  2               ; -----------------------------
001CAC  2               ; RETURN CHARSET OF CHAR IN [A]
001CAC  2               ; -----------------------------
001CAC  2               
001CAC  2               SAYSET:
001CAC  2  C9 61                CMP     #'a'
001CAE  2  90 07                BCC     SAY1
001CB0  2  C9 7B                CMP     #'z'+1
001CB2  2  B0 03                BCS     SAY1
001CB4  2  A9 00                LDA     #0              ; IT'S CHARSET #0
001CB6  2  60                   RTS
001CB7  2               
001CB7  2               SAY1:
001CB7  2  C9 41                CMP     #'A'
001CB9  2  90 07                BCC     SAY2
001CBB  2  C9 5B                CMP     #'Z'+1
001CBD  2  B0 03                BCS     SAY2
001CBF  2  A9 01                LDA     #1              ; IT'S CHARSET #1
001CC1  2  60                   RTS
001CC2  2               
001CC2  2               SAY2:
001CC2  2  A9 02                LDA     #2              ; IT'S CHARSET #2
001CC4  2  60                   RTS
001CC5  2               
001CC5  2               ; ----------------------
001CC5  2               ; CRUSH Z-CHARS IN [OUT]
001CC5  2               ; ----------------------
001CC5  2               
001CC5  2               ZCRUSH:
001CC5  2  A5 9B                LDA     OUT+1           ; GET 2ND Z-CHAR
001CC7  2  0A                   ASL     A               ; SHIFT BITS INTO POSITION
001CC8  2  0A                   ASL     A
001CC9  2  0A                   ASL     A
001CCA  2  0A                   ASL     A
001CCB  2  26 9A                ROL     OUT             ; ALONG WITH 1ST Z-CHAR
001CCD  2  0A                   ASL     A
001CCE  2  26 9A                ROL     OUT
001CD0  2  05 9C                ORA     OUT+2           ; SUPERIMPOSE 3RD Z-CHAR
001CD2  2  85 9B                STA     OUT+1
001CD4  2               
001CD4  2  A5 9E                LDA     OUT+4           ; GET 5TH Z-CHAR
001CD6  2  0A                   ASL     A               ; SHIFT BITS
001CD7  2  0A                   ASL     A
001CD8  2  0A                   ASL     A
001CD9  2  0A                   ASL     A
001CDA  2  26 9D                ROL     OUT+3           ; ALONG WITH 4TH Z-CHAR
001CDC  2  0A                   ASL     A
001CDD  2  26 9D                ROL     OUT+3
001CDF  2  05 9F                ORA     OUT+5           ; SUPERIMPOSE 6TH Z-CHAR
001CE1  2  AA                   TAX                     ; SAVE HERE
001CE2  2  A5 9D                LDA     OUT+3           ; GRAB 4TH Z-CHAR
001CE4  2  09 80                ORA     #%10000000      ; SET HIGH BIT
001CE6  2  85 9C                STA     OUT+2           ; MOVE CRUSHED Z-WORD
001CE8  2  86 9D                STX     OUT+3           ; INTO PLACE
001CEA  2  60                   RTS
001CEB  2               
001CEB  2               ; -----------------------
001CEB  2               ; CHARSET #2 DECODE TABLE
001CEB  2               ; -----------------------
001CEB  2               
001CEB  2               CHRTBL:
001CEB  2  00                   .BYTE   0               ; DUMMY BYTE FOR "DIRECT"
001CEC  2  0D                   .BYTE   $0D             ; EOL
001CED  2  30 31 32 33          .BYTE   "0123456789.,!?_#"
001CF1  2  34 35 36 37  
001CF5  2  38 39 2E 2C  
001CFD  2  27                   .BYTE   $27             ; SINGLE QUOTE
001CFE  2  22                   .BYTE   $22             ; DOUBLE QUOTE
001CFF  2  2F 5C 2D 3A          .BYTE   "/\-:()"
001D03  2  28 29        
001D05  2               
001D05  1                       .INCLUDE "objects.asm"
001D05  2               ;        PAGE
001D05  2               ;        SBTTL   "--- OBJECT & PROPERTY HANDLERS ---"
001D05  2               
001D05  2               ; ----------------------------------
001D05  2               ; GET ABSOLUTE ADDRESS OF OBJECT [A]
001D05  2               ; ----------------------------------
001D05  2               
001D05  2               ; EXIT: ADDRESS IN [I]
001D05  2               
001D05  2               OBJLOC:
001D05  2  85 6E                STA     I+LO            ; SAVE LSB FOR ADDING
001D07  2               
001D07  2  A2 00                LDX     #0              ; CLEAR MSB
001D09  2  86 6F                STX     I+HI            ; FOR SHIFTING
001D0B  2               
001D0B  2  0A                   ASL     A               ; MULTIPLY BY 8
001D0C  2  26 6F                ROL     I+HI
001D0E  2  0A                   ASL     A
001D0F  2  26 6F                ROL     I+HI
001D11  2  0A                   ASL     A
001D12  2  26 6F                ROL     I+HI
001D14  2               
001D14  2  18                   CLC                     ; ADD TO ITSELF
001D15  2  65 6E                ADC     I+LO            ; TO GET TIMES 9
001D17  2  90 02                BCC     OBJ1
001D19  2  E6 6F                INC     I+HI
001D1B  2               
001D1B  2               OBJ1:
001D1B  2  18                   CLC
001D1C  2  69 35                ADC     #53             ; NOW ADD 53
001D1E  2  90 02                BCC     OBJ2            ; (THE OBJECT TABLE OFFSET)
001D20  2  E6 6F                INC     I+HI
001D22  2               
001D22  2               OBJ2:
001D22  2  18                   CLC                     ; NEXT ADD THE ABS ADDR
001D23  2  65 92                ADC     OBJTAB+LO       ; OF THE OBJECT TABLE
001D25  2  85 6E                STA     I+LO
001D27  2               
001D27  2  A5 6F                LDA     I+HI
001D29  2  65 93                ADC     OBJTAB+HI
001D2B  2  85 6F                STA     I+HI
001D2D  2  60                   RTS
001D2E  2               
001D2E  2               ; -----------------------------
001D2E  2               ; GET ADDRESS OF PROPERTY TABLE
001D2E  2               ; -----------------------------
001D2E  2               
001D2E  2               ; EXIT: [I] HAS ABSOLUTE ADDR OF PROPERTY TABLE
001D2E  2               ;       [Y] HAS OFFSET TO START OF PROP IDS
001D2E  2               
001D2E  2               PROPB:
001D2E  2  A5 62                LDA     ARG1+LO
001D30  2  20 05 1D             JSR     OBJLOC
001D33  2  A0 07                LDY     #7
001D35  2  B1 6E                LDA     (I),Y           ; GET MSB OF P-TABLE ADDRESS
001D37  2  18                   CLC
001D38  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
001D3A  2  AA                   TAX                     ; AND SAVE HERE
001D3B  2  C8                   INY
001D3C  2  B1 6E                LDA     (I),Y           ; NOW GET LSB
001D3E  2  85 6E                STA     I+LO
001D40  2  86 6F                STX     I+HI            ; [I] NOW POINTS TO PROP TABLE
001D42  2               
001D42  2  A0 00                LDY     #0
001D44  2  B1 6E                LDA     (I),Y           ; GET LENGTH OF SHORT DESC
001D46  2  0A                   ASL     A               ; WORD-ALIGN IT
001D47  2  A8                   TAY                     ; EXPECTED HERE
001D48  2  C8                   INY                     ; POINT JUST PAST THE DESCRIPTION
001D49  2  60                   RTS
001D4A  2               
001D4A  2               ; -------------------
001D4A  2               ; FETCH A PROPERTY ID
001D4A  2               ; -------------------
001D4A  2               
001D4A  2               ; ENTRY: LIKE "PROPB" EXIT
001D4A  2               
001D4A  2               PROPN:
001D4A  2  B1 6E                LDA     (I),Y
001D4C  2  29 1F                AND     #%00011111      ; MASK OUT LENGTH BITS
001D4E  2  60                   RTS
001D4F  2               
001D4F  2               ; -------------------------------
001D4F  2               ; FETCH # BYTES IN PROPERTY VALUE
001D4F  2               ; -------------------------------
001D4F  2               
001D4F  2               ; ENTRY: LIKE "PROPB" EXIT
001D4F  2               
001D4F  2               PROPL:
001D4F  2  B1 6E                LDA     (I),Y
001D51  2  4A                   LSR     A               ; LENGTH IS IN
001D52  2  4A                   LSR     A               ; BITS 7-5
001D53  2  4A                   LSR     A               ; SO SHIFT INTO PLACE
001D54  2  4A                   LSR     A
001D55  2  4A                   LSR     A
001D56  2  60                   RTS
001D57  2               
001D57  2               ; ----------------------
001D57  2               ; POINT TO NEXT PROPERTY
001D57  2               ; ----------------------
001D57  2               
001D57  2               ; ENTRY: LIKE "PROPB" EXIT
001D57  2               
001D57  2               PROPNX:
001D57  2  20 4F 1D             JSR     PROPL           ; GET LENGTH OF CURRENT PROP
001D5A  2  AA                   TAX                     ; SAVE HERE
001D5B  2               
001D5B  2               PPX:
001D5B  2  C8                   INY                     ; LOOP UNTIL
001D5C  2  CA                   DEX                     ; [Y] POINTS TO
001D5D  2  10 FC                BPL     PPX             ; START OF NEXT PROP
001D5F  2  C8                   INY                     ; CORRECT ALIGNMENT
001D60  2  60                   RTS
001D61  2               
001D61  2               ; ----------------
001D61  2               ; GET OBJECT FLAGS
001D61  2               ; ----------------
001D61  2               
001D61  2               ; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
001D61  2               ; EXIT: FLAG WORD IN [K], BIT ID IN [J],
001D61  2               ;       FLAG WORD ADDRESS IN [I]
001D61  2               
001D61  2               FLAGSU:
001D61  2  A5 62                LDA     ARG1+LO
001D63  2  20 05 1D             JSR     OBJLOC          ; GET OBJECT ADDR IN [I]
001D66  2               
001D66  2  A5 64                LDA     ARG2+LO         ; LOOK AT FLAG ID
001D68  2  C9 10                CMP     #$10            ; FIRST SET OF FLAGS?
001D6A  2  90 0F                BCC     FLS1            ; YES, ADDR IN [I] IS CORRECT
001D6C  2               
001D6C  2  E9 10                SBC     #16             ; ELSE ZERO-ALIGN FLAG INDEX
001D6E  2  AA                   TAX                     ; SAVE IT HERE
001D6F  2               
001D6F  2  A5 6E                LDA     I+LO            ; ADD 2 TO ADDRESS IN [I]
001D71  2  18                   CLC                     ; TO POINT TO ADDRESS OF
001D72  2  69 02                ADC     #2              ; 2ND FLAG WORD
001D74  2  85 6E                STA     I+LO
001D76  2  90 02                BCC     FLS0
001D78  2  E6 6F                INC     I+HI
001D7A  2               
001D7A  2               FLS0:
001D7A  2  8A                   TXA                     ; RESTORE INDEX
001D7B  2               
001D7B  2               FLS1:
001D7B  2  85 72                STA     K+LO            ; SAVE FLAG ID HERE
001D7D  2               
001D7D  2  A2 01                LDX     #1              ; INIT THE
001D7F  2  86 70                STX     J+LO            ; FLAG WORD TO
001D81  2  CA                   DEX                     ; $0001
001D82  2  86 71                STX     J+HI
001D84  2               
001D84  2  A9 0F                LDA     #15             ; SUBTRACT THE BIT POSITION
001D86  2  38                   SEC                     ; FROM 15
001D87  2  E5 72                SBC     K+LO            ; TO GET THE SHIFT LOOP
001D89  2  AA                   TAX                     ; INDEX
001D8A  2  F0 07                BEQ     FLS2            ; EXIT NOW IF NO SHIFT NEEDED
001D8C  2               
001D8C  2               FLSL:
001D8C  2  06 70                ASL     J+LO            ; SHIFT THE BIT
001D8E  2  26 71                ROL     J+HI            ; INTO POSITION
001D90  2  CA                   DEX
001D91  2  D0 F9                BNE     FLSL
001D93  2               
001D93  2               FLS2:
001D93  2  A0 00                LDY     #0              ; MOVE THE FLAG WORD
001D95  2  B1 6E                LDA     (I),Y           ; INTO [J]
001D97  2  85 73                STA     K+HI            ; FIRST THE MSB
001D99  2  C8                   INY
001D9A  2  B1 6E                LDA     (I),Y
001D9C  2  85 72                STA     K+LO            ; THEN THE LSB
001D9E  2  60                   RTS
001D9F  2               
001D9F  1               
001D9F  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT I/O"
001D9F  1                       .INCLUDE "io.asm"
001D9F  2               ;        PAGE
001D9F  2               ;        SBTTL   "--- GAME I/O: DOS/65 ---"
001D9F  2               
001D9F  2               ; --------------
001D9F  2               ; INTERNAL ERROR
001D9F  2               ; --------------
001D9F  2               
001D9F  2               ; ENTRY: ERROR CODE IN [A]
001D9F  2               
001D9F  2               ERRM:
001D9F  2  49 6E 74 65          .BYTE   "Internal error "
001DA3  2  72 6E 61 6C  
001DA7  2  20 65 72 72  
001DAE  2               ENUMB:
001DAE  2  30 30 2E             .BYTE   "00."
001DB1  2               ERRML           = *-ERRM
001DB1  2               
001DB1  2               ZERROR:
001DB1  2  A0 01                LDY     #1              ; CONVERT ERROR BYTE IN [A]
001DB3  2               ECON:
001DB3  2  20 15 26             JSR     DIV10           ; TO ASCII DECIMAL IN [ENUMB]
001DB6  2  09 30                ORA     #'0'
001DB8  2  99 AE 1D             STA     ENUMB,Y
001DBB  2  8A                   TXA
001DBC  2  88                   DEY
001DBD  2  10 F4                BPL     ECON
001DBF  2               
001DBF  2  20 D0 1E             JSR     ZCRLF           ; CLEAR BUFFER
001DC2  2  A9 00                LDA     #0
001DC4  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001DC6  2               
001DC6  2  A2 9F                LDX     #<ERRM
001DC8  2  A9 1D                LDA     #>ERRM
001DCA  2  A0 12                LDY     #ERRML
001DCC  2  20 3F 21             JSR     DLINE
001DCF  2               
001DCF  2               ; FALL THROUGH ...
001DCF  2               
001DCF  2               ; ----
001DCF  2               ; QUIT
001DCF  2               ; ----
001DCF  2               
001DCF  2               ZQUIT:
001DCF  2  20 D0 1E             JSR     ZCRLF           ; FLUSH BUFFER
001DD2  2               
001DD2  2  A2 E0                LDX     #<TOQ
001DD4  2  A9 1D                LDA     #>TOQ
001DD6  2  A0 10                LDY     #TOQL
001DD8  2  20 3F 21             JSR     DLINE           ; "END OF STORY"
001DDB  2  A2 00                LDX     #0
001DDD  2  4C 03 01             JMP     PEM
001DE0  2               
001DE0  2               TOQ:
001DE0  2  45 6E 64 20          .BYTE   "End of session."
001DE4  2  6F 66 20 73  
001DE8  2  65 73 73 69  
001DEF  2  0D                   .BYTE   EOL
001DF0  2               TOQL            = *-TOQ
001DF0  2               
001DF0  2               ; -------
001DF0  2               ; RESTART
001DF0  2               ; -------
001DF0  2               
001DF0  2               ZSTART:
001DF0  2  20 D0 1E             JSR     ZCRLF
001DF3  2               
001DF3  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; SAVE SCRIPT STATE
001DF6  2  29 01                AND     #%00000001      ; FOR LATER
001DF8  2  8D 52 21             STA     SFLAG           ; (BM 5/14/85)
001DFB  2               
001DFB  2  4C 21 0E             JMP     WARM1           ; AND DO A WARMSTART
001DFE  2               
001DFE  2               ; --------------------
001DFE  2               ; PRINT VERSION NUMBER
001DFE  2               ; --------------------
001DFE  2               
001DFE  2               VERS:
001DFE  2  44 4F 53 2F          .BYTE   "DOS/65 Version F"
001E02  2  36 35 20 56  
001E06  2  65 72 73 69  
001E0E  2  0D                   .BYTE   EOL
001E0F  2               VERSL           = *-VERS
001E0F  2               
001E0F  2               VERNUM:
001E0F  2  20 D0 1E             JSR     ZCRLF
001E12  2               
001E12  2  A2 FE                LDX     #<VERS
001E14  2  A9 1D                LDA     #>VERS
001E16  2  A0 11                LDY     #VERSL
001E18  2  4C 3F 21             JMP     DLINE
001E1B  2               
001E1B  2               ; --------------------------
001E1B  2               ; RETURN TOP RAM PAGE IN [A]
001E1B  2               ; --------------------------
001E1B  2               
001E1B  2               MEMTOP:
001E1B  2  A9 CF                LDA     #$CF            ; IT'S A GIVEN
001E1D  2  60                   RTS
001E1E  2               
001E1E  2               ; --------------------------------
001E1E  2               ; RETURN RANDOM BYTES IN [A] & [X]
001E1E  2               ; --------------------------------
001E1E  2               RANDOM:
001E1E  2  18                   CLC
001E1F  2  A9 41                LDA     #$41
001E21  2  6D 88 1E             ADC     state+0
001E24  2  8D 88 1E             STA     state+0
001E27  2  6D 89 1E             ADC     state+1
001E2A  2  8D 89 1E             STA     state+1
001E2D  2  6D 8A 1E             ADC     state+2
001E30  2  8D 8A 1E             STA     state+2
001E33  2  6D 8B 1E             ADC     state+3
001E36  2  8D 8B 1E             STA     state+3
001E39  2  6D 8C 1E             ADC     state+4
001E3C  2  0A                   ASL
001E3D  2  6D 8B 1E             ADC     state+3
001E40  2  8D 8C 1E             STA     state+4
001E43  2  4D 8A 1E             EOR     state+2
001E46  2  AA                   TAX
001E47  2  18                   CLC
001E48  2  A9 41                LDA     #$41
001E4A  2  6D 8D 1E             ADC     state1+0
001E4D  2  8D 8D 1E             STA     state1+0
001E50  2  6D 8E 1E             ADC     state1+1
001E53  2  8D 8E 1E             STA     state1+1
001E56  2  6D 8F 1E             ADC     state1+2
001E59  2  8D 8F 1E             STA     state1+2
001E5C  2  6D 90 1E             ADC     state1+3
001E5F  2  8D 90 1E             STA     state1+3
001E62  2  6D 91 1E             ADC     state1+4
001E65  2  0A                   ASL
001E66  2  6D 90 1E             ADC     state1+3
001E69  2  8D 91 1E             STA     state1+4
001E6C  2  4D 8F 1E             EOR     state1+2
001E6F  2               
001E6F  2  8D 8D 1E             STA     state1
001E72  2  EE 88 1E             INC     state
001E75  2  EE 8E 1E             INC     state1+1
001E78  2  8E 89 1E             STX     state+1
001E7B  2  EE 8F 1E             INC     state1+2
001E7E  2  EE 90 1E             INC     state1+3
001E81  2  EE 8B 1E             INC     state+3
001E84  2  EE 8C 1E             INC     state+4
001E87  2  60                   RTS
001E88  2               ; RANDOM SEEDS
001E88  2               state:
001E88  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001E8C  2  00           
001E8D  2               state1:
001E8D  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001E91  2  00           
001E92  2               
001E92  2               
001E92  2               
001E92  2               ; -------------------
001E92  2               ; Z-PRINT A CHARACTER
001E92  2               ; -------------------
001E92  2               
001E92  2               ; ENTRY: ASCII CHAR IN [A]
001E92  2               
001E92  2               COUT:
001E92  2  C9 0D                CMP     #EOL            ; IF EOL,
001E94  2  F0 3A                BEQ     ZCRLF           ; DO IT!
001E96  2  C9 20                CMP     #SPACE          ; IGNORE ALL OTHER
001E98  2  90 0B                BCC     CEX             ; CONTROLS
001E9A  2               
001E9A  2  A6 BD                LDX     LENGTH          ; ELSE GET LINE POINTER
001E9C  2  9D 00 07             STA     LBUFF,X         ; ADD CHAR TO BUFFER
001E9F  2  E0 4F                CPX     #XSIZE          ; END OF LINE?
001EA1  2  B0 03                BCS     FLUSH           ; YES, FLUSH THE LINE
001EA3  2  E6 BD                INC     LENGTH          ; ELSE UPDATE POINTER
001EA5  2               
001EA5  2               CEX:
001EA5  2  60                   RTS
001EA6  2               
001EA6  2               ; -------------------
001EA6  2               ; FLUSH OUTPUT BUFFER
001EA6  2               ; -------------------
001EA6  2               
001EA6  2               ; ENTRY: LENGTH OF BUFFER IN [X]
001EA6  2               
001EA6  2               FLUSH:
001EA6  2  A9 20                LDA     #SPACE
001EA8  2               
001EA8  2               FL0:
001EA8  2  DD 00 07             CMP     LBUFF,X         ; FIND LAST SPACE CHAR
001EAB  2  F0 05                BEQ     FL1             ; IN THE LINE
001EAD  2  CA                   DEX
001EAE  2  D0 F8                BNE     FL0             ; IF NONE FOUND,
001EB0  2  A2 4F                LDX     #XSIZE          ; FLUSH ENTIRE LINE
001EB2  2               
001EB2  2               FL1:
001EB2  2  86 BE                STX     OLDLEN          ; SAVE OLD LINE POS HERE
001EB4  2  86 BD                STX     LENGTH          ; MAKE IT THE NEW LINE LENGTH
001EB6  2               
001EB6  2  20 D0 1E             JSR     ZCRLF           ; PRINT LINE UP TO LAST SPACE
001EB9  2               
001EB9  2               ; START NEW LINE WITH REMAINDER OF OLD
001EB9  2               
001EB9  2  A6 BE                LDX     OLDLEN          ; GET OLD LINE POS
001EBB  2  A0 00                LDY     #0              ; START NEW LINE AT BEGINNING
001EBD  2               FL2:
001EBD  2  E8                   INX
001EBE  2  E0 4F                CPX     #XSIZE          ; CONTINUE IF
001EC0  2  90 05                BCC     FL3             ; INSIDE OR
001EC2  2  F0 03                BEQ     FL3             ; AT END OF LINE
001EC4  2  84 BD                STY     LENGTH          ; ELSE SET NEW LINE LENGTH
001EC6  2  60                   RTS
001EC7  2               
001EC7  2               FL3:
001EC7  2  BD 00 07             LDA     LBUFF,X         ; GET CHAR FROM OLD LINE
001ECA  2  99 00 07             STA     LBUFF,Y         ; MOVE TO START OF NEW LINE
001ECD  2  C8                   INY                     ; UPDATE LENGTH OF NEW LINE
001ECE  2  D0 ED                BNE     FL2
001ED0  2               
001ED0  2               ; ---------------
001ED0  2               ; CARRIAGE RETURN
001ED0  2               ; ---------------
001ED0  2               
001ED0  2               ZCRLF:
001ED0  2  E6 C2                INC     LINCNT          ; NEW LINE GOING OUT
001ED2  2  A5 C2                LDA     LINCNT          ; IS IT TIME TO
001ED4  2  C5 C3                CMP     LMAX            ; PRINT "MORE" YET?
001ED6  2  90 22                BCC     CR1             ; NO, CONTINUE
001ED8  2               
001ED8  2               ; SCREEN FULL; PRINT "MORE"
001ED8  2               
001ED8  2  20 42 1F             JSR     ZUSL            ; UPDATE STATUS LINE
001EDB  2               
001EDB  2  A9 00                LDA     #0
001EDD  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
001EDF  2  20 F1 21             JSR     BOLD
001EE2  2  A2 1D                LDX     #<MORE
001EE4  2  A9 1F                LDA     #>MORE
001EE6  2  A0 06                LDY     #MOREL
001EE8  2  20 3F 21             JSR     DLINE           ; PRINT "MORE" DIRECTLY
001EEB  2  20 FF 21             JSR     UNBOLD
001EEE  2               ZCR0:
001EEE  2  20 88 20             JSR     GETKEY          ; GET KEYPRESS
001EF1  2  A2 23                LDX     #<MCLR
001EF3  2  A9 1F                LDA     #>MCLR
001EF5  2  A0 12                LDY     #MCLRL
001EF7  2  20 3F 21             JSR     DLINE           ; RUB OUT "MORE"
001EFA  2               
001EFA  2               CR1:
001EFA  2  A6 BD                LDX     LENGTH
001EFC  2  A9 0D                LDA     #EOL            ; INSTALL EOL AT
001EFE  2  9D 00 07             STA     LBUFF,X         ; END OF CURRENT LINE
001F01  2  E6 BD                INC     LENGTH          ; UPDATE LINE LENGTH
001F03  2               
001F03  2               LINOUT:
001F03  2  A4 BD                LDY     LENGTH          ; IF BUFFER EMPTY,
001F05  2  F0 11                BEQ     LINEX           ; DON'T PRINT ANYTHING
001F07  2               
001F07  2  84 CC                STY     PRLEN           ; SAVE LENGTH HERE FOR "PPRINT"
001F09  2  A2 00                LDX     #0              ; SEND CONTENTS OF [LBUFF]
001F0B  2               LOUT:
001F0B  2  BD 00 07             LDA     LBUFF,X         ; TO SCREEN
001F0E  2  20 C6 20             JSR     CHAR
001F11  2  E8                   INX
001F12  2  88                   DEY
001F13  2  D0 F6                BNE     LOUT
001F15  2               
001F15  2  20 53 21             JSR     PPRINT          ; PRINT [LBUFF] IF ENABLED
001F18  2               
001F18  2               LINEX:
001F18  2  A9 00                LDA     #0              ; RESET LINE LENGTH
001F1A  2  85 BD                STA     LENGTH          ; TO ZERO
001F1C  2  60                   RTS                     ; AND RETURN
001F1D  2               
001F1D  2               MORE:
001F1D  2  5B 4D 4F 52          .BYTE   "[MORE]"
001F21  2  45 5D        
001F23  2               MOREL           = *-MORE
001F23  2               
001F23  2               MCLR:
001F23  2  08 08 08 08          .BYTE   08,08,08,08,08,08,"      ",08,08,08,08,08,08
001F27  2  08 08 20 20  
001F2B  2  20 20 20 20  
001F35  2               MCLRL           = *-MCLR
001F35  2               
001F35  2               ; ----------------------
001F35  2               ; UPDATE THE STATUS LINE
001F35  2               ; ----------------------
001F35  2               
001F35  2               SCORE:
001F35  2  53 63 6F 72          .BYTE   "Score: "
001F39  2  65 3A 20     
001F3C  2               SCOREL          = *-SCORE
001F3C  2               
001F3C  2               CLOCK:
001F3C  2  54 69 6D 65          .BYTE   "Time: "
001F40  2  3A 20        
001F42  2               CLOCKL          = *-CLOCK
001F42  2               
001F42  2               
001F42  2               ZUSL:
001F42  2  A5 BD                LDA     LENGTH          ; SAVE ALL
001F44  2  48                   PHA                     ; STRING-PRINTING
001F45  2  A5 7E                LDA     MPCH            ; VARIABLES
001F47  2  48                   PHA
001F48  2  A5 7D                LDA     MPCM
001F4A  2  48                   PHA
001F4B  2  A5 7C                LDA     MPCL
001F4D  2  48                   PHA
001F4E  2  A5 AA                LDA     TSET
001F50  2  48                   PHA
001F51  2  A5 A9                LDA     PSET
001F53  2  48                   PHA
001F54  2  A5 AF                LDA     ZWORD+HI
001F56  2  48                   PHA
001F57  2  A5 AE                LDA     ZWORD+LO
001F59  2  48                   PHA
001F5A  2  A5 AD                LDA     ZFLAG
001F5C  2  48                   PHA
001F5D  2  A5 BB                LDA     DIGITS
001F5F  2  48                   PHA
001F60  2               
001F60  2  A2 4F                LDX     #XSIZE
001F62  2               USL0:
001F62  2  BD 00 07             LDA     LBUFF,X         ; MOVE CONTENTS OF [LBUFF]
001F65  2  9D 20 0D             STA     BUFSAV,X        ; TO [BUFSAV]
001F68  2  A9 20                LDA     #SPACE          ; CLEAR
001F6A  2  9D 00 07             STA     LBUFF,X         ; [LBUFF] WITH SPACES
001F6D  2  CA                   DEX
001F6E  2  10 F2                BPL     USL0
001F70  2               
001F70  2  A9 00                LDA     #0
001F72  2  85 BD                STA     LENGTH          ; RESET LINE LENGTH
001F74  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001F76  2  20 0D 22             JSR     REVERSE
001F79  2  A2 00                LDX     #0
001F7B  2  A0 00                LDY     #0
001F7D  2  20 8E 21             JSR     PLOT
001F80  2               ;
001F80  2               ; PRINT ROOM DESCRIPTION
001F80  2               ;
001F80  2  A9 10                LDA     #16             ; GLOBAL VAR #16 (ROOM ID)
001F82  2  20 68 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001F85  2  A5 6C                LDA     VALUE+LO
001F87  2  20 62 13             JSR     PRNTDC          ; PRINT SHORT ROOM DESCRIPTION
001F8A  2               
001F8A  2  A9 18                LDA     #24             ; MOVE LINE INDEX UP
001F8C  2  85 BD                STA     LENGTH          ; TO TIME/SCORE POSITION
001F8E  2               
001F8E  2  A9 11                LDA     #17             ; GLOBAL VAR #17 (SCORE/HOURS)
001F90  2  20 68 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001F93  2               
001F93  2  A5 BC                LDA     TIMEFL          ; GET MODE FLAG
001F95  2  D0 32                BNE     DOTIME          ; USE TIME MODE IF NON-ZERO
001F97  2               ;
001F97  2               ; PRINT "SCORE"
001F97  2               ;
001F97  2  A9 53                LDA     #'S'
001F99  2  20 92 1E             JSR     COUT
001F9C  2  A9 63                LDA     #'c'
001F9E  2  20 92 1E             JSR     COUT
001FA1  2  A9 6F                LDA     #'o'
001FA3  2  20 92 1E             JSR     COUT
001FA6  2  A9 72                LDA     #'r'
001FA8  2  20 92 1E             JSR     COUT
001FAB  2  A9 65                LDA     #'e'
001FAD  2  20 92 1E             JSR     COUT
001FB0  2  A9 3A                LDA     #':'
001FB2  2  20 92 1E             JSR     COUT
001FB5  2  A9 20                LDA     #SPACE
001FB7  2  20 92 1E             JSR     COUT
001FBA  2               
001FBA  2  A5 6C                LDA     VALUE+LO        ; MOVE SCORE VALUE
001FBC  2  85 B3                STA     QUOT+LO         ; INTO [QUOT]
001FBE  2  A5 6D                LDA     VALUE+HI        ; FOR PRINTING
001FC0  2  85 B4                STA     QUOT+HI
001FC2  2  20 BE 17             JSR     NUMBER          ; PRINT SCORE VALUE IN DECIMAL
001FC5  2               ;
001FC5  2  A9 2F                LDA     #'/'            ; PRINT A SLASH
001FC7  2  D0 35                BNE     MOVMIN          ; BRANCH ALWAYS
001FC9  2               
001FC9  2               ; PRINT "TIME"
001FC9  2               
001FC9  2               DOTIME:
001FC9  2  A9 54                LDA     #'T'
001FCB  2  20 92 1E             JSR     COUT
001FCE  2  A9 69                LDA     #'i'
001FD0  2  20 92 1E             JSR     COUT
001FD3  2  A9 6D                LDA     #'m'
001FD5  2  20 92 1E             JSR     COUT
001FD8  2  A9 65                LDA     #'e'
001FDA  2  20 92 1E             JSR     COUT
001FDD  2  A9 3A                LDA     #':'
001FDF  2  20 92 1E             JSR     COUT
001FE2  2  A9 20                LDA     #SPACE
001FE4  2  20 92 1E             JSR     COUT
001FE7  2               ;
001FE7  2  A5 6C                LDA     VALUE+LO        ; 00 IS REALLY 24
001FE9  2  D0 02                BNE     DT0
001FEB  2  A9 18                LDA     #24
001FED  2               DT0:
001FED  2  C9 0D                CMP     #13             ; IS HOURS > 12,
001FEF  2  90 02                BCC     DT1
001FF1  2  E9 0C                SBC     #12             ; CONVERT TO 1-12
001FF3  2               DT1:
001FF3  2  85 B3                STA     QUOT+LO         ; MOVE FOR PRINTING
001FF5  2  A9 00                LDA     #0
001FF7  2  85 B4                STA     QUOT+HI         ; CLEAR MSB
001FF9  2  20 BE 17             JSR     NUMBER
001FFC  2               
001FFC  2  A9 3A                LDA     #':'            ; COLON
001FFE  2               MOVMIN:
001FFE  2  20 92 1E             JSR     COUT            ; PRINT SLASH OR COLON
002001  2               
002001  2  A9 12                LDA     #18             ; GLOBAL VAR #18 (MOVES/MINUTES)
002003  2  20 68 10             JSR     GETVRG          ; GET IT INTO [VALUE]
002006  2  A5 6C                LDA     VALUE+LO        ; MOVE TO [QUOT]
002008  2  85 B3                STA     QUOT+LO         ; FOR EVENTUAL PRINTING
00200A  2  A5 6D                LDA     VALUE+HI
00200C  2  85 B4                STA     QUOT+HI
00200E  2               
00200E  2  A5 BC                LDA     TIMEFL          ; WHICH MODE?
002010  2  D0 06                BNE     DOMINS          ; TIME IF NZ
002012  2               ;
002012  2               ; PRINT NUMBER OF MOVES
002012  2               ;
002012  2  20 BE 17             JSR     NUMBER          ; SHOW # MOVES
002015  2  4C 44 20             JMP     STATEX          ; ALL DONE
002018  2               ;
002018  2               ; PRINT MINUTES
002018  2               ;
002018  2               DOMINS:
002018  2  A5 6C                LDA     VALUE+LO        ; CHECK MINUTES
00201A  2  C9 0A                CMP     #10             ; IF MORE THAN TEN
00201C  2  B0 05                BCS     DOM0            ; CONTINUE
00201E  2               
00201E  2  A9 30                LDA     #'0'            ; ELSE PRINT A
002020  2  20 92 1E             JSR     COUT            ; PADDING "0" FIRST
002023  2               
002023  2               DOM0:
002023  2  20 BE 17             JSR     NUMBER          ; SHOW MINUTES
002026  2               
002026  2  A9 20                LDA     #SPACE
002028  2  20 92 1E             JSR     COUT            ; SEPARATE THINGS
00202B  2               ;
00202B  2  A9 11                LDA     #17             ; CHECK "HOURS" AGAIN
00202D  2  20 68 10             JSR     GETVRG
002030  2  A5 6C                LDA     VALUE+LO
002032  2  C9 0C                CMP     #12             ; PAST NOON?
002034  2  B0 04                BCS     DOPM            ; YES, PRINT "PM"
002036  2               
002036  2  A9 41                LDA     #'A'            ; ELSE PRINT "AM"
002038  2  D0 02                BNE     DOXM            ; BRANCH ALWAYS
00203A  2               
00203A  2               DOPM:
00203A  2  A9 50                LDA     #'P'
00203C  2               
00203C  2               DOXM:
00203C  2  20 92 1E             JSR     COUT
00203F  2  A9 4D                LDA     #'M'
002041  2  20 92 1E             JSR     COUT
002044  2               ;
002044  2               ; STATUS LINE READY
002044  2               ;
002044  2               STATEX:
002044  2  A9 4F                LDA     #XSIZE          ; PRINT THE ENTIRE
002046  2  85 BD                STA     LENGTH          ; STATUS LINE
002048  2  20 FA 1E             JSR     CR1
00204B  2               
00204B  2  A2 4F                LDX     #XSIZE          ; RESTORE OLD [LBUFF]
00204D  2               USLX:
00204D  2  BD 20 0D             LDA     BUFSAV,X
002050  2  9D 00 07             STA     LBUFF,X
002053  2  CA                   DEX
002054  2  10 F7                BPL     USLX
002056  2               
002056  2  68                   PLA                     ; RESTORE ALL
002057  2  85 BB                STA     DIGITS          ; SAVED VARIABLES
002059  2  68                   PLA
00205A  2  85 AD                STA     ZFLAG
00205C  2  68                   PLA
00205D  2  85 AE                STA     ZWORD+LO
00205F  2  68                   PLA
002060  2  85 AF                STA     ZWORD+HI
002062  2  68                   PLA
002063  2  85 A9                STA     PSET
002065  2  68                   PLA
002066  2  85 AA                STA     TSET
002068  2  68                   PLA
002069  2  85 7C                STA     MPCL
00206B  2  68                   PLA
00206C  2  85 7D                STA     MPCM
00206E  2  68                   PLA
00206F  2  85 7E                STA     MPCH
002071  2  68                   PLA
002072  2  85 BD                STA     LENGTH
002074  2               
002074  2  A2 00                LDX     #0              ; RESTORE CURSOR
002076  2  A0 18                LDY     #YSIZE
002078  2  18                   CLC
002079  2  20 8E 21             JSR     PLOT
00207C  2               ;
00207C  2  A2 FF                LDX     #$FF
00207E  2  86 BF                STX     SCRIPT          ; RE-ENABLE SCRIPTING
002080  2  E8                   INX                     ; = 0
002081  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
002083  2  E8                   INX                     ; = 1
002084  2  20 FF 21             JSR     UNBOLD
002087  2  60                   RTS
002088  2               
002088  1                       .INCLUDE "machine.asm"
002088  2               ;        PAGE
002088  2               ;        SBTTL   "--- MACHINE-DEPENDENT I/O: DOS/65 ---"
002088  2               
002088  2               ; ----------------------------
002088  2               ; FETCH ASCII KEYCODE INTO [A]
002088  2               ; ----------------------------
002088  2               
002088  2               ; EXIT: ASCII IN [A] & [IOCHAR]
002088  2               
002088  2               GETKEY:
002088  2  8A                   TXA                     ; SAVE [X] & [Y]
002089  2  48                   PHA
00208A  2  98                   TYA
00208B  2  48                   PHA
00208C  2               GKEY1:
00208C  2  A2 06                LDX     #6              ;  GET KEY INTO [A]
00208E  2  20 03 01             JSR     PEM             ;
002091  2  C9 00                CMP     #$00
002093  2  F0 F7                BEQ     GKEY1           ; NOT IF CODE WAS ZERO
002095  2               
002095  2  C9 0D                CMP     #EOL            ; EOL?
002097  2  F0 24                BEQ     GOODKEY
002099  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
00209B  2  F0 20                BEQ     GOODKEY
00209D  2  C9 20                CMP     #SPACE          ; ANYTHING ELSE < "SPACE"
00209F  2  90 16                BCC     BADKEY          ; IS BAD
0020A1  2               
0020A1  2  C9 7B                CMP     #'z'+1
0020A3  2  B0 12                BCS     BADKEY
0020A5  2  C9 61                CMP     #'a'
0020A7  2  B0 14                BCS     GOODKEY
0020A9  2               
0020A9  2  C9 41                CMP     #'A'            ; TO ASCII LOWER CASE
0020AB  2  90 10                BCC     GOODKEY
0020AD  2  C9 5B                CMP     #'Z'+1
0020AF  2  B0 06                BCS     BADKEY
0020B1  2  18                   CLC
0020B2  2  69 20                ADC     #$20
0020B4  2  4C BD 20             JMP     GOODKEY
0020B7  2               
0020B7  2               BADKEY:
0020B7  2  20 86 21             JSR     BOOP            ; REJECT BAD KEYPRESS
0020BA  2  4C 8C 20             JMP     GKEY1           ; AND TRY AGAIN
0020BD  2               
0020BD  2               GOODKEY:
0020BD  2  85 C4                STA     IOCHAR          ; SAVE KEYCODE HERE
0020BF  2  68                   PLA                     ; RESTORE [X] & [Y]
0020C0  2  A8                   TAY
0020C1  2  68                   PLA
0020C2  2  AA                   TAX
0020C3  2  A5 C4                LDA     IOCHAR          ; GET KEYCODE HERE
0020C5  2               
0020C5  2  60                   RTS
0020C6  2               
0020C6  2               ; -------------------------
0020C6  2               ; OUTPUT AN ASCII CHARACTER
0020C6  2               ; -------------------------
0020C6  2               CHAR:
0020C6  2               LETTER:
0020C6  2  85 C4                STA     IOCHAR          ; SAVE HERE
0020C8  2  48                   PHA                     ; SAVE [A]
0020C9  2  8A                   TXA                     ; SAVE [X] & [Y]
0020CA  2  48                   PHA
0020CB  2  98                   TYA
0020CC  2  48                   PHA
0020CD  2  A5 C4                LDA     IOCHAR
0020CF  2  C9 0D                CMP     #13
0020D1  2  D0 0B                BNE     :+
0020D3  2  E6 C2                INC     LINCNT
0020D5  2  A9 0A                LDA     #10             ;  IS A CR, SO ADD A LF
0020D7  2  A2 02                LDX     #2              ;
0020D9  2  20 03 01             JSR     PEM             ;
0020DC  2  A9 0D                LDA     #13
0020DE  2               :
0020DE  2  A2 02                LDX     #2              ;  OUTPUT CHAR FROM [A]
0020E0  2  20 03 01             JSR     PEM             ;
0020E3  2               
0020E3  2  68                   PLA                     ; RESTORE [X] & [Y]
0020E4  2  A8                   TAY
0020E5  2  68                   PLA
0020E6  2  AA                   TAX
0020E7  2  68                   PLA
0020E8  2  60                   RTS
0020E9  2               
0020E9  2               
0020E9  2               
0020E9  2               ; ---------------------
0020E9  2               ; FETCH A LINE OF INPUT
0020E9  2               ; ---------------------
0020E9  2               
0020E9  2               ; ENTRY: ABS ADDR OF READ BUFFER IN [ARG1]
0020E9  2               ; EXIT: # CHARS READ IN [A]
0020E9  2               
0020E9  2               INPUT:
0020E9  2  20 03 1F             JSR     LINOUT          ; FLUSH [LBUFF]
0020EC  2               
0020EC  2  20 C1 22             JSR     CURSON          ; ACTIVATE CURSOR, CLEAR KEY QUEUE
0020EF  2               
0020EF  2  A0 00                LDY     #0
0020F1  2  84 C2                STY     LINCNT          ; RESET LINE COUNT
0020F3  2               
0020F3  2               INLOOP:
0020F3  2  20 88 20             JSR     GETKEY          ; GET ASCII INTO [A] AND [IOCHAR]
0020F6  2               
0020F6  2  C9 0D                CMP     #EOL            ; EOL?
0020F8  2  F0 2A                BEQ     ENDLIN          ; LINE DONE IF SO
0020FA  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
0020FC  2  F0 1C                BEQ     BACKUP          ; SPECIAL HANDLING
0020FE  2               
0020FE  2  99 00 07             STA     LBUFF,Y         ; ELSE ADD CHAR TO INPUT BUFFER
002101  2  C8                   INY                     ; NEXT POSITION IN LINE
002102  2               
002102  2               SHOWIT:
002102  2  20 C6 20             JSR     CHAR            ; SEND TO SCREEN
002105  2               
002105  2  C0 4D                CPY     #77             ; 2 SCREEN LINES FULL?
002107  2  90 EA                BCC     INLOOP          ; NO, GET ANOTHER CHAR
002109  2               
002109  2               ; HANDLE LINE OVERFLOW
002109  2               
002109  2               NOMORE:
002109  2  20 88 20             JSR     GETKEY
00210C  2  C9 0D                CMP     #EOL            ; IF EOL,
00210E  2  F0 14                BEQ     ENDLIN          ; WRAP UP THE LINE
002110  2  C9 08                CMP     #BACKSP         ; BACKSPACE
002112  2  F0 06                BEQ     BACKUP          ; IS OKAY TOO
002114  2  20 86 21             JSR     BOOP            ; ELSE COMPLAIN
002117  2  4C 09 21             JMP     NOMORE          ; AND INSIST
00211A  2               
00211A  2               ; HANDLE BACKSPACE
00211A  2               
00211A  2               BACKUP:
00211A  2  88                   DEY                     ; BACK UP THE POINTER
00211B  2  10 E5                BPL     SHOWIT          ; SEND BS IF NOT START OF LINE
00211D  2  20 86 21             JSR     BOOP            ; ELSE SCREAM WITH PAIN
002120  2  A0 00                LDY     #0              ; RESET POINTER
002122  2  F0 CF                BEQ     INLOOP          ; AND WAIT FOR SOMETHING BETTER
002124  2               
002124  2               ; HANDLE END OF LINE
002124  2               
002124  2               ENDLIN:
002124  2  99 00 07             STA     LBUFF,Y         ; SHIP EOL TO BUFFER
002127  2  C8                   INY                     ; UPDATE INDEX
002128  2  84 A2                STY     LINLEN          ; SAVE HERE FOR "READ"
00212A  2  84 CC                STY     PRLEN           ; AND HERE FOR "PPRINT"
00212C  2  A2 00                LDX     #0
00212E  2  20 C6 20             JSR     CHAR            ; AND SEND EOL TO SCREEN
002131  2               
002131  2               ; MOVE [LBUFF] TO [ARG1] W/LC CONVERSION
002131  2               
002131  2               LEX1:
002131  2  B9 FF 06             LDA     LBUFF-1,Y       ; GET A CHAR FROM [LBUFF]
002134  2  91 62                STA     (ARG1),Y        ; MOVE CHAR TO INPUT BUFFER AT [ARG1]
002136  2  88                   DEY                     ; LOOP TILL
002137  2  D0 F8                BNE     LEX1            ; ALL CHARS MOVED ("BNE" 8/14/85 BM)
002139  2               
002139  2  20 53 21             JSR     PPRINT          ; SCRIPT [LBUFF] IF ENABLED
00213C  2               
00213C  2  A5 A2                LDA     LINLEN          ; RESTORE # CHARS
00213E  2  60                   RTS                     ; INTO [A]
00213F  2               
00213F  2               ; -----------------------
00213F  2               ; DIRECT PRINT LINE [X/A]
00213F  2               ; -----------------------
00213F  2               
00213F  2               ; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
00213F  2               ;        STRING LENGTH IN [Y]
00213F  2               
00213F  2               DLINE:
00213F  2  8E 48 21             STX     STRING+LO       ; DROP STRING ADDRESS
002142  2  8D 49 21             STA     STRING+HI       ; INTO DUMMY BYTES
002145  2               
002145  2  A2 00                LDX     #0              ; INIT CHAR-FETCH INDEX
002147  2               
002147  2               DOUT:
002147  2  BD                   .BYTE   $BD             ; 6502 "LDA nnnn,X" OPCODE
002148  2               STRING:
002148  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
00214A  2  20 C6 20             JSR     CHAR
00214D  2  E8                   INX
00214E  2  88                   DEY                     ; LOOP TILL
00214F  2  D0 F6                BNE     DOUT            ; OUT OF CHARS
002151  2  60                   RTS
002152  2               
002152  2               ; -----------------------
002152  2               ; SEND [LBUFF] TO PRINTER
002152  2               ; -----------------------
002152  2               
002152  2               ; ENTRY: LENTH OF LINE IN [PRLEN]
002152  2               ; NOW WITH IMPROVED ERROR PROTECTION! (BM 11/24/84)
002152  2               
002152  2               SFLAG:
002152  2  00                   .BYTE   0               ; PREVIOUS SCRIPT MODE (BM 5/14/85)
002153  2               
002153  2               PPRINT:
002153  2  A5 BF                LDA     SCRIPT          ; SCRIPTING INTERNALLY ENABLED?
002155  2  F0 2C                BEQ     PEX             ; NO, SCRAM IMMEDIATELY
002157  2               
002157  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; CHECK SCRIPT FLAG
00215A  2  29 01                AND     #%00000001      ; SCRIPTING ON?
00215C  2  F0 1B                BEQ     PP3             ; NO, CHECK FOR "UNSCRIPT"
00215E  2               
00215E  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
002160  2  30 21                BMI     PEX             ; CAN'T OPEN IF NEGATIVE
002162  2  D0 04                BNE     PP1             ; ALREADY OPEN, SCRIPT THE LINE
002164  2               
002164  2               ; OPEN THE PRINTER FOR OUTPUT
002164  2  A2 01                LDX     #1
002166  2  86 CB                STX     PSTAT           ; SET STATUS TO "PRINTER OPENED" (1)
002168  2               
002168  2               PP1:
002168  2  A0 00                LDY     #0              ; INIT INDEX
00216A  2               PP2:
00216A  2               
00216A  2  B9 00 07             LDA     LBUFF,Y
00216D  2  A2 05                LDX     #5              ;  OUTPUT CHAR FROM [A] TO PRINTER (LST)
00216F  2  20 03 01             JSR     PEM             ;
002172  2  C8                   INY
002173  2  C6 CC                DEC     PRLEN
002175  2  D0 F3                BNE     PP2
002177  2  F0 0A                BEQ     PEX             ; RESET & RETURN
002179  2               
002179  2               ; CHECK FOR "UNSCRIPT"
002179  2               
002179  2               PP3:
002179  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
00217B  2  F0 06                BEQ     PEX             ; EXIT IF PRINTER WAS OFF
00217D  2  30 04                BMI     PEX             ; OR UNOPENABLE
00217F  2               
00217F  2               PCLOSE:
00217F  2  A9 00                LDA     #0              ; RESET PRINTER STATUS FLAG
002181  2  85 CB                STA     PSTAT           ; TO "CLOSED"
002183  2               
002183  2               PEX:
002183  2  60                   RTS
002184  2               
002184  2               ; ------------
002184  2               ; SPLIT SCREEN
002184  2               ; ------------
002184  2               ; NO SPLIT SCREEN IN DOS/65
002184  2               ZSPLIT:
002184  2               OFFSPL:
002184  2  60                   RTS
002185  2               
002185  2               ; ------
002185  2               ; SCREEN
002185  2               ; ------
002185  2               
002185  2               ; GO TO TOP WINDOW IF [A] = 0
002185  2               ; GO TO BOTTOM IF [A] = 1
002185  2               ; IGNORE IF SPLIT NOT ENABLED OR [A] <> 0 OR 1
002185  2               ZSCRN:
002185  2               ; SET TO TOP WINDOW
002185  2               TOTOP:
002185  2               ; SET TO BOTTOM WINDOW
002185  2               TOBOT:
002185  2               DOSCRN:
002185  2  60                   RTS
002186  2               
002186  2               ; ---------
002186  2               ; RAZZ USER
002186  2               ; ---------
002186  2               
002186  2               BOOP:
002186  2  A9 07                LDA     #7
002188  2  A2 02                LDX     #2
00218A  2  20 03 01             JSR     PEM
00218D  2  60                   RTS
00218E  2               
00218E  2               
00218E  2               PLOT:
00218E  2               ; ENTRY: [X] = X COORD
00218E  2               ;        [Y] = Y COORD
00218E  2               ; Convert X coordinate to 2 ASCII digits in PLOTCOLVAL
00218E  2  8A                   TXA                     ; Get X value
00218F  2  A2 01                LDX     #1              ; Start with ones digit
002191  2               ; Divide by 10 repeatedly to get digits
002191  2               :
002191  2  C9 0A                CMP     #10
002193  2  90 06                BCC     :+              ; Branch if < 10
002195  2  E9 0A                SBC     #10
002197  2  E8                   INX                     ; Count number of 10s
002198  2  4C 91 21             JMP     :-
00219B  2               :
00219B  2  18                   CLC
00219C  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
00219E  2  8D D2 21             STA     PLOTCOLVAL+1    ; Store ones digit
0021A1  2               
0021A1  2  8A                   TXA                     ; Get tens digit count
0021A2  2  18                   CLC
0021A3  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021A5  2  8D D1 21             STA     PLOTCOLVAL      ; Store tens digit
0021A8  2               ; Convert Y coordinate to 2 ASCII digits in PLOTROWVAL
0021A8  2  98                   TYA                     ; Get Y value
0021A9  2  A2 01                LDX     #1              ; Start with ones digit
0021AB  2               ; Divide by 10 repeatedly to get digits
0021AB  2               :
0021AB  2  C9 0A                CMP     #10
0021AD  2  90 06                BCC     :+              ; Branch if < 10
0021AF  2  E9 0A                SBC     #10
0021B1  2  E8                   INX                     ; Count number of 10s
0021B2  2  4C AB 21             JMP     :-
0021B5  2               :
0021B5  2  18                   CLC
0021B6  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
0021B8  2  8D CF 21             STA     PLOTROWVAL+1    ; Store ones digit
0021BB  2               
0021BB  2  8A                   TXA                     ; Get tens digit count
0021BC  2  18                   CLC
0021BD  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021BF  2  8D CE 21             STA     PLOTROWVAL      ; Store tens digit
0021C2  2               ;
0021C2  2  A2 CC                LDX     #<PLOTSTRING
0021C4  2  A9 21                LDA     #>PLOTSTRING
0021C6  2  A0 08                LDY     #8
0021C8  2  20 3F 21             JSR     DLINE
0021CB  2  60                   RTS
0021CC  2               PLOTSTRING:
0021CC  2  1B 5B                .BYTE   27,"["
0021CE  2               PLOTROWVAL:
0021CE  2  30 30                .BYTE   "00"
0021D0  2  3B                   .BYTE   ";"
0021D1  2               PLOTCOLVAL:
0021D1  2  30 30                .BYTE   "00"
0021D3  2  48                   .BYTE   "H"
0021D4  2               
0021D4  2               ; ------------------------
0021D4  2               ; CLEAR SCREEN
0021D4  2               ; ------------------------
0021D4  2               
0021D4  2               CLS:
0021D4  2  A9 14                LDA     #20
0021D6  2  85 C3                STA     LMAX
0021D8  2  A2 ED                LDX     #<CLSSTRING
0021DA  2  A9 21                LDA     #>CLSSTRING
0021DC  2  A0 04                LDY     #4
0021DE  2  20 3F 21             JSR     DLINE
0021E1  2  A9 00                LDA     #0
0021E3  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
0021E5  2  A2 00                LDX     #0
0021E7  2  A0 18                LDY     #YSIZE
0021E9  2  20 8E 21             JSR     PLOT
0021EC  2  60                   RTS
0021ED  2               CLSSTRING:
0021ED  2  1B 5B 32 4A          .BYTE   27,"[2J"
0021F1  2               
0021F1  2               BOLD:
0021F1  2  A2 FB                LDX     #<BOLDSTRING
0021F3  2  A9 21                LDA     #>BOLDSTRING
0021F5  2  A0 04                LDY     #4
0021F7  2  20 3F 21             JSR     DLINE
0021FA  2  60                   RTS
0021FB  2               BOLDSTRING:
0021FB  2  1B 5B 31 6D          .BYTE   27,"[1m"
0021FF  2               
0021FF  2               UNBOLD:
0021FF  2  A2 09                LDX     #<UNBOLDSTRING
002201  2  A9 22                LDA     #>UNBOLDSTRING
002203  2  A0 04                LDY     #4
002205  2  20 3F 21             JSR     DLINE
002208  2  60                   RTS
002209  2               UNBOLDSTRING:
002209  2  1B 5B 30 6D          .BYTE   27,"[0m"
00220D  2               
00220D  2               REVERSE:
00220D  2  A2 17                LDX     #<REVERSESTRING
00220F  2  A9 22                LDA     #>REVERSESTRING
002211  2  A0 04                LDY     #4
002213  2  20 3F 21             JSR     DLINE
002216  2  60                   RTS
002217  2               REVERSESTRING:
002217  2  1B 5B 37 6D          .BYTE   27,"[7m"
00221B  2               
00221B  1                       .INCLUDE "zdos.asm"
00221B  2               ;        PAGE
00221B  2               ;        SBTTL   "--- Z-DOS: DOS/65 ---"
00221B  2               
00221B  2               ; ---------------------
00221B  2               ; GET Z-BLOCK FROM DISK
00221B  2               ; ---------------------
00221B  2               
00221B  2               ; ENTRY: Z-BLOCK # IN [BLOCK]
00221B  2               ;        TARGET PAGE IN [DBUFF+HI]
00221B  2               GETDSK:
00221B  2  D8                   CLD
00221C  2  18                   CLC
00221D  2               
00221D  2  A5 CD                LDA     DBLOCK+LO       ; Load low byte of DBLOCK
00221F  2  0A                   ASL     A               ; Multiply by 2
002220  2  8D 03 25             STA     D65BLOCK+LO     ; Store low byte
002223  2  A5 CE                LDA     DBLOCK+HI       ; Load high byte of DBLOCK
002225  2  2A                   ROL     A               ; Rotate left (gets carry from previous ASL)
002226  2  8D 04 25             STA     D65BLOCK+HI     ; Store high byte
002229  2               
002229  2               ; read 256 byte block (zblock should be file block*2)
002229  2               ; EXTENT = INTEGER.PART.OF(n/128)
002229  2               ; 16 bit shift x6
002229  2  AD 03 25             LDA     D65BLOCK+LO     ; CALCULATE EXTENT
00222C  2  0A                   ASL     A
00222D  2  85 DE                STA     DTEMP+LO
00222F  2  AD 04 25             LDA     D65BLOCK+HI
002232  2  2A                   ROL     A
002233  2  8D CD 24             STA     GAMEFCB+12      ; = EXTENT (MAGIC!)
002236  2               
002236  2  AD 03 25             LDA     D65BLOCK+LO     ; CALCULATE RECORD = n-(EXTENT*128)
002239  2  29 7F                AND     #$7F
00223B  2  8D E1 24             STA     GAMEFCB+32      ; Store Record Number into FCB (Also Magic!)
00223E  2               
00223E  2  A9 C1                LDA     #<GAMEFCB       ; Open Extent
002240  2  A0 24                LDY     #>GAMEFCB
002242  2  A2 0F                LDX     #15
002244  2  20 03 01             JSR     PEM
002247  2  C9 FF                CMP     #$FF
002249  2  F0 48                BEQ     GETDSKERR
00224B  2               
00224B  2  A9 00                LDA     #0              ; Set Buffer Address
00224D  2  A4 D0                LDY     DBUFF+HI
00224F  2  A2 1A                LDX     #26
002251  2  20 03 01             JSR     PEM
002254  2               
002254  2  A9 C1                LDA     #<GAMEFCB       ; Read First sector (128 bytes)
002256  2  A0 24                LDY     #>GAMEFCB
002258  2  A2 14                LDX     #20
00225A  2  20 03 01             JSR     PEM
00225D  2  C9 FF                CMP     #$FF
00225F  2  F0 32                BEQ     GETDSKERR
002261  2               
002261  2  A9 80                LDA     #$80            ; Set Buffer Address
002263  2  A4 D0                LDY     DBUFF+HI
002265  2  A2 1A                LDX     #26
002267  2  20 03 01             JSR     PEM
00226A  2               
00226A  2  A9 C1                LDA     #<GAMEFCB       ; Read Second sector (128 bytes)
00226C  2  A0 24                LDY     #>GAMEFCB
00226E  2  A2 14                LDX     #20
002270  2  20 03 01             JSR     PEM
002273  2  C9 FF                CMP     #$FF
002275  2  F0 1C                BEQ     GETDSKERR
002277  2               
002277  2  A9 03                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
002279  2  A0 25                LDY     #>SPAREBYTES
00227B  2  A2 1A                LDX     #26
00227D  2  20 03 01             JSR     PEM
002280  2               
002280  2  A9 C1                LDA     #<GAMEFCB       ; Close Extent
002282  2  A0 24                LDY     #>GAMEFCB
002284  2  A2 10                LDX     #16
002286  2  20 03 01             JSR     PEM
002289  2               
002289  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
00228B  2  E6 CD                INC     DBLOCK+LO       ; POINT TO NEXT
00228D  2  D0 02                BNE     :+              ; Z-BLOCK
00228F  2  E6 CE                INC     DBLOCK+HI
002291  2               :
002291  2  18                   CLC
002292  2  60                   RTS
002293  2               GETDSKERR:
002293  2  A9 0E                LDA     #14
002295  2  4C B1 1D             JMP     ZERROR
002298  2               
002298  2               
002298  2               ; ENTRY FOR "RESTORE" ([TRACK], [SECTOR] & [DRIVE] PRE-ASSIGNED)
002298  2               
002298  2               GETRES:
002298  2               ;        CLC                     ; CARRY CLEAR = "READ BLOCK"
002298  2               ;        JSR     DISK            ; GO DO IT!
002298  2               ;        BCS     DSXERR          ; ERROR IF CARRY SET
002298  2               ;
002298  2               ;        LDY     #0              ; MOVE CONTENTS OF [IOBUFF]
002298  2               ;GDKL:
002298  2               ;        LDA     IOBUFF,Y        ; TO THE
002298  2               ;        STA     (DBUFF),Y       ; TARGET PAGE IN [DBUFF]
002298  2               ;        INY
002298  2               ;        BNE     GDKL
002298  2               ;
002298  2               ;        INC     DBLOCK+LO       ; POINT TO NEXT
002298  2               ;        BNE     GDEX            ; Z-BLOCK
002298  2               ;        INC     DBLOCK+HI
002298  2               ;
002298  2               ;GDEX:
002298  2               ;        JMP     NXTSEC          ; POINT TO NEXT SECTOR & PAGE
002298  2               
002298  2               ; --------------------
002298  2               ; PUT [DBLOCK] TO DISK
002298  2               ; --------------------
002298  2               
002298  2               ;        PAGE TO WRITE IN [DBUFF]
002298  2               
002298  2               PUTDSK:
002298  2               
002298  2  A9 00                LDA     #0              ; Set Buffer Address
00229A  2  A4 D0                LDY     DBUFF+HI
00229C  2  A2 1A                LDX     #26
00229E  2  20 03 01             JSR     PEM
0022A1  2               
0022A1  2  A9 E2                LDA     #<SAVEFCB       ; Write Record
0022A3  2  A0 24                LDY     #>SAVEFCB
0022A5  2  A2 15                LDX     #21
0022A7  2  20 03 01             JSR     PEM
0022AA  2               
0022AA  2  C9 FF                CMP     #$FF
0022AC  2  F0 03                BEQ     WRTERR
0022AE  2               
0022AE  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
0022B0  2  60                   RTS
0022B1  2               WRTERR:
0022B1  2  38                   SEC
0022B2  2  60                   RTS
0022B3  2               
0022B3  2               
0022B3  2               DSXERR:
0022B3  2  A9 0E                LDA     #14
0022B5  2               
0022B5  2               QERR:
0022B5  2  4C B1 1D             JMP     ZERROR
0022B8  2               
0022B8  2               ; -----------------------------
0022B8  2               ; SET UP SAVE & RESTORE SCREENS
0022B8  2               ; -----------------------------
0022B8  2               
0022B8  2               SAVRES:
0022B8  2  20 D0 1E             JSR     ZCRLF           ; CLEAR THE BUFFER
0022BB  2  A2 00                LDX     #0
0022BD  2  86 BF                STX     SCRIPT          ; DISABLE SCRIPTING
0022BF  2  18                   CLC
0022C0  2  60                   RTS
0022C1  2               
0022C1  2               
0022C1  2               
0022C1  2               ; FALL THROUGH ...
0022C1  2               
0022C1  2               ; --------------------------------
0022C1  2               ; ACTIVATE CURSOR, CLEAR KEY QUEUE
0022C1  2               ; --------------------------------
0022C1  2               
0022C1  2               CURSON:
0022C1  2  60                   RTS
0022C2  2               
0022C2  2               ; -----------------------------
0022C2  2               ; GET SAVE & RESTORE PARAMETERS
0022C2  2               ; -----------------------------
0022C2  2               
0022C2  2               FILENAME:
0022C2  2  0D                   .BYTE   EOL
0022C3  2  46 69 6C 65          .BYTE   "File Name:"
0022C7  2  20 4E 61 6D  
0022CB  2  65 3A        
0022CD  2               FILENAMEL       = *-FILENAME
0022CD  2               
0022CD  2               NO:
0022CD  2  4E 6F                .BYTE   "No"
0022CF  2               NOL             = *-NO
0022CF  2               
0022CF  2               YES:
0022CF  2  59 65 73             .BYTE   "Yes"
0022D2  2               YESL            = *-YES
0022D2  2               
0022D2  2               
0022D2  2               
0022D2  2               
0022D2  2               ALLSET:
0022D2  2  A2 CF                LDX     #<YES           ; PRINT "YES"
0022D4  2  A9 22                LDA     #>YES
0022D6  2  A0 03                LDY     #YESL
0022D8  2  20 3F 21             JSR     DLINE
0022DB  2               
0022DB  2               
0022DB  2               ; ---------------------
0022DB  2               ; "PRESS RETURN" PROMPT
0022DB  2               ; ---------------------
0022DB  2               
0022DB  2               RETURN:
0022DB  2  A2 F5                LDX     #<RTN
0022DD  2  A9 22                LDA     #>RTN
0022DF  2  A0 1E                LDY     #RTNL
0022E1  2  20 3F 21             JSR     DLINE           ; SHOW PROMPT
0022E4  2               
0022E4  2               ; ENTRY FOR QUIT/RESTART
0022E4  2               
0022E4  2               GETRET:
0022E4  2  20 C1 22             JSR     CURSON          ; ENABLE CURSOR
0022E7  2               
0022E7  2               GTRT:
0022E7  2  20 88 20             JSR     GETKEY          ; WAIT FOR [RETURN]
0022EA  2  C9 0D                CMP     #EOL
0022EC  2  F0 06                BEQ     RETEX
0022EE  2  20 86 21             JSR     BOOP            ; ACCEPT NO
0022F1  2  4C E7 22             JMP     GTRT            ; SUBSTITUTES!
0022F4  2               
0022F4  2               RETEX:
0022F4  2  60                   RTS
0022F5  2               
0022F5  2               RTN:
0022F5  2  0D                   .BYTE   EOL
0022F6  2  50 72 65 73          .BYTE   "Press [RETURN] to continue."
0022FA  2  73 20 5B 52  
0022FE  2  45 54 55 52  
002311  2  0D                   .BYTE   EOL
002312  2  3E                   .BYTE   ">"
002313  2               RTNL            = *-RTN
002313  2               
002313  2               
002313  2               ; -------------------------
002313  2               ; SET UP PHONEY STATUS LINE
002313  2               ; -------------------------
002313  2               
002313  2               ; ENTRY: TEXT SET UP FOR "DLINE"
002313  2               
002313  2               SROOM:
002313  2  60                   RTS
002314  2               
002314  2               ; ---------
002314  2               ; SAVE GAME
002314  2               ; ---------
002314  2               
002314  2               
002314  2               
002314  2               ZSAVE:
002314  2  20 B8 22             JSR     SAVRES          ; SET UP SCREEN
002317  2               
002317  2               ; get filename and place in FCB
002317  2               ; then open file for write/create
002317  2               
002317  2  A2 C2                LDX     #<FILENAME
002319  2  A9 22                LDA     #>FILENAME
00231B  2  A0 0B                LDY     #FILENAMEL
00231D  2  20 3F 21             JSR     DLINE           ; "FILENAME ..."
002320  2               
002320  2  A9 20                LDA     #' '
002322  2  8D E3 24             STA     SAVEFCB+1
002325  2  8D E4 24             STA     SAVEFCB+2
002328  2  8D E5 24             STA     SAVEFCB+3
00232B  2  8D E6 24             STA     SAVEFCB+4
00232E  2  8D E7 24             STA     SAVEFCB+5
002331  2  8D E8 24             STA     SAVEFCB+6
002334  2  8D E9 24             STA     SAVEFCB+7
002337  2  8D EA 24             STA     SAVEFCB+8
00233A  2               
00233A  2  A9 03                LDA     #<SPAREBYTES
00233C  2  85 62                STA     ARG1
00233E  2  A9 25                LDA     #>SPAREBYTES
002340  2  85 63                STA     ARG1+1
002342  2  20 E9 20             JSR     INPUT
002345  2  C9 0A                CMP     #10
002347  2  90 02                BCC     :+
002349  2  A9 09                LDA     #9
00234B  2               :
00234B  2  AA                   TAX
00234C  2  CA                   DEX
00234D  2               SFNLOOP:
00234D  2  BD 03 25             LDA     SPAREBYTES,X
002350  2               
002350  2  C9 30                CMP     #'0'
002352  2  B0 05                BCS     :+
002354  2  A9 5F                LDA     #'_'
002356  2  4C 7F 23             JMP     SFNOK
002359  2               :
002359  2  C9 3A                CMP     #':'
00235B  2  90 22                BCC     SFNOK
00235D  2  C9 41                CMP     #'A'
00235F  2  B0 05                BCS     :+
002361  2  A9 5F                LDA     #'_'
002363  2  4C 7F 23             JMP     SFNOK
002366  2               :
002366  2  C9 5B                CMP     #'Z'+1
002368  2  90 15                BCC     SFNOK
00236A  2  C9 61                CMP     #'a'
00236C  2  B0 05                BCS     :+
00236E  2  A9 5F                LDA     #'_'
002370  2  4C 7F 23             JMP     SFNOK
002373  2               :
002373  2  C9 7B                CMP     #'z'+1
002375  2  90 05                BCC     :+
002377  2  A9 5F                LDA     #'_'
002379  2  4C 7F 23             JMP     SFNOK
00237C  2               :
00237C  2  38                   SEC
00237D  2  E9 20                SBC     #$20
00237F  2               SFNOK:
00237F  2  9D E2 24             STA     SAVEFCB,X
002382  2  CA                   DEX
002383  2  10 C8                BPL     SFNLOOP
002385  2               
002385  2  A9 00                LDA     #0
002387  2  8D E2 24             STA     SAVEFCB+0
00238A  2  8D EE 24             STA     SAVEFCB+12
00238D  2  A9 53                LDA     #'S'
00238F  2  8D EB 24             STA     SAVEFCB+9
002392  2  A9 41                LDA     #'A'
002394  2  8D EC 24             STA     SAVEFCB+10
002397  2  A9 56                LDA     #'V'
002399  2  8D ED 24             STA     SAVEFCB+11
00239C  2               
00239C  2  A9 E2                LDA     #<SAVEFCB       ; Open Extent
00239E  2  A0 24                LDY     #>SAVEFCB
0023A0  2  A2 16                LDX     #22
0023A2  2  20 03 01             JSR     PEM
0023A5  2  C9 FF                CMP     #$FF
0023A7  2  F0 03                BEQ     BADSAV
0023A9  2               
0023A9  2  4C AF 23             JMP     DOSAVE          ; ERROR IF CARRY SET
0023AC  2               
0023AC  2               BADSAV:
0023AC  2  4C EF 10             JMP     PREDF           ; PREDICATE FAILS
0023AF  2               
0023AF  2               DOSAVE:
0023AF  2               
0023AF  2               ; SAVE GAME PARAMETERS IN [BUFSAV]
0023AF  2               
0023AF  2  AD 02 2B             LDA     ZBEGIN+ZID      ; MOVE GAME ID
0023B2  2  8D 20 0D             STA     BUFSAV+0        ; INTO 1ST 2 BYTES
0023B5  2  AD 03 2B             LDA     ZBEGIN+ZID+1    ; OF THE AUX LINE BUFFER
0023B8  2  8D 21 0D             STA     BUFSAV+1
0023BB  2               
0023BB  2  A5 74                LDA     ZSP             ; MOVE [ZSP]
0023BD  2  8D 22 0D             STA     BUFSAV+2        ; TO 3RD BYTE
0023C0  2  A5 75                LDA     OLDZSP          ; MOVE [OLDZSP]
0023C2  2  8D 23 0D             STA     BUFSAV+3        ; TO 4TH
0023C5  2               
0023C5  2  A2 02                LDX     #2              ; MOVE CONTENTS OF [ZPC]
0023C7  2               ZPCSAV:
0023C7  2  B5 76                LDA     ZPC,X           ; TO BYTES 5-7
0023C9  2  9D 24 0D             STA     BUFSAV+4,X      ; OF [BUFSAV]
0023CC  2  CA                   DEX
0023CD  2  10 F8                BPL     ZPCSAV
0023CF  2               
0023CF  2               ; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
0023CF  2               
0023CF  2  A9 0D                LDA     #>LOCALS
0023D1  2  85 D0                STA     DBUFF+HI        ; POINT TO THE PAGE
0023D3  2  20 98 22             JSR     PUTDSK          ; AND WRITE IT OUT
0023D6  2  B0 D4                BCS     BADSAV          ; CATCH WRITE ERROR HERE
0023D8  2               
0023D8  2               ; WRITE CONTENTS OF Z-STACK TO DISK
0023D8  2               
0023D8  2  A9 09                LDA     #>ZSTAKL        ; POINT TO 1ST PAGE
0023DA  2  85 D0                STA     DBUFF+HI
0023DC  2  20 98 22             JSR     PUTDSK          ; WRITE 1ST AND
0023DF  2  B0 CB                BCS     BADSAV
0023E1  2  20 98 22             JSR     PUTDSK          ; 2ND PAGE OF Z-STACK
0023E4  2  B0 C6                BCS     BADSAV
0023E6  2               
0023E6  2               ; WRITE ENTIRE GAME PRELOAD TO DISK
0023E6  2               
0023E6  2  A5 83                LDA     ZCODE           ; POINT TO 1ST PAGE
0023E8  2  85 D0                STA     DBUFF+HI        ; OF PRELOAD
0023EA  2               
0023EA  2  AE 0E 2B             LDX     ZBEGIN+ZPURBT   ; GET # IMPURE PAGES
0023ED  2  E8                   INX                     ; USE FOR INDEXING
0023EE  2  86 6E                STX     I+LO
0023F0  2               
0023F0  2               LSAVE:
0023F0  2  20 98 22             JSR     PUTDSK
0023F3  2  B0 B7                BCS     BADSAV
0023F5  2  C6 6E                DEC     I+LO
0023F7  2  D0 F7                BNE     LSAVE
0023F9  2               
0023F9  2  A9 E2                LDA     #<SAVEFCB       ; Open Extent
0023FB  2  A0 24                LDY     #>SAVEFCB
0023FD  2  A2 10                LDX     #16
0023FF  2  20 03 01             JSR     PEM
002402  2               
002402  2  4C FB 10             JMP     PREDS           ; ELSE PREDICATE SUCCEEDS
002405  2               
002405  2               ; ------------
002405  2               ; RESTORE GAME
002405  2               ; ------------
002405  2               
002405  2               RES:
002405  2  52 65 73 74          .BYTE   "Restore Position"
002409  2  6F 72 65 20  
00240D  2  50 6F 73 69  
002415  2  0D                   .BYTE   EOL
002416  2               RESL            = *-RES
002416  2               
002416  2               RSING:
002416  2  0D                   .BYTE   EOL
002417  2  52 65 73 74          .BYTE   "Restoring position "
00241B  2  6F 72 69 6E  
00241F  2  67 20 70 6F  
00242A  2               RSPOS:
00242A  2  2A 20 2E 2E          .BYTE   "* ..."
00242E  2  2E           
00242F  2  0D                   .BYTE   EOL
002430  2               RSINGL          = *-RSING
002430  2               
002430  2               ZREST:
002430  2  20 B8 22             JSR     SAVRES
002433  2               
002433  2  A2 05                LDX     #<RES
002435  2  A9 24                LDA     #>RES
002437  2  A0 11                LDY     #RESL
002439  2  20 13 23             JSR     SROOM           ; "RESTORE POSITION"
00243C  2               
00243C  2               ;        JSR     PARAMS          ; GET PARAMETERS
00243C  2               ;       BCS     BADRES          ; ERROR IF CARRY SET
00243C  2               
00243C  2  A2 16                LDX     #<RSING
00243E  2  A9 24                LDA     #>RSING
002440  2  A0 1A                LDY     #RSINGL
002442  2  20 3F 21             JSR     DLINE           ; "RESTORING POSITION X ..."
002445  2               
002445  2               ; SAVE LOCALS IN CASE OF ERROR
002445  2               
002445  2  A2 1F                LDX     #31
002447  2               LOCSAV:
002447  2  BD 00 0D             LDA     LOCALS,X        ; COPY ALL LOCALS
00244A  2  9D 00 01             STA     $0100,X         ; TO BOTTOM OF MACHINE STACK
00244D  2  CA                   DEX
00244E  2  10 F7                BPL     LOCSAV
002450  2               
002450  2  A9 0D                LDA     #>LOCALS
002452  2  85 D0                STA     DBUFF+HI
002454  2  20 98 22             JSR     GETRES          ; RETRIEVE 1ST BLOCK OF PRELOAD
002457  2               
002457  2  AD 20 0D             LDA     BUFSAV+0        ; DOES 1ST BYTE OF SAVED GAME ID
00245A  2  CD 02 2B             CMP     ZBEGIN+ZID      ; MATCH THE CURRENT ID?
00245D  2  D0 08                BNE     WRONG           ; WRONG DISK IF NOT
00245F  2               
00245F  2  AD 21 0D             LDA     BUFSAV+1        ; WHAT ABOUT THE 2ND BYTE?
002462  2  CD 03 2B             CMP     ZBEGIN+ZID+1
002465  2  F0 0E                BEQ     RIGHT           ; CONTINUE IF BOTH BYTES MATCH
002467  2               
002467  2               ; HANDLE INCORRECT SAVE DISK
002467  2               
002467  2               WRONG:
002467  2  A2 1F                LDX     #31             ; RESTORE ALL SAVED LOCALS
002469  2               WR0:
002469  2  BD 00 01             LDA     $0100,X
00246C  2  9D 00 0D             STA     LOCALS,X
00246F  2  CA                   DEX
002470  2  10 F7                BPL     WR0
002472  2               
002472  2               BADRES:
002472  2  4C EF 10             JMP     PREDF           ; PREDICATE FAILS
002475  2               
002475  2               ; CONTINUE RESTORE
002475  2               
002475  2               RIGHT:
002475  2  AD 10 2B             LDA     ZBEGIN+ZSCRIP   ; SAVE BOTH FLAG BYTES
002478  2  85 6E                STA     I+LO
00247A  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1
00247D  2  85 6F                STA     I+HI
00247F  2               
00247F  2  A9 09                LDA     #>ZSTAKL        ; RETRIEVE OLD CONTENTS OF
002481  2  85 D0                STA     DBUFF+HI        ; Z-STACK
002483  2  20 98 22             JSR     GETRES          ; GET 1ST BLOCK OF Z-STACK
002486  2  20 98 22             JSR     GETRES          ; AND 2ND BLOCK
002489  2               
002489  2  A5 83                LDA     ZCODE
00248B  2  85 D0                STA     DBUFF+HI
00248D  2  20 98 22             JSR     GETRES          ; GET 1ST BLOCK OF PRELOAD
002490  2               
002490  2  A5 6E                LDA     I+LO            ; RESTORE THE STATE
002492  2  8D 10 2B             STA     ZBEGIN+ZSCRIP   ; OF THE FLAG WORD
002495  2  A5 6F                LDA     I+HI
002497  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1
00249A  2               
00249A  2  AD 0E 2B             LDA     ZBEGIN+ZPURBT   ; GET # PAGES TO LOAD
00249D  2  85 6E                STA     I+LO
00249F  2               
00249F  2               LREST:
00249F  2  20 98 22             JSR     GETRES          ; FETCH THE REMAINDER
0024A2  2  C6 6E                DEC     I+LO            ; OF THE PRELOAD
0024A4  2  D0 F9                BNE     LREST
0024A6  2               
0024A6  2               ; RESTORE THE STATE OF THE SAVED GAME
0024A6  2               
0024A6  2  AD 22 0D             LDA     BUFSAV+2        ; RESTORE THE [ZSP]
0024A9  2  85 74                STA     ZSP
0024AB  2  AD 23 0D             LDA     BUFSAV+3        ; AND THE [OLDZSP]
0024AE  2  85 75                STA     OLDZSP
0024B0  2               
0024B0  2  A2 02                LDX     #2              ; RESTORE THE [ZPC]
0024B2  2               RESZPC:
0024B2  2  BD 24 0D             LDA     BUFSAV+4,X
0024B5  2  95 76                STA     ZPC,X
0024B7  2  CA                   DEX
0024B8  2  10 F8                BPL     RESZPC
0024BA  2               
0024BA  2  A9 00                LDA     #FALSE
0024BC  2  85 79                STA     ZPCFLG          ; INVALIDATE [ZPC]
0024BE  2               
0024BE  2  4C FB 10             JMP     PREDS           ; PREDICATE SUCCEEDS
0024C1  2               
0024C1  2               GAMEFCB:
0024C1  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024C5  2  00 00 00 00  
0024C9  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024CD  2  00 00 00 00  
0024D1  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024D5  2  00 00 00 00  
0024D9  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024DD  2  00 00 00 00  
0024E1  2  00                   .BYTE   00
0024E2  2               
0024E2  2               SAVEFCB:
0024E2  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024E6  2  00 00 00 00  
0024EA  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024EE  2  00 00 00 00  
0024F2  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024F6  2  00 00 00 00  
0024FA  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
0024FE  2  00 00 00 00  
002502  2  00                   .BYTE   00
002503  2               
002503  2               SPAREBYTES:
002503  2               D65BLOCK:
002503  2  xx xx xx xx          .RES    256
002507  2  xx xx xx xx  
00250B  2  xx xx xx xx  
002603  2               
002603  1                       .INCLUDE "disk.asm"
002603  2               ;        PAGE
002603  2               ;        SBTTL   "--- DISK ACCESS: DOS/65 ---"
002603  2               
002603  2               ; --------------
002603  2               ; OPEN DRIVE [A]
002603  2               ; WILL OPEN FILE SPECIFIED IN COMMAND LINE
002603  2               ; --------------
002603  2               DOPEN:
002603  2  A2 0C                LDX     #12
002605  2               :
002605  2  CA                   DEX
002606  2  BD 07 01             LDA     DFLFCB,X
002609  2  9D C1 24             STA     GAMEFCB,X
00260C  2  E0 00                CPX     #00
00260E  2  D0 F5                BNE     :-
002610  2  18                   CLC
002611  2  60                   RTS
002612  2               DOPEN_ERR:
002612  2  38                   SEC
002613  2  60                   RTS
002614  2               
002614  2               
002614  2               ; -------------------
002614  2               ; CLOSE CURRENT DRIVE
002614  2               ; -------------------
002614  2               
002614  2               DCLOSE:
002614  2  60                   RTS
002615  2               
002615  2               ;        LDA     #<DFLFCB
002615  2               ;        LDY     #>DFLFCB
002615  2               ;        LDX     #16
002615  2               ;        JSR     PEM
002615  2               
002615  2               ; FALL THROUGH ...
002615  2               
002615  2               
002615  2               ; ----------------
002615  2               ; DIVIDE [A] BY 10
002615  2               ; ----------------
002615  2               
002615  2               ; EXIT: QUOTIENT IN [X], REMAINDER IN [A]
002615  2               
002615  2               DIV10:
002615  2  A2 00                LDX     #0              ; START WITH ZERO QUOTIENT
002617  2               
002617  2               D10L:
002617  2  C9 0A                CMP     #10             ; IF DIVISOR < 10,
002619  2  90 05                BCC     D10EX           ; WE'RE DONE
00261B  2  E9 0A                SBC     #10             ; ELSE SUBTRACT ANOTHER 10
00261D  2  E8                   INX                     ; UPDATE QUOTIENT
00261E  2  D0 F7                BNE     D10L            ; BRANCH ALWAYS
002620  2               
002620  2               D10EX:
002620  2  60                   RTS
002621  2               
002621  1               
002621  1                       .IFDEF  DEBUG
002621  1                       .INCLUDE "bugger.asm"
002621  1                       .ENDIF
002621  1               
002621  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC."
002621  1                       .END
