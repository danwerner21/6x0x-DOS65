ca65 V2.18 - Ubuntu 2.19-1
Main file   : zip.asm
Current file: zip.asm

000000r 1               ; TITLE   "ZIP/6502-C INFOCOM, INC. --- EQUATES"
000000r 1               ; --------------------------
000000r 1               ; ZIP/6502 2.0 VERSION F
000000r 1               ; Z-CODE INTERPRETER PROGRAM
000000r 1               ; FOR DUODYNE DOS/65 65816
000000r 1               ; --------------------------
000000r 1               ; INFOCOM, INC.
000000r 1               ; 55 WHEELER STREET
000000r 1               ; CAMBRIDGE, MA 02136
000000r 1               ; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
000000r 1               
000000r 1               MSTART          = $0800         ; START OF FREE PROGRAM RAM
000000r 1               ZEROPG          = $60           ; START OF FREE Z-PAGE RAM
000000r 1               ZPGTOP          = $DF           ; END OF FREE Z-PAGE RAM
000000r 1               
000000r 1               ;DEBUG           = 0             ; ASSEMBLY FLAG FOR DEBUGGER
000000r 1               
000000r 1               ; -----------
000000r 1               ; ERROR CODES
000000r 1               ; -----------
000000r 1               ; 00 -- INSUFFICIENT RAM
000000r 1               ; 01 -- ILLEGAL X-OP
000000r 1               ; 02 -- ILLEGAL 0-OP
000000r 1               ; 03 -- ILLEGAL 1-OP
000000r 1               ; 04 -- ILLEGAL 2-OP
000000r 1               ; 05 -- Z-STACK UNDERFLOW
000000r 1               ; 06 -- Z-STACK OVERFLOW
000000r 1               ; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
000000r 1               ; 08 -- DIVISION BY ZERO
000000r 1               ; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
000000r 1               ; 10 -- ILLEGAL PROPERTY ID (PUTP)
000000r 1               ; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
000000r 1               ; 12 -- DISK ADDRESS OUT OF RANGE
000000r 1               ; 13 -- PARSER OVERFLOW
000000r 1               ; 14 -- DRIVE ACCESS
000000r 1               ; 15 -- Z-STACK DESTROYED
000000r 1               
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 00 0E             JMP     COLD
000803  1                       .INCLUDE "eq.asm"
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- MEMORY ORGANIZATION ---"
000803  2               
000803  2               TRUE	=	$FF
000803  2               FALSE	=	0
000803  2               LO	=	0
000803  2               HI	=	1
000803  2               
000803  2               IOBUFF	=	MSTART		; 256-BYTE DISK BUFFER
000803  2               ZSTAKL	=	MSTART+$100	; Z-STACK LSBS
000803  2               ZSTAKH	=	MSTART+$200	; Z-STACK MSBS
000803  2               PTABL	=	MSTART+$300	; PAGING TABLE LSBS ($A0 BYTES)
000803  2               PTABH	=	MSTART+$3A0	; PAGING TABLE MSBS ($A0 BYTES)
000803  2               LRUMAP	=	MSTART+$450	; TIMESTAMP MAP ($A0 BYTES) (BM 11/24/84)
000803  2               LOCALS  =     MSTART+$500     ; LOCAL VARIABLE STORAGE (32 BYTES)
000803  2               BUFSAV  =     MSTART+$520     ; I/O AUX BUFFER (80 BYTES)
000803  2               
000803  2               ZIP	=	MSTART+$600	; START OF EXECUTABLE CODE
000803  2               ZBEGIN	=	ZIP+$1D00	; START OF Z-CODE
000803  2               
000803  2               	; ---------------------
000803  2               	; Z-CODE HEADER OFFSETS
000803  2               	; ---------------------
000803  2               
000803  2               ZVERS	=	0		; VERSION BYTE
000803  2               ZMODE	=	1		; MODE SELECT BYTE
000803  2               ZID	=	2		; GAME ID WORD
000803  2               ZENDLD	=	4		; START OF NON-PRELOADED Z-CODE
000803  2               ZGO	=	6		; EXECUTION ADDRESS
000803  2               ZVOCAB	=	8		; START OF VOCABULARY TABLE
000803  2               ZOBJEC	=	10		; START OF OBJECT TABLE
000803  2               ZGLOBA	=	12		; START OF GLOBAL VARIABLE TABLE
000803  2               ZPURBT	=	14		; START OF "PURE" Z-CODE
000803  2               ZSCRIP	=	16		; FLAG WORD
000803  2               ZSERIA	=	18		; 3-WORD ASCII SERIAL NUMBER
000803  2               ZFWORD	=	24		; START OF FWORDS TABLE
000803  2               ZLENTH	=	26		; LENGTH OF Z-PROGRAM IN WORDS
000803  2               ZCHKSM	=	28		; Z-CODE CHECKSUM WORD
000803  2               
000803  2               ;	PAGE
000803  2               ;	SBTTL "--- ZIP Z-PAGE VARIABLES ---"
000803  2               
000803  2               OPCODE	=	ZEROPG		; (BYTE) CURRENT OPCODE
000803  2               NARGS	=	OPCODE+1	; (BYTE) # ARGUMENTS
000803  2               ARG1	=	OPCODE+2	; (WORD) ARGUMENT #1
000803  2               ARG2	=	OPCODE+4	; (WORD) ARGUMENT #2
000803  2               ARG3	=	OPCODE+6	; (WORD) ARGUMENT #3
000803  2               ARG4	=	OPCODE+8	; (WORD) ARGUMENT #4
000803  2               ABYTE	=	OPCODE+10	; (BYTE) X-OP ARGUMENT BYTE
000803  2               ADEX	=	OPCODE+11	; (BYTE) X-OP ARGUMENT INDEX
000803  2               
000803  2               VALUE	=	OPCODE+12	; (WORD) VALUE RETURN REGISTER
000803  2               I	=	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
000803  2               J	=	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
000803  2               K	=	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
000803  2               
000803  2               ZSP	=	VALUE+8		; (BYTE) Z-STACK POINTER
000803  2               OLDZSP	=	ZSP+1		; (BYTE) OLD Z-STACK POINTER
000803  2               
000803  2               ZPC	=	ZSP+2		; (3 BYTES) ZIP PROGRAM COUNTER
000803  2               ZPCL	=	ZPC		; (BYTE) LOW 8 BITS OF [ZPC]
000803  2               ZPCM	=	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
000803  2               ZPCH	=	ZPC+2		; (BYTE) HIGH BIT OF [ZPC]
000803  2               ZPCFLG	=	ZPC+3		; (BYTE) FLAG: "TRUE" IF [ZPCPNT] VALID
000803  2               ZPCPNT	=	ZPC+4		; (WORD) ABS POINTER TO CURRENT Z-PAGE
000803  2               
000803  2               MPC	=	ZPC+6		; (3 BYTES) MEMORY PROGRAM COUNTER
000803  2               MPCL	=	MPC		; (BYTE) LOW 8 BITS OF [MPC]
000803  2               MPCM	=	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
000803  2               MPCH	=	MPC+2		; (BYTE) HIGH BIT OF [MPC]
000803  2               MPCFLG	=	MPC+3		; (BYTE) FLAG: "TRUE" IF [MPCPNT] VALID
000803  2               MPCPNT	=	MPC+4		; (WORD) ABS POINTER TO CURRENT M-PAGE
000803  2               
000803  2               LRU	=	MPC+6		; (BYTE) PAGING INDEX
000803  2               ZCODE	=	LRU+1		; (BYTE) 1ST ABSOLUTE PAGE OF PRELOAD
000803  2               ZPURE	=	LRU+2		; (BYTE) 1ST VIRTUAL PAGE OF "PURE" Z-CODE
000803  2               PAGE0	=	LRU+3		; (BYTE) 1ST PAGE OF ACTUAL SWAPPING SPACE
000803  2               PMAX	=	LRU+4		; (BYTE) MAXIMUM # OF SWAPPING PAGES
000803  2               ZPAGE	=	LRU+5		; (BYTE) CURRENT SWAPPING PAGE
000803  2               TARGET	=	LRU+6		; (WORD) TARGET PAGE FOR SWAPPING
000803  2               STAMP	=	LRU+8		; (BYTE) CURRENT TIMESTAMP (BM 11/24/84)
000803  2               SWAP	=	LRU+9		; (BYTE) EARLIEST PAGE (BM 11/24/84)
000803  2               
000803  2               GLOBAL	=	LRU+10		; (WORD) GLOBAL VARIABLE POINTER
000803  2               VOCAB	=	GLOBAL+2	; (WORD) VOCAB TABLE POINTER
000803  2               FWORDS	=	GLOBAL+4	; (WORD) F-WORDS TABLE POINTER
000803  2               OBJTAB	=	GLOBAL+6	; (WORD) OBJECT TABLE POINTER
000803  2               
000803  2               	; Z-STRING MANIPULATION VARIABLES
000803  2               
000803  2               IN	=	GLOBAL+8	; (6 BYTES) INPUT BUFFER
000803  2               OUT	=	IN+6		; (6 BYTES) OUTPUT BUFFER
000803  2               
000803  2               SOURCE	=	OUT+6		; (BYTE) SOURCE BUFFER POINTER
000803  2               RESULT	=	SOURCE+1	; (BYTE) RESULT TABLE POINTER
000803  2               LINLEN	=	SOURCE+2	; (BYTE) LENGTH OF CURRENT LINE
000803  2               WRDLEN	=	SOURCE+3	; (BYTE) LENGTH OF CURRENT WORD
000803  2               ENTRY	=	SOURCE+4	; (WORD) ADDR OF CURRENT RESULT ENTRY
000803  2               NENTS	=	SOURCE+6	; (WORD) # ENTRIES IN VOCAB TABLE
000803  2               ESIZE	=	SOURCE+8	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
000803  2               PSET	=	SOURCE+9	; (BYTE) PERMANENT CHARSET
000803  2               TSET	=	SOURCE+10	; (BYTE) TEMPORARY CHARSET
000803  2               ZCHAR	=	SOURCE+11	; (BYTE) CURRENT Z-CHAR
000803  2               OFFSET	=	SOURCE+12	; (BYTE) F-WORD TABLE OFFSET
000803  2               ZFLAG	=	SOURCE+13	; (BYTE) Z-WORD ACCESS FLAG
000803  2               ZWORD	=	SOURCE+14	; (WORD) CURRENT Z-WORD
000803  2               CONCNT	=	SOURCE+16	; (BYTE) Z-STRING SOURCE COUNTER
000803  2               CONIN	=	SOURCE+17	; (BYTE) CONVERSION SOURCE INDEX
000803  2               CONOUT	=	SOURCE+18	; (BYTE) CONVERSION DEST INDEX
000803  2               
000803  2               QUOT	=	SOURCE+19	; (WORD) QUOTIENT FOR DIVISION
000803  2               REMAIN	=	QUOT+2		; (WORD) REMAINDER FOR DIVISION
000803  2               MTEMP	=	QUOT+4		; (WORD) MATH TEMPORARY REGISTER
000803  2               QSIGN	=	QUOT+6		; (BYTE) SIGN OF QUOTIENT
000803  2               RSIGN	=	QUOT+7		; (BYTE) SIGN OF REMAINDER
000803  2               DIGITS	=	QUOT+8		; (BYTE) DIGIT COUNT FOR "PRINTN"
000803  2               
000803  2               TIMEFL	=	QUOT+9		; (BYTE) "TRUE" IF TIME MODE
000803  2               LENGTH	=	TIMEFL+1	; (BYTE) LENGTH OF LINE IN [LINBUF]
000803  2               OLDLEN	=	TIMEFL+2	; (BYTE) OLD LINE LENGTH
000803  2               SCRIPT	=	TIMEFL+3	; (BYTE) SCRIPT ENABLE FLAG
000803  2               OLDX	=	TIMEFL+4	; (BYTE) OLD CURSOR X
000803  2               OLDY	=	TIMEFL+5	; (BYTE) OLD CURSOR Y
000803  2               LINCNT	=	TIMEFL+6	; (BYTE) LINE COUNTER
000803  2               LMAX	=	TIMEFL+7	; (BYTE) MAX # LINES/SCREEN
000803  2               
000803  2               IOCHAR	=	TIMEFL+8	; (BYTE) CHARACTER BUFFER
000803  2               SLINE	=	IOCHAR+1	; (BYTE) BORDERLINE FOR SPLIT
000803  2               SPSTAT	=	IOCHAR+2	; (BYTE) SPLIT SCREEN STATUS FLAG
000803  2               LFROM	=	IOCHAR+3	; (WORD) "FROM" LINE ADDRESS
000803  2               LTO	=	IOCHAR+5	; (WORD) "TO" LINE ADDRESS
000803  2               PSTAT	=	IOCHAR+7	; (BYTE) PRINTER STATUS FLAG
000803  2               PRLEN	=	IOCHAR+8	; (BYTE) SCRIPT LINE LENGTH
000803  2               
000803  2               DBLOCK	=	IOCHAR+9	; (WORD) Z-BLOCK TO READ
000803  2               DBUFF	=	DBLOCK+2	; (WORD) RAM PAGE TO ACCESS (LSB = 0)
000803  2               ;TRACK	=	DBLOCK+4	; (BYTE) TARGET TRACK
000803  2               ;SECTOR	=	DBLOCK+5	; (BYTE) TARGET SECTOR
000803  2               GPOSIT	=	DBLOCK+6	; (BYTE) DEFAULT SAVE POSITION
000803  2               GDRIVE	=	DBLOCK+7	; (BYTE) DEFAULT SAVE DRIVE
000803  2               TPOSIT	=	DBLOCK+8	; (BYTE) TEMP SAVE POSITION
000803  2               TDRIVE	=	DBLOCK+9	; (BYTE) TEMP SAVE DRIVE
000803  2               
000803  2               BLINK	=	DBLOCK+11	; (WORD) CURSOR BLINK TIMER
000803  2               
000803  2               ;DVD	=	DBLOCK+13	; (WORD) DISK DIVIDEND
000803  2               ;DSOR	=	DBLOCK+15	; (WORD) DISK DIVISOR
000803  2               DTEMP	=	DBLOCK+17	; (WORD) DISK TEMP VARIABLE
000803  2               
000803  1                       .SEGMENT "ZIP"
000803  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT INIT"
000803  1                       .INCLUDE "hardeq.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- HARDWARE EQUATES: DOS/65 ---"
000803  2               
000803  2               ; ---------
000803  2               ; CONSTANTS
000803  2               ; ---------
000803  2               
000803  2               XSIZE           = 79            ; X-SIZE OF SCREEN
000803  2               YSIZE           = 24            ; Y-SIZE OF SCREEN
000803  2               
000803  2               EOL             = $0D           ; EOL CHAR
000803  2               SPACE           = $20           ; SPACE CHAR
000803  2               BACKSP          = $08           ; BACKSPACE
000803  2               
000803  2               DFLFCB          = $107          ;DEFAULT FCB
000803  2               PEM             = $103          ;PEM ENTRY
000803  2               BOOT            = $100          ;WARM BOOT
000803  2               CCMLNG          = 2048          ;CCM LENGTH
000803  2               
000803  2               ; ---------
000803  2               ; ZERO-PAGE
000803  2               ; ---------
000803  2               
000803  2               
000803  2               ; -----------
000803  2               ; PAGES 2 & 3
000803  2               ; -----------
000803  2               
000803  2               LBUFF           = $0740         ; 89-BYTE LINE BUFFER
000803  2               
000803  1                       .INCLUDE "cold.asm"
000803  2               ;        PAGE
000803  2               ;        SBTTL   "--- MACHINE COLDSTART: DOS/65 ---"
000803  2               
000803  2               
000803  2               ; ---------
000803  2               ; COLDSTART
000803  2               ; ---------
000803  2                       .ORG    ZIP
000E00  2               
000E00  2               
000E00  2               COLD:
000E00  2  A9 00                LDA     #0
000E02  2  8D 8E 21             STA     SFLAG           ; NO PREVIOUS SCRIPTING (BM 5/14/85)
000E05  2  4C 5B 0E             JMP     WARM1
000E08  2               
000E08  2               ; ---------------
000E08  2               ; WARMSTART ENTRY
000E08  2               ; ---------------
000E08  2               
000E08  2               SLOAD:
000E08  2  49 6E 66 6F          .BYTE   "Infocom ZMachine Interpreter for DOS/65"
000E0C  2  63 6F 6D 20  
000E10  2  5A 4D 61 63  
000E2F  2  0D                   .BYTE   EOL
000E30  2  0D                   .BYTE   EOL
000E31  2  20 20 20 20          .BYTE   "                 The story is loading ..."
000E35  2  20 20 20 20  
000E39  2  20 20 20 20  
000E5A  2  0D                   .BYTE   EOL
000E5B  2               SLOADL          = *-SLOAD
000E5B  2               
000E5B  2               WARM1:
000E5B  2  D8                   CLD
000E5C  2                       .IFDEF  DUODYNE
000E5C  2                       .ELSE
000E5C  2                       LDX     #$FF            ; (Dont do this for Duodyne . . . . .)
000E5C  2                       TXS                     ; RESET MACHINE STACK
000E5C  2                       .ENDIF
000E5C  2               
000E5C  2               
000E5C  2               
000E5C  2  20 10 22             JSR     CLS             ; CLEAR SCREEN, ETC.
000E5F  2               
000E5F  2  A0 08                LDY     #8              ; POSITION "STORY LOADING" MESSAGE
000E61  2  A2 0B                LDX     #11             ; AT (8,11)
000E63  2  18                   CLC
000E64  2  20 CA 21             JSR     PLOT
000E67  2               
000E67  2  A2 08                LDX     #<SLOAD
000E69  2  A9 0E                LDA     #>SLOAD
000E6B  2  A0 53                LDY     #SLOADL
000E6D  2  20 79 21             JSR     DLINE           ; "THE STORY IS LOADING ..."
000E70  2  20 6E 26             JSR     DOPEN           ; AND OPEN THE STORY
000E73  2               
000E73  2               
000E73  2               ; FALL THROUGH TO ZIP WARMSTART AT "WARM2"
000E73  2               
000E73  1               
000E73  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- INIT & MAINLINE"
000E73  1                       .INCLUDE "warm.asm"
000E73  2               ;        PAGE
000E73  2               ;        SBTTL   "--- WARMSTART ROUTINE ---"
000E73  2               
000E73  2               ; -------------
000E73  2               ; ZIP WARMSTART
000E73  2               ; -------------
000E73  2               
000E73  2               WARM2:
000E73  2               
000E73  2               ; PROBABLY NOT THE BEST WAY TO DO THIS
000E73  2               ; I NEED TO USE THE CLOCK TO SEED THE RNG
000E73  2  A5 44                LDA     $44
000E75  2  8D C2 1E             STA     state+0
000E78  2  A5 46                LDA     $46
000E7A  2  8D C7 1E             STA     state1+0
000E7D  2  A5 3B                LDA     $3B
000E7F  2  8D C3 1E             STA     state+1
000E82  2  A5 3D                LDA     $3D
000E84  2  8D C8 1E             STA     state1+1
000E87  2  AD 35 06             LDA     $0635
000E8A  2  8D C4 1E             STA     state+2
000E8D  2  8D C9 1E             STA     state1+2
000E90  2  08                   PHP
000E91  2  68                   PLA
000E92  2  8D C5 1E             STA     state+3
000E95  2  BA                   TSX
000E96  2  8E CA 1E             STX     state1+3
000E99  2  AD 00 04             LDA     $0400
000E9C  2  8D C6 1E             STA     state+4
000E9F  2  AD 01 04             LDA     $0401
000EA2  2  8D CB 1E             STA     state1+4
000EA5  2               
000EA5  2               
000EA5  2  A9 00                LDA     #0              ; CLEAR ALL Z-PAGE VARIABLES
000EA7  2  A2 60                LDX     #ZEROPG
000EA9  2               ST0:
000EA9  2  95 00                STA     0,X
000EAB  2  E8                   INX
000EAC  2  E0 DF                CPX     #ZPGTOP
000EAE  2  90 F9                BCC     ST0
000EB0  2               
000EB0  2               ; INIT THE PAGING TABLES
000EB0  2               
000EB0  2  AA                   TAX                     ; = 0
000EB1  2  A9 FF                LDA     #$FF
000EB3  2               ST1A:
000EB3  2  9D 00 0B             STA     PTABL,X
000EB6  2  9D A0 0B             STA     PTABH,X
000EB9  2  E8                   INX
000EBA  2  E0 A0                CPX     #$A0
000EBC  2  90 F5                BCC     ST1A
000EBE  2               
000EBE  2               ; INIT THE TIMESTAMP MAP (BM 11/24/84)\
000EBE  2               
000EBE  2  A9 00                LDA     #0
000EC0  2  AA                   TAX
000EC1  2               ST1B:
000EC1  2  9D 50 0C             STA     LRUMAP,X
000EC4  2  E8                   INX
000EC5  2  E0 A0                CPX     #$A0
000EC7  2  90 F8                BCC     ST1B
000EC9  2               
000EC9  2  E6 74                INC     ZSP             ; INIT Z-STACK POINTERS
000ECB  2  E6 75                INC     OLDZSP          ; TO "1"
000ECD  2  E6 8A                INC     STAMP           ; INIT TIMESTAMP (BM 11/24/84)
000ECF  2               
000ECF  2               ; GRAB THE FIRST BLOCK OF PRELOAD
000ECF  2               
000ECF  2  A9 2B                LDA     #>ZBEGIN        ; MSB OF PRELOAD START ADDRESS
000ED1  2  85 83                STA     ZCODE           ; FREEZE IT HERE
000ED3  2  85 D0                STA     DBUFF+HI        ; LSB IS ALWAYS ZERO
000ED5  2  20 57 22             JSR     GETDSK          ; [DBLOCK] SET TO Z-BLOCK 0
000ED8  2               
000ED8  2               ; EXTRACT GAME DATA FROM Z-CODE HEADER
000ED8  2               
000ED8  2  AE 04 2B             LDX     ZBEGIN+ZENDLD   ; MSB OF ENDLOAD POINTER
000EDB  2  E8                   INX                     ; ADD 1 TO GET
000EDC  2  86 84                STX     ZPURE           ; 1ST "PURE" PAGE OF Z-CODE
000EDE  2               
000EDE  2  8A                   TXA                     ; ADD START PAGE OF PRELOAD
000EDF  2  18                   CLC                     ; TO CALC ABSOLUTE START ADDRESS
000EE0  2  65 83                ADC     ZCODE           ; OF PAGING SPACE
000EE2  2  85 85                STA     PAGE0
000EE4  2               
000EE4  2  20 55 1E             JSR     MEMTOP          ; RETURNS TOP RAM PAGE IN [A]
000EE7  2  38                   SEC
000EE8  2  E5 85                SBC     PAGE0           ; SUBTRACT ADDRESS OF PAGING SPACE
000EEA  2  F0 02                BEQ     NORAM
000EEC  2  B0 05                BCS     SETNP           ; ERROR IF NOT ENOUGH RAM
000EEE  2               
000EEE  2               ; *** ERROR #0 -- INSUFFICIENT RAM ***
000EEE  2               
000EEE  2               NORAM:
000EEE  2  A9 00                LDA     #0
000EF0  2  4C EB 1D             JMP     ZERROR
000EF3  2               
000EF3  2               SETNP:
000EF3  2  C9 A0                CMP     #$A0            ; DON'T ALLOW MORE THAN $A0 PAGES
000EF5  2  90 02                BCC     SETA0
000EF7  2  A9 A0                LDA     #$A0
000EF9  2               SETA0:
000EF9  2  85 86                STA     PMAX            ; SET # SWAPPING PAGES
000EFB  2               
000EFB  2  AD 01 2B             LDA     ZBEGIN+ZMODE
000EFE  2  09 20                ORA     #%00100000      ; ENABLE SPLIT-SCREEN
000F00  2  8D 01 2B             STA     ZBEGIN+ZMODE
000F03  2               
000F03  2  29 02                AND     #%00000010      ; ISOLATE STATUS-FORMAT BIT
000F05  2  85 BC                STA     TIMEFL          ; 0=SCORE, NZ=TIME
000F07  2               
000F07  2  AD 0C 2B             LDA     ZBEGIN+ZGLOBA   ; GET MSB OF GLOBAL TABLE ADDR
000F0A  2  18                   CLC                     ; CONVERT TO
000F0B  2  65 83                ADC     ZCODE           ; ABSOLUTE ADDRESS
000F0D  2  85 8D                STA     GLOBAL+HI
000F0F  2  AD 0D 2B             LDA     ZBEGIN+ZGLOBA+1 ; LSB NEEDN'T CHANGE
000F12  2  85 8C                STA     GLOBAL+LO
000F14  2               
000F14  2  AD 18 2B             LDA     ZBEGIN+ZFWORD   ; DO SAME FOR FWORDS TABLE
000F17  2  18                   CLC
000F18  2  65 83                ADC     ZCODE
000F1A  2  85 91                STA     FWORDS+HI
000F1C  2  AD 19 2B             LDA     ZBEGIN+ZFWORD+1 ; NO CHANGE FOR LSB
000F1F  2  85 90                STA     FWORDS+LO
000F21  2               
000F21  2  AD 08 2B             LDA     ZBEGIN+ZVOCAB   ; NOW DO VOCABULARY TABLE
000F24  2  18                   CLC
000F25  2  65 83                ADC     ZCODE
000F27  2  85 8F                STA     VOCAB+HI
000F29  2  AD 09 2B             LDA     ZBEGIN+ZVOCAB+1 ; LSB SAME
000F2C  2  85 8E                STA     VOCAB+LO
000F2E  2               
000F2E  2  AD 0A 2B             LDA     ZBEGIN+ZOBJEC   ; NOT TO MENTION
000F31  2  18                   CLC                     ; THE OBJECT TABLE
000F32  2  65 83                ADC     ZCODE
000F34  2  85 93                STA     OBJTAB+HI
000F36  2  AD 0B 2B             LDA     ZBEGIN+ZOBJEC+1 ; LSB SAME
000F39  2  85 92                STA     OBJTAB+LO
000F3B  2               
000F3B  2               ; FETCH THE REST OF THE PRELOAD
000F3B  2               
000F3B  2               LDPRE:
000F3B  2  A5 CD                LDA     DBLOCK+LO       ; CHECK CURRENT BLOCK #
000F3D  2  C5 84                CMP     ZPURE           ; LOADED LAST PRELOAD PAGE YET?
000F3F  2  B0 06                BCS     WARMEX          ; YES, TIME TO PLAY!
000F41  2  20 57 22             JSR     GETDSK          ; ELSE GRAB NEXT Z-BLOCK
000F44  2  4C 3B 0F             JMP     LDPRE
000F47  2               
000F47  2               WARMEX:
000F47  2  AD 06 2B             LDA     ZBEGIN+ZGO      ; GET START ADDRESS OF Z-CODE
000F4A  2  85 77                STA     ZPCM            ; MSB
000F4C  2  AD 07 2B             LDA     ZBEGIN+ZGO+1    ; AND LSB
000F4F  2  85 76                STA     ZPCL            ; HIGH BIT ALREADY ZEROED
000F51  2               
000F51  2  E6 BF                INC     SCRIPT          ; ENABLE SCRIPTING
000F53  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; STUFF IN THE
000F56  2  0D 8E 21             ORA     SFLAG           ; PREVIOUS SCRIPT MODE
000F59  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1 ; (BM 5/14/85)
000F5C  2               
000F5C  2  20 10 22             JSR     CLS             ; CLEAR SCREEN, DISABLE SPLIT
000F5F  2               
000F5F  2               ; ... AND FALL INTO MAIN LOOP
000F5F  2               
000F5F  1                       .INCLUDE "main.asm"
000F5F  2               ;        PAGE
000F5F  2               ;        SBTTL   "--- MAIN LOOP ---"
000F5F  2               
000F5F  2               MLOOP:
000F5F  2  A9 00                LDA     #0
000F61  2  85 61                STA     NARGS           ; RESET # ARGUMENTS
000F63  2  20 E3 19             JSR     NEXTPC          ; GET NEXT INSTRUCTION INTO [A]
000F66  2  85 60                STA     OPCODE          ; SAVE IT HERE
000F68  2               
000F68  2                       .IFDEF  DEBUG
000F68  2                       STA     MBYTE
000F68  2                       LDA     #0              ; BREAKPOINT #0
000F68  2                       JSR     DOBUG
000F68  2                       LDA     MBYTE
000F68  2                       .ENDIF
000F68  2               
000F68  2               ; DECODE AN OPCODE
000F68  2               
000F68  2  AA                   TAX                     ; SET FLAGS
000F69  2  30 03                BMI     DC0             ; IF POSITIVE,
000F6B  2  4C 29 10             JMP     OP2             ; IT'S A 2-OP
000F6E  2               
000F6E  2               DC0:
000F6E  2  C9 B0                CMP     #$B0
000F70  2  B0 03                BCS     DC1
000F72  2  4C FA 0F             JMP     OP1             ; OR MAYBE A 1-OP
000F75  2               
000F75  2               DC1:
000F75  2  C9 C0                CMP     #$C0
000F77  2  B0 03                BCS     OPEXT
000F79  2  4C EB 0F             JMP     OP0             ; PERHAPS A 0-OP
000F7C  2               
000F7C  2               ; --------------
000F7C  2               ; HANDLE AN X-OP
000F7C  2               ; --------------
000F7C  2               
000F7C  2               OPEXT:
000F7C  2  20 E3 19             JSR     NEXTPC          ; GRAB THE ARGUMENT ID BYTE
000F7F  2  85 6A                STA     ABYTE           ; HOLD IT HERE
000F81  2               
000F81  2  A2 00                LDX     #0
000F83  2  86 6B                STX     ADEX            ; INIT ARGUMENT INDEX
000F85  2  F0 06                BEQ     OPX1            ; JUMP TO TOP OF LOOP
000F87  2               
000F87  2               OPX0:
000F87  2  A5 6A                LDA     ABYTE           ; GET ARG BYTE
000F89  2  0A                   ASL     A               ; SHIFT NEXT 2 ARG BITS
000F8A  2  0A                   ASL     A               ; INTO BITS 7 & 6
000F8B  2  85 6A                STA     ABYTE           ; HOLD FOR LATER
000F8D  2               
000F8D  2               OPX1:
000F8D  2  29 C0                AND     #%11000000      ; MASK OUT GARBAGE BITS
000F8F  2  D0 06                BNE     OPX2
000F91  2  20 75 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
000F94  2  4C A8 0F             JMP     OPXNXT
000F97  2               
000F97  2               OPX2:
000F97  2  C9 40                CMP     #%01000000      ; IS IT A SHORT IMMEDIATE?
000F99  2  D0 06                BNE     OPX3            ; NO, KEEP GUESSING
000F9B  2  20 71 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
000F9E  2  4C A8 0F             JMP     OPXNXT
000FA1  2               
000FA1  2               OPX3:
000FA1  2  C9 80                CMP     #%10000000      ; LAST TEST
000FA3  2  D0 17                BNE     OPX4            ; 11 = NO MORE ARGUMENTS
000FA5  2  20 89 10             JSR     GETVAR          ; 10 = VARIABLE
000FA8  2               
000FA8  2               OPXNXT:
000FA8  2  A6 6B                LDX     ADEX            ; RETRIEVE ARGUMENT INDEX
000FAA  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB OF VALUE
000FAC  2  95 62                STA     ARG1+LO,X       ; STORE IN ARGUMENT TABLE
000FAE  2  A5 6D                LDA     VALUE+HI        ; GRAB MSB OF VALUE
000FB0  2  95 63                STA     ARG1+HI,X       ; STORE THAT, TOO
000FB2  2               
000FB2  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNTER
000FB4  2               
000FB4  2  E8                   INX
000FB5  2  E8                   INX
000FB6  2  86 6B                STX     ADEX            ; UPDATE INDEX
000FB8  2  E0 08                CPX     #8              ; DONE 4 ARGUMENTS YET?
000FBA  2  90 CB                BCC     OPX0            ; NO, GET SOME MORE
000FBC  2               
000FBC  2               ; ALL X-OP ARGUMENTS READY
000FBC  2               
000FBC  2               OPX4:
000FBC  2  A5 60                LDA     OPCODE          ; IS THIS
000FBE  2  C9 E0                CMP     #$E0            ; AN EXTENDED 2-OP?
000FC0  2  B0 03                BCS     DOXOP           ; NO, IT'S A REAL X-OP
000FC2  2  4C 52 10             JMP     OP2EX           ; ELSE TREAT IT LIKE A 2-OP
000FC5  2               
000FC5  2               DOXOP:
000FC5  2  A2 33                LDX     #<OPTX          ; GET ADDR OF X-OP TABLE
000FC7  2  A0 12                LDY     #>OPTX          ; INTO [X/Y]
000FC9  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
000FCB  2  C9 0C                CMP     #NOPSX          ; IS IT A LEGAL X-OP?
000FCD  2  90 05                BCC     DODIS           ; YUP; TIME TO DISPATCH IT
000FCF  2               
000FCF  2               ; *** ERROR #1 -- ILLEGAL X-OP ***
000FCF  2               
000FCF  2  A9 01                LDA     #1
000FD1  2  4C EB 1D             JMP     ZERROR
000FD4  2               
000FD4  2               ; ---------------
000FD4  2               ; OPCODE DISPATCH
000FD4  2               ; ---------------
000FD4  2               
000FD4  2               ; ENTRY: MASKED OPCODE INDEX IN [A]
000FD4  2               ;        OP-TABLE ADDR IN X/Y (LSB/MSB)
000FD4  2               
000FD4  2               DODIS:
000FD4  2  86 6E                STX     I+LO            ; SAVE TABLE ADDRESS
000FD6  2  84 6F                STY     I+HI            ; IN A POINTER
000FD8  2               
000FD8  2  0A                   ASL     A               ; WORD-ALIGN THE OP INDEX
000FD9  2  A8                   TAY
000FDA  2  B1 6E                LDA     (I),Y           ; GET LSB OF DISPATCH ADDRESS
000FDC  2  8D E6 0F             STA     GO+LO           ; INSTALL AS JSR OPERAND
000FDF  2  C8                   INY
000FE0  2  B1 6E                LDA     (I),Y           ; SAME WITH MSB
000FE2  2  8D E7 0F             STA     GO+HI
000FE5  2               
000FE5  2  20                   .BYTE   $20             ; 6502 "JSR" OPCODE
000FE6  2               GO:
000FE6  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
000FE8  2               
000FE8  2  4C 5F 0F             JMP     MLOOP           ; GO BACK FOR ANOTHER OPCODE
000FEB  2               
000FEB  2               ; -------------
000FEB  2               ; HANDLE A 0-OP
000FEB  2               ; -------------
000FEB  2               
000FEB  2               OP0:
000FEB  2  A2 C5                LDX     #<OPT0          ; GET 0-OP TABLE ADDR
000FED  2  A0 11                LDY     #>OPT0          ; INTO [X/Y]
000FEF  2  29 0F                AND     #%00001111      ; ISOLATE 0-OP ID BITS
000FF1  2  C9 0E                CMP     #NOPS0          ; OUT OF RANGE?
000FF3  2  90 DF                BCC     DODIS           ; NO, DISPATCH IT
000FF5  2               
000FF5  2               ; *** ERROR #2 -- ILLEGAL 0-OP ***
000FF5  2               
000FF5  2  A9 02                LDA     #2
000FF7  2  4C EB 1D             JMP     ZERROR
000FFA  2               
000FFA  2               ; -------------
000FFA  2               ; HANDLE A 1-OP
000FFA  2               ; -------------
000FFA  2               
000FFA  2               OP1:
000FFA  2  29 30                AND     #%00110000      ; ISOLATE ARGUMENT BITS
000FFC  2  D0 06                BNE     OP1A
000FFE  2  20 75 10             JSR     GETLNG          ; 00 = LONG IMMEDIATE
001001  2  4C 15 10             JMP     OP1EX
001004  2               
001004  2               OP1A:
001004  2  C9 10                CMP     #%00010000      ; TEST AGAIN
001006  2  D0 06                BNE     OP1B
001008  2  20 71 10             JSR     GETSHT          ; 01 = SHORT IMMEDIATE
00100B  2  4C 15 10             JMP     OP1EX
00100E  2               
00100E  2               OP1B:
00100E  2  C9 20                CMP     #%00100000      ; ONE MORE TEST
001010  2  D0 12                BNE     BADOP1          ; UNDEFINED STATE!
001012  2  20 89 10             JSR     GETVAR          ; 10 = VARIABLE
001015  2               
001015  2               OP1EX:
001015  2  20 66 10             JSR     V2A1            ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
001018  2  A2 E1                LDX     #<OPT1          ; GET ADDR OF 1-OP TABLE
00101A  2  A0 11                LDY     #>OPT1          ; INTO [X/Y]
00101C  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE
00101E  2  29 0F                AND     #%00001111      ; ISOLATE OP ID BITS
001020  2  C9 10                CMP     #NOPS1          ; IF WITHIN RANGE,
001022  2  90 B0                BCC     DODIS           ; EXECUTE THE 1-OP
001024  2               
001024  2               ; *** ERROR #3 -- ILLEGAL 1-OP ***
001024  2               
001024  2               BADOP1:
001024  2  A9 03                LDA     #3
001026  2  4C EB 1D             JMP     ZERROR
001029  2               
001029  2               ; -------------
001029  2               ; HANDLE A 2-OP
001029  2               ; -------------
001029  2               
001029  2               OP2:
001029  2  29 40                AND     #%01000000      ; ISOLATE 1ST ARG BIT
00102B  2  D0 06                BNE     OP2A
00102D  2  20 71 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
001030  2  4C 36 10             JMP     OP2B
001033  2               OP2A:
001033  2  20 89 10             JSR     GETVAR          ; 1 = VARIABLE
001036  2               OP2B:
001036  2  20 66 10             JSR     V2A1            ; [VALUE] TO [ARG1], UPDATE [NARGS]
001039  2               
001039  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
00103B  2  29 20                AND     #%00100000      ; ISOLATE 2ND ARG BIT
00103D  2  D0 06                BNE     OP2C
00103F  2  20 71 10             JSR     GETSHT          ; 0 = SHORT IMMEDIATE
001042  2  4C 48 10             JMP     OP2D
001045  2               OP2C:
001045  2  20 89 10             JSR     GETVAR          ; 1 = VARIABLE
001048  2               OP2D:
001048  2  A5 6C                LDA     VALUE+LO        ; MOVE 2ND [VALUE]
00104A  2  85 64                STA     ARG2+LO         ; INTO [ARG2]
00104C  2  A5 6D                LDA     VALUE+HI
00104E  2  85 65                STA     ARG2+HI
001050  2  E6 61                INC     NARGS           ; UPDATE ARGUMENT COUNT
001052  2               
001052  2               ; EXECUTE A 2-OP OR EXTENDED 2-OP
001052  2               
001052  2               OP2EX:
001052  2  A2 01                LDX     #<OPT2          ; LSB OF DISPATCH TABLE
001054  2  A0 12                LDY     #>OPT2          ; MSB
001056  2  A5 60                LDA     OPCODE          ; RESTORE OPCODE BYTE
001058  2  29 1F                AND     #%00011111      ; ISOLATE OP ID BITS
00105A  2  C9 19                CMP     #NOPS2
00105C  2  B0 03                BCS     BADOP2          ; ERROR IF OUT OF RANGE
00105E  2  4C D4 0F             JMP     DODIS           ; ELSE DISPATCH
001061  2               
001061  2               ; *** ERROR #4 -- ILLEGAL 2-OP ****
001061  2               
001061  2               BADOP2:
001061  2  A9 04                LDA     #4
001063  2  4C EB 1D             JMP     ZERROR
001066  2               
001066  2               ; --------------------------------------
001066  2               ; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
001066  2               ; --------------------------------------
001066  2               
001066  2               V2A1:
001066  2  A5 6C                LDA     VALUE+LO
001068  2  85 62                STA     ARG1+LO
00106A  2  A5 6D                LDA     VALUE+HI
00106C  2  85 63                STA     ARG1+HI
00106E  2  E6 61                INC     NARGS
001070  2  60                   RTS
001071  2               
001071  1                       .INCLUDE "subs.asm"
001071  2               ;        PAGE
001071  2               ;        SBTTL   "--- OPCODE SUPPORT SUBROUTINES ---"
001071  2               
001071  2               ; -----------------------
001071  2               ; FETCH A SHORT IMMEDIATE
001071  2               ; -----------------------
001071  2               
001071  2               GETSHT:
001071  2  A9 00                LDA     #0              ; MSB IS ZERO
001073  2  F0 03                BEQ     GETV            ; FETCH LSB FROM Z-CODE
001075  2               
001075  2               ; ----------------------
001075  2               ; FETCH A LONG IMMEDIATE
001075  2               ; ----------------------
001075  2               
001075  2               GETLNG:
001075  2  20 E3 19             JSR     NEXTPC          ; GRAB MSB
001078  2               
001078  2               GETV:
001078  2  85 6D                STA     VALUE+HI
00107A  2  20 E3 19             JSR     NEXTPC          ; GRAB LSB
00107D  2  85 6C                STA     VALUE+LO
00107F  2  60                   RTS
001080  2               
001080  2               ; ----------------
001080  2               ; FETCH A VARIABLE
001080  2               ; ----------------
001080  2               
001080  2               ; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
001080  2               
001080  2               VARGET:
001080  2  AA                   TAX                     ; IF NON-ZERO,
001081  2  D0 0B                BNE     GETVR1          ; ACCESS A VARIABLE
001083  2               
001083  2  20 AF 10             JSR     POPVAL          ; ELSE PULL VAR OFF Z-STACK
001086  2  4C C5 10             JMP     PSHVAL          ; WITHOUT ALTERING STACK
001089  2               
001089  2               ; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
001089  2               
001089  2               GETVAR:
001089  2  20 E3 19             JSR     NEXTPC          ; GRAB VAR-TYPE BYTE
00108C  2  F0 21                BEQ     POPVAL          ; VALUE IS ON Z-STACK
00108E  2               
00108E  2               ; IS VARIABLE LOCAL OR GLOBAL?
00108E  2               
00108E  2               GETVR1:
00108E  2  C9 10                CMP     #$10            ; IF >= 16,
001090  2  B0 10                BCS     GETVRG          ; IT'S GLOBAL
001092  2               
001092  2               ; HANDLE A LOCAL VARIABLE
001092  2               
001092  2               GETVRL:
001092  2  38                   SEC
001093  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
001095  2  0A                   ASL     A               ; WORD INDEX
001096  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
001097  2               
001097  2  BD 00 0D             LDA     LOCALS+LO,X     ; GRAB LSB
00109A  2  85 6C                STA     VALUE+LO
00109C  2  BD 01 0D             LDA     LOCALS+HI,X     ; AND MSB
00109F  2  85 6D                STA     VALUE+HI
0010A1  2  60                   RTS
0010A2  2               
0010A2  2               ; HANDLE A GLOBAL VARIABLE
0010A2  2               
0010A2  2               GETVRG:
0010A2  2  20 13 11             JSR     GVCALC          ; GET ADDRESS OF GLOBAL INTO [I]
0010A5  2  B1 6E                LDA     (I),Y           ; MSB OF GLOBAL ([Y] = 0)
0010A7  2  85 6D                STA     VALUE+HI
0010A9  2  C8                   INY                     ; = 1
0010AA  2  B1 6E                LDA     (I),Y           ; LSB OF GLOBAL
0010AC  2  85 6C                STA     VALUE+LO        ; SAVE IT
0010AE  2  60                   RTS                     ; AND WE'RE DONE
0010AF  2               
0010AF  2               ; ----------------------------------
0010AF  2               ; POP Z-STACK INTO [VALUE] AND [X/A]
0010AF  2               ; ----------------------------------
0010AF  2               
0010AF  2               POPVAL:
0010AF  2  C6 74                DEC     ZSP
0010B1  2  F0 0D                BEQ     UNDER           ; UNDERFLOW IF ZERO!
0010B3  2               
0010B3  2  A4 74                LDY     ZSP             ; READ STACK POINTER
0010B5  2  BE 00 09             LDX     ZSTAKL,Y        ; GRAB LSB OF STACK VALUE
0010B8  2  86 6C                STX     VALUE+LO        ; GIVE TO [VALUE]
0010BA  2  B9 00 0A             LDA     ZSTAKH,Y        ; ALSO GRAB MSB
0010BD  2  85 6D                STA     VALUE+HI        ; A SIMILAR FATE
0010BF  2  60                   RTS
0010C0  2               
0010C0  2               ; *** ERROR #5 -- Z-STACK UNDERFLOW ***
0010C0  2               
0010C0  2               UNDER:
0010C0  2  A9 05                LDA     #5
0010C2  2  4C EB 1D             JMP     ZERROR
0010C5  2               
0010C5  2               ; -----------------------
0010C5  2               ; PUSH [VALUE] TO Z-STACK
0010C5  2               ; -----------------------
0010C5  2               
0010C5  2               PSHVAL:
0010C5  2  A6 6C                LDX     VALUE+LO
0010C7  2  A5 6D                LDA     VALUE+HI
0010C9  2               
0010C9  2               ; ---------------------
0010C9  2               ; PUSH [X/A] TO Z-STACK
0010C9  2               ; ---------------------
0010C9  2               
0010C9  2               PUSHXA:
0010C9  2  A4 74                LDY     ZSP             ; READ STACK POINTER
0010CB  2  99 00 0A             STA     ZSTAKH,Y        ; PUSH MSB IN [A]
0010CE  2  8A                   TXA
0010CF  2  99 00 09             STA     ZSTAKL,Y        ; AND LSB IN [X]
0010D2  2               
0010D2  2  E6 74                INC     ZSP             ; UPDATE Z-STACK POINTER
0010D4  2  F0 01                BEQ     OVER            ; OVERFLOW IF ZEROED!
0010D6  2  60                   RTS
0010D7  2               
0010D7  2               ; *** ERROR #6 -- Z-STACK OVERFLOW ***
0010D7  2               
0010D7  2               OVER:
0010D7  2  A9 06                LDA     #6
0010D9  2  4C EB 1D             JMP     ZERROR
0010DC  2               
0010DC  2               ; --------------
0010DC  2               ; RETURN A VALUE
0010DC  2               ; --------------
0010DC  2               
0010DC  2               ; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
0010DC  2               
0010DC  2               VARPUT:
0010DC  2  AA                   TAX                     ; IF ZERO,
0010DD  2  D0 13                BNE     PUTVR1
0010DF  2               
0010DF  2  C6 74                DEC     ZSP             ; FLUSH TOP WORD OFF STACK
0010E1  2  D0 E2                BNE     PSHVAL          ; AND REPLACE WITH [VALUE]
0010E3  2  F0 DB                BEQ     UNDER           ; ERROR IF [ZSP] BECAME ZERO!
0010E5  2               
0010E5  2               ; RETURN A ZERO
0010E5  2               
0010E5  2               RET0:
0010E5  2  A9 00                LDA     #0
0010E7  2               
0010E7  2               ; RETURN BYTE IN [A]
0010E7  2               
0010E7  2               PUTBYT:
0010E7  2  85 6C                STA     VALUE+LO
0010E9  2  A9 00                LDA     #0
0010EB  2  85 6D                STA     VALUE+HI        ; CLEAR MSB
0010ED  2               
0010ED  2               ; RETURN [VALUE]
0010ED  2               
0010ED  2               PUTVAL:
0010ED  2  20 E3 19             JSR     NEXTPC          ; GET VARIABLE ID BYTE
0010F0  2  F0 D3                BEQ     PSHVAL          ; [VALUE] GOES TO Z-STACK
0010F2  2               
0010F2  2               ; LOCAL OR GLOBAL VARIABLE?
0010F2  2               
0010F2  2               PUTVR1:
0010F2  2  C9 10                CMP     #$10            ; IF >= 16,
0010F4  2  B0 10                BCS     PUTVLG          ; IT'S GLOBAL
0010F6  2               
0010F6  2               ; PUT A LOCAL VARIABLE
0010F6  2               
0010F6  2               PUTVLL:
0010F6  2  38                   SEC
0010F7  2  E9 01                SBC     #1              ; FORM A ZERO-ALIGNED
0010F9  2  0A                   ASL     A               ; WORD INDEX
0010FA  2  AA                   TAX                     ; INTO THE [LOCALS] TABLE
0010FB  2               
0010FB  2  A5 6C                LDA     VALUE+LO        ; GRAB LSB
0010FD  2  9D 00 0D             STA     LOCALS+LO,X     ; SAVE IN LOCAL TABLE
001100  2  A5 6D                LDA     VALUE+HI        ; DO SAME TO
001102  2  9D 01 0D             STA     LOCALS+HI,X     ; MSB
001105  2  60                   RTS
001106  2               
001106  2               ; RETURN A GLOBAL VARIABLE
001106  2               
001106  2               PUTVLG:
001106  2  20 13 11             JSR     GVCALC
001109  2  A5 6D                LDA     VALUE+HI        ; GET MSB
00110B  2  91 6E                STA     (I),Y           ; STORE AS 1ST BYTE ([Y] = 0)
00110D  2  C8                   INY                     ; = 1
00110E  2  A5 6C                LDA     VALUE+LO        ; NOW GET LSB
001110  2  91 6E                STA     (I),Y           ; STORE AS 2ND BYTE
001112  2  60                   RTS
001113  2               
001113  2               ; -----------------------
001113  2               ; CALC GLOBAL WORD OFFSET
001113  2               ; -----------------------
001113  2               
001113  2               ; ENTRY: VAR-ID BYTE (16-255) IN [A]
001113  2               ; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [I]
001113  2               ;       [Y] = 0 FOR INDEXING
001113  2               
001113  2               GVCALC:
001113  2  38                   SEC
001114  2  E9 10                SBC     #$10            ; FORM A ZERO-ALIGNED INDEX
001116  2  A0 00                LDY     #0              ; MAKE SURE MSB OF OFFSET AND [Y]
001118  2  84 6F                STY     I+HI            ; ARE CLEARED
00111A  2               
00111A  2  0A                   ASL     A               ; MULTIPLY OFFSET BY 2
00111B  2  26 6F                ROL     I+HI            ; TO WORD-ALIGN IT
00111D  2               
00111D  2  18                   CLC                     ; ADD OFFSET TO ADDR OF GLOBAL TABLE
00111E  2  65 8C                ADC     GLOBAL+LO       ; TO FORM THE ABSOLUTE
001120  2  85 6E                STA     I+LO            ; ADDRESS OF THE
001122  2  A5 6F                LDA     I+HI            ; DESIRED GLOBAL VARIABLE
001124  2  65 8D                ADC     GLOBAL+HI       ; STORE ADDRESS BACK IN [VAL]
001126  2  85 6F                STA     I+HI            ; AS A POINTER
001128  2               
001128  2               WCEX:
001128  2  60                   RTS
001129  2               
001129  2               ; ---------------
001129  2               ; PREDICATE FAILS
001129  2               ; ---------------
001129  2               
001129  2               PREDF:
001129  2  20 E3 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
00112C  2  10 0C                BPL     PREDB           ; DO BRANCH IF BIT 7 OFF
00112E  2               
00112E  2               ; -----------------------
00112E  2               ; IGNORE PREDICATE BRANCH
00112E  2               ; -----------------------
00112E  2               
00112E  2               ; ENTRY: 1ST BRANCH BYTE IN [A]
00112E  2               
00112E  2               PREDNB:
00112E  2  29 40                AND     #%01000000      ; TEST BIT 6
001130  2  D0 F6                BNE     WCEX            ; SHORT BRANCH IF SET
001132  2  4C E3 19             JMP     NEXTPC          ; ELSE SKIP OVER 2ND BRANCH BYTE
001135  2               
001135  2               ; ------------------
001135  2               ; PREDICATE SUCCEEDS
001135  2               ; ------------------
001135  2               
001135  2               PREDS:
001135  2  20 E3 19             JSR     NEXTPC          ; GET 1ST BRANCH BYTE
001138  2  10 F4                BPL     PREDNB          ; DON'T BRANCH IF BIT 7 CLEAR
00113A  2               
00113A  2               ; --------------------------
00113A  2               ; PERFORM A PREDICATE BRANCH
00113A  2               ; --------------------------
00113A  2               
00113A  2               ; ENTRY: 1ST PRED BYTE IN [A]
00113A  2               
00113A  2               PREDB:
00113A  2  AA                   TAX                     ; SAVE HERE
00113B  2  29 40                AND     #%01000000      ; LONG OR SHORT BRANCH?
00113D  2  F0 0B                BEQ     PREDLB          ; LONG IF BIT 6 IS CLEAR
00113F  2               
00113F  2               ; HANDLE A SHORT BRANCH
00113F  2               
00113F  2  8A                   TXA                     ; RESTORE PRED BYTE
001140  2  29 3F                AND     #%00111111      ; FORM SHORT OFFSET
001142  2  85 6C                STA     VALUE+LO        ; USE AS LSB OF BRANCH OFFSET
001144  2  A9 00                LDA     #0
001146  2  85 6D                STA     VALUE+HI        ; MSB OF OFFSET IS ZERO
001148  2  F0 13                BEQ     PREDB1          ; DO THE BRANCH
00114A  2               
00114A  2               ; HANDLE A LONG BRANCH
00114A  2               
00114A  2               PREDLB:
00114A  2  8A                   TXA                     ; RESTORE 1ST PRED BYTE
00114B  2  29 3F                AND     #%00111111      ; FORM MSB OF OFFSET
00114D  2               
00114D  2  AA                   TAX                     ; SAVE HERE FOR REFERENCE
00114E  2               
00114E  2  29 20                AND     #%00100000      ; CHECK SIGN OF 14-BIT VALUE
001150  2  F0 04                BEQ     DOB2            ; POSITIVE IF ZERO, SO USE [X]
001152  2               
001152  2  8A                   TXA                     ; ELSE RESTORE BYTE
001153  2  09 E0                ORA     #%11100000      ; EXTEND THE SIGN BIT
001155  2  AA                   TAX                     ; BACK HERE FOR STORAGE
001156  2               
001156  2               DOB2:
001156  2  86 6D                STX     VALUE+HI
001158  2  20 E3 19             JSR     NEXTPC          ; FETCH LSB OF 14-BIT OFFSET
00115B  2  85 6C                STA     VALUE+LO
00115D  2               
00115D  2               ; BRANCH TO Z-ADDRESS IN [VALUE]
00115D  2               
00115D  2               PREDB1:
00115D  2  A5 6D                LDA     VALUE+HI        ; CHECK MSB OF OFFSET
00115F  2  D0 0E                BNE     PREDB3          ; DO BRANCH IF NZ
001161  2               
001161  2  A5 6C                LDA     VALUE+LO        ; IF LSB IS NON-ZERO,
001163  2  D0 03                BNE     PREDB2          ; MAKE SURE IT ISN'T 1
001165  2  4C 56 12             JMP     ZRFALS          ; ELSE DO AN "RFALSE"
001168  2               
001168  2               PREDB2:
001168  2  C9 01                CMP     #1              ; IF OFFSET = 1
00116A  2  D0 03                BNE     PREDB3
00116C  2  4C 4B 12             JMP     ZRTRUE          ; DO AN "RTRUE"
00116F  2               
00116F  2               ; ENTRY POINT FOR "JUMP"
00116F  2               
00116F  2               PREDB3:
00116F  2  20 A9 11             JSR     DECVAL          ; SUBTRACT 2 FROM THE OFFSET
001172  2  20 A9 11             JSR     DECVAL          ; IN [VALUE]
001175  2               
001175  2  A9 00                LDA     #0              ; CLEAR THE MSB
001177  2  85 6F                STA     I+HI            ; OF [I]
001179  2               
001179  2  A5 6D                LDA     VALUE+HI        ; MAKE MSB OF OFFSET
00117B  2  85 6E                STA     I+LO            ; THE LSB OF [I]
00117D  2  0A                   ASL     A               ; EXTEND THE SIGN OF OFFSET
00117E  2  26 6F                ROL     I+HI            ; INTO MSB OF [I]
001180  2               
001180  2  A5 6C                LDA     VALUE+LO        ; GET LSB OF OFFSET
001182  2  18                   CLC
001183  2  65 76                ADC     ZPCL            ; ADD LOW 8 BITS OF ZPC
001185  2  90 06                BCC     PREDB5          ; IF OVERFLOWED,
001187  2               
001187  2  E6 6E                INC     I+LO            ; UPDATE UPPER 9 BITS
001189  2  D0 02                BNE     PREDB5
00118B  2  E6 6F                INC     I+HI
00118D  2               
00118D  2               PREDB5:
00118D  2  85 76                STA     ZPCL            ; UPDATE ZPC
00118F  2               
00118F  2  A5 6E                LDA     I+LO            ; IF UPPER 9 BITS ARE ZERO,
001191  2  05 6F                ORA     I+HI            ; NO NEED TO CHANGE PAGES
001193  2  F0 13                BEQ     ZNOOP
001195  2               
001195  2  A5 6E                LDA     I+LO            ; ELSE CALC NEW UPPER BITS
001197  2  18                   CLC
001198  2  65 77                ADC     ZPCM
00119A  2  85 77                STA     ZPCM
00119C  2               
00119C  2  A5 6F                LDA     I+HI
00119E  2  65 78                ADC     ZPCH
0011A0  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
0011A2  2  85 78                STA     ZPCH
0011A4  2               
0011A4  2  A9 00                LDA     #0
0011A6  2  85 79                STA     ZPCFLG          ; [ZPC] NO LONGER VALID
0011A8  2               
0011A8  2               ; FALL THROUGH ...
0011A8  2               
0011A8  2               ; ----
0011A8  2               ; NOOP
0011A8  2               ; ----
0011A8  2               
0011A8  2               ZNOOP:
0011A8  2  60                   RTS
0011A9  2               
0011A9  2               ; -----------------
0011A9  2               ; DECREMENT [VALUE]
0011A9  2               ; -----------------
0011A9  2               
0011A9  2               DECVAL:
0011A9  2  A5 6C                LDA     VALUE+LO
0011AB  2  38                   SEC
0011AC  2  E9 01                SBC     #1
0011AE  2  85 6C                STA     VALUE+LO
0011B0  2  B0 02                BCS     DVX
0011B2  2  C6 6D                DEC     VALUE+HI
0011B4  2               DVX:
0011B4  2  60                   RTS
0011B5  2               
0011B5  2               ; -----------------
0011B5  2               ; INCREMENT [VALUE]
0011B5  2               ; -----------------
0011B5  2               
0011B5  2               INCVAL:
0011B5  2  E6 6C                INC     VALUE+LO
0011B7  2  D0 02                BNE     IVX
0011B9  2  E6 6D                INC     VALUE+HI
0011BB  2               IVX:
0011BB  2  60                   RTS
0011BC  2               
0011BC  2               ; ----------------------
0011BC  2               ; MOVE [ARG1] TO [VALUE]
0011BC  2               ; ----------------------
0011BC  2               
0011BC  2               A12VAL:
0011BC  2  A5 62                LDA     ARG1+LO
0011BE  2  85 6C                STA     VALUE+LO
0011C0  2  A5 63                LDA     ARG1+HI
0011C2  2  85 6D                STA     VALUE+HI
0011C4  2  60                   RTS
0011C5  2               
0011C5  1                       .INCLUDE "dispatch.asm"
0011C5  2               ;        PAGE
0011C5  2               ;        SBTTL   "--- OPCODE DISPATCH TABLES ---"
0011C5  2               
0011C5  2               ; 0-OPS
0011C5  2               
0011C5  2               OPT0:
0011C5  2  4B 12                .WORD   ZRTRUE          ; 0
0011C7  2  56 12                .WORD   ZRFALS          ; 1
0011C9  2  5A 12                .WORD   ZPRI            ; 2
0011CB  2  77 12                .WORD   ZPRR            ; 3
0011CD  2  A8 11                .WORD   ZNOOP           ; 4
0011CF  2  8D 23                .WORD   ZSAVE           ; 5
0011D1  2  02 24                .WORD   ZREST           ; 6
0011D3  2  2A 1E                .WORD   ZSTART          ; 7
0011D5  2  80 12                .WORD   ZRSTAK          ; 8
0011D7  2  AF 10                .WORD   POPVAL          ; 9
0011D9  2  09 1E                .WORD   ZQUIT           ; 10
0011DB  2  0A 1F                .WORD   ZCRLF           ; 11
0011DD  2  7C 1F                .WORD   ZUSL            ; 12
0011DF  2  86 12                .WORD   ZVER            ; 13
0011E1  2               
0011E1  2               NOPS0           = 14            ; NUMBER OF 0-OPS
0011E1  2               
0011E1  2               ; 1-OPS
0011E1  2               
0011E1  2               OPT1:
0011E1  2  E4 12                .WORD   ZZERO           ; 0
0011E3  2  ED 12                .WORD   ZNEXT           ; 1
0011E5  2  F6 12                .WORD   ZFIRST          ; 2
0011E7  2  09 13                .WORD   ZLOC            ; 3
0011E9  2  15 13                .WORD   ZPTSIZ          ; 4
0011EB  2  32 13                .WORD   ZINC            ; 5
0011ED  2  3D 13                .WORD   ZDEC            ; 6
0011EF  2  4A 13                .WORD   ZPRB            ; 7
0011F1  2  24 10                .WORD   BADOP1          ; 8 (UNDEFINED)
0011F3  2  58 13                .WORD   ZREMOV          ; 9
0011F5  2  9A 13                .WORD   ZPRD            ; 10
0011F7  2  B7 13                .WORD   ZRET            ; 11
0011F9  2  FF 13                .WORD   ZJUMP           ; 12
0011FB  2  05 14                .WORD   ZPRINT          ; 13
0011FD  2  13 14                .WORD   ZVALUE          ; 14
0011FF  2  1B 14                .WORD   ZBCOM           ; 15
001201  2               
001201  2               NOPS1           = 16            ; NUMBER OF 1-OPS
001201  2               
001201  2               ; 2-OPS
001201  2               
001201  2               OPT2:
001201  2  61 10                .WORD   BADOP2          ; 0 (UNDEFINED)
001203  2  C9 16                .WORD   ZEQUAL          ; 1
001205  2  2B 14                .WORD   ZLESS           ; 2
001207  2  3F 14                .WORD   ZGRTR           ; 3
001209  2  31 14                .WORD   ZDLESS          ; 4
00120B  2  4A 14                .WORD   ZIGRTR          ; 5
00120D  2  7A 14                .WORD   ZIN             ; 6
00120F  2  8A 14                .WORD   ZBTST           ; 7
001211  2  9D 14                .WORD   ZBOR            ; 8
001213  2  A9 14                .WORD   ZBAND           ; 9
001215  2  B5 14                .WORD   ZFSETP          ; 10
001217  2  C9 14                .WORD   ZFSET           ; 11
001219  2  DC 14                .WORD   ZFCLR           ; 12
00121B  2  F3 14                .WORD   ZSET            ; 13
00121D  2  00 15                .WORD   ZMOVE           ; 14
00121F  2  2A 15                .WORD   ZGET            ; 15
001221  2  3A 15                .WORD   ZGETB           ; 16
001223  2  57 15                .WORD   ZGETP           ; 17
001225  2  9F 15                .WORD   ZGETPT          ; 18
001227  2  CC 15                .WORD   ZNEXTP          ; 19
001229  2  EB 15                .WORD   ZADD            ; 20
00122B  2  F8 15                .WORD   ZSUB            ; 21
00122D  2  05 16                .WORD   ZMUL            ; 22
00122F  2  29 16                .WORD   ZDIV            ; 23
001231  2  33 16                .WORD   ZMOD            ; 24
001233  2               
001233  2               NOPS2           = 25            ; NUMBER OF 2-OPS
001233  2               
001233  2               ; X-OPS
001233  2               
001233  2               OPTX:
001233  2  FC 16                .WORD   ZCALL           ; 0
001235  2  91 17                .WORD   ZPUT            ; 1
001237  2  9F 17                .WORD   ZPUTB           ; 2
001239  2  BA 17                .WORD   ZPUTP           ; 3
00123B  2  66 18                .WORD   ZREAD           ; 4
00123D  2  EB 17                .WORD   ZPRC            ; 5
00123F  2  F0 17                .WORD   ZPRN            ; 6
001241  2  35 18                .WORD   ZRAND           ; 7
001243  2  57 18                .WORD   ZPUSH           ; 8
001245  2  5E 18                .WORD   ZPOP            ; 9
001247  2  C0 21                .WORD   ZSPLIT          ; 10
001249  2  C1 21                .WORD   ZSCRN           ; 11
00124B  2               
00124B  2               NOPSX           = 12            ; NUMBER OF X-OPS
00124B  2               
00124B  1               
00124B  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OPCODE EXECUTORS"
00124B  1                       .INCLUDE "ops0.asm"
00124B  2               ;        PAGE
00124B  2               ;        SBTTL   "--- 0-OPS ---"
00124B  2               
00124B  2               ; -----
00124B  2               ; RTRUE
00124B  2               ; -----
00124B  2               
00124B  2               ; SIMULATE A "RETURN 1"
00124B  2               
00124B  2               ZRTRUE:
00124B  2  A2 01                LDX     #1
00124D  2               
00124D  2               ZRT0:
00124D  2  A9 00                LDA     #0
00124F  2               
00124F  2               ZRT1:
00124F  2  86 62                STX     ARG1+LO         ; GIVE TO
001251  2  85 63                STA     ARG1+HI         ; [ARG1]
001253  2  4C B7 13             JMP     ZRET            ; AND DO THE RETURN
001256  2               
001256  2               ; ------
001256  2               ; RFALSE
001256  2               ; ------
001256  2               
001256  2               ; SIMULATE A "RETURN 0"
001256  2               
001256  2               ZRFALS:
001256  2  A2 00                LDX     #0
001258  2  F0 F3                BEQ     ZRT0
00125A  2               
00125A  2               ; ------
00125A  2               ; PRINTI
00125A  2               ; ------
00125A  2               
00125A  2               ; PRINT Z-STRING FOLLOWING THE OPCODE
00125A  2               
00125A  2               ZPRI:
00125A  2  A5 78                LDA     ZPCH            ; MOVE [ZPC] INTO [MPC]
00125C  2  85 7E                STA     MPCH
00125E  2  A5 77                LDA     ZPCM
001260  2  85 7D                STA     MPCM
001262  2  A5 76                LDA     ZPCL
001264  2  85 7C                STA     MPCL
001266  2               
001266  2  A9 00                LDA     #0
001268  2  85 7F                STA     MPCFLG          ; [MPC] NO LONGER VALID
00126A  2               
00126A  2  20 34 1B             JSR     PZSTR           ; PRINT THE Z-STRING AT [MPC]
00126D  2               
00126D  2  A2 05                LDX     #5              ; COPY STATE OF [MPC]
00126F  2               PRIL:
00126F  2  B5 7C                LDA     MPC,X           ; INTO [ZPC]
001271  2  95 76                STA     ZPC,X
001273  2  CA                   DEX
001274  2  10 F9                BPL     PRIL
001276  2  60                   RTS
001277  2               
001277  2               ; ------
001277  2               ; PRINTR
001277  2               ; ------
001277  2               
001277  2               ; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
001277  2               
001277  2               ZPRR:
001277  2  20 5A 12             JSR     ZPRI
00127A  2  20 0A 1F             JSR     ZCRLF
00127D  2  4C 4B 12             JMP     ZRTRUE
001280  2               
001280  2               ; ------
001280  2               ; RSTACK
001280  2               ; ------
001280  2               
001280  2               ; "RETURN" WITH VALUE ON STACK
001280  2               
001280  2               ZRSTAK:
001280  2  20 AF 10             JSR     POPVAL          ; GET VALUE INTO [X/A]
001283  2  4C 4F 12             JMP     ZRT1            ; AND GIVE IT TO "RETURN"
001286  2               
001286  2               ; ------
001286  2               ; VERIFY
001286  2               ; ------
001286  2               
001286  2               ; VERIFY GAME CODE ON DISK
001286  2               
001286  2               ZVER:
001286  2  20 49 1E             JSR     VERNUM          ; DISPLAY ZIP VERSION NUMBER
001289  2               
001289  2  A2 03                LDX     #3
00128B  2  A9 00                LDA     #0
00128D  2               ZVR:
00128D  2  95 70                STA     J+LO,X          ; CLEAR [J], [K]
00128F  2  95 7C                STA     MPC,X           ; [MPC] AND [MPCFLG]
001291  2  CA                   DEX
001292  2  10 F9                BPL     ZVR
001294  2               
001294  2  A9 40                LDA     #64             ; POINT [MPC] TO Z-ADDRESS $00040
001296  2  85 7C                STA     MPCL            ; 1ST 64 BYTES AREN'T CHECKED
001298  2               
001298  2  AD 1A 2B             LDA     ZBEGIN+ZLENTH   ; GET LENGTH OF Z-CODE
00129B  2  85 6F                STA     I+HI            ; IN WORDS
00129D  2  AD 1B 2B             LDA     ZBEGIN+ZLENTH+1 ; FIRST MSB
0012A0  2  85 6E                STA     I+LO            ; THEN LSB
0012A2  2               
0012A2  2  06 6E                ASL     I+LO            ; CONVERT Z-CODE LENGTH
0012A4  2  26 6F                ROL     I+HI            ; TO # BYTES
0012A6  2  26 72                ROL     K+LO            ; TOP BIT IN [K+LO]
0012A8  2               
0012A8  2  A9 73                LDA     #K+HI           ; PATCH THE "GETBYT" ROUTINE
0012AA  2  8D 24 1A             STA     PATCH           ; TO USE [K+HI]=0 INSTEAD OF [ZPURE]
0012AD  2               
0012AD  2               VSUM:
0012AD  2  20 19 1A             JSR     GETBYT          ; GET A Z-BYTE INTO [A]
0012B0  2  18                   CLC
0012B1  2  65 70                ADC     J+LO            ; ADD IT TO SUM
0012B3  2  85 70                STA     J+LO            ; IN [J]
0012B5  2  90 02                BCC     VSUM0
0012B7  2  E6 71                INC     J+HI
0012B9  2               
0012B9  2               VSUM0:
0012B9  2  A5 7C                LDA     MPCL            ; END OF Z-CODE YET?
0012BB  2  C5 6E                CMP     I+LO            ; CHECK LSB
0012BD  2  D0 EE                BNE     VSUM
0012BF  2               
0012BF  2  A5 7D                LDA     MPCM            ; MIDDLE BYTE
0012C1  2  C5 6F                CMP     I+HI
0012C3  2  D0 E8                BNE     VSUM
0012C5  2               
0012C5  2  A5 7E                LDA     MPCH            ; AND HIGH BIT
0012C7  2  C5 72                CMP     K+LO
0012C9  2  D0 E2                BNE     VSUM
0012CB  2               
0012CB  2  A9 84                LDA     #ZPURE          ; UNPATCH "GETBYT"
0012CD  2  8D 24 1A             STA     PATCH
0012D0  2               
0012D0  2  AD 1D 2B             LDA     ZBEGIN+ZCHKSM+1 ; GET LSB OF CHECKSUM
0012D3  2  C5 70                CMP     J+LO            ; DOES IT MATCH?
0012D5  2  D0 0A                BNE     BADVER          ; NO, PREDICATE FAILS
0012D7  2               
0012D7  2  AD 1C 2B             LDA     ZBEGIN+ZCHKSM   ; ELSE CHECK MSB
0012DA  2  C5 71                CMP     J+HI            ; LOOK GOOD?
0012DC  2  D0 03                BNE     BADVER          ; IF MATCHED,
0012DE  2  4C 35 11             JMP     PREDS           ; GAME IS OKAY
0012E1  2               
0012E1  2               BADVER:
0012E1  2  4C 29 11             JMP     PREDF
0012E4  2               
0012E4  1                       .INCLUDE "ops1.asm"
0012E4  2               ;        PAGE
0012E4  2               ;        SBTTL   "--- 1-OPS ---"
0012E4  2               
0012E4  2               ; -----
0012E4  2               ; ZERO?
0012E4  2               ; -----
0012E4  2               
0012E4  2               ; [ARG1] = 0?
0012E4  2               
0012E4  2               ZZERO:
0012E4  2  A5 62                LDA     ARG1+LO
0012E6  2  05 63                ORA     ARG1+HI
0012E8  2  F0 1C                BEQ     PFINE
0012EA  2               
0012EA  2               PYUCK:
0012EA  2  4C 29 11             JMP     PREDF
0012ED  2               
0012ED  2               ; -----
0012ED  2               ; NEXT?
0012ED  2               ; -----
0012ED  2               
0012ED  2               ; RETURN "NEXT" POINTER IN OBJECT [ARG1];
0012ED  2               ; FAIL IF LAST AND RETURN ZERO
0012ED  2               
0012ED  2               ZNEXT:
0012ED  2  A5 62                LDA     ARG1+LO
0012EF  2  20 3F 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012F2  2  A0 05                LDY     #5              ; POINT TO "NEXT" SLOT
0012F4  2  D0 07                BNE     FIRST1
0012F6  2               
0012F6  2               ; ------
0012F6  2               ; FIRST?
0012F6  2               ; ------
0012F6  2               
0012F6  2               ; RETURN "FIRST" POINTER IN OBJECT [ARG1];
0012F6  2               ; FAIL IF LAST AND RETURN ZERO
0012F6  2               
0012F6  2               ZFIRST:
0012F6  2  A5 62                LDA     ARG1+LO
0012F8  2  20 3F 1D             JSR     OBJLOC          ; GET OBJECT ADDR INTO [I]
0012FB  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
0012FD  2               
0012FD  2               FIRST1:
0012FD  2  B1 6E                LDA     (I),Y           ; GET CONTENTS OF SLOT
0012FF  2  20 E7 10             JSR     PUTBYT          ; PASS IT TO VARIABLE
001302  2               
001302  2  A5 6C                LDA     VALUE+LO        ; EXAMINE THE VALUE JUST "PUT"
001304  2  F0 E4                BEQ     PYUCK           ; FAIL IF IT WAS ZERO
001306  2               
001306  2               PFINE:
001306  2  4C 35 11             JMP     PREDS           ; ELSE REJOICE
001309  2               
001309  2               ; ---
001309  2               ; LOC
001309  2               ; ---
001309  2               
001309  2               ; RETURN THE OBJECT CONTAINING OBJECT [ARG1];
001309  2               ; RETURN ZERO IF NONE
001309  2               
001309  2               ZLOC:
001309  2  A5 62                LDA     ARG1+LO
00130B  2  20 3F 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
00130E  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001310  2  B1 6E                LDA     (I),Y           ; GET THE BYTE
001312  2  4C E7 10             JMP     PUTBYT          ; AND SHIP IT OUT
001315  2               
001315  2               ; ------
001315  2               ; PTSIZE
001315  2               ; ------
001315  2               
001315  2               ; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
001315  2               
001315  2               ZPTSIZ:
001315  2  A5 63                LDA     ARG1+HI         ; MOVE ABS ADDR OF
001317  2  18                   CLC                     ; THE PROP TABLE
001318  2  65 83                ADC     ZCODE           ; INTO [I]
00131A  2  85 6F                STA     I+HI
00131C  2               
00131C  2  A5 62                LDA     ARG1+LO         ; DECREMENT THE
00131E  2  38                   SEC                     ; ADDRESS
00131F  2  E9 01                SBC     #1              ; WHILE MOVING LSB
001321  2  85 6E                STA     I+LO
001323  2  B0 02                BCS     PTZ0
001325  2  C6 6F                DEC     I+HI
001327  2               
001327  2               PTZ0:
001327  2  A0 00                LDY     #0              ; GET THE LENGTH
001329  2  20 89 1D             JSR     PROPL           ; OF PROPERTY AT [I] INTO [A]
00132C  2               
00132C  2  18                   CLC
00132D  2  69 01                ADC     #1              ; INCREMENT RESULT
00132F  2  4C E7 10             JMP     PUTBYT          ; AND RETURN IT
001332  2               
001332  2               ; ---
001332  2               ; INC
001332  2               ; ---
001332  2               
001332  2               ; INCREMENT VARIABLE [ARG1]
001332  2               
001332  2               ZINC:
001332  2  A5 62                LDA     ARG1+LO
001334  2  20 80 10             JSR     VARGET          ; FETCH VARIABLE INTO [VALUE]
001337  2  20 B5 11             JSR     INCVAL          ; INCREMENT IT
00133A  2  4C 45 13             JMP     ZD0
00133D  2               
00133D  2               ; ---
00133D  2               ; DEC
00133D  2               ; ---
00133D  2               
00133D  2               ; DECREMENT VARIABLE [ARG1]
00133D  2               
00133D  2               ZDEC:
00133D  2  A5 62                LDA     ARG1+LO
00133F  2  20 80 10             JSR     VARGET          ; FETCH VAR INTO [VALUE]
001342  2  20 A9 11             JSR     DECVAL          ; DECREMENT IT
001345  2               
001345  2               ZD0:
001345  2  A5 62                LDA     ARG1+LO         ; PUT RESULT BACK
001347  2  4C DC 10             JMP     VARPUT          ; INTO THE SAME VARIABLE
00134A  2               
00134A  2               ; ------
00134A  2               ; PRINTB
00134A  2               ; ------
00134A  2               
00134A  2               ; PRINT Z-STRING AT [ARG1]
00134A  2               
00134A  2               ZPRB:
00134A  2  A5 62                LDA     ARG1+LO
00134C  2  85 6E                STA     I+LO
00134E  2  A5 63                LDA     ARG1+HI
001350  2  85 6F                STA     I+HI
001352  2               
001352  2  20 08 1B             JSR     SETWRD          ; MOVE Z-ADDR TO [MPC]
001355  2  4C 34 1B             JMP     PZSTR           ; AND PRINT
001358  2               
001358  2               ; ------
001358  2               ; REMOVE
001358  2               ; ------
001358  2               
001358  2               ; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
001358  2               
001358  2               ZREMOV:
001358  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ADDR
00135A  2  20 3F 1D             JSR     OBJLOC          ; INTO [I]
00135D  2               
00135D  2  A5 6E                LDA     I+LO            ; COPY THE SOURCE ADDR
00135F  2  85 70                STA     J+LO            ; INTO [J]
001361  2  A5 6F                LDA     I+HI            ; FOR LATER REFERENCE
001363  2  85 71                STA     J+HI
001365  2               
001365  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001367  2  B1 6E                LDA     (I),Y           ; GET THE DATA
001369  2  F0 2E                BEQ     REMVEX          ; SCRAM IF NO OBJECT
00136B  2               
00136B  2  20 3F 1D             JSR     OBJLOC          ; ELSE GET ADDR OF OBJECT [A] INTO [I]
00136E  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
001370  2  B1 6E                LDA     (I),Y           ; GRAB DATA
001372  2  C5 62                CMP     ARG1+LO         ; IS THIS THE FIRST?
001374  2  D0 09                BNE     REMVC1          ; NO, KEEP SEARCHING
001376  2               
001376  2  A0 05                LDY     #5              ; ELSE COPY SOURCE'S "NEXT" SLOT
001378  2  B1 70                LDA     (J),Y
00137A  2  C8                   INY                     ; INTO DEST'S "FIRST" SLOT ([Y] = 6)
00137B  2  91 6E                STA     (I),Y
00137D  2  D0 11                BNE     REMVC2          ; BRANCH ALWAYS
00137F  2               
00137F  2               REMVC1:
00137F  2  20 3F 1D             JSR     OBJLOC
001382  2  A0 05                LDY     #5              ; GET "NEXT"
001384  2  B1 6E                LDA     (I),Y
001386  2  C5 62                CMP     ARG1+LO         ; FOUND IT?
001388  2  D0 F5                BNE     REMVC1          ; NO, KEEP TRYING
00138A  2               
00138A  2  A0 05                LDY     #5              ; WHEN FOUND
00138C  2  B1 70                LDA     (J),Y           ; MOVE "NEXT" SLOT OF SOURCE
00138E  2  91 6E                STA     (I),Y           ; TO "NEXT" SLOT OF DEST
001390  2               
001390  2               REMVC2:
001390  2  A9 00                LDA     #0
001392  2  A0 04                LDY     #4              ; CLEAR "LOC"
001394  2  91 70                STA     (J),Y
001396  2  C8                   INY                     ; AND "NEXT" SLOTS ([Y] = 5)
001397  2  91 70                STA     (J),Y           ; OF SOURCE OBJECT
001399  2               
001399  2               REMVEX:
001399  2  60                   RTS
00139A  2               
00139A  2               ; ------
00139A  2               ; PRINTD
00139A  2               ; ------
00139A  2               
00139A  2               ; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
00139A  2               
00139A  2               ZPRD:
00139A  2  A5 62                LDA     ARG1+LO
00139C  2               
00139C  2               ; ENTRY POINT FOR "USL"
00139C  2               
00139C  2               PRNTDC:
00139C  2  20 3F 1D             JSR     OBJLOC          ; GET ADDR OF OBJECT INTO [I]
00139F  2  A0 07                LDY     #7              ; GET PROP TABLE POINTER
0013A1  2  B1 6E                LDA     (I),Y           ; FETCH MSB
0013A3  2  AA                   TAX                     ; SAVE IT HERE
0013A4  2  C8                   INY
0013A5  2  B1 6E                LDA     (I),Y           ; FETCH LSB
0013A7  2  85 6E                STA     I+LO            ; STORE LSB
0013A9  2  86 6F                STX     I+HI            ; AND MSB
0013AB  2               
0013AB  2  E6 6E                INC     I+LO            ; POINT PAST THE
0013AD  2  D0 02                BNE     PDC0            ; LENGTH BYTE
0013AF  2  E6 6F                INC     I+HI
0013B1  2               
0013B1  2               PDC0:
0013B1  2  20 08 1B             JSR     SETWRD          ; CALC Z-STRING ADDR
0013B4  2  4C 34 1B             JMP     PZSTR           ; AND PRINT IT
0013B7  2               
0013B7  2               ; ------
0013B7  2               ; RETURN
0013B7  2               ; ------
0013B7  2               
0013B7  2               ; RETURN FROM "CALL" WITH VALUE [ARG1]
0013B7  2               
0013B7  2               ZRET:
0013B7  2  A5 75                LDA     OLDZSP          ; RE-SYNC THE
0013B9  2  85 74                STA     ZSP             ; Z-STACK POINTER
0013BB  2               
0013BB  2  20 AF 10             JSR     POPVAL          ; POP # LOCALS INTO [X/A]
0013BE  2  86 6F                STX     I+HI            ; SAVE HERE
0013C0  2               
0013C0  2               ; MAKE SURE [X] WAS COMPLEMENT OF [A] (BM 11/24/84)
0013C0  2               
0013C0  2  49 FF                EOR     #$FF            ; COMPLEMENT [A]
0013C2  2  C5 6F                CMP     I+HI            ; MATCHED?
0013C4  2  D0 34                BNE     STKERR          ; ERROR IF NOT
0013C6  2               
0013C6  2  8A                   TXA                     ; SET FLAGS; ANY LOCALS?
0013C7  2  F0 19                BEQ     RET2            ; SKIP IF NOT
0013C9  2               
0013C9  2               ; RESTORE PUSHED LOCALS
0013C9  2               
0013C9  2  CA                   DEX                     ; ZERO-ALIGN
0013CA  2  8A                   TXA                     ; AND
0013CB  2  0A                   ASL     A               ; WORD-ALIGN # LOCALS
0013CC  2  85 6E                STA     I+LO            ; FOR USE AS A STORAGE INDEX
0013CE  2               
0013CE  2               RET1:
0013CE  2  20 AF 10             JSR     POPVAL          ; POP A LOCAL INTO [X/A]
0013D1  2               
0013D1  2  A4 6E                LDY     I+LO            ; RETRIEVE STORAGE INDEX
0013D3  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE MSB OF LOCAL
0013D6  2  8A                   TXA                     ; MOVE LSB
0013D7  2  99 00 0D             STA     LOCALS+LO,Y     ; AND STORE THAT TOO
0013DA  2               
0013DA  2  C6 6E                DEC     I+LO
0013DC  2  C6 6E                DEC     I+LO            ; UPDATE STORAGE INDEX
0013DE  2               
0013DE  2  C6 6F                DEC     I+HI            ; AND LOCALS COUNT
0013E0  2  D0 EC                BNE     RET1            ; POP TILL NO MORE LOCALS
0013E2  2               
0013E2  2               ; RESTORE OTHER VARIABLES
0013E2  2               
0013E2  2               RET2:
0013E2  2  20 AF 10             JSR     POPVAL          ; POP [ZPCH] AND [ZPCM]
0013E5  2  86 77                STX     ZPCM
0013E7  2  85 78                STA     ZPCH
0013E9  2               
0013E9  2  20 AF 10             JSR     POPVAL          ; POP AND RESTORE
0013EC  2  86 75                STX     OLDZSP
0013EE  2  85 76                STA     ZPCL
0013F0  2               
0013F0  2  A9 00                LDA     #0
0013F2  2  85 79                STA     ZPCFLG          ; ZPC CHANGED!
0013F4  2               
0013F4  2  20 BC 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
0013F7  2  4C ED 10             JMP     PUTVAL          ; AND RETURN IT
0013FA  2               
0013FA  2               ; *** ERROR #15: Z-STACK DESTROYED ***
0013FA  2               
0013FA  2               STKERR:
0013FA  2  A9 0F                LDA     #15             ; (BM 11/24/84)
0013FC  2  4C EB 1D             JMP     ZERROR
0013FF  2               
0013FF  2               ; ----
0013FF  2               ; JUMP
0013FF  2               ; ----
0013FF  2               
0013FF  2               ; JUMP TO Z-LOCATION IN [ARG1]
0013FF  2               
0013FF  2               ZJUMP:
0013FF  2  20 BC 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
001402  2  4C 6F 11             JMP     PREDB3          ; A BRANCH THAT ALWAYS SUCCEEDS
001405  2               
001405  2               ; -----
001405  2               ; PRINT
001405  2               ; -----
001405  2               
001405  2               ; PRINT Z-STRING AT WORD POINTER [ARG1]
001405  2               
001405  2               ZPRINT:
001405  2  A5 62                LDA     ARG1+LO
001407  2  85 6E                STA     I+LO
001409  2  A5 63                LDA     ARG1+HI
00140B  2  85 6F                STA     I+HI
00140D  2               
00140D  2  20 22 1B             JSR     SETSTR          ; CALC STRING ADDRESS
001410  2  4C 34 1B             JMP     PZSTR           ; AND PRINT IT
001413  2               
001413  2               ; -----
001413  2               ; VALUE
001413  2               ; -----
001413  2               
001413  2               ; RETURN VALUE OF VARIABLE [ARG1]
001413  2               
001413  2               ZVALUE:
001413  2  A5 62                LDA     ARG1+LO
001415  2  20 80 10             JSR     VARGET          ; GET THE VALUE
001418  2  4C ED 10             JMP     PUTVAL          ; EASY ENOUGH
00141B  2               
00141B  2               ; ----
00141B  2               ; BCOM
00141B  2               ; ----
00141B  2               
00141B  2               ; COMPLEMENT [ARG1]
00141B  2               
00141B  2               ZBCOM:
00141B  2  A5 62                LDA     ARG1+LO
00141D  2  49 FF                EOR     #$FF
00141F  2  AA                   TAX
001420  2  A5 63                LDA     ARG1+HI
001422  2  49 FF                EOR     #$FF
001424  2               
001424  2               ; FALL THROUGH ...
001424  2               
001424  2               ; ---------------------
001424  2               ; RETURN VALUE IN [X/A]
001424  2               ; ---------------------
001424  2               
001424  2               VEXIT:
001424  2  86 6C                STX     VALUE+LO
001426  2  85 6D                STA     VALUE+HI
001428  2  4C ED 10             JMP     PUTVAL
00142B  2               
00142B  1                       .INCLUDE "ops2.asm"
00142B  2               ;        PAGE
00142B  2               ;        SBTTL   "--- 2-OPS ---"
00142B  2               
00142B  2               ; -----
00142B  2               ; LESS?
00142B  2               ; -----
00142B  2               
00142B  2               ; [ARG1] < [ARG2]?
00142B  2               
00142B  2               ZLESS:
00142B  2  20 BC 11             JSR     A12VAL          ; MOVE [ARG1] TO [VALUE]
00142E  2  4C 34 14             JMP     DLS0            ; MOVE [ARG2] TO [I] & COMPARE
001431  2               
001431  2               ; ------
001431  2               ; DLESS?
001431  2               ; ------
001431  2               
001431  2               ; DECREMENT [ARG1]; SUCCEED IF < [ARG2]
001431  2               
001431  2               ZDLESS:
001431  2  20 3D 13             JSR     ZDEC            ; MOVES ([ARG1]-1) TO [VALUE]
001434  2               
001434  2               DLS0:
001434  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [I]
001436  2  85 6E                STA     I+LO
001438  2  A5 65                LDA     ARG2+HI
00143A  2  85 6F                STA     I+HI
00143C  2               
00143C  2  4C 5D 14             JMP     COMPAR          ; COMPARE & RETURN
00143F  2               
00143F  2               ; -----
00143F  2               ; GRTR?
00143F  2               ; -----
00143F  2               
00143F  2               ; [ARG1] > [ARG2]?
00143F  2               
00143F  2               ZGRTR:
00143F  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [I]
001441  2  85 6E                STA     I+LO
001443  2  A5 63                LDA     ARG1+HI
001445  2  85 6F                STA     I+HI
001447  2               
001447  2  4C 55 14             JMP     A2VAL           ; MOVE [ARG2] TO [VALUE] & COMPARE
00144A  2               
00144A  2               ; ------
00144A  2               ; IGRTR?
00144A  2               ; ------
00144A  2               
00144A  2               ; INCREMENT [ARG1]; SUCCEED IF GREATER THAN [ARG2]
00144A  2               
00144A  2               ZIGRTR:
00144A  2  20 32 13             JSR     ZINC            ; GET ([ARG1]+1) INTO [VALUE]
00144D  2               
00144D  2  A5 6C                LDA     VALUE+LO        ; MOVE [VALUE] TO [I]
00144F  2  85 6E                STA     I+LO
001451  2  A5 6D                LDA     VALUE+HI
001453  2  85 6F                STA     I+HI
001455  2               
001455  2               A2VAL:
001455  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO [VALUE]
001457  2  85 6C                STA     VALUE+LO
001459  2  A5 65                LDA     ARG2+HI
00145B  2  85 6D                STA     VALUE+HI
00145D  2               
00145D  2               COMPAR:
00145D  2  20 64 14             JSR     SCOMP           ; COMPARE [VALUE] AND [I]
001460  2  90 38                BCC     PGOOD
001462  2  B0 23                BCS     PBAD
001464  2               
001464  2               ; -----------------
001464  2               ; SIGNED COMPARISON
001464  2               ; -----------------
001464  2               
001464  2               ; ENTRY: VALUES IN [VALUE] AND [I]
001464  2               
001464  2               SCOMP:
001464  2  A5 6F                LDA     I+HI
001466  2  45 6D                EOR     VALUE+HI
001468  2  10 05                BPL     SCMP
00146A  2  A5 6F                LDA     I+HI
00146C  2  C5 6D                CMP     VALUE+HI
00146E  2  60                   RTS
00146F  2               
00146F  2               SCMP:
00146F  2  A5 6D                LDA     VALUE+HI
001471  2  C5 6F                CMP     I+HI
001473  2  D0 04                BNE     SCEX
001475  2  A5 6C                LDA     VALUE+LO
001477  2  C5 6E                CMP     I+LO
001479  2               SCEX:
001479  2  60                   RTS
00147A  2               
00147A  2               ; ---
00147A  2               ; IN?
00147A  2               ; ---
00147A  2               
00147A  2               ; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
00147A  2               
00147A  2               ZIN:
00147A  2  A5 62                LDA     ARG1+LO
00147C  2  20 3F 1D             JSR     OBJLOC          ; GET ADDR OF TARGET OBJECT INTO [I]
00147F  2               
00147F  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT
001481  2  B1 6E                LDA     (I),Y           ; GET DATA
001483  2  C5 64                CMP     ARG2+LO         ; IS IT THERE?
001485  2  F0 13                BEQ     PGOOD           ; YES, SUCCEED
001487  2               
001487  2               PBAD:
001487  2  4C 29 11             JMP     PREDF           ; TOO BAD, CHUM ...
00148A  2               
00148A  2               ; ----
00148A  2               ; BTST
00148A  2               ; ----
00148A  2               
00148A  2               ; IS EVERY "ON" BIT IN [ARG1]
00148A  2               ; ALSO "ON" IN [ARG2]?
00148A  2               
00148A  2               ZBTST:
00148A  2  A5 64                LDA     ARG2+LO         ; FIRST CHECK LSBS
00148C  2  25 62                AND     ARG1+LO
00148E  2  C5 64                CMP     ARG2+LO         ; LSBS MATCH?
001490  2  D0 F5                BNE     PBAD            ; NO, EXIT NOW
001492  2               
001492  2  A5 65                LDA     ARG2+HI         ; ELSE CHECK MSBS
001494  2  25 63                AND     ARG1+HI
001496  2  C5 65                CMP     ARG2+HI         ; MATCHED?
001498  2  D0 ED                BNE     PBAD            ; SORRY ...
00149A  2               
00149A  2               PGOOD:
00149A  2  4C 35 11             JMP     PREDS
00149D  2               
00149D  2               ; ---
00149D  2               ; BOR
00149D  2               ; ---
00149D  2               
00149D  2               ; RETURN [ARG1] "OR" [ARG2]
00149D  2               
00149D  2               ZBOR:
00149D  2  A5 62                LDA     ARG1+LO
00149F  2  05 64                ORA     ARG2+LO
0014A1  2  AA                   TAX
0014A2  2  A5 63                LDA     ARG1+HI
0014A4  2  05 65                ORA     ARG2+HI
0014A6  2  4C 24 14             JMP     VEXIT
0014A9  2               
0014A9  2               ; ----
0014A9  2               ; BAND
0014A9  2               ; ----
0014A9  2               
0014A9  2               ; RETURN [ARG1] "AND" [ARG2]
0014A9  2               
0014A9  2               ZBAND:
0014A9  2  A5 62                LDA     ARG1+LO
0014AB  2  25 64                AND     ARG2+LO
0014AD  2  AA                   TAX
0014AE  2  A5 63                LDA     ARG1+HI
0014B0  2  25 65                AND     ARG2+HI
0014B2  2  4C 24 14             JMP     VEXIT
0014B5  2               
0014B5  2               ; -----
0014B5  2               ; FSET?
0014B5  2               ; -----
0014B5  2               
0014B5  2               ; IS FLAG [ARG1] SET IN OBJECT [ARG2]?
0014B5  2               
0014B5  2               ZFSETP:
0014B5  2  20 9B 1D             JSR     FLAGSU          ; GET BITS INTO [K] AND [J]
0014B8  2  A5 73                LDA     K+HI            ; DO MSBS
0014BA  2  25 71                AND     J+HI
0014BC  2  85 73                STA     K+HI
0014BE  2               
0014BE  2  A5 72                LDA     K+LO            ; DO LSBS
0014C0  2  25 70                AND     J+LO
0014C2  2               
0014C2  2  05 73                ORA     K+HI            ; ANY BITS ON?
0014C4  2  D0 D4                BNE     PGOOD           ; TARGET BIT MUST BE ON
0014C6  2  4C 29 11             JMP     PREDF
0014C9  2               
0014C9  2               ; ----
0014C9  2               ; FSET
0014C9  2               ; ----
0014C9  2               
0014C9  2               ; SET FLAG [ARG2] IN OBJECT [ARG1]
0014C9  2               
0014C9  2               ZFSET:
0014C9  2  20 9B 1D             JSR     FLAGSU          ; GET BITS INTO [K] & [J], ADDR IN [I]
0014CC  2               
0014CC  2  A0 00                LDY     #0
0014CE  2  A5 73                LDA     K+HI            ; FIRST DO MSBS
0014D0  2  05 71                ORA     J+HI
0014D2  2  91 6E                STA     (I),Y
0014D4  2               
0014D4  2  C8                   INY
0014D5  2  A5 72                LDA     K+LO            ; THEN LSBS
0014D7  2  05 70                ORA     J+LO
0014D9  2  91 6E                STA     (I),Y
0014DB  2  60                   RTS
0014DC  2               
0014DC  2               ; ------
0014DC  2               ; FCLEAR
0014DC  2               ; ------
0014DC  2               
0014DC  2               ; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
0014DC  2               
0014DC  2               ZFCLR:
0014DC  2  20 9B 1D             JSR     FLAGSU          ; GETS BITS INTO [J] & [K], ADDR IN [I]
0014DF  2               
0014DF  2  A0 00                LDY     #0
0014E1  2  A5 71                LDA     J+HI            ; FETCH MSB
0014E3  2  49 FF                EOR     #$FF            ; COMPLEMENT IT
0014E5  2  25 73                AND     K+HI            ; RUB OUT FLAG
0014E7  2  91 6E                STA     (I),Y
0014E9  2               
0014E9  2  C8                   INY
0014EA  2  A5 70                LDA     J+LO            ; SAME FOR LSB
0014EC  2  49 FF                EOR     #$FF
0014EE  2  25 72                AND     K+LO
0014F0  2  91 6E                STA     (I),Y
0014F2  2  60                   RTS
0014F3  2               
0014F3  2               ; ---
0014F3  2               ; SET
0014F3  2               ; ---
0014F3  2               
0014F3  2               ; SET VARIABLE [ARG1] EQUAL TO [ARG2]
0014F3  2               
0014F3  2               ZSET:
0014F3  2  A5 64                LDA     ARG2+LO         ; MOVE THE VALUE
0014F5  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
0014F7  2  A5 65                LDA     ARG2+HI
0014F9  2  85 6D                STA     VALUE+HI
0014FB  2               
0014FB  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
0014FD  2  4C DC 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
001500  2               
001500  2               ; ----
001500  2               ; MOVE
001500  2               ; ----
001500  2               
001500  2               ; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
001500  2               
001500  2               ZMOVE:
001500  2  20 58 13             JSR     ZREMOV          ; REMOVE FIRST
001503  2               
001503  2  A5 62                LDA     ARG1+LO
001505  2  20 3F 1D             JSR     OBJLOC          ; GET SOURCE OBJECT ADDR INTO [I]
001508  2               
001508  2  A5 6E                LDA     I+LO            ; COPY SOURCE ADDRESS
00150A  2  85 70                STA     J+LO            ; INTO [J]
00150C  2  A5 6F                LDA     I+HI
00150E  2  85 71                STA     J+HI
001510  2               
001510  2  A5 64                LDA     ARG2+LO         ; GET DEST OBJECT ID
001512  2  A0 04                LDY     #4              ; POINT TO "LOC" SLOT OF SOURCE
001514  2  91 6E                STA     (I),Y           ; AND MOVE IT IN
001516  2               
001516  2  20 3F 1D             JSR     OBJLOC          ; GET ADDR OF DEST OBJECT INTO [I]
001519  2               
001519  2  A0 06                LDY     #6              ; POINT TO "FIRST" SLOT
00151B  2  B1 6E                LDA     (I),Y           ; GET "FIRST" OF DEST
00151D  2  AA                   TAX                     ; SAVE HERE FOR A MOMENT
00151E  2               
00151E  2  A5 62                LDA     ARG1+LO         ; GET SOURCE OBJECT ID
001520  2  91 6E                STA     (I),Y           ; MAKE IT "FIRST" OF DEST
001522  2               
001522  2  8A                   TXA                     ; RESTORE "FIRST" OF DEST
001523  2  F0 04                BEQ     ZMVEX           ; SCRAM IF ZERO
001525  2               
001525  2  A0 05                LDY     #5              ; MAKE "FIRST" OF DEST
001527  2  91 70                STA     (J),Y           ; THE "NEXT" OF SOURCE
001529  2               
001529  2               ZMVEX:
001529  2  60                   RTS
00152A  2               
00152A  2               ; ---
00152A  2               ; GET
00152A  2               ; ---
00152A  2               
00152A  2               ; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
00152A  2               
00152A  2               ZGET:
00152A  2  20 3F 15             JSR     WCALC           ; CALC ADDRESS
00152D  2  20 19 1A             JSR     GETBYT          ; GET 1ST BYTE (MSB)
001530  2               
001530  2               DOGET:
001530  2  85 6D                STA     VALUE+HI        ; SAVE MSB
001532  2  20 19 1A             JSR     GETBYT          ; GET LSB
001535  2  85 6C                STA     VALUE+LO        ; SAVE AND
001537  2  4C ED 10             JMP     PUTVAL          ; HAND IT OVER
00153A  2               
00153A  2               ; ----
00153A  2               ; GETB
00153A  2               ; ----
00153A  2               
00153A  2               ; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
00153A  2               
00153A  2               ZGETB:
00153A  2  20 43 15             JSR     BCALC
00153D  2  F0 F1                BEQ     DOGET           ; [A] = 0, SO CLEAR MSB OF [VALUE]
00153F  2               
00153F  2               ; --------------------
00153F  2               ; CALC TABLE ADDRESSES
00153F  2               ; --------------------
00153F  2               
00153F  2               ; WORD-ALIGNED ENTRY
00153F  2               
00153F  2               WCALC:
00153F  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN FOR
001541  2  26 65                ROL     ARG2+HI         ; WORD ACCESS
001543  2               
001543  2               ; BYTE-ALIGNED ENTRY
001543  2               
001543  2               BCALC:
001543  2  A5 64                LDA     ARG2+LO         ; ADD BASE ADDR OF TABLE
001545  2  18                   CLC                     ; TO ITEM
001546  2  65 62                ADC     ARG1+LO         ; INDEX
001548  2  85 7C                STA     MPCL
00154A  2               
00154A  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSBS
00154C  2  65 63                ADC     ARG1+HI
00154E  2  85 7D                STA     MPCM
001550  2               
001550  2  A9 00                LDA     #0
001552  2  85 7E                STA     MPCH            ; CLEAR TOP BIT
001554  2  85 7F                STA     MPCFLG          ; & INVALIDATE [MPC]
001556  2  60                   RTS
001557  2               
001557  2               ; ----
001557  2               ; GETP
001557  2               ; ----
001557  2               
001557  2               ; RETURN PROPERTY [ARG2] OF OBJECT [ARG1];
001557  2               ; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
001557  2               
001557  2               ZGETP:
001557  2  20 68 1D             JSR     PROPB
00155A  2               
00155A  2               GETP1:
00155A  2  20 84 1D             JSR     PROPN
00155D  2  C5 64                CMP     ARG2+LO
00155F  2  F0 1B                BEQ     GETP3
001561  2  90 06                BCC     GETP2
001563  2               
001563  2  20 91 1D             JSR     PROPNX
001566  2  4C 5A 15             JMP     GETP1           ; TRY AGAIN WITH NEXT PROP
001569  2               
001569  2               GETP2:
001569  2  A5 64                LDA     ARG2+LO         ; GET PROPERTY #
00156B  2  38                   SEC                     ; ZERO-ALIGN IT
00156C  2  E9 01                SBC     #1
00156E  2  0A                   ASL     A               ; WORD-ALIGN IT
00156F  2  A8                   TAY                     ; USE AS AN INDEX
001570  2  B1 92                LDA     (OBJTAB),Y      ; GET MSB OF PROPERTY
001572  2  85 6D                STA     VALUE+HI
001574  2  C8                   INY
001575  2  B1 92                LDA     (OBJTAB),Y      ; DO SAME WITH LSB
001577  2  85 6C                STA     VALUE+LO
001579  2  4C ED 10             JMP     PUTVAL          ; RETURN DEFAULT IN [VALUE]
00157C  2               
00157C  2               GETP3:
00157C  2  20 89 1D             JSR     PROPL
00157F  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST BYTE OF PROP
001580  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
001581  2  F0 09                BEQ     GETPB           ; GET A BYTE PROPERTY
001583  2  C9 01                CMP     #1              ; IF LENGTH = 1
001585  2  F0 0B                BEQ     GETPW           ; GET A WORD PROPERTY
001587  2               
001587  2               ; *** ERROR #7: PROPERTY LENGTH ***
001587  2               
001587  2  A9 07                LDA     #7
001589  2  4C EB 1D             JMP     ZERROR
00158C  2               
00158C  2               ; GET A 1-BYTE PROPERTY
00158C  2               
00158C  2               GETPB:
00158C  2  B1 6E                LDA     (I),Y           ; GET LSB INTO [A]
00158E  2  A2 00                LDX     #0              ; CLEAR MSB IN [X]
001590  2  F0 06                BEQ     ETPEX
001592  2               
001592  2               ; GET A 2-BYTE PROPERTY
001592  2               
001592  2               GETPW:
001592  2  B1 6E                LDA     (I),Y           ; GET MSB
001594  2  AA                   TAX                     ; INTO [X]
001595  2  C8                   INY                     ; POINT TO LSB
001596  2  B1 6E                LDA     (I),Y           ; GET IT INTO [A]
001598  2               
001598  2               ETPEX:
001598  2  85 6C                STA     VALUE+LO        ; STORE LSB
00159A  2  86 6D                STX     VALUE+HI        ; AND MSB
00159C  2  4C ED 10             JMP     PUTVAL
00159F  2               
00159F  2               ; -----
00159F  2               ; GETPT
00159F  2               ; -----
00159F  2               
00159F  2               ; RETURN POINTER TO PROP TABLE [ARG2]
00159F  2               ; IN OBJECT [ARG1]
00159F  2               
00159F  2               ZGETPT:
00159F  2  20 68 1D             JSR     PROPB
0015A2  2               
0015A2  2               GETPT1:
0015A2  2  20 84 1D             JSR     PROPN           ; RETURNS OFFSET IN [Y]
0015A5  2  C5 64                CMP     ARG2+LO
0015A7  2  F0 08                BEQ     GETPT2
0015A9  2  90 1E                BCC     DORET
0015AB  2  20 91 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
0015AE  2  4C A2 15             JMP     GETPT1
0015B1  2               
0015B1  2               GETPT2:
0015B1  2  E6 6E                INC     I+LO
0015B3  2  D0 02                BNE     GETPT3
0015B5  2  E6 6F                INC     I+HI
0015B7  2               
0015B7  2               GETPT3:
0015B7  2  98                   TYA                     ; FETCH OFFSET
0015B8  2  18                   CLC
0015B9  2  65 6E                ADC     I+LO            ; ADD LSB OF TABLE ADDRESS
0015BB  2  85 6C                STA     VALUE+LO
0015BD  2               
0015BD  2  A5 6F                LDA     I+HI            ; AND MSB
0015BF  2  69 00                ADC     #0
0015C1  2  38                   SEC                     ; STRIP OFF
0015C2  2  E5 83                SBC     ZCODE           ; RELATIVE POINTER
0015C4  2  85 6D                STA     VALUE+HI
0015C6  2  4C ED 10             JMP     PUTVAL          ; AND RETURN
0015C9  2               
0015C9  2               DORET:
0015C9  2  4C E5 10             JMP     RET0            ; ELSE RETURN A ZERO
0015CC  2               
0015CC  2               ; -----
0015CC  2               ; NEXTP
0015CC  2               ; -----
0015CC  2               
0015CC  2               ; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [ARG1];
0015CC  2               ; RETURN ZERO IF LAST; RETURN FIRST IF [ARG2]=0; ERROR IF NONE
0015CC  2               
0015CC  2               ZNEXTP:
0015CC  2  20 68 1D             JSR     PROPB
0015CF  2  A5 64                LDA     ARG2+LO         ; IF [ARG2]=0
0015D1  2  F0 12                BEQ     NXTP3           ; RETURN "FIRST" SLOT
0015D3  2               
0015D3  2               NXTP1:
0015D3  2  20 84 1D             JSR     PROPN           ; FETCH PROPERTY #
0015D6  2  C5 64                CMP     ARG2+LO         ; COMPARE TO TARGET #
0015D8  2  F0 08                BEQ     NXTP2           ; FOUND IT!
0015DA  2  90 ED                BCC     DORET           ; LAST PROP, SO RETURN ZERO
0015DC  2  20 91 1D             JSR     PROPNX          ; ELSE TRY NEXT PROPERTY
0015DF  2  4C D3 15             JMP     NXTP1
0015E2  2               
0015E2  2               NXTP2:
0015E2  2  20 91 1D             JSR     PROPNX          ; POINT TO FOLLOWING PROPERTY
0015E5  2               
0015E5  2               NXTP3:
0015E5  2  20 84 1D             JSR     PROPN           ; GET THE PROPERTY #
0015E8  2  4C E7 10             JMP     PUTBYT          ; AND RETURN IT
0015EB  2               
0015EB  2               ; ---
0015EB  2               ; ADD
0015EB  2               ; ---
0015EB  2               
0015EB  2               ; RETURN [ARG1] + [ARG2]
0015EB  2               
0015EB  2               ZADD:
0015EB  2  A5 62                LDA     ARG1+LO         ; ADD LSBS
0015ED  2  18                   CLC
0015EE  2  65 64                ADC     ARG2+LO
0015F0  2  AA                   TAX                     ; SAVE LSB HERE
0015F1  2  A5 63                LDA     ARG1+HI         ; ADD MSBS
0015F3  2  65 65                ADC     ARG2+HI
0015F5  2  4C 24 14             JMP     VEXIT
0015F8  2               
0015F8  2               ; ---
0015F8  2               ; SUB
0015F8  2               ; ---
0015F8  2               
0015F8  2               ; RETURN [ARG1] - [ARG2]
0015F8  2               
0015F8  2               ZSUB:
0015F8  2  A5 62                LDA     ARG1+LO         ; SUBTRACT LSBS
0015FA  2  38                   SEC
0015FB  2  E5 64                SBC     ARG2+LO
0015FD  2  AA                   TAX                     ; SAVE LSB HERE
0015FE  2  A5 63                LDA     ARG1+HI         ; SUBTRACT MSBS
001600  2  E5 65                SBC     ARG2+HI
001602  2  4C 24 14             JMP     VEXIT           ; EXIT WITH [X]=LSB, [A]=MSB
001605  2               
001605  2               ; ---
001605  2               ; MUL
001605  2               ; ---
001605  2               
001605  2               ; RETURN [ARG1] * [ARG2]
001605  2               
001605  2               ZMUL:
001605  2  20 BF 16             JSR     MINIT           ; INIT THINGS
001608  2               
001608  2               ZMLOOP:
001608  2  66 B8                ROR     MTEMP+HI
00160A  2  66 B7                ROR     MTEMP+LO
00160C  2  66 65                ROR     ARG2+HI
00160E  2  66 64                ROR     ARG2+LO
001610  2  90 0D                BCC     ZMNEXT
001612  2               
001612  2  A5 62                LDA     ARG1+LO
001614  2  18                   CLC
001615  2  65 B7                ADC     MTEMP+LO
001617  2  85 B7                STA     MTEMP+LO
001619  2  A5 63                LDA     ARG1+HI
00161B  2  65 B8                ADC     MTEMP+HI
00161D  2  85 B8                STA     MTEMP+HI
00161F  2               
00161F  2               ZMNEXT:
00161F  2  CA                   DEX
001620  2  10 E6                BPL     ZMLOOP
001622  2               
001622  2  A6 64                LDX     ARG2+LO         ; PUT LSB OF PRODUCT
001624  2  A5 65                LDA     ARG2+HI         ; AND MSB
001626  2  4C 24 14             JMP     VEXIT           ; WHERE "VEXIT" EXPECTS THEM
001629  2               
001629  2               ; ---
001629  2               ; DIV
001629  2               ; ---
001629  2               
001629  2               ; RETURN QUOTIENT OF [ARG1] / [ARG2]
001629  2               
001629  2               ZDIV:
001629  2  20 3D 16             JSR     DIVIDE
00162C  2  A6 B3                LDX     QUOT+LO
00162E  2  A5 B4                LDA     QUOT+HI
001630  2  4C 24 14             JMP     VEXIT
001633  2               
001633  2               ; ---
001633  2               ; MOD
001633  2               ; ---
001633  2               
001633  2               ; RETURN REMAINDER OF [ARG1] / [ARG2]
001633  2               
001633  2               ZMOD:
001633  2  20 3D 16             JSR     DIVIDE
001636  2  A6 B5                LDX     REMAIN+LO       ; FETCH THE REMAINDER
001638  2  A5 B6                LDA     REMAIN+HI       ; IN [REMAIN]
00163A  2  4C 24 14             JMP     VEXIT           ; AND RETURN IT
00163D  2               
00163D  2               ; ---------------
00163D  2               ; SIGNED DIVISION
00163D  2               ; ---------------
00163D  2               
00163D  2               ; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
00163D  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
00163D  2               
00163D  2               DIVIDE:
00163D  2  A5 63                LDA     ARG1+HI         ; SIGN OF REMAINDER
00163F  2  85 BA                STA     RSIGN           ; IS THE SIGN OF THE DIVIDEND
001641  2  45 65                EOR     ARG2+HI         ; SIGN OF QUOTIENT IS POSITIVE
001643  2  85 B9                STA     QSIGN           ; IF SIGNS OF TERMS ARE THE SAME
001645  2               
001645  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
001647  2  85 B3                STA     QUOT+LO
001649  2  A5 63                LDA     ARG1+HI
00164B  2  85 B4                STA     QUOT+HI         ; IF DIVIDEND IS POSITIVE
00164D  2  10 03                BPL     ABSDIV          ; MOVE DIVISOR
00164F  2  20 7B 16             JSR     ABQUOT          ; ELSE CALC ABS(DIVIDEND) FIRST
001652  2               
001652  2               ABSDIV:
001652  2  A5 64                LDA     ARG2+LO
001654  2  85 B5                STA     REMAIN+LO
001656  2  A5 65                LDA     ARG2+HI
001658  2  85 B6                STA     REMAIN+HI       ; IF REMAINDER IS POSITIVE
00165A  2  10 03                BPL     GODIV           ; WE'RE READY TO DIVIDE
00165C  2  20 6D 16             JSR     ABREM           ; ELSE CALC ABS(DIVISOR)
00165F  2               
00165F  2               GODIV:
00165F  2  20 89 16             JSR     UDIV            ; DO UNSIGNED DIVIDE
001662  2               
001662  2  A5 B9                LDA     QSIGN           ; SHOULD QUOTIENT BE FLIPPED?
001664  2  10 03                BPL     RFLIP           ; NO, TEST REMAINDER
001666  2  20 7B 16             JSR     ABQUOT          ; ELSE GET ABSOLUTE VALUE
001669  2               
001669  2               RFLIP:
001669  2  A5 BA                LDA     RSIGN           ; SHOULD EMAINDER BE FLIPPED?
00166B  2  10 0D                BPL     DIVEX           ; NO, WE'RE DONE
00166D  2               
00166D  2               ; ELSE FALL THROUGH ...
00166D  2               
00166D  2               ; ----------------
00166D  2               ; CALC ABS(REMAIN)
00166D  2               ; ----------------
00166D  2               
00166D  2               ABREM:
00166D  2  A9 00                LDA     #0
00166F  2  38                   SEC
001670  2  E5 B5                SBC     REMAIN+LO
001672  2  85 B5                STA     REMAIN+LO
001674  2  A9 00                LDA     #0
001676  2  E5 B6                SBC     REMAIN+HI
001678  2  85 B6                STA     REMAIN+HI
00167A  2               
00167A  2               DIVEX:
00167A  2  60                   RTS
00167B  2               
00167B  2               ; --------------
00167B  2               ; CALC ABS(QUOT)
00167B  2               ; --------------
00167B  2               
00167B  2               ABQUOT:
00167B  2  A9 00                LDA     #0
00167D  2  38                   SEC
00167E  2  E5 B3                SBC     QUOT+LO
001680  2  85 B3                STA     QUOT+LO
001682  2  A9 00                LDA     #0
001684  2  E5 B4                SBC     QUOT+HI
001686  2  85 B4                STA     QUOT+HI
001688  2  60                   RTS
001689  2               
001689  2               ; -----------------
001689  2               ; UNSIGNED DIVISION
001689  2               ; -----------------
001689  2               
001689  2               ; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
001689  2               ; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
001689  2               
001689  2               UDIV:
001689  2  A5 B5                LDA     REMAIN+LO       ; CHECK [REMAIN]
00168B  2  05 B6                ORA     REMAIN+HI       ; BEFORE PROCEEDING
00168D  2  F0 2B                BEQ     DIVERR          ; CAN'T DIVIDE BY ZERO!
00168F  2               
00168F  2  20 BF 16             JSR     MINIT           ; SET IT ALL UP
001692  2               
001692  2               UDLOOP:
001692  2  26 B3                ROL     QUOT+LO
001694  2  26 B4                ROL     QUOT+HI
001696  2  26 B7                ROL     MTEMP+LO
001698  2  26 B8                ROL     MTEMP+HI
00169A  2               
00169A  2  A5 B7                LDA     MTEMP+LO
00169C  2  38                   SEC
00169D  2  E5 B5                SBC     REMAIN+LO
00169F  2  A8                   TAY                     ; SAVE HERE
0016A0  2  A5 B8                LDA     MTEMP+HI
0016A2  2  E5 B6                SBC     REMAIN+HI
0016A4  2  90 04                BCC     UDNEXT
0016A6  2  84 B7                STY     MTEMP+LO
0016A8  2  85 B8                STA     MTEMP+HI
0016AA  2               
0016AA  2               UDNEXT:
0016AA  2  CA                   DEX
0016AB  2  D0 E5                BNE     UDLOOP
0016AD  2               
0016AD  2  26 B3                ROL     QUOT+LO         ; SHIFT LAST CARRY FOR QUOTIENT
0016AF  2  26 B4                ROL     QUOT+HI
0016B1  2               
0016B1  2  A5 B7                LDA     MTEMP+LO        ; MOVE REMAINDER
0016B3  2  85 B5                STA     REMAIN+LO       ; INTO [REMAIN]
0016B5  2  A5 B8                LDA     MTEMP+HI
0016B7  2  85 B6                STA     REMAIN+HI
0016B9  2  60                   RTS
0016BA  2               
0016BA  2               ; *** ERROR #8: DIVISION BY ZERO ***
0016BA  2               
0016BA  2               DIVERR:
0016BA  2  A9 08                LDA     #8
0016BC  2  4C EB 1D             JMP     ZERROR
0016BF  2               
0016BF  2               ; ---------
0016BF  2               ; MATH INIT
0016BF  2               ; ---------
0016BF  2               
0016BF  2               MINIT:
0016BF  2  A2 10                LDX     #16             ; INIT LOOPING INDEX
0016C1  2  A9 00                LDA     #0
0016C3  2  85 B7                STA     MTEMP+LO        ; CLEAR TEMP
0016C5  2  85 B8                STA     MTEMP+HI        ; REGISTER
0016C7  2  18                   CLC                     ; AND CARRY
0016C8  2  60                   RTS
0016C9  2               
0016C9  1                       .INCLUDE "opsx.asm"
0016C9  2               ;        PAGE
0016C9  2               ;        SBTTL   "--- X-OPS ---"
0016C9  2               
0016C9  2               ; ------
0016C9  2               ; EQUAL?
0016C9  2               ; ------
0016C9  2               
0016C9  2               ; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
0016C9  2               
0016C9  2               ZEQUAL:
0016C9  2  C6 61                DEC     NARGS           ; DOUBLE-CHECK # ARGS
0016CB  2  D0 05                BNE     DOEQ            ; MUST BE AT LEAST TWO, OR ...
0016CD  2               
0016CD  2               ; *** ERROR #9: NOT ENOUGH "EQUAL?" ARGS ***
0016CD  2               
0016CD  2  A9 09                LDA     #9
0016CF  2  4C EB 1D             JMP     ZERROR
0016D2  2               
0016D2  2               DOEQ:
0016D2  2  A5 62                LDA     ARG1+LO         ; FETCH LSB
0016D4  2  A6 63                LDX     ARG1+HI         ; AND MSB OF [ARG1]
0016D6  2               
0016D6  2  C5 64                CMP     ARG2+LO         ; TEST LSB OF [ARG2]
0016D8  2  D0 04                BNE     TRY2            ; NO GOOD, LOOK FOR ANOTHER ARG
0016DA  2  E4 65                CPX     ARG2+HI         ; ELSE TRY MSB OF [ARG2]
0016DC  2  F0 18                BEQ     EQOK            ; MATCHED!
0016DE  2               
0016DE  2               TRY2:
0016DE  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016E0  2  F0 17                BEQ     EQBAD           ; YES, WE FAILED
0016E2  2               
0016E2  2  C5 66                CMP     ARG3+LO         ; TRY LSB OF [ARG3]
0016E4  2  D0 04                BNE     TRY3            ; NO GOOD, LOOK FOR ANOTHER ARG
0016E6  2  E4 67                CPX     ARG3+HI         ; HOW ABOUT MSB OF [ARG3]?
0016E8  2  F0 0C                BEQ     EQOK            ; YAY!
0016EA  2               
0016EA  2               TRY3:
0016EA  2  C6 61                DEC     NARGS           ; OUT OF ARGS YET?
0016EC  2  F0 0B                BEQ     EQBAD           ; IF NOT ...
0016EE  2               
0016EE  2  C5 68                CMP     ARG4+LO         ; TRY [ARG4]
0016F0  2  D0 07                BNE     EQBAD           ; SORRY, CHUM
0016F2  2  E4 69                CPX     ARG4+HI         ; MSB MATCHED?
0016F4  2  D0 03                BNE     EQBAD           ; TOO BAD
0016F6  2               
0016F6  2               EQOK:
0016F6  2  4C 35 11             JMP     PREDS           ; FINALLY MATCHED!
0016F9  2               
0016F9  2               EQBAD:
0016F9  2  4C 29 11             JMP     PREDF           ; FAILURE (SNIFF!)
0016FC  2               
0016FC  2               ; ----
0016FC  2               ; CALL
0016FC  2               ; ----
0016FC  2               
0016FC  2               ; BRANCH TO FUNCTION AT ([ARG1]*2), PASSING
0016FC  2               ; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
0016FC  2               
0016FC  2               ZCALL:
0016FC  2  A5 62                LDA     ARG1+LO
0016FE  2  05 63                ORA     ARG1+HI         ; IS CALL ADDRESS ZERO?
001700  2  D0 03                BNE     DOCALL          ; NO, CONTINUE
001702  2               
001702  2  4C E7 10             JMP     PUTBYT          ; ELSE RETURN THE ZERO IN [A]
001705  2               
001705  2               DOCALL:
001705  2  A6 75                LDX     OLDZSP          ; SAVE OLD STACK POINTER
001707  2  A5 76                LDA     ZPCL            ; AND LSB OF [ZPC]
001709  2  20 C9 10             JSR     PUSHXA          ; ON THE Z-STACK
00170C  2               
00170C  2  A6 77                LDX     ZPCM            ; SAVE MIDDLE 8 BITS
00170E  2  A5 78                LDA     ZPCH            ; AND TOP BIT OF [ZPC]
001710  2  20 C9 10             JSR     PUSHXA          ; AS WELL
001713  2               
001713  2               ; FORM 16-BIT ADDRESS FROM [ARG1]
001713  2               
001713  2  A9 00                LDA     #0              ; CLEAR HIGH BIT FOR ROTATE
001715  2  85 79                STA     ZPCFLG          ; AND INVALIDATE [ZPC]
001717  2               
001717  2  06 62                ASL     ARG1+LO         ; MULTIPLY [ARG1]
001719  2  26 63                ROL     ARG1+HI         ; BY TWO
00171B  2  2A                   ROL     A               ; HIGH BIT INTO [A]
00171C  2  85 78                STA     ZPCH            ; NEW HIGH BIT OF [ZPC]
00171E  2               
00171E  2  A5 63                LDA     ARG1+HI         ; GET NEW LOW BYTES
001720  2  85 77                STA     ZPCM
001722  2  A5 62                LDA     ARG1+LO
001724  2  85 76                STA     ZPCL
001726  2               
001726  2  20 E3 19             JSR     NEXTPC          ; FETCH # LOCALS TO PASS
001729  2  85 70                STA     J+LO            ; SAVE HERE FOR COUNTING
00172B  2  85 71                STA     J+HI            ; AND HERE FOR LATER REFERENCE
00172D  2  F0 2B                BEQ     ZCALL2          ; SKIP IF NO LOCALS
00172F  2               
00172F  2  A9 00                LDA     #0
001731  2  85 6E                STA     I+LO            ; ELSE INIT STORAGE INDEX
001733  2               
001733  2               ZCALL1:
001733  2  A4 6E                LDY     I+LO
001735  2  BE 00 0D             LDX     LOCALS+LO,Y     ; GET LSB OF LOCAL INTO [X]
001738  2  B9 01 0D             LDA     LOCALS+HI,Y     ; AND MSB INTO [A]
00173B  2  84 6E                STY     I+LO            ; SAVE THE INDEX
00173D  2  20 C9 10             JSR     PUSHXA          ; PUSH LOCAL IN [X/A] ONTO Z-STACK
001740  2               
001740  2  20 E3 19             JSR     NEXTPC          ; GET MSB OF NEW LOCAL
001743  2  85 6F                STA     I+HI            ; SAVE IT HERE
001745  2  20 E3 19             JSR     NEXTPC          ; NOW GET LSB
001748  2               
001748  2  A4 6E                LDY     I+LO            ; RESTORE INDEX
00174A  2  99 00 0D             STA     LOCALS+LO,Y     ; STORE LSB INTO [LOCALS]
00174D  2  A5 6F                LDA     I+HI            ; RETRIEVE MSB
00174F  2  99 01 0D             STA     LOCALS+HI,Y     ; STORE IT INTO [LOCALS]
001752  2               
001752  2  C8                   INY
001753  2  C8                   INY                     ; UPDATE
001754  2  84 6E                STY     I+LO            ; THE STORAGE INDEX
001756  2               
001756  2  C6 70                DEC     J+LO            ; ANY MORE LOCALS?
001758  2  D0 D9                BNE     ZCALL1          ; YES, KEEP LOOPING
00175A  2               
00175A  2               ; MOVE UP TO 3 ARGUMENTS TO [LOCALS]
00175A  2               
00175A  2               ZCALL2:
00175A  2  C6 61                DEC     NARGS           ; EXTRA ARGS IN THIS CALL?
00175C  2  F0 26                BEQ     ZCALL3          ; NO, CONTINUE
00175E  2               
00175E  2  A5 64                LDA     ARG2+LO         ; MOVE [ARG2] TO LOCAL #1
001760  2  8D 00 0D             STA     LOCALS+LO
001763  2  A5 65                LDA     ARG2+HI
001765  2  8D 01 0D             STA     LOCALS+HI
001768  2               
001768  2  C6 61                DEC     NARGS           ; ANY LEFT?
00176A  2  F0 18                BEQ     ZCALL3          ; NO, SCRAM
00176C  2               
00176C  2  A5 66                LDA     ARG3+LO         ; MOVE [ARG3] TO LOCAL #2
00176E  2  8D 02 0D             STA     LOCALS+LO+2
001771  2  A5 67                LDA     ARG3+HI
001773  2  8D 03 0D             STA     LOCALS+HI+2
001776  2               
001776  2  C6 61                DEC     NARGS           ; ANY LEFT?
001778  2  F0 0A                BEQ     ZCALL3          ; NO, EXUENT
00177A  2               
00177A  2  A5 68                LDA     ARG4+LO         ; MOVE [ARG4] TO LOCAL #3
00177C  2  8D 04 0D             STA     LOCALS+LO+4
00177F  2  A5 69                LDA     ARG4+HI
001781  2  8D 05 0D             STA     LOCALS+HI+4
001784  2               
001784  2               ZCALL3:
001784  2  A6 71                LDX     J+HI            ; RETRIEVE # LOCALS
001786  2  8A                   TXA                     ; DUPE INTO [A]
001787  2  49 FF                EOR     #$FF            ; COMPLEMENT FOR ERROR CHECK (BM 11/24/84)
001789  2  20 C9 10             JSR     PUSHXA          ; PUSH # LOCALS ONTO Z-STACK
00178C  2               
00178C  2  A5 74                LDA     ZSP             ; REMEMBER WHERE
00178E  2  85 75                STA     OLDZSP          ; WE CAME FROM
001790  2               
001790  2  60                   RTS                     ; WHEW!
001791  2               
001791  2               ; ---
001791  2               ; PUT
001791  2               ; ---
001791  2               
001791  2               ; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
001791  2               
001791  2               ZPUT:
001791  2  06 64                ASL     ARG2+LO         ; WORD-ALIGN [ARG2]
001793  2  26 65                ROL     ARG2+HI
001795  2               
001795  2  20 A7 17             JSR     PCALC           ; GET ITEM ADDR INTO [I]
001798  2  A5 67                LDA     ARG3+HI         ; STORE MSB OF [ARG3]
00179A  2  91 6E                STA     (I),Y           ; INTO MSB OF TABLE POSITION
00179C  2  C8                   INY                     ; POINT TO LSB
00179D  2  D0 03                BNE     PUTLSB          ; BRANCH ALWAYS
00179F  2               
00179F  2               ; ----
00179F  2               ; PUTB
00179F  2               ; ----
00179F  2               
00179F  2               ; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
00179F  2               
00179F  2               ZPUTB:
00179F  2  20 A7 17             JSR     PCALC
0017A2  2               
0017A2  2               ; ENTRY FOR "PUT"
0017A2  2               
0017A2  2               PUTLSB:
0017A2  2  A5 66                LDA     ARG3+LO         ; GET LSB OF [ARG3]
0017A4  2  91 6E                STA     (I),Y           ; STORE IN TABLE AT [Y]
0017A6  2  60                   RTS
0017A7  2               
0017A7  2               ; ---------------------------
0017A7  2               ; CALC ITEM ADDRESS FOR "PUT"
0017A7  2               ; ---------------------------
0017A7  2               
0017A7  2               PCALC:
0017A7  2  A5 64                LDA     ARG2+LO         ; ADD ITEM OFFSET IN [ARG2]
0017A9  2  18                   CLC                     ; TO TABLE ADDR IN [ARG1]
0017AA  2  65 62                ADC     ARG1+LO         ; TO FORM A POINTER
0017AC  2  85 6E                STA     I+LO            ; IN [I]
0017AE  2               
0017AE  2  A5 65                LDA     ARG2+HI         ; SAME FOR MSB
0017B0  2  65 63                ADC     ARG1+HI
0017B2  2  18                   CLC
0017B3  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
0017B5  2  85 6F                STA     I+HI
0017B7  2               
0017B7  2  A0 00                LDY     #0              ; ZERO FOR INDEXING
0017B9  2  60                   RTS
0017BA  2               
0017BA  2               ; ----
0017BA  2               ; PUTP
0017BA  2               ; ----
0017BA  2               
0017BA  2               ; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
0017BA  2               
0017BA  2               ZPUTP:
0017BA  2  20 68 1D             JSR     PROPB
0017BD  2               
0017BD  2               PUTP1:
0017BD  2  20 84 1D             JSR     PROPN
0017C0  2  C5 64                CMP     ARG2+LO
0017C2  2  F0 08                BEQ     PUTP2
0017C4  2  90 1B                BCC     PNERR           ; ERROR IF LOWER
0017C6  2               
0017C6  2  20 91 1D             JSR     PROPNX          ; TRY NEXT PROPERTY
0017C9  2  4C BD 17             JMP     PUTP1
0017CC  2               
0017CC  2               PUTP2:
0017CC  2  20 89 1D             JSR     PROPL
0017CF  2  C8                   INY                     ; MAKE [Y] POINT TO 1ST PROPERTY BYTE
0017D0  2  AA                   TAX                     ; (SET FLAGS) IF LENGTH IN [A] = 0
0017D1  2  F0 09                BEQ     PUTP3           ; PUT A BYTE
0017D3  2  C9 01                CMP     #1              ; PUT A WORD IF [A] = 1
0017D5  2  D0 0F                BNE     PLERR           ; ELSE LENGTH IS BAD
0017D7  2               
0017D7  2  A5 67                LDA     ARG3+HI         ; GET MSB OF PROPERTY
0017D9  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017DB  2  C8                   INY                     ; POINT TO LSB SLOT
0017DC  2               
0017DC  2               PUTP3:
0017DC  2  A5 66                LDA     ARG3+LO         ; FETCH LSB
0017DE  2  91 6E                STA     (I),Y           ; AND STORE IN OBJECT
0017E0  2  60                   RTS
0017E1  2               
0017E1  2               ; *** ERROR #10: BAD PROPERTY NUMBER ***
0017E1  2               
0017E1  2               PNERR:
0017E1  2  A9 0A                LDA     #10
0017E3  2  4C EB 1D             JMP     ZERROR
0017E6  2               
0017E6  2               ; *** ERROR #11: PUTP PROPERTY LENGTH ***
0017E6  2               
0017E6  2               PLERR:
0017E6  2  A9 0B                LDA     #11
0017E8  2  4C EB 1D             JMP     ZERROR
0017EB  2               
0017EB  2               ; ------
0017EB  2               ; PRINTC
0017EB  2               ; ------
0017EB  2               
0017EB  2               ; PRINT CHAR WITH ASCII VALUE IN [ARG1]
0017EB  2               
0017EB  2               ZPRC:
0017EB  2  A5 62                LDA     ARG1+LO         ; GRAB THE CHAR
0017ED  2  4C CC 1E             JMP     COUT            ; AND SHIP IT OUT
0017F0  2               
0017F0  2               ; ------
0017F0  2               ; PRINTN
0017F0  2               ; ------
0017F0  2               
0017F0  2               ; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
0017F0  2               
0017F0  2               ZPRN:
0017F0  2  A5 62                LDA     ARG1+LO         ; MOVE [ARG1] TO [QUOT]
0017F2  2  85 B3                STA     QUOT+LO
0017F4  2  A5 63                LDA     ARG1+HI
0017F6  2  85 B4                STA     QUOT+HI
0017F8  2               
0017F8  2               ; PRINT [QUOT]
0017F8  2               
0017F8  2               NUMBER:
0017F8  2  A5 B4                LDA     QUOT+HI         ; IF VALUE IS POSITIVE
0017FA  2  10 08                BPL     DIGCNT          ; CONTINUE
0017FC  2               
0017FC  2  A9 2D                LDA     #$2D            ; ELSE START WITH A MINUS SIGN
0017FE  2  20 CC 1E             JSR     COUT
001801  2               
001801  2  20 7B 16             JSR     ABQUOT          ; AND CALC ABS([QUOT])
001804  2               
001804  2               ; COUNT # OF DECIMAL DIGITS
001804  2               
001804  2               DIGCNT:
001804  2  A9 00                LDA     #0              ; RESET
001806  2  85 BB                STA     DIGITS          ; DIGIT INDEX
001808  2               
001808  2               DGC:
001808  2  A5 B3                LDA     QUOT+LO         ; IS QUOTIENT
00180A  2  05 B4                ORA     QUOT+HI         ; ZERO YET?
00180C  2  F0 12                BEQ     PRNTN3          ; YES, READY TO PRINT
00180E  2               
00180E  2  A9 0A                LDA     #10             ; ELSE DIVIDE [QUOT]
001810  2  85 B5                STA     REMAIN+LO       ; BY 10 (LSB)
001812  2  A9 00                LDA     #0
001814  2  85 B6                STA     REMAIN+HI       ; 10 (MSB)
001816  2               
001816  2  20 89 16             JSR     UDIV            ; UNSIGNED DIVIDE
001819  2               
001819  2  A5 B5                LDA     REMAIN+LO       ; FETCH LSB OF REMAINDER (THE DIGIT)
00181B  2  48                   PHA                     ; SAVE IT ON STACK
00181C  2  E6 BB                INC     DIGITS          ; UPDATE DIGIT COUNT
00181E  2  D0 E8                BNE     DGC             ; LOOP TILL QUOTIENT=0
001820  2               
001820  2               PRNTN3:
001820  2  A5 BB                LDA     DIGITS          ; IF DIGIT COUNT IS NZ
001822  2  D0 05                BNE     PRNTN4          ; CONTINUE
001824  2               
001824  2  A9 30                LDA     #'0'            ; ELSE PRINT "0"
001826  2  4C CC 1E             JMP     COUT            ; AND RETURN
001829  2               
001829  2               PRNTN4:
001829  2  68                   PLA                     ; PULL A DIGIT OFF THE STACK
00182A  2  18                   CLC
00182B  2  69 30                ADC     #'0'            ; CONVERT TO ASCII
00182D  2  20 CC 1E             JSR     COUT            ; AND PRINT IT
001830  2  C6 BB                DEC     DIGITS          ; OUT OF DIGITS YET?
001832  2  D0 F5                BNE     PRNTN4          ; NO, KEEP LOOPING
001834  2  60                   RTS
001835  2               
001835  2               ; ------
001835  2               ; RANDOM
001835  2               ; ------
001835  2               
001835  2               ; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
001835  2               
001835  2               ZRAND:
001835  2  A5 62                LDA     ARG1+LO         ; MAKE [ARG1] THE DIVISOR
001837  2  85 64                STA     ARG2+LO
001839  2  A5 63                LDA     ARG1+HI
00183B  2  85 65                STA     ARG2+HI
00183D  2               
00183D  2  20 58 1E             JSR     RANDOM          ; GET RANDOM BYTES INTO [A] AND [X]
001840  2  86 62                STX     ARG1+LO         ; MAKE THEM THE DIVIDEND
001842  2  29 7F                AND     #$7F            ; MAKE SURE MSB IS POSITIVE
001844  2  85 63                STA     ARG1+HI
001846  2               
001846  2  20 3D 16             JSR     DIVIDE          ; SIGNED DIVIDE, [ARG1] / [ARG2]
001849  2               
001849  2  A5 B5                LDA     REMAIN+LO       ; MOVE REMAINDER
00184B  2  85 6C                STA     VALUE+LO        ; INTO [VALUE]
00184D  2  A5 B6                LDA     REMAIN+HI
00184F  2  85 6D                STA     VALUE+HI
001851  2               
001851  2  20 B5 11             JSR     INCVAL          ; INCREMENT [VALUE]
001854  2  4C ED 10             JMP     PUTVAL          ; AND RETURN RESULT
001857  2               
001857  2               ; ----
001857  2               ; PUSH
001857  2               ; ----
001857  2               
001857  2               ; PUSH [ARG1] ONTO THE Z-STACK
001857  2               
001857  2               ZPUSH:
001857  2  A6 62                LDX     ARG1+LO
001859  2  A5 63                LDA     ARG1+HI
00185B  2  4C C9 10             JMP     PUSHXA
00185E  2               
00185E  2               ; ---
00185E  2               ; POP
00185E  2               ; ---
00185E  2               
00185E  2               ; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
00185E  2               
00185E  2               ZPOP:
00185E  2  20 AF 10             JSR     POPVAL          ; VALUE INTO [VALUE]
001861  2  A5 62                LDA     ARG1+LO         ; GET VARIABLE ID
001863  2  4C DC 10             JMP     VARPUT          ; AND CHANGE THE VARIABLE
001866  2               
001866  1                       .INCLUDE "read.asm"
001866  2               ;        PAGE
001866  2               ;        SBTTL   "--- READ HANDLER ---"
001866  2               
001866  2               ; ----
001866  2               ; READ
001866  2               ; ----
001866  2               
001866  2               ; READ LINE INTO TABLE [ARG1]; PARSE INTO TABLE [ARG2]
001866  2               
001866  2               ZREAD:
001866  2  20 7C 1F             JSR     ZUSL            ; UPDATE THE STATUS LINE
001869  2               
001869  2  A5 63                LDA     ARG1+HI         ; MAKE THE TABLE ADDRESSES
00186B  2  18                   CLC                     ; ABSOLUTE
00186C  2  65 83                ADC     ZCODE           ; LSBS NEED NOT CHANGE
00186E  2  85 63                STA     ARG1+HI
001870  2               
001870  2  A5 65                LDA     ARG2+HI
001872  2  18                   CLC
001873  2  65 83                ADC     ZCODE
001875  2  85 65                STA     ARG2+HI
001877  2               
001877  2  20 23 21             JSR     INPUT           ; READ LINE; RETURN LENGTH IN [A]
00187A  2  85 A2                STA     LINLEN          ; SAVE # CHARS IN LINE
00187C  2               
00187C  2  A9 00                LDA     #0
00187E  2  85 A3                STA     WRDLEN          ; INIT # CHARS IN WORD COUNTER
001880  2               
001880  2  A0 01                LDY     #1              ; POINT TO "# WORDS READ" SLOT
001882  2  91 64                STA     (ARG2),Y        ; AND CLEAR IT ([A] = 0)
001884  2               
001884  2  84 A0                STY     SOURCE          ; INIT SOURCE TABLE PNTR ([Y] = 1)
001886  2  C8                   INY                     ; = 2
001887  2  84 A1                STY     RESULT          ; AND RESULT TABLE POINTER
001889  2               
001889  2               ; MAIN LOOP STARTS HERE
001889  2               
001889  2               READL:
001889  2  A0 00                LDY     #0              ; POINT TO "MAX WORDS" SLOT
00188B  2  B1 64                LDA     (ARG2),Y        ; AND READ IT
00188D  2  F0 04                BEQ     RLERR           ; PATCH IF ZERO
00188F  2  C9 3C                CMP     #60             ; OKAY IF < 60
001891  2  90 04                BCC     RL0
001893  2               
001893  2               RLERR:
001893  2  A9 3B                LDA     #59             ; MAXIMUM VALUE IS 59 (BM 5/14/85)
001895  2  91 64                STA     (ARG2),Y
001897  2               
001897  2               RL0:
001897  2  C8                   INY                     ; POINT TO "# WORDS READ" SLOT
001898  2  D1 64                CMP     (ARG2),Y        ; TOO MANY WORDS?
00189A  2  90 06                BCC     RLEX            ; EXIT IF SO (BM 5/1/85)
00189C  2               
00189C  2               RL1:
00189C  2  A5 A2                LDA     LINLEN
00189E  2  05 A3                ORA     WRDLEN          ; OUT OF CHARS AND WORDS?
0018A0  2  D0 01                BNE     RL2             ; NOT YET
0018A2  2               RLEX:
0018A2  2  60                   RTS                     ; ELSE EXIT
0018A3  2               
0018A3  2               RL2:
0018A3  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH
0018A5  2  C9 06                CMP     #6              ; 6 CHARS DONE?
0018A7  2  90 03                BCC     RL3             ; NO, KEEP GOING
0018A9  2  20 3A 19             JSR     FLUSHW          ; ELSE FLUSH REMAINDER OF WORD
0018AC  2               
0018AC  2               RL3:
0018AC  2  A5 A3                LDA     WRDLEN          ; GET WORD LENGTH AGAIN
0018AE  2  D0 24                BNE     READL2          ; CONTINUE IF NOT FIRST CHAR
0018B0  2               
0018B0  2               ; START A NEW WORD
0018B0  2               
0018B0  2  A2 05                LDX     #5              ; CLEAR Z-WORD INPUT BUFFER
0018B2  2               RLL:
0018B2  2  95 94                STA     IN,X            ; [A] = 0
0018B4  2  CA                   DEX
0018B5  2  10 FB                BPL     RLL
0018B7  2               
0018B7  2  20 2C 19             JSR     EFIND           ; GET BASE ADDRESS INTO [ENTRY]
0018BA  2  A5 A0                LDA     SOURCE          ; STORE THE START POS OF THE WORD
0018BC  2  A0 03                LDY     #3              ; INTO THE "WORD START" SLOT
0018BE  2  91 A4                STA     (ENTRY),Y       ; OF THE RESULT TABLE
0018C0  2               
0018C0  2  A8                   TAY
0018C1  2  B1 62                LDA     (ARG1),Y        ; GET A CHAR FROM SOURCE BUFFER
0018C3  2  20 67 19             JSR     SIB             ; IS IT A SELF-INSERTING BREAK?
0018C6  2  B0 26                BCS     DOSIB           ; YES IF CARRY WAS SET
0018C8  2               
0018C8  2  20 55 19             JSR     NORM            ; IS IT A "NORMAL" BREAK?
0018CB  2  90 07                BCC     READL2          ; NO, CONTINUE
0018CD  2               
0018CD  2  E6 A0                INC     SOURCE          ; ELSE FLUSH THE STRANDED BREAK
0018CF  2  C6 A2                DEC     LINLEN          ; UPDATE # CHARS LEFT IN LINE
0018D1  2  4C 89 18             JMP     READL           ; AND LOOP
0018D4  2               
0018D4  2               READL2:
0018D4  2  A5 A2                LDA     LINLEN          ; OUT OF CHARS YET?
0018D6  2  F0 1E                BEQ     READL3          ; LOOKS THAT WAY
0018D8  2               
0018D8  2  A4 A0                LDY     SOURCE
0018DA  2  B1 62                LDA     (ARG1),Y        ; ELSE GRAB NEXT CHAR
0018DC  2  20 50 19             JSR     BREAK           ; IS IT A BREAK?
0018DF  2  B0 15                BCS     READL3          ; YES IF CARRY WAS SET
0018E1  2               
0018E1  2  A6 A3                LDX     WRDLEN          ; ELSE STORE THE CHAR
0018E3  2  95 94                STA     IN,X            ; INTO THE INPUT BUFFER
0018E5  2               
0018E5  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018E7  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD
0018E9  2  E6 A0                INC     SOURCE          ; POINT TO NEXT CHAR IN SOURCE
0018EB  2  4C 89 18             JMP     READL           ; AND LOOP BACK
0018EE  2               
0018EE  2               DOSIB:
0018EE  2  85 94                STA     IN              ; PUT THE BREAK INTO 1ST WORD SLOT
0018F0  2  C6 A2                DEC     LINLEN          ; ONE LESS CHAR IN LINE
0018F2  2  E6 A3                INC     WRDLEN          ; ONE MORE IN WORD BUFFER
0018F4  2  E6 A0                INC     SOURCE          ; POINT TO NEXT SOURCE CHAR
0018F6  2               
0018F6  2               READL3:
0018F6  2  A5 A3                LDA     WRDLEN          ; ANY CHARS IN WORD YET?
0018F8  2  F0 8F                BEQ     READL           ; APPARENTLY NOT, SO LOOP BACK
0018FA  2               
0018FA  2  20 2C 19             JSR     EFIND           ; GET ENTRY ADDR INTO [ENTRY]
0018FD  2  A5 A3                LDA     WRDLEN          ; GET ACTUAL LNGTH OF WORD
0018FF  2  A0 02                LDY     #2              ; STORE IT IN "WORD LENGTH" SLOT
001901  2  91 A4                STA     (ENTRY),Y       ; OF THE CURRENT ENTRY
001903  2               
001903  2  20 50 1C             JSR     CONZST          ; CONVERT ASCII IN [IN] TO Z-STRING
001906  2  20 79 19             JSR     FINDW           ; AND LOOK IT UP IN VOCABULARY
001909  2               
001909  2  A0 01                LDY     #1
00190B  2  B1 64                LDA     (ARG2),Y        ; FETCH THE # WORDS READ
00190D  2  18                   CLC
00190E  2  69 01                ADC     #1              ; INCREMENT IT
001910  2  91 64                STA     (ARG2),Y        ; AND UPDATE
001912  2               
001912  2  20 2C 19             JSR     EFIND           ; MAKE [ENTRY] POINT TO ENTRY
001915  2               
001915  2  A0 00                LDY     #0
001917  2  84 A3                STY     WRDLEN          ; CLEAR # CHARS IN WORD
001919  2  A5 6D                LDA     VALUE+HI        ; GET MSB OF VOCAB ENTRY ADDRESS
00191B  2  91 A4                STA     (ENTRY),Y       ; AND STORE IN 1ST SLOT OF ENTRY
00191D  2  C8                   INY
00191E  2  A5 6C                LDA     VALUE+LO        ; ALSO STORE LSB IN 2ND SLOT
001920  2  91 A4                STA     (ENTRY),Y
001922  2               
001922  2  A5 A1                LDA     RESULT          ; UPDATE THE
001924  2  18                   CLC                     ; RESULT TABLE POINTER
001925  2  69 04                ADC     #4              ; SO IT POINTS TO THE
001927  2  85 A1                STA     RESULT          ; NEXT ENTRY
001929  2               
001929  2  4C 89 18             JMP     READL           ; AND LOOP BACK
00192C  2               
00192C  2               ; -----------------------------------
00192C  2               ; FIND BASE ADDR OF RESULT ENTRY SLOT
00192C  2               ; -----------------------------------
00192C  2               
00192C  2               EFIND:
00192C  2  A5 64                LDA     ARG2+LO         ; LSB OF RESULT TABLE BASE
00192E  2  18                   CLC
00192F  2  65 A1                ADC     RESULT          ; AND CURRENT POINTER
001931  2  85 A4                STA     ENTRY+LO        ; SAVE IN [ENTRY]
001933  2  A5 65                LDA     ARG2+HI         ; ALSO ADD MSB
001935  2  69 00                ADC     #0
001937  2  85 A5                STA     ENTRY+HI
001939  2  60                   RTS
00193A  2               
00193A  2               ; ----------
00193A  2               ; FLUSH WORD
00193A  2               ; ----------
00193A  2               
00193A  2               FLUSHW:
00193A  2  A5 A2                LDA     LINLEN          ; ANY CHARS LEFT IN LINE?
00193C  2  F0 11                BEQ     FLEX            ; NO, SCRAM
00193E  2               
00193E  2  A4 A0                LDY     SOURCE          ; GET CURRENT CHAR POINTER
001940  2  B1 62                LDA     (ARG1),Y        ; AND GRAB A CHAR
001942  2  20 50 19             JSR     BREAK           ; IS IT A BREAK?
001945  2  B0 08                BCS     FLEX            ; EXIT IF SO
001947  2  C6 A2                DEC     LINLEN          ; ELSE UPDATE CHAR COUNT
001949  2  E6 A3                INC     WRDLEN          ; AND WORD-CHAR COUNT
00194B  2  E6 A0                INC     SOURCE          ; AND CHAR POINTER
00194D  2  D0 EB                BNE     FLUSHW          ; AND LOOP BACK (ALWAYS)
00194F  2               
00194F  2               FLEX:
00194F  2  60                   RTS
001950  2               
001950  2               ; ---------------------------------
001950  2               ; IS CHAR IN [A] ANY TYPE OF BREAK?
001950  2               ; ---------------------------------
001950  2               
001950  2               BREAK:
001950  2  20 67 19             JSR     SIB             ; CHECK FOR A SIB FIRST
001953  2  B0 22                BCS     FBRK            ; EXIT NOW IF MATCHED
001955  2               
001955  2               ; ELSE FALL THROUGH ...
001955  2               
001955  2               ; --------------------------------
001955  2               ; IS CHAR IN [A] A "NORMAL" BREAK?
001955  2               ; --------------------------------
001955  2               
001955  2               NORM:
001955  2  A2 05                LDX     #NBRKS-1        ; NUMBER OF "NORMAL" BREAKS
001957  2               NBL:
001957  2  DD 61 19             CMP     BRKTBL,X        ; MATCHED?
00195A  2  F0 1B                BEQ     FBRK            ; YES, EXIT
00195C  2  CA                   DEX
00195D  2  10 F8                BPL     NBL             ; NO, KEEP LOOKING
00195F  2  18                   CLC                     ; NO MATCH, CLEAR CARRY
001960  2  60                   RTS                     ; AND RETURN
001961  2               
001961  2               ; ------------------
001961  2               ; NORMAL BREAK CHARS
001961  2               ; ------------------
001961  2               
001961  2               BRKTBL:
001961  2  21 3F 2C 2E          .BYTE   "!?,."          ; IN ORDER OF
001965  2  0D                   .BYTE   EOL             ; ASCENDING FREQUENCY
001966  2  20                   .BYTE   SPACE           ; SPACE CHAR IS TESTED FIRST FOR SPEED
001967  2               
001967  2               NBRKS           = *-BRKTBL      ; # NORMAL BREAKS
001967  2               
001967  2               ; ---------------------
001967  2               ; IS CHAR IN [A] A SIB?
001967  2               ; ---------------------
001967  2               
001967  2               SIB:
001967  2  AA                   TAX                     ; SAVE TEST CHAR
001968  2  A0 00                LDY     #0              ; 1ST BYTE IN VOCAB TABLE
00196A  2  B1 8E                LDA     (VOCAB),Y       ; HAS # SIBS
00196C  2  A8                   TAY                     ; USE AS AN INDEX
00196D  2  8A                   TXA                     ; RESTORE TEST CHAR
00196E  2               SBL:
00196E  2  D1 8E                CMP     (VOCAB),Y       ; MATCHED?
001970  2  F0 05                BEQ     FBRK            ; YES, REPORT IT
001972  2  88                   DEY
001973  2  D0 F9                BNE     SBL             ; ELSE KEEP LOOPING
001975  2  18                   CLC                     ; NO MATCH, SO
001976  2  60                   RTS                     ; EXIT WITH CARRY CLEAR
001977  2               
001977  2               FBRK:
001977  2  38                   SEC                     ; EXIT WITH CARRY SET
001978  2  60                   RTS                     ; IF MATCHED WITH A BREAK CHAR
001979  2               
001979  2               ; -----------------
001979  2               ; VOCABULARY SEARCH
001979  2               ; -----------------
001979  2               
001979  2               ; ENTRY: 4-BYTE TARGET Z-WORD IN [OUT]
001979  2               ; EXIT: ABS ENTRY ADDRESS IN [VALUE] IF FOUND;
001979  2               ;       OTHERWISE [VALUE] = 0
001979  2               
001979  2               FINDW:
001979  2  A0 00                LDY     #0              ; GET # SIBS
00197B  2  B1 8E                LDA     (VOCAB),Y       ; IN VOCAB TABLE
00197D  2  18                   CLC                     ; INCREMENT IT
00197E  2  69 01                ADC     #1              ; FOR PROPER ALIGNMENT
001980  2  65 8E                ADC     VOCAB+LO        ; NOW ADD THE BASE ADDR OF THE TABLE
001982  2  85 6C                STA     VALUE+LO        ; TO GET THE ACTUAL BASE ADDR
001984  2  A5 8F                LDA     VOCAB+HI        ; OF THE VOCAB ENTRIES
001986  2  69 00                ADC     #0              ; WHICH IS SAVED
001988  2  85 6D                STA     VALUE+HI        ; IN [VALUE]
00198A  2               
00198A  2  B1 6C                LDA     (VALUE),Y       ; GET # BYTES PER ENTRY ([Y] = 0)
00198C  2  85 A8                STA     ESIZE           ; SAVE IT HERE
00198E  2               
00198E  2  20 B5 11             JSR     INCVAL          ; POINT TO NEXT BYTE
001991  2  B1 6C                LDA     (VALUE),Y       ; GET # ENTRIES IN TABLE (MSB)
001993  2  85 A7                STA     NENTS+HI        ; AND STUFF IT IN [NENTS]
001995  2               
001995  2  20 B5 11             JSR     INCVAL          ; NEXT BYTE
001998  2  B1 6C                LDA     (VALUE),Y       ; DON'T FORGET THE LSB!
00199A  2  85 A6                STA     NENTS+LO
00199C  2               
00199C  2  20 B5 11             JSR     INCVAL          ; [VALUE] NOW POINTS TO 1ST ENTRY
00199F  2               
00199F  2               ; BEGIN THE SEARCH!
00199F  2               
00199F  2               FWL1:
00199F  2  A0 00                LDY     #0
0019A1  2  B1 6C                LDA     (VALUE),Y       ; GET 1ST BYTE OF ENTRY
0019A3  2  C5 9A                CMP     OUT             ; MATCHED 1ST BYTE OF TARGET?
0019A5  2  D0 15                BNE     WNEXT           ; NO, SKIP TO NEXT WORD
0019A7  2               
0019A7  2  C8                   INY
0019A8  2  B1 6C                LDA     (VALUE),Y
0019AA  2  C5 9B                CMP     OUT+1           ; 2ND BYTE MATCHED?
0019AC  2  D0 0E                BNE     WNEXT           ; NOPE
0019AE  2               
0019AE  2  C8                   INY
0019AF  2  B1 6C                LDA     (VALUE),Y
0019B1  2  C5 9C                CMP     OUT+2           ; 3RD BYTE?
0019B3  2  D0 07                BNE     WNEXT           ; SORRY ...
0019B5  2               
0019B5  2  C8                   INY
0019B6  2  B1 6C                LDA     (VALUE),Y
0019B8  2  C5 9D                CMP     OUT+3           ; LAST BYTE
0019BA  2  F0 1F                BEQ     FWSUCC          ; FOUND IT!
0019BC  2               
0019BC  2               WNEXT:
0019BC  2  A5 A8                LDA     ESIZE           ; GET ENTRY SIZE
0019BE  2  18                   CLC                     ; AND ADD IT TO ENTRY ADDRESS
0019BF  2  65 6C                ADC     VALUE+LO        ; TO MAKE [VALUE]
0019C1  2  85 6C                STA     VALUE+LO        ; POINT TO THE NEXT ENTRY
0019C3  2  90 02                BCC     WNX
0019C5  2  E6 6D                INC     VALUE+HI
0019C7  2               
0019C7  2               WNX:
0019C7  2  A5 A6                LDA     NENTS+LO        ; DECREMENT THE
0019C9  2  38                   SEC                     ; ENTRY COUNTER
0019CA  2  E9 01                SBC     #1
0019CC  2  85 A6                STA     NENTS+LO
0019CE  2  B0 02                BCS     WNX1
0019D0  2  C6 A7                DEC     NENTS+HI
0019D2  2               
0019D2  2               WNX1:
0019D2  2  05 A7                ORA     NENTS+HI        ; KEEP SEARCHING
0019D4  2  D0 C9                BNE     FWL1            ; UNTIL COUNT IS ZERO
0019D6  2               
0019D6  2  85 6C                STA     VALUE+LO
0019D8  2  85 6D                STA     VALUE+HI
0019DA  2  60                   RTS                     ; THEN RETURN WITH [VALUE] = 0
0019DB  2               
0019DB  2               ; ENTRY MATCHED!
0019DB  2               
0019DB  2               FWSUCC:
0019DB  2  A5 6D                LDA     VALUE+HI        ; CONVERT ABSOLUTE ENTRY ADDRESS
0019DD  2  38                   SEC                     ; IN [VALUE]
0019DE  2  E5 83                SBC     ZCODE           ; TO RELATIVE Z-ADDRESS
0019E0  2  85 6D                STA     VALUE+HI        ; LSB NEEDN'T CHANGE
0019E2  2  60                   RTS
0019E3  2               
0019E3  1               
0019E3  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- OP SUPPORT & MEMORY MANAGEMENT"
0019E3  1                       .INCLUDE "paging.asm"
0019E3  2               ;        PAGE
0019E3  2               ;        SBTTL   "--- TIME-STAMP PAGING ROUTINE ---"
0019E3  2               
0019E3  2               ; -------------------------
0019E3  2               ; FETCH NEXT BYTE OF Z-CODE
0019E3  2               ; -------------------------
0019E3  2               
0019E3  2               ; EXIT: BYTE AT [ZPC] IN [A] & [Y]; FLAGS SET
0019E3  2               
0019E3  2               NEXTPC:
0019E3  2  A5 79                LDA     ZPCFLG          ; IS [ZPCPNT] VALID?
0019E5  2  D0 1E                BNE     NPC2            ; YES, GET THE BYTE
0019E7  2               
0019E7  2               ; Z-PAGE HAS CHANGED!
0019E7  2               
0019E7  2  A5 77                LDA     ZPCM            ; GET TOP
0019E9  2  A4 78                LDY     ZPCH            ; 9 BITS OF [ZPC]
0019EB  2  D0 08                BNE     NPC0            ; SWAP PAGE IF TOP BIT IS SET
0019ED  2               
0019ED  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
0019EF  2  B0 04                BCS     NPC0            ; NO, SWAP IT IN
0019F1  2               
0019F1  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
0019F3  2  D0 07                BNE     NPC1            ; AND GIVE IT TO [ZPCPNT]
0019F5  2               
0019F5  2               NPC0:
0019F5  2  A2 00                LDX     #0
0019F7  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
0019F9  2  20 4F 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
0019FC  2               
0019FC  2               NPC1:
0019FC  2  85 7B                STA     ZPCPNT+HI       ; SET ABS PAGE ADDRESS
0019FE  2  A2 FF                LDX     #$FF
001A00  2  86 79                STX     ZPCFLG          ; VALIDATE [ZPCPNT]
001A02  2  E8                   INX                     ; = 0
001A03  2  86 7A                STX     ZPCPNT+LO       ; CLEAR LSB OF POINTER
001A05  2               
001A05  2               NPC2:
001A05  2  A4 76                LDY     ZPCL            ; FETCH PAGE INDEX
001A07  2  B1 7A                LDA     (ZPCPNT),Y      ; GET Z-BYTE
001A09  2               
001A09  2  E6 76                INC     ZPCL            ; END OF PAGE YET?
001A0B  2  D0 0A                BNE     NPC3            ; NO, EXIT
001A0D  2               
001A0D  2  A0 00                LDY     #0
001A0F  2  84 79                STY     ZPCFLG          ; ELSE INVALIDATE [ZPCPNT]
001A11  2               
001A11  2  E6 77                INC     ZPCM            ; POINT [ZPC] TO
001A13  2  D0 02                BNE     NPC3            ; THE NEXT
001A15  2  E6 78                INC     ZPCH            ; Z-PAGE
001A17  2               
001A17  2               NPC3:
001A17  2  A8                   TAY                     ; SET FLAGS
001A18  2  60                   RTS                     ; AND RETURN
001A19  2               
001A19  2               ; -------------------------------
001A19  2               ; GET NEXT BYTE OF VIRTUAL MEMORY
001A19  2               ; -------------------------------
001A19  2               
001A19  2               ; EXIT: BYTE AT [MPC] IN [A] & [Y]; FLAGS SET
001A19  2               
001A19  2               GETBYT:
001A19  2  A5 7F                LDA     MPCFLG          ; IS [MPCPNT] VALID?
001A1B  2  D0 1E                BNE     GTBT2           ; YES, GET THE BYTE
001A1D  2               
001A1D  2               ; Z-PAGE HAS CHANGED!
001A1D  2               
001A1D  2  A5 7D                LDA     MPCM            ; GET TOP
001A1F  2  A4 7E                LDY     MPCH            ; 9 BITS OF [MPC]
001A21  2  D0 08                BNE     GTBT0           ; SWAP PAGE IF TOP BIT IS SET
001A23  2               
001A23  2               PATCH           = *+1           ; PATCH POINT FOR "VERIFY"
001A23  2               
001A23  2  C5 84                CMP     ZPURE           ; IS THIS PAGE PRELOADED?
001A25  2  B0 04                BCS     GTBT0           ; NO, SWAP IT IN
001A27  2               
001A27  2  65 83                ADC     ZCODE           ; ELSE MAKE IT ABSOLUTE
001A29  2  D0 07                BNE     GTBT1           ; AND GIVE IT TO [MPCPNT]
001A2B  2               
001A2B  2               GTBT0:
001A2B  2  A2 00                LDX     #0
001A2D  2  86 79                STX     ZPCFLG          ; INVALIDATE [ZPC]
001A2F  2  20 4F 1A             JSR     PAGE            ; AND GET ABS PAGE ADDR INTO [A]
001A32  2               
001A32  2               GTBT1:
001A32  2  85 81                STA     MPCPNT+HI       ; SET ABS PAGE ADDRESS
001A34  2  A2 FF                LDX     #$FF
001A36  2  86 7F                STX     MPCFLG          ; VALIDATE [MPCPNT]
001A38  2  E8                   INX                     ; = 0
001A39  2  86 80                STX     MPCPNT+LO       ; CLEAR LSB OF POINTER
001A3B  2               
001A3B  2               GTBT2:
001A3B  2  A4 7C                LDY     MPCL            ; FETCH PAGE INDEX
001A3D  2  B1 80                LDA     (MPCPNT),Y      ; GET Z-BYTE
001A3F  2               
001A3F  2  E6 7C                INC     MPCL            ; END OF PAGE YET?
001A41  2  D0 0A                BNE     GTBT3           ; NO, EXIT
001A43  2               
001A43  2  A0 00                LDY     #0
001A45  2  84 7F                STY     MPCFLG          ; ELSE INVALIDATE [MPCPNT]
001A47  2               
001A47  2  E6 7D                INC     MPCM            ; POINT [MPC] TO
001A49  2  D0 02                BNE     GTBT3           ; THE NEXT
001A4B  2  E6 7E                INC     MPCH            ; Z-PAGE
001A4D  2               
001A4D  2               GTBT3:
001A4D  2  A8                   TAY                     ; SET FLAGS
001A4E  2  60                   RTS                     ; AND RETURN
001A4F  2               
001A4F  2               ; ------------------------
001A4F  2               ; LOCATE A SWAPABLE Z-PAGE
001A4F  2               ; ------------------------
001A4F  2               
001A4F  2               ; ENTRY: TARGET Z-PAGE IN [A/Y] (9 BITS)
001A4F  2               ; EXIT: ABSOLUTE PAGE IN [A]
001A4F  2               
001A4F  2               PAGE:
001A4F  2  85 88                STA     TARGET+LO       ; SAVE THE
001A51  2  84 89                STY     TARGET+HI       ; TARGET Z-PAGE HERE
001A53  2               
001A53  2               ; IS THIS Z-PAGE ALREADY PAGED IN?
001A53  2               
001A53  2  A2 00                LDX     #0
001A55  2  86 87                STX     ZPAGE           ; START AT BUFFER #0
001A57  2               
001A57  2               PG1:
001A57  2  DD 00 0B             CMP     PTABL,X         ; LSB MATCHED?
001A5A  2  D0 08                BNE     PG2             ; NO, TRY NEXT BUFFER
001A5C  2  98                   TYA                     ; ELSE CHECK
001A5D  2  DD A0 0B             CMP     PTABH,X         ; TOP BIT
001A60  2  F0 2B                BEQ     PG4             ; MATCHED! BUFFER IN [ZPAGE]
001A62  2  A5 88                LDA     TARGET+LO       ; ELSE RESTORE LSB
001A64  2               PG2:
001A64  2  E6 87                INC     ZPAGE           ; UPDATE TALLY
001A66  2  E8                   INX
001A67  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS YET?
001A69  2  90 EC                BCC     PG1             ; NO, KEEP SEARCHING
001A6B  2               
001A6B  2               ; SWAP IN THE TARGET PAGE
001A6B  2               
001A6B  2               PG3:
001A6B  2  20 C8 1A             JSR     EARLY           ; GET EARLIEST PAGE
001A6E  2  A6 8B                LDX     SWAP            ; INTO [SWAP] & [X]
001A70  2  86 87                STX     ZPAGE           ; SAVE FOR LATER
001A72  2               
001A72  2  A5 88                LDA     TARGET+LO       ; ASSIGN THE TARGET PAGE
001A74  2  9D 00 0B             STA     PTABL,X         ; TO THE EARLIEST BUFFER
001A77  2  85 CD                STA     DBLOCK+LO       ; ALSO GIVE IT TO ZDOS
001A79  2               
001A79  2  A5 89                LDA     TARGET+HI       ; SAME FOR TOP BIT
001A7B  2  29 01                AND     #%00000001      ; USE ONLY BIT 0
001A7D  2  9D A0 0B             STA     PTABH,X
001A80  2  85 CE                STA     DBLOCK+HI
001A82  2               
001A82  2  8A                   TXA
001A83  2  18                   CLC
001A84  2  65 85                ADC     PAGE0           ; CALC ABS ADDR OF BUFFER
001A86  2  85 D0                STA     DBUFF+HI        ; GIVE IT TO ZDOS
001A88  2               
001A88  2  20 57 22             JSR     GETDSK          ; SWAP IN THE NEW PAGE
001A8B  2  B0 36                BCS     DSKERR          ; ERROR IF CARRY SET
001A8D  2               
001A8D  2               ; UPDATE THE TIMESTAMP
001A8D  2               
001A8D  2               PG4:
001A8D  2  A4 87                LDY     ZPAGE           ; GET THE BUFFER INDEX
001A8F  2  B9 50 0C             LDA     LRUMAP,Y        ; GET THIS BUFFER'S STAMP
001A92  2  C5 8A                CMP     STAMP           ; SAME AS CURRENT STAMP?
001A94  2  F0 27                BEQ     PG8             ; YES, EXIT
001A96  2               
001A96  2  E6 8A                INC     STAMP           ; UPDATE STAMP
001A98  2  D0 1C                BNE     PG7             ; CONTINUE IF NO OVERFLOW
001A9A  2               
001A9A  2               ; HANDLE STAMP OVERFLOW
001A9A  2               
001A9A  2  20 E2 1A             JSR     EARLY2          ; GET EARLIEST NON-ZERO STAMP INTO [LRU]
001A9D  2               
001A9D  2  A2 00                LDX     #0              ; INIT INDEX
001A9F  2               PG5:
001A9F  2  BD 50 0C             LDA     LRUMAP,X        ; GET A STAMP READING
001AA2  2  F0 06                BEQ     PG6             ; EXIT IF ALREADY ZERO
001AA4  2  38                   SEC                     ; ELSE SUBTRACT OFF
001AA5  2  E5 82                SBC     LRU             ; THE EARLIEST TIMESTAMP
001AA7  2  9D 50 0C             STA     LRUMAP,X        ; AND REPLACE THE STAMP
001AAA  2               PG6:
001AAA  2  E8                   INX
001AAB  2  E4 86                CPX     PMAX            ; END OF SWAPPING SPACE?
001AAD  2  90 F0                BCC     PG5             ; LOOP TILL ALL STAMPS FIXED
001AAF  2               
001AAF  2  A9 00                LDA     #0              ; TURN BACK THE CLOCK
001AB1  2  38                   SEC                     ; TO REFLECT NEW
001AB2  2  E5 82                SBC     LRU             ; STAMP READING
001AB4  2  85 8A                STA     STAMP
001AB6  2               
001AB6  2               PG7:
001AB6  2  A5 8A                LDA     STAMP           ; FETCH STAMP
001AB8  2  A4 87                LDY     ZPAGE           ; AND PAGE INDEX (BM 8/27/85)
001ABA  2  99 50 0C             STA     LRUMAP,Y        ; STAMP TARGET PAGE WITH IT
001ABD  2               
001ABD  2               PG8:
001ABD  2  A5 87                LDA     ZPAGE           ; GET BUFFER INDEX
001ABF  2  18                   CLC                     ; MAKE IT
001AC0  2  65 85                ADC     PAGE0           ; ABSOLUTE
001AC2  2  60                   RTS                     ; AND RETURN IT IN [A]
001AC3  2               
001AC3  2               ; *** ERROR #14: DRIVE ACCESS ***
001AC3  2               
001AC3  2               DSKERR:
001AC3  2  A9 0E                LDA     #14
001AC5  2  4C EB 1D             JMP     ZERROR
001AC8  2               
001AC8  2               ; -------------------------
001AC8  2               ; LOCATE EARLIEST TIMESTAMP
001AC8  2               ; -------------------------
001AC8  2               
001AC8  2               ; EXIT: [LRU] - EARLIEST TIMESTAMP
001AC8  2               ;	[SWAP] = INDEX TO EARLIEST BUFFER
001AC8  2               
001AC8  2               EARLY:
001AC8  2  A2 00                LDX     #0              ; INIT INDEX
001ACA  2  86 8B                STX     SWAP            ; AND [SWAP]
001ACC  2  AD 50 0C             LDA     LRUMAP          ; GET STAMP OF BUFFER #0
001ACF  2  E8                   INX                     ; START COMPARE WITH BUFFER #1
001AD0  2               EAR0:
001AD0  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001AD3  2  90 05                BCC     EAR1            ; NO, TRY NEXT STAMP
001AD5  2  BD 50 0C             LDA     LRUMAP,X        ; ELSE FETCH EARLIER ENTRY
001AD8  2  86 8B                STX     SWAP            ; AND REMEMBER WHERE WE FOUND IT
001ADA  2               EAR1:
001ADA  2  E8                   INX                     ; POINT TO NEXT STAMP
001ADB  2  E4 86                CPX     PMAX            ; OUT OF STAMPS YET?
001ADD  2  90 F1                BCC     EAR0            ; LOOP TILL EMPTY
001ADF  2               
001ADF  2  85 82                STA     LRU             ; SAVE EARLIEST STAMP HERE
001AE1  2  60                   RTS
001AE2  2               
001AE2  2               ; ----------------------------------
001AE2  2               ; LOCATE EARLIEST NON-ZERO TIMESTAMP
001AE2  2               ; (BM/LS 8/27/85)
001AE2  2               ; ----------------------------------
001AE2  2               
001AE2  2               EARLY2:
001AE2  2  A2 00                LDX     #0
001AE4  2  86 8B                STX     SWAP            ; INIT INDEX
001AE6  2               
001AE6  2               E2A:
001AE6  2  BD 50 0C             LDA     LRUMAP,X        ; GET STAMP OF 1ST BUFFER
001AE9  2  D0 07                BNE     E2B             ; NON-ZERO, SO IT'S OKAY
001AEB  2  E8                   INX                     ; ELSE SKIP TO NEXT BUFFER
001AEC  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001AEE  2  90 F6                BCC     E2A             ; NO, KEEP LOOKING
001AF0  2  B0 13                BCS     E2E             ; ELSE WE MUST USE 0
001AF2  2               
001AF2  2               E2B:
001AF2  2  E8                   INX                     ; START COMPARE WITH NEXT BUFFER
001AF3  2               
001AF3  2               E2C:
001AF3  2  DD 50 0C             CMP     LRUMAP,X        ; IS THIS STAMP EARLIER THAN [A]?
001AF6  2  90 08                BCC     E2D             ; IF SMALLER, TRY NEXT STAMP
001AF8  2  BC 50 0C             LDY     LRUMAP,X        ; IS TEST STAMP 0?
001AFB  2  F0 03                BEQ     E2D             ; YES, USE OLD
001AFD  2  98                   TYA                     ; ELSE USE NEW
001AFE  2  86 8B                STX     SWAP            ; UPDATE BUFFER INDEX
001B00  2               
001B00  2               E2D:
001B00  2  E8                   INX                     ; POINT TO NEXT BUFFER
001B01  2  E4 86                CPX     PMAX            ; OUT OF BUFFERS?
001B03  2  90 EE                BCC     E2C             ; NO, LOOP TILL EMPTY
001B05  2               
001B05  2               E2E:
001B05  2  85 82                STA     LRU             ; [A] HAS EARLIEST STAMP
001B07  2  60                   RTS
001B08  2               
001B08  2               ; -------------------------
001B08  2               ; POINT [MPC] TO V-ADDR [I]
001B08  2               ; -------------------------
001B08  2               
001B08  2               SETWRD:
001B08  2  A5 6E                LDA     I+LO
001B0A  2  85 7C                STA     MPCL
001B0C  2  A5 6F                LDA     I+HI
001B0E  2  85 7D                STA     MPCM
001B10  2               
001B10  2  A9 00                LDA     #0
001B12  2  85 7E                STA     MPCH            ; ZERO TOP BIT
001B14  2  85 7F                STA     MPCFLG          ; INVALIDATE [MPC]
001B16  2  60                   RTS
001B17  2               
001B17  2               ; ----------------------------
001B17  2               ; GET Z-WORD AT [MPC] INTO [I]
001B17  2               ; ----------------------------
001B17  2               
001B17  2               GETWRD:
001B17  2  20 19 1A             JSR     GETBYT
001B1A  2  85 6F                STA     I+HI
001B1C  2  20 19 1A             JSR     GETBYT
001B1F  2  85 6E                STA     I+LO
001B21  2  60                   RTS
001B22  2               
001B22  1                       .INCLUDE "zstring.asm"
001B22  2               ;        PAGE
001B22  2               ;        SBTTL   "--- Z-STRING HANDLERS ---"
001B22  2               
001B22  2               ; -----------------------
001B22  2               ; POINT TO ZSTRING IN [I]
001B22  2               ; -----------------------
001B22  2               
001B22  2               SETSTR:
001B22  2  A5 6E                LDA     I+LO            ; WORD-ALIGN THE ADDRESS
001B24  2  0A                   ASL     A
001B25  2  85 7C                STA     MPCL
001B27  2  A5 6F                LDA     I+HI
001B29  2  2A                   ROL     A
001B2A  2  85 7D                STA     MPCM
001B2C  2  A9 00                LDA     #0
001B2E  2  85 7F                STA     MPCFLG          ; [MPC] IS CHANGING!
001B30  2  2A                   ROL     A
001B31  2  85 7E                STA     MPCH
001B33  2               
001B33  2               ZSTEX:
001B33  2  60                   RTS
001B34  2               
001B34  2               ; -----------------------
001B34  2               ; PRINT Z-STRING AT [MPC]
001B34  2               ; -----------------------
001B34  2               
001B34  2               PZSTR:
001B34  2  A2 00                LDX     #0
001B36  2  86 A9                STX     PSET            ; ASSUME PERMANENT CHARSET
001B38  2  86 AD                STX     ZFLAG           ; CLEAR BYTE FLAG
001B3A  2  CA                   DEX                     ; = $FF
001B3B  2  86 AA                STX     TSET            ; NO TEMPSET ACTIVE
001B3D  2               
001B3D  2               PZTOP:
001B3D  2  20 08 1C             JSR     GETZCH          ; GET A Z-CHAR
001B40  2  B0 F1                BCS     ZSTEX           ; END OF STRING IF CARRY IS SET
001B42  2               
001B42  2  85 AB                STA     ZCHAR           ; ELSE SAVE CHAR HERE
001B44  2  AA                   TAX                     ; SET FLAGS
001B45  2  F0 41                BEQ     BLANK           ; PRINT SPACE IF CHAR = 0
001B47  2               
001B47  2  C9 04                CMP     #4              ; IS THIS AN F-WORD?
001B49  2  90 5B                BCC     DOFREQ          ; APPARENTLY SO
001B4B  2               
001B4B  2  C9 06                CMP     #6              ; PERHAPS A SHIFT CODE?
001B4D  2  90 3D                BCC     NEWSET          ; YES, CHANGE CHARSETS
001B4F  2               
001B4F  2  20 FC 1B             JSR     GETSET          ; ELSE GET CHARSET
001B52  2  AA                   TAX                     ; SET FLAGS
001B53  2  D0 0B                BNE     SET1            ; SKIP IF NOT CHARSET #0
001B55  2               
001B55  2               ; PRINT A LOWER-CASE CHAR (CHARSET #0)
001B55  2               
001B55  2  A9 5B                LDA     #$61-6          ; ASCII "a" MINUS Z-OFFSET
001B57  2               
001B57  2               TOASC:
001B57  2  18                   CLC
001B58  2  65 AB                ADC     ZCHAR           ; ADD Z-CHAR INDEX
001B5A  2               
001B5A  2               SHOVE:
001B5A  2  20 CC 1E             JSR     COUT            ; SHOW THE CHAR
001B5D  2  4C 3D 1B             JMP     PZTOP           ; AND GRAB NEXT CHAR
001B60  2               
001B60  2               ; PRINT AN UPPER-CASE CHAR (CHARSET #1)
001B60  2               
001B60  2               SET1:
001B60  2  C9 01                CMP     #1              ; MAKE SURE IT'S SET #1
001B62  2  D0 04                BNE     SET2            ; ELSE MUST BE SET #2
001B64  2               
001B64  2  A9 3B                LDA     #$41-6          ; ASCII "A" MINUS Z-OFFSET
001B66  2  D0 EF                BNE     TOASC           ; SAME AS SET #0
001B68  2               
001B68  2               ; PRINT FROM CHARSET #2
001B68  2               
001B68  2               SET2:
001B68  2  A5 AB                LDA     ZCHAR           ; RETRIEVE THE Z-CHAR
001B6A  2  38                   SEC
001B6B  2  E9 06                SBC     #6              ; ZERO-ALIGN IT
001B6D  2  F0 07                BEQ     DIRECT          ; IF ZERO, IT'S A "DIRECT" ASCII
001B6F  2               
001B6F  2  AA                   TAX                     ; OTHERWISE USE CODE AS AN INDEX
001B70  2  BD 25 1D             LDA     CHRTBL,X        ; INTO THE CHARSET TABLE
001B73  2  4C 5A 1B             JMP     SHOVE           ; AND PRINT THE CHAR
001B76  2               
001B76  2               ; DECODE A "DIRECT" ASCII CHAR
001B76  2               
001B76  2               DIRECT:
001B76  2  20 08 1C             JSR     GETZCH          ; FETCH NEXT Z-CHAR
001B79  2  0A                   ASL     A
001B7A  2  0A                   ASL     A
001B7B  2  0A                   ASL     A
001B7C  2  0A                   ASL     A
001B7D  2  0A                   ASL     A               ; SHIFT INTO POSITION
001B7E  2  85 AB                STA     ZCHAR           ; AND SAVE HERE
001B80  2  20 08 1C             JSR     GETZCH          ; GRAB YET ANOTHER Z-CHAR
001B83  2  05 AB                ORA     ZCHAR           ; SUPERIMPOSE THE 2ND BYTE
001B85  2  4C 5A 1B             JMP     SHOVE           ; AND PRINT THE RESULT
001B88  2               
001B88  2               ; PRINT A SPACE
001B88  2               
001B88  2               BLANK:
001B88  2  A9 20                LDA     #SPACE          ; ASCII SPACE CHAR
001B8A  2  D0 CE                BNE     SHOVE
001B8C  2               
001B8C  2               ; CHANGE CHARSET
001B8C  2               
001B8C  2               NEWSET:
001B8C  2  38                   SEC                     ; CONVERT THE SHIFT CODE
001B8D  2  E9 03                SBC     #3              ; TO 1 OR 2
001B8F  2  A8                   TAY
001B90  2  20 FC 1B             JSR     GETSET          ; IS MODE TEMPORARY?
001B93  2  D0 05                BNE     TOPERM          ; YES, DO A PERMSHIFT
001B95  2  84 AA                STY     TSET            ; ELSE JUST A TEMPSHIFT
001B97  2  4C 3D 1B             JMP     PZTOP           ; AND CONTINUE
001B9A  2               
001B9A  2               TOPERM:
001B9A  2  84 A9                STY     PSET            ; SET PERM CHARSET
001B9C  2  C5 A9                CMP     PSET            ; SAME AS BEFORE?
001B9E  2  F0 9D                BEQ     PZTOP           ; YES, CONTINUE
001BA0  2  A9 00                LDA     #0
001BA2  2  85 A9                STA     PSET            ; ELSE RESET CHARSET
001BA4  2  F0 97                BEQ     PZTOP           ; BEFORE LOOPING BACK
001BA6  2               
001BA6  2               ; PRINT AN F-WORD
001BA6  2               
001BA6  2               DOFREQ:
001BA6  2  38                   SEC
001BA7  2  E9 01                SBC     #1              ; ZERO-ALIGN THE CODE
001BA9  2  0A                   ASL     A               ; AND MULTIPLY TIMES 64
001BAA  2  0A                   ASL     A               ; TO OBTAIN THE SEGMENT OFFSET
001BAB  2  0A                   ASL     A               ; INTO THE F-WORDS TABLE
001BAC  2  0A                   ASL     A
001BAD  2  0A                   ASL     A
001BAE  2  0A                   ASL     A
001BAF  2  85 AC                STA     OFFSET          ; SAVE OFFSET FOR LATER
001BB1  2               
001BB1  2  20 08 1C             JSR     GETZCH          ; NOW GET THE F-WORD POINTER
001BB4  2  0A                   ASL     A               ; WORD-ALIGN IT
001BB5  2  18                   CLC                     ; AND
001BB6  2  65 AC                ADC     OFFSET          ; ADD THE SEGMENT OFFSET
001BB8  2  A8                   TAY                     ; TO GET THE OFFSET OF THE F-WORD
001BB9  2  B1 90                LDA     (FWORDS),Y      ; FROM THE START OF THE F-WORDS TABLE
001BBB  2  85 6F                STA     I+HI            ; SAVE MSB OF F-WORD ADDRESS
001BBD  2  C8                   INY
001BBE  2  B1 90                LDA     (FWORDS),Y      ; ALSO SAVE LSB
001BC0  2  85 6E                STA     I+LO            ; Z-ADDRESS OF F-WORD IS IN [I]
001BC2  2               
001BC2  2               ; SAVE THE STATE OF CURRENT Z-STRING
001BC2  2               
001BC2  2  A5 7E                LDA     MPCH
001BC4  2  48                   PHA
001BC5  2  A5 7D                LDA     MPCM
001BC7  2  48                   PHA
001BC8  2  A5 7C                LDA     MPCL
001BCA  2  48                   PHA
001BCB  2  A5 A9                LDA     PSET
001BCD  2  48                   PHA
001BCE  2  A5 AD                LDA     ZFLAG
001BD0  2  48                   PHA
001BD1  2  A5 AF                LDA     ZWORD+HI
001BD3  2  48                   PHA
001BD4  2  A5 AE                LDA     ZWORD+LO
001BD6  2  48                   PHA
001BD7  2               
001BD7  2  20 22 1B             JSR     SETSTR          ; PRINT THE Z-STRING
001BDA  2  20 34 1B             JSR     PZSTR           ; IN [I]
001BDD  2               
001BDD  2               ; RESTORE OLD Z-STRING
001BDD  2               
001BDD  2  68                   PLA
001BDE  2  85 AE                STA     ZWORD+LO
001BE0  2  68                   PLA
001BE1  2  85 AF                STA     ZWORD+HI
001BE3  2  68                   PLA
001BE4  2  85 AD                STA     ZFLAG
001BE6  2  68                   PLA
001BE7  2  85 A9                STA     PSET
001BE9  2  68                   PLA
001BEA  2  85 7C                STA     MPCL
001BEC  2  68                   PLA
001BED  2  85 7D                STA     MPCM
001BEF  2  68                   PLA
001BF0  2  85 7E                STA     MPCH
001BF2  2               
001BF2  2  A2 FF                LDX     #$FF
001BF4  2  86 AA                STX     TSET            ; DISABLE TEMP CHARSET
001BF6  2  E8                   INX                     ; = 0
001BF7  2  86 7F                STX     MPCFLG          ; [MPC] HAS CHANGED
001BF9  2  4C 3D 1B             JMP     PZTOP           ; CONTINUE INNOCENTLY
001BFC  2               
001BFC  2               ; ----------------------
001BFC  2               ; RETURN CURRENT CHARSET
001BFC  2               ; ----------------------
001BFC  2               
001BFC  2               GETSET:
001BFC  2  A5 AA                LDA     TSET
001BFE  2  10 03                BPL     GS
001C00  2  A5 A9                LDA     PSET
001C02  2  60                   RTS
001C03  2               
001C03  2               GS:
001C03  2  A0 FF                LDY     #$FF
001C05  2  84 AA                STY     TSET
001C07  2  60                   RTS
001C08  2               
001C08  2               ; -----------------
001C08  2               ; FETCH NEXT Z-CHAR
001C08  2               ; -----------------
001C08  2               
001C08  2               GETZCH:
001C08  2  A5 AD                LDA     ZFLAG           ; WHICH BYTE IS THIS?
001C0A  2  10 02                BPL     GTZ0            ; $FF = LAST
001C0C  2  38                   SEC                     ; SET CARRY TO INDICATE
001C0D  2  60                   RTS                     ; NO MORE CHARS
001C0E  2               
001C0E  2               GTZ0:
001C0E  2  D0 13                BNE     GETZ1           ; NOT FIRST CHAR, EITHER
001C10  2               
001C10  2               ; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
001C10  2               
001C10  2  E6 AD                INC     ZFLAG           ; UPDATE CHAR COUNT
001C12  2               
001C12  2  20 19 1A             JSR     GETBYT          ; GET TRIPLET AT [MPC]
001C15  2  85 AF                STA     ZWORD+HI        ; INTO [ZWORD]
001C17  2  20 19 1A             JSR     GETBYT
001C1A  2  85 AE                STA     ZWORD+LO
001C1C  2               
001C1C  2  A5 AF                LDA     ZWORD+HI
001C1E  2  4A                   LSR     A
001C1F  2  4A                   LSR     A               ; SHIFT 1ST CHAR INTO PLACE
001C20  2  4C 4C 1C             JMP     GTEXIT          ; AND RETURN IT
001C23  2               
001C23  2               GETZ1:
001C23  2  38                   SEC
001C24  2  E9 01                SBC     #1
001C26  2  D0 16                BNE     GETZ2           ; LAST CHAR IN TRIPLET IF ZERO
001C28  2  A9 02                LDA     #2              ; ELSE
001C2A  2  85 AD                STA     ZFLAG           ; RESET CHAR INDEX
001C2C  2               
001C2C  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001C2E  2  85 6E                STA     I+LO            ; MOVE HERE FOR SHIFTING
001C30  2  A5 AF                LDA     ZWORD+HI        ; GET TOP HALF
001C32  2               
001C32  2  06 6E                ASL     I+LO            ; SHIFT THE TOP 3 BITS OF LOWER HALF
001C34  2  2A                   ROL     A               ; INTO THE BOTTOM OF THE TOP HALF
001C35  2  06 6E                ASL     I+LO
001C37  2  2A                   ROL     A
001C38  2  06 6E                ASL     I+LO
001C3A  2  2A                   ROL     A
001C3B  2  4C 4C 1C             JMP     GTEXIT
001C3E  2               
001C3E  2               GETZ2:
001C3E  2  A9 00                LDA     #0              ; SET FLAG TO INDICATE
001C40  2  85 AD                STA     ZFLAG           ; END OF TRIPLET
001C42  2               
001C42  2  A5 AF                LDA     ZWORD+HI        ; TEST TOP HALF OF TRIPLET
001C44  2  10 04                BPL     GETZ3           ; CONTINUE IF NOT END OF STRING
001C46  2  A9 FF                LDA     #$FF            ; ELSE
001C48  2  85 AD                STA     ZFLAG           ; INDICATE LAST TRIPLET IN STRING
001C4A  2               
001C4A  2               GETZ3:
001C4A  2  A5 AE                LDA     ZWORD+LO        ; GET BOTTOM HALF OF TRIPLET
001C4C  2               
001C4C  2               GTEXIT:
001C4C  2  29 1F                AND     #%00011111      ; MASK OUT GARBAGE BITS
001C4E  2  18                   CLC
001C4F  2  60                   RTS
001C50  2               
001C50  2               ; ---------------------------------
001C50  2               ; CONVERT [IN] TO Z-STRING IN [OUT]
001C50  2               ; ---------------------------------
001C50  2               
001C50  2               CONZST:
001C50  2  A9 05                LDA     #$05            ; FILL OUTPUT BUFFER
001C52  2  AA                   TAX                     ; WITH PAD CHARS ($05)
001C53  2               CZSL:
001C53  2  95 9A                STA     OUT,X
001C55  2  CA                   DEX
001C56  2  10 FB                BPL     CZSL
001C58  2               
001C58  2  A9 06                LDA     #6              ; INIT
001C5A  2  85 B0                STA     CONCNT          ; CHAR COUNT
001C5C  2               
001C5C  2  A9 00                LDA     #0              ; CLEAR
001C5E  2  85 B1                STA     CONIN           ; SOURCE AND
001C60  2  85 B2                STA     CONOUT          ; OUTPUT INDEXES
001C62  2               
001C62  2               CONTOP:
001C62  2  A6 B1                LDX     CONIN           ; FETCH SOURCE INDEX
001C64  2  E6 B1                INC     CONIN           ; AND UPDATE
001C66  2  B5 94                LDA     IN,X            ; GRAB AN ASCII CHAR
001C68  2  85 AB                STA     ZCHAR           ; SAVE IT HERE
001C6A  2  D0 04                BNE     NEXTZ           ; CONTINUE IF CHAR WAS NZ
001C6C  2               
001C6C  2  A9 05                LDA     #5              ; ELSE SHIP OUT
001C6E  2  D0 2C                BNE     CSHIP           ; A PAD CHAR
001C70  2               
001C70  2               NEXTZ:
001C70  2  A5 AB                LDA     ZCHAR
001C72  2  20 E6 1C             JSR     SAYSET          ; WHICH CHARSET TO USE?
001C75  2  F0 20                BEQ     CSET0           ; LOWER-CASE IF ZERO
001C77  2               
001C77  2  18                   CLC                     ; ELSE DO A TEMP-SHIFT
001C78  2  69 03                ADC     #3              ; 4 = CHARSET 1, 5 = CHARSET 2
001C7A  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001C7C  2  95 9A                STA     OUT,X           ; SEND THE SHIFT CHAR
001C7E  2               
001C7E  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001C80  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001C82  2  D0 03                BNE     CTEST           ; IF OUT OF CHARS
001C84  2  4C FF 1C             JMP     ZCRUSH          ; CRUSH 'EM!
001C87  2               
001C87  2               CTEST:
001C87  2  A5 AB                LDA     ZCHAR           ; TEST CHAR AGAIN
001C89  2  20 E6 1C             JSR     SAYSET
001C8C  2  C9 02                CMP     #2
001C8E  2  F0 19                BEQ     CSET2           ; CHARSET #2
001C90  2               
001C90  2               ; HANDLE CHARSET #1 (UPPER CASE ALPHA)
001C90  2               
001C90  2  A5 AB                LDA     ZCHAR
001C92  2  38                   SEC
001C93  2  E9 3B                SBC     #$41-6          ; CONVERT TO Z-CHAR
001C95  2  10 05                BPL     CSHIP           ; AND SEND TO OUTPUT
001C97  2               
001C97  2               ; HANDLE CHARSET #0 (LOWER CASE ALPHA)
001C97  2               
001C97  2               CSET0:
001C97  2  A5 AB                LDA     ZCHAR
001C99  2  38                   SEC
001C9A  2  E9 5B                SBC     #$61-6          ; CONVERT TO Z-CHAR
001C9C  2               
001C9C  2               ; SHIP Z-CHAR TO OUTPUT BUFFER
001C9C  2               
001C9C  2               CSHIP:
001C9C  2  A6 B2                LDX     CONOUT          ; FETCH OUTPUT INDEX
001C9E  2  95 9A                STA     OUT,X
001CA0  2               
001CA0  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001CA2  2  C6 B0                DEC     CONCNT          ; DONE 6 CHARS YET?
001CA4  2  D0 BC                BNE     CONTOP          ; NO, LOOP BACK
001CA6  2  4C FF 1C             JMP     ZCRUSH          ; ELSE CRUSH
001CA9  2               
001CA9  2               ; HANDLE CHARSET #2 (MISCELLANEOUS)
001CA9  2               
001CA9  2               CSET2:
001CA9  2  A5 AB                LDA     ZCHAR           ; GRAB CHAR
001CAB  2  20 D6 1C             JSR     CTABLE          ; IS IT IN CHARSET #3 TABLE?
001CAE  2  D0 EC                BNE     CSHIP           ; YES, SEND IT TO OUTPUT
001CB0  2               
001CB0  2               ; SEND A "DIRECT" ASCII CHAR
001CB0  2               
001CB0  2  A9 06                LDA     #6              ; ASCII ALERT!
001CB2  2  A6 B2                LDX     CONOUT
001CB4  2  95 9A                STA     OUT,X
001CB6  2               
001CB6  2  E6 B2                INC     CONOUT          ; UPDATE INDEX
001CB8  2  C6 B0                DEC     CONCNT          ; AND CHAR COUNT
001CBA  2  F0 43                BEQ     ZCRUSH          ; BUFFER FULL!
001CBC  2               
001CBC  2               ; SEND 1ST HALF OF "DIRECT"
001CBC  2               
001CBC  2  A5 AB                LDA     ZCHAR
001CBE  2  4A                   LSR     A
001CBF  2  4A                   LSR     A
001CC0  2  4A                   LSR     A
001CC1  2  4A                   LSR     A
001CC2  2  4A                   LSR     A
001CC3  2  29 03                AND     #%00000011      ; MASK GARBAGE
001CC5  2  A6 B2                LDX     CONOUT
001CC7  2  95 9A                STA     OUT,X
001CC9  2               
001CC9  2  E6 B2                INC     CONOUT
001CCB  2  C6 B0                DEC     CONCNT
001CCD  2  F0 30                BEQ     ZCRUSH          ; BUFFER FULL!
001CCF  2               
001CCF  2               ; SEND 2ND HALF OF "DIRECT"
001CCF  2               
001CCF  2  A5 AB                LDA     ZCHAR           ; GET CHAR YET AGAIN
001CD1  2  29 1F                AND     #%00011111      ; MASK JUNK
001CD3  2  4C 9C 1C             JMP     CSHIP           ; AND SHIP IT OUT
001CD6  2               
001CD6  2               ; ---------------------
001CD6  2               ; IS [A] IN CHARSET #3?
001CD6  2               ; ---------------------
001CD6  2               
001CD6  2               ; EXIT: [A] = CHAR CODE IF FOUND, Z-FLAG CLEARED
001CD6  2               ;       Z-FLAG SET IF NOT FOUND
001CD6  2               
001CD6  2               CTABLE:
001CD6  2  A2 19                LDX     #25
001CD8  2               CNL:
001CD8  2  DD 25 1D             CMP     CHRTBL,X
001CDB  2  F0 04                BEQ     CNOK
001CDD  2  CA                   DEX
001CDE  2  D0 F8                BNE     CNL
001CE0  2  60                   RTS                     ; Z-FLAG SET IF NO MATCH
001CE1  2               
001CE1  2               CNOK:
001CE1  2  8A                   TXA                     ; CHAR CODE IS INDEX
001CE2  2  18                   CLC
001CE3  2  69 06                ADC     #6              ; PLUS 6
001CE5  2  60                   RTS
001CE6  2               
001CE6  2               ; -----------------------------
001CE6  2               ; RETURN CHARSET OF CHAR IN [A]
001CE6  2               ; -----------------------------
001CE6  2               
001CE6  2               SAYSET:
001CE6  2  C9 61                CMP     #'a'
001CE8  2  90 07                BCC     SAY1
001CEA  2  C9 7B                CMP     #'z'+1
001CEC  2  B0 03                BCS     SAY1
001CEE  2  A9 00                LDA     #0              ; IT'S CHARSET #0
001CF0  2  60                   RTS
001CF1  2               
001CF1  2               SAY1:
001CF1  2  C9 41                CMP     #'A'
001CF3  2  90 07                BCC     SAY2
001CF5  2  C9 5B                CMP     #'Z'+1
001CF7  2  B0 03                BCS     SAY2
001CF9  2  A9 01                LDA     #1              ; IT'S CHARSET #1
001CFB  2  60                   RTS
001CFC  2               
001CFC  2               SAY2:
001CFC  2  A9 02                LDA     #2              ; IT'S CHARSET #2
001CFE  2  60                   RTS
001CFF  2               
001CFF  2               ; ----------------------
001CFF  2               ; CRUSH Z-CHARS IN [OUT]
001CFF  2               ; ----------------------
001CFF  2               
001CFF  2               ZCRUSH:
001CFF  2  A5 9B                LDA     OUT+1           ; GET 2ND Z-CHAR
001D01  2  0A                   ASL     A               ; SHIFT BITS INTO POSITION
001D02  2  0A                   ASL     A
001D03  2  0A                   ASL     A
001D04  2  0A                   ASL     A
001D05  2  26 9A                ROL     OUT             ; ALONG WITH 1ST Z-CHAR
001D07  2  0A                   ASL     A
001D08  2  26 9A                ROL     OUT
001D0A  2  05 9C                ORA     OUT+2           ; SUPERIMPOSE 3RD Z-CHAR
001D0C  2  85 9B                STA     OUT+1
001D0E  2               
001D0E  2  A5 9E                LDA     OUT+4           ; GET 5TH Z-CHAR
001D10  2  0A                   ASL     A               ; SHIFT BITS
001D11  2  0A                   ASL     A
001D12  2  0A                   ASL     A
001D13  2  0A                   ASL     A
001D14  2  26 9D                ROL     OUT+3           ; ALONG WITH 4TH Z-CHAR
001D16  2  0A                   ASL     A
001D17  2  26 9D                ROL     OUT+3
001D19  2  05 9F                ORA     OUT+5           ; SUPERIMPOSE 6TH Z-CHAR
001D1B  2  AA                   TAX                     ; SAVE HERE
001D1C  2  A5 9D                LDA     OUT+3           ; GRAB 4TH Z-CHAR
001D1E  2  09 80                ORA     #%10000000      ; SET HIGH BIT
001D20  2  85 9C                STA     OUT+2           ; MOVE CRUSHED Z-WORD
001D22  2  86 9D                STX     OUT+3           ; INTO PLACE
001D24  2  60                   RTS
001D25  2               
001D25  2               ; -----------------------
001D25  2               ; CHARSET #2 DECODE TABLE
001D25  2               ; -----------------------
001D25  2               
001D25  2               CHRTBL:
001D25  2  00                   .BYTE   0               ; DUMMY BYTE FOR "DIRECT"
001D26  2  0D                   .BYTE   $0D             ; EOL
001D27  2  30 31 32 33          .BYTE   "0123456789.,!?_#"
001D2B  2  34 35 36 37  
001D2F  2  38 39 2E 2C  
001D37  2  27                   .BYTE   $27             ; SINGLE QUOTE
001D38  2  22                   .BYTE   $22             ; DOUBLE QUOTE
001D39  2  2F 5C 2D 3A          .BYTE   "/\-:()"
001D3D  2  28 29        
001D3F  2               
001D3F  1                       .INCLUDE "objects.asm"
001D3F  2               ;        PAGE
001D3F  2               ;        SBTTL   "--- OBJECT & PROPERTY HANDLERS ---"
001D3F  2               
001D3F  2               ; ----------------------------------
001D3F  2               ; GET ABSOLUTE ADDRESS OF OBJECT [A]
001D3F  2               ; ----------------------------------
001D3F  2               
001D3F  2               ; EXIT: ADDRESS IN [I]
001D3F  2               
001D3F  2               OBJLOC:
001D3F  2  85 6E                STA     I+LO            ; SAVE LSB FOR ADDING
001D41  2               
001D41  2  A2 00                LDX     #0              ; CLEAR MSB
001D43  2  86 6F                STX     I+HI            ; FOR SHIFTING
001D45  2               
001D45  2  0A                   ASL     A               ; MULTIPLY BY 8
001D46  2  26 6F                ROL     I+HI
001D48  2  0A                   ASL     A
001D49  2  26 6F                ROL     I+HI
001D4B  2  0A                   ASL     A
001D4C  2  26 6F                ROL     I+HI
001D4E  2               
001D4E  2  18                   CLC                     ; ADD TO ITSELF
001D4F  2  65 6E                ADC     I+LO            ; TO GET TIMES 9
001D51  2  90 02                BCC     OBJ1
001D53  2  E6 6F                INC     I+HI
001D55  2               
001D55  2               OBJ1:
001D55  2  18                   CLC
001D56  2  69 35                ADC     #53             ; NOW ADD 53
001D58  2  90 02                BCC     OBJ2            ; (THE OBJECT TABLE OFFSET)
001D5A  2  E6 6F                INC     I+HI
001D5C  2               
001D5C  2               OBJ2:
001D5C  2  18                   CLC                     ; NEXT ADD THE ABS ADDR
001D5D  2  65 92                ADC     OBJTAB+LO       ; OF THE OBJECT TABLE
001D5F  2  85 6E                STA     I+LO
001D61  2               
001D61  2  A5 6F                LDA     I+HI
001D63  2  65 93                ADC     OBJTAB+HI
001D65  2  85 6F                STA     I+HI
001D67  2  60                   RTS
001D68  2               
001D68  2               ; -----------------------------
001D68  2               ; GET ADDRESS OF PROPERTY TABLE
001D68  2               ; -----------------------------
001D68  2               
001D68  2               ; EXIT: [I] HAS ABSOLUTE ADDR OF PROPERTY TABLE
001D68  2               ;       [Y] HAS OFFSET TO START OF PROP IDS
001D68  2               
001D68  2               PROPB:
001D68  2  A5 62                LDA     ARG1+LO
001D6A  2  20 3F 1D             JSR     OBJLOC
001D6D  2  A0 07                LDY     #7
001D6F  2  B1 6E                LDA     (I),Y           ; GET MSB OF P-TABLE ADDRESS
001D71  2  18                   CLC
001D72  2  65 83                ADC     ZCODE           ; MAKE IT ABSOLUTE
001D74  2  AA                   TAX                     ; AND SAVE HERE
001D75  2  C8                   INY
001D76  2  B1 6E                LDA     (I),Y           ; NOW GET LSB
001D78  2  85 6E                STA     I+LO
001D7A  2  86 6F                STX     I+HI            ; [I] NOW POINTS TO PROP TABLE
001D7C  2               
001D7C  2  A0 00                LDY     #0
001D7E  2  B1 6E                LDA     (I),Y           ; GET LENGTH OF SHORT DESC
001D80  2  0A                   ASL     A               ; WORD-ALIGN IT
001D81  2  A8                   TAY                     ; EXPECTED HERE
001D82  2  C8                   INY                     ; POINT JUST PAST THE DESCRIPTION
001D83  2  60                   RTS
001D84  2               
001D84  2               ; -------------------
001D84  2               ; FETCH A PROPERTY ID
001D84  2               ; -------------------
001D84  2               
001D84  2               ; ENTRY: LIKE "PROPB" EXIT
001D84  2               
001D84  2               PROPN:
001D84  2  B1 6E                LDA     (I),Y
001D86  2  29 1F                AND     #%00011111      ; MASK OUT LENGTH BITS
001D88  2  60                   RTS
001D89  2               
001D89  2               ; -------------------------------
001D89  2               ; FETCH # BYTES IN PROPERTY VALUE
001D89  2               ; -------------------------------
001D89  2               
001D89  2               ; ENTRY: LIKE "PROPB" EXIT
001D89  2               
001D89  2               PROPL:
001D89  2  B1 6E                LDA     (I),Y
001D8B  2  4A                   LSR     A               ; LENGTH IS IN
001D8C  2  4A                   LSR     A               ; BITS 7-5
001D8D  2  4A                   LSR     A               ; SO SHIFT INTO PLACE
001D8E  2  4A                   LSR     A
001D8F  2  4A                   LSR     A
001D90  2  60                   RTS
001D91  2               
001D91  2               ; ----------------------
001D91  2               ; POINT TO NEXT PROPERTY
001D91  2               ; ----------------------
001D91  2               
001D91  2               ; ENTRY: LIKE "PROPB" EXIT
001D91  2               
001D91  2               PROPNX:
001D91  2  20 89 1D             JSR     PROPL           ; GET LENGTH OF CURRENT PROP
001D94  2  AA                   TAX                     ; SAVE HERE
001D95  2               
001D95  2               PPX:
001D95  2  C8                   INY                     ; LOOP UNTIL
001D96  2  CA                   DEX                     ; [Y] POINTS TO
001D97  2  10 FC                BPL     PPX             ; START OF NEXT PROP
001D99  2  C8                   INY                     ; CORRECT ALIGNMENT
001D9A  2  60                   RTS
001D9B  2               
001D9B  2               ; ----------------
001D9B  2               ; GET OBJECT FLAGS
001D9B  2               ; ----------------
001D9B  2               
001D9B  2               ; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
001D9B  2               ; EXIT: FLAG WORD IN [K], BIT ID IN [J],
001D9B  2               ;       FLAG WORD ADDRESS IN [I]
001D9B  2               
001D9B  2               FLAGSU:
001D9B  2  A5 62                LDA     ARG1+LO
001D9D  2  20 3F 1D             JSR     OBJLOC          ; GET OBJECT ADDR IN [I]
001DA0  2               
001DA0  2  A5 64                LDA     ARG2+LO         ; LOOK AT FLAG ID
001DA2  2  C9 10                CMP     #$10            ; FIRST SET OF FLAGS?
001DA4  2  90 0F                BCC     FLS1            ; YES, ADDR IN [I] IS CORRECT
001DA6  2               
001DA6  2  E9 10                SBC     #16             ; ELSE ZERO-ALIGN FLAG INDEX
001DA8  2  AA                   TAX                     ; SAVE IT HERE
001DA9  2               
001DA9  2  A5 6E                LDA     I+LO            ; ADD 2 TO ADDRESS IN [I]
001DAB  2  18                   CLC                     ; TO POINT TO ADDRESS OF
001DAC  2  69 02                ADC     #2              ; 2ND FLAG WORD
001DAE  2  85 6E                STA     I+LO
001DB0  2  90 02                BCC     FLS0
001DB2  2  E6 6F                INC     I+HI
001DB4  2               
001DB4  2               FLS0:
001DB4  2  8A                   TXA                     ; RESTORE INDEX
001DB5  2               
001DB5  2               FLS1:
001DB5  2  85 72                STA     K+LO            ; SAVE FLAG ID HERE
001DB7  2               
001DB7  2  A2 01                LDX     #1              ; INIT THE
001DB9  2  86 70                STX     J+LO            ; FLAG WORD TO
001DBB  2  CA                   DEX                     ; $0001
001DBC  2  86 71                STX     J+HI
001DBE  2               
001DBE  2  A9 0F                LDA     #15             ; SUBTRACT THE BIT POSITION
001DC0  2  38                   SEC                     ; FROM 15
001DC1  2  E5 72                SBC     K+LO            ; TO GET THE SHIFT LOOP
001DC3  2  AA                   TAX                     ; INDEX
001DC4  2  F0 07                BEQ     FLS2            ; EXIT NOW IF NO SHIFT NEEDED
001DC6  2               
001DC6  2               FLSL:
001DC6  2  06 70                ASL     J+LO            ; SHIFT THE BIT
001DC8  2  26 71                ROL     J+HI            ; INTO POSITION
001DCA  2  CA                   DEX
001DCB  2  D0 F9                BNE     FLSL
001DCD  2               
001DCD  2               FLS2:
001DCD  2  A0 00                LDY     #0              ; MOVE THE FLAG WORD
001DCF  2  B1 6E                LDA     (I),Y           ; INTO [J]
001DD1  2  85 73                STA     K+HI            ; FIRST THE MSB
001DD3  2  C8                   INY
001DD4  2  B1 6E                LDA     (I),Y
001DD6  2  85 72                STA     K+LO            ; THEN THE LSB
001DD8  2  60                   RTS
001DD9  2               
001DD9  1               
001DD9  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC. --- MACHINE DEPENDENT I/O"
001DD9  1                       .INCLUDE "io.asm"
001DD9  2               ;        PAGE
001DD9  2               ;        SBTTL   "--- GAME I/O: DOS/65 ---"
001DD9  2               
001DD9  2               ; --------------
001DD9  2               ; INTERNAL ERROR
001DD9  2               ; --------------
001DD9  2               
001DD9  2               ; ENTRY: ERROR CODE IN [A]
001DD9  2               
001DD9  2               ERRM:
001DD9  2  49 6E 74 65          .BYTE   "Internal error "
001DDD  2  72 6E 61 6C  
001DE1  2  20 65 72 72  
001DE8  2               ENUMB:
001DE8  2  30 30 2E             .BYTE   "00."
001DEB  2               ERRML           = *-ERRM
001DEB  2               
001DEB  2               ZERROR:
001DEB  2  A0 01                LDY     #1              ; CONVERT ERROR BYTE IN [A]
001DED  2               ECON:
001DED  2  20 DF 26             JSR     DIV10           ; TO ASCII DECIMAL IN [ENUMB]
001DF0  2  09 30                ORA     #'0'
001DF2  2  99 E8 1D             STA     ENUMB,Y
001DF5  2  8A                   TXA
001DF6  2  88                   DEY
001DF7  2  10 F4                BPL     ECON
001DF9  2               
001DF9  2  20 0A 1F             JSR     ZCRLF           ; CLEAR BUFFER
001DFC  2  A9 00                LDA     #0
001DFE  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001E00  2               
001E00  2  A2 D9                LDX     #<ERRM
001E02  2  A9 1D                LDA     #>ERRM
001E04  2  A0 12                LDY     #ERRML
001E06  2  20 79 21             JSR     DLINE
001E09  2               
001E09  2               ; FALL THROUGH ...
001E09  2               
001E09  2               ; ----
001E09  2               ; QUIT
001E09  2               ; ----
001E09  2               
001E09  2               ZQUIT:
001E09  2  20 0A 1F             JSR     ZCRLF           ; FLUSH BUFFER
001E0C  2               
001E0C  2  A2 1A                LDX     #<TOQ
001E0E  2  A9 1E                LDA     #>TOQ
001E10  2  A0 10                LDY     #TOQL
001E12  2  20 79 21             JSR     DLINE           ; "END OF STORY"
001E15  2  A2 00                LDX     #0
001E17  2  4C 03 01             JMP     PEM
001E1A  2               
001E1A  2               TOQ:
001E1A  2  45 6E 64 20          .BYTE   "End of session."
001E1E  2  6F 66 20 73  
001E22  2  65 73 73 69  
001E29  2  0D                   .BYTE   EOL
001E2A  2               TOQL            = *-TOQ
001E2A  2               
001E2A  2               ; -------
001E2A  2               ; RESTART
001E2A  2               ; -------
001E2A  2               
001E2A  2               ZSTART:
001E2A  2  20 0A 1F             JSR     ZCRLF
001E2D  2               
001E2D  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; SAVE SCRIPT STATE
001E30  2  29 01                AND     #%00000001      ; FOR LATER
001E32  2  8D 8E 21             STA     SFLAG           ; (BM 5/14/85)
001E35  2               
001E35  2  4C 5B 0E             JMP     WARM1           ; AND DO A WARMSTART
001E38  2               
001E38  2               ; --------------------
001E38  2               ; PRINT VERSION NUMBER
001E38  2               ; --------------------
001E38  2               
001E38  2               VERS:
001E38  2  44 4F 53 2F          .BYTE   "DOS/65 Version F"
001E3C  2  36 35 20 56  
001E40  2  65 72 73 69  
001E48  2  0D                   .BYTE   EOL
001E49  2               VERSL           = *-VERS
001E49  2               
001E49  2               VERNUM:
001E49  2  20 0A 1F             JSR     ZCRLF
001E4C  2               
001E4C  2  A2 38                LDX     #<VERS
001E4E  2  A9 1E                LDA     #>VERS
001E50  2  A0 11                LDY     #VERSL
001E52  2  4C 79 21             JMP     DLINE
001E55  2               
001E55  2               ; --------------------------
001E55  2               ; RETURN TOP RAM PAGE IN [A]
001E55  2               ; --------------------------
001E55  2               
001E55  2               MEMTOP:
001E55  2  A9 CF                LDA     #$CF            ; IT'S A GIVEN
001E57  2  60                   RTS
001E58  2               
001E58  2               ; --------------------------------
001E58  2               ; RETURN RANDOM BYTES IN [A] & [X]
001E58  2               ; --------------------------------
001E58  2               RANDOM:
001E58  2  18                   CLC
001E59  2  A9 41                LDA     #$41
001E5B  2  6D C2 1E             ADC     state+0
001E5E  2  8D C2 1E             STA     state+0
001E61  2  6D C3 1E             ADC     state+1
001E64  2  8D C3 1E             STA     state+1
001E67  2  6D C4 1E             ADC     state+2
001E6A  2  8D C4 1E             STA     state+2
001E6D  2  6D C5 1E             ADC     state+3
001E70  2  8D C5 1E             STA     state+3
001E73  2  6D C6 1E             ADC     state+4
001E76  2  0A                   ASL
001E77  2  6D C5 1E             ADC     state+3
001E7A  2  8D C6 1E             STA     state+4
001E7D  2  4D C4 1E             EOR     state+2
001E80  2  AA                   TAX
001E81  2  18                   CLC
001E82  2  A9 41                LDA     #$41
001E84  2  6D C7 1E             ADC     state1+0
001E87  2  8D C7 1E             STA     state1+0
001E8A  2  6D C8 1E             ADC     state1+1
001E8D  2  8D C8 1E             STA     state1+1
001E90  2  6D C9 1E             ADC     state1+2
001E93  2  8D C9 1E             STA     state1+2
001E96  2  6D CA 1E             ADC     state1+3
001E99  2  8D CA 1E             STA     state1+3
001E9C  2  6D CB 1E             ADC     state1+4
001E9F  2  0A                   ASL
001EA0  2  6D CA 1E             ADC     state1+3
001EA3  2  8D CB 1E             STA     state1+4
001EA6  2  4D C9 1E             EOR     state1+2
001EA9  2               
001EA9  2  8D C7 1E             STA     state1
001EAC  2  EE C2 1E             INC     state
001EAF  2  EE C8 1E             INC     state1+1
001EB2  2  8E C3 1E             STX     state+1
001EB5  2  EE C9 1E             INC     state1+2
001EB8  2  EE CA 1E             INC     state1+3
001EBB  2  EE C5 1E             INC     state+3
001EBE  2  EE C6 1E             INC     state+4
001EC1  2  60                   RTS
001EC2  2               ; RANDOM SEEDS
001EC2  2               state:
001EC2  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001EC6  2  00           
001EC7  2               state1:
001EC7  2  00 00 00 00          .BYTE   $00,$00,$00,$00,$00
001ECB  2  00           
001ECC  2               
001ECC  2               
001ECC  2               
001ECC  2               ; -------------------
001ECC  2               ; Z-PRINT A CHARACTER
001ECC  2               ; -------------------
001ECC  2               
001ECC  2               ; ENTRY: ASCII CHAR IN [A]
001ECC  2               
001ECC  2               COUT:
001ECC  2  C9 0D                CMP     #EOL            ; IF EOL,
001ECE  2  F0 3A                BEQ     ZCRLF           ; DO IT!
001ED0  2  C9 20                CMP     #SPACE          ; IGNORE ALL OTHER
001ED2  2  90 0B                BCC     CEX             ; CONTROLS
001ED4  2               
001ED4  2  A6 BD                LDX     LENGTH          ; ELSE GET LINE POINTER
001ED6  2  9D 40 07             STA     LBUFF,X         ; ADD CHAR TO BUFFER
001ED9  2  E0 4F                CPX     #XSIZE          ; END OF LINE?
001EDB  2  B0 03                BCS     FLUSH           ; YES, FLUSH THE LINE
001EDD  2  E6 BD                INC     LENGTH          ; ELSE UPDATE POINTER
001EDF  2               
001EDF  2               CEX:
001EDF  2  60                   RTS
001EE0  2               
001EE0  2               ; -------------------
001EE0  2               ; FLUSH OUTPUT BUFFER
001EE0  2               ; -------------------
001EE0  2               
001EE0  2               ; ENTRY: LENGTH OF BUFFER IN [X]
001EE0  2               
001EE0  2               FLUSH:
001EE0  2  A9 20                LDA     #SPACE
001EE2  2               
001EE2  2               FL0:
001EE2  2  DD 40 07             CMP     LBUFF,X         ; FIND LAST SPACE CHAR
001EE5  2  F0 05                BEQ     FL1             ; IN THE LINE
001EE7  2  CA                   DEX
001EE8  2  D0 F8                BNE     FL0             ; IF NONE FOUND,
001EEA  2  A2 4F                LDX     #XSIZE          ; FLUSH ENTIRE LINE
001EEC  2               
001EEC  2               FL1:
001EEC  2  86 BE                STX     OLDLEN          ; SAVE OLD LINE POS HERE
001EEE  2  86 BD                STX     LENGTH          ; MAKE IT THE NEW LINE LENGTH
001EF0  2               
001EF0  2  20 0A 1F             JSR     ZCRLF           ; PRINT LINE UP TO LAST SPACE
001EF3  2               
001EF3  2               ; START NEW LINE WITH REMAINDER OF OLD
001EF3  2               
001EF3  2  A6 BE                LDX     OLDLEN          ; GET OLD LINE POS
001EF5  2  A0 00                LDY     #0              ; START NEW LINE AT BEGINNING
001EF7  2               FL2:
001EF7  2  E8                   INX
001EF8  2  E0 4F                CPX     #XSIZE          ; CONTINUE IF
001EFA  2  90 05                BCC     FL3             ; INSIDE OR
001EFC  2  F0 03                BEQ     FL3             ; AT END OF LINE
001EFE  2  84 BD                STY     LENGTH          ; ELSE SET NEW LINE LENGTH
001F00  2  60                   RTS
001F01  2               
001F01  2               FL3:
001F01  2  BD 40 07             LDA     LBUFF,X         ; GET CHAR FROM OLD LINE
001F04  2  99 40 07             STA     LBUFF,Y         ; MOVE TO START OF NEW LINE
001F07  2  C8                   INY                     ; UPDATE LENGTH OF NEW LINE
001F08  2  D0 ED                BNE     FL2
001F0A  2               
001F0A  2               ; ---------------
001F0A  2               ; CARRIAGE RETURN
001F0A  2               ; ---------------
001F0A  2               
001F0A  2               ZCRLF:
001F0A  2  E6 C2                INC     LINCNT          ; NEW LINE GOING OUT
001F0C  2  A5 C2                LDA     LINCNT          ; IS IT TIME TO
001F0E  2  C5 C3                CMP     LMAX            ; PRINT "MORE" YET?
001F10  2  90 22                BCC     CR1             ; NO, CONTINUE
001F12  2               
001F12  2               ; SCREEN FULL; PRINT "MORE"
001F12  2               
001F12  2  20 7C 1F             JSR     ZUSL            ; UPDATE STATUS LINE
001F15  2               
001F15  2  A9 00                LDA     #0
001F17  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
001F19  2  20 2D 22             JSR     BOLD
001F1C  2  A2 57                LDX     #<MORE
001F1E  2  A9 1F                LDA     #>MORE
001F20  2  A0 06                LDY     #MOREL
001F22  2  20 79 21             JSR     DLINE           ; PRINT "MORE" DIRECTLY
001F25  2  20 3B 22             JSR     UNBOLD
001F28  2               ZCR0:
001F28  2  20 C2 20             JSR     GETKEY          ; GET KEYPRESS
001F2B  2  A2 5D                LDX     #<MCLR
001F2D  2  A9 1F                LDA     #>MCLR
001F2F  2  A0 12                LDY     #MCLRL
001F31  2  20 79 21             JSR     DLINE           ; RUB OUT "MORE"
001F34  2               
001F34  2               CR1:
001F34  2  A6 BD                LDX     LENGTH
001F36  2  A9 0D                LDA     #EOL            ; INSTALL EOL AT
001F38  2  9D 40 07             STA     LBUFF,X         ; END OF CURRENT LINE
001F3B  2  E6 BD                INC     LENGTH          ; UPDATE LINE LENGTH
001F3D  2               
001F3D  2               LINOUT:
001F3D  2  A4 BD                LDY     LENGTH          ; IF BUFFER EMPTY,
001F3F  2  F0 11                BEQ     LINEX           ; DON'T PRINT ANYTHING
001F41  2               
001F41  2  84 CC                STY     PRLEN           ; SAVE LENGTH HERE FOR "PPRINT"
001F43  2  A2 00                LDX     #0              ; SEND CONTENTS OF [LBUFF]
001F45  2               LOUT:
001F45  2  BD 40 07             LDA     LBUFF,X         ; TO SCREEN
001F48  2  20 00 21             JSR     CHAR
001F4B  2  E8                   INX
001F4C  2  88                   DEY
001F4D  2  D0 F6                BNE     LOUT
001F4F  2               
001F4F  2  20 8F 21             JSR     PPRINT          ; PRINT [LBUFF] IF ENABLED
001F52  2               
001F52  2               LINEX:
001F52  2  A9 00                LDA     #0              ; RESET LINE LENGTH
001F54  2  85 BD                STA     LENGTH          ; TO ZERO
001F56  2  60                   RTS                     ; AND RETURN
001F57  2               
001F57  2               MORE:
001F57  2  5B 4D 4F 52          .BYTE   "[MORE]"
001F5B  2  45 5D        
001F5D  2               MOREL           = *-MORE
001F5D  2               
001F5D  2               MCLR:
001F5D  2  08 08 08 08          .BYTE   08,08,08,08,08,08,"      ",08,08,08,08,08,08
001F61  2  08 08 20 20  
001F65  2  20 20 20 20  
001F6F  2               MCLRL           = *-MCLR
001F6F  2               
001F6F  2               ; ----------------------
001F6F  2               ; UPDATE THE STATUS LINE
001F6F  2               ; ----------------------
001F6F  2               
001F6F  2               SCORE:
001F6F  2  53 63 6F 72          .BYTE   "Score: "
001F73  2  65 3A 20     
001F76  2               SCOREL          = *-SCORE
001F76  2               
001F76  2               CLOCK:
001F76  2  54 69 6D 65          .BYTE   "Time: "
001F7A  2  3A 20        
001F7C  2               CLOCKL          = *-CLOCK
001F7C  2               
001F7C  2               
001F7C  2               ZUSL:
001F7C  2  A5 BD                LDA     LENGTH          ; SAVE ALL
001F7E  2  48                   PHA                     ; STRING-PRINTING
001F7F  2  A5 7E                LDA     MPCH            ; VARIABLES
001F81  2  48                   PHA
001F82  2  A5 7D                LDA     MPCM
001F84  2  48                   PHA
001F85  2  A5 7C                LDA     MPCL
001F87  2  48                   PHA
001F88  2  A5 AA                LDA     TSET
001F8A  2  48                   PHA
001F8B  2  A5 A9                LDA     PSET
001F8D  2  48                   PHA
001F8E  2  A5 AF                LDA     ZWORD+HI
001F90  2  48                   PHA
001F91  2  A5 AE                LDA     ZWORD+LO
001F93  2  48                   PHA
001F94  2  A5 AD                LDA     ZFLAG
001F96  2  48                   PHA
001F97  2  A5 BB                LDA     DIGITS
001F99  2  48                   PHA
001F9A  2               
001F9A  2  A2 4F                LDX     #XSIZE
001F9C  2               USL0:
001F9C  2  BD 40 07             LDA     LBUFF,X         ; MOVE CONTENTS OF [LBUFF]
001F9F  2  9D 20 0D             STA     BUFSAV,X        ; TO [BUFSAV]
001FA2  2  A9 20                LDA     #SPACE          ; CLEAR
001FA4  2  9D 40 07             STA     LBUFF,X         ; [LBUFF] WITH SPACES
001FA7  2  CA                   DEX
001FA8  2  10 F2                BPL     USL0
001FAA  2               
001FAA  2  A9 00                LDA     #0
001FAC  2  85 BD                STA     LENGTH          ; RESET LINE LENGTH
001FAE  2  85 BF                STA     SCRIPT          ; DISABLE SCRIPTING
001FB0  2  20 49 22             JSR     REVERSE
001FB3  2  A2 00                LDX     #0
001FB5  2  A0 00                LDY     #0
001FB7  2  20 CA 21             JSR     PLOT
001FBA  2               ;
001FBA  2               ; PRINT ROOM DESCRIPTION
001FBA  2               ;
001FBA  2  A9 10                LDA     #16             ; GLOBAL VAR #16 (ROOM ID)
001FBC  2  20 A2 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001FBF  2  A5 6C                LDA     VALUE+LO
001FC1  2  20 9C 13             JSR     PRNTDC          ; PRINT SHORT ROOM DESCRIPTION
001FC4  2               
001FC4  2  A9 18                LDA     #24             ; MOVE LINE INDEX UP
001FC6  2  85 BD                STA     LENGTH          ; TO TIME/SCORE POSITION
001FC8  2               
001FC8  2  A9 11                LDA     #17             ; GLOBAL VAR #17 (SCORE/HOURS)
001FCA  2  20 A2 10             JSR     GETVRG          ; GET IT INTO [VALUE]
001FCD  2               
001FCD  2  A5 BC                LDA     TIMEFL          ; GET MODE FLAG
001FCF  2  D0 32                BNE     DOTIME          ; USE TIME MODE IF NON-ZERO
001FD1  2               ;
001FD1  2               ; PRINT "SCORE"
001FD1  2               ;
001FD1  2  A9 53                LDA     #'S'
001FD3  2  20 CC 1E             JSR     COUT
001FD6  2  A9 63                LDA     #'c'
001FD8  2  20 CC 1E             JSR     COUT
001FDB  2  A9 6F                LDA     #'o'
001FDD  2  20 CC 1E             JSR     COUT
001FE0  2  A9 72                LDA     #'r'
001FE2  2  20 CC 1E             JSR     COUT
001FE5  2  A9 65                LDA     #'e'
001FE7  2  20 CC 1E             JSR     COUT
001FEA  2  A9 3A                LDA     #':'
001FEC  2  20 CC 1E             JSR     COUT
001FEF  2  A9 20                LDA     #SPACE
001FF1  2  20 CC 1E             JSR     COUT
001FF4  2               
001FF4  2  A5 6C                LDA     VALUE+LO        ; MOVE SCORE VALUE
001FF6  2  85 B3                STA     QUOT+LO         ; INTO [QUOT]
001FF8  2  A5 6D                LDA     VALUE+HI        ; FOR PRINTING
001FFA  2  85 B4                STA     QUOT+HI
001FFC  2  20 F8 17             JSR     NUMBER          ; PRINT SCORE VALUE IN DECIMAL
001FFF  2               ;
001FFF  2  A9 2F                LDA     #'/'            ; PRINT A SLASH
002001  2  D0 35                BNE     MOVMIN          ; BRANCH ALWAYS
002003  2               
002003  2               ; PRINT "TIME"
002003  2               
002003  2               DOTIME:
002003  2  A9 54                LDA     #'T'
002005  2  20 CC 1E             JSR     COUT
002008  2  A9 69                LDA     #'i'
00200A  2  20 CC 1E             JSR     COUT
00200D  2  A9 6D                LDA     #'m'
00200F  2  20 CC 1E             JSR     COUT
002012  2  A9 65                LDA     #'e'
002014  2  20 CC 1E             JSR     COUT
002017  2  A9 3A                LDA     #':'
002019  2  20 CC 1E             JSR     COUT
00201C  2  A9 20                LDA     #SPACE
00201E  2  20 CC 1E             JSR     COUT
002021  2               ;
002021  2  A5 6C                LDA     VALUE+LO        ; 00 IS REALLY 24
002023  2  D0 02                BNE     DT0
002025  2  A9 18                LDA     #24
002027  2               DT0:
002027  2  C9 0D                CMP     #13             ; IS HOURS > 12,
002029  2  90 02                BCC     DT1
00202B  2  E9 0C                SBC     #12             ; CONVERT TO 1-12
00202D  2               DT1:
00202D  2  85 B3                STA     QUOT+LO         ; MOVE FOR PRINTING
00202F  2  A9 00                LDA     #0
002031  2  85 B4                STA     QUOT+HI         ; CLEAR MSB
002033  2  20 F8 17             JSR     NUMBER
002036  2               
002036  2  A9 3A                LDA     #':'            ; COLON
002038  2               MOVMIN:
002038  2  20 CC 1E             JSR     COUT            ; PRINT SLASH OR COLON
00203B  2               
00203B  2  A9 12                LDA     #18             ; GLOBAL VAR #18 (MOVES/MINUTES)
00203D  2  20 A2 10             JSR     GETVRG          ; GET IT INTO [VALUE]
002040  2  A5 6C                LDA     VALUE+LO        ; MOVE TO [QUOT]
002042  2  85 B3                STA     QUOT+LO         ; FOR EVENTUAL PRINTING
002044  2  A5 6D                LDA     VALUE+HI
002046  2  85 B4                STA     QUOT+HI
002048  2               
002048  2  A5 BC                LDA     TIMEFL          ; WHICH MODE?
00204A  2  D0 06                BNE     DOMINS          ; TIME IF NZ
00204C  2               ;
00204C  2               ; PRINT NUMBER OF MOVES
00204C  2               ;
00204C  2  20 F8 17             JSR     NUMBER          ; SHOW # MOVES
00204F  2  4C 7E 20             JMP     STATEX          ; ALL DONE
002052  2               ;
002052  2               ; PRINT MINUTES
002052  2               ;
002052  2               DOMINS:
002052  2  A5 6C                LDA     VALUE+LO        ; CHECK MINUTES
002054  2  C9 0A                CMP     #10             ; IF MORE THAN TEN
002056  2  B0 05                BCS     DOM0            ; CONTINUE
002058  2               
002058  2  A9 30                LDA     #'0'            ; ELSE PRINT A
00205A  2  20 CC 1E             JSR     COUT            ; PADDING "0" FIRST
00205D  2               
00205D  2               DOM0:
00205D  2  20 F8 17             JSR     NUMBER          ; SHOW MINUTES
002060  2               
002060  2  A9 20                LDA     #SPACE
002062  2  20 CC 1E             JSR     COUT            ; SEPARATE THINGS
002065  2               ;
002065  2  A9 11                LDA     #17             ; CHECK "HOURS" AGAIN
002067  2  20 A2 10             JSR     GETVRG
00206A  2  A5 6C                LDA     VALUE+LO
00206C  2  C9 0C                CMP     #12             ; PAST NOON?
00206E  2  B0 04                BCS     DOPM            ; YES, PRINT "PM"
002070  2               
002070  2  A9 41                LDA     #'A'            ; ELSE PRINT "AM"
002072  2  D0 02                BNE     DOXM            ; BRANCH ALWAYS
002074  2               
002074  2               DOPM:
002074  2  A9 50                LDA     #'P'
002076  2               
002076  2               DOXM:
002076  2  20 CC 1E             JSR     COUT
002079  2  A9 4D                LDA     #'M'
00207B  2  20 CC 1E             JSR     COUT
00207E  2               ;
00207E  2               ; STATUS LINE READY
00207E  2               ;
00207E  2               STATEX:
00207E  2  A9 4F                LDA     #XSIZE          ; PRINT THE ENTIRE
002080  2  85 BD                STA     LENGTH          ; STATUS LINE
002082  2  20 34 1F             JSR     CR1
002085  2               
002085  2  A2 4F                LDX     #XSIZE          ; RESTORE OLD [LBUFF]
002087  2               USLX:
002087  2  BD 20 0D             LDA     BUFSAV,X
00208A  2  9D 40 07             STA     LBUFF,X
00208D  2  CA                   DEX
00208E  2  10 F7                BPL     USLX
002090  2               
002090  2  68                   PLA                     ; RESTORE ALL
002091  2  85 BB                STA     DIGITS          ; SAVED VARIABLES
002093  2  68                   PLA
002094  2  85 AD                STA     ZFLAG
002096  2  68                   PLA
002097  2  85 AE                STA     ZWORD+LO
002099  2  68                   PLA
00209A  2  85 AF                STA     ZWORD+HI
00209C  2  68                   PLA
00209D  2  85 A9                STA     PSET
00209F  2  68                   PLA
0020A0  2  85 AA                STA     TSET
0020A2  2  68                   PLA
0020A3  2  85 7C                STA     MPCL
0020A5  2  68                   PLA
0020A6  2  85 7D                STA     MPCM
0020A8  2  68                   PLA
0020A9  2  85 7E                STA     MPCH
0020AB  2  68                   PLA
0020AC  2  85 BD                STA     LENGTH
0020AE  2               
0020AE  2  A2 00                LDX     #0              ; RESTORE CURSOR
0020B0  2  A0 18                LDY     #YSIZE
0020B2  2  18                   CLC
0020B3  2  20 CA 21             JSR     PLOT
0020B6  2               ;
0020B6  2  A2 FF                LDX     #$FF
0020B8  2  86 BF                STX     SCRIPT          ; RE-ENABLE SCRIPTING
0020BA  2  E8                   INX                     ; = 0
0020BB  2  86 7F                STX     MPCFLG          ; INVALIDATE [MPC]
0020BD  2  E8                   INX                     ; = 1
0020BE  2  20 3B 22             JSR     UNBOLD
0020C1  2  60                   RTS
0020C2  2               
0020C2  1                       .INCLUDE "machine.asm"
0020C2  2               ;        PAGE
0020C2  2               ;        SBTTL   "--- MACHINE-DEPENDENT I/O: DOS/65 ---"
0020C2  2               
0020C2  2               ; ----------------------------
0020C2  2               ; FETCH ASCII KEYCODE INTO [A]
0020C2  2               ; ----------------------------
0020C2  2               
0020C2  2               ; EXIT: ASCII IN [A] & [IOCHAR]
0020C2  2               
0020C2  2               GETKEY:
0020C2  2  8A                   TXA                     ; SAVE [X] & [Y]
0020C3  2  48                   PHA
0020C4  2  98                   TYA
0020C5  2  48                   PHA
0020C6  2               GKEY1:
0020C6  2  A2 06                LDX     #6              ;  GET KEY INTO [A]
0020C8  2  20 03 01             JSR     PEM             ;
0020CB  2  C9 00                CMP     #$00
0020CD  2  F0 F7                BEQ     GKEY1           ; NOT IF CODE WAS ZERO
0020CF  2               
0020CF  2  C9 0D                CMP     #EOL            ; EOL?
0020D1  2  F0 24                BEQ     GOODKEY
0020D3  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
0020D5  2  F0 20                BEQ     GOODKEY
0020D7  2  C9 20                CMP     #SPACE          ; ANYTHING ELSE < "SPACE"
0020D9  2  90 16                BCC     BADKEY          ; IS BAD
0020DB  2               
0020DB  2  C9 7B                CMP     #'z'+1
0020DD  2  B0 12                BCS     BADKEY
0020DF  2  C9 61                CMP     #'a'
0020E1  2  B0 14                BCS     GOODKEY
0020E3  2               
0020E3  2  C9 41                CMP     #'A'            ; TO ASCII LOWER CASE
0020E5  2  90 10                BCC     GOODKEY
0020E7  2  C9 5B                CMP     #'Z'+1
0020E9  2  B0 06                BCS     BADKEY
0020EB  2  18                   CLC
0020EC  2  69 20                ADC     #$20
0020EE  2  4C F7 20             JMP     GOODKEY
0020F1  2               
0020F1  2               BADKEY:
0020F1  2  20 C2 21             JSR     BOOP            ; REJECT BAD KEYPRESS
0020F4  2  4C C6 20             JMP     GKEY1           ; AND TRY AGAIN
0020F7  2               
0020F7  2               GOODKEY:
0020F7  2  85 C4                STA     IOCHAR          ; SAVE KEYCODE HERE
0020F9  2  68                   PLA                     ; RESTORE [X] & [Y]
0020FA  2  A8                   TAY
0020FB  2  68                   PLA
0020FC  2  AA                   TAX
0020FD  2  A5 C4                LDA     IOCHAR          ; GET KEYCODE HERE
0020FF  2               
0020FF  2  60                   RTS
002100  2               
002100  2               ; -------------------------
002100  2               ; OUTPUT AN ASCII CHARACTER
002100  2               ; -------------------------
002100  2               CHAR:
002100  2               LETTER:
002100  2  85 C4                STA     IOCHAR          ; SAVE HERE
002102  2  48                   PHA                     ; SAVE [A]
002103  2  8A                   TXA                     ; SAVE [X] & [Y]
002104  2  48                   PHA
002105  2  98                   TYA
002106  2  48                   PHA
002107  2  A5 C4                LDA     IOCHAR
002109  2  C9 0D                CMP     #13
00210B  2  D0 0B                BNE     :+
00210D  2  E6 C2                INC     LINCNT
00210F  2  A9 0A                LDA     #10             ;  IS A CR, SO ADD A LF
002111  2  A2 02                LDX     #2              ;
002113  2  20 03 01             JSR     PEM             ;
002116  2  A9 0D                LDA     #13
002118  2               :
002118  2  A2 02                LDX     #2              ;  OUTPUT CHAR FROM [A]
00211A  2  20 03 01             JSR     PEM             ;
00211D  2               
00211D  2  68                   PLA                     ; RESTORE [X] & [Y]
00211E  2  A8                   TAY
00211F  2  68                   PLA
002120  2  AA                   TAX
002121  2  68                   PLA
002122  2  60                   RTS
002123  2               
002123  2               
002123  2               
002123  2               ; ---------------------
002123  2               ; FETCH A LINE OF INPUT
002123  2               ; ---------------------
002123  2               
002123  2               ; ENTRY: ABS ADDR OF READ BUFFER IN [ARG1]
002123  2               ; EXIT: # CHARS READ IN [A]
002123  2               
002123  2               INPUT:
002123  2  20 3D 1F             JSR     LINOUT          ; FLUSH [LBUFF]
002126  2               
002126  2  20 3A 23             JSR     CURSON          ; ACTIVATE CURSOR, CLEAR KEY QUEUE
002129  2               
002129  2  A0 00                LDY     #0
00212B  2  84 C2                STY     LINCNT          ; RESET LINE COUNT
00212D  2               
00212D  2               INLOOP:
00212D  2  20 C2 20             JSR     GETKEY          ; GET ASCII INTO [A] AND [IOCHAR]
002130  2               
002130  2  C9 0D                CMP     #EOL            ; EOL?
002132  2  F0 2A                BEQ     ENDLIN          ; LINE DONE IF SO
002134  2  C9 08                CMP     #BACKSP         ; BACKSPACE?
002136  2  F0 1C                BEQ     BACKUP          ; SPECIAL HANDLING
002138  2               
002138  2  99 40 07             STA     LBUFF,Y         ; ELSE ADD CHAR TO INPUT BUFFER
00213B  2  C8                   INY                     ; NEXT POSITION IN LINE
00213C  2               
00213C  2               SHOWIT:
00213C  2  20 00 21             JSR     CHAR            ; SEND TO SCREEN
00213F  2               
00213F  2  C0 4D                CPY     #77             ; 2 SCREEN LINES FULL?
002141  2  90 EA                BCC     INLOOP          ; NO, GET ANOTHER CHAR
002143  2               
002143  2               ; HANDLE LINE OVERFLOW
002143  2               
002143  2               NOMORE:
002143  2  20 C2 20             JSR     GETKEY
002146  2  C9 0D                CMP     #EOL            ; IF EOL,
002148  2  F0 14                BEQ     ENDLIN          ; WRAP UP THE LINE
00214A  2  C9 08                CMP     #BACKSP         ; BACKSPACE
00214C  2  F0 06                BEQ     BACKUP          ; IS OKAY TOO
00214E  2  20 C2 21             JSR     BOOP            ; ELSE COMPLAIN
002151  2  4C 43 21             JMP     NOMORE          ; AND INSIST
002154  2               
002154  2               ; HANDLE BACKSPACE
002154  2               
002154  2               BACKUP:
002154  2  88                   DEY                     ; BACK UP THE POINTER
002155  2  10 E5                BPL     SHOWIT          ; SEND BS IF NOT START OF LINE
002157  2  20 C2 21             JSR     BOOP            ; ELSE SCREAM WITH PAIN
00215A  2  A0 00                LDY     #0              ; RESET POINTER
00215C  2  F0 CF                BEQ     INLOOP          ; AND WAIT FOR SOMETHING BETTER
00215E  2               
00215E  2               ; HANDLE END OF LINE
00215E  2               
00215E  2               ENDLIN:
00215E  2  99 40 07             STA     LBUFF,Y         ; SHIP EOL TO BUFFER
002161  2  C8                   INY                     ; UPDATE INDEX
002162  2  84 A2                STY     LINLEN          ; SAVE HERE FOR "READ"
002164  2  84 CC                STY     PRLEN           ; AND HERE FOR "PPRINT"
002166  2  A2 00                LDX     #0
002168  2  20 00 21             JSR     CHAR            ; AND SEND EOL TO SCREEN
00216B  2               
00216B  2               ; MOVE [LBUFF] TO [ARG1] W/LC CONVERSION
00216B  2               
00216B  2               LEX1:
00216B  2  B9 3F 07             LDA     LBUFF-1,Y       ; GET A CHAR FROM [LBUFF]
00216E  2  91 62                STA     (ARG1),Y        ; MOVE CHAR TO INPUT BUFFER AT [ARG1]
002170  2  88                   DEY                     ; LOOP TILL
002171  2  D0 F8                BNE     LEX1            ; ALL CHARS MOVED ("BNE" 8/14/85 BM)
002173  2               
002173  2  20 8F 21             JSR     PPRINT          ; SCRIPT [LBUFF] IF ENABLED
002176  2               
002176  2  A5 A2                LDA     LINLEN          ; RESTORE # CHARS
002178  2  60                   RTS                     ; INTO [A]
002179  2               
002179  2               ; -----------------------
002179  2               ; DIRECT PRINT LINE [X/A]
002179  2               ; -----------------------
002179  2               
002179  2               ; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
002179  2               ;        STRING LENGTH IN [Y]
002179  2               
002179  2               DLINE:
002179  2  8E 82 21             STX     STRING+LO       ; DROP STRING ADDRESS
00217C  2  8D 83 21             STA     STRING+HI       ; INTO DUMMY BYTES
00217F  2               
00217F  2  A2 00                LDX     #0              ; INIT CHAR-FETCH INDEX
002181  2               
002181  2               DOUT:
002181  2  BD                   .BYTE   $BD             ; 6502 "LDA nnnn,X" OPCODE
002182  2               STRING:
002182  2  00 00                .WORD   $0000           ; DUMMY OPERAND BYTES
002184  2  20 00 21             JSR     CHAR
002187  2  E8                   INX
002188  2  88                   DEY                     ; LOOP TILL
002189  2  C0 00                CPY     #$00
00218B  2  D0 F4                BNE     DOUT            ; NOT OUT OF CHARS
00218D  2  60                   RTS
00218E  2               
00218E  2               ; -----------------------
00218E  2               ; SEND [LBUFF] TO PRINTER
00218E  2               ; -----------------------
00218E  2               
00218E  2               ; ENTRY: LENTH OF LINE IN [PRLEN]
00218E  2               ; NOW WITH IMPROVED ERROR PROTECTION! (BM 11/24/84)
00218E  2               
00218E  2               SFLAG:
00218E  2  00                   .BYTE   0               ; PREVIOUS SCRIPT MODE (BM 5/14/85)
00218F  2               
00218F  2               PPRINT:
00218F  2  A5 BF                LDA     SCRIPT          ; SCRIPTING INTERNALLY ENABLED?
002191  2  F0 2C                BEQ     PEX             ; NO, SCRAM IMMEDIATELY
002193  2               
002193  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1 ; CHECK SCRIPT FLAG
002196  2  29 01                AND     #%00000001      ; SCRIPTING ON?
002198  2  F0 1B                BEQ     PP3             ; NO, CHECK FOR "UNSCRIPT"
00219A  2               
00219A  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
00219C  2  30 21                BMI     PEX             ; CAN'T OPEN IF NEGATIVE
00219E  2  D0 04                BNE     PP1             ; ALREADY OPEN, SCRIPT THE LINE
0021A0  2               
0021A0  2               ; OPEN THE PRINTER FOR OUTPUT
0021A0  2  A2 01                LDX     #1
0021A2  2  86 CB                STX     PSTAT           ; SET STATUS TO "PRINTER OPENED" (1)
0021A4  2               
0021A4  2               PP1:
0021A4  2  A0 00                LDY     #0              ; INIT INDEX
0021A6  2               PP2:
0021A6  2               
0021A6  2  B9 40 07             LDA     LBUFF,Y
0021A9  2  A2 05                LDX     #5              ;  OUTPUT CHAR FROM [A] TO PRINTER (LST)
0021AB  2  20 03 01             JSR     PEM             ;
0021AE  2  C8                   INY
0021AF  2  C6 CC                DEC     PRLEN
0021B1  2  D0 F3                BNE     PP2
0021B3  2  F0 0A                BEQ     PEX             ; RESET & RETURN
0021B5  2               
0021B5  2               ; CHECK FOR "UNSCRIPT"
0021B5  2               
0021B5  2               PP3:
0021B5  2  A5 CB                LDA     PSTAT           ; CHECK PRINTER STATUS
0021B7  2  F0 06                BEQ     PEX             ; EXIT IF PRINTER WAS OFF
0021B9  2  30 04                BMI     PEX             ; OR UNOPENABLE
0021BB  2               
0021BB  2               PCLOSE:
0021BB  2  A9 00                LDA     #0              ; RESET PRINTER STATUS FLAG
0021BD  2  85 CB                STA     PSTAT           ; TO "CLOSED"
0021BF  2               
0021BF  2               PEX:
0021BF  2  60                   RTS
0021C0  2               
0021C0  2               ; ------------
0021C0  2               ; SPLIT SCREEN
0021C0  2               ; ------------
0021C0  2               ; NO SPLIT SCREEN IN DOS/65
0021C0  2               ZSPLIT:
0021C0  2               OFFSPL:
0021C0  2  60                   RTS
0021C1  2               
0021C1  2               ; ------
0021C1  2               ; SCREEN
0021C1  2               ; ------
0021C1  2               
0021C1  2               ; GO TO TOP WINDOW IF [A] = 0
0021C1  2               ; GO TO BOTTOM IF [A] = 1
0021C1  2               ; IGNORE IF SPLIT NOT ENABLED OR [A] <> 0 OR 1
0021C1  2               ZSCRN:
0021C1  2               ; SET TO TOP WINDOW
0021C1  2               TOTOP:
0021C1  2               ; SET TO BOTTOM WINDOW
0021C1  2               TOBOT:
0021C1  2               DOSCRN:
0021C1  2  60                   RTS
0021C2  2               
0021C2  2               ; ---------
0021C2  2               ; RAZZ USER
0021C2  2               ; ---------
0021C2  2               
0021C2  2               BOOP:
0021C2  2  A9 07                LDA     #7
0021C4  2  A2 02                LDX     #2
0021C6  2  20 03 01             JSR     PEM
0021C9  2  60                   RTS
0021CA  2               
0021CA  2               
0021CA  2               PLOT:
0021CA  2               ; ENTRY: [X] = X COORD
0021CA  2               ;        [Y] = Y COORD
0021CA  2               ; Convert X coordinate to 2 ASCII digits in PLOTCOLVAL
0021CA  2  8A                   TXA                     ; Get X value
0021CB  2  A2 01                LDX     #1              ; Start with ones digit
0021CD  2               ; Divide by 10 repeatedly to get digits
0021CD  2               :
0021CD  2  C9 0A                CMP     #10
0021CF  2  90 06                BCC     :+              ; Branch if < 10
0021D1  2  E9 0A                SBC     #10
0021D3  2  E8                   INX                     ; Count number of 10s
0021D4  2  4C CD 21             JMP     :-
0021D7  2               :
0021D7  2  18                   CLC
0021D8  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
0021DA  2  8D 0E 22             STA     PLOTCOLVAL+1    ; Store ones digit
0021DD  2               
0021DD  2  8A                   TXA                     ; Get tens digit count
0021DE  2  18                   CLC
0021DF  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021E1  2  8D 0D 22             STA     PLOTCOLVAL      ; Store tens digit
0021E4  2               ; Convert Y coordinate to 2 ASCII digits in PLOTROWVAL
0021E4  2  98                   TYA                     ; Get Y value
0021E5  2  A2 01                LDX     #1              ; Start with ones digit
0021E7  2               ; Divide by 10 repeatedly to get digits
0021E7  2               :
0021E7  2  C9 0A                CMP     #10
0021E9  2  90 06                BCC     :+              ; Branch if < 10
0021EB  2  E9 0A                SBC     #10
0021ED  2  E8                   INX                     ; Count number of 10s
0021EE  2  4C E7 21             JMP     :-
0021F1  2               :
0021F1  2  18                   CLC
0021F2  2  69 30                ADC     #'0'            ; Convert remainder to ASCII
0021F4  2  8D 0B 22             STA     PLOTROWVAL+1    ; Store ones digit
0021F7  2               
0021F7  2  8A                   TXA                     ; Get tens digit count
0021F8  2  18                   CLC
0021F9  2  69 2F                ADC     #'0'-1          ; Convert to ASCII (-1 since we started at 1)
0021FB  2  8D 0A 22             STA     PLOTROWVAL      ; Store tens digit
0021FE  2               ;
0021FE  2  A2 08                LDX     #<PLOTSTRING
002200  2  A9 22                LDA     #>PLOTSTRING
002202  2  A0 08                LDY     #8
002204  2  20 79 21             JSR     DLINE
002207  2  60                   RTS
002208  2               PLOTSTRING:
002208  2  1B 5B                .BYTE   27,"["
00220A  2               PLOTROWVAL:
00220A  2  30 30                .BYTE   "00"
00220C  2  3B                   .BYTE   ";"
00220D  2               PLOTCOLVAL:
00220D  2  30 30                .BYTE   "00"
00220F  2  48                   .BYTE   "H"
002210  2               
002210  2               ; ------------------------
002210  2               ; CLEAR SCREEN
002210  2               ; ------------------------
002210  2               
002210  2               CLS:
002210  2  A9 14                LDA     #20
002212  2  85 C3                STA     LMAX
002214  2  A2 29                LDX     #<CLSSTRING
002216  2  A9 22                LDA     #>CLSSTRING
002218  2  A0 04                LDY     #4
00221A  2  20 79 21             JSR     DLINE
00221D  2  A9 00                LDA     #0
00221F  2  85 C2                STA     LINCNT          ; RESET LINE COUNTER
002221  2  A2 00                LDX     #0
002223  2  A0 18                LDY     #YSIZE
002225  2  20 CA 21             JSR     PLOT
002228  2  60                   RTS
002229  2               CLSSTRING:
002229  2  1B 5B 32 4A          .BYTE   27,"[2J"
00222D  2               
00222D  2               BOLD:
00222D  2  A2 37                LDX     #<BOLDSTRING
00222F  2  A9 22                LDA     #>BOLDSTRING
002231  2  A0 04                LDY     #4
002233  2  20 79 21             JSR     DLINE
002236  2  60                   RTS
002237  2               BOLDSTRING:
002237  2  1B 5B 31 6D          .BYTE   27,"[1m"
00223B  2               
00223B  2               UNBOLD:
00223B  2  A2 45                LDX     #<UNBOLDSTRING
00223D  2  A9 22                LDA     #>UNBOLDSTRING
00223F  2  A0 04                LDY     #4
002241  2  20 79 21             JSR     DLINE
002244  2  60                   RTS
002245  2               UNBOLDSTRING:
002245  2  1B 5B 30 6D          .BYTE   27,"[0m"
002249  2               
002249  2               REVERSE:
002249  2  A2 53                LDX     #<REVERSESTRING
00224B  2  A9 22                LDA     #>REVERSESTRING
00224D  2  A0 04                LDY     #4
00224F  2  20 79 21             JSR     DLINE
002252  2  60                   RTS
002253  2               REVERSESTRING:
002253  2  1B 5B 37 6D          .BYTE   27,"[7m"
002257  2               
002257  1                       .INCLUDE "zdos.asm"
002257  2               ;        PAGE
002257  2               ;        SBTTL   "--- Z-DOS: DOS/65 ---"
002257  2               
002257  2               ; ---------------------
002257  2               ; GET Z-BLOCK FROM DISK
002257  2               ; ---------------------
002257  2               
002257  2               ; ENTRY: Z-BLOCK # IN [BLOCK]
002257  2               ;        TARGET PAGE IN [DBUFF+HI]
002257  2               GETDSK:
002257  2  D8                   CLD
002258  2  18                   CLC
002259  2               
002259  2  A5 CD                LDA     DBLOCK+LO       ; Load low byte of DBLOCK
00225B  2  0A                   ASL     A               ; Multiply by 2
00225C  2  8D 6E 25             STA     D65BLOCK+LO     ; Store low byte
00225F  2  A5 CE                LDA     DBLOCK+HI       ; Load high byte of DBLOCK
002261  2  2A                   ROL     A               ; Rotate left (gets carry from previous ASL)
002262  2  8D 6F 25             STA     D65BLOCK+HI     ; Store high byte
002265  2               
002265  2               ; read 256 byte block (zblock should be file block*2)
002265  2               ; EXTENT = INTEGER.PART.OF(n/128)
002265  2               ; 16 bit shift x6
002265  2  AD 6E 25             LDA     D65BLOCK+LO     ; CALCULATE EXTENT
002268  2  0A                   ASL     A
002269  2  85 DE                STA     DTEMP+LO
00226B  2  AD 6F 25             LDA     D65BLOCK+HI
00226E  2  2A                   ROL     A
00226F  2  8D 38 25             STA     GAMEFCB+12      ; = EXTENT (MAGIC!)
002272  2               
002272  2  AD 6E 25             LDA     D65BLOCK+LO     ; CALCULATE RECORD = n-(EXTENT*128)
002275  2  29 7F                AND     #$7F
002277  2  8D 4C 25             STA     GAMEFCB+32      ; Store Record Number into FCB (Also Magic!)
00227A  2               
00227A  2  A9 2C                LDA     #<GAMEFCB       ; Open Extent
00227C  2  A0 25                LDY     #>GAMEFCB
00227E  2  A2 0F                LDX     #15
002280  2  20 03 01             JSR     PEM
002283  2  C9 FF                CMP     #$FF
002285  2  F0 48                BEQ     GETDSKERR
002287  2               
002287  2  A9 00                LDA     #0              ; Set Buffer Address
002289  2  A4 D0                LDY     DBUFF+HI
00228B  2  A2 1A                LDX     #26
00228D  2  20 03 01             JSR     PEM
002290  2               
002290  2  A9 2C                LDA     #<GAMEFCB       ; Read First sector (128 bytes)
002292  2  A0 25                LDY     #>GAMEFCB
002294  2  A2 14                LDX     #20
002296  2  20 03 01             JSR     PEM
002299  2  C9 FF                CMP     #$FF
00229B  2  F0 32                BEQ     GETDSKERR
00229D  2               
00229D  2  A9 80                LDA     #$80            ; Set Buffer Address
00229F  2  A4 D0                LDY     DBUFF+HI
0022A1  2  A2 1A                LDX     #26
0022A3  2  20 03 01             JSR     PEM
0022A6  2               
0022A6  2  A9 2C                LDA     #<GAMEFCB       ; Read Second sector (128 bytes)
0022A8  2  A0 25                LDY     #>GAMEFCB
0022AA  2  A2 14                LDX     #20
0022AC  2  20 03 01             JSR     PEM
0022AF  2  C9 FF                CMP     #$FF
0022B1  2  F0 1C                BEQ     GETDSKERR
0022B3  2               
0022B3  2  A9 6E                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
0022B5  2  A0 25                LDY     #>SPAREBYTES
0022B7  2  A2 1A                LDX     #26
0022B9  2  20 03 01             JSR     PEM
0022BC  2               
0022BC  2  A9 2C                LDA     #<GAMEFCB       ; Close Extent
0022BE  2  A0 25                LDY     #>GAMEFCB
0022C0  2  A2 10                LDX     #16
0022C2  2  20 03 01             JSR     PEM
0022C5  2               
0022C5  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
0022C7  2  E6 CD                INC     DBLOCK+LO       ; POINT TO NEXT
0022C9  2  D0 02                BNE     :+              ; Z-BLOCK
0022CB  2  E6 CE                INC     DBLOCK+HI
0022CD  2               :
0022CD  2  18                   CLC
0022CE  2  60                   RTS
0022CF  2               GETDSKERR:
0022CF  2  A9 0E                LDA     #14
0022D1  2  4C EB 1D             JMP     ZERROR
0022D4  2               
0022D4  2               
0022D4  2               ; ENTRY FOR "RESTORE" ([TRACK], [SECTOR] & [DRIVE] PRE-ASSIGNED)
0022D4  2               
0022D4  2               GETRES:
0022D4  2               
0022D4  2  A9 00                LDA     #0              ; Set Buffer Address
0022D6  2  A4 D0                LDY     DBUFF+HI
0022D8  2  A2 1A                LDX     #26
0022DA  2  20 03 01             JSR     PEM
0022DD  2               
0022DD  2  A9 4D                LDA     #<SAVEFCB       ; READ Record
0022DF  2  A0 25                LDY     #>SAVEFCB
0022E1  2  A2 14                LDX     #20
0022E3  2  20 03 01             JSR     PEM
0022E6  2               
0022E6  2  A9 80                LDA     #$80            ; Set Buffer Address
0022E8  2  A4 D0                LDY     DBUFF+HI
0022EA  2  A2 1A                LDX     #26
0022EC  2  20 03 01             JSR     PEM
0022EF  2               
0022EF  2  A9 4D                LDA     #<SAVEFCB       ; READ Record
0022F1  2  A0 25                LDY     #>SAVEFCB
0022F3  2  A2 14                LDX     #20
0022F5  2  20 03 01             JSR     PEM
0022F8  2               
0022F8  2  C9 FF                CMP     #$FF
0022FA  2  F0 2E                BEQ     WRTERR
0022FC  2  4C 27 23             JMP     NXTSEC          ; POINT TO NEXT SECTOR & PAGE
0022FF  2               
0022FF  2               ; --------------------
0022FF  2               ; PUT [DBLOCK] TO DISK
0022FF  2               ; --------------------
0022FF  2               
0022FF  2               ;        PAGE TO WRITE IN [DBUFF]
0022FF  2               
0022FF  2               PUTDSK:
0022FF  2               
0022FF  2  A9 00                LDA     #0              ; Set Buffer Address
002301  2  A4 D0                LDY     DBUFF+HI
002303  2  A2 1A                LDX     #26
002305  2  20 03 01             JSR     PEM
002308  2               
002308  2  A9 4D                LDA     #<SAVEFCB       ; Write Record
00230A  2  A0 25                LDY     #>SAVEFCB
00230C  2  A2 15                LDX     #21
00230E  2  20 03 01             JSR     PEM
002311  2               
002311  2  A9 80                LDA     #$80            ; Set Buffer Address
002313  2  A4 D0                LDY     DBUFF+HI
002315  2  A2 1A                LDX     #26
002317  2  20 03 01             JSR     PEM
00231A  2               
00231A  2  A9 4D                LDA     #<SAVEFCB       ; Write Record
00231C  2  A0 25                LDY     #>SAVEFCB
00231E  2  A2 15                LDX     #21
002320  2  20 03 01             JSR     PEM
002323  2               
002323  2  C9 FF                CMP     #$FF
002325  2  F0 03                BEQ     WRTERR
002327  2               NXTSEC:
002327  2  E6 D0                INC     DBUFF+HI        ; POINT TO NEXT RAM PAGE
002329  2  60                   RTS
00232A  2               WRTERR:
00232A  2  38                   SEC
00232B  2  60                   RTS
00232C  2               
00232C  2               
00232C  2               DSXERR:
00232C  2  A9 0E                LDA     #14
00232E  2               
00232E  2               QERR:
00232E  2  4C EB 1D             JMP     ZERROR
002331  2               
002331  2               ; -----------------------------
002331  2               ; SET UP SAVE & RESTORE SCREENS
002331  2               ; -----------------------------
002331  2               
002331  2               SAVRES:
002331  2  20 0A 1F             JSR     ZCRLF           ; CLEAR THE BUFFER
002334  2  A2 00                LDX     #0
002336  2  86 BF                STX     SCRIPT          ; DISABLE SCRIPTING
002338  2  18                   CLC
002339  2  60                   RTS
00233A  2               
00233A  2               
00233A  2               
00233A  2               ; FALL THROUGH ...
00233A  2               
00233A  2               ; --------------------------------
00233A  2               ; ACTIVATE CURSOR, CLEAR KEY QUEUE
00233A  2               ; --------------------------------
00233A  2               
00233A  2               CURSON:
00233A  2  60                   RTS
00233B  2               
00233B  2               ; -----------------------------
00233B  2               ; GET SAVE & RESTORE PARAMETERS
00233B  2               ; -----------------------------
00233B  2               
00233B  2               FILENAME:
00233B  2  0D                   .BYTE   EOL
00233C  2  46 69 6C 65          .BYTE   "File Name:"
002340  2  20 4E 61 6D  
002344  2  65 3A        
002346  2               FILENAMEL       = *-FILENAME
002346  2               
002346  2               NO:
002346  2  4E 6F                .BYTE   "No"
002348  2               NOL             = *-NO
002348  2               
002348  2               YES:
002348  2  59 65 73             .BYTE   "Yes"
00234B  2               YESL            = *-YES
00234B  2               
00234B  2               
00234B  2               
00234B  2               
00234B  2               ALLSET:
00234B  2  A2 48                LDX     #<YES           ; PRINT "YES"
00234D  2  A9 23                LDA     #>YES
00234F  2  A0 03                LDY     #YESL
002351  2  20 79 21             JSR     DLINE
002354  2               
002354  2               
002354  2               ; ---------------------
002354  2               ; "PRESS RETURN" PROMPT
002354  2               ; ---------------------
002354  2               
002354  2               RETURN:
002354  2  A2 6E                LDX     #<RTN
002356  2  A9 23                LDA     #>RTN
002358  2  A0 1E                LDY     #RTNL
00235A  2  20 79 21             JSR     DLINE           ; SHOW PROMPT
00235D  2               
00235D  2               ; ENTRY FOR QUIT/RESTART
00235D  2               
00235D  2               GETRET:
00235D  2  20 3A 23             JSR     CURSON          ; ENABLE CURSOR
002360  2               
002360  2               GTRT:
002360  2  20 C2 20             JSR     GETKEY          ; WAIT FOR [RETURN]
002363  2  C9 0D                CMP     #EOL
002365  2  F0 06                BEQ     RETEX
002367  2  20 C2 21             JSR     BOOP            ; ACCEPT NO
00236A  2  4C 60 23             JMP     GTRT            ; SUBSTITUTES!
00236D  2               
00236D  2               RETEX:
00236D  2  60                   RTS
00236E  2               
00236E  2               RTN:
00236E  2  0D                   .BYTE   EOL
00236F  2  50 72 65 73          .BYTE   "Press [RETURN] to continue."
002373  2  73 20 5B 52  
002377  2  45 54 55 52  
00238A  2  0D                   .BYTE   EOL
00238B  2  3E                   .BYTE   ">"
00238C  2               RTNL            = *-RTN
00238C  2               
00238C  2               
00238C  2               ; -------------------------
00238C  2               ; SET UP PHONEY STATUS LINE
00238C  2               ; -------------------------
00238C  2               
00238C  2               ; ENTRY: TEXT SET UP FOR "DLINE"
00238C  2               
00238C  2               SROOM:
00238C  2  60                   RTS
00238D  2               
00238D  2               ; ---------
00238D  2               ; SAVE GAME
00238D  2               ; ---------
00238D  2               
00238D  2               
00238D  2               
00238D  2               ZSAVE:
00238D  2  20 A3 24             JSR     GETFILENAME
002390  2  A9 4D                LDA     #<SAVEFCB       ; Open Extent
002392  2  A0 25                LDY     #>SAVEFCB
002394  2  A2 16                LDX     #22
002396  2  20 03 01             JSR     PEM
002399  2  C9 FF                CMP     #$FF
00239B  2  F0 03                BEQ     BADSAV
00239D  2               
00239D  2  4C A3 23             JMP     DOSAVE          ; ERROR IF CARRY SET
0023A0  2               
0023A0  2               BADSAV:
0023A0  2  4C 29 11             JMP     PREDF           ; PREDICATE FAILS
0023A3  2               
0023A3  2               DOSAVE:
0023A3  2               
0023A3  2               ; SAVE GAME PARAMETERS IN [BUFSAV]
0023A3  2               
0023A3  2  AD 02 2B             LDA     ZBEGIN+ZID      ; MOVE GAME ID
0023A6  2  8D 20 0D             STA     BUFSAV+0        ; INTO 1ST 2 BYTES
0023A9  2  AD 03 2B             LDA     ZBEGIN+ZID+1    ; OF THE AUX LINE BUFFER
0023AC  2  8D 21 0D             STA     BUFSAV+1
0023AF  2               
0023AF  2  A5 74                LDA     ZSP             ; MOVE [ZSP]
0023B1  2  8D 22 0D             STA     BUFSAV+2        ; TO 3RD BYTE
0023B4  2  A5 75                LDA     OLDZSP          ; MOVE [OLDZSP]
0023B6  2  8D 23 0D             STA     BUFSAV+3        ; TO 4TH
0023B9  2               
0023B9  2  A2 02                LDX     #2              ; MOVE CONTENTS OF [ZPC]
0023BB  2               ZPCSAV:
0023BB  2  B5 76                LDA     ZPC,X           ; TO BYTES 5-7
0023BD  2  9D 24 0D             STA     BUFSAV+4,X      ; OF [BUFSAV]
0023C0  2  CA                   DEX
0023C1  2  10 F8                BPL     ZPCSAV
0023C3  2               
0023C3  2               ; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
0023C3  2               
0023C3  2  A9 0D                LDA     #>LOCALS
0023C5  2  85 D0                STA     DBUFF+HI        ; POINT TO THE PAGE
0023C7  2  20 FF 22             JSR     PUTDSK          ; AND WRITE IT OUT
0023CA  2  B0 D4                BCS     BADSAV          ; CATCH WRITE ERROR HERE
0023CC  2               
0023CC  2               ; WRITE CONTENTS OF Z-STACK TO DISK
0023CC  2               
0023CC  2  A9 09                LDA     #>ZSTAKL        ; POINT TO 1ST PAGE
0023CE  2  85 D0                STA     DBUFF+HI
0023D0  2  20 FF 22             JSR     PUTDSK          ; WRITE 1ST AND
0023D3  2  B0 CB                BCS     BADSAV
0023D5  2  20 FF 22             JSR     PUTDSK          ; 2ND PAGE OF Z-STACK
0023D8  2  B0 C6                BCS     BADSAV
0023DA  2               
0023DA  2               ; WRITE ENTIRE GAME PRELOAD TO DISK
0023DA  2               
0023DA  2  A5 83                LDA     ZCODE           ; POINT TO 1ST PAGE
0023DC  2  85 D0                STA     DBUFF+HI        ; OF PRELOAD
0023DE  2               
0023DE  2  AE 0E 2B             LDX     ZBEGIN+ZPURBT   ; GET # IMPURE PAGES
0023E1  2  E8                   INX                     ; USE FOR INDEXING
0023E2  2  86 6E                STX     I+LO
0023E4  2               
0023E4  2               LSAVE:
0023E4  2  20 FF 22             JSR     PUTDSK
0023E7  2  B0 B7                BCS     BADSAV
0023E9  2  C6 6E                DEC     I+LO
0023EB  2  D0 F7                BNE     LSAVE
0023ED  2               
0023ED  2  A9 6E                LDA     #<SPAREBYTES    ; Set Buffer Address
0023EF  2  A0 25                LDY     #>SPAREBYTES
0023F1  2  A2 1A                LDX     #26
0023F3  2  20 03 01             JSR     PEM
0023F6  2               
0023F6  2  A9 4D                LDA     #<SAVEFCB       ; Close
0023F8  2  A0 25                LDY     #>SAVEFCB
0023FA  2  A2 10                LDX     #16
0023FC  2  20 03 01             JSR     PEM
0023FF  2  4C 35 11             JMP     PREDS           ; ELSE PREDICATE SUCCEEDS
002402  2               
002402  2               ; ------------
002402  2               ; RESTORE GAME
002402  2               ; ------------
002402  2               
002402  2               ZREST:
002402  2  20 A3 24             JSR     GETFILENAME
002405  2  A9 4D                LDA     #<SAVEFCB       ; Open Extent
002407  2  A0 25                LDY     #>SAVEFCB
002409  2  A2 0F                LDX     #15
00240B  2  20 03 01             JSR     PEM
00240E  2  C9 FF                CMP     #$FF
002410  2  F0 30                BEQ     BADRES
002412  2               
002412  2  4C 15 24             JMP     DOREST          ; ERROR IF CARRY SET
002415  2               
002415  2               DOREST:
002415  2               ; SAVE LOCALS IN CASE OF ERROR
002415  2  A2 1F                LDX     #31
002417  2               LOCSAV:
002417  2  BD 00 0D             LDA     LOCALS,X        ; COPY ALL LOCALS
00241A  2  9D 6E 25             STA     SPAREBYTES,X    ; TO BOTTOM OF MACHINE STACK
00241D  2  CA                   DEX
00241E  2  10 F7                BPL     LOCSAV
002420  2               
002420  2  A9 0D                LDA     #>LOCALS
002422  2  85 D0                STA     DBUFF+HI
002424  2  20 D4 22             JSR     GETRES          ; RETRIEVE 1ST BLOCK OF PRELOAD
002427  2               
002427  2  AD 20 0D             LDA     BUFSAV+0        ; DOES 1ST BYTE OF SAVED GAME ID
00242A  2  CD 02 2B             CMP     ZBEGIN+ZID      ; MATCH THE CURRENT ID?
00242D  2  D0 08                BNE     WRONG           ; WRONG DISK IF NOT
00242F  2               
00242F  2  AD 21 0D             LDA     BUFSAV+1        ; WHAT ABOUT THE 2ND BYTE?
002432  2  CD 03 2B             CMP     ZBEGIN+ZID+1
002435  2  F0 0E                BEQ     RIGHT           ; CONTINUE IF BOTH BYTES MATCH
002437  2               
002437  2               ; HANDLE INCORRECT SAVE DISK
002437  2               
002437  2               WRONG:
002437  2  A2 1F                LDX     #31             ; RESTORE ALL SAVED LOCALS
002439  2               WR0:
002439  2  BD 6E 25             LDA     SPAREBYTES,X
00243C  2  9D 00 0D             STA     LOCALS,X
00243F  2  CA                   DEX
002440  2  10 F7                BPL     WR0
002442  2               
002442  2               BADRES:
002442  2  4C 29 11             JMP     PREDF           ; PREDICATE FAILS
002445  2               
002445  2               ; CONTINUE RESTORE
002445  2               
002445  2               RIGHT:
002445  2  AD 10 2B             LDA     ZBEGIN+ZSCRIP   ; SAVE BOTH FLAG BYTES
002448  2  85 6E                STA     I+LO
00244A  2  AD 11 2B             LDA     ZBEGIN+ZSCRIP+1
00244D  2  85 6F                STA     I+HI
00244F  2               
00244F  2  A9 09                LDA     #>ZSTAKL        ; RETRIEVE OLD CONTENTS OF
002451  2  85 D0                STA     DBUFF+HI        ; Z-STACK
002453  2  20 D4 22             JSR     GETRES          ; GET 1ST BLOCK OF Z-STACK
002456  2  20 D4 22             JSR     GETRES          ; AND 2ND BLOCK
002459  2               
002459  2  A5 83                LDA     ZCODE
00245B  2  85 D0                STA     DBUFF+HI
00245D  2  20 D4 22             JSR     GETRES          ; GET 1ST BLOCK OF PRELOAD
002460  2               
002460  2  A5 6E                LDA     I+LO            ; RESTORE THE STATE
002462  2  8D 10 2B             STA     ZBEGIN+ZSCRIP   ; OF THE FLAG WORD
002465  2  A5 6F                LDA     I+HI
002467  2  8D 11 2B             STA     ZBEGIN+ZSCRIP+1
00246A  2               
00246A  2  AD 0E 2B             LDA     ZBEGIN+ZPURBT   ; GET # PAGES TO LOAD
00246D  2  85 6E                STA     I+LO
00246F  2               
00246F  2               LREST:
00246F  2  20 D4 22             JSR     GETRES          ; FETCH THE REMAINDER
002472  2  C6 6E                DEC     I+LO            ; OF THE PRELOAD
002474  2  D0 F9                BNE     LREST
002476  2               
002476  2  A9 6E                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
002478  2  A0 25                LDY     #>SPAREBYTES
00247A  2  A2 1A                LDX     #26
00247C  2  20 03 01             JSR     PEM
00247F  2               
00247F  2  A9 4D                LDA     #<SAVEFCB       ; Close Extent
002481  2  A0 25                LDY     #>SAVEFCB
002483  2  A2 10                LDX     #16
002485  2  20 03 01             JSR     PEM
002488  2               
002488  2               
002488  2               ; RESTORE THE STATE OF THE SAVED GAME
002488  2               
002488  2  AD 22 0D             LDA     BUFSAV+2        ; RESTORE THE [ZSP]
00248B  2  85 74                STA     ZSP
00248D  2  AD 23 0D             LDA     BUFSAV+3        ; AND THE [OLDZSP]
002490  2  85 75                STA     OLDZSP
002492  2               
002492  2  A2 02                LDX     #2              ; RESTORE THE [ZPC]
002494  2               RESZPC:
002494  2  BD 24 0D             LDA     BUFSAV+4,X
002497  2  95 76                STA     ZPC,X
002499  2  CA                   DEX
00249A  2  10 F8                BPL     RESZPC
00249C  2               
00249C  2  A9 00                LDA     #FALSE
00249E  2  85 79                STA     ZPCFLG          ; INVALIDATE [ZPC]
0024A0  2  4C 35 11             JMP     PREDS           ; PREDICATE SUCCEEDS
0024A3  2               
0024A3  2               
0024A3  2               GETFILENAME:
0024A3  2               ; get filename and place in FCB
0024A3  2               ; then open file for write/create
0024A3  2  20 31 23             JSR     SAVRES          ; SET UP SCREEN
0024A6  2  A2 3B                LDX     #<FILENAME
0024A8  2  A9 23                LDA     #>FILENAME
0024AA  2  A0 0B                LDY     #FILENAMEL
0024AC  2  20 79 21             JSR     DLINE           ; "FILENAME ..."
0024AF  2               
0024AF  2  A9 20                LDA     #' '
0024B1  2  8D 4E 25             STA     SAVEFCB+1
0024B4  2  8D 4F 25             STA     SAVEFCB+2
0024B7  2  8D 50 25             STA     SAVEFCB+3
0024BA  2  8D 51 25             STA     SAVEFCB+4
0024BD  2  8D 52 25             STA     SAVEFCB+5
0024C0  2  8D 53 25             STA     SAVEFCB+6
0024C3  2  8D 54 25             STA     SAVEFCB+7
0024C6  2  8D 55 25             STA     SAVEFCB+8
0024C9  2               
0024C9  2  A9 6E                LDA     #<SPAREBYTES
0024CB  2  85 62                STA     ARG1
0024CD  2  A9 25                LDA     #>SPAREBYTES
0024CF  2  85 63                STA     ARG1+1
0024D1  2  20 23 21             JSR     INPUT
0024D4  2  C9 0A                CMP     #10
0024D6  2  90 02                BCC     :+
0024D8  2  A9 09                LDA     #9
0024DA  2               :
0024DA  2  AA                   TAX
0024DB  2  CA                   DEX
0024DC  2               GFNLOOP:
0024DC  2  BD 6E 25             LDA     SPAREBYTES,X
0024DF  2               
0024DF  2  C9 30                CMP     #'0'
0024E1  2  B0 05                BCS     :+
0024E3  2  A9 5F                LDA     #'_'
0024E5  2  4C 0E 25             JMP     GFNOK
0024E8  2               :
0024E8  2  C9 3A                CMP     #':'
0024EA  2  90 22                BCC     GFNOK
0024EC  2  C9 41                CMP     #'A'
0024EE  2  B0 05                BCS     :+
0024F0  2  A9 5F                LDA     #'_'
0024F2  2  4C 0E 25             JMP     GFNOK
0024F5  2               :
0024F5  2  C9 5B                CMP     #'Z'+1
0024F7  2  90 15                BCC     GFNOK
0024F9  2  C9 61                CMP     #'a'
0024FB  2  B0 05                BCS     :+
0024FD  2  A9 5F                LDA     #'_'
0024FF  2  4C 0E 25             JMP     GFNOK
002502  2               :
002502  2  C9 7B                CMP     #'z'+1
002504  2  90 05                BCC     :+
002506  2  A9 5F                LDA     #'_'
002508  2  4C 0E 25             JMP     GFNOK
00250B  2               :
00250B  2  38                   SEC
00250C  2  E9 20                SBC     #$20
00250E  2               GFNOK:
00250E  2  9D 4D 25             STA     SAVEFCB,X
002511  2  CA                   DEX
002512  2  10 C8                BPL     GFNLOOP
002514  2               
002514  2  A9 00                LDA     #0
002516  2  8D 4D 25             STA     SAVEFCB+0
002519  2  8D 59 25             STA     SAVEFCB+12
00251C  2  A9 53                LDA     #'S'
00251E  2  8D 56 25             STA     SAVEFCB+9
002521  2  A9 41                LDA     #'A'
002523  2  8D 57 25             STA     SAVEFCB+10
002526  2  A9 56                LDA     #'V'
002528  2  8D 58 25             STA     SAVEFCB+11
00252B  2  60                   RTS
00252C  2               
00252C  2               
00252C  2               
00252C  2               GAMEFCB:
00252C  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002530  2  00 00 00 00  
002534  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002538  2  00 00 00 00  
00253C  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002540  2  00 00 00 00  
002544  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002548  2  00 00 00 00  
00254C  2  00                   .BYTE   00
00254D  2               
00254D  2               SAVEFCB:
00254D  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002551  2  00 00 00 00  
002555  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002559  2  00 00 00 00  
00255D  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002561  2  00 00 00 00  
002565  2  00 00 00 00          .BYTE   00,00,00,00,00,00,00,00
002569  2  00 00 00 00  
00256D  2  00                   .BYTE   00
00256E  2               
00256E  2               SPAREBYTES:
00256E  2               D65BLOCK:
00256E  2  xx xx xx xx          .RES    256
002572  2  xx xx xx xx  
002576  2  xx xx xx xx  
00266E  2               
00266E  1                       .INCLUDE "disk.asm"
00266E  2               ;        PAGE
00266E  2               ;        SBTTL   "--- DISK ACCESS: DOS/65 ---"
00266E  2               
00266E  2               ; --------------
00266E  2               ; OPEN DRIVE [A]
00266E  2               ; WILL OPEN FILE SPECIFIED IN COMMAND LINE
00266E  2               ; --------------
00266E  2               DOPEN:
00266E  2  A2 0C                LDX     #12
002670  2               :
002670  2  CA                   DEX
002671  2  BD 07 01             LDA     DFLFCB,X
002674  2  9D 2C 25             STA     GAMEFCB,X
002677  2  E0 00                CPX     #00
002679  2  D0 F5                BNE     :-
00267B  2               
00267B  2  A9 2C                LDA     #<GAMEFCB       ; Open Extent
00267D  2  A0 25                LDY     #>GAMEFCB
00267F  2  A2 0F                LDX     #15
002681  2  20 03 01             JSR     PEM
002684  2  C9 FF                CMP     #$FF
002686  2  F0 13                BEQ     OPENDSKERR
002688  2               
002688  2  A9 6E                LDA     #<SPAREBYTES    ; Set Buffer Address to safe spot
00268A  2  A0 25                LDY     #>SPAREBYTES
00268C  2  A2 1A                LDX     #26
00268E  2  20 03 01             JSR     PEM
002691  2               
002691  2  A9 2C                LDA     #<GAMEFCB       ; Close Extent
002693  2  A0 25                LDY     #>GAMEFCB
002695  2  A2 10                LDX     #16
002697  2  20 03 01             JSR     PEM
00269A  2  60                   RTS
00269B  2               
00269B  2               OPENDSKERR:
00269B  2               
00269B  2  A2 A9                LDX     #<OPENERR
00269D  2  A9 26                LDA     #>OPENERR
00269F  2  A0 35                LDY     #OPENERRL
0026A1  2  20 79 21             JSR     DLINE
0026A4  2               
0026A4  2  A9 0E                LDA     #14
0026A6  2  4C EB 1D             JMP     ZERROR
0026A9  2               
0026A9  2               OPENERR:
0026A9  2  0D 0D 0D 0D          .BYTE   EOL,EOL,EOL,EOL
0026AD  2  55 6E 61 62          .BYTE   "Unable to open game file."
0026B1  2  6C 65 20 74  
0026B5  2  6F 20 6F 70  
0026C6  2  0D                   .BYTE   EOL
0026C7  2  55 53 41 47          .BYTE   "USAGE:  ZIP <GAMEFILE>"
0026CB  2  45 3A 20 20  
0026CF  2  5A 49 50 20  
0026DD  2  0D                   .BYTE   EOL
0026DE  2               OPENERRL        = *-OPENERR
0026DE  2               
0026DE  2               ; -------------------
0026DE  2               ; CLOSE CURRENT DRIVE
0026DE  2               ; -------------------
0026DE  2               
0026DE  2               DCLOSE:
0026DE  2  60                   RTS
0026DF  2               
0026DF  2               ; FALL THROUGH ...
0026DF  2               
0026DF  2               
0026DF  2               ; ----------------
0026DF  2               ; DIVIDE [A] BY 10
0026DF  2               ; ----------------
0026DF  2               
0026DF  2               ; EXIT: QUOTIENT IN [X], REMAINDER IN [A]
0026DF  2               
0026DF  2               DIV10:
0026DF  2  A2 00                LDX     #0              ; START WITH ZERO QUOTIENT
0026E1  2               
0026E1  2               D10L:
0026E1  2  C9 0A                CMP     #10             ; IF DIVISOR < 10,
0026E3  2  90 05                BCC     D10EX           ; WE'RE DONE
0026E5  2  E9 0A                SBC     #10             ; ELSE SUBTRACT ANOTHER 10
0026E7  2  E8                   INX                     ; UPDATE QUOTIENT
0026E8  2  D0 F7                BNE     D10L            ; BRANCH ALWAYS
0026EA  2               
0026EA  2               D10EX:
0026EA  2  60                   RTS
0026EB  2               
0026EB  1               
0026EB  1                       .IFDEF  DEBUG
0026EB  1                       .INCLUDE "bugger.asm"
0026EB  1                       .ENDIF
0026EB  1               
0026EB  1               ;        TITLE   "ZIP/6502-C INFOCOM, INC."
0026EB  1                       .END
