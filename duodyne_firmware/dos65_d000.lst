ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               .P816
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	DOS/65 for the Duodyne 65816
000000r 1               ;
000000r 1               ;  DWERNER 12/17/2023 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;       It is assumed that Bank 0 is not usable due to IO and ROM starting at DF00-FFFF
000000r 1               ;       OS will run in Bank $1D
000000r 1               ;       Drivers will run in Bank $1E
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               DOS65BANK       = $1D           ; Bank for DOS65
000000r 1               DOS65DRIVERSBNK = $1E           ; Bank for DOS65 Drivers
000000r 1               DOSSIZE         = OSEND-DOSBEGIN
000000r 1               DRIVERSIZE      = DRIVEREND-DRIVERBEGIN
000000r 1               
000000r 1                       .INCLUDE "MACROS.ASM"
000000r 2               ;___________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	USEFUL 65186 MACROS
000000r 2               ;__________________________________________________________________________________________________
000000r 2               
000000r 2               .macro       STORECONTEXT             ; Store Complete Context at the beginning of a Sub
000000r 2                       PHX
000000r 2                       phy
000000r 2                       pha
000000r 2                       php
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       RESTORECONTEXT                 ; Restore Complete Context at the end of a Sub
000000r 2                       plp
000000r 2                       pla
000000r 2                       ply
000000r 2                       plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       INDEX16                         ; Set 16bit Index Registers
000000r 2               		REP #$10 		; 16 bit Index registers
000000r 2               		.I16
000000r 2               .endmacro
000000r 2               .macro       INDEX8                          ; Set 8bit Index Registers
000000r 2               		SEP #$10 		; 8 bit Index registers
000000r 2               		.I8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR16                  ; Set 16bit Index Registers
000000r 2               		REP #$20 		; 16 bit Index registers
000000r 2               		.A16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR8                   ; Set 8bit Index Registers
000000r 2               		SEP #$20 		; 8 bit Index registers
000000r 2               		.A8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX16             ; Set 16bit Index Registers
000000r 2               		REP #$30 		; 16 bit Index registers
000000r 2               		.A16
000000r 2                               .I16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX8              ; Set 8bit Index Registers
000000r 2               		SEP #$30 		; 8 bit Index registers
000000r 2               		.A8
000000r 2                               .I8
000000r 2               .endmacro
000000r 2               
000000r 1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	DOS/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp          = $0100         ; warm boot jump
000000r 2               pemjmp          = $0103         ; jump to pem
000000r 2               iostat          = $0106         ; i/o status
000000r 2               dflfcb          = $0107         ; default fcb
000000r 2               dflbuf          = $0128         ; default buffer
000000r 2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
000000r 2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
000000r 2               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 2               hstbuf          = $0400         ; 0400-05ff host buffer
000000r 2               LHSTBUF         = (DOS65BANK*$10000)+$0400         ; 0400-05ff host buffer
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               
000000r 2               
000000r 2               DSKY_BUF        = $0600         ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN     = 8             ;
000000r 2               DSKY_HEXBUF     = $0608         ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN  = 4             ;
000000r 2               debsehd         = $0610         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               debcyll         = $0611         ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         = $0612         ; DEBLOCKED CYLINDER MSB
000000r 2               dskcfg          = $0617         ; 16 bytes disk configuration table
000000r 2               LDSKCFG         = (DOS65BANK*$10000)+$0617         ; 16 bytes disk configuration table
000000r 2               DSKUNIT         = $0628         ; seek disk number
000000r 2               LDSKUNIT        = (DOS65BANK*$10000)+$0628         ; seek disk number
000000r 2               slicetmp        = $0631         ; (word)
000000r 2               STACKA          = $0635
000000r 2               nmsstr          = $0636
000000r 2               FLRETRY         = $0637         ;
000000r 2               FLRETRY1        = $0638         ;
000000r 2               ST0             = $0639         ;
000000r 2               FLERR           = $063A         ;
000000r 2               FCMD            = $063B         ;
000000r 2               PPIDEINDEX      = $063C
000000r 2               DSKY_X_STORAGE  = $063D
000000r 2               DSKY_Y_STORAGE  = $063E
000000r 2               DSKY_TEMP_VAL   = $063F
000000r 2               DSKY_PPIX_VAL   = $0640
000000r 2               FLOPPY_DETCT    = $0641
000000r 2               DSKY_PRESENT    = $0642
000000r 2               Cdebsehd        = $0643         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 2               Cdebcyll        = $0644         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 2               Cdebcylm        = $0645         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 2               CacUnit         = $0646         ; UNIT (IN CACHE)
000000r 2               
000000r 2               tea             = $800          ;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               addinp          = $02           ;initialized to a,y
000000r 2               bufadd          = $04           ;buffer address
000000r 2               alcpnt          = $06           ;allocation map pointer
000000r 2               chkpnt          = $08           ;checksum map pointer
000000r 2               numvar          = $50           ;RESERVED ZERO PAGE SPACE
000000r 2               
000000r 2               
000000r 2               msgptr          = chkpnt+2      ;message pointer
000000r 2               movptr          = msgptr        ;and move pointer
000000r 2               dcbloc          = msgptr+2      ;pointer to dcb
000000r 2               
000000r 2               dcbpc           = $2C           ;pointer to DCB table
000000r 2               dskcfpc         = $2E           ;pointer to disk configuration table
000000r 2               cmdlnp          = $30           ;pointer to command line buffer
000000r 2               farfunct        = $32           ; function to call in driver area
000000r 2               farpointer      = $33           ;
000000r 2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 2               CONSOLE         = $0712
000000r 2               TEMPWORD        = $3B           ;
000000r 2               TEMPWORD1       = $3D           ;
000000r 2               TEMPWORD2       = $3F           ;
000000r 2               STRPTR          = $41           ;
000000r 2               DSKYMODE        = $43           ; DSKY MODE (0=NONE, 1=DSKY, 2=DSKY NG
000000r 2               sektrk          = $44           ; seek track number
000000r 2               seksec          = $46           ; seek sector number
000000r 2               sekdsk          = $48           ; seek disk number
000000r 2               currentDrive    = $49
000000r 2               pcf_buffer      = $4A           ; only used in PCF driver, free for use outside as temp (word)
000000r 2               pcf_address     = $4C           ; only used in PCF driver, free for use outside as temp (byte)
000000r 2  00                   .BYTE   $00
000001r 2               
000001r 2               OPTIONREGISTER  = IO+$51   ;   OPTION REG.
000001r 2               STACK           = $5FFF         ;   POINTER TO TOP OF STACK
000001r 2               DO_FARCALL      = $F200
000001r 2               
000001r 2               ;page zero and system ram assignments
000001r 2               DEST            = $EC           ;pointer for OutMsg
000001r 2               SRC             = $EE           ;pointer for OutMsg
000001r 2               OUTMSG_W        = $F0           ;pointer for OutMsg
000001r 2               dmaadr          = $f4           ;pointer for r/w
000001r 2               
000001r 2               
000001r 2               ;pem constants on entry to write
000001r 2               wrall           = 0             ;write to allocated
000001r 2               wrdir           = 1             ;write to directory
000001r 2               wrual           = 2             ;write to unallocated
000001r 2               
000001r 2               ;fixed parameters
000001r 2               lf              = $a            ;linefeeed
000001r 2               cr              = $d            ;return
000001r 2               eof             = $1a           ;end of file
000001r 2               null            = 0             ;null
000001r 2               ctlc            = 3             ;abort
000001r 2               ctle            = 5             ;physical cr lf
000001r 2               ctli            = 9             ;tab character
000001r 2               ctlp            = $10           ;toggle printer
000001r 2               ctlr            = $12           ;repeat line
000001r 2               ctls            = $13           ;freeze
000001r 2               ctlx            = $18           ;cancel
000001r 2               semico          = $3b           ;semicolon
000001r 2               delete          = $08           ;delete character
000001r 2               numcmd          = 36            ;number commands
000001r 2               DEFDRV          = 0             ; SET TO DEFAULT DRIVE LETTER
000001r 2               
000001r 2               
000001r 2                       .IFDEF RBC6X0X
000001r 2                       .DEFINE COMSUFFIX "COM"
000001r 2                       .ENDIF
000001r 2               
000001r 2                       .IFDEF NHYODYNE
000001r 2                       .DEFINE COMSUFFIX "CO6"
000001r 2                       .ENDIF
000001r 2               
000001r 2                       .IFDEF DUODYNE
000001r 2                       .DEFINE COMSUFFIX "CO6"
000001r 2                       .ENDIF
000001r 2               
000001r 2               
000001r 2               DEBUG           = 0
000001r 2               
000001r 1               
000001r 1                       .SEGMENT "LOWCODE"
000000r 1                       .ORG    $8800
008800  1  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
008801  1  18                   CLC                     ;
008802  1  FB                   XCE                     ; SET NATIVE MODE
008803  1               
008803  1               ; begin by copying DOS/65 to Code Bank
008803  1  C2 30                ACCUMULATORINDEX16
008805  1  A2 2D 88             LDX     #OSBEGIN
008808  1  A0 00 D0             LDY     #DOSBEGIN
00880B  1  A9 04 22             LDA     #DOSSIZE-1
00880E  1  54 1D 00             MVN     #00, #DOS65BANK
008811  1               
008811  1               ; Then copy Drivers into Driver Bank
008811  1  A2 32 AA             LDX     #OSBEGIN+DOSSIZE
008814  1  A0 00 80             LDY     #DRIVERBEGIN
008817  1  A9 1B 08             LDA     #DRIVERSIZE-1
00881A  1  54 1E 00             MVN     #00, #DOS65DRIVERSBNK
00881D  1               
00881D  1               ; Set Default Console
00881D  1  E2 30                ACCUMULATORINDEX8
00881F  1  A9 04                LDA     #$04
008821  1  8F 12 07 1E          STA     f:DOS65DRIVERSBNK*$10000+CONSOLE
008825  1               ; Set Data Bank
008825  1  A9 1D                LDA     #DOS65BANK
008827  1  48                   PHA
008828  1  AB                   PLB
008829  1  5C 00 D0 1D          JML     $1DD000
00882D  1               
00882D  1               OSBEGIN:
00882D  1                       .ORG    DOSBEGIN
00D000  1  E2 30                ACCUMULATORINDEX8
00D002  1                       .INCLUDE "../dos65_os/ccm215.asm"
00D002  2               ;________________________________________________________________________________________________________________________________
00D002  2               ;
00D002  2               ;	DOS/65 console command module (ccm)
00D002  2               ;
00D002  2               ;________________________________________________________________________________________________________________________________
00D002  2               
00D002  2               ;ccm unique definitions
00D002  2               nbuilt          = 7             ;number built in commands
00D002  2               ;main program
00D002  2               ; warm boot vector
00D002  2  4C 83 E5             JMP     boot
00D005  2               ccm:
00D005  2  D8                   CLD                     ;set binary mode
00D006  2  48                   PHA                     ;save drive number
00D007  2  20 03 D4             JSR     rstdsk          ;initialize system
00D00A  2  68                   PLA                     ;restore drive num
00D00B  2  20 07 D4             JSR     slctds          ;select drive
00D00E  2  AD 6D E4             LDA     sysdef+6        ;get line length
00D011  2  4A                   LSR     a               ;divide
00D012  2  4A                   LSR     a               ;by
00D013  2  4A                   LSR     a               ;16
00D014  2  4A                   LSR     a               ;for dir
00D015  2  8D FD D7             STA     sixten          ;and save
00D018  2  AD 4A D7             LDA     cnslng          ;get buffer length
00D01B  2  D0 3F                BNE     mrecmd          ;if more handle it
00D01D  2               ccmlpe:
00D01D  2                       .IFDEF  DUODYNE
00D01D  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00D01E  2  18                   CLC                     ;
00D01F  2  FB                   XCE                     ; SET NATIVE MODE
00D020  2  C2 30                ACCUMULATORINDEX16
00D022  2  A9 FF 5F             LDA     #STACK          ; get the stack address
00D025  2  1B                   TCS                     ; and set the stack to it
00D026  2  E2 30                ACCUMULATORINDEX8
00D028  2                       .ELSE
00D028  2                       LDX     #$ff            ;set
00D028  2                       TXS                     ;stack
00D028  2                       .ENDIF
00D028  2  D8                   CLD                     ;set binary mode
00D029  2               ;        LDA     #17             ; SEND A XON
00D029  2               ;        JSR     chrout          ; ----------
00D029  2  20 70 D4             JSR     hdrout          ;send header
00D02C  2  A9 3E                LDA     #'>'            ;then print
00D02E  2  20 F7 D3             JSR     chrout          ;prompt
00D031  2  AD 92 D6             LDA     cnsbvc          ;point to start
00D034  2  AC 93 D6             LDY     cnsbvc+1        ;of buffer
00D037  2  20 FB D3             JSR     rdebuf          ;do buffer read
00D03A  2  A0 00                LDY     #0              ;clear index
00D03C  2  AE 4A D7             LDX     cnslng          ;get length
00D03F  2  F0 DC                BEQ     ccmlpe          ;loop if empty
00D041  2               lwrupr:
00D041  2  B9 4B D7             LDA     cnstxt,y        ;else get char
00D044  2  C9 61                CMP     #'a'            ;if less than a
00D046  2  90 09                BCC     nxtchg          ;skip convert
00D048  2  C9 7B                CMP     #'z'+1          ;if over z
00D04A  2  B0 05                BCS     nxtchg          ;skip convert
00D04C  2  29 5F                AND     #%01011111      ;else convert
00D04E  2  99 4B D7             STA     cnstxt,y        ;put back in buffer
00D051  2               nxtchg:
00D051  2  C8                   INY                     ;bump index
00D052  2  CA                   DEX                     ;count down
00D053  2  D0 EC                BNE     lwrupr          ;loop if more
00D055  2  8A                   TXA                     ;set a to zero
00D056  2  99 4B D7             STA     cnstxt,y        ;insert stopper
00D059  2  8D EE D7             STA     cnbfpt          ;initialize pointer
00D05C  2               mrecmd:
00D05C  2  20 AB D5             JSR     stdflb          ;set default buffer
00D05F  2  20 32 D4             JSR     intdsk          ;get drive number
00D062  2  8D EF D7             STA     dfldsk          ;store as default
00D065  2  20 AC D4             JSR     prslin          ;parse command
00D068  2  D0 66                BNE     cmderr          ;error if afn
00D06A  2  AD F0 D7             LDA     tmpdsk          ;get temporary
00D06D  2  F0 04                BEQ     nodrch          ;if zero ok
00D06F  2  A9 15                LDA     #nbuilt*3       ;else set and
00D071  2  D0 2E                BNE     dotrns          ;do transient
00D073  2               nodrch:
00D073  2  A9 00                LDA     #0              ;clear
00D075  2  AA                   TAX                     ;table index
00D076  2  8D F3 D7             STA     ccmcount        ;and count
00D079  2               tsnxfn:
00D079  2  A0 01                LDY     #1              ;set fcb index
00D07B  2               tsnxch:
00D07B  2  BD 24 D7             LDA     fnctbl,x        ;get table entry
00D07E  2  F0 1A                BEQ     gotcmd          ;if zero got it
00D080  2  D9 CA D7             CMP     fcbone,y        ;else test
00D083  2  D0 04                BNE     nocmpr          ;no good if not =
00D085  2  E8                   INX                     ;bump
00D086  2  C8                   INY                     ;pointers
00D087  2  D0 F2                BNE     tsnxch          ;and loop
00D089  2               nocmpr:
00D089  2  E8                   INX                     ;go to end
00D08A  2  BD 24 D7             LDA     fnctbl,x        ;of table
00D08D  2  D0 FA                BNE     nocmpr          ;entry
00D08F  2  E8                   INX                     ;point to next
00D090  2  EE F3 D7             INC     ccmcount        ;bump count
00D093  2  AD F3 D7             LDA     ccmcount        ;and if not
00D096  2  C9 07                CMP     #nbuilt         ;limit then
00D098  2  D0 DF                BNE     tsnxfn          ;try next
00D09A  2               gotcmd:
00D09A  2  AD F3 D7             LDA     ccmcount        ;get count
00D09D  2  0A                   ASL     a               ;multiply by two
00D09E  2  6D F3 D7             ADC     ccmcount        ;then add for x3
00D0A1  2               dotrns:
00D0A1  2  AA                   TAX                     ;use as index
00D0A2  2  E8                   INX                     ;bump to pass jmp
00D0A3  2  BD 9D D6             LDA     xqfntb,x        ;to get
00D0A6  2  BC 9E D6             LDY     xqfntb+1,x      ;entry address
00D0A9  2  8D F1 D7             STA     vector          ;then set
00D0AC  2  8C F2 D7             STY     vector+1        ;vector
00D0AF  2  AD 96 D6             LDA     extcvc+1        ;save
00D0B2  2  48                   PHA                     ;return
00D0B3  2  AD 95 D6             LDA     extcvc          ;address
00D0B6  2  48                   PHA                     ;on stack
00D0B7  2                       .IFDEF  DUODYNE
00D0B7  2  A2 00                LDX     #$00
00D0B9  2  7C F1 D7             JMP     (vector,x)      ;execute
00D0BC  2                       .ELSE
00D0BC  2                       JMP     (vector)        ;execute
00D0BC  2                       .ENDIF
00D0BC  2               extcmd:
00D0BC  2  20 3B D4             JSR     rstddr          ;restore default
00D0BF  2               extwod:
00D0BF  2  20 AC D4             JSR     prslin          ;parse more
00D0C2  2  AD CB D7             LDA     fcbone+1        ;if first
00D0C5  2  38                   SEC                     ;character
00D0C6  2  E9 20                SBC     #' '            ;not a space
00D0C8  2  0D F0 D7             ORA     tmpdsk          ;or if temporary
00D0CB  2  D0 03                BNE     cmderr          ;then an error
00D0CD  2  4C 1D D0             JMP     ccmlpe          ;else loop
00D0D0  2               ;command error syntax handler
00D0D0  2               cmderr:
00D0D0  2  20 E8 D3             JSR     ccrlf           ;do a cr lf
00D0D3  2  AC F4 D7             LDY     curpnt          ;get command pointer
00D0D6  2               cmerlp:
00D0D6  2  B9 4B D7             LDA     cnstxt,y        ;get char
00D0D9  2  F0 0A                BEQ     cmerex          ;if null then done
00D0DB  2  C9 20                CMP     #' '            ;if space
00D0DD  2  F0 06                BEQ     cmerex          ;then done
00D0DF  2  20 79 D4             JSR     cotsxy          ;output with save
00D0E2  2  C8                   INY                     ;point to next
00D0E3  2  D0 F1                BNE     cmerlp          ;and loop
00D0E5  2               cmerex:
00D0E5  2  A9 3F                LDA     #'?'            ;send a
00D0E7  2  20 F7 D3             JSR     chrout          ;question mark
00D0EA  2  4C 1D D0             JMP     ccmlpe          ;and start over
00D0ED  2               ;execute dir command
00D0ED  2               ; dir <afn>
00D0ED  2               dir:
00D0ED  2  20 AC D4             JSR     prslin          ;find object file
00D0F0  2  20 B2 D5             JSR     clrslt          ;clear auto and select
00D0F3  2  A9 20                LDA     #' '            ;if name
00D0F5  2  CD CB D7             CMP     fcbone+1        ;and
00D0F8  2  D0 0F                BNE     findfr          ;type are
00D0FA  2  CD D3 D7             CMP     fcbone+9        ;not empty
00D0FD  2  D0 0A                BNE     findfr          ;then use it
00D0FF  2  A9 3F                LDA     #'?'            ;else
00D101  2  A0 0B                LDY     #11             ;fill
00D103  2               fillqu:
00D103  2  99 CA D7             STA     fcbone,y        ;fcb
00D106  2  88                   DEY                     ;with
00D107  2  D0 FA                BNE     fillqu          ;question marks
00D109  2               findfr:
00D109  2  20 66 D4             JSR     srchf1          ;search for first match
00D10C  2  30 58                BMI     notfnd          ;error if none
00D10E  2               fnddir:
00D10E  2  AD FD D7             LDA     sixten          ;set across
00D111  2  8D FC D7             STA     across          ;to four
00D114  2  20 E8 D3             JSR     ccrlf           ;do a crlf
00D117  2               
00D117  2               dirl:
00D117  2  20 73 D4             JSR     hdr             ;do header
00D11A  2  A9 3A                LDA     #':'            ;then a
00D11C  2  20 F7 D3             JSR     chrout          ;colon
00D11F  2  AD F5 D7             LDA     diradd          ;get number
00D122  2  0A                   ASL     a               ;and
00D123  2  0A                   ASL     a               ;multiply
00D124  2  0A                   ASL     a               ;by
00D125  2  0A                   ASL     a               ;thirty two
00D126  2  0A                   ASL     a               ;then
00D127  2  29 60                AND     #%01100000      ;mask out insignificant
00D129  2  A8                   TAY                     ;make a pointer
00D12A  2  C8                   INY                     ;and bump
00D12B  2  A2 01                LDX     #1              ;set counter
00D12D  2               nmelpe:
00D12D  2  B9 28 01             LDA     dflbuf,y        ;get name
00D130  2  29 7F                AND     #$7F            ;mask out read only bit
00D132  2  20 79 D4             JSR     cotsxy          ;else send to console
00D135  2               noname:
00D135  2  C8                   INY                     ;bump index
00D136  2  E8                   INX                     ;and count
00D137  2  E0 0C                CPX     #12             ;if count is 12
00D139  2  F0 0C                BEQ     endnme          ;then done
00D13B  2  E0 09                CPX     #9              ;or if not 9
00D13D  2  D0 EE                BNE     nmelpe          ;then loop
00D13F  2  A9 2E                LDA     #'.'            ;else send
00D141  2  20 79 D4             JSR     cotsxy          ;a period
00D144  2  4C 2D D1             JMP     nmelpe          ;and loop
00D147  2               endnme:
00D147  2  20 FF D3             JSR     chkcst          ;check console status
00D14A  2  D0 19                BNE     extdir          ;if key down quit
00D14C  2  20 9E D4             JSR     setone          ;else point to fcb
00D14F  2  20 17 D4             JSR     srchnx          ;else search for next
00D152  2  8D F5 D7             STA     diradd          ;save number
00D155  2  30 0E                BMI     extdir          ;quit if not found
00D157  2  CE FC D7             DEC     across          ;drop count
00D15A  2  F0 B2                BEQ     fnddir          ;new line if 0
00D15C  2  20 F5 D3             JSR     spcout          ;send
00D15F  2  20 F5 D3             JSR     spcout          ;two spaces
00D162  2  4C 17 D1             JMP     dirl            ;and stay
00D165  2               extdir:
00D165  2  60                   RTS                     ;else done
00D166  2               ;not found error handler
00D166  2               notfnd:
00D166  2  A0 34                LDY     #ntfnms         ;point to message
00D168  2  4C C7 D5             JMP     sndmsg          ;send and exit
00D16B  2               ;execute ren command
00D16B  2               ; ren <ufn> <ufn>
00D16B  2               ;where first ufn is from name and second is to name
00D16B  2               ren:
00D16B  2  20 AC D4             JSR     prslin          ;get old name
00D16E  2  D0 57                BNE     renerr          ;error if afn
00D170  2  20 A5 D4             JSR     tmpold          ;save drive
00D173  2  20 B2 D5             JSR     clrslt          ;clear auto and select
00D176  2  20 66 D4             JSR     srchf1          ;if file does not exist
00D179  2  30 4F                BMI     fntfnd          ;then an error
00D17B  2  20 E7 D5             JSR     frssec          ;move name to second half
00D17E  2  AC EE D7             LDY     cnbfpt          ;get pointer
00D181  2  B9 4B D7             LDA     cnstxt,y        ;and then char
00D184  2  C9 20                CMP     #' '            ;if not a space
00D186  2  D0 3C                BNE     rensyn          ;then error
00D188  2  20 AC D4             JSR     prslin          ;get new name
00D18B  2  D0 37                BNE     rensyn          ;error if afn
00D18D  2  AD F0 D7             LDA     tmpdsk          ;get new drive
00D190  2  F0 12                BEQ     nonwdr          ;if zero ok
00D192  2  CD F9 D7             CMP     oldtmp          ;compare to old
00D195  2  F0 0D                BEQ     nonwdr          ;ok if same
00D197  2  38                   SEC                     ;drop for default check
00D198  2  E9 01                SBC     #1
00D19A  2  CD EF D7             CMP     dfldsk          ;if not default
00D19D  2  D0 25                BNE     rensyn          ;is error
00D19F  2  AD F9 D7             LDA     oldtmp          ;and then if from not
00D1A2  2  D0 20                BNE     rensyn          ;default is error
00D1A4  2               nonwdr:
00D1A4  2  AD F9 D7             LDA     oldtmp          ;else get old
00D1A7  2  8D F0 D7             STA     tmpdsk          ;and save
00D1AA  2  A9 00                LDA     #0              ;clear
00D1AC  2  8D DA D7             STA     fcbone+16
00D1AF  2  20 B2 D5             JSR     clrslt          ;reselect
00D1B2  2  20 66 D4             JSR     srchf1          ;search for old
00D1B5  2  10 09                BPL     filexs          ;error if found
00D1B7  2  20 E7 D5             JSR     frssec          ;swap names
00D1BA  2  20 9E D4             JSR     setone          ;point to fcb
00D1BD  2  4C 2E D4             JMP     renmfl          ;and do it
00D1C0  2               ;ren file exists error handler
00D1C0  2               filexs:
00D1C0  2  A0 3E                LDY     #flexms         ;point to
00D1C2  2  D0 08                BNE     remsg           ;and send
00D1C4  2               ;ren syntax error handler
00D1C4  2               rensyn:
00D1C4  2  20 3B D4             JSR     rstddr          ;restore default
00D1C7  2               renerr:
00D1C7  2  4C D0 D0             JMP     cmderr          ;do error
00D1CA  2               ;ren source file not found error handler
00D1CA  2               fntfnd:
00D1CA  2  A0 34                LDY     #ntfnms         ;point to
00D1CC  2               remsg:
00D1CC  2  4C C7 D5             JMP     sndmsg          ;and send
00D1CF  2               ;execute save command
00D1CF  2               ; save <length> <drive:>ufn (<address>)
00D1CF  2               save:
00D1CF  2  A9 00                LDA     #<tea           ;set start address to tea start
00D1D1  2  A0 08                LDY     #>tea
00D1D3  2  8D 03 D8             STA     sadr
00D1D6  2  8C 04 D8             STY     sadr+1
00D1D9  2  20 0C D6             JSR     bldnum          ;calculate length
00D1DC  2  D0 7A                BNE     saverr          ;error if > 255 pages
00D1DE  2  8D F8 D7             STA     length          ;else save low
00D1E1  2  0D F8 D7             ORA     length          ;test for zero length
00D1E4  2  F0 72                BEQ     saverr          ;error if is
00D1E6  2  20 AC D4             JSR     prslin          ;get file name
00D1E9  2  D0 6D                BNE     saverr          ;error if afn
00D1EB  2  20 E7 D5             JSR     frssec          ;move name to second half
00D1EE  2  20 A5 D4             JSR     tmpold          ;save drive
00D1F1  2  20 0C D6             JSR     bldnum          ;it is so find value
00D1F4  2  AE CB D7             LDX     fcbone+1        ;see if there
00D1F7  2  E0 20                CPX     #' '
00D1F9  2  F0 0A                BEQ     nosadr          ;it is not
00D1FB  2  8D 03 D8             STA     sadr            ;and set address
00D1FE  2  8C 04 D8             STY     sadr+1
00D201  2  C0 02                CPY     #2              ;make sure is high enough
00D203  2  90 53                BCC     saverr          ;error if not
00D205  2               nosadr:
00D205  2  20 FA D5             JSR     secfrs          ;move name back
00D208  2  20 B2 D5             JSR     clrslt          ;clear auto and select
00D20B  2  20 1B D4             JSR     dlt1            ;delete
00D20E  2  20 9E D4             JSR     setone          ;then create
00D211  2  20 2A D4             JSR     cratfl          ;new file
00D214  2  30 45                BMI     noroom          ;say no room if error
00D216  2  20 51 D4             JSR     open1           ;open file
00D219  2  30 44                BMI     noopen          ;if error
00D21B  2  18                   CLC                     ;now find end page
00D21C  2  AD 04 D8             LDA     sadr+1
00D21F  2  6D F8 D7             ADC     length
00D222  2  8D F8 D7             STA     length
00D225  2  AD 03 D8             LDA     sadr            ;get start address
00D228  2  AC 04 D8             LDY     sadr+1
00D22B  2               wrtmre:
00D22B  2  8D FA D7             STA     dskbuf          ;set
00D22E  2  8C FB D7             STY     dskbuf+1        ;buffer
00D231  2  20 CE E2             JSR     mv128           ;move data to buffer
00D234  2  20 9E D4             JSR     setone          ;point to fcb
00D237  2  20 26 D4             JSR     wrrcrd          ;write record
00D23A  2  D0 27                BNE     wrterr          ;exit if error
00D23C  2  18                   CLC                     ;else
00D23D  2  AD FA D7             LDA     dskbuf          ;get old
00D240  2  AC FB D7             LDY     dskbuf+1        ;buffer
00D243  2  69 80                ADC     #128            ;add 128
00D245  2  90 03                BCC     donotc          ;if carry
00D247  2  C8                   INY                     ;bump upper
00D248  2  F0 05                BEQ     clssav          ;done if page zero
00D24A  2               donotc:
00D24A  2  CC F8 D7             CPY     length          ;loop if upper
00D24D  2  D0 DC                BNE     wrtmre          ;not at limit
00D24F  2               clssav:
00D24F  2  20 9E D4             JSR     setone          ;else point to
00D252  2  20 0F D4             JSR     clsefl          ;and close file
00D255  2  30 10                BMI     cantcl          ;say so if error
00D257  2               extera:
00D257  2  60                   RTS
00D258  2               ;save error handler
00D258  2               saverr:
00D258  2  4C D0 D0             JMP     cmderr          ;do error
00D25B  2               ;save no room error handler
00D25B  2               noroom:
00D25B  2  A0 01                LDY     #nospms         ;point to
00D25D  2  D0 0A                BNE     semsg           ;and send
00D25F  2               ;save can not open error handler
00D25F  2               noopen:
00D25F  2  A0 55                LDY     #cnnoms         ;point to
00D261  2  D0 06                BNE     semsg           ;and send
00D263  2               ;save write error handler
00D263  2               wrterr:
00D263  2  A0 62                LDY     #wrerms         ;point
00D265  2  D0 02                BNE     semsg           ;to and send
00D267  2               ;save can not close error
00D267  2               cantcl:
00D267  2  A0 0A                LDY     #ntclms         ;point to
00D269  2               semsg:
00D269  2  4C C7 D5             JMP     sndmsg          ;and send
00D26C  2               ;execute era command
00D26C  2               ; era <afn>
00D26C  2               era:
00D26C  2  20 AC D4             JSR     prslin          ;get file name
00D26F  2  C9 0B                CMP     #11             ;if not all ?
00D271  2  D0 13                BNE     nteral          ;then skip verify
00D273  2  A0 18                LDY     #alflms         ;else point to
00D275  2  20 C7 D5             JSR     sndmsg          ;and send all files
00D278  2  20 F1 D3             JSR     cnsrde          ;get an input
00D27B  2  48                   PHA                     ;and save
00D27C  2  20 E8 D3             JSR     ccrlf           ;do a cr lf
00D27F  2  68                   PLA                     ;restore char
00D280  2  29 5F                AND     #$5f            ;convert to upper case
00D282  2  C9 59                CMP     #'Y'            ;if not y
00D284  2  D0 D1                BNE     extera          ;then quit
00D286  2               nteral:
00D286  2  20 B2 D5             JSR     clrslt          ;clear auto and select
00D289  2  4C 1B D4             JMP     dlt1            ;delete first
00D28C  2               ;execute type command
00D28C  2               ; type d:ufn
00D28C  2               type:
00D28C  2  20 AC D4             JSR     prslin          ;get file
00D28F  2  D0 30                BNE     typafn          ;error if afn
00D291  2  20 4E D4             JSR     casdo1          ;clear - select - open file 1
00D294  2  30 32                BMI     notype          ;error if not found
00D296  2  20 E8 D3             JSR     ccrlf           ;else do cr lf
00D299  2               typmre:
00D299  2  20 60 D4             JSR     read1           ;read record
00D29C  2  F0 04                BEQ     okread          ;if ok continue
00D29E  2  10 20                BPL     exttyp          ;exit if just end
00D2A0  2  30 22                BMI     typerr          ;else error
00D2A2  2               okread:
00D2A2  2  A2 00                LDX     #0              ;clear index
00D2A4  2               typlpe:
00D2A4  2  BD 28 01             LDA     dflbuf,x        ;get char
00D2A7  2  C9 1A                CMP     #eof            ;if eof
00D2A9  2  F0 15                BEQ     exttyp          ;then exit
00D2AB  2  20 79 D4             JSR     cotsxy          ;else send
00D2AE  2  20 FF D3             JSR     chkcst          ;if key down
00D2B1  2  D0 08                BNE     exttok          ;then exit
00D2B3  2  AE F6 D7             LDX     savx            ;else get index
00D2B6  2  E8                   INX                     ;bump it
00D2B7  2  10 EB                BPL     typlpe          ;and loop if < 128
00D2B9  2  30 DE                BMI     typmre          ;else read more
00D2BB  2               exttok:
00D2BB  2  A2 06                LDX     #6              ;clear console
00D2BD  2  20 03 01             JSR     pemjmp          ;with no echo
00D2C0  2               exttyp:
00D2C0  2  60                   RTS
00D2C1  2               ;type syntax error handler
00D2C1  2               typafn:
00D2C1  2  4C D0 D0             JMP     cmderr          ;error return
00D2C4  2               ;type read error handler
00D2C4  2               typerr:
00D2C4  2  A0 29                LDY     #rderms         ;point to
00D2C6  2  D0 02                BNE     temsg           ;and send
00D2C8  2               ;type not found error handler
00D2C8  2               notype:
00D2C8  2  A0 34                LDY     #ntfnms         ;point to
00D2CA  2               temsg:
00D2CA  2  4C C7 D5             JMP     sndmsg          ;and send
00D2CD  2               ;execute load command
00D2CD  2               ; load <ufn> (<address>)
00D2CD  2               load:
00D2CD  2  20 DC D5             JSR     setddb          ;set load start to tea start
00D2D0  2  20 AC D4             JSR     prslin          ;build fcb
00D2D3  2  D0 EC                BNE     typafn          ;error if afn
00D2D5  2  20 E7 D5             JSR     frssec          ;save in second half
00D2D8  2  20 A5 D4             JSR     tmpold          ;save file
00D2DB  2  20 0C D6             JSR     bldnum          ;find start address
00D2DE  2  AE CB D7             LDX     fcbone+1        ;see if number
00D2E1  2  E0 20                CPX     #' '
00D2E3  2  F0 03                BEQ     usedfl          ;if none use default
00D2E5  2  20 E0 D5             JSR     setdb           ;and set
00D2E8  2               usedfl:
00D2E8  2  20 FA D5             JSR     secfrs          ;move name back
00D2EB  2  20 4E D4             JSR     casdo1          ;clear - select - open file 1
00D2EE  2  30 D8                BMI     notype          ;exit if not found
00D2F0  2  AD FA D7             LDA     dskbuf          ;get load start
00D2F3  2  AC FB D7             LDY     dskbuf+1
00D2F6  2               lcmdlp:
00D2F6  2  20 36 D4             JSR     setbuf          ;set as disk buffer
00D2F9  2  20 60 D4             JSR     read1           ;read record
00D2FC  2  D0 06                BNE     loadnd          ;done if not zero
00D2FE  2  20 BB E2             JSR     adjdb           ;bump address
00D301  2  4C F6 D2             JMP     lcmdlp          ;and loop
00D304  2               loadnd:
00D304  2  30 BE                BMI     typerr          ;if error say so
00D306  2  4C AB D5             JMP     stdflb          ;back to default buffer
00D309  2               ;execute go command
00D309  2               ; go (<address>)
00D309  2               go:
00D309  2  20 0C D6             JSR     bldnum          ;get address
00D30C  2  AE CB D7             LDX     fcbone+1        ;get first char
00D30F  2  E0 20                CPX     #' '            ;see if nothing
00D311  2  F0 03                BEQ     nolnum          ;nothing so use tea
00D313  2  4C 7D D3             JMP     godoit          ;then execute
00D316  2               nolnum:
00D316  2  4C 79 D3             JMP     gotea
00D319  2               ;execute trns (transient) command
00D319  2               ; <ufn> (<fn>) (<fn>)
00D319  2               trns:
00D319  2  AD CB D7             LDA     fcbone+1        ;get first char
00D31C  2  C9 20                CMP     #' '            ;if not space
00D31E  2  D0 11                BNE     chktyp          ;check type
00D320  2  AD F0 D7             LDA     tmpdsk          ;else test temp
00D323  2  F0 09                BEQ     skpdrv          ;if none skip
00D325  2  38                   SEC                     ;else convert
00D326  2  E9 01                SBC     #1              ;to number
00D328  2  8D EF D7             STA     dfldsk          ;set default
00D32B  2  20 07 D4             JSR     slctds          ;and select
00D32E  2               skpdrv:
00D32E  2  4C BF D0             JMP     extwod          ;return
00D331  2               chktyp:
00D331  2  AD D3 D7             LDA     fcbone+9        ;get type
00D334  2  C9 20                CMP     #' '            ;if space
00D336  2  F0 03                BEQ     typemp          ;then ok
00D338  2  4C E0 D3             JMP     trnerr          ;else error
00D33B  2               typemp:
00D33B  2  A2 02                LDX     #2              ;make
00D33D  2               setcom:
00D33D  2  BD EB D7             LDA     typcom,x        ;type
00D340  2  9D D3 D7             STA     fcbone+9,x      ;com
00D343  2  CA                   DEX                     ;then
00D344  2  10 F7                BPL     setcom          ;continue
00D346  2  20 4E D4             JSR     casdo1          ;clear - select - open file one
00D349  2  10 03                BPL     gottrn          ;jump if ok
00D34B  2  4C DD D3             JMP     topner          ;else do error
00D34E  2               gottrn:
00D34E  2  20 DC D5             JSR     setddb          ;set start to tea
00D351  2               nxtrcr:
00D351  2  20 36 D4             JSR     setbuf          ;set address
00D354  2  20 60 D4             JSR     read1           ;read fcb 1
00D357  2  D0 1E                BNE     endlde          ;branch if error or eof
00D359  2  20 BB E2             JSR     adjdb           ;adjust address up by 128
00D35C  2  CD 98 D6             CMP     ccmvc           ;if new low
00D35F  2  90 07                BCC     tryhig          ;ok try high
00D361  2  CC 99 D6             CPY     ccmvc+1         ;else if high
00D364  2  90 EB                BCC     nxtrcr          ;ok do more
00D366  2  B0 07                BCS     chklnd          ;else check for end
00D368  2               tryhig:
00D368  2  CC 99 D6             CPY     ccmvc+1         ;if high less
00D36B  2  90 E4                BCC     nxtrcr          ;then ok
00D36D  2  F0 E2                BEQ     nxtrcr          ;or ok if same
00D36F  2               chklnd:
00D36F  2  20 AB D5             JSR     stdflb          ;set buffer to default
00D372  2  20 60 D4             JSR     read1           ;read (should be eof)
00D375  2  F0 6C                BEQ     tlderr          ;error if more
00D377  2               endlde:
00D377  2  30 6A                BMI     tlderr          ;do error
00D379  2               gotea:
00D379  2  A9 00                LDA     #<tea           ;set go address to tea start
00D37B  2  A0 08                LDY     #>tea
00D37D  2               godoit:
00D37D  2  8D D2 D3             STA     do+1            ;set to ay
00D380  2  8C D3 D3             STY     do+2
00D383  2  20 3B D4             JSR     rstddr          ;else restore default
00D386  2  20 AC D4             JSR     prslin          ;parse file
00D389  2  AD F0 D7             LDA     tmpdsk          ;set auto
00D38C  2  8D CA D7             STA     fcbone          ;select position
00D38F  2  A2 10                LDX     #16             ;do a second
00D391  2  20 AE D4             JSR     prsmre          ;fcb if there
00D394  2  AD F0 D7             LDA     tmpdsk          ;set auto select
00D397  2  8D DA D7             STA     fcbone+16       ;again
00D39A  2  A0 00                LDY     #0              ;clear record
00D39C  2  8C EA D7             STY     fcbone+32       ;counter
00D39F  2  A2 20                LDX     #32             ;move
00D3A1  2               movfcb:
00D3A1  2  BD CA D7             LDA     fcbone,x        ;all
00D3A4  2  9D 07 01             STA     dflfcb,x        ;to
00D3A7  2  CA                   DEX                     ;default
00D3A8  2  10 F7                BPL     movfcb          ;fcb
00D3AA  2  E8                   INX                     ;set x to zero
00D3AB  2               tstbuf:
00D3AB  2  B9 4B D7             LDA     cnstxt,y        ;get char
00D3AE  2  F0 07                BEQ     isnull          ;if null jump
00D3B0  2  C9 20                CMP     #' '            ;or if space
00D3B2  2  F0 03                BEQ     isnull          ;jump
00D3B4  2  C8                   INY                     ;else bump pointer
00D3B5  2  D0 F4                BNE     tstbuf          ;and loop
00D3B7  2               isnull:
00D3B7  2  A9 00                LDA     #0              ;clear
00D3B9  2  8D 28 01             STA     dflbuf          ;count
00D3BC  2               movbuf:
00D3BC  2  B9 4B D7             LDA     cnstxt,y        ;get char
00D3BF  2  9D 29 01             STA     dflbuf+1,x      ;and move
00D3C2  2  F0 07                BEQ     fillov          ;exit if null
00D3C4  2  E8                   INX                     ;increment
00D3C5  2  C8                   INY                     ;counters
00D3C6  2  EE 28 01             INC     dflbuf          ;and length
00D3C9  2  D0 F1                BNE     movbuf          ;and loop
00D3CB  2               fillov:
00D3CB  2  20 E8 D3             JSR     ccrlf           ;do a cr lf
00D3CE  2  20 AB D5             JSR     stdflb          ;set default
00D3D1  2               do:
00D3D1  2  20 00 08             JSR     tea             ;execute
00D3D4  2  AD EF D7             LDA     dfldsk          ;get default
00D3D7  2  20 07 D4             JSR     slctds          ;and set
00D3DA  2  4C 1D D0             JMP     ccmlpe          ;then loop
00D3DD  2               ;trns syntax error handler
00D3DD  2               topner:
00D3DD  2  20 3B D4             JSR     rstddr          ;restore default
00D3E0  2               trnerr:
00D3E0  2  4C D0 D0             JMP     cmderr          ;do error
00D3E3  2               ;trns load error
00D3E3  2               tlderr:
00D3E3  2  A0 4A                LDY     #lderms         ;point to
00D3E5  2  4C C7 D5             JMP     sndmsg          ;and send
00D3E8  2               ;carriage return and linefeed
00D3E8  2               ccrlf:
00D3E8  2  A9 0D                LDA     #cr             ;get a cr
00D3EA  2  20 F7 D3             JSR     chrout          ;send
00D3ED  2  A9 0A                LDA     #lf             ;get a lf
00D3EF  2  D0 06                BNE     chrout          ;and send
00D3F1  2               ;pem entry routines
00D3F1  2               cnsrde:
00D3F1  2  A2 01                LDX     #1              ;console read
00D3F3  2  D0 43                BNE     pemgo
00D3F5  2               spcout:
00D3F5  2  A9 20                LDA     #' '            ;output space
00D3F7  2               chrout:
00D3F7  2  A2 02                LDX     #2              ;console output
00D3F9  2  D0 3D                BNE     pemgo
00D3FB  2               rdebuf:
00D3FB  2  A2 0A                LDX     #10             ;buffered input
00D3FD  2  D0 39                BNE     pemgo
00D3FF  2               chkcst:
00D3FF  2  A2 0B                LDX     #11             ;check console
00D401  2  D0 35                BNE     pemgo
00D403  2               rstdsk:
00D403  2  A2 0D                LDX     #13             ;initialize system
00D405  2  D0 31                BNE     pemgo
00D407  2               slctds:
00D407  2  A2 0E                LDX     #14             ;select drive
00D409  2  D0 2D                BNE     pemgo
00D40B  2               openfl:
00D40B  2  A2 0F                LDX     #15             ;open file
00D40D  2  D0 29                BNE     pemgo
00D40F  2               clsefl:
00D40F  2  A2 10                LDX     #16             ;close file
00D411  2  D0 25                BNE     pemgo
00D413  2               srchfr:
00D413  2  A2 11                LDX     #17             ;first match
00D415  2  D0 21                BNE     pemgo
00D417  2               srchnx:
00D417  2  A2 12                LDX     #18             ;next match
00D419  2  D0 1D                BNE     pemgo
00D41B  2               ;delete file one
00D41B  2               dlt1:
00D41B  2  20 9E D4             JSR     setone          ;point to fcb
00D41E  2               dltfil:
00D41E  2  A2 13                LDX     #19             ;delete file
00D420  2  D0 16                BNE     pemgo
00D422  2               rdrcrd:
00D422  2  A2 14                LDX     #20             ;read record
00D424  2  D0 12                BNE     pemgo
00D426  2               wrrcrd:
00D426  2  A2 15                LDX     #21             ;write record
00D428  2  D0 0E                BNE     pemgo
00D42A  2               cratfl:
00D42A  2  A2 16                LDX     #22             ;create file
00D42C  2  D0 0A                BNE     pemgo
00D42E  2               renmfl:
00D42E  2  A2 17                LDX     #23             ;rename file
00D430  2  D0 06                BNE     pemgo
00D432  2               intdsk:
00D432  2  A2 19                LDX     #25             ;read drive num
00D434  2  D0 02                BNE     pemgo
00D436  2               setbuf:
00D436  2  A2 1A                LDX     #26             ;set buffer add
00D438  2               pemgo:
00D438  2  4C 03 01             JMP     pemjmp          ;go to pem
00D43B  2               ;restore default drive
00D43B  2               rstddr:
00D43B  2  AD F0 D7             LDA     tmpdsk          ;if temp drive
00D43E  2  F0 1F                BEQ     extddr          ;zero then exit
00D440  2  38                   SEC                     ;else
00D441  2  E9 01                SBC     #1              ;subtract one
00D443  2  CD EF D7             CMP     dfldsk          ;compare to default
00D446  2  F0 17                BEQ     extddr          ;exit if same
00D448  2               seldfl:
00D448  2  AD EF D7             LDA     dfldsk          ;else get default
00D44B  2  4C 07 D4             JMP     slctds          ;select
00D44E  2               ;clear auto - select disk - open file at fcbone
00D44E  2               casdo1:
00D44E  2  20 B2 D5             JSR     clrslt          ;clear auto and select
00D451  2               ;open file one
00D451  2               ; returns:n=1 if not found
00D451  2               open1:
00D451  2  A9 00                LDA     #0              ;clear
00D453  2  8D EA D7             STA     fcbone+32       ;record number
00D456  2  20 9E D4             JSR     setone          ;point to fcb
00D459  2  20 0B D4             JSR     openfl          ;open it
00D45C  2  8D F5 D7             STA     diradd          ;save number
00D45F  2               extddr:
00D45F  2  60                   RTS
00D460  2               ;read file one
00D460  2               read1:
00D460  2  20 9E D4             JSR     setone          ;point to fcb
00D463  2  4C 22 D4             JMP     rdrcrd          ;do read
00D466  2               ;search for first file one
00D466  2               ; returns:n=1 if not found
00D466  2               srchf1:
00D466  2  20 9E D4             JSR     setone          ;point to fcb
00D469  2  20 13 D4             JSR     srchfr          ;search for first
00D46C  2  8D F5 D7             STA     diradd          ;save number
00D46F  2  60                   RTS
00D470  2               ;header output
00D470  2               hdrout:
00D470  2  20 E8 D3             JSR     ccrlf           ;do cr lf
00D473  2               hdr:
00D473  2  20 32 D4             JSR     intdsk          ;get drive number
00D476  2  18                   CLC                     ;make
00D477  2  69 41                ADC     #'A'            ;a letter
00D479  2               ;output with save of x and y
00D479  2               ;this routine calls the pem resident routine
00D479  2               ;tstchr to see if a char is a printing char.
00D479  2               ;if it is then c=1 upon return from tstchr.
00D479  2               cotsxy:
00D479  2  8E F6 D7             STX     savx            ;save x
00D47C  2  8C F7 D7             STY     savy            ;and y
00D47F  2  20 C5 E0             JSR     tstchr          ;see if printing
00D482  2  B0 10                BCS     isprnt          ;jump if is
00D484  2  48                   PHA                     ;else save
00D485  2  AD 6B E4             LDA     sysdef+4        ;get invert
00D488  2  20 F7 D3             JSR     chrout          ;send it
00D48B  2  68                   PLA                     ;get char
00D48C  2  09 40                ORA     #'@'            ;make printing
00D48E  2  20 F7 D3             JSR     chrout          ;send it
00D491  2  AD 6A E4             LDA     sysdef+3        ;get normal
00D494  2               isprnt:
00D494  2  20 F7 D3             JSR     chrout          ;do output
00D497  2  AC F7 D7             LDY     savy            ;get y
00D49A  2  AE F6 D7             LDX     savx            ;and x
00D49D  2  60                   RTS
00D49E  2               ;set up fcb one pointer
00D49E  2               setone:
00D49E  2  AD 9B D6             LDA     fcb1vc          ;low
00D4A1  2  AC 9C D6             LDY     fcb1vc+1        ;and high
00D4A4  2  60                   RTS
00D4A5  2               ;save tmpdsk in oldtmp
00D4A5  2               tmpold:
00D4A5  2  AD F0 D7             LDA     tmpdsk
00D4A8  2  8D F9 D7             STA     oldtmp
00D4AB  2  60                   RTS
00D4AC  2               ;parse command line
00D4AC  2               prslin:
00D4AC  2  A2 00                LDX     #0              ;clear index
00D4AE  2               prsmre:
00D4AE  2  8A                   TXA                     ;save
00D4AF  2  48                   PHA                     ;index
00D4B0  2  A9 00                LDA     #0              ;clear temp
00D4B2  2  8D F0 D7             STA     tmpdsk          ;drive flag
00D4B5  2  AC EE D7             LDY     cnbfpt          ;get buffer pointer
00D4B8  2  20 79 D5             JSR     skpspc          ;find first non-space
00D4BB  2  8C F4 D7             STY     curpnt          ;save index
00D4BE  2  F0 0D                BEQ     nulchr          ;jump if null
00D4C0  2  29 0F                AND     #%00001111      ;else look at 4 lsbs
00D4C2  2  48                   PHA                     ;and save
00D4C3  2  C8                   INY                     ;point to next char
00D4C4  2  B9 4B D7             LDA     cnstxt,y        ;and get it
00D4C7  2  C9 3A                CMP     #':'            ;if a colon
00D4C9  2  F0 0A                BEQ     drvinp          ;jump and set drive
00D4CB  2  68                   PLA                     ;else clear stack
00D4CC  2  88                   DEY                     ;backup index
00D4CD  2               nulchr:
00D4CD  2  AD EF D7             LDA     dfldsk          ;set automatic
00D4D0  2  9D CA D7             STA     fcbone,x        ;to default
00D4D3  2  10 08                BPL     trynme          ;then parse name
00D4D5  2               drvinp:
00D4D5  2  68                   PLA                     ;get number
00D4D6  2  8D F0 D7             STA     tmpdsk          ;set temp flag
00D4D9  2  9D CA D7             STA     fcbone,x        ;and fcb
00D4DC  2  C8                   INY                     ;point past colon
00D4DD  2               trynme:
00D4DD  2  A9 08                LDA     #8              ;set name count
00D4DF  2  8D F3 D7             STA     ccmcount        ;to eight
00D4E2  2               tstnme:
00D4E2  2  20 86 D5             JSR     tstlgl          ;test for illegal
00D4E5  2  F0 1D                BEQ     flnmsp          ;if illegal jump
00D4E7  2  E8                   INX                     ;bump pointer
00D4E8  2  C9 2A                CMP     #'*'            ;if not *
00D4EA  2  D0 07                BNE     notafn          ;skip ? fill
00D4EC  2  A9 3F                LDA     #'?'            ;get a ?
00D4EE  2  9D CA D7             STA     fcbone,x        ;store
00D4F1  2  D0 04                BNE     nxtout          ;and jump
00D4F3  2               notafn:
00D4F3  2  9D CA D7             STA     fcbone,x        ;store char
00D4F6  2  C8                   INY                     ;bump source
00D4F7  2               nxtout:
00D4F7  2  CE F3 D7             DEC     ccmcount        ;drop counter down
00D4FA  2  D0 E6                BNE     tstnme          ;and loop
00D4FC  2               skpmre:
00D4FC  2  20 86 D5             JSR     tstlgl          ;if illegal
00D4FF  2  F0 11                BEQ     trytyp          ;try type
00D501  2  C8                   INY                     ;else bump index
00D502  2  D0 F8                BNE     skpmre          ;and loop
00D504  2               flnmsp:
00D504  2  E8                   INX                     ;next position
00D505  2  A9 20                LDA     #' '            ;get a space
00D507  2  9D CA D7             STA     fcbone,x        ;store
00D50A  2  CE F3 D7             DEC     ccmcount        ;count down
00D50D  2  D0 F5                BNE     flnmsp          ;and loop
00D50F  2  B9 4B D7             LDA     cnstxt,y        ;get char again
00D512  2               trytyp:
00D512  2  48                   PHA                     ;save char
00D513  2  A9 03                LDA     #3              ;set count
00D515  2  8D F3 D7             STA     ccmcount        ;to three
00D518  2  68                   PLA                     ;get char
00D519  2  C9 2E                CMP     #'.'            ;if not .
00D51B  2  D0 23                BNE     fltysp          ;then fill spaces
00D51D  2  C8                   INY                     ;else bump source
00D51E  2               tsttyp:
00D51E  2  20 86 D5             JSR     tstlgl          ;if not legal
00D521  2  F0 1D                BEQ     fltysp          ;then fill spaces
00D523  2  E8                   INX                     ;else bump index
00D524  2  C9 2A                CMP     #'*'            ;if not *
00D526  2  D0 07                BNE     notaft          ;then skip fill
00D528  2  A9 3F                LDA     #'?'            ;else get ?
00D52A  2  9D CA D7             STA     fcbone,x        ;move to fcb
00D52D  2  D0 04                BNE     mrtyfl          ;and loop
00D52F  2               notaft:
00D52F  2  9D CA D7             STA     fcbone,x        ;move char to fcb
00D532  2  C8                   INY                     ;bump source
00D533  2               mrtyfl:
00D533  2  CE F3 D7             DEC     ccmcount        ;count down
00D536  2  D0 E6                BNE     tsttyp          ;and loop
00D538  2               nttype:
00D538  2  20 86 D5             JSR     tstlgl          ;if illegal
00D53B  2  F0 0E                BEQ     filnul          ;fill out nulls
00D53D  2  C8                   INY                     ;else bump source
00D53E  2  D0 F8                BNE     nttype          ;and loop
00D540  2               fltysp:
00D540  2  E8                   INX                     ;bump fcb pointer
00D541  2  A9 20                LDA     #' '            ;get space
00D543  2  9D CA D7             STA     fcbone,x        ;put in fcb
00D546  2  CE F3 D7             DEC     ccmcount        ;count down
00D549  2  D0 F5                BNE     fltysp          ;and continue
00D54B  2               filnul:
00D54B  2  A9 03                LDA     #3              ;clear
00D54D  2  8D F3 D7             STA     ccmcount        ;three
00D550  2               mrnlty:
00D550  2  E8                   INX                     ;bump fcb pointer
00D551  2  A9 00                LDA     #0              ;get a zero
00D553  2  9D CA D7             STA     fcbone,x        ;move to fcb
00D556  2  CE F3 D7             DEC     ccmcount        ;count down
00D559  2  D0 F5                BNE     mrnlty          ;loop until done
00D55B  2  8C EE D7             STY     cnbfpt          ;update start pointer
00D55E  2  A9 00                LDA     #0              ;clear
00D560  2  8D F3 D7             STA     ccmcount        ;count
00D563  2  68                   PLA                     ;restore stack
00D564  2  A8                   TAY                     ;move to index
00D565  2  A2 0B                LDX     #11             ;counter to 11
00D567  2               tstqus:
00D567  2  C8                   INY                     ;point to
00D568  2  B9 CA D7             LDA     fcbone,y        ;and get char
00D56B  2  C9 3F                CMP     #'?'            ;if not a ?
00D56D  2  D0 03                BNE     nxtqus          ;then jump
00D56F  2  EE F3 D7             INC     ccmcount        ;else bump count
00D572  2               nxtqus:
00D572  2  CA                   DEX                     ;loop until
00D573  2  D0 F2                BNE     tstqus          ;11 tested
00D575  2  AD F3 D7             LDA     ccmcount        ;get count
00D578  2  60                   RTS                     ;and return
00D579  2               ;skip space
00D579  2               skpspc:
00D579  2  B9 4B D7             LDA     cnstxt,y        ;get char
00D57C  2  F0 07                BEQ     extskp          ;jump if null
00D57E  2  C9 20                CMP     #' '            ;if not space
00D580  2  D0 03                BNE     extskp          ;then exit
00D582  2  C8                   INY                     ;else go to next
00D583  2  D0 F4                BNE     skpspc          ;and test
00D585  2               extskp:
00D585  2  60                   RTS
00D586  2               ;test legal
00D586  2               tstlgl:
00D586  2  B9 4B D7             LDA     cnstxt,y        ;get char
00D589  2  F0 1C                BEQ     extlgl
00D58B  2  C9 20                CMP     #' '            ;if space
00D58D  2  90 19                BCC     badinp          ;ok - less is error
00D58F  2  F0 16                BEQ     extlgl
00D591  2  C9 3D                CMP     #'='
00D593  2  F0 12                BEQ     extlgl
00D595  2  C9 2E                CMP     #'.'
00D597  2  F0 0E                BEQ     extlgl
00D599  2  C9 3A                CMP     #':'
00D59B  2  F0 0A                BEQ     extlgl
00D59D  2  C9 3B                CMP     #semico
00D59F  2  F0 06                BEQ     extlgl
00D5A1  2  C9 3C                CMP     #'<'
00D5A3  2  F0 02                BEQ     extlgl
00D5A5  2  C9 3E                CMP     #'>'
00D5A7  2               extlgl:
00D5A7  2  60                   RTS
00D5A8  2               badinp:
00D5A8  2  4C D0 D0             JMP     cmderr
00D5AB  2               ;set default buffer address
00D5AB  2               stdflb:
00D5AB  2  A9 28                LDA     #<dflbuf        ;point to
00D5AD  2  A0 01                LDY     #>dflbuf        ;location
00D5AF  2  4C 36 D4             JMP     setbuf          ;and set
00D5B2  2               ;clear automatic and select
00D5B2  2               clrslt:
00D5B2  2  A9 00                LDA     #0              ;clear auto
00D5B4  2  8D CA D7             STA     fcbone          ;select
00D5B7  2               slttmp:
00D5B7  2  AD F0 D7             LDA     tmpdsk          ;get temp
00D5BA  2  F0 1F                BEQ     extsnd          ;if zero exit
00D5BC  2  38                   SEC                     ;else subtract
00D5BD  2  E9 01                SBC     #1              ;one
00D5BF  2  CD EF D7             CMP     dfldsk          ;if same as default
00D5C2  2  F0 17                BEQ     extsnd          ;then quit
00D5C4  2  4C 07 D4             JMP     slctds          ;else set
00D5C7  2               ;send message
00D5C7  2               sndmsg:
00D5C7  2  8C F7 D7             STY     savy            ;save index
00D5CA  2  20 E8 D3             JSR     ccrlf           ;do cr and lf
00D5CD  2  AC F7 D7             LDY     savy            ;get index
00D5D0  2               lpesnd:
00D5D0  2  B9 B6 D6             LDA     msgtbl,y        ;get char
00D5D3  2  F0 06                BEQ     extsnd          ;if null quit
00D5D5  2  20 79 D4             JSR     cotsxy          ;else send
00D5D8  2  C8                   INY                     ;point to next
00D5D9  2  D0 F5                BNE     lpesnd          ;and loop
00D5DB  2               extsnd:
00D5DB  2  60                   RTS
00D5DC  2               ;set load start address
00D5DC  2               setddb:
00D5DC  2  A9 00                LDA     #<tea           ;to tea start
00D5DE  2  A0 08                LDY     #>tea
00D5E0  2               setdb:
00D5E0  2  8D FA D7             STA     dskbuf          ;to ay
00D5E3  2  8C FB D7             STY     dskbuf+1
00D5E6  2  60                   RTS
00D5E7  2               ;move first part of fcb to second half
00D5E7  2               ;and move second part to first part.
00D5E7  2               ;only ren depends upon this routine to actually
00D5E7  2               ;swap fcb halves.
00D5E7  2               ;alters:a,x,p
00D5E7  2               ;returns:x=$ff
00D5E7  2               frssec:
00D5E7  2  A2 0F                LDX     #15             ;set index to last
00D5E9  2               frsclp:
00D5E9  2  BD CA D7             LDA     fcbone,x        ;get byte
00D5EC  2  BC DA D7             LDY     fcbone+16,x
00D5EF  2  9D DA D7             STA     fcbone+16,x     ;move it
00D5F2  2  98                   TYA
00D5F3  2  9D CA D7             STA     fcbone,x
00D5F6  2  CA                   DEX
00D5F7  2  10 F0                BPL     frsclp          ;until 16 moved
00D5F9  2  60                   RTS
00D5FA  2               ;move second part of fcb to first half
00D5FA  2               ;restore tmpdsk from save location
00D5FA  2               ;alters:a,x,p
00D5FA  2               ;returns:x=$ff
00D5FA  2               secfrs:
00D5FA  2  A2 0F                LDX     #15             ;set index to last
00D5FC  2               scfrlp:
00D5FC  2  BD DA D7             LDA     fcbone+16,x     ;get byte
00D5FF  2  9D CA D7             STA     fcbone,x        ;move it
00D602  2  CA                   DEX
00D603  2  10 F7                BPL     scfrlp          ;loop until done
00D605  2  AD F9 D7             LDA     oldtmp          ;get old flag
00D608  2  8D F0 D7             STA     tmpdsk          ;and set
00D60B  2  60                   RTS
00D60C  2               ;build a number from command line and leave in num
00D60C  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00D60C  2               ;move parse index past number
00D60C  2               ;modifies:all
00D60C  2               ;returns:a,y set to low and high of number
00D60C  2               ;	 flags set according to y which is high part of number
00D60C  2               bldnum:
00D60C  2  A9 09                LDA     #9              ;preset to decimal
00D60E  2  8D FE D7             STA     moduls
00D611  2  20 AC D4             JSR     prslin          ;put in fcb
00D614  2  AD F0 D7             LDA     tmpdsk          ;if temp
00D617  2  D0 67                BNE     numerr          ;is error
00D619  2  8D FF D7             STA     num             ;else clear num
00D61C  2  8D 00 D8             STA     num+1
00D61F  2  A8                   TAY                     ;and index
00D620  2  B9 CB D7             LDA     fcbone+1,y      ;get first char
00D623  2  C9 24                CMP     #'$'            ;see if hex signal
00D625  2  D0 06                BNE     bnumlp          ;skip if not
00D627  2  A9 0F                LDA     #15             ;set for modulus
00D629  2  8D FE D7             STA     moduls
00D62C  2  C8                   INY                     ;bump past $
00D62D  2               bnumlp:
00D62D  2  C8                   INY                     ;next char
00D62E  2  B9 CA D7             LDA     fcbone,y        ;get digit
00D631  2  C9 20                CMP     #' '            ;see if space
00D633  2  F0 4E                BEQ     endnlp          ;done if is
00D635  2  20 A5 E2             JSR     tstdec          ;see if decimal
00D638  2  90 0E                BCC     usedig          ;use if is
00D63A  2  20 AF E2             JSR     tsthex          ;see if hex
00D63D  2  B0 41                BCS     numerr          ;error if not
00D63F  2  E9 06                SBC     #6              ;remove offset
00D641  2  A2 0F                LDX     #15             ;test for hex modulus
00D643  2  EC FE D7             CPX     moduls
00D646  2  D0 38                BNE     numerr          ;error if not
00D648  2               usedig:
00D648  2  29 0F                AND     #%00001111      ;eliminate ascii bias
00D64A  2  48                   PHA                     ;save result
00D64B  2  AD FF D7             LDA     num             ;move number to temp
00D64E  2  8D 01 D8             STA     tnum
00D651  2  AD 00 D8             LDA     num+1
00D654  2  8D 02 D8             STA     tnum+1
00D657  2  AE FE D7             LDX     moduls          ;get modulus
00D65A  2  18                   CLC
00D65B  2               addlpe:
00D65B  2  AD FF D7             LDA     num             ;add number to itself
00D65E  2  6D 01 D8             ADC     tnum
00D661  2  8D FF D7             STA     num
00D664  2  AD 00 D8             LDA     num+1           ;modulus times
00D667  2  6D 02 D8             ADC     tnum+1
00D66A  2  8D 00 D8             STA     num+1
00D66D  2  B0 11                BCS     numerr          ;error if carry out
00D66F  2  CA                   DEX
00D670  2  D0 E9                BNE     addlpe          ;loop if more
00D672  2  68                   PLA                     ;get input back
00D673  2  6D FF D7             ADC     num             ;add in
00D676  2  8D FF D7             STA     num
00D679  2  90 B2                BCC     bnumlp          ;loop if no carry
00D67B  2  EE 00 D8             INC     num+1           ;else bump high
00D67E  2  D0 AD                BNE     bnumlp          ;and loop for more
00D680  2               ;error in bldnum - handle and quit
00D680  2               numerr:
00D680  2  4C D0 D0             JMP     cmderr          ;do general error
00D683  2               ;end of use of name part - check type
00D683  2               endnlp:
00D683  2  AD D3 D7             LDA     fcbone+9        ;get first
00D686  2  C9 20                CMP     #' '            ;see if space
00D688  2  D0 F6                BNE     numerr          ;error if not
00D68A  2  AD FF D7             LDA     num             ;return with result
00D68D  2  AC 00 D8             LDY     num+1
00D690  2  60                   RTS
00D691  2               ;relocatable vectors
00D691  2  4C                   .BYTE   $4c
00D692  2               cnsbvc:
00D692  2  49 D7                .WORD   cnsbuf
00D694  2  4C                   .BYTE   $4c
00D695  2               extcvc:
00D695  2  BB D0                .WORD   extcmd-1
00D697  2  4C                   .BYTE   $4c
00D698  2               ccmvc:
00D698  2  05 D0                .WORD   ccm
00D69A  2  4C                   .BYTE   $4c
00D69B  2               fcb1vc:
00D69B  2  CA D7                .WORD   fcbone
00D69D  2               ;function entry vector
00D69D  2               xqfntb:
00D69D  2  4C ED D0             JMP     dir
00D6A0  2  4C CF D1             JMP     save
00D6A3  2  4C 6C D2             JMP     era
00D6A6  2  4C 8C D2             JMP     type
00D6A9  2  4C 6B D1             JMP     ren
00D6AC  2  4C 09 D3             JMP     go
00D6AF  2  4C CD D2             JMP     load
00D6B2  2  4C 19 D3             JMP     trns
00D6B5  2               ;terminator for relocation
00D6B5  2  FF                   .BYTE   $ff
00D6B6  2               ;messages
00D6B6  2               msgtbl:
00D6B6  2  00                   .BYTE   0
00D6B7  2               nospms          = *-msgtbl
00D6B7  2  4E 4F 20 53          .BYTE   "NO SPACE",0
00D6BB  2  50 41 43 45  
00D6BF  2  00           
00D6C0  2               ntclms          = *-msgtbl
00D6C0  2  43 41 4E 20          .BYTE   "CAN NOT CLOSE",0
00D6C4  2  4E 4F 54 20  
00D6C8  2  43 4C 4F 53  
00D6CE  2               alflms          = *-msgtbl
00D6CE  2  41 4C 4C 20          .BYTE   "ALL FILES (Y/N)?",0
00D6D2  2  46 49 4C 45  
00D6D6  2  53 20 28 59  
00D6DF  2               rderms          = *-msgtbl
00D6DF  2  52 45 41 44          .BYTE   "READ ERROR",0
00D6E3  2  20 45 52 52  
00D6E7  2  4F 52 00     
00D6EA  2               ntfnms          = *-msgtbl
00D6EA  2  4E 4F 54 20          .BYTE   "NOT FOUND",0
00D6EE  2  46 4F 55 4E  
00D6F2  2  44 00        
00D6F4  2               flexms          = *-msgtbl
00D6F4  2  46 49 4C 45          .BYTE   "FILE EXISTS",0
00D6F8  2  20 45 58 49  
00D6FC  2  53 54 53 00  
00D700  2               lderms          = *-msgtbl
00D700  2  4C 4F 41 44          .BYTE   "LOAD ERROR",0
00D704  2  20 45 52 52  
00D708  2  4F 52 00     
00D70B  2               cnnoms          = *-msgtbl
00D70B  2  43 41 4E 20          .BYTE   "CAN NOT OPEN",0
00D70F  2  4E 4F 54 20  
00D713  2  4F 50 45 4E  
00D718  2               wrerms          = *-msgtbl
00D718  2  57 52 49 54          .BYTE   "WRITE ERROR",0
00D71C  2  45 20 45 52  
00D720  2  52 4F 52 00  
00D724  2               ;function name table
00D724  2               fnctbl:
00D724  2  44 49 52 20          .BYTE   "DIR ",0
00D728  2  00           
00D729  2  53 41 56 45          .BYTE   "SAVE ",0
00D72D  2  20 00        
00D72F  2  45 52 41 20          .BYTE   "ERA ",0
00D733  2  00           
00D734  2  54 59 50 45          .BYTE   "TYPE ",0
00D738  2  20 00        
00D73A  2  52 45 4E 20          .BYTE   "REN ",0
00D73E  2  00           
00D73F  2  47 4F 20 00          .BYTE   "GO ",0
00D743  2  4C 4F 41 44          .BYTE   "LOAD ",0
00D747  2  20 00        
00D749  2               ;input buffer
00D749  2               cnsbuf:
00D749  2               cnsmax:
00D749  2  7F                   .BYTE   127
00D74A  2               cnslng:
00D74A  2  00                   .BYTE   0
00D74B  2               cnstxt:
00D74B  2  xx xx xx xx          .RES    127
00D74F  2  xx xx xx xx  
00D753  2  xx xx xx xx  
00D7CA  2               ;fcb one
00D7CA  2               fcbone:
00D7CA  2  xx xx xx xx          .RES    33
00D7CE  2  xx xx xx xx  
00D7D2  2  xx xx xx xx  
00D7EB  2               ;com type field
00D7EB  2               
00D7EB  2               typcom:
00D7EB  2  43 4F 36             .BYTE   COMSUFFIX
00D7EE  2               
00D7EE  2               ;variable storage
00D7EE  2               cnbfpt:
00D7EE  2  00                   .BYTE   0               ;buffer index
00D7EF  2               dfldsk:
00D7EF  2  00                   .BYTE   0               ;default drive
00D7F0  2               tmpdsk:
00D7F0  2  00                   .BYTE   0               ;temporary dvive
00D7F1  2               ;align vector on word boundary
00D7F1  2                       .ALIGN  2
00D7F1  2               vector:
00D7F1  2  00 00                .WORD   0               ;execution vector
00D7F3  2               ccmcount:
00D7F3  2  00                   .BYTE   0               ;counter
00D7F4  2               curpnt:
00D7F4  2  00                   .BYTE   0               ;input parse start
00D7F5  2               diradd:
00D7F5  2  00                   .BYTE   0               ;directory number
00D7F6  2               savx:
00D7F6  2  00                   .BYTE   0               ;save x location
00D7F7  2               savy:
00D7F7  2  00                   .BYTE   0               ;save y location
00D7F8  2               length:
00D7F8  2  00                   .BYTE   0               ;number tages to save
00D7F9  2               oldtmp:
00D7F9  2  00                   .BYTE   0               ;temp drive in ren
00D7FA  2               dskbuf:
00D7FA  2  00 08                .WORD   tea             ;disk buffer start
00D7FC  2               across:
00D7FC  2  00                   .BYTE   0               ;dir count on line
00D7FD  2               sixten:
00D7FD  2  00                   .BYTE   0               ;line length div 16
00D7FE  2               moduls:
00D7FE  2  09                   .BYTE   9               ;modulus-1 for number input
00D7FF  2               num:
00D7FF  2  00 00                .WORD   0               ;input number
00D801  2               tnum:
00D801  2  00 00                .WORD   0               ;temp in bldnum
00D803  2               sadr:
00D803  2  00 08                .WORD   tea             ;save start address
00D805  2               
00D805  1                       .INCLUDE "../dos65_os/pemrbc.asm"
00D805  2               .P816
00D805  2               ;________________________________________________________________________________________________________________________________
00D805  2               ;
00D805  2               ;	DOS/65 primitive execution module (pem)
00D805  2               ;
00D805  2               ;
00D805  2               ;________________________________________________________________________________________________________________________________
00D805  2               
00D805  2               ;main program
00D805  2               ; input:x=command,a=value,a&y=address
00D805  2               ; returns:a=value,a&y=address
00D805  2               ; alters:all
00D805  2               
00D805  2               pem:
00D805  2  D8                   CLD                     ;set binary mode
00D806  2  8D 9C E3             STA     bytinp          ;save input
00D809  2  8D E1 E3             STA     lowin           ;value and
00D80C  2  8C 9D E3             STY     bytinp+1        ;save high
00D80F  2  8C E2 E3             STY     lowin+1         ;address
00D812  2  8E 9E E3             STX     cmdinp          ;and command
00D815  2  E0 24                CPX     #numcmd         ;if invalid
00D817  2  B0 52                BCS     extpem          ;then exit
00D819  2  BD 58 E3             LDA     swctbl,x        ;if flag zero
00D81C  2  F0 08                BEQ     noswin          ;skip switch
00D81E  2  A9 FF                LDA     #255            ;else set
00D820  2  8D 9B E3             STA     swcflg          ;memory switch flag
00D823  2  20 F2 DA             JSR     switch          ;move data to page zero
00D826  2               noswin:
00D826  2  A9 00                LDA     #0              ;clear drive
00D828  2  8D A3 E3             STA     tmpdrv          ;switch flag
00D82B  2  AD 9E E3             LDA     cmdinp          ;get command
00D82E  2  0A                   ASL     a               ;multiply by two
00D82F  2  6D 9E E3             ADC     cmdinp          ;then add to get x3
00D832  2  AA                   TAX                     ;and make a pointer
00D833  2  E8                   INX                     ;bump to pass jmp
00D834  2  BD 7F D8             LDA     cmdtbl,x        ;get command
00D837  2  BC 80 D8             LDY     cmdtbl+1,x      ;address
00D83A  2  8D A5 E3             STA     xqtvec          ;and put
00D83D  2  8C A6 E3             STY     xqtvec+1        ;in vector
00D840  2  AD E8 E2             LDA     extevc+1        ;get return
00D843  2  48                   PHA                     ;address
00D844  2  AD E7 E2             LDA     extevc          ;and push
00D847  2  48                   PHA                     ;as return
00D848  2  AD 9C E3             LDA     bytinp          ;get input value
00D84B  2  AC 9D E3             LDY     bytinp+1
00D84E  2                       .IFDEF DUODYNE
00D84E  2  A2 00                ldx     #$00
00D850  2  7C A5 E3             JMP     (xqtvec,x)        ;then execute
00D853  2                       .ELSE
00D853  2                       JMP     (xqtvec)        ;then execute
00D853  2                       .ENDIF
00D853  2               extexq:
00D853  2  8D 9F E3             STA     bytout          ;save value
00D856  2  8C A0 E3             STY     addout+1        ;and address
00D859  2  AD A3 E3             LDA     tmpdrv          ;get temp drive
00D85C  2  F0 0D                BEQ     extpem          ;if zero skip switch
00D85E  2  A0 00                LDY     #0              ;else
00D860  2  91 02                STA     (addinp),y      ;put back in fcb
00D862  2  AD AE E3             LDA     olddrv          ;get old drive number
00D865  2  8D 9C E3             STA     bytinp          ;set input value
00D868  2  20 0D DB             JSR     chgdrv          ;then switch back
00D86B  2               extpem:
00D86B  2  2C 9B E3             BIT     swcflg          ;test memory switch
00D86E  2  10 08                BPL     noswot          ;if not set skip
00D870  2  20 F2 DA             JSR     switch          ;else do memory switch
00D873  2  A9 00                LDA     #0              ;clear
00D875  2  8D 9B E3             STA     swcflg          ;flag
00D878  2               noswot:
00D878  2  AC A0 E3             LDY     addout+1        ;get address
00D87B  2  AD 9F E3             LDA     bytout          ;and value (address low)
00D87E  2  60                   RTS
00D87F  2               ;command vector table
00D87F  2               cmdtbl:
00D87F  2  4C F3 D8             JMP     xwboot          ;warm boot
00D882  2  4C E4 DA             JMP     xcnsin          ;console input with echo
00D885  2  4C 1D E1             JMP     sndchr          ;console output
00D888  2  4C 46 E4             JMP     sim+21          ;tape reader
00D88B  2  4C 43 E4             JMP     sim+18          ;tape punch
00D88E  2  4C 40 E4             JMP     sim+15          ;printer output
00D891  2  4C 8F E0             JMP     getcon          ;console input w/o echo
00D894  2  4C 28 D9             JMP     xgtios          ;read i/o status
00D897  2  4C 33 D9             JMP     xstios          ;set i/o status
00D89A  2  4C D4 E0             JMP     sndstr          ;print buffer
00D89D  2  4C 89 E1             JMP     bufinp          ;read buffer
00D8A0  2  4C 9F E0             JMP     kbdsts          ;test console ready
00D8A3  2  4C 5E E4             JMP     sim+45          ;read list status
00D8A6  2  4C 3B DB             JMP     xintds          ;initialize system
00D8A9  2  4C 0D DB             JMP     chgdrv          ;log in drive
00D8AC  2  4C B8 DD             JMP     xopen           ;open file
00D8AF  2  4C F3 DD             JMP     xclose          ;close file
00D8B2  2  4C 17 DE             JMP     xfndfr          ;find first match
00D8B5  2  4C 43 D9             JMP     xfndnx          ;find next match
00D8B8  2  4C AB D9             JMP     xdltfl          ;delete file
00D8BB  2  4C 4B D9             JMP     xread           ;read record
00D8BE  2  4C D0 D9             JMP     xwrite          ;write record
00D8C1  2  4C BA DE             JMP     xmake           ;create file
00D8C4  2  4C 89 D9             JMP     xrenme          ;rename file
00D8C7  2  4C 3B D9             JMP     xintlg          ;interrogate log in status
00D8CA  2  4C 37 D9             JMP     xintdr          ;interrogate current drive
00D8CD  2  4C 02 DB             JMP     chgdma          ;set buffer address
00D8D0  2  4C 2C D9             JMP     xrdalv          ;read allocation map start
00D8D3  2  4C 76 DD             JMP     setron          ;set r/w status
00D8D6  2  4C 3F D9             JMP     xrdros          ;read r/w status
00D8D9  2  4C EB D8             JMP     setlst          ;set list echo status
00D8DC  2  4C EF D8             JMP     lststs          ;read list echo status
00D8DF  2  4C 03 D9             JMP     xrtclo          ;read low clock
00D8E2  2  4C 17 D9             JMP     xrtchi          ;read high clock
00D8E5  2  4C 21 D9             JMP     xrddcb          ;read dcb address
00D8E8  2  4C 64 E4             JMP     sim+51          ;translate sector
00D8EB  2               ;set list echo status
00D8EB  2               setlst:
00D8EB  2  8D 99 E3             STA     lstflg          ;set flag
00D8EE  2  60                   RTS
00D8EF  2               ;read list echo status
00D8EF  2               lststs:
00D8EF  2  AD 99 E3             LDA     lstflg          ;read flag
00D8F2  2  60                   RTS
00D8F3  2               ;execute warm boot
00D8F3  2               ; ***this command does not return to pem***
00D8F3  2               ; ***instead it jumps to sim, resets	***
00D8F3  2               ; ***system and stack and jumps to ccm. ***
00D8F3  2               xwboot:
00D8F3  2  2C 9B E3             BIT     swcflg          ;test memory switch flag
00D8F6  2  10 08                BPL     dowmbt          ;if clear do not
00D8F8  2  20 F2 DA             JSR     switch          ;switch memory
00D8FB  2  A9 00                LDA     #0              ;clear
00D8FD  2  8D 9B E3             STA     swcflg          ;flag
00D900  2               dowmbt:
00D900  2  4C 34 E4             JMP     sim+3           ;go to sim
00D903  2               
00D903  2               ;execute read real time clock
00D903  2               xrtclo:
00D903  2  20 61 E4             JSR     sim+48          ;read clock
00D906  2               
00D906  2  8D CA E3             STA     rtclk           ;save low
00D909  2  8C CB E3             STY     rtclk+1         ;middle
00D90C  2  8E CC E3             STX     rtclk+2         ;high
00D90F  2  8A                   TXA
00D910  2  29 80                AND     #%10000000      ;test for valid
00D912  2  A8                   TAY
00D913  2  AD CA E3             LDA     rtclk           ;get low
00D916  2  60                   RTS
00D917  2               ;execute read real time clock high
00D917  2               xrtchi:
00D917  2  AD CC E3             LDA     rtclk+2         ;get high
00D91A  2  29 7F                AND     #%01111111      ;clear status
00D91C  2  A8                   TAY
00D91D  2  AD CB E3             LDA     rtclk+1         ;get middle
00D920  2  60                   RTS
00D921  2               ;execute read dcb address
00D921  2               xrddcb:
00D921  2  AD 75 DB             LDA     cptdcb+1        ;get address
00D924  2  AC 76 DB             LDY     cptdcb+2
00D927  2  60                   RTS
00D928  2               ;execute read i/o status
00D928  2               xgtios:
00D928  2  AD 06 01             LDA     iostat          ;get status byte
00D92B  2  60                   RTS
00D92C  2               ;execute read allocation map starting address
00D92C  2               xrdalv:
00D92C  2  AD D9 E3             LDA     alcmap          ;get
00D92F  2  AC DA E3             LDY     alcmap+1        ;starting address
00D932  2  60                   RTS                     ;then return
00D933  2               ;execute set i/o status
00D933  2               xstios:
00D933  2  8D 06 01             STA     iostat          ;set status
00D936  2  60                   RTS
00D937  2               ;execute interrogate current drive
00D937  2               xintdr:
00D937  2  AD AF E3             LDA     curdrv          ;get number
00D93A  2  60                   RTS
00D93B  2               ;execute read log in status
00D93B  2               xintlg:
00D93B  2  AD B0 E3             LDA     lginvc          ;get status
00D93E  2  60                   RTS
00D93F  2               ;execute read read/write status
00D93F  2               xrdros:
00D93F  2  AD B1 E3             LDA     ronlst          ;get status
00D942  2  60                   RTS
00D943  2               ;execute find next match
00D943  2               xfndnx:
00D943  2  20 1B DB             JSR     autodr          ;auto drive select
00D946  2  A9 0D                LDA     #13             ;match including
00D948  2  4C 24 DE             JMP     search          ;extent
00D94B  2               ;execute read next record
00D94B  2               xread:
00D94B  2  20 1B DB             JSR     autodr          ;auto drive select
00D94E  2  20 98 DD             JSR     inrcct          ;initialize record counters
00D951  2  AD BA E3             LDA     nxtrec          ;if next record less
00D954  2  CD BB E3             CMP     numrec          ;then number records
00D957  2  90 13                BCC     tryrde          ;then try to read
00D959  2  C9 80                CMP     #128            ;but if not and
00D95B  2  F0 03                BEQ     tryext          ;is max try to extend
00D95D  2               rdeeof:
00D95D  2  A9 01                LDA     #1              ;else set eof
00D95F  2  60                   RTS                     ;code and return
00D960  2               tryext:
00D960  2  A2 01                LDX     #1              ;try for a read
00D962  2  20 F6 DE             JSR     extend          ;file extension
00D965  2  C9 00                CMP     #0              ;if not ok exit eof
00D967  2  D0 F4                BNE     rdeeof          ;with jump back
00D969  2  8D BA E3             STA     nxtrec          ;clear next record
00D96C  2               tryrde:
00D96C  2  20 88 DF             JSR     getblk          ;and get block
00D96F  2  AD B5 E3             LDA     blknum          ;if block not zero
00D972  2  0D B6 E3             ORA     blknum+1
00D975  2  D0 03                BNE     dorde           ;do the read
00D977  2  A9 02                LDA     #2              ;else set unwritten
00D979  2  60                   RTS                     ;code and exit
00D97A  2               dorde:
00D97A  2  20 69 DE             JSR     calrcn          ;calculate record number
00D97D  2  20 B5 DC             JSR     sttrsc          ;set track and sector
00D980  2  20 41 E0             JSR     rdesec          ;do sector read
00D983  2  20 A7 DD             JSR     updtrc          ;update counters
00D986  2  A9 00                LDA     #0              ;return w/o error
00D988  2               extrde:
00D988  2  60                   RTS
00D989  2               ;execute file rename
00D989  2               xrenme:
00D989  2  20 1B DB             JSR     autodr          ;automatic drive select
00D98C  2  20 1E E0             JSR     tstron          ;test for r/o
00D98F  2  A9 0C                LDA     #12             ;match name
00D991  2  20 1C DE             JSR     frstsr          ;and type
00D994  2  30 14                BMI     extren          ;exit if not found
00D996  2               doren:
00D996  2  A9 00                LDA     #0              ;clear drive select
00D998  2  A0 10                LDY     #16             ;in new name
00D99A  2  91 02                STA     (addinp),y      ;part of fcb
00D99C  2  A9 0C                LDA     #12             ;then move
00D99E  2  A2 10                LDX     #16             ;new name
00D9A0  2  20 89 DE             JSR     dirchg          ;to directory
00D9A3  2  A9 0C                LDA     #12             ;see if
00D9A5  2  20 24 DE             JSR     search          ;another match
00D9A8  2  10 EC                BPL     doren           ;loop if found
00D9AA  2               extren:
00D9AA  2  60                   RTS                     ;number
00D9AB  2               ;execute delete file
00D9AB  2               xdltfl:
00D9AB  2  20 1B DB             JSR     autodr          ;automatic drive select
00D9AE  2  20 1E E0             JSR     tstron          ;test for r/o
00D9B1  2  A9 0C                LDA     #12             ;match name
00D9B3  2  20 1C DE             JSR     frstsr          ;and type
00D9B6  2  30 17                BMI     extdlt          ;done if not found
00D9B8  2               dodlt:
00D9B8  2  A2 00                LDX     #0              ;else do a
00D9BA  2  20 EE DF             JSR     mapdir          ;delete
00D9BD  2  AC B4 E3             LDY     subrec          ;then change
00D9C0  2  AD 57 E3             LDA     empty           ;byte zero to
00D9C3  2  91 04                STA     (bufadd),y      ;empty code
00D9C5  2  20 47 E0             JSR     updtck          ;then update directory
00D9C8  2  A9 0C                LDA     #12             ;search
00D9CA  2  20 24 DE             JSR     search          ;for next
00D9CD  2  10 E9                BPL     dodlt           ;loop if found
00D9CF  2               extdlt:
00D9CF  2  60                   RTS                     ;exit
00D9D0  2               ;execute write next record
00D9D0  2               xwrite:
00D9D0  2  20 1B DB             JSR     autodr          ;automatic drive select
00D9D3  2  20 1E E0             JSR     tstron          ;test for r/o
00D9D6  2  20 98 DD             JSR     inrcct          ;initialize counters
00D9D9  2  AD BA E3             LDA     nxtrec          ;get next record
00D9DC  2  C9 80                CMP     #128            ;compare to max
00D9DE  2  90 03                BCC     ntexte          ;continue if less
00D9E0  2  A9 01                LDA     #1              ;else flag as extend
00D9E2  2  60                   RTS                     ;error and exit
00D9E3  2               ntexte:
00D9E3  2  20 88 DF             JSR     getblk          ;calculate block num
00D9E6  2  A9 00                LDA     #0              ;say normal write
00D9E8  2  8D DE E3             STA     pemwrtype       ;for now
00D9EB  2  AD B5 E3             LDA     blknum          ;get it and if
00D9EE  2  0D B6 E3             ORA     blknum+1
00D9F1  2  F0 03                BEQ     *+5             ;zero then get number
00D9F3  2  4C B3 DA             JMP     blkopn          ;else go write
00D9F6  2  A9 02                LDA     #2              ;say unalloc write
00D9F8  2  8D DE E3             STA     pemwrtype
00D9FB  2  AD 95 E3             LDA     fcbind          ;get index from prior
00D9FE  2  48                   PHA                     ;and save
00D9FF  2  C9 10                CMP     #16             ;if first block
00DA01  2  F0 1A                BEQ     isfrst          ;then don't change
00DA03  2  A8                   TAY                     ;else make an index
00DA04  2  88                   DEY                     ;point to last
00DA05  2  2C C5 E3             BIT     blmode          ;test mode
00DA08  2  10 01                BPL     *+3             ;done if byte
00DA0A  2  88                   DEY                     ;else drop for word
00DA0B  2  B1 02                LDA     (addinp),y      ;and get that number
00DA0D  2  8D B5 E3             STA     blknum          ;store as starting
00DA10  2  C8                   INY                     ;bump for word
00DA11  2  A9 00                LDA     #0              ;preset for byte
00DA13  2  2C C5 E3             BIT     blmode          ;test mode
00DA16  2  10 02                BPL     *+4             ;done if byte
00DA18  2  B1 02                LDA     (addinp),y      ;else get high
00DA1A  2  8D B6 E3             STA     blknum+1        ;then set high
00DA1D  2               isfrst:
00DA1D  2  AD B5 E3             LDA     blknum          ;get block
00DA20  2  8D AA E3             STA     lkdown          ;set lower and
00DA23  2  8D AC E3             STA     lookup          ;upper pointers
00DA26  2  AD B6 E3             LDA     blknum+1        ;now set high part
00DA29  2  8D AB E3             STA     lkdown+1
00DA2C  2  8D AD E3             STA     lookup+1
00DA2F  2               srblag:
00DA2F  2  AD AC E3             LDA     lookup          ;if upper pointer
00DA32  2  CD D0 E3             CMP     maxblk          ;not at max
00DA35  2  D0 08                BNE     upnemx          ;then keep going
00DA37  2  AC AD E3             LDY     lookup+1        ;now check high
00DA3A  2  CC D1 E3             CPY     maxblk+1
00DA3D  2  F0 12                BEQ     tstdwn          ;go test down
00DA3F  2               upnemx:
00DA3F  2  EE AC E3             INC     lookup          ;else bump upper
00DA42  2  D0 03                BNE     *+5
00DA44  2  EE AD E3             INC     lookup+1
00DA47  2  AD AA E3             LDA     lkdown          ;then if lower
00DA4A  2  0D AB E3             ORA     lkdown+1
00DA4D  2  F0 18                BEQ     dotest          ;is zero start test
00DA4F  2  D0 0B                BNE     dcdown          ;else drop lower
00DA51  2               tstdwn:
00DA51  2  AD AA E3             LDA     lkdown          ;if upper & lower at
00DA54  2  0D AB E3             ORA     lkdown+1
00DA57  2  D0 03                BNE     dcdown          ;drop if not zero
00DA59  2  A8                   TAY                     ;also set y
00DA5A  2  F0 30                BEQ     extsbl          ;then exit
00DA5C  2               dcdown:
00DA5C  2  AD AA E3             LDA     lkdown          ;drop lower
00DA5F  2  D0 03                BNE     *+5
00DA61  2  CE AB E3             DEC     lkdown+1
00DA64  2  CE AA E3             DEC     lkdown
00DA67  2               dotest:
00DA67  2  AD AA E3             LDA     lkdown          ;get lower
00DA6A  2  AC AB E3             LDY     lkdown+1
00DA6D  2  20 5A DD             JSR     tstblk          ;and test
00DA70  2  D0 09                BNE     trylup          ;if full try upper
00DA72  2  AD AA E3             LDA     lkdown          ;else use lower
00DA75  2  AC AB E3             LDY     lkdown+1
00DA78  2  4C 8C DA             JMP     extsbl          ;as result
00DA7B  2               trylup:
00DA7B  2  AD AC E3             LDA     lookup          ;get upper
00DA7E  2  AC AD E3             LDY     lookup+1
00DA81  2  20 5A DD             JSR     tstblk          ;if full
00DA84  2  D0 A9                BNE     srblag          ;then loop
00DA86  2  AD AC E3             LDA     lookup          ;else use upper
00DA89  2  AC AD E3             LDY     lookup+1
00DA8C  2               extsbl:
00DA8C  2  8D B5 E3             STA     blknum          ;then save number
00DA8F  2  8C B6 E3             STY     blknum+1
00DA92  2  0D B6 E3             ORA     blknum+1        ;see if zero
00DA95  2  D0 04                BNE     gtgood          ;then proceed
00DA97  2  68                   PLA                     ;clear stack
00DA98  2  A9 02                LDA     #2              ;set end
00DA9A  2  60                   RTS                     ;of data return
00DA9B  2               gtgood:
00DA9B  2  AD B5 E3             LDA     blknum          ;get low again
00DA9E  2  20 6E DD             JSR     setblk          ;set allocation map
00DAA1  2  68                   PLA                     ;get block
00DAA2  2  A8                   TAY                     ;pointer back
00DAA3  2  AD B5 E3             LDA     blknum          ;get number
00DAA6  2  91 02                STA     (addinp),y      ;and put in fcb
00DAA8  2  AD B6 E3             LDA     blknum+1        ;get high
00DAAB  2  C8                   INY
00DAAC  2  2C C5 E3             BIT     blmode          ;test mode
00DAAF  2  10 02                BPL     *+4             ;done if byte
00DAB1  2  91 02                STA     (addinp),y      ;else set high
00DAB3  2               blkopn:
00DAB3  2  20 69 DE             JSR     calrcn          ;calculate record num
00DAB6  2  20 B5 DC             JSR     sttrsc          ;set track and sector
00DAB9  2  20 4D E0             JSR     wrtsec          ;do write
00DABC  2  AE BA E3             LDX     nxtrec          ;get next record
00DABF  2  EC BB E3             CPX     numrec          ;if less than max
00DAC2  2  90 05                BCC     notful          ;then ok
00DAC4  2  E8                   INX                     ;else bump count
00DAC5  2  8E BB E3             STX     numrec          ;and save
00DAC8  2  CA                   DEX                     ;back down
00DAC9  2               notful:
00DAC9  2  E0 7F                CPX     #127            ;if not at max
00DACB  2  D0 11                BNE     noawex          ;skip extending
00DACD  2  20 A7 DD             JSR     updtrc          ;update record counters
00DAD0  2  A2 00                LDX     #0              ;do write
00DAD2  2  20 F6 DE             JSR     extend          ;file extension
00DAD5  2  C9 00                CMP     #0              ;if not ok
00DAD7  2  D0 0A                BNE     extwrt          ;exit
00DAD9  2  A9 FF                LDA     #255            ;else start counter
00DADB  2  8D BA E3             STA     nxtrec          ;at one short
00DADE  2               noawex:
00DADE  2  20 A7 DD             JSR     updtrc          ;then update counters
00DAE1  2  A9 00                LDA     #0              ;good return
00DAE3  2               extwrt:
00DAE3  2  60                   RTS                     ;exit
00DAE4  2               ;execute console input
00DAE4  2               xcnsin:
00DAE4  2  20 8F E0             JSR     getcon          ;get input
00DAE7  2  20 C5 E0             JSR     tstchr          ;test it and
00DAEA  2  90 05                BCC     extxci          ;if control exit
00DAEC  2  48                   PHA                     ;else save
00DAED  2  20 1D E1             JSR     sndchr          ;echo
00DAF0  2  68                   PLA                     ;restore
00DAF1  2               extxci:
00DAF1  2  60                   RTS                     ;return
00DAF2  2               ;switch memory
00DAF2  2               ;page zero block begins at $02 and is numvar bytes long.
00DAF2  2               switch:
00DAF2  2  A2 4F                LDX     #numvar-1       ;get number to switch
00DAF4  2               nxtswh:
00DAF4  2  B5 02                LDA     2,x             ;get zero page
00DAF6  2  BC E1 E3             LDY     varblk,x        ;and save area
00DAF9  2  9D E1 E3             STA     varblk,x        ;save zero
00DAFC  2  94 02                STY     2,x             ;and high
00DAFE  2  CA                   DEX                     ;count down
00DAFF  2  10 F3                BPL     nxtswh          ;and loop until done
00DB01  2               drvsme:
00DB01  2  60                   RTS                     ;then return
00DB02  2               ;change dma address
00DB02  2               ; input:addinp=address
00DB02  2               ; returns:none
00DB02  2               ; alters:all
00DB02  2               chgdma:
00DB02  2  A5 02                LDA     addinp          ;get low
00DB04  2  A4 03                LDY     addinp+1        ;and high address
00DB06  2  85 04                STA     bufadd          ;then store
00DB08  2  84 05                STY     bufadd+1        ;in address
00DB0A  2  4C 55 E4             JMP     sim+36          ;then go to sim
00DB0D  2               
00DB0D  2               ;change drive
00DB0D  2               ; input:bytinp
00DB0D  2               ; returns:none
00DB0D  2               ; alters:all
00DB0D  2               chgdrv:
00DB0D  2  AD 9C E3             LDA     bytinp          ;get input
00DB10  2  CD AF E3             CMP     curdrv          ;if same as current
00DB13  2  F0 EC                BEQ     drvsme          ;do nothing
00DB15  2  8D AF E3             STA     curdrv          ;else change current
00DB18  2  4C 4E DB             JMP     mapdrv          ;then log it in
00DB1B  2               ;automatic drive select
00DB1B  2               ; input:(addinp) 0=no change
00DB1B  2               ; 1-8 or 'A'-'H' = change
00DB1B  2               ; returns:none
00DB1B  2               ; alters:all
00DB1B  2               autodr:
00DB1B  2  A0 00                LDY     #0              ;get
00DB1D  2  B1 02                LDA     (addinp),y      ;first byte of fcb
00DB1F  2  F0 19                BEQ     qtatdr          ;if zero quit
00DB21  2  38                   SEC                     ;set carry for
00DB22  2  E9 01                SBC     #1              ;subtract one
00DB24  2  29 07                AND     #%00000111      ;look at three lsbs
00DB26  2  8D 9C E3             STA     bytinp          ;make parameter
00DB29  2  AD AF E3             LDA     curdrv          ;get current
00DB2C  2  8D AE E3             STA     olddrv          ;and save
00DB2F  2  B1 02                LDA     (addinp),y      ;get fcb entry
00DB31  2  8D A3 E3             STA     tmpdrv          ;and save as flag
00DB34  2  98                   TYA                     ;set a to 0
00DB35  2  91 02                STA     (addinp),y      ;clear byte zero in fcb
00DB37  2  20 0D DB             JSR     chgdrv          ;then select new drive
00DB3A  2               qtatdr:
00DB3A  2  60                   RTS                     ;and return
00DB3B  2               ;execute initialize system
00DB3B  2               ; input:none
00DB3B  2               ; returns:none
00DB3B  2               ; alters:all,curdrv,lginvc,bufadd
00DB3B  2               xintds:
00DB3B  2  A9 00                LDA     #DEFDRV         ;set current
00DB3D  2  8D AF E3             STA     curdrv          ;drive to a
00DB40  2  8D B0 E3             STA     lginvc          ;clear log in status
00DB43  2  A9 28                LDA     #<dflbuf        ;get default buffer
00DB45  2  A0 01                LDY     #>dflbuf        ;address
00DB47  2  85 02                STA     addinp          ;and set up
00DB49  2  84 03                STY     addinp+1        ;parameters
00DB4B  2  20 02 DB             JSR     chgdma          ;change address
00DB4E  2               
00DB4E  2               ;log in drive and set pointers and maps
00DB4E  2               ; input:curdrv
00DB4E  2               ; returns:none
00DB4E  2               ; alters:all
00DB4E  2               mapdrv:
00DB4E  2  AD AF E3             LDA     curdrv          ;if current drive
00DB51  2  C9 08                CMP     #8              ;is 0 to 7
00DB53  2  90 0F                BCC     vlddrv          ;then log it in
00DB55  2               drserr:
00DB55  2  20 70 E0             JSR     errout          ;send error message
00DB58  2  AD EA E2             LDA     sltmvc          ;point to
00DB5B  2  AC EB E2             LDY     sltmvc+1        ;select message
00DB5E  2  20 D4 E0             JSR     sndstr          ;and send it
00DB61  2               
00DB61  2  4C F3 D8             JMP     xwboot          ;and abort
00DB64  2               
00DB64  2               vlddrv:
00DB64  2               ; meep meep meep -- SELF MODIFYING CODE ALERT!
00DB64  2  20 4C E4             JSR     sim+27          ;go to sim to set
00DB67  2  8D 75 DB             STA     cptdcb+1        ;save
00DB6A  2  8C 76 DB             STY     cptdcb+2
00DB6D  2  0D 76 DB             ORA     cptdcb+2        ;see if invalid
00DB70  2               
00DB70  2  F0 E3                BEQ     drserr          ;error if is
00DB72  2               ;capture dcb
00DB72  2  A0 0D                LDY     #14-1           ;do 14 bytes
00DB74  2               cptdcb:
00DB74  2  B9 FF FF             LDA     $ffff,y         ;get value from sim
00DB77  2  99 D0 E3             STA     dcb,y           ;store it
00DB7A  2  88                   DEY
00DB7B  2  10 F7                BPL     cptdcb          ;loop for more
00DB7D  2  AD D6 E3             LDA     blkscd          ;get block size code
00DB80  2  A8                   TAY                     ;save in y
00DB81  2  18                   CLC
00DB82  2  69 03                ADC     #3              ;convert to sxb
00DB84  2  8D C9 E3             STA     sxb             ;and save
00DB87  2  B9 8F E3             LDA     sabtbl,y        ;get sab
00DB8A  2  8D C8 E3             STA     sab             ;and set
00DB8D  2  AD D7 E3             LDA     maxdir          ;get max dir
00DB90  2  8D C6 E3             STA     maxdrc          ;set max dir record
00DB93  2  AD D8 E3             LDA     maxdir+1
00DB96  2  4A                   LSR     a               ;divide by 4
00DB97  2  6E C6 E3             ROR     maxdrc
00DB9A  2  4A                   LSR     a
00DB9B  2  6E C6 E3             ROR     maxdrc
00DB9E  2  8D C7 E3             STA     maxdrc+1        ;then save high
00DBA1  2  A9 00                LDA     #0              ;set mode to byte
00DBA3  2  8D C5 E3             STA     blmode
00DBA6  2  AD D1 E3             LDA     maxblk+1        ;branch if max block
00DBA9  2  F0 05                BEQ     ntm255          ;not over 255
00DBAB  2               ;if y=0 when the following line is executed it means
00DBAB  2               ;that the user has put an illegal combination into
00DBAB  2               ;the disk definition table. may want to consider
00DBAB  2               ;putting some error checking here in the future if
00DBAB  2               ;there is space in pem.
00DBAB  2  88                   DEY                     ;back up index
00DBAC  2  38                   SEC                     ;else set mode to word
00DBAD  2  6E C5 E3             ROR     blmode
00DBB0  2               ntm255:
00DBB0  2  B9 8C E3             LDA     exmtbl,y        ;get extent mask
00DBB3  2  8D DF E3             STA     exm
00DBB6  2               
00DBB6  2  38                   SEC                     ;now calculate cexm1f
00DBB7  2  A9 1F                LDA     #31
00DBB9  2  F9 8C E3             SBC     exmtbl,y
00DBBC  2  8D E0 E3             STA     cexm1f
00DBBF  2  AE AF E3             LDX     curdrv          ;get drive as pointer
00DBC2  2  BD 84 E3             LDA     bitmap,x        ;get bit
00DBC5  2  2D B0 E3             AND     lginvc          ;if logged in
00DBC8  2  D0 0C                BNE     extstm          ;then exit
00DBCA  2  BD 84 E3             LDA     bitmap,x        ;get bit back
00DBCD  2  0D B0 E3             ORA     lginvc          ;set in log-in
00DBD0  2  8D B0 E3             STA     lginvc          ;and update
00DBD3  2  4C D7 DB             JMP     flinal          ;then fill in maps
00DBD6  2               
00DBD6  2               extstm:
00DBD6  2  60                   RTS                     ;and return
00DBD7  2               ;fill in allocation map
00DBD7  2               flinal:
00DBD7  2  20 32 E0             JSR     setrw           ;set to read/write
00DBDA  2  AD D0 E3             LDA     maxblk          ;divide max block by
00DBDD  2  8D CD E3             STA     gpcnt           ;eight to get max
00DBE0  2  AD D1 E3             LDA     maxblk+1
00DBE3  2  A2 03                LDX     #3
00DBE5  2               clcnab:
00DBE5  2  4A                   LSR     a               ;use a for speed
00DBE6  2  6E CD E3             ROR     gpcnt
00DBE9  2  CA                   DEX
00DBEA  2  D0 F9                BNE     clcnab          ;loop if more
00DBEC  2  8D CE E3             STA     gpcnt+1         ;save high
00DBEF  2  EE CD E3             INC     gpcnt           ;bump by one
00DBF2  2  D0 03                BNE     *+5
00DBF4  2  EE CE E3             INC     gpcnt+1         ;with carry
00DBF7  2  AD D9 E3             LDA     alcmap          ;get map start
00DBFA  2  AC DA E3             LDY     alcmap+1
00DBFD  2  85 06                STA     alcpnt          ;set pointer to start
00DBFF  2  84 07                STY     alcpnt+1
00DC01  2  A0 00                LDY     #0              ;clear index
00DC03  2               clraml:
00DC03  2  A9 00                LDA     #0              ;clear byte
00DC05  2  91 06                STA     (alcpnt),y      ;put in map
00DC07  2  E6 06                INC     alcpnt          ;bump pointer
00DC09  2  D0 02                BNE     *+4
00DC0B  2  E6 07                INC     alcpnt+1        ;with carry
00DC0D  2  AD CD E3             LDA     gpcnt           ;get low of count
00DC10  2  D0 03                BNE     *+5             ;skip if not zero
00DC12  2  CE CE E3             DEC     gpcnt+1         ;else drop high
00DC15  2  CE CD E3             DEC     gpcnt           ;always drop low
00DC18  2  AD CD E3             LDA     gpcnt           ;test for zero
00DC1B  2  0D CE E3             ORA     gpcnt+1
00DC1E  2  D0 E3                BNE     clraml          ;loop if more
00DC20  2               ;at this point complete map is cleared
00DC20  2  AD C6 E3             LDA     maxdrc          ;get low of max dir record
00DC23  2  8D CD E3             STA     gpcnt
00DC26  2  AD C7 E3             LDA     maxdrc+1        ;high in a
00DC29  2  AE C9 E3             LDX     sxb             ;set x according to block size
00DC2C  2               clcmdb:
00DC2C  2  4A                   LSR     a               ;do division
00DC2D  2  6E CD E3             ROR     gpcnt
00DC30  2  CA                   DEX
00DC31  2  D0 F9                BNE     clcmdb          ;until x is zero
00DC33  2  8D CE E3             STA     gpcnt+1         ;set high
00DC36  2  EE CD E3             INC     gpcnt           ;then bump by one
00DC39  2  D0 03                BNE     *+5
00DC3B  2  EE CE E3             INC     gpcnt+1
00DC3E  2  8E B5 E3             STX     blknum          ;clear block number
00DC41  2  8E B6 E3             STX     blknum+1
00DC44  2               fildal:
00DC44  2  AD B5 E3             LDA     blknum          ;get block number
00DC47  2  AC B6 E3             LDY     blknum+1
00DC4A  2  20 6E DD             JSR     setblk          ;set bit
00DC4D  2  EE B5 E3             INC     blknum          ;bump block number
00DC50  2  D0 03                BNE     *+5
00DC52  2  EE B6 E3             INC     blknum+1
00DC55  2  AD CD E3             LDA     gpcnt           ;get low of count
00DC58  2  D0 03                BNE     *+5             ;skip if not zero
00DC5A  2  CE CE E3             DEC     gpcnt+1         ;else drop high
00DC5D  2  CE CD E3             DEC     gpcnt           ;always do low
00DC60  2  AD CD E3             LDA     gpcnt           ;test for zero
00DC63  2  0D CE E3             ORA     gpcnt+1
00DC66  2  D0 DC                BNE     fildal          ;loop if more
00DC68  2               ;at this point directory space is mapped
00DC68  2  20 87 DC             JSR     intdrv          ;initialize drive
00DC6B  2  20 E2 DF             JSR     cldrnm          ;clear directory number
00DC6E  2               
00DC6E  2               fillpe:
00DC6E  2  A2 01                LDX     #1              ;parameter for fill
00DC70  2  20 29 DF             JSR     nxtdir          ;execute for next directory
00DC73  2  30 11                BMI     extfil          ;done if invalid
00DC75  2  AC B4 E3             LDY     subrec          ;get offset
00DC78  2  B1 04                LDA     (bufadd),y      ;get empty/valid flag
00DC7A  2  C9 E5                CMP     #$e5            ;if empty
00DC7C  2  F0 F0                BEQ     fillpe          ;try next
00DC7E  2  A2 01                LDX     #1              ;parameter for fill in
00DC80  2  20 EE DF             JSR     mapdir          ;do directory map
00DC83  2  4C 6E DC             JMP     fillpe          ;then loop
00DC86  2               extfil:
00DC86  2  60                   RTS                     ;return
00DC87  2               ;initialize drive
00DC87  2               ; input:nsystr
00DC87  2               ; returns:none
00DC87  2               ; alters:all
00DC87  2               intdrv:
00DC87  2  20 49 E4             JSR     sim+24          ;home then
00DC8A  2  AD D4 E3             LDA     nsystr          ;get number of system tracks
00DC8D  2  AC D5 E3             LDY     nsystr+1
00DC90  2  4C 4F E4             JMP     sim+30          ;and set in sim
00DC93  2               
00DC93  2               ;directory record set up
00DC93  2               ; input:dirnum
00DC93  2               ; returns:none
00DC93  2               ; alters:all,recnum,dirrec
00DC93  2               drrcsu:
00DC93  2  AD B3 E3             LDA     dirnum+1        ;move high dir number
00DC96  2  8D B6 E3             STA     recnum+1        ;to record number
00DC99  2  AD B2 E3             LDA     dirnum          ;divide
00DC9C  2  4E B6 E3             LSR     recnum+1        ;directory by four
00DC9F  2  6A                   ROR     a
00DCA0  2  4E B6 E3             LSR     recnum+1
00DCA3  2  6A                   ROR     a
00DCA4  2  8D BC E3             STA     dirrec          ;and save
00DCA7  2  8D B5 E3             STA     recnum          ;set low record number
00DCAA  2  AD B6 E3             LDA     recnum+1        ;get high
00DCAD  2  8D BD E3             STA     dirrec+1        ;and set
00DCB0  2  A9 00                LDA     #0              ;clear top byte
00DCB2  2  8D B7 E3             STA     recnum+2
00DCB5  2               ;set track and sector
00DCB5  2               ; input:recnum
00DCB5  2               ; returns:none
00DCB5  2               ; alters:all,countr,trkctr
00DCB5  2               sttrsc:
00DCB5  2  A2 00                LDX     #0              ;clear track counter
00DCB7  2  8E CF E3             STX     trkctr
00DCBA  2  8E A7 E3             STX     countr          ;and record
00DCBD  2  8E A8 E3             STX     countr+1        ;counter
00DCC0  2  8E A9 E3             STX     countr+2
00DCC3  2               trnxtr:
00DCC3  2  AD B5 E3             LDA     recnum          ;from
00DCC6  2  CD A7 E3             CMP     countr          ;record number
00DCC9  2  AD B6 E3             LDA     recnum+1        ;and if a
00DCCC  2  ED A8 E3             SBC     countr+1        ;borrow then
00DCCF  2  AD B7 E3             LDA     recnum+2
00DCD2  2  ED A9 E3             SBC     countr+2
00DCD5  2  90 21                BCC     higher          ;gone too far
00DCD7  2  18                   CLC                     ;else
00DCD8  2  AD A7 E3             LDA     countr          ;get counter
00DCDB  2  6D D2 E3             ADC     sectrk          ;add sectors per track
00DCDE  2  8D A7 E3             STA     countr          ;sectors per track
00DCE1  2  AD A8 E3             LDA     countr+1
00DCE4  2  6D D3 E3             ADC     sectrk+1
00DCE7  2  8D A8 E3             STA     countr+1
00DCEA  2  90 03                BCC     bumptr          ;done if no carry
00DCEC  2  EE A9 E3             INC     countr+2        ;else bump high
00DCEF  2               bumptr:
00DCEF  2  E8                   INX                     ;increase track count
00DCF0  2  D0 D1                BNE     trnxtr          ;with carry
00DCF2  2  EE CF E3             INC     trkctr
00DCF5  2  4C C3 DC             JMP     trnxtr          ;then loop
00DCF8  2               higher:
00DCF8  2  CA                   DEX                     ;back up track
00DCF9  2  E0 FF                CPX     #$ff            ;see if wrap around
00DCFB  2  D0 03                BNE     *+5             ;wasn't
00DCFD  2  CE CF E3             DEC     trkctr          ;else drop high
00DD00  2  8A                   TXA                     ;move to a
00DD01  2  18                   CLC                     ;add starting track
00DD02  2  6D D4 E3             ADC     nsystr
00DD05  2  AA                   TAX                     ;save in x
00DD06  2  AD CF E3             LDA     trkctr
00DD09  2  6D D5 E3             ADC     nsystr+1
00DD0C  2  A8                   TAY                     ;move to correct registers
00DD0D  2  8A                   TXA
00DD0E  2  20 4F E4             JSR     sim+30          ;then set in sim
00DD11  2               
00DD11  2  38                   SEC                     ;back
00DD12  2  AD A7 E3             LDA     countr          ;counter down
00DD15  2  ED D2 E3             SBC     sectrk          ;by sectors per track
00DD18  2  8D A7 E3             STA     countr          ;and save
00DD1B  2  AD A8 E3             LDA     countr+1
00DD1E  2  ED D3 E3             SBC     sectrk+1
00DD21  2  8D A8 E3             STA     countr+1
00DD24  2  38                   SEC                     ;now
00DD25  2  AD B5 E3             LDA     recnum          ;find difference
00DD28  2  ED A7 E3             SBC     countr          ;as sector
00DD2B  2  AA                   TAX                     ;save in x
00DD2C  2  AD B6 E3             LDA     recnum+1
00DD2F  2  ED A8 E3             SBC     countr+1
00DD32  2  A8                   TAY                     ;move to correct registers
00DD33  2  8A                   TXA
00DD34  2  20 64 E4             JSR     sim+51          ;translate
00DD37  2               
00DD37  2  4C 52 E4             JMP     sim+33          ;and set through sim
00DD3A  2               
00DD3A  2               ;get block bit mask and index
00DD3A  2               ; input:a&y=block number
00DD3A  2               ; returns:a=bit mask and y=0
00DD3A  2               ; alters:all and alcpnt
00DD3A  2               blkmsk:
00DD3A  2  48                   PHA                     ;save block number
00DD3B  2  84 07                STY     alcpnt+1        ;including high
00DD3D  2  A0 03                LDY     #3              ;divide by eight
00DD3F  2               blkmlp:
00DD3F  2  46 07                LSR     alcpnt+1        ;shift high
00DD41  2  6A                   ROR     a
00DD42  2  88                   DEY                     ;loop until done
00DD43  2  D0 FA                BNE     blkmlp
00DD45  2  18                   CLC                     ;now add map start
00DD46  2  6D D9 E3             ADC     alcmap
00DD49  2  85 06                STA     alcpnt
00DD4B  2  A5 07                LDA     alcpnt+1
00DD4D  2  6D DA E3             ADC     alcmap+1
00DD50  2  85 07                STA     alcpnt+1
00DD52  2  68                   PLA                     ;get number back
00DD53  2  29 07                AND     #%00000111      ;look at 3 lsbs
00DD55  2  AA                   TAX                     ;get
00DD56  2  BD 7C E3             LDA     bitmsk,x        ;mask
00DD59  2  60                   RTS                     ;and return
00DD5A  2               ;test block
00DD5A  2               ; input:a&y=block number
00DD5A  2               ; returns:z=1 if unassigned
00DD5A  2               ; 	   =0 if assigned and bit in a is set
00DD5A  2               ; alters:all
00DD5A  2               tstblk:
00DD5A  2  20 3A DD             JSR     blkmsk          ;get mask and index
00DD5D  2  31 06                AND     (alcpnt),y      ;mask with map entry
00DD5F  2  60                   RTS                     ;then return
00DD60  2               ;alter block status
00DD60  2               ; input:a&y=block number,x=1 if set
00DD60  2               ;		   	  =0 if reset
00DD60  2               ; returns:none
00DD60  2               ; alters:all and allocation map
00DD60  2               altalc:
00DD60  2  E0 01                CPX     #1              ;if set
00DD62  2  F0 0A                BEQ     setblk          ;go do it
00DD64  2               clrblk:
00DD64  2  20 3A DD             JSR     blkmsk          ;else get mask
00DD67  2  49 FF                EOR     #$ff            ;and complement
00DD69  2  31 06                AND     (alcpnt),y      ;preserve others
00DD6B  2  91 06                STA     (alcpnt),y      ;and save
00DD6D  2  60                   RTS                     ;then return
00DD6E  2               setblk:
00DD6E  2  20 3A DD             JSR     blkmsk          ;get mask
00DD71  2  11 06                ORA     (alcpnt),y      ;set bit
00DD73  2  91 06                STA     (alcpnt),y      ;and put back
00DD75  2  60                   RTS                     ;then return
00DD76  2               ;set current drive to read only
00DD76  2               ; input:curdrv,ronlst,bitmap
00DD76  2               ; returns:none
00DD76  2               ; alters:a,x,p and ronlst
00DD76  2               setron:
00DD76  2  AE AF E3             LDX     curdrv          ;get number
00DD79  2  BD 84 E3             LDA     bitmap,x        ;and get mask
00DD7C  2  0D B1 E3             ORA     ronlst          ;or with status
00DD7F  2  8D B1 E3             STA     ronlst          ;and put back
00DD82  2  60                   RTS                     ;then return
00DD83  2               ;calculate checksum of buffer @ bufadd
00DD83  2               ; input: buffer@(bufadd)
00DD83  2               ; returns:a=checksum
00DD83  2               ; alters:a,y,p
00DD83  2               clcchk:
00DD83  2  A9 00                LDA     #0              ;clear accumulator
00DD85  2  A0 7F                LDY     #127            ;start at end
00DD87  2               chkmre:
00DD87  2  18                   CLC                     ;no carry
00DD88  2  71 04                ADC     (bufadd),y      ;add byte
00DD8A  2  88                   DEY                     ;count down
00DD8B  2  10 FA                BPL     chkmre          ;and loop until done
00DD8D  2  60                   RTS                     ;then return
00DD8E  2               ;check read/write status
00DD8E  2               ; input:curdrv,ronlst
00DD8E  2               ; returns:z=0 if r/o or z=1 if r/w
00DD8E  2               ; alters:a,x,p
00DD8E  2               chkron:
00DD8E  2  AE AF E3             LDX     curdrv          ;get current drive
00DD91  2  BD 84 E3             LDA     bitmap,x        ;get mask
00DD94  2  2D B1 E3             AND     ronlst          ;and test status
00DD97  2  60                   RTS
00DD98  2               ;initialize record counters from fcb
00DD98  2               ; input:fcb@(addinp)
00DD98  2               ; returns:none
00DD98  2               ; alters:a,y,p,nxtrec,numrec
00DD98  2               inrcct:
00DD98  2  A0 20                LDY     #32             ;next record offset
00DD9A  2  B1 02                LDA     (addinp),y      ;get next record
00DD9C  2  8D BA E3             STA     nxtrec          ;and save
00DD9F  2  A0 0F                LDY     #15             ;number records offset
00DDA1  2  B1 02                LDA     (addinp),y      ;get number
00DDA3  2  8D BB E3             STA     numrec          ;and save
00DDA6  2  60                   RTS                     ;and return
00DDA7  2               ;update record counters in fcb
00DDA7  2               ; input:nxtrec,numrec
00DDA7  2               ; returns:none
00DDA7  2               ; alters:all,fcb@(addinp)
00DDA7  2               updtrc:
00DDA7  2  AE BA E3             LDX     nxtrec          ;get next record
00DDAA  2  E8                   INX                     ;bump it
00DDAB  2  8A                   TXA                     ;transfer
00DDAC  2  A0 20                LDY     #32             ;set offset
00DDAE  2  91 02                STA     (addinp),y      ;and store in fcb
00DDB0  2  AD BB E3             LDA     numrec          ;get number
00DDB3  2  A0 0F                LDY     #15             ;and its offset
00DDB5  2  91 02                STA     (addinp),y      ;and store
00DDB7  2  60                   RTS                     ;then return
00DDB8  2               ;execute open file
00DDB8  2               xopen:
00DDB8  2  20 1B DB             JSR     autodr          ;auto drive select
00DDBB  2               ;open file
00DDBB  2               ; input:fcb @ (addinp)
00DDBB  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00DDBB  2               ; alters:all
00DDBB  2               opnfle:
00DDBB  2  20 1A DE             JSR     fndf13          ;match all including extent
00DDBE  2  30 32                BMI     extopn          ;done if not found
00DDC0  2  A9 0C                LDA     #12             ;point to first char
00DDC2  2  0D B4 E3             ORA     subrec          ;add offset
00DDC5  2  A8                   TAY                     ;make it a pointer
00DDC6  2               nxopmv:
00DDC6  2  B1 04                LDA     (bufadd),y      ;get buffer contents
00DDC8  2  AA                   TAX                     ;and save
00DDC9  2  98                   TYA                     ;save index
00DDCA  2  29 1F                AND     #%00011111      ;remove offset
00DDCC  2  A8                   TAY                     ;back to index
00DDCD  2  8A                   TXA                     ;get byte back
00DDCE  2  91 02                STA     (addinp),y      ;and store in fcb
00DDD0  2  98                   TYA                     ;get index
00DDD1  2  0D B4 E3             ORA     subrec          ;add offset back
00DDD4  2  A8                   TAY                     ;and make index again
00DDD5  2  C8                   INY                     ;next position
00DDD6  2  98                   TYA                     ;if index
00DDD7  2  29 1F                AND     #%00011111      ;not gone past
00DDD9  2  D0 EB                BNE     nxopmv          ;end then loop
00DDDB  2               ;now correct extent and max records
00DDDB  2  A0 0C                LDY     #12             ;point at extent in fcb
00DDDD  2  AD 96 E3             LDA     savext          ;get save from search
00DDE0  2  D1 02                CMP     (addinp),y      ;compare
00DDE2  2  F0 0B                BEQ     extsme          ;jump ahead if same
00DDE4  2  91 02                STA     (addinp),y      ;else change extent
00DDE6  2  A9 80                LDA     #128            ;assume fcb ext < dir ext
00DDE8  2  90 01                BCC     fcbxls          ;jump ahead if true
00DDEA  2  0A                   ASL     a               ;clear a
00DDEB  2               fcbxls:
00DDEB  2  A0 0F                LDY     #15             ;point to max
00DDED  2  91 02                STA     (addinp),y      ;and set
00DDEF  2               extsme:
00DDEF  2  AD BE E3             LDA     dirmod          ;else get number
00DDF2  2               extopn:
00DDF2  2  60                   RTS                     ;and return
00DDF3  2               ;execute close file
00DDF3  2               xclose:
00DDF3  2  20 1B DB             JSR     autodr          ;auto drive select
00DDF6  2               ;close file
00DDF6  2               ;if file is r/o then no actual close
00DDF6  2               ;operation is performed.
00DDF6  2               ; input:fcb @ (addinp)
00DDF6  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00DDF6  2               ; alters:all
00DDF6  2               clsfle:
00DDF6  2  20 1A DE             JSR     fndf13          ;match including extent
00DDF9  2  30 1B                BMI     extcls          ;exit if not found
00DDFB  2  20 8E DD             JSR     chkron          ;see if r/o
00DDFE  2  D0 13                BNE     noclse          ;branch if is
00DE00  2               ;now set flag to ensure directory extent and number of
00DE00  2               ;records fields are only changed if necessary.
00DE00  2               ;The decision to change is determined by whether or
00DE00  2               ;not the system is closing an extent less than the
00DE00  2               ;maximum extent in the directory entry. If that is
00DE00  2               ;the case, the directory extent and number of record
00DE00  2               ;fields are not changed.
00DE00  2  A0 0C                LDY     #12             ;get extent
00DE02  2  B1 02                LDA     (addinp),y
00DE04  2  48                   PHA                     ;save it
00DE05  2  98                   TYA                     ;now look in directory
00DE06  2  0D B4 E3             ORA     subrec
00DE09  2  A8                   TAY
00DE0A  2  68                   PLA                     ;get extent back
00DE0B  2  D1 04                CMP     (bufadd),y
00DE0D  2  6E 94 E3             ROR     skpdir          ;save result
00DE10  2               ;now go do it
00DE10  2  20 85 DE             JSR     updtdr          ;update directory
00DE13  2               noclse:
00DE13  2  AD BE E3             LDA     dirmod          ;get directory number
00DE16  2               extcls:
00DE16  2  60                   RTS                     ;and return
00DE17  2               ;execute find first match
00DE17  2               xfndfr:
00DE17  2  20 1B DB             JSR     autodr          ;auto drive select
00DE1A  2               fndf13:
00DE1A  2  A9 0D                LDA     #13             ;match including extent
00DE1C  2               ;search for first match
00DE1C  2               ; input:a=number char to match
00DE1C  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00DE1C  2               ; alters:all
00DE1C  2               frstsr:
00DE1C  2  48                   PHA                     ;save number to match
00DE1D  2  20 E2 DF             JSR     cldrnm          ;clear directory number to -1
00DE20  2  20 87 DC             JSR     intdrv          ;and drive
00DE23  2  68                   PLA                     ;get number to match
00DE24  2               ;search for directory match
00DE24  2               ; input:a=number char to match
00DE24  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00DE24  2               ; alters:all
00DE24  2               search:
00DE24  2  8D B8 E3             STA     chrcnt          ;save number
00DE27  2               newtry:
00DE27  2  A2 00                LDX     #0              ;set for search
00DE29  2  8E B9 E3             STX     cmppnt          ;clear pointer
00DE2C  2  20 29 DF             JSR     nxtdir          ;get next entry
00DE2F  2  30 37                BMI     exitsr          ;exit if not found
00DE31  2  AE B8 E3             LDX     chrcnt          ;get count
00DE34  2               mremch:
00DE34  2  AC B9 E3             LDY     cmppnt          ;get pointer
00DE37  2  EE B9 E3             INC     cmppnt          ;and bump
00DE3A  2  B1 02                LDA     (addinp),y      ;get fcb entry
00DE3C  2  C0 0C                CPY     #12             ;see if at extent
00DE3E  2  D0 13                BNE     notaex          ;jump if not
00DE40  2  8D 96 E3             STA     savext          ;save for later use
00DE43  2  48                   PHA                     ;save extent
00DE44  2  98                   TYA                     ;change to directory
00DE45  2  0D B4 E3             ORA     subrec          ;coordinates
00DE48  2  A8                   TAY
00DE49  2  68                   PLA                     ;get extent back
00DE4A  2  51 04                EOR     (bufadd),y      ;exclusive or with dir
00DE4C  2  2D E0 E3             AND     cexm1f          ;and with exm complement + 1f
00DE4F  2  F0 11                BEQ     trynxt          ;ok if zero
00DE51  2  D0 D4                BNE     newtry          ;else get next directory
00DE53  2               notaex:
00DE53  2  C9 3F                CMP     #'?'            ;if a ? then
00DE55  2  F0 0B                BEQ     trynxt          ;is a match
00DE57  2  48                   PHA                     ;save char
00DE58  2  98                   TYA                     ;then add
00DE59  2  0D B4 E3             ORA     subrec          ;offset to
00DE5C  2  A8                   TAY                     ;make pointer
00DE5D  2  68                   PLA                     ;get char back
00DE5E  2               ;        sta     savex
00DE5E  2               ;        lda	(bufadd),y	;if not same
00DE5E  2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
00DE5E  2               ;	cmp	savex	        ;if not same
00DE5E  2  D1 04                CMP     (bufadd),y      ;if not same
00DE60  2  D0 C5                BNE     newtry          ;try next directory
00DE62  2               trynxt:
00DE62  2  CA                   DEX                     ;else count number down
00DE63  2  D0 CF                BNE     mremch          ;and loop if more
00DE65  2  AD BE E3             LDA     dirmod          ;return with directory
00DE68  2               exitsr:
00DE68  2  60                   RTS                     ;number mod 4
00DE69  2               ;calculate logical record number
00DE69  2               ; input:blknum
00DE69  2               ; returns:none
00DE69  2               ; alters:a,x,p,recnum
00DE69  2               calrcn:
00DE69  2  AE C9 E3             LDX     sxb             ;set x according to blkscd
00DE6C  2               mulmre:
00DE6C  2  0E B5 E3             ASL     blknum          ;multiply block
00DE6F  2  2E B6 E3             ROL     blknum+1        ;number
00DE72  2  2E B7 E3             ROL     blknum+2
00DE75  2  CA                   DEX                     ;by code
00DE76  2  D0 F4                BNE     mulmre
00DE78  2  AD C8 E3             LDA     sab             ;set mask in a
00DE7B  2  2D BA E3             AND     nxtrec          ;and with next record
00DE7E  2  0D B5 E3             ORA     recnum          ;or with number
00DE81  2  8D B5 E3             STA     recnum          ;and save
00DE84  2  60                   RTS
00DE85  2               ;update directory
00DE85  2               updtdr:
00DE85  2  A9 20                LDA     #32             ;change all
00DE87  2  A2 00                LDX     #0              ;from start
00DE89  2               ;change directory entry
00DE89  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00DE89  2               ; returns:none
00DE89  2               ; alters:all,directory,checksums
00DE89  2               dirchg:
00DE89  2  8D B8 E3             STA     chrcnt          ;save count
00DE8C  2  CE B8 E3             DEC     chrcnt          ;back up
00DE8F  2               mrechg:
00DE8F  2  18                   CLC                     ;clear carry
00DE90  2  8A                   TXA                     ;get offset
00DE91  2  6D B8 E3             ADC     chrcnt          ;compute index
00DE94  2  A8                   TAY                     ;and set
00DE95  2  C0 0C                CPY     #12             ;see if at extent
00DE97  2  F0 04                BEQ     docare          ;if so do special
00DE99  2  C0 0F                CPY     #15             ;see if at number rec
00DE9B  2  D0 05                BNE     dntcar          ;if not skip
00DE9D  2               docare:
00DE9D  2  2C 94 E3             BIT     skpdir          ;check flag
00DEA0  2  10 0D                BPL     nochng          ;skip if ok
00DEA2  2               dntcar:
00DEA2  2  B1 02                LDA     (addinp),y      ;get char
00DEA4  2  48                   PHA                     ;save it
00DEA5  2  AD B8 E3             LDA     chrcnt          ;get count
00DEA8  2  0D B4 E3             ORA     subrec          ;add offset
00DEAB  2  A8                   TAY                     ;make an index
00DEAC  2  68                   PLA                     ;get char back
00DEAD  2  91 04                STA     (bufadd),y      ;and put in buffer
00DEAF  2               nochng:
00DEAF  2  CE B8 E3             DEC     chrcnt          ;count down
00DEB2  2  10 DB                BPL     mrechg          ;and loop
00DEB4  2  20 93 DC             JSR     drrcsu          ;set it up
00DEB7  2  4C 47 E0             JMP     updtck          ;and do change
00DEBA  2               ;execute create file
00DEBA  2               xmake:
00DEBA  2  20 1B DB             JSR     autodr          ;auto drive select
00DEBD  2               ;create file
00DEBD  2               ; input:fcb@(addinp)
00DEBD  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00DEBD  2               ; alters:dirnum,dirmod,fcb@(addinp)
00DEBD  2               mkefle:
00DEBD  2  20 1E E0             JSR     tstron          ;test for r/o
00DEC0  2  A5 02                LDA     addinp          ;save fcb
00DEC2  2  48                   PHA                     ;address
00DEC3  2  A5 03                LDA     addinp+1        ;on
00DEC5  2  48                   PHA                     ;stack
00DEC6  2  AD ED E2             LDA     empdvc          ;then point
00DEC9  2  AC EE E2             LDY     empdvc+1        ;to empty
00DECC  2  85 02                STA     addinp          ;dummy
00DECE  2  84 03                STY     addinp+1        ;fcb
00DED0  2  A9 01                LDA     #1              ;match only
00DED2  2  20 1C DE             JSR     frstsr          ;first char
00DED5  2  68                   PLA                     ;restore
00DED6  2  85 03                STA     addinp+1        ;fcb
00DED8  2  68                   PLA                     ;address
00DED9  2  85 02                STA     addinp          ;from stack
00DEDB  2  AD BE E3             LDA     dirmod          ;get number mod 4
00DEDE  2  30 15                BMI     extmke          ;quit if not found
00DEE0  2  A0 0D                LDY     #13             ;else set up
00DEE2  2  A9 00                LDA     #0              ;to clear
00DEE4  2               mkeagn:
00DEE4  2  91 02                STA     (addinp),y      ;rest of
00DEE6  2  C8                   INY                     ;fcb
00DEE7  2  C0 21                CPY     #33             ;including next
00DEE9  2  D0 F9                BNE     mkeagn          ;record
00DEEB  2               ;the next two lines ensure that the extent and
00DEEB  2               ;number of records fields are updated
00DEEB  2  38                   SEC
00DEEC  2  6E 94 E3             ROR     skpdir
00DEEF  2  20 85 DE             JSR     updtdr          ;update directory
00DEF2  2  AD BE E3             LDA     dirmod          ;get number
00DEF5  2               extmke:
00DEF5  2  60                   RTS                     ;and quit
00DEF6  2               ;extend file
00DEF6  2               ; input:fcb@(addinp), x=1 read
00DEF6  2               ;		        0 write
00DEF6  2               extend:
00DEF6  2  8E A2 E3             STX     exrwfl          ;save parameter
00DEF9  2  20 F6 DD             JSR     clsfle          ;close current extent
00DEFC  2  30 2A                BMI     extext          ;exit if not found
00DEFE  2  A0 0C                LDY     #12             ;else
00DF00  2  B1 02                LDA     (addinp),y      ;get extent
00DF02  2  18                   CLC                     ;and
00DF03  2  69 01                ADC     #1              ;add one
00DF05  2  29 1F                AND     #%00011111      ;see if overflow
00DF07  2  F0 17                BEQ     exteof          ;eof if so
00DF09  2  91 02                STA     (addinp),y      ;and save
00DF0B  2  20 1A DE             JSR     fndf13          ;see if next extent exists
00DF0E  2  10 0B                BPL     opnext          ;if so open
00DF10  2  AD A2 E3             LDA     exrwfl          ;if not and is write then create
00DF13  2  D0 13                BNE     extext          ;else return as eof
00DF15  2               dwrtex:
00DF15  2  20 BD DE             JSR     mkefle          ;create file
00DF18  2  4C 1E DF             JMP     tstext          ;and test
00DF1B  2               opnext:
00DF1B  2  20 BB DD             JSR     opnfle          ;open
00DF1E  2               tstext:
00DF1E  2  10 03                BPL     extnok          ;continue if ok
00DF20  2               exteof:
00DF20  2  A9 01                LDA     #1              ;else set eof
00DF22  2  60                   RTS                     ;and return
00DF23  2               extnok:
00DF23  2  20 98 DD             JSR     inrcct          ;initialize counters
00DF26  2  A9 00                LDA     #0              ;good
00DF28  2               extext:
00DF28  2  60                   RTS                     ;return
00DF29  2               ;set up next directory block
00DF29  2               ; input:dirnum,x=1 for update checksum
00DF29  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00DF29  2               ; alters:alll,dirnum,dirmod
00DF29  2               nxtdir:
00DF29  2  8A                   TXA                     ;save operation
00DF2A  2  48                   PHA                     ;on stack
00DF2B  2  EE B2 E3             INC     dirnum          ;bump directory
00DF2E  2  D0 03                BNE     *+5
00DF30  2  EE B3 E3             INC     dirnum+1
00DF33  2               
00DF33  2  AD D7 E3             LDA     maxdir          ;if not at limit continue
00DF36  2  CD B2 E3             CMP     dirnum
00DF39  2  AD D8 E3             LDA     maxdir+1
00DF3C  2  ED B3 E3             SBC     dirnum+1
00DF3F  2  B0 05                BCS     gtnxdr          ;then continue
00DF41  2  68                   PLA                     ;else clear stack
00DF42  2  AA                   TAX                     ;and set x
00DF43  2  4C E2 DF             JMP     cldrnm          ;set to invalid
00DF46  2               gtnxdr:
00DF46  2  AD B2 E3             LDA     dirnum          ;get low again
00DF49  2  29 03                AND     #%00000011      ;look at 2 lsbs
00DF4B  2  8D BE E3             STA     dirmod          ;save mod 4
00DF4E  2  0A                   ASL     a               ;multiply
00DF4F  2  0A                   ASL     a               ;by
00DF50  2  0A                   ASL     a               ;32 to
00DF51  2  0A                   ASL     a               ;get pointer
00DF52  2  0A                   ASL     a               ;offset
00DF53  2  8D B4 E3             STA     subrec          ;and save
00DF56  2  F0 05                BEQ     getdir          ;if zero read new
00DF58  2  68                   PLA                     ;else clear stack
00DF59  2  AA                   TAX                     ;set x
00DF5A  2  4C 65 DF             JMP     gotdir          ;and exit
00DF5D  2               getdir:
00DF5D  2  20 93 DC             JSR     drrcsu          ;set up to read
00DF60  2  20 41 E0             JSR     rdesec          ;do read
00DF63  2  68                   PLA                     ;get operation
00DF64  2  AA                   TAX                     ;code
00DF65  2               ;;;;;;	jsr	chksop		;do it
00DF65  2               gotdir:
00DF65  2  AD BE E3             LDA     dirmod          ;and return
00DF68  2               exnxdr:
00DF68  2  60                   RTS                     ;with number
00DF69  2               ;checksum operation
00DF69  2               ;this routine assumes calling routine has checked for
00DF69  2               ;valid dirnum and hence valid dirrec
00DF69  2               ; input:chkflg,dirrec,x (1=update else check)
00DF69  2               ; returns:none
00DF69  2               ; alters:map@(chkmap)
00DF69  2               chksop:
00DF69  2  60                   rts
00DF6A  2  2C DB E3             BIT     chkflg          ;check flag
00DF6D  2  30 F9                BMI     exnxdr          ;done if set
00DF6F  2  CA                   DEX                     ;dec code
00DF70  2  D0 09                BNE     tstchk          ;if not zero test
00DF72  2  20 83 DD             JSR     clcchk          ;else calculate
00DF75  2  20 CC DF             JSR     clcckp          ;calculate pointer
00DF78  2  91 08                STA     (chkpnt),y      ;and save
00DF7A  2  60                   RTS                     ;then return
00DF7B  2               tstchk:
00DF7B  2  20 83 DD             JSR     clcchk          ;do calculation
00DF7E  2  20 CC DF             JSR     clcckp          ;calculate pointer
00DF81  2  D1 08                CMP     (chkpnt),y      ;compare to old
00DF83  2  F0 E3                BEQ     exnxdr          ;if equal ok
00DF85  2  4C 76 DD             JMP     setron          ;else set to r/o
00DF88  2               ;get block number
00DF88  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00DF88  2               ; returns:none
00DF88  2               ; alters:all,blknum
00DF88  2               getblk:
00DF88  2  AE C9 E3             LDX     sxb             ;set x according to blkscd
00DF8B  2  AD BA E3             LDA     nxtrec          ;get next record
00DF8E  2               gblp:
00DF8E  2  4A                   LSR     a               ;divide by 2 x times
00DF8F  2  CA                   DEX
00DF90  2  D0 FC                BNE     gblp
00DF92  2  8D B5 E3             STA     blknum          ;save previous as temp
00DF95  2               ;use extent as offset but first use sxb to create param
00DF95  2  38                   SEC
00DF96  2  A9 08                LDA     #8
00DF98  2  ED C9 E3             SBC     sxb
00DF9B  2  AA                   TAX
00DF9C  2               ;now get extent from fcb
00DF9C  2  A0 0C                LDY     #12
00DF9E  2  B1 02                LDA     (addinp),y
00DFA0  2  2D DF E3             AND     exm             ;and with mask
00DFA3  2  4A                   LSR     a               ;shift with lsb to c
00DFA4  2               gbxlp:
00DFA4  2  2A                   ROL     a               ;now go other way
00DFA5  2  CA                   DEX
00DFA6  2  D0 FC                BNE     gbxlp
00DFA8  2  18                   CLC                     ;now add saved value
00DFA9  2  6D B5 E3             ADC     blknum          ;back
00DFAC  2  2C C5 E3             BIT     blmode          ;test mode
00DFAF  2  10 01                BPL     *+3             ;skip if byte
00DFB1  2  0A                   ASL     a               ;else times two
00DFB2  2  18                   CLC                     ;then add
00DFB3  2  69 10                ADC     #16             ;offset into fcb
00DFB5  2  8D 95 E3             STA     fcbind          ;save for later
00DFB8  2  A8                   TAY                     ;set index
00DFB9  2  B1 02                LDA     (addinp),y      ;get number
00DFBB  2  8D B5 E3             STA     blknum          ;store
00DFBE  2  C8                   INY
00DFBF  2  A9 00                LDA     #0              ;clear
00DFC1  2  2C C5 E3             BIT     blmode          ;test mode
00DFC4  2  10 02                BPL     *+4             ;skip if byte
00DFC6  2  B1 02                LDA     (addinp),y      ;else get high
00DFC8  2  8D B6 E3             STA     blknum+1        ;high byte
00DFCB  2  60                   RTS                     ;and return
00DFCC  2               ;calculate chkpnt as function of dirrec and chkmap
00DFCC  2               ; input:dirrec,chkmap
00DFCC  2               ; returns:y=0
00DFCC  2               ; alters:y,p,chkpnt
00DFCC  2               clcckp:
00DFCC  2  48                   PHA                     ;save a
00DFCD  2  18                   CLC
00DFCE  2  AD BC E3             LDA     dirrec          ;add record number
00DFD1  2  6D DC E3             ADC     chkmap          ;to start
00DFD4  2  85 08                STA     chkpnt
00DFD6  2  AD BD E3             LDA     dirrec+1
00DFD9  2  6D DD E3             ADC     chkmap+1
00DFDC  2  85 09                STA     chkpnt+1
00DFDE  2  A0 00                LDY     #0
00DFE0  2  68                   PLA                     ;get a back
00DFE1  2  60                   RTS
00DFE2  2               ;clear directory number to $ffff
00DFE2  2               ; input:none
00DFE2  2               ; returns:a=$ff,n=1,z=0
00DFE2  2               ; alters:a,p,dirnum,dirmod
00DFE2  2               cldrnm:
00DFE2  2  A9 FF                LDA     #$ff            ;set to $ff
00DFE4  2  8D B2 E3             STA     dirnum
00DFE7  2  8D B3 E3             STA     dirnum+1
00DFEA  2  8D BE E3             STA     dirmod
00DFED  2  60                   RTS
00DFEE  2               ;change allocation map
00DFEE  2               ; input:subrec,directory record @ (bufadd)
00DFEE  2               ; returns:none
00DFEE  2               ; alters:all,allocation map
00DFEE  2               mapdir:
00DFEE  2  18                   CLC                     ;add 16 to
00DFEF  2  AD B4 E3             LDA     subrec          ;to subrec to point
00DFF2  2  69 10                ADC     #16             ;to block number field
00DFF4  2  A8                   TAY                     ;make index
00DFF5  2               lpmpdr:
00DFF5  2  8C C3 E3             STY     mpdrsy          ;save index
00DFF8  2  8A                   TXA                     ;save x
00DFF9  2  48                   PHA                     ;operation
00DFFA  2  B1 04                LDA     (bufadd),y      ;get block number
00DFFC  2  8D C4 E3             STA     mpdrtm          ;save in temp
00DFFF  2  C8                   INY                     ;bump index for word
00E000  2  20 82 E0             JSR     gthibn          ;get high part of number
00E003  2               mpdrnw:
00E003  2  0D C4 E3             ORA     mpdrtm          ;see if zero
00E006  2  F0 0A                BEQ     skpedr          ;skip if zero
00E008  2  20 82 E0             JSR     gthibn          ;get high again
00E00B  2  A8                   TAY                     ;move to y
00E00C  2  AD C4 E3             LDA     mpdrtm          ;get low again
00E00F  2  20 60 DD             JSR     altalc          ;else alter map
00E012  2               skpedr:
00E012  2  68                   PLA                     ;get operation
00E013  2  AA                   TAX                     ;back
00E014  2  AC C3 E3             LDY     mpdrsy          ;get index back
00E017  2  C8                   INY                     ;bump it
00E018  2  98                   TYA                     ;if still
00E019  2  29 0F                AND     #%00001111      ;in field
00E01B  2  D0 D8                BNE     lpmpdr          ;then loop
00E01D  2  60                   RTS                     ;else quit
00E01E  2               ;test r/w status
00E01E  2               ;does warm boot if r/o
00E01E  2               ; input:curdrv,ronlst
00E01E  2               ; returns:none
00E01E  2               ; alters:a,x,p
00E01E  2               tstron:
00E01E  2  20 8E DD             JSR     chkron          ;test bit
00E021  2  F0 1D                BEQ     exttro          ;exit if r/w
00E023  2  20 70 E0             JSR     errout          ;else send error
00E026  2  AD F0 E2             LDA     rommvc          ;point to r/o
00E029  2  AC F1 E2             LDY     rommvc+1        ;message
00E02C  2  20 D4 E0             JSR     sndstr          ;send it
00E02F  2  4C F3 D8             JMP     xwboot          ;then abort
00E032  2               ;set current drive to r/w
00E032  2               ; input:curdrv,ronlst
00E032  2               ; returns:ronlst
00E032  2               ; alters:a,x,p,ronlst
00E032  2               setrw:
00E032  2  AE AF E3             LDX     curdrv          ;get drive
00E035  2  BD 84 E3             LDA     bitmap,x        ;and mask
00E038  2  49 FF                EOR     #$ff            ;complement
00E03A  2  2D B1 E3             AND     ronlst          ;and with status
00E03D  2  8D B1 E3             STA     ronlst          ;save
00E040  2               exttro:
00E040  2  60                   RTS                     ;return
00E041  2               ;read sector
00E041  2               rdesec:
00E041  2  20 58 E4             JSR     sim+39          ;do read
00E044  2               
00E044  2  4C 53 E0             JMP     chkrwe          ;check for error
00E047  2               ;update checksum and directory
00E047  2               updtck:
00E047  2  A2 01                LDX     #1              ;set for update
00E049  2               ;;;;;	jsr	chksop		;do it
00E049  2  A9 01                LDA     #1              ;say is directory op
00E04B  2  D0 03                BNE     secwrt          ;do it
00E04D  2               ;write sector
00E04D  2               wrtsec:
00E04D  2  AD DE E3             LDA     pemwrtype       ;get write type
00E050  2               secwrt:
00E050  2  20 5B E4             JSR     sim+42          ;do write
00E053  2               
00E053  2               chkrwe:
00E053  2  C9 00                CMP     #0              ;if not ok
00E055  2  F0 E9                BEQ     exttro          ;done if zero
00E057  2               ;read/write error
00E057  2               rwerrt:
00E057  2  20 70 E0             JSR     errout          ;send error message
00E05A  2  AD F3 E2             LDA     bdsmvc          ;point to
00E05D  2  AC F4 E2             LDY     bdsmvc+1        ;bad sector message
00E060  2  20 D4 E0             JSR     sndstr          ;and send
00E063  2  20 8F E0             JSR     getcon          ;get input
00E066  2  C9 0D                CMP     #cr             ;if a cr
00E068  2  F0 03                BEQ     ignerr          ;then continue
00E06A  2  4C F3 D8             JMP     xwboot          ;else abort
00E06D  2               ignerr:
00E06D  2  4C 6B E2             JMP     pcrlf           ;crlf and return
00E070  2               ;error output routine
00E070  2               ; input:curdrv,pemmvc
00E070  2               ; returns:none
00E070  2               ; alters:all
00E070  2               errout:
00E070  2  AD F6 E2             LDA     pemmvc          ;point to
00E073  2  AC F7 E2             LDY     pemmvc+1        ;error message
00E076  2  20 D4 E0             JSR     sndstr          ;send it
00E079  2  AD AF E3             LDA     curdrv          ;get drive number
00E07C  2  18                   CLC                     ;add
00E07D  2  69 41                ADC     #'A'            ;ascii a
00E07F  2  4C 1D E1             JMP     sndchr          ;and send it
00E082  2               ;get high part of block number if word (zero if byte)
00E082  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00E082  2               ; returns:a=high part of block number
00E082  2               ; alters:a,p,mpdrsy iff word
00E082  2               gthibn:
00E082  2  A9 00                LDA     #0              ;preset for byte
00E084  2  2C C5 E3             BIT     blmode          ;test mode
00E087  2  10 05                BPL     gthiex          ;done if byte
00E089  2  B1 04                LDA     (bufadd),y      ;get high
00E08B  2  8C C3 E3             STY     mpdrsy          ;alter y
00E08E  2               gthiex:
00E08E  2  60                   RTS
00E08F  2               ;get console input
00E08F  2               ; input:pndkey
00E08F  2               ; returns:a=character
00E08F  2               ; alters:all,pndkey
00E08F  2               getcon:
00E08F  2  AD 98 E3             LDA     pndkey          ;get pending
00E092  2  48                   PHA                     ;save it
00E093  2  A9 00                LDA     #0              ;clear
00E095  2  8D 98 E3             STA     pndkey          ;pending
00E098  2  68                   PLA                     ;restore
00E099  2  D0 03                BNE     extget          ;exit if not null
00E09B  2  20 3A E4             JSR     sim+9           ;else get new
00E09E  2               
00E09E  2               extget:
00E09E  2  60                   RTS                     ;and return
00E09F  2               ;check keyboard status
00E09F  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00E09F  2               ; input:pndkey
00E09F  2               ; returns:a=0 if no input or <>0 if input
00E09F  2               ; alters:all,pndkey
00E09F  2               kbdsts:
00E09F  2  AD 98 E3             LDA     pndkey          ;get pending
00E0A2  2  D0 20                BNE     extkbd          ;if there quit
00E0A4  2  20 37 E4             JSR     sim+6           ;else test
00E0A7  2  C9 00                CMP     #$00            ;if zero
00E0A9  2  F0 19                BEQ     extkbd          ;exit
00E0AB  2  20 3A E4             JSR     sim+9           ;else get input
00E0AE  2  C9 13                CMP     #ctls           ;if not freeze
00E0B0  2  D0 0D                BNE     newpnd          ;save input
00E0B2  2  20 3A E4             JSR     sim+9           ;else wait for more
00E0B5  2  C9 03                CMP     #ctlc           ;if not abort
00E0B7  2  D0 03                BNE     nowarm          ;then jump
00E0B9  2  4C F3 D8             JMP     xwboot          ;else do warm boot
00E0BC  2               nowarm:
00E0BC  2  A9 00                LDA     #0              ;clear
00E0BE  2  60                   RTS                     ;and return
00E0BF  2               newpnd:
00E0BF  2  8D 98 E3             STA     pndkey          ;save
00E0C2  2  A9 FF                LDA     #$ff            ;set ready
00E0C4  2               extkbd:
00E0C4  2  60                   RTS                     ;and return
00E0C5  2               ;test character
00E0C5  2               ; input:a=character
00E0C5  2               ; returns:c=0 if control or c=1 if printing
00E0C5  2               ; alters:p
00E0C5  2               tstchr:
00E0C5  2  C9 0D                CMP     #cr             ;if cr
00E0C7  2  F0 0A                BEQ     chtext          ;quit
00E0C9  2  C9 0A                CMP     #lf             ;if linefeed
00E0CB  2  F0 06                BEQ     chtext          ;quit
00E0CD  2  C9 09                CMP     #ctli           ;if tab
00E0CF  2  F0 02                BEQ     chtext          ;quit
00E0D1  2  C9 20                CMP     #' '            ;see if control
00E0D3  2               chtext:
00E0D3  2  60                   RTS                     ;and return
00E0D4  2               ;send string ending in $
00E0D4  2               ; input:ay=string address
00E0D4  2               ; returns:none
00E0D4  2               ; alters:all,index,sndlpe+1 and +2
00E0D4  2               sndstr:
00E0D4  2  8D DD E0             STA     sndlpe+1        ;set pointer
00E0D7  2  8C DE E0             STY     sndlpe+2
00E0DA  2  A0 00                LDY     #0
00E0DC  2               sndlpe:
00E0DC  2  B9 FF FF             LDA     $ffff,y         ;get char
00E0DF  2  C9 24                CMP     #'$'            ;if terminator
00E0E1  2  F0 0C                BEQ     sndext          ;then exit
00E0E3  2  C8                   INY                     ;else bump
00E0E4  2  8C BF E3             STY     index           ;and save
00E0E7  2  20 1D E1             JSR     sndchr          ;send char
00E0EA  2  AC BF E3             LDY     index           ;get index
00E0ED  2  D0 ED                BNE     sndlpe          ;and loop
00E0EF  2               sndext:
00E0EF  2  60                   RTS                     ;return
00E0F0  2               ;send char to printer if enabled
00E0F0  2               ; input:a=character,lstflg
00E0F0  2               ; returns:a=character
00E0F0  2               ; alters:x,y,p
00E0F0  2               lstout:
00E0F0  2  2C 99 E3             BIT     lstflg          ;test flag
00E0F3  2  10 0A                BPL     extlst          ;exit if off
00E0F5  2  2C C1 E3             BIT     outflg          ;test output flag
00E0F8  2  30 05                BMI     extlst          ;done if set
00E0FA  2  48                   PHA                     ;save char
00E0FB  2  20 40 E4             JSR     sim+15          ;send
00E0FE  2  68                   PLA                     ;get char
00E0FF  2               extlst:
00E0FF  2  60                   RTS                     ;and done
00E100  2               ;output a character
00E100  2               ; input:a=character,console definition block in sim
00E100  2               ; returns:none
00E100  2               ; alters:all,positn
00E100  2               output:
00E100  2  20 C5 E0             JSR     tstchr          ;test it
00E103  2  B0 18                BCS     sndchr          ;if not control jump
00E105  2  48                   PHA                     ;else save
00E106  2  AD 6B E4             LDA     sysdef+4        ;get invert
00E109  2  20 36 E1             JSR     nolist          ;send to console
00E10C  2  A9 5E                LDA     #'^'            ;get arrow
00E10E  2  20 F0 E0             JSR     lstout          ;send to printer
00E111  2  68                   PLA                     ;get character
00E112  2  09 40                ORA     #'A'-1          ;convert to ascii
00E114  2  20 2E E1             JSR     pchrot          ;send to all
00E117  2  AD 6A E4             LDA     sysdef+3        ;get normal
00E11A  2  4C 36 E1             JMP     nolist          ;to console
00E11D  2               sndchr:
00E11D  2  C9 09                CMP     #ctli           ;if not tab
00E11F  2  D0 0D                BNE     pchrot          ;send
00E121  2               tabspc:
00E121  2  A9 20                LDA     #' '            ;else get space
00E123  2  20 2E E1             JSR     pchrot          ;send
00E126  2  AD 9A E3             LDA     positn          ;get count
00E129  2  29 07                AND     #7              ;if not mod 8
00E12B  2  D0 F4                BNE     tabspc          ;loop
00E12D  2  60                   RTS                     ;else exit
00E12E  2               pchrot:
00E12E  2  48                   PHA                     ;save char
00E12F  2  20 9F E0             JSR     kbdsts          ;test input
00E132  2  68                   PLA                     ;restore
00E133  2  20 F0 E0             JSR     lstout          ;to printer if on
00E136  2               nolist:
00E136  2  48                   PHA                     ;save again
00E137  2  2C C1 E3             BIT     outflg          ;test flag
00E13A  2  30 03                BMI     *+5             ;done if set
00E13C  2  20 3D E4             JSR     sim+12          ;to console
00E13F  2  68                   PLA                     ;restore
00E140  2  EE 9A E3             INC     positn          ;bump col
00E143  2  C9 20                CMP     #' '            ;if space or more
00E145  2  B0 26                BCS     extchr          ;is ok
00E147  2  CD 69 E4             CMP     sysdef+2        ;also ok
00E14A  2  F0 21                BEQ     extchr          ;if forward
00E14C  2  CE 9A E3             DEC     positn          ;else drop back
00E14F  2  CD 67 E4             CMP     sysdef+0        ;see if bs
00E152  2  D0 06                BNE     tryotr          ;branch if not
00E154  2  CE 9A E3             DEC     positn          ;else drop again
00E157  2  30 0F                BMI     zrocol          ;zero if <0
00E159  2  60                   RTS                     ;else ok
00E15A  2               tryotr:
00E15A  2  C9 0D                CMP     #cr             ;if a cr
00E15C  2  F0 0A                BEQ     zrocol          ;clear col
00E15E  2  CD 6E E4             CMP     sysdef+7        ;if a formfeed
00E161  2  F0 05                BEQ     zrocol          ;also clear
00E163  2  CD 6F E4             CMP     sysdef+8        ;if not home
00E166  2  D0 05                BNE     extchr          ;then done
00E168  2               zrocol:
00E168  2  A9 00                LDA     #0              ;clear
00E16A  2  8D 9A E3             STA     positn          ;column
00E16D  2               extchr:
00E16D  2  60                   RTS                     ;and exit
00E16E  2               ;go to left and space past prompt
00E16E  2               ; input:frscol,positn
00E16E  2               ; returns:none
00E16E  2               ; alters:positn
00E16E  2               spcovr:
00E16E  2  A9 0D                LDA     #cr             ;get cr
00E170  2  20 2E E1             JSR     pchrot          ;send to all
00E173  2  A9 0A                LDA     #lf             ;send lf
00E175  2  20 F0 E0             JSR     lstout          ;only to printer
00E178  2               mreovr:
00E178  2  AD 97 E3             LDA     frscol          ;get first
00E17B  2  CD 9A E3             CMP     positn          ;see if there
00E17E  2  F0 ED                BEQ     extchr          ;done if is
00E180  2  AD 69 E4             LDA     sysdef+2        ;get forward
00E183  2  20 36 E1             JSR     nolist          ;send it
00E186  2  4C 78 E1             JMP     mreovr          ;and loop
00E189  2               ;buffered read
00E189  2               ; input:buffer@(addinp)
00E189  2               ; returns:none
00E189  2               ; alters:all,buffer@(addinp)
00E189  2               bufinp:
00E189  2  A9 00                LDA     #0              ;clear
00E18B  2  A0 01                LDY     #1              ;length
00E18D  2  91 02                STA     (addinp),y      ;position in buffer
00E18F  2  8C A1 E3             STY     bufpsn          ;set point to 1
00E192  2  AD 9A E3             LDA     positn          ;get current
00E195  2  8D 97 E3             STA     frscol          ;and save
00E198  2               nxtinp:
00E198  2  20 8F E0             JSR     getcon          ;get input
00E19B  2  AC A1 E3             LDY     bufpsn          ;get index
00E19E  2  C9 0D                CMP     #cr             ;if not a cr
00E1A0  2  D0 03                BNE     notcr           ;then jump
00E1A2  2  4C 68 E2             JMP     endlin          ;else done
00E1A5  2               notcr:
00E1A5  2  C9 08                CMP     #delete         ;if not delete
00E1A7  2  D0 5E                BNE     ntdelt          ;then jump
00E1A9  2  C0 01                CPY     #1              ;else if start
00E1AB  2  F0 EB                BEQ     nxtinp          ;then loop
00E1AD  2  B1 02                LDA     (addinp),y      ;get last
00E1AF  2  48                   PHA                     ;save char
00E1B0  2  A0 01                LDY     #1              ;point to count
00E1B2  2  38                   SEC                     ;set carry
00E1B3  2  B1 02                LDA     (addinp),y      ;get count
00E1B5  2  E9 01                SBC     #1              ;decrement
00E1B7  2  91 02                STA     (addinp),y      ;then save
00E1B9  2  68                   PLA                     ;restore char
00E1BA  2  CE A1 E3             DEC     bufpsn          ;backup pointer
00E1BD  2  C9 20                CMP     #' '            ;if space or more
00E1BF  2  B0 40                BCS     nrmbs           ;just backspace
00E1C1  2  C9 09                CMP     #ctli           ;see if tab
00E1C3  2  D0 30                BNE     ctlbs           ;if not is control
00E1C5  2  38                   SEC                     ;set flag
00E1C6  2  6E C1 E3             ROR     outflg
00E1C9  2  AD 9A E3             LDA     positn          ;get position and save
00E1CC  2  8D C2 E3             STA     lstcol
00E1CF  2  20 6E E1             JSR     spcovr          ;else go back
00E1D2  2  20 75 E2             JSR     rptlne          ;and retype
00E1D5  2  AD 9A E3             LDA     positn          ;get new last position
00E1D8  2  48                   PHA                     ;save on stack
00E1D9  2  38                   SEC                     ;subtract to get delta
00E1DA  2  AD C2 E3             LDA     lstcol
00E1DD  2  ED 9A E3             SBC     positn
00E1E0  2  8D C2 E3             STA     lstcol          ;and save
00E1E3  2  0E C1 E3             ASL     outflg          ;clear flag
00E1E6  2               bstab:
00E1E6  2  20 95 E2             JSR     dobs            ;do one
00E1E9  2  CE C2 E3             DEC     lstcol          ;drop count
00E1EC  2  D0 F8                BNE     bstab           ;loop if more
00E1EE  2  68                   PLA                     ;get position
00E1EF  2  8D 9A E3             STA     positn          ;and set
00E1F2  2  4C 98 E1             JMP     nxtinp          ;then loop
00E1F5  2               ctlbs:
00E1F5  2  AD 6A E4             LDA     sysdef+3        ;get normal
00E1F8  2  20 91 E2             JSR     chkbs           ;bs if printing
00E1FB  2  AD 6B E4             LDA     sysdef+4        ;same for invert
00E1FE  2  20 91 E2             JSR     chkbs           ;then delete char itself
00E201  2               nrmbs:
00E201  2  20 95 E2             JSR     dobs            ;do a backspace
00E204  2  4C 98 E1             JMP     nxtinp          ;and loop
00E207  2               ntdelt:
00E207  2  C9 10                CMP     #ctlp           ;if not ctl-p
00E209  2  D0 0B                BNE     ntctlp          ;then jump
00E20B  2  AD 99 E3             LDA     lstflg          ;else get printer flag
00E20E  2  49 FF                EOR     #$ff            ;complement
00E210  2  8D 99 E3             STA     lstflg          ;save
00E213  2  4C 98 E1             JMP     nxtinp          ;and loop
00E216  2               ntctlp:
00E216  2  C9 18                CMP     #ctlx           ;if not ctl-x
00E218  2  D0 0C                BNE     ntctlx          ;then jump
00E21A  2  20 6E E1             JSR     spcovr          ;restart
00E21D  2  AD 68 E4             LDA     sysdef+1        ;get clear to eol
00E220  2  20 36 E1             JSR     nolist          ;send it
00E223  2  4C 89 E1             JMP     bufinp          ;and start over
00E226  2               ntctlx:
00E226  2  C9 12                CMP     #ctlr           ;if not ctl-r
00E228  2  D0 09                BNE     ntctlr          ;then jump
00E22A  2  20 6E E1             JSR     spcovr          ;restart
00E22D  2  20 75 E2             JSR     rptlne          ;retype line
00E230  2  4C 98 E1             JMP     nxtinp          ;and start over
00E233  2               ntctlr:
00E233  2  C8                   INY                     ;next position
00E234  2  91 02                STA     (addinp),y      ;store char
00E236  2  48                   PHA                     ;and save
00E237  2  8C A1 E3             STY     bufpsn          ;index
00E23A  2  A0 01                LDY     #1              ;point to count
00E23C  2  98                   TYA                     ;set a to 1
00E23D  2  18                   CLC                     ;then
00E23E  2  71 02                ADC     (addinp),y      ;add count
00E240  2  91 02                STA     (addinp),y      ;and save
00E242  2  68                   PLA                     ;restore char
00E243  2               dontsv:
00E243  2  20 00 E1             JSR     output          ;send char
00E246  2  AC A1 E3             LDY     bufpsn          ;get index
00E249  2  B1 02                LDA     (addinp),y      ;get char
00E24B  2  C9 03                CMP     #ctlc           ;if not ctl-c
00E24D  2  D0 0B                BNE     ignrcc          ;ignore
00E24F  2  A0 01                LDY     #1              ;get count
00E251  2  B1 02                LDA     (addinp),y      ;from buffer
00E253  2  C9 01                CMP     #1              ;if not at start
00E255  2  D0 03                BNE     ignrcc          ;ignore
00E257  2  4C F3 D8             JMP     xwboot          ;else do warm boot
00E25A  2               ignrcc:
00E25A  2  A0 01                LDY     #1              ;get
00E25C  2  B1 02                LDA     (addinp),y      ;count
00E25E  2  88                   DEY                     ;point to max
00E25F  2  D1 02                CMP     (addinp),y      ;if length
00E261  2  B0 03                BCS     lineen          ;at max jump
00E263  2  4C 98 E1             JMP     nxtinp          ;else loop
00E266  2               lineen:
00E266  2  A9 0D                LDA     #cr             ;get a cr
00E268  2               endlin:
00E268  2  4C 2E E1             JMP     pchrot          ;and send
00E26B  2               ;cr and lf
00E26B  2               pcrlf:
00E26B  2  A9 0D                LDA     #cr             ;then a
00E26D  2  20 2E E1             JSR     pchrot          ;cr
00E270  2  A9 0A                LDA     #lf             ;and a
00E272  2  4C 2E E1             JMP     pchrot          ;lf
00E275  2               ;retype line
00E275  2               rptlne:
00E275  2  AD A1 E3             LDA     bufpsn          ;save point
00E278  2  8D C0 E3             STA     numcnt          ;as count
00E27B  2  A9 01                LDA     #1              ;start position
00E27D  2  48                   PHA                     ;save
00E27E  2               mrerpt:
00E27E  2  68                   PLA                     ;get position
00E27F  2  CE C0 E3             DEC     numcnt          ;count down
00E282  2  D0 01                BNE     *+3             ;continue if more
00E284  2  60                   RTS                     ;else done
00E285  2  A8                   TAY                     ;else make index
00E286  2  C8                   INY                     ;and bump
00E287  2  98                   TYA                     ;save
00E288  2  48                   PHA                     ;on stack
00E289  2  B1 02                LDA     (addinp),y      ;get char
00E28B  2  20 00 E1             JSR     output          ;send
00E28E  2  4C 7E E2             JMP     mrerpt          ;and loop
00E291  2               ;check for printing and backspace if needed
00E291  2               chkbs:
00E291  2  C9 20                CMP     #' '            ;compare to space
00E293  2  90 19                BCC     extdec          ;not printing so done
00E295  2               ;do a backspace
00E295  2               dobs:
00E295  2  AD 67 E4             LDA     sysdef+0        ;get backspace
00E298  2  48                   PHA                     ;save it
00E299  2  20 36 E1             JSR     nolist          ;send
00E29C  2  A9 20                LDA     #' '            ;get space
00E29E  2  20 36 E1             JSR     nolist          ;send
00E2A1  2  68                   PLA                     ;get backspace
00E2A2  2  4C 36 E1             JMP     nolist          ;send it
00E2A5  2               ;test for decimal digit
00E2A5  2               ;if decimal then c=0 else c=1
00E2A5  2               tstdec:
00E2A5  2  C9 30                CMP     #'0'            ;if under 0
00E2A7  2  90 04                BCC     notdec          ;then not decimal
00E2A9  2  C9 3A                CMP     #'9'+1          ;if 9 or under is ok
00E2AB  2  90 01                BCC     extdec
00E2AD  2               notdec:
00E2AD  2  38                   SEC                     ;else not a match
00E2AE  2               extdec:
00E2AE  2  60                   RTS
00E2AF  2               ;test for hexadecimal digit
00E2AF  2               ;if hex then c=0 else c=1
00E2AF  2               tsthex:
00E2AF  2  20 A5 E2             JSR     tstdec          ;first try decimal
00E2B2  2  90 FA                BCC     extdec          ;ok if dec
00E2B4  2  C9 41                CMP     #'A'            ;if under A
00E2B6  2  90 F5                BCC     notdec          ;then not hex
00E2B8  2  C9 47                CMP     #'F'+1          ;set c in F compare
00E2BA  2  60                   RTS
00E2BB  2               ;bump load address by 128 and return in ay
00E2BB  2               adjdb:
00E2BB  2  AD FA D7             LDA     dskbuf          ;get old
00E2BE  2  AC FB D7             LDY     dskbuf+1        ;address
00E2C1  2  18                   CLC                     ;and bump
00E2C2  2  69 80                ADC     #128            ;by 128
00E2C4  2  8D FA D7             STA     dskbuf          ;save low
00E2C7  2  90 04                BCC     *+6             ;then bump
00E2C9  2  C8                   INY                     ;and save
00E2CA  2  8C FB D7             STY     dskbuf+1        ;high as needed
00E2CD  2  60                   RTS
00E2CE  2               ;move record from disk buffer to default buffer
00E2CE  2               mv128:
00E2CE  2  AD FA D7             LDA     dskbuf          ;get address
00E2D1  2  AC FB D7             LDY     dskbuf+1
00E2D4  2  8D DD E2             STA     mvfrom+1        ;and set pointer
00E2D7  2  8C DE E2             STY     mvfrom+2
00E2DA  2  A2 00                LDX     #0              ;clear index
00E2DC  2               mvfrom:
00E2DC  2  BD FF FF             LDA     $ffff,x         ;get byte
00E2DF  2  9D 28 01             STA     dflbuf,x        ;move it
00E2E2  2  E8                   INX
00E2E3  2  10 F7                BPL     mvfrom          ;loop until done
00E2E5  2  60                   RTS
00E2E6  2               
00E2E6  2               ;relocatable vectors
00E2E6  2  4C                   .BYTE   $4c
00E2E7  2               extevc:
00E2E7  2  52 D8                .WORD   extexq-1
00E2E9  2  4C                   .BYTE   $4c
00E2EA  2               sltmvc:
00E2EA  2  46 E3                .WORD   sltmsg
00E2EC  2  4C                   .BYTE   $4c
00E2ED  2               empdvc:
00E2ED  2  57 E3                .WORD   empty
00E2EF  2  4C                   .BYTE   $4c
00E2F0  2               rommvc:
00E2F0  2  FC E2                .WORD   romsg
00E2F2  2  4C                   .BYTE   $4c
00E2F3  2               bdsmvc:
00E2F3  2  03 E3                .WORD   bdsmsg
00E2F5  2  4C                   .BYTE   $4c
00E2F6  2               pemmvc:
00E2F6  2  36 E3                .WORD   pemmsg
00E2F8  2  4C                   .BYTE   $4c
00E2F9  2               dcbevc:
00E2F9  2  D0 E3                .WORD   dcb
00E2FB  2               ;relocation stopper
00E2FB  2  FF                   .BYTE   $ff
00E2FC  2               ;messages
00E2FC  2               romsg:
00E2FC  2  20 2D 20 52          .BYTE   " - R/O$"
00E300  2  2F 4F 24     
00E303  2               bdsmsg:
00E303  2  20 2D 20 42          .BYTE   " - BAD SECTOR"
00E307  2  41 44 20 53  
00E30B  2  45 43 54 4F  
00E310  2  0D 0A 3C 52          .BYTE   cr,lf,"<RET> TO IGNORE -- <OTHER> "
00E314  2  45 54 3E 20  
00E318  2  54 4F 20 49  
00E32D  2  54 4F 20 41          .BYTE   "TO ABORT$"
00E331  2  42 4F 52 54  
00E335  2  24           
00E336  2               pemmsg:
00E336  2  0D 0A 50 45          .BYTE   cr,lf,"PEM ERROR ON $"
00E33A  2  4D 20 45 52  
00E33E  2  52 4F 52 20  
00E346  2               sltmsg:
00E346  2  20 2D 20 49          .BYTE   " - INVALID DRIVE$"
00E34A  2  4E 56 41 4C  
00E34E  2  49 44 20 44  
00E357  2               
00E357  2               ;dummy fcb
00E357  2               empty:
00E357  2  E5                   .BYTE   $e5
00E358  2               ;zero page switch enable table
00E358  2               swctbl:
00E358  2  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0
00E35C  2  00 00 00 00  
00E360  2  00 00 01 00          .BYTE   0,0,1,0,0,1,1,1
00E364  2  00 01 01 01  
00E368  2  01 01 01 01          .BYTE   1,1,1,1,1,1,1,1
00E36C  2  01 01 01 01  
00E370  2  00 00 01 00          .BYTE   0,0,1,0,0,0,0,0
00E374  2  00 00 00 00  
00E378  2  00 00 00 00          .BYTE   0,0,0,0
00E37C  2               ;bit mask table
00E37C  2               bitmsk:
00E37C  2  80 40 20 10          .BYTE   128,64,32,16,8,4,2,1
00E380  2  08 04 02 01  
00E384  2               ;bit map table
00E384  2               bitmap:
00E384  2  01 02 04 08          .BYTE   1,2,4,8,16,32,64,128
00E388  2  10 20 40 80  
00E38C  2               ;extent mask table (also uses 3 bytes in sabtbl
00E38C  2               exmtbl:
00E38C  2  00 01 03             .BYTE   0,1,3
00E38F  2               ;sab table
00E38F  2               sabtbl:
00E38F  2  07 0F 1F 3F          .BYTE   7,15,31,63,127
00E393  2  7F           
00E394  2               ;variable storage
00E394  2               skpdir:
00E394  2  00                   .BYTE   0               ;positive if no change
00E395  2               fcbind:
00E395  2  00                   .BYTE   0               ;index to block number
00E396  2               savext:
00E396  2  00                   .BYTE   0               ;save extent
00E397  2               frscol:
00E397  2  00                   .BYTE   0               ;first col
00E398  2               pndkey:
00E398  2  00                   .BYTE   0               ;pending input
00E399  2               lstflg:
00E399  2  00                   .BYTE   0               ;printer flag
00E39A  2               positn:
00E39A  2  00                   .BYTE   0               ;print position
00E39B  2               swcflg:
00E39B  2  00                   .BYTE   0               ;zero page switch flag
00E39C  2               bytinp:
00E39C  2  00 00                .WORD   0               ;input value
00E39E  2               cmdinp:
00E39E  2  00                   .BYTE   0               ;input command
00E39F  2               addout:
00E39F  2  00 00                .WORD   0               ;output address
00E3A1  2               bytout          = addout        ;output value
00E3A1  2               bufpsn:
00E3A1  2  00                   .BYTE   0               ;input buffer position
00E3A2  2               exrwfl:
00E3A2  2  00                   .BYTE   0               ;extend flag
00E3A3  2               tmpdrv:
00E3A3  2  00                   .BYTE   0               ;temporary drive number
00E3A4  2               ;align xqtvec on word boundary
00E3A4  2  xx                   .ALIGN  2
00E3A5  2               xqtvec:
00E3A5  2  00 00                .WORD   0               ;command vector
00E3A7  2               countr:
00E3A7  2  00 00                .WORD   0               ;record counter
00E3A9  2  00                   .BYTE   0               ;overflow
00E3AA  2               lkdown:
00E3AA  2  00 00                .WORD   0               ;down pnt. for block search
00E3AC  2               lookup:
00E3AC  2  00 00                .WORD   0               ;up pnt. for block search
00E3AE  2               olddrv:
00E3AE  2  00                   .BYTE   0               ;old drive number
00E3AF  2               curdrv:
00E3AF  2  00                   .BYTE   0               ;current drive
00E3B0  2               lginvc:
00E3B0  2  00                   .BYTE   0               ;log in status
00E3B1  2               ronlst:
00E3B1  2  00                   .BYTE   0               ;read write status
00E3B2  2               dirnum:
00E3B2  2  00 00                .WORD   0               ;directory number
00E3B4  2               subrec:
00E3B4  2  00                   .BYTE   0               ;directory offset
00E3B5  2               recnum:
00E3B5  2  00 00                .WORD   0               ;record number
00E3B7  2               blknum          = recnum        ;block number
00E3B7  2  00                   .BYTE   0               ;overflow
00E3B8  2               chrcnt:
00E3B8  2  00                   .BYTE   0               ;character count
00E3B9  2               cmppnt:
00E3B9  2  00                   .BYTE   0               ;comparison pointer
00E3BA  2               nxtrec:
00E3BA  2  00                   .BYTE   0               ;next record
00E3BB  2               numrec:
00E3BB  2  00                   .BYTE   0               ;number records
00E3BC  2               dirrec:
00E3BC  2  00 00                .WORD   0               ;directory record
00E3BE  2               dirmod:
00E3BE  2  00                   .BYTE   0               ;directory mod 4
00E3BF  2               index:
00E3BF  2  00                   .BYTE   0               ;buffer index
00E3C0  2               numcnt:
00E3C0  2  00                   .BYTE   0               ;counter
00E3C1  2               outflg:
00E3C1  2  00                   .BYTE   0               ;output enable flag
00E3C2  2               lstcol:
00E3C2  2  00                   .BYTE   0               ;last column
00E3C3  2               mpdrsy:
00E3C3  2  00                   .BYTE   0               ;save for y in mapdir
00E3C4  2               mpdrtm:
00E3C4  2  00                   .BYTE   0               ;temp in mapdir
00E3C5  2               blmode:
00E3C5  2  00                   .BYTE   0               ;<128 if byte else word
00E3C6  2               maxdrc:
00E3C6  2  00 00                .WORD   0               ;max directory record
00E3C8  2               sab:
00E3C8  2  00                   .BYTE   0               ;mask for block
00E3C9  2               sxb:
00E3C9  2  00                   .BYTE   0               ;shift for block
00E3CA  2               rtclk:
00E3CA  2  00 00 00             .BYTE   0,0,0           ;real time clock
00E3CD  2               gpcnt:
00E3CD  2  00 00                .WORD   0               ;gp counter
00E3CF  2               trkctr:
00E3CF  2  00                   .BYTE   0               ;track counter
00E3D0  2               ;following region is used to capture dcb
00E3D0  2               dcb:
00E3D0  2               maxblk:
00E3D0  2  00 00                .WORD   0               ;maximum block number
00E3D2  2               sectrk:
00E3D2  2  00 00                .WORD   0               ;sectors per track
00E3D4  2               nsystr:
00E3D4  2  00 00                .WORD   0               ;number system tracks
00E3D6  2               blkscd:
00E3D6  2  00                   .BYTE   0               ;block size code
00E3D7  2               maxdir:
00E3D7  2  00 00                .WORD   0               ;maximum directory number
00E3D9  2               alcmap:
00E3D9  2  00 00                .WORD   0               ;address of allocation map
00E3DB  2               chkflg:
00E3DB  2  00                   .BYTE   0               ;check flag
00E3DC  2               chkmap:
00E3DC  2  00 00                .WORD   0               ;address of checksum map
00E3DE  2               pemwrtype:
00E3DE  2  00                   .BYTE   0               ;write type 0=norm,1=dir,2=unalloc
00E3DF  2               exm:
00E3DF  2  00                   .BYTE   0               ;extent mask
00E3E0  2               cexm1f:
00E3E0  2  00                   .BYTE   0               ;exm complemented and 1f
00E3E1  2               ;zero page save block
00E3E1  2               varblk:
00E3E1  2               lowin:
00E3E1  2  xx xx xx xx          .RES    numvar
00E3E5  2  xx xx xx xx  
00E3E9  2  xx xx xx xx  
00E431  2               
00E431  1                       .INCLUDE "../dos65_os/simrbc.asm"
00E431  2               ;--------------------------------
00E431  2               ;dos/65 system interface module (sim)
00E431  2               ;--------------------------------
00E431  2               
00E431  2               
00E431  2               ;dos/65 system interface module (sim)
00E431  2               ;version 3.00
00E431  2               ;this version is designed to work with the 6x0x
00E431  2               
00E431  2               ;fixed parameters
00E431  2               simstart:
00E431  2               
00E431  2               ;main program
00E431  2               ;jump vector used by pem
00E431  2               sim:
00E431  2  4C 83 E5             JMP     boot            ;from cold start
00E434  2               wboote:
00E434  2  4C 39 E6             JMP     wboot           ;from warm boot
00E437  2  4C 1D E7             JMP     consts          ;check for input
00E43A  2  4C 24 E7             JMP     conrde          ;get input
00E43D  2  4C 2B E7             JMP     conwrt          ;send to terminal
00E440  2  4C 34 E7             JMP     prnwrt          ;printer output
00E443  2  4C 35 E7             JMP     punwrt          ;punch output
00E446  2  4C 36 E7             JMP     rdrinp          ;reader input
00E449  2  4C 66 E6             JMP     home            ;home drive
00E44C  2  4C 49 E6             JMP     seldsk          ;select disk
00E44F  2  4C 6A E6             JMP     seltrk          ;set track
00E452  2  4C 6F E6             JMP     selsec          ;set sector
00E455  2  4C 18 E7             JMP     setdma          ;set buffer address
00E458  2  4C 74 E6             JMP     read            ;read sector
00E45B  2  4C B8 E6             JMP     write           ;write sector
00E45E  2  A9 01                LDA     #1              ;printer always ready
00E460  2  60                   RTS
00E461  2  4C 37 E7             JMP     rdtime          ;clock entry
00E464  2  4C 3A E7             JMP     xlate           ;translate
00E467  2               
00E467  2               ;console definition block
00E467  2               sysdef:
00E467  2  08                   .BYTE   8               ;backspace
00E468  2  01                   .BYTE   1               ;clear to end of line
00E469  2  0C                   .BYTE   $c              ;forward space
00E46A  2  00                   .BYTE   0               ;normal video
00E46B  2  5E                   .BYTE   '^'             ;invert video
00E46C  2  18                   .BYTE   24              ;lines per screen
00E46D  2  50                   .BYTE   80              ;char per line
00E46E  2  0C                   .BYTE   $c              ;formfeed
00E46F  2  1E                   .BYTE   $1e             ;home
00E470  2  02                   .BYTE   2               ;clear to end of screen
00E471  2               
00E471  2               ;opening id message
00E471  2               opnmsg:
00E471  2  0D 0A                .BYTE   cr, lf
00E473  2               
00E473  2  64 38 38 38          .BYTE   "d8888b.  .d88b.  .d8888.    dD     ooooo", cr, lf
00E477  2  38 62 2E 20  
00E47B  2  20 2E 64 38  
00E49D  2  38 38 20 20          .BYTE   "88  `8D .8P  Y8. 88'  YP   d8'    8P~~~~", cr, lf
00E4A1  2  60 38 44 20  
00E4A5  2  2E 38 50 20  
00E4C7  2  38 38 20 20          .BYTE   "88   88 88    88 `8bo.    d8'    dP", cr, lf
00E4CB  2  20 38 38 20  
00E4CF  2  38 38 20 20  
00E4EC  2  38 38 20 20          .BYTE   "88   88 88    88   `Y8b. d8888b. V8888b.", cr, lf,0
00E4F0  2  20 38 38 20  
00E4F4  2  38 38 20 20  
00E517  2               opnmsg1:
00E517  2  38 38 20 20          .BYTE   "88  .8D `8b  d8' db   8D 88' `8D     `8D ", cr, lf
00E51B  2  2E 38 44 20  
00E51F  2  60 38 62 20  
00E542  2  59 38 38 38          .BYTE   "Y8888D'  `Y88P'  `8888Y' `8888P  88oobY'", cr, lf
00E546  2  38 44 27 20  
00E54A  2  20 60 59 38  
00E56C  2  44 4F 53 2F          .BYTE   "DOS/65 V3.00", cr, lf, 0
00E570  2  36 35 20 56  
00E574  2  33 2E 30 30  
00E57B  2               
00E57B  2               DSKYMSG:
00E57B  2  54 6E 5C 5E          .BYTE   $54, $6E, $5C, $5E, $6E, $54, $79, $40
00E57F  2  6E 54 79 40  
00E583  2               
00E583  2               ;cold entry from loader
00E583  2               boot:
00E583  2                       .IFDEF  DUODYNE
00E583  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00E584  2  18                   CLC                     ;
00E585  2  FB                   XCE                     ; SET NATIVE MODE
00E586  2  C2 30                ACCUMULATORINDEX16
00E588  2  A9 FF 5F             LDA     #STACK          ; get the stack address
00E58B  2  1B                   TCS                     ; and set the stack to it
00E58C  2  E2 30                ACCUMULATORINDEX8
00E58E  2                       .ELSE
00E58E  2                       SEI
00E58E  2                       LDX     #$ff            ;set stack
00E58E  2                       TXS                     ;pointer
00E58E  2                       CLD                     ;set binary mode
00E58E  2                       .ENDIF
00E58E  2               
00E58E  2  A9 71                LDA     #<opnmsg        ;point to message
00E590  2  A0 E4                LDY     #>opnmsg
00E592  2  20 3B E7             JSR     outmsg          ;send it
00E595  2  A9 17                LDA     #<opnmsg1       ;point to message
00E597  2  A0 E5                LDY     #>opnmsg1
00E599  2  20 3B E7             JSR     outmsg          ;send it
00E59C  2               ;set up jumps into dos/65 in page one
00E59C  2               
00E59C  2               ; setup diskconfig table
00E59C  2  A2 00                LDX     #0
00E59E  2               :
00E59E  2  BD 36 E8             LDA     dftdskcfg, x
00E5A1  2  9D 17 06             STA     dskcfg, x
00E5A4  2  E8                   INX
00E5A5  2  E0 10                CPX     #$10
00E5A7  2  D0 F5                BNE     :-
00E5A9  2               
00E5A9  2  A9 28                LDA     #40             ; DSKY INITIALIZE
00E5AB  2  85 32                STA     farfunct
00E5AD  2  20 00 F2             JSR     DO_FARCALL
00E5B0  2               
00E5B0  2  A9 34                LDA     #52             ; RTC_RESET
00E5B2  2  85 32                STA     farfunct
00E5B4  2  20 00 F2             JSR     DO_FARCALL
00E5B7  2               
00E5B7  2  A9 3C                LDA     #60             ; IDE INITIALIZE
00E5B9  2  85 32                STA     farfunct
00E5BB  2  20 00 F2             JSR     DO_FARCALL
00E5BE  2               
00E5BE  2  A9 3F                LDA     #63             ; SD INITIALIZE
00E5C0  2  85 32                STA     farfunct
00E5C2  2  20 00 F2             JSR     DO_FARCALL
00E5C5  2               
00E5C5  2  A9 42                LDA     #66             ; FLOPPY INITIALIZE
00E5C7  2  85 32                STA     farfunct
00E5C9  2  20 00 F2             JSR     DO_FARCALL
00E5CC  2               
00E5CC  2  A9 4B                LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
00E5CE  2  85 30                STA     cmdlnp
00E5D0  2  A9 D7                LDA     #>cnstxt
00E5D2  2  85 31                STA     cmdlnp + 1
00E5D4  2               
00E5D4  2  A9 17                LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00E5D6  2  85 2E                STA     dskcfpc
00E5D8  2  A9 06                LDA     #>dskcfg
00E5DA  2  85 2F                STA     dskcfpc + 1
00E5DC  2               
00E5DC  2  A9 C6                LDA     #<dcba          ; STORE POINTER TO DCB TABLES FOR APPS
00E5DE  2  85 2C                STA     dcbpc
00E5E0  2  A9 E7                LDA     #>dcba
00E5E2  2  85 2D                STA     dcbpc + 1
00E5E4  2               
00E5E4  2               
00E5E4  2               setup:
00E5E4  2  A2 00                LDX     #0              ;clear index
00E5E6  2               ;
00E5E6  2  A9 4B                LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
00E5E8  2  85 30                STA     cmdlnp
00E5EA  2  A9 D7                LDA     #>cnstxt
00E5EC  2  85 31                STA     cmdlnp + 1
00E5EE  2               
00E5EE  2  A9 17                LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00E5F0  2  85 2E                STA     dskcfpc
00E5F2  2  A9 06                LDA     #>dskcfg
00E5F4  2  85 2F                STA     dskcfpc + 1
00E5F6  2               
00E5F6  2  A9 C6                LDA     #<dcba          ; STORE POINTER TO DCB TABLES FOR APPS
00E5F8  2  85 2C                STA     dcbpc
00E5FA  2  A9 E7                LDA     #>dcba
00E5FC  2  85 2D                STA     dcbpc + 1
00E5FE  2               ;
00E5FE  2               ;first clear key dba variables
00E5FE  2               ;        STX     hstact          ;host buffer inactive
00E5FE  2               ;        STX     unacnt          ;clear unalloc count
00E5FE  2               setupl:
00E5FE  2  BD 33 E6             LDA     inttbl,x        ;get byte
00E601  2  9D 00 01             STA     $100,x          ;insert at start
00E604  2  E8                   INX
00E605  2  E0 06                CPX     #6
00E607  2  D0 F5                BNE     setupl          ;loop until done
00E609  2  A9 28                LDA     #<dflbuf        ;get low buffer
00E60B  2  A0 01                LDY     #>dflbuf        ;and high
00E60D  2  20 18 E7             JSR     setdma          ;and set
00E610  2  A5 48                LDA     sekdsk          ;get disk
00E612  2               
00E612  2  A2 00                LDX     #$00            ; SHOW A STARTUP MESSAGE ON DSKY
00E614  2               :
00E614  2  BD 7B E5             LDA     DSKYMSG,x
00E617  2  9D 00 06             STA     DSKY_BUF,x
00E61A  2  E8                   INX
00E61B  2  E0 08                CPX     #8
00E61D  2  D0 F5                BNE     :-
00E61F  2  A9 29                LDA     #41             ; DSKY_SHOW
00E621  2  85 32                STA     farfunct
00E623  2  20 00 F2             JSR     DO_FARCALL
00E626  2               
00E626  2  A9 00                LDA     #DEFDRV         ;set zero
00E628  2  20 49 E6             JSR     seldsk          ;and select drive zero
00E62B  2  20 66 E6             JSR     home            ;home that drive
00E62E  2  A9 00                LDA     #DEFDRV         ;set zero
00E630  2  4C 05 D0             JMP     ccm             ;and go to ccm
00E633  2               ;initialization table
00E633  2               inttbl:
00E633  2  4C 34 E4 4C          .BYTE   $4c,<wboote,>wboote,$4c,<pem,>pem
00E637  2  05 D8        
00E639  2               ;warm boot-read dos/65 back except sim and then
00E639  2               ; jump to ccm.
00E639  2               
00E639  2               
00E639  2               wboot:
00E639  2                       .IFDEF  DUODYNE
00E639  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00E63A  2  18                   CLC                     ;
00E63B  2  FB                   XCE                     ; SET NATIVE MODE
00E63C  2  C2 30                ACCUMULATORINDEX16
00E63E  2  A9 FF 5F             LDA     #STACK          ; get the stack address
00E641  2  1B                   TCS                     ; and set the stack to it
00E642  2  E2 30                ACCUMULATORINDEX8
00E644  2  4B                   PHK
00E645  2  AB                   PLB
00E646  2                       .ELSE
00E646  2                       SEI
00E646  2                       LDX     #$ff            ;set stack
00E646  2                       TXS                     ;pointer
00E646  2                       CLD                     ;set binary mode
00E646  2                       .ENDIF
00E646  2               
00E646  2  4C E4 E5             JMP     setup           ;go setup
00E649  2               
00E649  2               
00E649  2               
00E649  2               ;__SELDSK_________________________________________________________________________________________________
00E649  2               ;
00E649  2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
00E649  2               ;________________________________________________________________________________________________________
00E649  2               ;select disk
00E649  2               seldsk:
00E649  2  29 07                AND     #7              ;eight drives only
00E64B  2  85 48                STA     sekdsk          ;save for later
00E64D  2  0A                   ASL     a               ;multiply by two
00E64E  2  AA                   TAX                     ;make an Index
00E64F  2  BD 56 E6             LDA     dcbtbl,x        ;get address
00E652  2  BC 57 E6             LDY     dcbtbl+1,x
00E655  2  60                   RTS
00E656  2               
00E656  2               ;table of dcb addresses
00E656  2               dcbtbl:
00E656  2  C6 E7                .WORD   dcba
00E658  2  D4 E7                .WORD   dcbb
00E65A  2  E2 E7                .WORD   dcbc
00E65C  2  F0 E7                .WORD   dcbd
00E65E  2  FE E7                .WORD   dcbe
00E660  2  0C E8                .WORD   dcbf
00E662  2  1A E8                .WORD   dcbg
00E664  2  28 E8                .WORD   dcbh
00E666  2               
00E666  2               
00E666  2               
00E666  2               ;__HOME__________________________________________________________________________________________________
00E666  2               ;
00E666  2               ; 	PERFORM DOS/65 HEAD HOME
00E666  2               ;________________________________________________________________________________________________________
00E666  2               home:
00E666  2  A9 00                LDA     #$00
00E668  2  A0 00                LDY     #$00
00E66A  2               
00E66A  2               ;__SELTRK________________________________________________________________________________________________
00E66A  2               ;
00E66A  2               ; 	PERFORM DOS/65 SELECT TRACK
00E66A  2               ;
00E66A  2               ;	A=TRACK LOW BYTE
00E66A  2               ;	Y=TRACK HIGH BYTE
00E66A  2               ;________________________________________________________________________________________________________
00E66A  2               seltrk:
00E66A  2  85 44                STA     sektrk          ;save number
00E66C  2  84 45                STY     sektrk+1
00E66E  2  60                   RTS
00E66F  2               
00E66F  2               ;__SELSEC________________________________________________________________________________________________
00E66F  2               ;
00E66F  2               ; 	PERFORM DOS/65 SECTOR SELECT
00E66F  2               ;
00E66F  2               ;	A=SECTOR LOW BYTE
00E66F  2               ;	Y=SECTOR HIGH BYTE
00E66F  2               ;________________________________________________________________________________________________________
00E66F  2               selsec:
00E66F  2  85 46                STA     seksec          ;save low and high
00E671  2  84 47                STY     seksec+1
00E673  2  60                   RTS
00E674  2               
00E674  2               ;__READ__________________________________________________________________________________________________
00E674  2               ;
00E674  2               ; PERFORM DOS / 65 SECTOR READ
00E674  2               ;________________________________________________________________________________________________________
00E674  2               read:
00E674  2  20 A6 E7             JSR     GET_DRIVE_DEVICE;
00E677  2  29 F0                AND     #$F0            ; only want first nybble
00E679  2  C9 00                CMP     #$00
00E67B  2  D0 0B                BNE     :+              ; not MD drive
00E67D  2               ;MD
00E67D  2  A9 40                LDA     #64             ; md read sector
00E67F  2  85 32                STA     farfunct
00E681  2  20 00 F2             JSR     DO_FARCALL
00E684  2  20 4F E7             JSR     DEBSECR
00E687  2  60                   RTS
00E688  2               :
00E688  2  C9 10                CMP     #$10
00E68A  2  D0 0B                BNE     :+              ; not SD drive
00E68C  2               ;SD
00E68C  2                       .IFDEF DUODYNE
00E68C  2                       .ELSE
00E68C  2                       JSR     CONVERT_SECTOR_LBA
00E68C  2                       .ENDIF
00E68C  2  A9 40                LDA     #64             ; sd read sector
00E68E  2  85 32                STA     farfunct
00E690  2  20 00 F2             JSR     DO_FARCALL
00E693  2  20 4F E7             JSR     DEBSECR
00E696  2  60                   RTS
00E697  2               :
00E697  2  C9 20                CMP     #$20
00E699  2  D0 0B                BNE     :+              ; not floppy drive
00E69B  2               ;FD
00E69B  2                       .IFDEF DUODYNE
00E69B  2                       .ELSE
00E69B  2                       JSR     SETUP_FD_CHS
00E69B  2                       .ENDIF
00E69B  2  A9 43                LDA     #67             ; floppy read sector
00E69D  2  85 32                STA     farfunct
00E69F  2  20 00 F2             JSR     DO_FARCALL
00E6A2  2  20 4F E7             JSR     DEBSECR
00E6A5  2  60                   RTS
00E6A6  2               :
00E6A6  2  C9 30                CMP     #$30
00E6A8  2  D0 0B                BNE     :+              ; invalid drive
00E6AA  2               ;PPIDE
00E6AA  2                       .IFDEF DUODYNE
00E6AA  2                       .ELSE
00E6AA  2                       JSR     CONVERT_SECTOR_LBA
00E6AA  2                       .ENDIF
00E6AA  2  A9 3D                LDA     #61             ; IDE_READ_SECTOR
00E6AC  2  85 32                STA     farfunct
00E6AE  2  20 00 F2             JSR     DO_FARCALL
00E6B1  2  20 4F E7             JSR     DEBSECR
00E6B4  2  60                   RTS
00E6B5  2               :
00E6B5  2  A9 FF                LDA     #$FF            ; signal error
00E6B7  2  60                   RTS                     ;
00E6B8  2               
00E6B8  2               
00E6B8  2               ;__WRITE_________________________________________________________________________________________________
00E6B8  2               ;
00E6B8  2               ; PERFORM DOS / 65 SECTOR WRITE
00E6B8  2               ;________________________________________________________________________________________________________
00E6B8  2               write:
00E6B8  2  20 A6 E7             JSR     GET_DRIVE_DEVICE;
00E6BB  2  29 F0                AND     #$F0            ; only want first nybble
00E6BD  2               
00E6BD  2  C9 00                CMP     #$00
00E6BF  2  D0 12                BNE     :+              ; not MD drive
00E6C1  2               ;MD
00E6C1  2  A9 40                LDA     #64             ;PPP_READ_SECTOR
00E6C3  2  85 32                STA     farfunct
00E6C5  2  20 00 F2             JSR     DO_FARCALL
00E6C8  2  20 79 E7             JSR     BLKSECR
00E6CB  2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
00E6CD  2  85 32                STA     farfunct
00E6CF  2  20 00 F2             JSR     DO_FARCALL
00E6D2  2  60                   RTS
00E6D3  2               :
00E6D3  2  C9 10                CMP     #$10
00E6D5  2  D0 12                BNE     :+              ; not SD drive
00E6D7  2               ;SD
00E6D7  2                       .IFDEF DUODYNE
00E6D7  2                       .ELSE
00E6D7  2                       JSR     CONVERT_SECTOR_LBA
00E6D7  2                       .ENDIF
00E6D7  2               
00E6D7  2  A9 40                LDA     #64             ;PPP_READ_SECTOR
00E6D9  2  85 32                STA     farfunct
00E6DB  2  20 00 F2             JSR     DO_FARCALL
00E6DE  2  20 79 E7             JSR     BLKSECR
00E6E1  2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
00E6E3  2  85 32                STA     farfunct
00E6E5  2  20 00 F2             JSR     DO_FARCALL
00E6E8  2  60                   RTS
00E6E9  2               :
00E6E9  2               
00E6E9  2  C9 20                CMP     #$20
00E6EB  2  D0 12                BNE     :+              ; not floppy drive
00E6ED  2               ;FD
00E6ED  2                       .IFDEF DUODYNE
00E6ED  2                       .ELSE
00E6ED  2                       JSR     SETUP_FD_CHS
00E6ED  2                       .ENDIF
00E6ED  2  A9 43                LDA     #67             ; floppy read sector
00E6EF  2  85 32                STA     farfunct
00E6F1  2  20 00 F2             JSR     DO_FARCALL
00E6F4  2  20 79 E7             JSR     BLKSECR
00E6F7  2  A9 44                LDA     #68             ; floppy write sector
00E6F9  2  85 32                STA     farfunct
00E6FB  2  20 00 F2             JSR     DO_FARCALL
00E6FE  2  60                   RTS
00E6FF  2               :
00E6FF  2  C9 30                CMP     #$30
00E701  2  D0 12                BNE     :+              ; invalid drive
00E703  2               ;PPIDE
00E703  2                       .IFDEF DUODYNE
00E703  2                       .ELSE
00E703  2                       JSR     CONVERT_SECTOR_LBA
00E703  2                       .ENDIF
00E703  2               
00E703  2  A9 3D                LDA     #61             ; IDE read sector
00E705  2  85 32                STA     farfunct
00E707  2  20 00 F2             JSR     DO_FARCALL
00E70A  2  20 79 E7             JSR     BLKSECR
00E70D  2  A9 3E                LDA     #62             ; IDE_WRITE_SECTOR
00E70F  2  85 32                STA     farfunct
00E711  2  20 00 F2             JSR     DO_FARCALL
00E714  2  60                   RTS
00E715  2               :
00E715  2  A9 FF                LDA     #$FF            ; signal error
00E717  2  60                   RTS                     ;
00E718  2               
00E718  2               
00E718  2               ;__SETDMA________________________________________________________________________________________________
00E718  2               ;
00E718  2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
00E718  2               ;
00E718  2               ;	A=BUFFER LOW BYTE
00E718  2               ;	Y=BUFFER HIGH BYTE
00E718  2               ;________________________________________________________________________________________________________
00E718  2               setdma:
00E718  2  85 F4                STA     dmaadr          ;store low
00E71A  2  84 F5                STY     dmaadr+1        ;and high
00E71C  2  60                   RTS
00E71D  2               
00E71D  2               
00E71D  2               ;__CONSTS________________________________________________________________________________________________
00E71D  2               ;
00E71D  2               ; 	GET DOS/65 CONSOLE STATUS
00E71D  2               ;________________________________________________________________________________________________________
00E71D  2               consts:
00E71D  2  A9 03                LDA     #03
00E71F  2  85 32                STA     farfunct
00E721  2  4C 00 F2             JMP     DO_FARCALL
00E724  2               
00E724  2               ;__CONRDE________________________________________________________________________________________________
00E724  2               ;
00E724  2               ; 	PERFORM DOS/65 CONSOLE READ
00E724  2               ;________________________________________________________________________________________________________
00E724  2               conrde:
00E724  2  A9 02                LDA     #02
00E726  2  85 32                STA     farfunct
00E728  2  4C 00 F2             JMP     DO_FARCALL      ;console read
00E72B  2               
00E72B  2               ;__CONWRT________________________________________________________________________________________________
00E72B  2               ;
00E72B  2               ; 	PERFORM DOS/65 CONSOLE WRITE
00E72B  2               ;________________________________________________________________________________________________________
00E72B  2               conwrt:
00E72B  2  48                   PHA
00E72C  2  A9 00                LDA     #00
00E72E  2  85 32                STA     farfunct
00E730  2  68                   PLA
00E731  2  4C 00 F2             JMP     DO_FARCALL
00E734  2               
00E734  2               prnwrt:
00E734  2  60                   RTS                     ;printer
00E735  2               punwrt:
00E735  2  60                   RTS                     ;punch output
00E736  2               rdrinp:
00E736  2  60                   RTS                     ;reader input
00E737  2               rdtime:
00E737  2  A2 80                LDX     #128
00E739  2  60                   RTS                     ;read clock
00E73A  2               xlate:
00E73A  2  60                   RTS                     ;sector translate
00E73B  2               
00E73B  2               
00E73B  2               ;__OUTMSG________________________________________________________________________________________________
00E73B  2               ;
00E73B  2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
00E73B  2               ;
00E73B  2               ;	A=POINTER LOW BYTE
00E73B  2               ;	Y=POINTER HIGH BYTE
00E73B  2               ;________________________________________________________________________________________________________
00E73B  2               outmsg: ;output message
00E73B  2  85 F0                STA     OUTMSG_W
00E73D  2  84 F1                STY     OUTMSG_W+1
00E73F  2  A0 00                LDY     #$00
00E741  2               OUTSTRLP:
00E741  2  B1 F0                LDA     (OUTMSG_W),Y    ; LOAD NEXT CHAR FROM STRING INTO ACC
00E743  2  C9 00                CMP     #$00            ; IS NULL?
00E745  2  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00E747  2  20 2B E7             JSR     conwrt          ; PRINT CHAR IN ACC
00E74A  2  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
00E74B  2  4C 41 E7             JMP     OUTSTRLP        ; DO NEXT CHAR
00E74E  2               ENDOUTSTR:
00E74E  2  60                   RTS                     ; RETURN
00E74F  2               
00E74F  2                       .IFDEF DUODYNE
00E74F  2                       .ELSE
00E74F  2               
00E74F  2               ;___CONVERT_SECTOR_LBA___________________________________________________________________________________
00E74F  2               ;
00E74F  2               ; 	TRANSLATE LBA SECTORS
00E74F  2               ;________________________________________________________________________________________________________
00E74F  2               CONVERT_SECTOR_LBA:
00E74F  2                       LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
00E74F  2                       AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
00E74F  2                       ASL     a               ; MOVE TO HIGH BYTE
00E74F  2                       ASL     a
00E74F  2                       ASL     a
00E74F  2                       ASL     a
00E74F  2                       TAX                     ; PARK IN X
00E74F  2                       LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
00E74F  2                       LSR     A               ;
00E74F  2                       LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
00E74F  2                       AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
00E74F  2                       STA     debsehd         ; STORE IN SECTOR/HEAD
00E74F  2                       TXA                     ; GET HEAD BACK
00E74F  2                       ORA     debsehd
00E74F  2                       STA     debsehd         ; STORE IN SECTOR/HEAD
00E74F  2               
00E74F  2                       LDA     sektrk
00E74F  2                       STA     debcyll         ; STORE IN TRACK (lsb)
00E74F  2                       LDA     sektrk+1
00E74F  2                       STA     debcylm         ; STORE IN TRACK (msb)
00E74F  2               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
00E74F  2                       LDA     debcylm
00E74F  2                       LSR     A
00E74F  2                       STA     debcylm
00E74F  2                       LDA     debcyll
00E74F  2                       ROR     A
00E74F  2                       STA     debcyll
00E74F  2               
00E74F  2                       LDA     debcylm
00E74F  2                       LSR     A
00E74F  2                       STA     debcylm
00E74F  2                       LDA     debcyll
00E74F  2                       ROR     A
00E74F  2                       STA     debcyll
00E74F  2               
00E74F  2                       LDA     debcylm
00E74F  2                       LSR     A
00E74F  2                       STA     debcylm
00E74F  2                       LDA     debcyll
00E74F  2                       ROR     A
00E74F  2                       STA     debcyll
00E74F  2               
00E74F  2                       LDA     debcylm
00E74F  2                       LSR     A
00E74F  2                       STA     debcylm
00E74F  2                       LDA     debcyll
00E74F  2                       ROR     A
00E74F  2                       STA     debcyll
00E74F  2               ;	ADD SLICE OFFSET
00E74F  2                       LDA     sekdsk          ; GET DRIVE#
00E74F  2                       AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00E74F  2                       ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00E74F  2                       TAX                     ; MOVE TO X REGISTER
00E74F  2                       INX                     ; WANT SECOND BYTE OF ENTRY
00E74F  2                       LDA     dskcfg,X        ; GET SLICE#
00E74F  2                       STA     slicetmp+1      ; SLICE OFFSET MSB
00E74F  2                       LDA     #0              ; GET SLICE#
00E74F  2                       STA     slicetmp        ; SLICE OFFSET LSB
00E74F  2                       CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
00E74F  2                       ROR     slicetmp+1
00E74F  2                       ROR     slicetmp
00E74F  2                       ROR     slicetmp+1
00E74F  2                       ROR     slicetmp
00E74F  2               
00E74F  2                       LDA     dskcfg,X        ; GET SLICE#
00E74F  2                       CLC
00E74F  2                       ADC     slicetmp
00E74F  2                       STA     slicetmp
00E74F  2                       LDA     #$00            ; LOGIC ERROR FOR SLICES THAT CARRY?
00E74F  2                       ADC     slicetmp+1      ;
00E74F  2                       STA     slicetmp+1      ;
00E74F  2               
00E74F  2               ; ADD SLICE OFFSET TO TRACK #
00E74F  2                       CLC                     ; clear carry
00E74F  2                       LDA     slicetmp
00E74F  2                       ADC     debcyll
00E74F  2                       STA     debcyll         ; store sum of LSBs
00E74F  2                       LDA     slicetmp+1
00E74F  2                       ADC     debcylm         ; add the MSBs using carry from
00E74F  2                       STA     debcylm         ; the previous calculation
00E74F  2               
00E74F  2               
00E74F  2               ; DISPLAY ON DSKY IF PRESENT
00E74F  2                       LDA     sekdsk
00E74F  2                       STA     DSKY_HEXBUF
00E74F  2                       LDA     debcylm
00E74F  2                       STA     DSKY_HEXBUF+1
00E74F  2                       LDA     debcyll
00E74F  2                       STA     DSKY_HEXBUF+2
00E74F  2                       LDA     debsehd
00E74F  2                       STA     DSKY_HEXBUF+3
00E74F  2                       LDA     #42             ; DSKY_BIN2SEG
00E74F  2                       STA     farfunct
00E74F  2                       JSR     DO_FARCALL
00E74F  2                       LDA     #41             ; DSKY_SHOW
00E74F  2                       STA     farfunct
00E74F  2                       JSR     DO_FARCALL
00E74F  2                       RTS
00E74F  2               
00E74F  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
00E74F  2               ;
00E74F  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
00E74F  2               ;________________________________________________________________________________________________________________________________
00E74F  2               ;
00E74F  2               SETUP_FD_CHS:
00E74F  2                       LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
00E74F  2                       AND     #$01            ; FILTER OUT HEAD
00E74F  2                       STA     debcylm         ; STORE HEAD
00E74F  2                       LDA     sektrk          ; SAVE TRACK IN A
00E74F  2                       LSR     A               ; REMOVE HEAD BIT
00E74F  2                       STA     debcyll         ; STORE IN TRACK
00E74F  2                       LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
00E74F  2                       LSR     A               ;
00E74F  2                       LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
00E74F  2                       STA     debsehd         ; STORE IN SECTOR
00E74F  2               
00E74F  2                       LDA     sekdsk
00E74F  2                       STA     DSKY_HEXBUF
00E74F  2                       LDA     debcylm
00E74F  2                       STA     DSKY_HEXBUF+1
00E74F  2                       LDA     debcyll
00E74F  2                       STA     DSKY_HEXBUF+2
00E74F  2                       LDA     debsehd
00E74F  2                       STA     DSKY_HEXBUF+3
00E74F  2                       LDA     #42             ; DSKY_BIN2SEG
00E74F  2                       STA     farfunct
00E74F  2                       JSR     DO_FARCALL
00E74F  2                       LDA     #41             ; DSKY_SHOW
00E74F  2                       STA     farfunct
00E74F  2                       JSR     DO_FARCALL
00E74F  2                       RTS
00E74F  2               
00E74F  2                       .ENDIF
00E74F  2               
00E74F  2               
00E74F  2               ;___DEBSECR______________________________________________________________________________________________
00E74F  2               ;
00E74F  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
00E74F  2               ;
00E74F  2               ;________________________________________________________________________________________________________
00E74F  2               DEBSECR:
00E74F  2  08                   PHP
00E750  2  48                   PHA
00E751  2  A5 46                LDA     seksec          ;
00E753  2  29 03                AND     #$03            ; GET SECTOR INDEX
00E755  2  18                   CLC                     ;
00E756  2  2A                   ROL     A               ;
00E757  2  AA                   TAX                     ;
00E758  2  BD 71 E7             LDA     DEBTAB,X        ;
00E75B  2  85 EE                STA     SRC
00E75D  2  E8                   INX
00E75E  2  BD 71 E7             LDA     DEBTAB,X        ;
00E761  2  85 EF                STA     SRC+1           ;
00E763  2  A5 F4                LDA     dmaadr          ;
00E765  2  85 EC                STA     DEST            ;
00E767  2  A5 F5                LDA     dmaadr+1        ;
00E769  2  85 ED                STA     DEST+1          ;
00E76B  2  20 99 E7             JSR     COPY_DOS_SECTOR ;
00E76E  2  68                   PLA
00E76F  2  28                   PLP
00E770  2  60                   RTS
00E771  2               
00E771  2               DEBTAB:
00E771  2  00 04                .WORD   hstbuf          ;
00E773  2  80 04                .WORD   hstbuf+128      ;
00E775  2  00 05                .WORD   hstbuf+256      ;
00E777  2  80 05                .WORD   hstbuf+384      ;
00E779  2               
00E779  2               
00E779  2               ;___BLKSECR______________________________________________________________________________________________
00E779  2               ;
00E779  2               ;	BLOCK 512 BYTE SECTOR FOR DOS/65
00E779  2               ;
00E779  2               ;________________________________________________________________________________________________________
00E779  2               BLKSECR:
00E779  2  08                   PHP
00E77A  2  A5 46                LDA     seksec          ;
00E77C  2  29 03                AND     #$03            ; GET SECTOR INDEX
00E77E  2  18                   CLC                     ;
00E77F  2  2A                   ROL     A               ;
00E780  2  AA                   TAX                     ;
00E781  2  BD 71 E7             LDA     DEBTAB,X        ;
00E784  2  85 EC                STA     DEST
00E786  2  E8                   INX
00E787  2  BD 71 E7             LDA     DEBTAB,X        ;
00E78A  2  85 ED                STA     DEST+1          ;
00E78C  2  A5 F4                LDA     dmaadr          ;
00E78E  2  85 EE                STA     SRC             ;
00E790  2  A5 F5                LDA     dmaadr+1        ;
00E792  2  85 EF                STA     SRC+1           ;
00E794  2  20 99 E7             JSR     COPY_DOS_SECTOR ;
00E797  2  28                   PLP
00E798  2  60                   RTS
00E799  2               
00E799  2               
00E799  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00E799  2               ;
00E799  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
00E799  2               ;
00E799  2               ;________________________________________________________________________________________________________
00E799  2               COPY_DOS_SECTOR:
00E799  2  A0 00                LDY     #$00            ;
00E79B  2               COPY_DOS_SECTOR1:
00E79B  2  B1 EE                LDA     (SRC),Y         ;
00E79D  2  91 EC                STA     (DEST),Y        ;
00E79F  2  C8                   INY                     ;
00E7A0  2  98                   TYA                     ;
00E7A1  2  C9 80                CMP     #$80            ;
00E7A3  2  D0 F6                BNE     COPY_DOS_SECTOR1;
00E7A5  2  60                   RTS
00E7A6  2               
00E7A6  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00E7A6  2               ;
00E7A6  2               ; GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00E7A6  2               ;
00E7A6  2               ;________________________________________________________________________________________________________
00E7A6  2               GET_DRIVE_DEVICE:
00E7A6  2  8E C5 E7             STX     GET_DRIVE_DEVICE_TMP
00E7A9  2  A5 48                LDA     sekdsk          ; GET DRIVE
00E7AB  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00E7AD  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00E7AE  2  AA                   TAX                     ; MOVE TO X REGISTER
00E7AF  2  BD 17 06             LDA     dskcfg, X       ; GET device
00E7B2  2  29 0F                AND     #$0F
00E7B4  2  85 49                STA     currentDrive
00E7B6  2  BD 17 06             LDA     dskcfg, X       ; GET device
00E7B9  2               ; SETUP FLOPPY CONTROL WHILE WE ARE HERE
00E7B9  2  29 01                AND     #$01
00E7BB  2  8D 28 06             STA     DSKUNIT
00E7BE  2  BD 17 06             LDA     dskcfg, X       ; GET device
00E7C1  2  AE C5 E7             LDX     GET_DRIVE_DEVICE_TMP
00E7C4  2  60                   RTS
00E7C5  2               
00E7C5  2               GET_DRIVE_DEVICE_TMP:
00E7C5  2  00                   .BYTE   00
00E7C6  2               ;------------------------------------------------------------------------------------
00E7C6  2               
00E7C6  2                       .IFDEF  RBC6X0X
00E7C6  2               ;disk control blocks
00E7C6  2               dcba:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpa           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbb:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpb           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbc:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpc           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbd:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpd           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbe:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpe           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbf:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpf           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbg:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpg           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbh:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almph           ;address of map for a
00E7C6  2                       .BYTE   128             ;no checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               
00E7C6  2               ; See Platform Documentation for Drive Types.
00E7C6  2               dftdskcfg:
00E7C6  2                       .BYTE   $10, $00        ; disk A: unit, slice (invalid for floppy disks) SD
00E7C6  2                       .BYTE   $30, $00        ; disk B: unit, slice (invalid for floppy disks) PPIDE
00E7C6  2                       .BYTE   $90, $00        ; disk C: unit, slice (invalid for floppy disks)
00E7C6  2                       .BYTE   $90, $00        ; disk D: unit, slice (invalid for floppy disks)
00E7C6  2                       .BYTE   $90, $00        ; disk E: unit, slice (invalid for floppy disks)
00E7C6  2                       .BYTE   $90, $00        ; disk F: unit, slice (invalid for floppy disks)
00E7C6  2                       .BYTE   $90, $00        ; disk G: unit, slice (invalid for floppy disks)
00E7C6  2                       .BYTE   $90, $00        ; disk H: unit, slice (invalid for floppy disks)
00E7C6  2               
00E7C6  2               
00E7C6  2               
00E7C6  2                       .ENDIF
00E7C6  2               
00E7C6  2               ;__________________________________________________________________________________________________________________________________
00E7C6  2                       .IFDEF  NHYODYNE
00E7C6  2               dcba:
00E7C6  2                       .WORD   127             ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   0               ;number system tracks
00E7C6  2                       .BYTE   1               ;block size = 2048
00E7C6  2                       .WORD   255             ;max directory number
00E7C6  2                       .WORD   almpa           ;address of map for a
00E7C6  2                       .BYTE   00              ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbb:
00E7C6  2                       .WORD   191             ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   0               ;number system tracks
00E7C6  2                       .BYTE   1               ;block size = 2048
00E7C6  2                       .WORD   155             ;max directory number
00E7C6  2                       .WORD   almpb           ;address of map for b
00E7C6  2                       .BYTE   00              ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbc:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpc           ;address of map for C
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbd:
00E7C6  2                       .WORD   350             ;max block number
00E7C6  2                       .WORD   36              ;sectors per track
00E7C6  2                       .WORD   4               ;number system tracks
00E7C6  2                       .BYTE   1               ;block size = 2048
00E7C6  2                       .WORD   127             ;max directory number
00E7C6  2                       .WORD   almpd           ;address of map for d
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbe:
00E7C6  2                       .WORD   350             ;max block number
00E7C6  2                       .WORD   36              ;sectors per track
00E7C6  2                       .WORD   4               ;number system tracks
00E7C6  2                       .BYTE   1               ;block size = 2048
00E7C6  2                       .WORD   127             ;max directory number
00E7C6  2                       .WORD   almpe           ;address of map for e
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbf:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpf           ;address of map for f
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbg:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almpg           ;address of map for g
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               dcbh:
00E7C6  2                       .WORD   2047            ;max block number
00E7C6  2                       .WORD   64              ;sectors per track
00E7C6  2                       .WORD   16              ;number system tracks
00E7C6  2                       .BYTE   2               ;block size = 4096
00E7C6  2                       .WORD   511             ;max directory number
00E7C6  2                       .WORD   almph           ;address of map for h
00E7C6  2                       .BYTE   0               ;do checksums
00E7C6  2                       .WORD   ckmp            ;checksum map
00E7C6  2               
00E7C6  2               dftdskcfg:
00E7C6  2                       .BYTE   $00, $00        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00E7C6  2                       .BYTE   $01, $00        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00E7C6  2                       .BYTE   $30, $06        ; disk C: unit, slice IDE
00E7C6  2                       .BYTE   $20, $00        ; disk D: unit, slice FLOPPY A
00E7C6  2                       .BYTE   $21, $00        ; disk E: unit, slice FLOPPY B
00E7C6  2                       .BYTE   $30, $03        ; disk F: unit, slice IDE
00E7C6  2                       .BYTE   $30, $04        ; disk G: unit, slice IDE
00E7C6  2                       .BYTE   $30, $00        ; disk H: unit, slice IDE
00E7C6  2               
00E7C6  2                       .ENDIF
00E7C6  2               
00E7C6  2               ;__________________________________________________________________________________________________________________________________
00E7C6  2                       .IFDEF  DUODYNE
00E7C6  2               dcba:
00E7C6  2  FF 07                .WORD   2047            ;max block number
00E7C8  2  40 00                .WORD   64              ;sectors per track
00E7CA  2  10 00                .WORD   16              ;number system tracks
00E7CC  2  02                   .BYTE   2               ;block size = 4096
00E7CD  2  FF 01                .WORD   511             ;max directory number
00E7CF  2  46 EA                .WORD   almpc           ;address of map for C
00E7D1  2  00                   .BYTE   0               ;do checksums
00E7D2  2  46 F0                .WORD   ckmp            ;checksum map
00E7D4  2               dcbb:
00E7D4  2  FF 07                .WORD   2047            ;max block number
00E7D6  2  40 00                .WORD   64              ;sectors per track
00E7D8  2  10 00                .WORD   16              ;number system tracks
00E7DA  2  02                   .BYTE   2               ;block size = 4096
00E7DB  2  FF 01                .WORD   511             ;max directory number
00E7DD  2  46 EA                .WORD   almpc           ;address of map for C
00E7DF  2  00                   .BYTE   0               ;do checksums
00E7E0  2  46 F0                .WORD   ckmp            ;checksum map
00E7E2  2               dcbc:
00E7E2  2  FF 07                .WORD   2047            ;max block number
00E7E4  2  40 00                .WORD   64              ;sectors per track
00E7E6  2  10 00                .WORD   16              ;number system tracks
00E7E8  2  02                   .BYTE   2               ;block size = 4096
00E7E9  2  FF 01                .WORD   511             ;max directory number
00E7EB  2  46 EA                .WORD   almpc           ;address of map for C
00E7ED  2  00                   .BYTE   0               ;do checksums
00E7EE  2  46 F0                .WORD   ckmp            ;checksum map
00E7F0  2               dcbd:
00E7F0  2  FF 07                .WORD   2047            ;max block number
00E7F2  2  40 00                .WORD   64              ;sectors per track
00E7F4  2  10 00                .WORD   16              ;number system tracks
00E7F6  2  02                   .BYTE   2               ;block size = 4096
00E7F7  2  FF 01                .WORD   511             ;max directory number
00E7F9  2  46 EB                .WORD   almpd           ;address of map for C
00E7FB  2  00                   .BYTE   0               ;do checksums
00E7FC  2  46 F0                .WORD   ckmp            ;checksum map
00E7FE  2               dcbe:
00E7FE  2  FF 07                .WORD   2047            ;max block number
00E800  2  40 00                .WORD   64              ;sectors per track
00E802  2  10 00                .WORD   16              ;number system tracks
00E804  2  02                   .BYTE   2               ;block size = 4096
00E805  2  FF 01                .WORD   511             ;max directory number
00E807  2  46 EC                .WORD   almpe           ;address of map for C
00E809  2  00                   .BYTE   0               ;do checksums
00E80A  2  46 F0                .WORD   ckmp            ;checksum map
00E80C  2               dcbf:
00E80C  2  FF 07                .WORD   2047            ;max block number
00E80E  2  40 00                .WORD   64              ;sectors per track
00E810  2  10 00                .WORD   16              ;number system tracks
00E812  2  02                   .BYTE   2               ;block size = 4096
00E813  2  FF 01                .WORD   511             ;max directory number
00E815  2  46 ED                .WORD   almpf           ;address of map for f
00E817  2  00                   .BYTE   0               ;do checksums
00E818  2  46 F0                .WORD   ckmp            ;checksum map
00E81A  2               dcbg:
00E81A  2  FF 07                .WORD   2047            ;max block number
00E81C  2  40 00                .WORD   64              ;sectors per track
00E81E  2  10 00                .WORD   16              ;number system tracks
00E820  2  02                   .BYTE   2               ;block size = 4096
00E821  2  FF 01                .WORD   511             ;max directory number
00E823  2  46 EE                .WORD   almpg           ;address of map for g
00E825  2  00                   .BYTE   0               ;do checksums
00E826  2  46 F0                .WORD   ckmp            ;checksum map
00E828  2               dcbh:
00E828  2  FF 07                .WORD   2047            ;max block number
00E82A  2  40 00                .WORD   64              ;sectors per track
00E82C  2  10 00                .WORD   16              ;number system tracks
00E82E  2  02                   .BYTE   2               ;block size = 4096
00E82F  2  FF 01                .WORD   511             ;max directory number
00E831  2  46 EF                .WORD   almph           ;address of map for h
00E833  2  00                   .BYTE   0               ;do checksums
00E834  2  46 F0                .WORD   ckmp            ;checksum map
00E836  2               
00E836  2               dftdskcfg:
00E836  2  30 06                .BYTE   $30, $06        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00E838  2  30 01                .BYTE   $30, $01        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00E83A  2  30 06                .BYTE   $30, $06        ; disk C: unit, slice
00E83C  2  30 00                .BYTE   $30, $00        ; disk D: unit, slice
00E83E  2  30 01                .BYTE   $30, $01        ; disk E: unit, slice
00E840  2  30 02                .BYTE   $30, $02        ; disk F: unit, slice
00E842  2  30 03                .BYTE   $30, $03        ; disk G: unit, slice
00E844  2  30 04                .BYTE   $30, $04        ; disk H: unit, slice
00E846  2                       .ENDIF
00E846  2               
00E846  2               
00E846  2               ;allocation maps
00E846  2               almpa:
00E846  2  xx xx xx xx          .RES    256
00E84A  2  xx xx xx xx  
00E84E  2  xx xx xx xx  
00E946  2               almpb:
00E946  2  xx xx xx xx          .RES    256
00E94A  2  xx xx xx xx  
00E94E  2  xx xx xx xx  
00EA46  2               almpc:
00EA46  2  xx xx xx xx          .RES    256
00EA4A  2  xx xx xx xx  
00EA4E  2  xx xx xx xx  
00EB46  2               almpd:
00EB46  2  xx xx xx xx          .RES    256
00EB4A  2  xx xx xx xx  
00EB4E  2  xx xx xx xx  
00EC46  2               almpe:
00EC46  2  xx xx xx xx          .RES    256
00EC4A  2  xx xx xx xx  
00EC4E  2  xx xx xx xx  
00ED46  2               almpf:
00ED46  2  xx xx xx xx          .RES    256
00ED4A  2  xx xx xx xx  
00ED4E  2  xx xx xx xx  
00EE46  2               almpg:
00EE46  2  xx xx xx xx          .RES    256
00EE4A  2  xx xx xx xx  
00EE4E  2  xx xx xx xx  
00EF46  2               almph:
00EF46  2  xx xx xx xx          .RES    256
00EF4A  2  xx xx xx xx  
00EF4E  2  xx xx xx xx  
00F046  2               
00F046  2               ;checksum maps
00F046  2               ;drive a
00F046  2               ckmp:
00F046  2  xx xx xx xx          .RES    128
00F04A  2  xx xx xx xx  
00F04E  2  xx xx xx xx  
00F0C6  2               
00F0C6  1               
00F0C6  1               OSVECTAG:
00F0C6  1  xx xx xx xx          .RES    $F200-OSVECTAG
00F0CA  1  xx xx xx xx  
00F0CE  1  xx xx xx xx  
00F200  1  5C 00 80 1E          JML     $1E8000
00F204  1  60                   RTS
00F205  1               OSEND:
00F205  1               
00F205  1                       .ORG    $8000
008000  1               DRIVERBEGIN:
008000  1                       .INCLUDE "dos65drv.asm"
008000  2               ;________________________________________________________________________________________________________________________________
008000  2               ;
008000  2               ;	Nhyodyne dos/65 banked driver code
008000  2               ;       Intended for 65816
008000  2               ;
008000  2               ;  DWERNER 12/22/2023 	Initial
008000  2               ;________________________________________________________________________________________________________________________________
008000  2               
008000  2               DSKYOSC         = 1000000       ; Set DSKY NG Osc frequency
008000  2               
008000  2                       .ORG    $8000
008000  2               
008000  2               ; for Duodyne 65816:
008000  2               ;________________________________________________________________________________________________________________________________
008000  2               ;       It is assumed that Bank 0 is not usable due to IO and ROM starting at DF00-FFFF
008000  2               ;       OS will run in Bank 1
008000  2               ;       Drivers will run in Bank 2
008000  2               ;________________________________________________________________________________________________________________________________
008000  2               
008000  2               ;__DISPATCHER________________________________________________________________________________________
008000  2               ;
008000  2               ;  Function dispatcher
008000  2               ;  function to call is located in "farfunct"
008000  2               ;____________________________________________________________________________________________________
008000  2               ;
008000  2               FUNCTION_DISPATCHER:
008000  2  08                   PHP
008001  2               FUNCTION_DISPATCHER1:
008001  2  E2 30                ACCUMULATORINDEX8
008003  2  48                   PHA
008004  2  8A                   TXA
008005  2  48                   PHA
008006  2  A9 1E                LDA     #DOS65DRIVERSBNK
008008  2  48                   PHA
008009  2  AB                   PLB
00800A  2  A5 32                LDA     farfunct
00800C  2  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
00800D  2  AA                   TAX
00800E  2  BD 2C 80             LDA     DISPATCHTABLE,X
008011  2  85 33                STA     farpointer
008013  2  BD 2D 80             LDA     DISPATCHTABLE+1,X
008016  2  85 34                STA     farpointer+1
008018  2  68                   PLA
008019  2  AA                   TAX
00801A  2  68                   PLA
00801B  2  20 29 80             JSR     jsrindirect
00801E  2  48                   PHA
00801F  2  A9 1D                LDA     #DOS65BANK
008021  2  48                   PHA
008022  2  AB                   PLB
008023  2  68                   PLA
008024  2  28                   PLP
008025  2  5C 04 F2 1D          JML     $1DF204
008029  2               
008029  2               jsrindirect:
008029  2  6C 33 00             JMP     (farpointer)
00802C  2               
00802C  2               DISPATCHTABLE:
00802C  2  07 88                .WORD   DFT_CONSOLE     ; FUNCTION 00 - WRITE CONSOLE
00802E  2  07 88                .WORD   DFT_CONSOLE     ; FUNCTION 01 - READ CONSOLE
008030  2  07 88                .WORD   DFT_CONSOLE     ; FUNCTION 02 - READ CONSOLE (BLOCKING)
008032  2  07 88                .WORD   DFT_CONSOLE     ; FUNCTION 03 - GET CONSOLE STATUS
008034  2               
008034  2  50 81                .WORD   WRSER1          ; FUNCTION 04 - WRITE SERIAL PORT
008036  2  61 81                .WORD   RDSER1          ; FUNCTION 05 - READ SERIAL PORT
008038  2  73 81                .WORD   RDSER1W         ; FUNCTION 06 - READ SERIAL PORT (BLOCKING)
00803A  2  84 81                .WORD   SERIALSTATUS    ; FUNCTION 07 - GET SERIAL STATUS
00803C  2  4F 81                .WORD   SERIALINIT      ; FUNCTION 08 - SERIAL PORT INIT
00803E  2               
00803E  2  50 81                .WORD   WRSER1          ; FUNCTION 09 - WRITE VIDEO
008040  2  61 81                .WORD   RDSER1          ; FUNCTION 10 - READ KEYBOARD
008042  2  73 81                .WORD   RDSER1W         ; FUNCTION 11 - READ KEYBOARD (BLOCKING)
008044  2  84 81                .WORD   SERIALSTATUS    ; FUNCTION 12 - GET KEYBOARD STATUS
008046  2  4F 81                .WORD   SERIALINIT      ; FUNCTION 13 - INIT INTERFACE
008048  2               
008048  2  1B 88                .WORD   drv_noop        ; FUNCTION 14
00804A  2  1B 88                .WORD   drv_noop        ; FUNCTION 15
00804C  2  1B 88                .WORD   drv_noop        ; FUNCTION 16
00804E  2  1B 88                .WORD   drv_noop        ; FUNCTION 17
008050  2  1B 88                .WORD   drv_noop        ; FUNCTION 18
008052  2  1B 88                .WORD   drv_noop        ; FUNCTION 19
008054  2  1B 88                .WORD   drv_noop        ; FUNCTION 20
008056  2  1B 88                .WORD   drv_noop        ; FUNCTION 21
008058  2  1B 88                .WORD   drv_noop        ; FUNCTION 22
00805A  2  1B 88                .WORD   drv_noop        ; FUNCTION 23
00805C  2  1B 88                .WORD   drv_noop        ; FUNCTION 24
00805E  2  1B 88                .WORD   drv_noop        ; FUNCTION 25
008060  2  1B 88                .WORD   drv_noop        ; FUNCTION 26
008062  2  1B 88                .WORD   drv_noop        ; FUNCTION 27
008064  2  1B 88                .WORD   drv_noop        ; FUNCTION 28
008066  2  1B 88                .WORD   drv_noop        ; FUNCTION 29
008068  2  1B 88                .WORD   drv_noop        ; FUNCTION 30
00806A  2  1B 88                .WORD   drv_noop        ; FUNCTION 31
00806C  2  1B 88                .WORD   drv_noop        ; FUNCTION 32
00806E  2  1B 88                .WORD   drv_noop        ; FUNCTION 33
008070  2  1B 88                .WORD   drv_noop        ; FUNCTION 34
008072  2  1B 88                .WORD   drv_noop        ; FUNCTION 35
008074  2  1B 88                .WORD   drv_noop        ; FUNCTION 36
008076  2  1B 88                .WORD   drv_noop        ; FUNCTION 37
008078  2  1B 88                .WORD   drv_noop        ; FUNCTION 38
00807A  2  1B 88                .WORD   drv_noop        ; FUNCTION 39
00807C  2               
00807C  2  1B 88                .WORD   drv_noop        ; DSKY_INIT       ; FUNCTION 40 -
00807E  2  1B 88                .WORD   drv_noop        ; DSKY_SHOW       ; FUNCTION 41 -
008080  2  1B 88                .WORD   drv_noop        ; DSKY_BIN2SEG    ; FUNCTION 42 -
008082  2  1B 88                .WORD   drv_noop        ; DSKY_RESET      ; FUNCTION 43 -
008084  2  1B 88                .WORD   drv_noop        ; DSKY_STAT       ; FUNCTION 44 -
008086  2  1B 88                .WORD   drv_noop        ; DSKY_GETKEY     ; FUNCTION 45 -
008088  2  1B 88                .WORD   drv_noop        ; DSKY_BEEP       ; FUNCTION 46 -
00808A  2  1B 88                .WORD   drv_noop        ; DSKY_DSPL       ; FUNCTION 47 -
00808C  2  1B 88                .WORD   drv_noop        ; DSKY_PUTLED     ; FUNCTION 48 -
00808E  2  1B 88                .WORD   drv_noop        ; DSKY_BLANK      ; FUNCTION 49 -
008090  2               ;
008090  2  CD 86                .WORD   RTC_WRITE       ; FUNCTION 50 - WRITE RTC REGISTER
008092  2  E4 86                .WORD   RTC_READ        ; FUNCTION 51 - READ RTC REGISTER
008094  2  6E 86                .WORD   RTC_INIT        ; FUNCTION 52 - INIT RTC
008096  2  FB 86                .WORD   RTC_LED         ; FUNCTION 53 - CONTROL LEDS
008098  2  20 87                .WORD   RTC_BUTTON      ; FUNCTION 54 - READ BUTTON
00809A  2  27 87                .WORD   RTC_BEEP        ; FUNCTION 55 - MAKE SOME NOISE
00809C  2               ;
00809C  2  1B 88                .WORD   drv_noop        ; FUNCTION 56
00809E  2  1B 88                .WORD   drv_noop        ; FUNCTION 57
0080A0  2  1B 88                .WORD   drv_noop        ; FUNCTION 58
0080A2  2  1B 88                .WORD   drv_noop        ; FUNCTION 59
0080A4  2               
0080A4  2  94 81                .WORD   PPIDE_INIT      ; FUNCTION 60 - called during OS init
0080A6  2  8D 83                .WORD   IDE_READ_SECTOR ; FUNCTION 61 - read a sector from drive
0080A8  2  E4 83                .WORD   IDE_WRITE_SECTOR; FUNCTION 62 - write a sector to drive
0080AA  2               ;
0080AA  2  1B 88                .WORD   drv_noop        ; FUNCTION 63 - init the mem device
0080AC  2  1B 88                .WORD   drv_noop        ; FUNCTION 64 - read a sector from the memory device
0080AE  2  1B 88                .WORD   drv_noop        ; FUNCTION 65 - write a sector to the memory device
0080B0  2               ;
0080B0  2  1B 88                .WORD   drv_noop        ; FL_SETUP        ; FUNCTION 66 - init floppy device
0080B2  2  1B 88                .WORD   drv_noop        ; FL_READ_SECTOR  ; FUNCTION 67 - read a sector from floppy device
0080B4  2  1B 88                .WORD   drv_noop        ; FL_WRITE_SECTOR ; FUNCTION 68 - write a sector to floppy device
0080B6  2               
0080B6  2               ;______________________________________________________________________________
0080B6  2               
0080B6  2               
0080B6  2               
0080B6  2               ;__DRIVERS___________________________________________________________________________________________
0080B6  2               ;
0080B6  2                       .INCLUDE "drvmacros.asm"
0080B6  3               ;___________________________________________________________________________________________________
0080B6  3               ;
0080B6  3               ;	USEFUL 65186 MACROS
0080B6  3               ;__________________________________________________________________________________________________
0080B6  3               .macro          PRTDBG      message
0080B6  3               .LOCAL p1
0080B6  3               .LOCAL p2
0080B6  3               .LOCAL p3
0080B6  3               .LOCAL p4
0080B6  3               .LOCAL p5
0080B6  3                 .if     .paramcount <> 1
0080B6  3                       .error  "Too few parameters for macro PRTDBG"
0080B6  3                       .endif
0080B6  3                       .if DEBUG=1
0080B6  3                       PHA
0080B6  3                       txa
0080B6  3                       PHA
0080B6  3                       tya
0080B6  3                       PHA
0080B6  3                       LDX #$00
0080B6  3               p1:
0080B6  3                       LDA p4,x
0080B6  3                       INX
0080B6  3                       CMP #'$'
0080B6  3                       BEQ p2
0080B6  3                       JSR MACRO_OUTCH
0080B6  3                       JMP p1
0080B6  3               p2:
0080B6  3                       LDA #13
0080B6  3                       jsr MACRO_OUTCH
0080B6  3                       LDA #10
0080B6  3                       jsr MACRO_OUTCH
0080B6  3                       PLA
0080B6  3                       tay
0080B6  3                       PLA
0080B6  3                       tax
0080B6  3                       pla
0080B6  3                       JMP p5
0080B6  3               p4:
0080B6  3                       .BYTE message
0080B6  3               p5:
0080B6  3                       .endif
0080B6  3               .endmacro
0080B6  3               
0080B6  3               .macro          PRTS      message
0080B6  3               .LOCAL p1
0080B6  3               .LOCAL p2
0080B6  3               .LOCAL p3
0080B6  3               .LOCAL p4
0080B6  3               .LOCAL p5
0080B6  3                 .if     .paramcount <> 1
0080B6  3                       .error  "Too few parameters for macro PRTS"
0080B6  3                       .endif
0080B6  3                       PHA
0080B6  3                       PHX
0080B6  3                       PHY
0080B6  3                       LDX #$00
0080B6  3               p1:
0080B6  3                       LDA p4,x
0080B6  3                       INX
0080B6  3                       CMP #'$'
0080B6  3                       BEQ p2
0080B6  3                       JSR MACRO_OUTCH
0080B6  3                       JMP p1
0080B6  3               p2:
0080B6  3                       PLY
0080B6  3                       PLX
0080B6  3                       PLA
0080B6  3                       JMP p5
0080B6  3               p4:
0080B6  3                       .BYTE message
0080B6  3               p5:
0080B6  3               .endmacro
0080B6  3               
0080B6  3               .macro          DBGFLAG      character
0080B6  3                 .if     .paramcount <> 1
0080B6  3                       .error  "Too few parameters for macro DBGFLAG"
0080B6  3                       .endif
0080B6  3                       .if DEBUG=1
0080B6  3                       PHA
0080B6  3                       LDA #character
0080B6  3                       JSR MACRO_OUTCH
0080B6  3                       pla
0080B6  3                       .endif
0080B6  3               .endmacro
0080B6  3               
0080B6  3               
0080B6  3               ;__PRTHEXBYTE__________________________________________________
0080B6  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0080B6  3               ;______________________________________________________________
0080B6  3               PRTHEXBYTE:
0080B6  3  48                   PHA
0080B7  3  8D 35 06             sta     STACKA
0080BA  3  8A                   txa
0080BB  3  48                   PHa
0080BC  3  98                   tya
0080BD  3  48                   PHA
0080BE  3  AD 35 06             lda     STACKA
0080C1  3  AA                   TAX				; SAVE A REGISTER
0080C2  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
0080C3  3  4A                   LSR 				;
0080C4  3  4A                   LSR 				;
0080C5  3  4A                   LSR 				;
0080C6  3  18                   CLC               		; CLEAR CARRY
0080C7  3  20 D4 80             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0080CA  3  8A                   TXA				; RESTORE ACCUMULATOR
0080CB  3  20 D4 80             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0080CE  3  68                   pla
0080CF  3  A8                   TAY
0080D0  3  68                   pla
0080D1  3  AA                   TAX
0080D2  3  68                   PLA
0080D3  3  60                   RTS
0080D4  3               
0080D4  3               ;__PRINT_DIGIT_________________________________________________
0080D4  3               ;
0080D4  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0080D4  3               ;
0080D4  3               ;______________________________________________________________
0080D4  3               PRINT_DIGIT:
0080D4  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
0080D6  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
0080D8  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
0080DA  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0080DC  3  18                          CLC				; CLEAR CARRY
0080DD  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
0080DF  3               PRINT_DIGIT_OUT:					;
0080DF  3  4C 41 81                    JMP MACRO_OUTCH              		; PRINT OUT CHAR
0080E2  3               
0080E2  3               NEWLINE:
0080E2  3  48                           pha
0080E3  3  A9 0D                        LDA #$0D
0080E5  3  20 41 81                     JSR MACRO_OUTCH
0080E8  3  A9 0A                        LDA #$0A
0080EA  3  20 41 81                     Jsr MACRO_OUTCH
0080ED  3  68                           pla
0080EE  3  60                           rts
0080EF  3               SPACE:
0080EF  3  48                           pha
0080F0  3  A9 20                        LDA #' '
0080F2  3  20 41 81                     JSR MACRO_OUTCH
0080F5  3  68                           pla
0080F6  3  60                           rts
0080F7  3               
0080F7  3               
0080F7  3               PRTDEC:
0080F7  3  48                           PHA
0080F8  3  8D 35 06                     STA     STACKA
0080FB  3  98                           TYA
0080FC  3  48                           phA
0080FD  3  8A                           TXA
0080FE  3  48                           PHA
0080FF  3  AD 35 06                     LDA     STACKA
008102  3  48                           PHA
008103  3  A0 00                        ldy #00
008105  3  A2 FF                        LDX #$FF
008107  3  38                           SEC
008108  3               PrDec100:
008108  3  E8                           INX
008109  3  E9 64                        SBC #100
00810B  3  B0 FB                        BCS PrDec100            ;Count how many 100s
00810D  3  69 64                        ADC #100
00810F  3  20 2B 81                     JSR PrDecDigit          ;Print the 100s
008112  3  A2 FF                        LDX #$FF
008114  3  38                           SEC                     ;Prepare for subtraction
008115  3               PrDec10:
008115  3  E8                           INX
008116  3  E9 0A                        SBC #10
008118  3  B0 FB                        BCS PrDec10             ;Count how many 10s
00811A  3  69 0A                        ADC #10
00811C  3  20 2B 81                     JSR PrDecDigit          ;Print the 10s
00811F  3  AA                           TAX                     ;Pass 1s into X
008120  3  A0 01                        ldy #1
008122  3  20 2B 81                     JSR PrDecDigit          ;Print the 1s
008125  3  68                           PLA
008126  3  68                           pla
008127  3  AA                           TAX
008128  3  68                           pla
008129  3  A8                           TAY
00812A  3  60                           RTS
00812B  3               PrDecDigit:
00812B  3  48                           PHA
00812C  3  C0 00                        cpy #$00
00812E  3  D0 09                        bne PrDecDigit1
008130  3  8A                           txa
008131  3  A8                           tay
008132  3  C0 00                        cpy #$00
008134  3  D0 03                        bne PrDecDigit1
008136  3  4C 3F 81                     jmp PrDecDigit2
008139  3               PrDecDigit1:
008139  3  8A                           TXA                     ;Save A, pass digit to A
00813A  3  09 30                        ORA #'0'
00813C  3  20 41 81                     JSR  MACRO_OUTCH        ;Convert to character and print it
00813F  3               PrDecDigit2:
00813F  3  68                           PLA
008140  3  60                           RTS                     ;Restore A and return
008141  3               
008141  3               
008141  3               MACRO_OUTCH:
008141  3  DA                   PHX
008142  3  48                   pha
008143  3  AE 12 07             LDX     CONSOLE
008146  3  8A                   txa
008147  3  0A                   asl
008148  3  AA                   tax
008149  3  68                   pla
00814A  3  FC 2C 80             jsr     (DISPATCHTABLE,X)
00814D  3  FA                   PLX
00814E  3  60                   rts
00814F  3               ;
00814F  3               
00814F  2                       .INCLUDE "dosser.asm"
00814F  3               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00814F  3               ;
00814F  3               ; 	Nhyodyne serial drivers for single serial port card
00814F  3               ;
00814F  3               ;	Entry points:
00814F  3               ;		SERIALINIT  - called during OS init
00814F  3               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00814F  3               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00814F  3               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00814F  3               ;		SERIALSTATUS- GET UART STATUS
00814F  3               ;________________________________________________________________________________________________________________________________
00814F  3               ;
00814F  3               
00814F  3               
00814F  3               ;*
00814F  3               ;* HARDWARE I/O ADDRESSES
00814F  3               ;*
00814F  3               
00814F  3               
00814F  3               ;__________________________________________________________________________________________________
00814F  3               ; $8000-$8007 UART 16C550
00814F  3               ;__________________________________________________________________________________________________
00814F  3               UART0           = IO+$58        ;   DATA IN/OUT
00814F  3               UART1           = IO+$59        ;   CHECK RX
00814F  3               UART2           = IO+$5A        ;   INTERRUPTS
00814F  3               UART3           = IO+$5B        ;   LINE CONTROL
00814F  3               UART4           = IO+$5C        ;   MODEM CONTROL
00814F  3               UART5           = IO+$5D        ;   LINE STATUS
00814F  3               UART6           = IO+$5E        ;   MODEM STATUS
00814F  3               UART7           = IO+$5F        ;   SCRATCH REG.
00814F  3               
00814F  3               
00814F  3               ;__SERIALINIT____________________________________________________________________________________________________________________
00814F  3               ;
00814F  3               ;	INITIALIZE SERIAL PORTS
00814F  3               ;________________________________________________________________________________________________________________________________
00814F  3               ;
00814F  3               SERIALINIT:
00814F  3               ;	LDA	#$80			;
00814F  3               ;	STA	f:UART3			; SET DLAB FLAG
00814F  3               ;	LDA	#12			; SET TO 12 = 9600 BAUD
00814F  3               ;	STA	f:UART0			; save baud rate
00814F  3               ;	LDA	#00			;
00814F  3               ;	STA	f:UART1			;
00814F  3               ;	LDA	#03			;
00814F  3               ;	STA	f:UART3			; SET 8 BIT DATA, 1 STOPBIT
00814F  3               ;	STA	f:UART4			;
00814F  3               
00814F  3  60                   RTS
008150  3               
008150  3               
008150  3               
008150  3               ;__WRSER1________________________________________________________________________________________________________________________
008150  3               ;
008150  3               ;	WRITE CHARACTER(A) TO UART
008150  3               ;________________________________________________________________________________________________________________________________
008150  3               ;
008150  3               WRSER1:
008150  3  48                   PHA
008151  3               WRSER1a:
008151  3  AF 5D 03 00          LDA     f:UART5         ; READ LINE STATUS REGISTER
008155  3  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
008157  3  C9 00                CMP     #$00
008159  3  F0 F6                BEQ     WRSER1a         ; NO, WAIT FOR IT
00815B  3  68                   PLA
00815C  3  8F 58 03 00          STA     f:UART0         ; THEN WRITE THE CHAR TO UART
008160  3  60                   RTS
008161  3               
008161  3               ;__RDSER1________________________________________________________________________________________________________________________
008161  3               ;
008161  3               ;	READ CHARACTER FROM UART TO (A)
008161  3               ;________________________________________________________________________________________________________________________________
008161  3               ;
008161  3               RDSER1:
008161  3  AF 5D 03 00          LDA     f:UART5         ; READ LINE STATUS REGISTER
008165  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008167  3  C9 00                CMP     #$00
008169  3  F0 05                BEQ     RDSER1N         ; LOOP UNTIL DATA IS READY
00816B  3  AF 58 03 00          LDA     f:UART0         ; THEN READ THE CHAR FROM THE UART
00816F  3  60                   RTS
008170  3               RDSER1N:
008170  3  A9 00                LDA     #$00            ;
008172  3  60                   RTS                     ;
008173  3               
008173  3               ;__RDSER1W_______________________________________________________________________________________________________________________
008173  3               ;
008173  3               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
008173  3               ;________________________________________________________________________________________________________________________________
008173  3               ;
008173  3               
008173  3               RDSER1W:
008173  3  AF 5D 03 00          LDA     f:UART5         ; READ LINE STATUS REGISTER
008177  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008179  3  C9 00                CMP     #$00
00817B  3  F0 F6                BEQ     RDSER1W         ; LOOP UNTIL DATA IS READY
00817D  3  AF 58 03 00          LDA     f:UART0         ; THEN READ THE CHAR FROM THE UART
008181  3  29 7F                AND     #$7F
008183  3  60                   RTS
008184  3               
008184  3               ;__SERIALSTATUS__________________________________________________________________________________________________________________
008184  3               ;
008184  3               ;	READ UARD STATUS
008184  3               ;________________________________________________________________________________________________________________________________
008184  3               ;
008184  3               SERIALSTATUS:
008184  3  AF 5D 03 00          LDA     f:UART5         ; READ LINE STATUS REGISTER
008188  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00818A  3  C9 00                CMP     #$00
00818C  3  F0 03                BEQ     RDSTAT1         ; NO, INDICATE NO CHAR
00818E  3  A9 FF                LDA     #$FF            ; GET DATA CHAR
008190  3  60                   RTS
008191  3               RDSTAT1:
008191  3  A9 00                LDA     #$00            ; GET DATA CHAR
008193  3  60                   RTS
008194  3               
008194  3               ; end
008194  3               
008194  2                       .INCLUDE "doside.asm"
008194  3               ;__IDE DRIVERS___________________________________________________________________________________________________________________
008194  3               ;
008194  3               ; 	Duodyne IDE disk drivers for Z80PPIDE card
008194  3               ;
008194  3               ;	Entry points:
008194  3               ;		PPIDE_INIT   	- called during OS init
008194  3               ;		IDE_READ_SECTOR - read a sector from drive
008194  3               ;		IDE_WRITE_SECTOR- write a sector to drive
008194  3               ;________________________________________________________________________________________________________________________________
008194  3               ;
008194  3               PPIDE_PPI       = IO+$88        ; PORT A
008194  3               ;
008194  3               PPIDELO         = PPIDE_PPI+0   ; LSB
008194  3               PPIDEHI         = PPIDE_PPI+1   ; MSB
008194  3               PPIDECNTRL      = PPIDE_PPI+2   ; Control Signals
008194  3               PPIDEPPIC       = PPIDE_PPI+3   ; CONTROL BYTE PPI 82C55
008194  3               
008194  3               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
008194  3               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
008194  3               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
008194  3               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008194  3               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008194  3               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008194  3               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008194  3               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008194  3               
008194  3               PPIDE_DATA      = PPIDE_CS0_LINE
008194  3               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
008194  3               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
008194  3               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008194  3               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
008194  3               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
008194  3               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008194  3               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008194  3               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008194  3               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008194  3               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008194  3               
008194  3               
008194  3               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
008194  3               PPIDE_CMD_RECAL = $10
008194  3               PPIDE_CMD_READ  = $20
008194  3               PPIDE_CMD_WRITE = $30
008194  3               PPIDE_CMD_INIT  = $91
008194  3               PPIDE_CMD_ID    = $EC
008194  3               PPIDE_CMD_SPINDOWN = $E0
008194  3               PPIDE_CMD_SPINUP = $E1
008194  3               
008194  3               
008194  3               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
008194  3               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
008194  3               
008194  3               ;__PPIDE_INIT_________________________________________________________________________________________
008194  3               ;
008194  3               ;  INIT AND DISPLAY IDE INFO
008194  3               ;____________________________________________________________________________________________________
008194  3               ;
008194  3               PPIDE_INIT:
008194  3                       PRTDBG  "PPIDE INIT:$"
008194  3  48 DA 5A A2          PRTS    "PPIDE :$"
008198  3  00 BD AD 81  
00819C  3  E8 C9 24 F0  
0081B5  3  20 E2 80             JSR     NEWLINE
0081B8  3  20 77 83             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
0081BB  3  D0 35                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
0081BD  3               ;
0081BD  3  48 DA 5A A2          PRTS    " IO=0x$"
0081C1  3  00 BD D6 81  
0081C5  3  E8 C9 24 F0  
0081DD  3  A9 03                LDA     #>PPIDE_PPI     ; GET BASE PORT
0081DF  3  20 B6 80             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0081E2  3  A9 88                LDA     #<PPIDE_PPI     ; GET BASE PORT
0081E4  3  20 B6 80             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0081E7  3               ;
0081E7  3  20 17 84             JSR     PPIDE_RESET     ; RESET THE BUS
0081EA  3  20 80 82             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
0081ED  3  B0 03                BCS     IDE_ABORT
0081EF  3  4C 1B 82             JMP     IDE_PRINT_INFO
0081F2  3               IDE_ABORT:
0081F2  3  48 DA 5A A2          PRTS    " NOT PRESENT$" ; NOT PRESENT
0081F6  3  00 BD 0B 82  
0081FA  3  E8 C9 24 F0  
008218  3  4C 7C 82             JMP     IDE_INITA
00821B  3               IDE_PRINT_INFO:
00821B  3  20 E2 80             JSR     NEWLINE
00821E  3  48 DA 5A A2          PRTS    " PPIDE0: Blocks=$"
008222  3  00 BD 37 82  
008226  3  E8 C9 24 F0  
008248  3  A9 00                LDA     #$00
00824A  3  20 BF 82             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00824D  3  48 DA 5A A2          PRTS    " PPIDE1: Blocks=$"
008251  3  00 BD 66 82  
008255  3  E8 C9 24 F0  
008277  3  A9 01                LDA     #$01
008279  3  20 BF 82             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
00827C  3               IDE_INITA:
00827C  3  20 E2 80             JSR     NEWLINE
00827F  3  60                   RTS                     ; DONE
008280  3               ;
008280  3               ;__PPIDE_PROBE_______________________________________________________________________________________
008280  3               ;
008280  3               ;  PROBE FOR IDE HARDWARE
008280  3               ;____________________________________________________________________________________________________
008280  3               ;
008280  3               PPIDE_PROBE:
008280  3               ;
008280  3               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008280  3               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008280  3               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008280  3               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008280  3               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008280  3               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008280  3               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008280  3               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008280  3               
008280  3  A9 00                LDA     #$00
008282  3  8F 88 03 00          STA     f:PPIDELO       ; PPI PORT A, DATALO
008286  3  20 4A 84             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
008289  3  B0 32                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
00828B  3               
00828B  3  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
00828D  3  20 6B 85             JSR     IDE_READ
008290  3               
008290  3  8A                   TXA
008291  3  29 40                AND     #%01000000
008293  3  C9 00                CMP     #$00
008295  3  F0 26                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008297  3               
008297  3               ; CHECK SIGNATURE
008297  3  A9 0A                LDA     #PPIDE_SEC_CNT
008299  3  20 6B 85             JSR     IDE_READ
00829C  3               
00829C  3  E0 01                CPX     #$01
00829E  3  D0 1D                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
0082A0  3               
0082A0  3  A9 0B                LDA     #PPIDE_LBALOW
0082A2  3  20 6B 85             JSR     IDE_READ
0082A5  3               
0082A5  3  E0 01                CPX     #$01
0082A7  3  D0 14                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
0082A9  3               
0082A9  3  A9 0C                LDA     #PPIDE_LBAMID
0082AB  3  20 6B 85             JSR     IDE_READ
0082AE  3               
0082AE  3  E0 00                CPX     #$00
0082B0  3  D0 0B                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
0082B2  3               
0082B2  3  A9 0D                LDA     #PPIDE_LBAHI
0082B4  3  20 6B 85             JSR     IDE_READ
0082B7  3               
0082B7  3  E0 00                CPX     #$00
0082B9  3  D0 02                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
0082BB  3               
0082BB  3  18                   CLC
0082BC  3  60                   RTS
0082BD  3               PPIDE_PROBE_FAIL:
0082BD  3  38                   SEC
0082BE  3  60                   RTS
0082BF  3               
0082BF  3               ;*__IDE_READ_INFO___________________________________________________________________________________
0082BF  3               ;*
0082BF  3               ;*  READ IDE INFORMATION
0082BF  3               ;*	CARRY SET ON ERROR
0082BF  3               ;* 	A=MST/SLV
0082BF  3               ;*____________________________________________________________________________________________________
0082BF  3               IDE_READ_INFO:
0082BF  3                       PRTDBG  "IDE Read INFORMATION$"
0082BF  3  48                   PHA
0082C0  3  48                   PHA
0082C1  3               ; SET DRIVE BIT
0082C1  3  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
0082C3  3  0A                   ASL     a               ; SHIFT 4
0082C4  3  0A                   ASL     a               ;
0082C5  3  0A                   ASL     a               ;
0082C6  3  0A                   ASL     a               ;
0082C7  3  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
0082C9  3  AA                   TAX
0082CA  3  A0 00                LDY     #$00
0082CC  3  A9 0E                LDA     #PPIDE_DEVICE
0082CE  3  20 91 85             JSR     IDE_WRITE
0082D1  3               
0082D1  3  20 4A 84             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
0082D4  3  B0 4E                BCS     IDE_READ_INFO_ABORT
0082D6  3               
0082D6  3  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
0082D8  3  A2 EC                LDX     #PPIDE_CMD_ID
0082DA  3  20 91 85             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
0082DD  3  20 7F 84             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
0082E0  3  B0 42                BCS     IDE_READ_INFO_ABORT
0082E2  3               
0082E2  3  20 BA 84             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
0082E5  3  48 DA 5A A2          PRTS    "0x$"
0082E9  3  00 BD FE 82  
0082ED  3  E8 C9 24 F0  
008301  3  AF 7B 04 1D          LDA     f:LHSTBUF+123
008305  3  20 B6 80             JSR     PRTHEXBYTE
008308  3  AF 7A 04 1D          LDA     f:LHSTBUF+122
00830C  3  20 B6 80             JSR     PRTHEXBYTE
00830F  3  AF 79 04 1D          LDA     f:LHSTBUF+121
008313  3  20 B6 80             JSR     PRTHEXBYTE
008316  3  AF 78 04 1D          LDA     f:LHSTBUF+120
00831A  3  20 B6 80             JSR     PRTHEXBYTE
00831D  3  68                   PLA
00831E  3  20 E2 80             JSR     NEWLINE
008321  3  68                   PLA
008322  3  18                   CLC
008323  3  60                   RTS
008324  3               IDE_READ_INFO_ABORT:
008324  3  68                   PLA
008325  3  48 DA 5A A2          PRTS    "NOT PRESENT$"  ; NOT PRESENT
008329  3  00 BD 3E 83  
00832D  3  E8 C9 24 F0  
00834A  3  20 E2 80             JSR     NEWLINE
00834D  3  68                   PLA
00834E  3  20 53 83             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008351  3  38                   SEC
008352  3  60                   RTS                     ;
008353  3               
008353  3               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008353  3  18                   CLC
008354  3  69 30                ADC     #$30
008356  3  A2 00                LDX     #$00
008358  3               @1:
008358  3  DD 17 06             CMP     dskcfg,X        ; GET device
00835B  3  F0 09                BEQ     @2
00835D  3  E8                   INX
00835E  3  E8                   INX
00835F  3  E0 10                CPX     #16
008361  3  D0 F5                BNE     @1
008363  3  4C 76 83             JMP     @3
008366  3               @2:
008366  3  48                   PHA
008367  3  A9 00                LDA     #$00
008369  3  9D 17 06             STA     dskcfg,X        ; SET device
00836C  3  E8                   INX
00836D  3  9D 17 06             STA     dskcfg,X        ; SET device
008370  3  68                   PLA
008371  3  E8                   INX
008372  3  E0 10                CPX     #16
008374  3  D0 E2                BNE     @1
008376  3               @3:
008376  3  60                   RTS
008377  3               
008377  3               ;__IDE_PPIDETECT____________________________________________________________________________________
008377  3               ;
008377  3               ;  PROBE FOR PPI HARDWARE
008377  3               ;____________________________________________________________________________________________________
008377  3               ;
008377  3               IDE_PPIDETECT:
008377  3               ;
008377  3               ; TEST FOR PPI EXISTENCE
008377  3               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008377  3               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008377  3               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008377  3               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008377  3               ; INTERFERE WITH THE VALUE BEING READ.
008377  3  20 C3 85             JSR     SET_PPI_WR
00837A  3               ;
00837A  3  A9 00                LDA     #$00            ; VALUE ZERO
00837C  3  8F 88 03 00          STA     f:PPIDELO       ; PUSH VALUE TO PORT
008380  3  EA                   NOP
008381  3  EA                   NOP
008382  3  EA                   NOP
008383  3  EA                   NOP
008384  3  EA                   NOP
008385  3  EA                   NOP
008386  3  AF 88 03 00          LDA     f:PPIDELO       ; GET PORT VALUE
00838A  3  C9 00                CMP     #$00
00838C  3  60                   RTS                     ; AND RETURN
00838D  3               ;
00838D  3               
00838D  3               
00838D  3               ;*__IDE_READ_SECTOR___________________________________________________________________________________
00838D  3               ;*
00838D  3               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00838D  3               ;*
00838D  3               ;*____________________________________________________________________________________________________
00838D  3               IDE_READ_SECTOR:
00838D  3                       PRTDBG  "IDE Read Sector$"
00838D  3  20 CC 85             JSR     IDE_CONVERT_SECTOR_LBA
008390  3  AD 10 06             LDA     debsehd         ; STORE CURRENT PARMS
008393  3  CD 43 06             CMP     Cdebsehd        ;
008396  3  D0 18                BNE     IDE_READ_SECTOR_DIRTY
008398  3  AD 12 06             LDA     debcylm         ;
00839B  3  CD 45 06             CMP     Cdebcylm        ;
00839E  3  D0 10                BNE     IDE_READ_SECTOR_DIRTY
0083A0  3  AD 11 06             LDA     debcyll         ;
0083A3  3  CD 44 06             CMP     Cdebcyll        ;
0083A6  3  D0 08                BNE     IDE_READ_SECTOR_DIRTY
0083A8  3  A5 48                LDA     sekdsk
0083AA  3  CD 46 06             CMP     CacUnit         ;
0083AD  3  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
0083AF  3  60                   RTS
0083B0  3               
0083B0  3               IDE_READ_SECTOR_DIRTY:
0083B0  3                       PRTDBG  "IDE Read Sector Buffer Dirty$"
0083B0  3  20 4A 84             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
0083B3  3  B0 2C                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
0083B5  3               IDE_READ_SECTOR_DIRTY1:
0083B5  3  20 39 85             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
0083B8  3  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
0083BA  3  A2 20                LDX     #PPIDE_CMD_READ
0083BC  3  20 91 85             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
0083BF  3  20 7F 84             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
0083C2  3  B0 1D                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
0083C4  3  20 BA 84             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
0083C7  3  AD 10 06             LDA     debsehd         ; STORE CURRENT PARMS
0083CA  3  8D 43 06             STA     Cdebsehd        ;
0083CD  3  AD 11 06             LDA     debcyll         ;
0083D0  3  8D 44 06             STA     Cdebcyll        ;
0083D3  3  AD 12 06             LDA     debcylm         ;
0083D6  3  8D 45 06             STA     Cdebcylm        ;
0083D9  3  A5 48                LDA     sekdsk
0083DB  3  8D 46 06             STA     CacUnit         ;
0083DE  3  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
0083E0  3  60                   RTS
0083E1  3               IDE_READ_SECTOR_DIRTY_ERROR:
0083E1  3  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
0083E3  3  60                   RTS
0083E4  3               
0083E4  3               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
0083E4  3               ;*
0083E4  3               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
0083E4  3               ;*
0083E4  3               ;*____________________________________________________________________________________________________
0083E4  3               IDE_WRITE_SECTOR:
0083E4  3                       PRTDBG  "IDE Write Sector$"
0083E4  3  20 CC 85             JSR     IDE_CONVERT_SECTOR_LBA
0083E7  3  20 4A 84             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
0083EA  3  B0 28                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
0083EC  3               IDE_WRITE_SECTOR_RAW:
0083EC  3  20 39 85             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
0083EF  3  A9 0F                LDA     #PPIDE_COMMAND
0083F1  3  A2 30                LDX     #PPIDE_CMD_WRITE
0083F3  3  20 91 85             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
0083F6  3  20 7F 84             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
0083F9  3  B0 19                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
0083FB  3  20 F3 84             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
0083FE  3  20 4A 84             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
008401  3  B0 11                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008403  3  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
008405  3  8D 43 06             STA     Cdebsehd        ;
008408  3  8D 44 06             STA     Cdebcyll        ;
00840B  3  8D 45 06             STA     Cdebcylm        ;
00840E  3  8D 46 06             STA     CacUnit         ;
008411  3  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008413  3  60                   RTS
008414  3               IDE_WRITE_SECTOR_ERROR:
008414  3  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008416  3  60                   RTS
008417  3               
008417  3               ;*__PPIDE_RESET____________________________________________________________________________________
008417  3               ;*
008417  3               ;*  SOFT RESET IDE CHANNEL
008417  3               ;*
008417  3               ;*____________________________________________________________________________________________________
008417  3               PPIDE_RESET:
008417  3                       PRTDBG  "IDE Reset$"
008417  3  A9 00                LDA     #$00
008419  3  8D 10 06             STA     debsehd
00841C  3  8D 11 06             STA     debcyll
00841F  3  8D 12 06             STA     debcylm
008422  3  A9 FF                LDA     #$FF            ;
008424  3  8D 43 06             STA     Cdebsehd        ;
008427  3  8D 44 06             STA     Cdebcyll        ;
00842A  3  8D 45 06             STA     Cdebcylm        ;
00842D  3  8D 46 06             STA     CacUnit         ;
008430  3  A9 80                LDA     #PPIDE_RST_LINE
008432  3  8F 8A 03 00          STA     f:PPIDECNTRL    ; ASSERT RST LINE ON IDE INTERFACE
008436  3                       PRTDBG  "IDE Reset Delay$"
008436  3               
008436  3               
008436  3  C2 10                INDEX16                 ; A bit of waiting
008438  3  A2 00 00             LDX     #$0000
00843B  3               :
00843B  3  E8                   INX
00843C  3  E0 00 F0             CPX     #$F000
00843F  3  D0 FA                BNE     :-
008441  3  E2 10                INDEX8
008443  3  A9 00                LDA     #$00
008445  3  8F 8A 03 00          STA     f:PPIDECNTRL    ; DEASSERT RST LINE ON IDE INTERFACE
008449  3               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008449  3               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008449  3               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  JSR     DSKY_REINIT
008449  3               
008449  3  60                   RTS
00844A  3               
00844A  3               
00844A  3               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
00844A  3               ;*
00844A  3               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
00844A  3               ;*
00844A  3               ;*____________________________________________________________________________________________________
00844A  3               IDE_WAIT_NOT_BUSY:
00844A  3  48                   PHA
00844B  3  DA                   PHX
00844C  3  5A                   PHY
00844D  3  A9 00                LDA     #$00
00844F  3  8D 37 06             STA     FLRETRY
008452  3  8D 38 06             STA     FLRETRY+1
008455  3               IDE_WAIT_NOT_BUSY1:
008455  3  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
008457  3  20 6B 85             JSR     IDE_READ
00845A  3  8A                   TXA
00845B  3  29 80                AND     #$80
00845D  3  C9 00                CMP     #$00            ; !@#$ PROBABLY NOT NECESSARY
00845F  3  F0 19                BEQ     IDE_WAIT_NOT_BUSY2
008461  3  EE 37 06             INC     FLRETRY
008464  3  AD 37 06             LDA     FLRETRY         ; !@#$ PROBABLY NOT NECESSARY
008467  3  C9 00                CMP     #$00            ; !@#$ PROBABLY NOT NECESSARY
008469  3  D0 EA                BNE     IDE_WAIT_NOT_BUSY1
00846B  3  EE 38 06             INC     FLRETRY+1
00846E  3  AD 38 06             LDA     FLRETRY+1       ; !@#$ PROBABLY NOT NECESSARY
008471  3  C9 00                CMP     #$00            ; !@#$ PROBABLY NOT NECESSARY
008473  3  D0 E0                BNE     IDE_WAIT_NOT_BUSY1
008475  3  7A                   PLY
008476  3  FA                   PLX
008477  3  68                   PLA
008478  3  38                   SEC
008479  3  60                   RTS
00847A  3               IDE_WAIT_NOT_BUSY2:
00847A  3  7A                   PLY
00847B  3  FA                   PLX
00847C  3  68                   PLA
00847D  3  18                   CLC
00847E  3  60                   RTS
00847F  3               
00847F  3               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
00847F  3               ;*
00847F  3               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
00847F  3               ;*
00847F  3               ;*____________________________________________________________________________________________________
00847F  3               IDE_WAIT_DRQ:
00847F  3  48                   PHA
008480  3  DA                   PHX
008481  3  5A                   PHY
008482  3  A9 00                LDA     #$00
008484  3  8D 37 06             STA     FLRETRY
008487  3  8D 38 06             STA     FLRETRY+1
00848A  3               IDE_WAIT_DRQ1:
00848A  3  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
00848C  3  20 6B 85             JSR     IDE_READ
00848F  3  8A                   TXA
008490  3  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
008492  3  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008494  3  F0 1F                BEQ     IDE_WAIT_DRQ2
008496  3  29 01                AND     #%00000001      ; IS ERROR?
008498  3  C9 01                CMP     #%00000001      ;
00849A  3  F0 14                BEQ     IDE_WAIT_DRQE
00849C  3  EE 37 06             INC     FLRETRY
00849F  3  AD 37 06             LDA     FLRETRY         ; !@#$ PROBABLY NOT NECESSARY
0084A2  3  C9 00                CMP     #$00            ; !@#$ PROBABLY NOT NECESSARY
0084A4  3  D0 E4                BNE     IDE_WAIT_DRQ1
0084A6  3  EE 38 06             INC     FLRETRY+1
0084A9  3  AD 38 06             LDA     FLRETRY+1       ; !@#$ PROBABLY NOT NECESSARY
0084AC  3  C9 00                CMP     #$00            ; !@#$ PROBABLY NOT NECESSARY
0084AE  3  D0 DA                BNE     IDE_WAIT_DRQ1
0084B0  3               IDE_WAIT_DRQE:
0084B0  3  7A                   PLY
0084B1  3  FA                   PLX
0084B2  3  68                   PLA
0084B3  3  38                   SEC
0084B4  3  60                   RTS
0084B5  3               IDE_WAIT_DRQ2:
0084B5  3  7A                   PLY
0084B6  3  FA                   PLX
0084B7  3  68                   PLA
0084B8  3  18                   CLC
0084B9  3  60                   RTS
0084BA  3               
0084BA  3               
0084BA  3               
0084BA  3               ;*__IDE_READ_BUFFER___________________________________________________________________________________
0084BA  3               ;*
0084BA  3               ;*  READ IDE BUFFER LITTLE ENDIAN
0084BA  3               ;*
0084BA  3               ;*____________________________________________________________________________________________________
0084BA  3               IDE_READ_BUFFER:
0084BA  3  A2 00                LDX     #$00            ; INDEX
0084BC  3               IDEBUFRD:
0084BC  3  8E 3C 06             STX     PPIDEINDEX
0084BF  3  A9 08                LDA     #PPIDE_DATA
0084C1  3  20 6B 85             JSR     IDE_READ
0084C4  3  8A                   TXA
0084C5  3  AE 3C 06             LDX     PPIDEINDEX
0084C8  3  9F 00 04 1D          STA     f:LHSTBUF,X     ;
0084CC  3  98                   TYA                     ; THEN HIGH BYTE OF WORD
0084CD  3  9F 01 04 1D          STA     f:LHSTBUF+1,X   ;
0084D1  3  E8                   INX
0084D2  3  E8                   INX                     ;
0084D3  3  E0 00                CPX     #$00            ;
0084D5  3  D0 E5                BNE     IDEBUFRD        ;
0084D7  3               IDEBUFRD1:
0084D7  3  8E 3C 06             STX     PPIDEINDEX
0084DA  3  A9 08                LDA     #PPIDE_DATA
0084DC  3  20 6B 85             JSR     IDE_READ
0084DF  3  8A                   TXA
0084E0  3  AE 3C 06             LDX     PPIDEINDEX
0084E3  3  9F 00 05 1D          STA     f:LHSTBUF+256,X ;
0084E7  3  98                   TYA                     ; THEN HIGH BYTE OF WORD
0084E8  3  9F 01 05 1D          STA     f:LHSTBUF+257,X ;
0084EC  3  E8                   INX                     ;
0084ED  3  E8                   INX                     ;
0084EE  3  E0 00                CPX     #$00            ;
0084F0  3  D0 E5                BNE     IDEBUFRD1       ;
0084F2  3  60                   RTS                     ;
0084F3  3               
0084F3  3               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
0084F3  3               ;*
0084F3  3               ;*  WRITE IDE BUFFER LITTLE ENDIAN
0084F3  3               ;*
0084F3  3               ;*____________________________________________________________________________________________________
0084F3  3               IDE_WRITE_BUFFER:
0084F3  3  A2 00                LDX     #$00            ; INDEX
0084F5  3               IDEBUFWT:
0084F5  3  8E 3C 06             STX     PPIDEINDEX
0084F8  3  BF 00 04 1D          LDA     f:LHSTBUF,X     ; SECTORS ARE BIG ENDIAN
0084FC  3  8D 38 85             STA     WRTMP
0084FF  3  BF 01 04 1D          LDA     f:LHSTBUF+1,X   ; SECTORS ARE BIG ENDIAN
008503  3  A8                   TAY
008504  3  AE 38 85             LDX     WRTMP
008507  3  A9 08                LDA     #PPIDE_DATA
008509  3  20 91 85             JSR     IDE_WRITE
00850C  3  AE 3C 06             LDX     PPIDEINDEX
00850F  3  E8                   INX                     ;
008510  3  E8                   INX                     ;
008511  3  E0 00                CPX     #$00            ;
008513  3  D0 E0                BNE     IDEBUFWT        ;
008515  3  A2 00                LDX     #$00            ; INDEX
008517  3               IDEBUFWT1:
008517  3  8E 3C 06             STX     PPIDEINDEX
00851A  3  BF 00 05 1D          LDA     f:LHSTBUF+256,X ; SECTORS ARE BIG ENDIAN
00851E  3  8D 38 85             STA     WRTMP
008521  3  BF 01 05 1D          LDA     f:LHSTBUF+257,X ; SECTORS ARE BIG ENDIAN
008525  3  A8                   TAY
008526  3  AE 38 85             LDX     WRTMP
008529  3  A9 08                LDA     #PPIDE_DATA
00852B  3  20 91 85             JSR     IDE_WRITE
00852E  3  AE 3C 06             LDX     PPIDEINDEX
008531  3  E8                   INX                     ;
008532  3  E8                   INX                     ;
008533  3  E0 00                CPX     #$00            ;
008535  3  D0 E0                BNE     IDEBUFWT1       ;
008537  3  60                   RTS                     ;
008538  3               WRTMP:
008538  3  00                   .BYTE   00
008539  3               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008539  3               ;*
008539  3               ;*  SETUP LBA DATA
008539  3               ;*  A= DRIVE DEVICE
008539  3               ;*____________________________________________________________________________________________________
008539  3               IDE_SETUP_LBA:
008539  3                       PRTDBG  "PPIDE SETUP LBA$"
008539  3  A5 49                LDA     currentDrive
00853B  3  29 01                AND     #$01            ; only want drive cfg
00853D  3  0A                   ASL     a               ; SHIFT 4
00853E  3  0A                   ASL     a               ;
00853F  3  0A                   ASL     a               ;
008540  3  0A                   ASL     a               ;
008541  3  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008543  3  AA                   TAX
008544  3  A0 00                LDY     #$00
008546  3  A9 0E                LDA     #PPIDE_DEVICE
008548  3  20 91 85             JSR     IDE_WRITE
00854B  3               
00854B  3  AE 12 06             LDX     debcylm
00854E  3  A9 0D                LDA     #PPIDE_LBAHI
008550  3  20 91 85             JSR     IDE_WRITE
008553  3               
008553  3  AE 11 06             LDX     debcyll         ;
008556  3  A9 0C                LDA     #PPIDE_LBAMID
008558  3  20 91 85             JSR     IDE_WRITE
00855B  3               
00855B  3  AE 10 06             LDX     debsehd         ;
00855E  3  A9 0B                LDA     #PPIDE_LBALOW
008560  3  20 91 85             JSR     IDE_WRITE
008563  3               
008563  3  A2 01                LDX     #$01
008565  3  A9 0A                LDA     #PPIDE_SEC_CNT
008567  3  20 91 85             JSR     IDE_WRITE
00856A  3               
00856A  3  60                   RTS
00856B  3               
00856B  3               
00856B  3               ;-------------------------------------------------------------------------------
00856B  3               
00856B  3               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
00856B  3               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
00856B  3               ; PROGRAM WOULD NOT CALL TO THESE.
00856B  3               
00856B  3               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
00856B  3               ;INPUT A = IDE REGSITER ADDRESS
00856B  3               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
00856B  3               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
00856B  3               
00856B  3               IDE_READ:
00856B  3  20 BA 85             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
00856E  3  8F 8A 03 00          STA     f:PPIDECNTRL    ;DRIVE ADDRESS ONTO CONTROL LINES
008572  3  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
008574  3  8F 8A 03 00          STA     f:PPIDECNTRL
008578  3  48                   PHA
008579  3  AF 88 03 00          LDA     f:PPIDELO       ; READ LOWER BYTE
00857D  3  AA                   TAX
00857E  3  AF 89 03 00          LDA     f:PPIDEHI       ; READ UPPER BYTE
008582  3  A8                   TAY
008583  3  68                   PLA
008584  3  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
008586  3  8F 8A 03 00          STA     f:PPIDECNTRL
00858A  3  A9 00                LDA     #$00
00858C  3  8F 8A 03 00          STA     f:PPIDECNTRL    ;DEASSERT ALL CONTROL PINS
008590  3  60                   RTS
008591  3               
008591  3               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008591  3               ;INPUT A = IDE REGISTER ADDRESS
008591  3               ;INPUT REGISTER X = LSB TO WRITE
008591  3               ;INPUT REGISTER Y = MSB TO WRITE
008591  3               ;
008591  3               
008591  3               IDE_WRITE:
008591  3  20 C3 85             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
008594  3  48                   PHA
008595  3  98                   TYA
008596  3  8F 89 03 00          STA     f:PPIDEHI       ; WRITE UPPER BYTE
00859A  3  8A                   TXA
00859B  3  8F 88 03 00          STA     f:PPIDELO       ; WRITE LOWER BYTE
00859F  3  68                   PLA
0085A0  3  8F 8A 03 00          STA     f:PPIDECNTRL    ;DRIVE ADDRESS ONTO CONTROL LINES
0085A4  3  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
0085A6  3  8F 8A 03 00          STA     f:PPIDECNTRL
0085AA  3  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
0085AC  3  8F 8A 03 00          STA     f:PPIDECNTRL
0085B0  3  A9 00                LDA     #$00
0085B2  3  8F 8A 03 00          STA     f:PPIDECNTRL    ;DEASSERT ALL CONTROL PINS
0085B6  3  20 BA 85             JSR     SET_PPI_RD
0085B9  3  60                   RTS
0085BA  3               
0085BA  3               
0085BA  3               ;-----------------------------------------------------------------------------------
0085BA  3               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
0085BA  3               ;
0085BA  3               ;------------------------------------------------------------------------------------
0085BA  3               
0085BA  3               SET_PPI_RD:
0085BA  3  48                   PHA
0085BB  3  A9 92                LDA     #PPRD_IDE_8255
0085BD  3  8F 8B 03 00          STA     f:PPIDEPPIC     ;CONFIG 8255 CHIP, READ MODE
0085C1  3  68                   PLA
0085C2  3  60                   RTS
0085C3  3               
0085C3  3               SET_PPI_WR:
0085C3  3  48                   PHA
0085C4  3  A9 80                LDA     #PPWR_IDE_8255
0085C6  3  8F 8B 03 00          STA     f:PPIDEPPIC     ;CONFIG 8255 CHIP, WRITE MODE
0085CA  3  68                   PLA
0085CB  3  60                   RTS
0085CC  3               
0085CC  3               
0085CC  3               
0085CC  3               ;___IDE_CONVERT_SECTOR_LBA_______________________________________________________________________________
0085CC  3               ;
0085CC  3               ; 	TRANSLATE LBA SECTORS
0085CC  3               ;________________________________________________________________________________________________________
0085CC  3               IDE_CONVERT_SECTOR_LBA:
0085CC  3  A5 44                LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0085CE  3  29 0F                AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
0085D0  3  0A                   ASL     a               ; MOVE TO HIGH BYTE
0085D1  3  0A                   ASL     a
0085D2  3  0A                   ASL     a
0085D3  3  0A                   ASL     a
0085D4  3  AA                   TAX                     ; PARK IN X
0085D5  3  A5 46                LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
0085D7  3  4A                   LSR     A               ;
0085D8  3  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
0085D9  3  29 0F                AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
0085DB  3  8D 10 06             STA     debsehd         ; STORE IN SECTOR/HEAD
0085DE  3  8A                   TXA                     ; GET HEAD BACK
0085DF  3  0D 10 06             ORA     debsehd
0085E2  3  8D 10 06             STA     debsehd         ; STORE IN SECTOR/HEAD
0085E5  3               
0085E5  3  A5 44                LDA     sektrk
0085E7  3  8D 11 06             STA     debcyll         ; STORE IN TRACK (lsb)
0085EA  3  A5 45                LDA     sektrk+1
0085EC  3  8D 12 06             STA     debcylm         ; STORE IN TRACK (msb)
0085EF  3               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
0085EF  3  AD 12 06             LDA     debcylm
0085F2  3  4A                   LSR     A
0085F3  3  8D 12 06             STA     debcylm
0085F6  3  AD 11 06             LDA     debcyll
0085F9  3  6A                   ROR     A
0085FA  3  8D 11 06             STA     debcyll
0085FD  3               
0085FD  3  AD 12 06             LDA     debcylm
008600  3  4A                   LSR     A
008601  3  8D 12 06             STA     debcylm
008604  3  AD 11 06             LDA     debcyll
008607  3  6A                   ROR     A
008608  3  8D 11 06             STA     debcyll
00860B  3               
00860B  3  AD 12 06             LDA     debcylm
00860E  3  4A                   LSR     A
00860F  3  8D 12 06             STA     debcylm
008612  3  AD 11 06             LDA     debcyll
008615  3  6A                   ROR     A
008616  3  8D 11 06             STA     debcyll
008619  3               
008619  3  AD 12 06             LDA     debcylm
00861C  3  4A                   LSR     A
00861D  3  8D 12 06             STA     debcylm
008620  3  AD 11 06             LDA     debcyll
008623  3  6A                   ROR     A
008624  3  8D 11 06             STA     debcyll
008627  3               ;	ADD SLICE OFFSET
008627  3  A5 48                LDA     sekdsk          ; GET DRIVE#
008629  3  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00862B  3  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00862C  3  AA                   TAX                     ; MOVE TO X REGISTER
00862D  3  E8                   INX                     ; WANT SECOND BYTE OF ENTRY
00862E  3  BF 17 06 1D          LDA     F:LDSKCFG,X     ; GET SLICE#
008632  3  8D 32 06             STA     slicetmp+1      ; SLICE OFFSET MSB
008635  3  A9 00                LDA     #0              ; GET SLICE#
008637  3  8D 31 06             STA     slicetmp        ; SLICE OFFSET LSB
00863A  3  18                   CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
00863B  3  6E 32 06             ROR     slicetmp+1
00863E  3  6E 31 06             ROR     slicetmp
008641  3  6E 32 06             ROR     slicetmp+1
008644  3  6E 31 06             ROR     slicetmp
008647  3               
008647  3  BF 17 06 1D          LDA     F:LDSKCFG,X     ; GET SLICE#
00864B  3  18                   CLC
00864C  3  6D 31 06             ADC     slicetmp
00864F  3  8D 31 06             STA     slicetmp
008652  3  A9 00                LDA     #$00            ; LOGIC ERROR FOR SLICES THAT CARRY?
008654  3  6D 32 06             ADC     slicetmp+1      ;
008657  3  8D 32 06             STA     slicetmp+1      ;
00865A  3               
00865A  3               ; ADD SLICE OFFSET TO TRACK #
00865A  3  18                   CLC                     ; clear carry
00865B  3  AD 31 06             LDA     slicetmp
00865E  3  6D 11 06             ADC     debcyll
008661  3  8D 11 06             STA     debcyll         ; store sum of LSBs
008664  3  AD 32 06             LDA     slicetmp+1
008667  3  6D 12 06             ADC     debcylm         ; add the MSBs using carry from
00866A  3  8D 12 06             STA     debcylm         ; the previous calculation
00866D  3  60                   RTS
00866E  3               
00866E  2                       .INCLUDE "dosrtc.asm"
00866E  3               ;__RTC DRIVERS____________________________________________________________________________________________________________________
00866E  3               ;
00866E  3               ; 	Duodyne Real Time Clock drivers (ROMRAM Card)
00866E  3               ;
00866E  3               ;	Entry points:
00866E  3               ;		RTC_INIT        - called during OS init
00866E  3               ;		RTC_READ        - read a sector from drive
00866E  3               ;		RTC_WRITE       - write a sector to drive
00866E  3               ;		RTC_LED         - UPDATE LEDS
00866E  3               ;               RTC_BUTTON      - GET BUTTON STATUS
00866E  3               ;               RTC_BEEP        - BEEP RTC SPEAKER
00866E  3               ;
00866E  3               ;________________________________________________________________________________________________________________________________
00866E  3               ;
00866E  3               ; RAM BANK $1E is RAM area for Drivers
00866E  3               ; RAM BANK $1D is operating bank for DOS/65 $8000-$FFFF
00866E  3               ;
00866E  3               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00866E  3               ; ROM Drive starts in bank $22
00866E  3               ; RAM Drive starts in bank $02
00866E  3               ;
00866E  3               ;
00866E  3               ;
00866E  3               RTCIO           = IO+$94        ; PORT A
00866E  3               ;
00866E  3               ; Write Bits
00866E  3               ; Latch IO   MSB   7 6 5 4 3 2 1 0  LSB
00866E  3               ;                  | | | | | | | |-- USER LED 0
00866E  3               ;                  | | | | | | |---- USER LED 1
00866E  3               ;                  | | | | | |------ SPEAKER
00866E  3               ;                  | | | | |-------- /MEMORY ENABLE
00866E  3               ;                  | | | |---------- RTC RESET
00866E  3               ;                  | | |------------ RTC WRITE
00866E  3               ;                  | |-------------- RTC CLK
00866E  3               ;                  |---------------- RTC DATA
00866E  3               ;
00866E  3               ; Read Bits
00866E  3               ; Latch IO   MSB   7 6 5 4 3 2 1 0  LSB
00866E  3               ;                  X | X X X X | |-- RTC DQ
00866E  3               ;                    |         |---- /MEMORY ENABLE
00866E  3               ;                    |-------------- USER BUTTON
00866E  3               ;
00866E  3               ;
00866E  3               ;
00866E  3               
00866E  3               
00866E  3               mask_data_out   = $01           ; RTC data line
00866E  3               mask_data_in    = $80           ; RTC data line
00866E  3               mask_clk        = $40           ; RTC Serial Clock line
00866E  3               mask_wrt_en     = $20           ; RTC Serial Clock line
00866E  3               mask_ce         = $10           ; RTC CHIP ENABLE
00866E  3               
00866E  3               mask_mem_en     = $08
00866E  3               mask_spk        = $04
00866E  3               mask_led1       = $02
00866E  3               mask_led0       = $01
00866E  3               
00866E  3               mask_button     = $40
00866E  3               
00866E  3               ;__RTC_INIT__________________________________________________________________________________________
00866E  3               ;
00866E  3               ;  INIT RTC
00866E  3               ;____________________________________________________________________________________________________
00866E  3               ;
00866E  3               RTC_INIT:
00866E  3                       PRTDBG  "RTC INIT:$"
00866E  3  48 DA 5A A2          PRTS    "RTC: $"
008672  3  00 BD 87 86  
008676  3  E8 C9 24 F0  
00868D  3  20 E2 80             JSR     NEWLINE
008690  3  48 DA 5A A2          PRTS    " IO=0x$"
008694  3  00 BD A9 86  
008698  3  E8 C9 24 F0  
0086B0  3  A9 03                LDA     #>RTCIO         ; GET BASE PORT
0086B2  3  20 B6 80             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0086B5  3  A9 94                LDA     #<RTCIO         ; GET BASE PORT
0086B7  3  20 B6 80             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0086BA  3  20 E2 80             JSR     NEWLINE         ;
0086BD  3  AD CC 86             LDA     RTCVALUE        ; RESET PORT VALUE
0086C0  3  8F 94 03 00          STA     f:RTCIO
0086C4  3  A0 80                LDY     #$80
0086C6  3  A2 40                LDX     #$40
0086C8  3  20 27 87             JSR     RTC_BEEP
0086CB  3               
0086CB  3  60                   RTS
0086CC  3               
0086CC  3               RTCVALUE:
0086CC  3  00                   .BYTE   $00
0086CD  3               
0086CD  3               
0086CD  3               ;__RTC_WRITE____________________________________________________
0086CD  3               ; write a value to the DS1302
0086CD  3               ; address in X
0086CD  3               ; value in Y
0086CD  3               ;_______________________________________________________________
0086CD  3               RTC_WRITE:
0086CD  3  48                   PHA
0086CE  3  20 66 87             JSR     RTC_CE_ENABLE
0086D1  3  8A                   TXA                     ; bring into A the address from X
0086D2  3  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
0086D4  3  18                   CLC
0086D5  3  0A                   ASL     A
0086D6  3  09 80                ORA     #%10000000      ; set MSB to one for DS1302 COMMAND BYTE (WRITE)
0086D8  3  20 80 87             JSR     RTC_WR          ; write address to DS1302
0086DB  3  98                   TYA                     ; start processing value
0086DC  3  20 80 87             JSR     RTC_WR          ; write value to DS1302
0086DF  3  20 73 87             JSR     RTC_CE_DISABLE
0086E2  3  68                   PLA
0086E3  3  60                   RTS
0086E4  3               
0086E4  3               ;__RTC_READ______________________________________________________
0086E4  3               ; read a value from the DS1302
0086E4  3               ; address in X
0086E4  3               ; value in Y
0086E4  3               ;_______________________________________________________________
0086E4  3               RTC_READ:
0086E4  3  48                   PHA
0086E5  3  20 66 87             JSR     RTC_CE_ENABLE
0086E8  3  8A                   TXA                     ; bring into A the address from X
0086E9  3  29 3F                AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
0086EB  3  18                   CLC
0086EC  3  0A                   ASL     A               ; rotate address bits to the left
0086ED  3  09 81                ORA     #%10000001      ; set MSB to one for DS1302 COMMAND BYTE (READ)
0086EF  3  20 80 87             JSR     RTC_WR          ; write address to DS1302
0086F2  3  20 B3 87             JSR     RTC_RD          ; read value from DS1302 (value is in reg A)
0086F5  3  A8                   TAY
0086F6  3  20 73 87             JSR     RTC_CE_DISABLE
0086F9  3  68                   PLA
0086FA  3  60                   RTS
0086FB  3               
0086FB  3               
0086FB  3               ;__RTC_LED______________________________________________________
0086FB  3               ; Control the LEDs on the RomRam card
0086FB  3               ; LED#  in X
0086FB  3               ; value in Y
0086FB  3               ;_______________________________________________________________
0086FB  3               RTC_LED:
0086FB  3  48                   PHA
0086FC  3  8A                   TXA
0086FD  3  29 01                AND     #$01
0086FF  3  C9 00                CMP     #00
008701  3  D0 0E                BNE     :+
008703  3  98                   TYA                     ; LED 00
008704  3  29 01                AND     #$01
008706  3  0D CC 86             ORA     RTCVALUE
008709  3  8D CC 86             STA     RTCVALUE
00870C  3  8F 94 03 00          STA     f:RTCIO
008710  3  60                   RTS
008711  3               :
008711  3  98                   TYA                     ; LED 01
008712  3  29 01                AND     #$01
008714  3  0A                   ASL
008715  3  0D CC 86             ORA     RTCVALUE
008718  3  8D CC 86             STA     RTCVALUE
00871B  3  8F 94 03 00          STA     f:RTCIO
00871F  3  60                   RTS
008720  3               ;__RTC_BUTTON___________________________________________________
008720  3               ; read the button state on the RomRam card
008720  3               ; button value in A
008720  3               ;_______________________________________________________________
008720  3               RTC_BUTTON:
008720  3  AF 94 03 00          LDA     f:RTCIO
008724  3  25 40                AND     mask_button
008726  3  60                   RTS
008727  3               
008727  3               ;__RTC_BEEP_____________________________________________________
008727  3               ; Produce a tone on the RomRam Speaker
008727  3               ; frequency in X (*FF)
008727  3               ; length in Y (*FF)
008727  3               ;_______________________________________________________________
008727  3               RTC_BEEP:
008727  3  48                   PHA
008728  3  86 3B                STX     TEMPWORD
00872A  3  84 3E                STY     TEMPWORD1+1
00872C  3  A9 00                LDA     #$00
00872E  3  85 3C                STA     TEMPWORD+1
008730  3  85 3D                STA     TEMPWORD1
008732  3  AD CC 86             LDA     RTCVALUE
008735  3  8D 65 87             STA     RTC_BEEP_TEMP
008738  3  C2 10                INDEX16
00873A  3  A4 3D                LDY     TEMPWORD1
00873C  3  A6 3B                LDX     TEMPWORD
00873E  3               RTC_BEEP1:
00873E  3  CA                   DEX
00873F  3  E0 00 00             CPX     #$00
008742  3  D0 10                BNE     :+
008744  3  A6 3B                LDX     TEMPWORD
008746  3  AD 65 87             LDA     RTC_BEEP_TEMP
008749  3  49 04                EOR     #mask_spk
00874B  3  8D 65 87             STA     RTC_BEEP_TEMP
00874E  3  29 F7                AND     #$F7
008750  3  8F 94 03 00          STA     f:RTCIO
008754  3               :
008754  3  88                   DEY
008755  3  C0 00 00             CPY     #$0000
008758  3  D0 E4                BNE     RTC_BEEP1
00875A  3               
00875A  3  E2 10                INDEX8
00875C  3  AD CC 86             LDA     RTCVALUE
00875F  3  8F 94 03 00          STA     f:RTCIO
008763  3  68                   PLA
008764  3  60                   RTS
008765  3               
008765  3               RTC_BEEP_TEMP:
008765  3  00                   .BYTE   00
008766  3               
008766  3               
008766  3               
008766  3               ;_______________________________________________________________
008766  3               ;
008766  3               ; RTC Internal Functions
008766  3               ;_______________________________________________________________
008766  3               RTC_CE_ENABLE:
008766  3  AD CC 86             LDA     RTCVALUE
008769  3  09 10                ORA     #mask_ce
00876B  3  8D CC 86             STA     RTCVALUE
00876E  3  8F 94 03 00          STA     f:RTCIO
008772  3  60                   RTS
008773  3               
008773  3               RTC_CE_DISABLE:
008773  3  AD CC 86             LDA     RTCVALUE
008776  3  29 EF                AND     #mask_ce^$ff
008778  3  8D CC 86             STA     RTCVALUE
00877B  3  8F 94 03 00          STA     f:RTCIO
00877F  3  60                   RTS
008780  3               
008780  3               ; function RTC_WR
008780  3               ; send value in A
008780  3               ; uses X
008780  3               RTC_WR:
008780  3  85 3D                STA     TEMPWORD1       ; save accumulator as it is the DATA
008782  3  A2 00                LDX     #$00            ; set X index counter of FOR loop
008784  3               RTC_WR1:
008784  3  A5 3D                LDA     TEMPWORD1
008786  3  29 01                AND     #$01
008788  3  C9 00                CMP     #$00            ; is LSB a 0 or 1?
00878A  3  F0 0C                BEQ     :+              ; if its a 0, do not set data.
00878C  3               ; LSB is a 1, handle it below
00878C  3  AD CC 86             LDA     RTCVALUE
00878F  3  09 80                ORA     #mask_data_in
008791  3  8F 94 03 00          STA     f:RTCIO
008795  3  20 FA 87             JSR     RTC_BIT_DELAY   ; let it settle a while
008798  3               :
008798  3  09 40                ORA     #mask_clk
00879A  3  8F 94 03 00          STA     f:RTCIO
00879E  3  20 FA 87             JSR     RTC_BIT_DELAY   ; let it settle a while
0087A1  3  AD CC 86             LDA     RTCVALUE
0087A4  3  8F 94 03 00          STA     f:RTCIO
0087A8  3  20 FA 87             JSR     RTC_BIT_DELAY   ; let it settle a while
0087AB  3               
0087AB  3  46 3D                LSR     TEMPWORD1       ; move next bit into LSB position for processing to RTC
0087AD  3  E8                   INX                     ; increment A in FOR loop (A=A+1)
0087AE  3  E0 08                CPX     #$08            ; is A < $08 ?
0087B0  3  D0 D2                BNE     RTC_WR1         ; No, do FOR loop again
0087B2  3  60                   RTS                     ; Yes, end function and return
0087B3  3               
0087B3  3               
0087B3  3               ; function RTC_RD
0087B3  3               ; get value into A
0087B3  3               ; uses X
0087B3  3               RTC_RD:
0087B3  3  AD CC 86             LDA     RTCVALUE
0087B6  3  09 20                ORA     #mask_wrt_en
0087B8  3  8D CC 86             STA     RTCVALUE
0087BB  3  8F 94 03 00          STA     f:RTCIO
0087BF  3  A9 00                LDA     #$00            ; set A=0 output of RTC_RD is passed in A
0087C1  3  85 3D                STA     TEMPWORD1
0087C3  3  A2 00                LDX     #$00            ; set X index counter of FOR loop
0087C5  3               RTC_RD1:
0087C5  3  AD CC 86             LDA     RTCVALUE
0087C8  3  09 40                ORA     #mask_clk
0087CA  3  8F 94 03 00          STA     f:RTCIO
0087CE  3  20 FA 87             JSR     RTC_BIT_DELAY   ; let it settle a while
0087D1  3  AF 94 03 00          LDA     f:RTCIO
0087D5  3  29 01                AND     #mask_data_out
0087D7  3  C9 00                CMP     #$00
0087D9  3  F0 06                BEQ     :+
0087DB  3  A5 3D                LDA     TEMPWORD1
0087DD  3  09 01                ORA     #1
0087DF  3  85 3D                STA     TEMPWORD1
0087E1  3               :
0087E1  3  AD CC 86             LDA     RTCVALUE
0087E4  3  29 DF                AND     #mask_wrt_en^$ff
0087E6  3  8D CC 86             STA     RTCVALUE
0087E9  3  8F 94 03 00          STA     f:RTCIO
0087ED  3  20 FA 87             JSR     RTC_BIT_DELAY   ; let it settle a while
0087F0  3  06 3D                ASL     TEMPWORD1       ; SHIFT
0087F2  3  E8                   INX                     ; increment FOR loop (A=A+1)
0087F3  3  E0 08                CPX     #$08            ; is A < $08 ?
0087F5  3  D0 CE                BNE     RTC_RD1         ; No, do FOR loop again
0087F7  3  A5 3D                LDA     TEMPWORD1
0087F9  3  60                   RTS                     ; Yes, end function and return.  Read RTC value is in A
0087FA  3               
0087FA  3               RTC_BIT_DELAY:                  ; purpose is to delay ~36 uS
0087FA  3               ; (6) JSR INTO
0087FA  3  48                   PHA                     ; 3
0087FB  3  A9 02                LDA     #$02            ; 2  (1 REP AT 1 MHZ 6 REPS AT 2MHZ)
0087FD  3  85 3B                STA     TEMPWORD        ; 3
0087FF  3               RTC_BIT_DELAY1:
0087FF  3  C6 3B                DEC     TEMPWORD        ;5
008801  3  D0 FC                BNE     RTC_BIT_DELAY1  ;3
008803  3               
008803  3  EA                   NOP                     ; 2
008804  3  EA                   NOP                     ; 2
008805  3  68                   PLA                     ; 4
008806  3  60                   RTS                     ; 6
008807  3               
008807  2               ;        .INCLUDE "dosdskyn.asm"
008807  2               ;        .INCLUDE "dosflp.asm"
008807  2               
008807  2               
008807  2               
008807  2               
008807  2               ;__DFT_CONSOLE___________________________________________________________________________________________________________________
008807  2               ;
008807  2               ;	      TRANSFER CONSOLE COMMAND TO DESIGNATED CONSOLE
008807  2               ;________________________________________________________________________________________________________________________________
008807  2               DFT_CONSOLE:
008807  2  8D 1A 88             STA     drvtmp
00880A  2  AD 12 07             LDA     CONSOLE
00880D  2  18                   CLC
00880E  2  65 32                ADC     farfunct
008810  2  85 32                STA     farfunct
008812  2  68                   PLA
008813  2  68                   PLA
008814  2  AD 1A 88             LDA     drvtmp
008817  2  4C 01 80             JMP     FUNCTION_DISPATCHER1
00881A  2               drvtmp:
00881A  2  00                   .BYTE   00
00881B  2               
00881B  2               drv_noop:
00881B  2  60                   RTS
00881C  2               
00881C  1               DRIVEREND:
00881C  1                       .END
