ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               .PC02
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	DOS/65 for the Duodyne 6502
000000r 1               ;
000000r 1               ;  DWERNER 5/03/2025 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;       It is assumed that Bank 0 is not usable due to IO and ROM starting at DF00-FFFF
000000r 1               ;       OS will run in Bank $82-$85
000000r 1               ;       Drivers will run in Bank $86-$87
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               
000000r 1               DOSSIZE         = OSEND-DOSBEGIN
000000r 1               DRIVERSIZE      = DRIVEREND-DRIVERBEGIN
000000r 1               LOADERSIZE      = LOADEREND-LOADERBEGIN
000000r 1               
000000r 1               OSSTART         = LOADEREND
000000r 1               DRIVERSTART     = LOADEREND+DOSSIZE
000000r 1               
000000r 1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	DOS/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp          = $0100         ; warm boot jump
000000r 2               pemjmp          = $0103         ; jump to pem
000000r 2               iostat          = $0106         ; i/o status
000000r 2               dflfcb          = $0107         ; default fcb
000000r 2               dflbuf          = $0128         ; default buffer
000000r 2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
000000r 2               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 2               hstbuf          = $0400         ; 0400-05ff host buffer
000000r 2               
000000r 2               ; Bank Registers
000000r 2               BANK00          = IO+$50
000000r 2               BANK40          = IO+$51
000000r 2               BANK80          = IO+$52
000000r 2               BANKC0          = IO+$53
000000r 2               OPTIONREGISTER  = IO+$51   ;   OPTION REG.
000000r 2               
000000r 2               DO_FARCALL      = $0200
000000r 2               BANKED_DRIVER_DISPATCHER        = $8800
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               DSKY_BUF        = $0600         ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN     = 8             ;
000000r 2               DSKY_HEXBUF     = $0608         ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN  = 4             ;
000000r 2               debsehd         = $0610         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               debcyll         = $0611         ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         = $0612         ; DEBLOCKED CYLINDER MSB
000000r 2               dskcfg          = $0617         ; 16 bytes disk configuration table
000000r 2               DSKUNIT         = $0628         ; seek disk number
000000r 2               slicetmp        = $0631         ; (word)
000000r 2               STACKA          = $0635
000000r 2               nmsstr          = $0636
000000r 2               FLRETRY         = $0637         ;
000000r 2               FLRETRY1        = $0638         ;
000000r 2               ST0             = $0639         ;
000000r 2               FLERR           = $063A         ;
000000r 2               FCMD            = $063B         ;
000000r 2               PPIDEINDEX      = $063C
000000r 2               DSKY_X_STORAGE  = $063D
000000r 2               DSKY_Y_STORAGE  = $063E
000000r 2               DSKY_TEMP_VAL   = $063F
000000r 2               DSKY_PPIX_VAL   = $0640
000000r 2               FLOPPY_DETCT    = $0641
000000r 2               DSKY_PRESENT    = $0642
000000r 2               Cdebsehd        = $0643         ; DEBLOCKED SECTOR AND HEAD (HS)  (IN CACHE)
000000r 2               Cdebcyll        = $0644         ; DEBLOCKED CYLINDER LSB (IN CACHE)
000000r 2               Cdebcylm        = $0645         ; DEBLOCKED CYLINDER MSB (IN CACHE)
000000r 2               CacUnit         = $0646         ; UNIT (IN CACHE)
000000r 2               CONSOLE         = $060F         ; CONSOLE DEVICE
000000r 2               tea             = $800          ;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               addinp          = $02           ;initialized to a,y
000000r 2               bufadd          = $04           ;buffer address
000000r 2               alcpnt          = $06           ;allocation map pointer
000000r 2               chkpnt          = $08           ;checksum map pointer
000000r 2               numvar          = $50           ;RESERVED ZERO PAGE SPACE
000000r 2               
000000r 2               
000000r 2               msgptr          = chkpnt+2      ;message pointer
000000r 2               movptr          = msgptr        ;and move pointer
000000r 2               dcbloc          = msgptr+2      ;pointer to dcb
000000r 2               
000000r 2               dcbpc           = $2C           ;pointer to DCB table
000000r 2               dskcfpc         = $2E           ;pointer to disk configuration table
000000r 2               cmdlnp          = $30           ;pointer to command line buffer
000000r 2               farfunct        = $32           ; function to call in driver area
000000r 2               farpointer      = $33           ;
000000r 2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 2               TEMPWORD        = $3B           ;
000000r 2               TEMPWORD1       = $3D           ;
000000r 2               TEMPWORD2       = $3F           ;
000000r 2               STRPTR          = $41           ;
000000r 2               DSKYMODE        = $43           ; DSKY MODE (0=NONE, 1=DSKY, 2=DSKY NG
000000r 2               sektrk          = $44           ; seek track number
000000r 2               seksec          = $46           ; seek sector number
000000r 2               sekdsk          = $48           ; seek disk number
000000r 2               currentDrive    = $49
000000r 2               pcf_buffer      = $4A           ; only used in PCF driver, free for use outside as temp (word)
000000r 2               pcf_address     = $4C           ; only used in PCF driver, free for use outside as temp (byte)
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST            = $EC           ;pointer for OutMsg
000000r 2               SRC             = $EE           ;pointer for OutMsg
000000r 2               OUTMSG_W        = $F0           ;pointer for OutMsg
000000r 2               dmaadr          = $f4           ;pointer for r/w
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall           = 0             ;write to allocated
000000r 2               wrdir           = 1             ;write to directory
000000r 2               wrual           = 2             ;write to unallocated
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf              = $a            ;linefeeed
000000r 2               cr              = $d            ;return
000000r 2               eof             = $1a           ;end of file
000000r 2               null            = 0             ;null
000000r 2               ctlc            = 3             ;abort
000000r 2               ctle            = 5             ;physical cr lf
000000r 2               ctli            = 9             ;tab character
000000r 2               ctlp            = $10           ;toggle printer
000000r 2               ctlr            = $12           ;repeat line
000000r 2               ctls            = $13           ;freeze
000000r 2               ctlx            = $18           ;cancel
000000r 2               semico          = $3b           ;semicolon
000000r 2               delete          = $08           ;delete character
000000r 2               numcmd          = 36            ;number commands
000000r 2               DEFDRV          = 0             ; SET TO DEFAULT DRIVE LETTER
000000r 2               
000000r 2               
000000r 2                       .IFDEF RBC6X0X
000000r 2                       .DEFINE COMSUFFIX "COM"
000000r 2                       .ENDIF
000000r 2               
000000r 2                       .IFDEF NHYODYNE
000000r 2                       .DEFINE COMSUFFIX "CO6"
000000r 2                       .ENDIF
000000r 2               
000000r 2                       .IFDEF DUODYNE
000000r 2                       .DEFINE COMSUFFIX "CO6"
000000r 2                       .ENDIF
000000r 2               
000000r 2                       .IFDEF DUODYNE02
000000r 2                       .DEFINE COMSUFFIX "CO6"
000000r 2                       .ENDIF
000000r 2               
000000r 2               DEBUG           = 0
000000r 2               
000000r 1                       .SEGMENT "LOWCODE"
000000r 1               
000000r 1               LOADERBEGIN:
000000r 1  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
000001r 1  18                   CLC                     ;
000002r 1               
000002r 1               ; RELOCATE FROM CPM RAM
000002r 1  A9 00                LDA     #$00
000004r 1  85 3B                STA     TEMPWORD
000006r 1  A9 84                LDA     #$84
000008r 1  85 3C                STA     TEMPWORD+1
00000Ar 1               
00000Ar 1  A9 00                LDA     #00
00000Cr 1  85 3D                STA     TEMPWORD1
00000Er 1  A9 04                LDA     #$04
000010r 1  85 3E                STA     TEMPWORD1+1
000012r 1  A0 00                LDY     #$00
000014r 1               LOOP:
000014r 1  B1 3B                LDA     (TEMPWORD),Y    ;MOVE IT
000016r 1  91 3D                STA     (TEMPWORD1),Y   ;MOVE IT
000018r 1  C8                   INY
000019r 1  D0 F9                BNE     LOOP
00001Br 1               
00001Br 1  E6 3C                INC     TEMPWORD+1
00001Dr 1  E6 3E                INC     TEMPWORD1+1
00001Fr 1  A5 3E                LDA     TEMPWORD1+1
000021r 1  C9 7F                CMP     #$7F
000023r 1  D0 EF                BNE     LOOP
000025r 1               
000025r 1  4C rr rr             JMP     RELOC1
000028r 1               RELOC1:
000028r 1               
000028r 1               ;* Setup Memory Banks  (page out ROM)
000028r 1  A9 83                LDA     #$83
00002Ar 1  8D 53 03             STA     BANKC0
00002Dr 1               
00002Dr 1               ; begin by copying DOS/65 to Code Bank
00002Dr 1  A9 rr                LDA     #<OSSTART
00002Fr 1  85 3B                STA     TEMPWORD
000031r 1  A9 rr                LDA     #>OSSTART
000033r 1  85 3C                STA     TEMPWORD+1
000035r 1               
000035r 1  A9 00                LDA     #00
000037r 1  85 3D                STA     TEMPWORD1
000039r 1  A9 D0                LDA     #$D0
00003Br 1  85 3E                STA     TEMPWORD1+1
00003Dr 1  A0 00                LDY     #$00
00003Fr 1               
00003Fr 1               LOOP1:
00003Fr 1  B1 3B                LDA     (TEMPWORD),Y    ;MOVE IT
000041r 1  91 3D                STA     (TEMPWORD1),Y   ;MOVE IT
000043r 1  C8                   INY
000044r 1  D0 F9                BNE     LOOP1
000046r 1               
000046r 1  E6 3C                INC     TEMPWORD+1
000048r 1  E6 3E                INC     TEMPWORD1+1
00004Ar 1  A5 3E                LDA     TEMPWORD1+1
00004Cr 1  C9 FF                CMP     #$FF
00004Er 1  D0 EF                BNE     LOOP1
000050r 1               
000050r 1               ; copy Drivers to proper bank
000050r 1  A9 85                LDA     #$85
000052r 1  8D 52 03             STA     BANK80
000055r 1  A9 86                LDA     #$86
000057r 1  8D 53 03             STA     BANKC0
00005Ar 1               
00005Ar 1               
00005Ar 1  A9 rr                LDA     #<DRIVERSTART
00005Cr 1  85 3B                STA     TEMPWORD
00005Er 1  A9 rr                LDA     #>DRIVERSTART
000060r 1  85 3C                STA     TEMPWORD+1
000062r 1               
000062r 1  A9 00                LDA     #00
000064r 1  85 3D                STA     TEMPWORD1
000066r 1  A9 88                LDA     #$88
000068r 1  85 3E                STA     TEMPWORD1+1
00006Ar 1               
00006Ar 1  A0 00                LDY     #$00
00006Cr 1               LOOP2:
00006Cr 1  B1 3B                LDA     (TEMPWORD),Y    ;MOVE IT
00006Er 1  91 3D                STA     (TEMPWORD1),Y   ;MOVE IT
000070r 1  C8                   INY
000071r 1  D0 F9                BNE     LOOP2
000073r 1               
000073r 1  E6 3C                INC     TEMPWORD+1
000075r 1  E6 3E                INC     TEMPWORD1+1
000077r 1  A5 3C                LDA     TEMPWORD+1
000079r 1  C9 80                CMP     #$80
00007Br 1  D0 EF                BNE     LOOP2
00007Dr 1               
00007Dr 1               
00007Dr 1               
00007Dr 1               ;* Setup Memory Banks  (page out ROM)
00007Dr 1  A9 80                LDA     #$80
00007Fr 1  8D 50 03             STA     BANK00
000082r 1  A9 81                LDA     #$81
000084r 1  8D 51 03             STA     BANK40
000087r 1  A9 82                LDA     #$82
000089r 1  8D 52 03             STA     BANK80
00008Cr 1  A9 83                LDA     #$83
00008Er 1  8D 53 03             STA     BANKC0
000091r 1               ; Boot
000091r 1  A9 2A                LDA     #'*'
000093r 1  8D 58 03             STA     UART0
000096r 1  A9 04                LDA     #04
000098r 1  8D 0F 06             STA     CONSOLE
00009Br 1               
00009Br 1  20 rr rr             JSR     PAGER_INIT
00009Er 1  4C 00 D0             JMP     $D000
0000A1r 1               
0000A1r 1                       .INCLUDE "dospager.asm"
0000A1r 2               ;__pager_________________________________________________________________________________________________________________________
0000A1r 2               ;
0000A1r 2               ; 	Nhyodyne Memory page management code
0000A1r 2               ;
0000A1r 2               ;	Entry points:
0000A1r 2               ;		PAGER_INIT          - called during OS init
0000A1r 2               ;________________________________________________________________________________________________________________________________
0000A1r 2               ;
0000A1r 2               
0000A1r 2               ;__PAGER_INIT___________________________________________________________________________________________
0000A1r 2               ;
0000A1r 2               ;  INIT -- Copy code into $0200-$02FF for controling banking
0000A1r 2               ;____________________________________________________________________________________________________
0000A1r 2               PAGER_INIT:
0000A1r 2  A2 00                LDX     #$00
0000A3r 2               :
0000A3r 2  BD rr rr             LDA     md_pagecode,X
0000A6r 2  9D 00 02             STA     MD_PAGERA,X
0000A9r 2  E8                   INX
0000AAr 2  E0 00                CPX     #$00
0000ACr 2  D0 F5                BNE     :-
0000AEr 2  60                   RTS
0000AFr 2               
0000AFr 2               md_pagecode:
0000AFr 2  48                   PHA
0000B0r 2  A9 85                LDA     #$85
0000B2r 2  8D 52 03             STA     BANK80
0000B5r 2  A9 86                LDA     #$86
0000B7r 2  8D 53 03             STA     BANKC0
0000BAr 2  EA                   NOP
0000BBr 2  EA                   NOP
0000BCr 2  68                   PLA
0000BDr 2  20 00 88             JSR     BANKED_DRIVER_DISPATCHER
0000C0r 2  48                   PHA
0000C1r 2  A9 82                LDA     #$82
0000C3r 2  8D 52 03             STA     BANK80
0000C6r 2  A9 83                LDA     #$83
0000C8r 2  8D 53 03             STA     BANKC0
0000CBr 2               
0000CBr 2  68                   PLA
0000CCr 2  60                   RTS
0000CDr 2               
0000CDr 1               
0000CDr 1               ;       Page Align
0000CDr 1  xx xx xx xx          .ALIGN  256
0000D1r 1  xx xx xx xx  
0000D5r 1  xx xx xx xx  
000100r 1               LOADEREND:
000100r 1               
000100r 1               
000100r 1               OSBEGIN:
000100r 1                       .SEGMENT "OS"
000000r 1                       .INCLUDE "../dos65_os/ccm215.asm"
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	DOS/65 console command module (ccm)
000000r 2               ;
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;ccm unique definitions
000000r 2               nbuilt          = 7             ;number built in commands
000000r 2               ;main program
000000r 2               ; warm boot vector
000000r 2  4C rr rr             JMP     boot
000003r 2               ccm:
000003r 2  D8                   CLD                     ;set binary mode
000004r 2  48                   PHA                     ;save drive number
000005r 2  20 rr rr             JSR     rstdsk          ;initialize system
000008r 2  68                   PLA                     ;restore drive num
000009r 2  20 rr rr             JSR     slctds          ;select drive
00000Cr 2  AD rr rr             LDA     sysdef+6        ;get line length
00000Fr 2  4A                   LSR     a               ;divide
000010r 2  4A                   LSR     a               ;by
000011r 2  4A                   LSR     a               ;16
000012r 2  4A                   LSR     a               ;for dir
000013r 2  8D rr rr             STA     sixten          ;and save
000016r 2  AD rr rr             LDA     cnslng          ;get buffer length
000019r 2  D0 37                BNE     mrecmd          ;if more handle it
00001Br 2               ccmlpe:
00001Br 2                       .IFDEF  DUODYNE
00001Br 2                       CLD                     ; VERIFY DECIMAL MODE IS OFF
00001Br 2                       CLC                     ;
00001Br 2                       XCE                     ; SET NATIVE MODE
00001Br 2                       ACCUMULATORINDEX16
00001Br 2                       LDA     #STACK          ; get the stack address
00001Br 2                       TCS                     ; and set the stack to it
00001Br 2                       ACCUMULATORINDEX8
00001Br 2                       .ELSE
00001Br 2  A2 FF                LDX     #$ff            ;set
00001Dr 2  9A                   TXS                     ;stack
00001Er 2                       .ENDIF
00001Er 2  D8                   CLD                     ;set binary mode
00001Fr 2               ;        LDA     #17             ; SEND A XON
00001Fr 2               ;        JSR     chrout          ; ----------
00001Fr 2  20 rr rr             JSR     hdrout          ;send header
000022r 2  A9 3E                LDA     #'>'            ;then print
000024r 2  20 rr rr             JSR     chrout          ;prompt
000027r 2  AD rr rr             LDA     cnsbvc          ;point to start
00002Ar 2  AC rr rr             LDY     cnsbvc+1        ;of buffer
00002Dr 2  20 rr rr             JSR     rdebuf          ;do buffer read
000030r 2  A0 00                LDY     #0              ;clear index
000032r 2  AE rr rr             LDX     cnslng          ;get length
000035r 2  F0 E4                BEQ     ccmlpe          ;loop if empty
000037r 2               lwrupr:
000037r 2  B9 rr rr             LDA     cnstxt,y        ;else get char
00003Ar 2  C9 61                CMP     #'a'            ;if less than a
00003Cr 2  90 09                BCC     nxtchg          ;skip convert
00003Er 2  C9 7B                CMP     #'z'+1          ;if over z
000040r 2  B0 05                BCS     nxtchg          ;skip convert
000042r 2  29 5F                AND     #%01011111      ;else convert
000044r 2  99 rr rr             STA     cnstxt,y        ;put back in buffer
000047r 2               nxtchg:
000047r 2  C8                   INY                     ;bump index
000048r 2  CA                   DEX                     ;count down
000049r 2  D0 EC                BNE     lwrupr          ;loop if more
00004Br 2  8A                   TXA                     ;set a to zero
00004Cr 2  99 rr rr             STA     cnstxt,y        ;insert stopper
00004Fr 2  8D rr rr             STA     cnbfpt          ;initialize pointer
000052r 2               mrecmd:
000052r 2  20 rr rr             JSR     stdflb          ;set default buffer
000055r 2  20 rr rr             JSR     intdsk          ;get drive number
000058r 2  8D rr rr             STA     dfldsk          ;store as default
00005Br 2  20 rr rr             JSR     prslin          ;parse command
00005Er 2  D0 64                BNE     cmderr          ;error if afn
000060r 2  AD rr rr             LDA     tmpdsk          ;get temporary
000063r 2  F0 04                BEQ     nodrch          ;if zero ok
000065r 2  A9 15                LDA     #nbuilt*3       ;else set and
000067r 2  D0 2E                BNE     dotrns          ;do transient
000069r 2               nodrch:
000069r 2  A9 00                LDA     #0              ;clear
00006Br 2  AA                   TAX                     ;table index
00006Cr 2  8D rr rr             STA     ccmcount        ;and count
00006Fr 2               tsnxfn:
00006Fr 2  A0 01                LDY     #1              ;set fcb index
000071r 2               tsnxch:
000071r 2  BD rr rr             LDA     fnctbl,x        ;get table entry
000074r 2  F0 1A                BEQ     gotcmd          ;if zero got it
000076r 2  D9 rr rr             CMP     fcbone,y        ;else test
000079r 2  D0 04                BNE     nocmpr          ;no good if not =
00007Br 2  E8                   INX                     ;bump
00007Cr 2  C8                   INY                     ;pointers
00007Dr 2  D0 F2                BNE     tsnxch          ;and loop
00007Fr 2               nocmpr:
00007Fr 2  E8                   INX                     ;go to end
000080r 2  BD rr rr             LDA     fnctbl,x        ;of table
000083r 2  D0 FA                BNE     nocmpr          ;entry
000085r 2  E8                   INX                     ;point to next
000086r 2  EE rr rr             INC     ccmcount        ;bump count
000089r 2  AD rr rr             LDA     ccmcount        ;and if not
00008Cr 2  C9 07                CMP     #nbuilt         ;limit then
00008Er 2  D0 DF                BNE     tsnxfn          ;try next
000090r 2               gotcmd:
000090r 2  AD rr rr             LDA     ccmcount        ;get count
000093r 2  0A                   ASL     a               ;multiply by two
000094r 2  6D rr rr             ADC     ccmcount        ;then add for x3
000097r 2               dotrns:
000097r 2  AA                   TAX                     ;use as index
000098r 2  E8                   INX                     ;bump to pass jmp
000099r 2  BD rr rr             LDA     xqfntb,x        ;to get
00009Cr 2  BC rr rr             LDY     xqfntb+1,x      ;entry address
00009Fr 2  8D rr rr             STA     vector          ;then set
0000A2r 2  8C rr rr             STY     vector+1        ;vector
0000A5r 2  AD rr rr             LDA     extcvc+1        ;save
0000A8r 2  48                   PHA                     ;return
0000A9r 2  AD rr rr             LDA     extcvc          ;address
0000ACr 2  48                   PHA                     ;on stack
0000ADr 2                       .IFDEF  DUODYNE
0000ADr 2                       LDX     #$00
0000ADr 2                       JMP     (vector,x)      ;execute
0000ADr 2                       .ELSE
0000ADr 2  6C rr rr             JMP     (vector)        ;execute
0000B0r 2                       .ENDIF
0000B0r 2               extcmd:
0000B0r 2  20 rr rr             JSR     rstddr          ;restore default
0000B3r 2               extwod:
0000B3r 2  20 rr rr             JSR     prslin          ;parse more
0000B6r 2  AD rr rr             LDA     fcbone+1        ;if first
0000B9r 2  38                   SEC                     ;character
0000BAr 2  E9 20                SBC     #' '            ;not a space
0000BCr 2  0D rr rr             ORA     tmpdsk          ;or if temporary
0000BFr 2  D0 03                BNE     cmderr          ;then an error
0000C1r 2  4C rr rr             JMP     ccmlpe          ;else loop
0000C4r 2               ;command error syntax handler
0000C4r 2               cmderr:
0000C4r 2  20 rr rr             JSR     ccrlf           ;do a cr lf
0000C7r 2  AC rr rr             LDY     curpnt          ;get command pointer
0000CAr 2               cmerlp:
0000CAr 2  B9 rr rr             LDA     cnstxt,y        ;get char
0000CDr 2  F0 0A                BEQ     cmerex          ;if null then done
0000CFr 2  C9 20                CMP     #' '            ;if space
0000D1r 2  F0 06                BEQ     cmerex          ;then done
0000D3r 2  20 rr rr             JSR     cotsxy          ;output with save
0000D6r 2  C8                   INY                     ;point to next
0000D7r 2  D0 F1                BNE     cmerlp          ;and loop
0000D9r 2               cmerex:
0000D9r 2  A9 3F                LDA     #'?'            ;send a
0000DBr 2  20 rr rr             JSR     chrout          ;question mark
0000DEr 2  4C rr rr             JMP     ccmlpe          ;and start over
0000E1r 2               ;execute dir command
0000E1r 2               ; dir <afn>
0000E1r 2               dir:
0000E1r 2  20 rr rr             JSR     prslin          ;find object file
0000E4r 2  20 rr rr             JSR     clrslt          ;clear auto and select
0000E7r 2  A9 20                LDA     #' '            ;if name
0000E9r 2  CD rr rr             CMP     fcbone+1        ;and
0000ECr 2  D0 0F                BNE     findfr          ;type are
0000EEr 2  CD rr rr             CMP     fcbone+9        ;not empty
0000F1r 2  D0 0A                BNE     findfr          ;then use it
0000F3r 2  A9 3F                LDA     #'?'            ;else
0000F5r 2  A0 0B                LDY     #11             ;fill
0000F7r 2               fillqu:
0000F7r 2  99 rr rr             STA     fcbone,y        ;fcb
0000FAr 2  88                   DEY                     ;with
0000FBr 2  D0 FA                BNE     fillqu          ;question marks
0000FDr 2               findfr:
0000FDr 2  20 rr rr             JSR     srchf1          ;search for first match
000100r 2  30 58                BMI     notfnd          ;error if none
000102r 2               fnddir:
000102r 2  AD rr rr             LDA     sixten          ;set across
000105r 2  8D rr rr             STA     across          ;to four
000108r 2  20 rr rr             JSR     ccrlf           ;do a crlf
00010Br 2               
00010Br 2               dirl:
00010Br 2  20 rr rr             JSR     hdr             ;do header
00010Er 2  A9 3A                LDA     #':'            ;then a
000110r 2  20 rr rr             JSR     chrout          ;colon
000113r 2  AD rr rr             LDA     diradd          ;get number
000116r 2  0A                   ASL     a               ;and
000117r 2  0A                   ASL     a               ;multiply
000118r 2  0A                   ASL     a               ;by
000119r 2  0A                   ASL     a               ;thirty two
00011Ar 2  0A                   ASL     a               ;then
00011Br 2  29 60                AND     #%01100000      ;mask out insignificant
00011Dr 2  A8                   TAY                     ;make a pointer
00011Er 2  C8                   INY                     ;and bump
00011Fr 2  A2 01                LDX     #1              ;set counter
000121r 2               nmelpe:
000121r 2  B9 28 01             LDA     dflbuf,y        ;get name
000124r 2  29 7F                AND     #$7F            ;mask out read only bit
000126r 2  20 rr rr             JSR     cotsxy          ;else send to console
000129r 2               noname:
000129r 2  C8                   INY                     ;bump index
00012Ar 2  E8                   INX                     ;and count
00012Br 2  E0 0C                CPX     #12             ;if count is 12
00012Dr 2  F0 0C                BEQ     endnme          ;then done
00012Fr 2  E0 09                CPX     #9              ;or if not 9
000131r 2  D0 EE                BNE     nmelpe          ;then loop
000133r 2  A9 2E                LDA     #'.'            ;else send
000135r 2  20 rr rr             JSR     cotsxy          ;a period
000138r 2  4C rr rr             JMP     nmelpe          ;and loop
00013Br 2               endnme:
00013Br 2  20 rr rr             JSR     chkcst          ;check console status
00013Er 2  D0 19                BNE     extdir          ;if key down quit
000140r 2  20 rr rr             JSR     setone          ;else point to fcb
000143r 2  20 rr rr             JSR     srchnx          ;else search for next
000146r 2  8D rr rr             STA     diradd          ;save number
000149r 2  30 0E                BMI     extdir          ;quit if not found
00014Br 2  CE rr rr             DEC     across          ;drop count
00014Er 2  F0 B2                BEQ     fnddir          ;new line if 0
000150r 2  20 rr rr             JSR     spcout          ;send
000153r 2  20 rr rr             JSR     spcout          ;two spaces
000156r 2  4C rr rr             JMP     dirl            ;and stay
000159r 2               extdir:
000159r 2  60                   RTS                     ;else done
00015Ar 2               ;not found error handler
00015Ar 2               notfnd:
00015Ar 2  A0 34                LDY     #ntfnms         ;point to message
00015Cr 2  4C rr rr             JMP     sndmsg          ;send and exit
00015Fr 2               ;execute ren command
00015Fr 2               ; ren <ufn> <ufn>
00015Fr 2               ;where first ufn is from name and second is to name
00015Fr 2               ren:
00015Fr 2  20 rr rr             JSR     prslin          ;get old name
000162r 2  D0 57                BNE     renerr          ;error if afn
000164r 2  20 rr rr             JSR     tmpold          ;save drive
000167r 2  20 rr rr             JSR     clrslt          ;clear auto and select
00016Ar 2  20 rr rr             JSR     srchf1          ;if file does not exist
00016Dr 2  30 4F                BMI     fntfnd          ;then an error
00016Fr 2  20 rr rr             JSR     frssec          ;move name to second half
000172r 2  AC rr rr             LDY     cnbfpt          ;get pointer
000175r 2  B9 rr rr             LDA     cnstxt,y        ;and then char
000178r 2  C9 20                CMP     #' '            ;if not a space
00017Ar 2  D0 3C                BNE     rensyn          ;then error
00017Cr 2  20 rr rr             JSR     prslin          ;get new name
00017Fr 2  D0 37                BNE     rensyn          ;error if afn
000181r 2  AD rr rr             LDA     tmpdsk          ;get new drive
000184r 2  F0 12                BEQ     nonwdr          ;if zero ok
000186r 2  CD rr rr             CMP     oldtmp          ;compare to old
000189r 2  F0 0D                BEQ     nonwdr          ;ok if same
00018Br 2  38                   SEC                     ;drop for default check
00018Cr 2  E9 01                SBC     #1
00018Er 2  CD rr rr             CMP     dfldsk          ;if not default
000191r 2  D0 25                BNE     rensyn          ;is error
000193r 2  AD rr rr             LDA     oldtmp          ;and then if from not
000196r 2  D0 20                BNE     rensyn          ;default is error
000198r 2               nonwdr:
000198r 2  AD rr rr             LDA     oldtmp          ;else get old
00019Br 2  8D rr rr             STA     tmpdsk          ;and save
00019Er 2  A9 00                LDA     #0              ;clear
0001A0r 2  8D rr rr             STA     fcbone+16
0001A3r 2  20 rr rr             JSR     clrslt          ;reselect
0001A6r 2  20 rr rr             JSR     srchf1          ;search for old
0001A9r 2  10 09                BPL     filexs          ;error if found
0001ABr 2  20 rr rr             JSR     frssec          ;swap names
0001AEr 2  20 rr rr             JSR     setone          ;point to fcb
0001B1r 2  4C rr rr             JMP     renmfl          ;and do it
0001B4r 2               ;ren file exists error handler
0001B4r 2               filexs:
0001B4r 2  A0 3E                LDY     #flexms         ;point to
0001B6r 2  D0 08                BNE     remsg           ;and send
0001B8r 2               ;ren syntax error handler
0001B8r 2               rensyn:
0001B8r 2  20 rr rr             JSR     rstddr          ;restore default
0001BBr 2               renerr:
0001BBr 2  4C rr rr             JMP     cmderr          ;do error
0001BEr 2               ;ren source file not found error handler
0001BEr 2               fntfnd:
0001BEr 2  A0 34                LDY     #ntfnms         ;point to
0001C0r 2               remsg:
0001C0r 2  4C rr rr             JMP     sndmsg          ;and send
0001C3r 2               ;execute save command
0001C3r 2               ; save <length> <drive:>ufn (<address>)
0001C3r 2               save:
0001C3r 2  A9 00                LDA     #<tea           ;set start address to tea start
0001C5r 2  A0 08                LDY     #>tea
0001C7r 2  8D rr rr             STA     sadr
0001CAr 2  8C rr rr             STY     sadr+1
0001CDr 2  20 rr rr             JSR     bldnum          ;calculate length
0001D0r 2  D0 7A                BNE     saverr          ;error if > 255 pages
0001D2r 2  8D rr rr             STA     length          ;else save low
0001D5r 2  0D rr rr             ORA     length          ;test for zero length
0001D8r 2  F0 72                BEQ     saverr          ;error if is
0001DAr 2  20 rr rr             JSR     prslin          ;get file name
0001DDr 2  D0 6D                BNE     saverr          ;error if afn
0001DFr 2  20 rr rr             JSR     frssec          ;move name to second half
0001E2r 2  20 rr rr             JSR     tmpold          ;save drive
0001E5r 2  20 rr rr             JSR     bldnum          ;it is so find value
0001E8r 2  AE rr rr             LDX     fcbone+1        ;see if there
0001EBr 2  E0 20                CPX     #' '
0001EDr 2  F0 0A                BEQ     nosadr          ;it is not
0001EFr 2  8D rr rr             STA     sadr            ;and set address
0001F2r 2  8C rr rr             STY     sadr+1
0001F5r 2  C0 02                CPY     #2              ;make sure is high enough
0001F7r 2  90 53                BCC     saverr          ;error if not
0001F9r 2               nosadr:
0001F9r 2  20 rr rr             JSR     secfrs          ;move name back
0001FCr 2  20 rr rr             JSR     clrslt          ;clear auto and select
0001FFr 2  20 rr rr             JSR     dlt1            ;delete
000202r 2  20 rr rr             JSR     setone          ;then create
000205r 2  20 rr rr             JSR     cratfl          ;new file
000208r 2  30 45                BMI     noroom          ;say no room if error
00020Ar 2  20 rr rr             JSR     open1           ;open file
00020Dr 2  30 44                BMI     noopen          ;if error
00020Fr 2  18                   CLC                     ;now find end page
000210r 2  AD rr rr             LDA     sadr+1
000213r 2  6D rr rr             ADC     length
000216r 2  8D rr rr             STA     length
000219r 2  AD rr rr             LDA     sadr            ;get start address
00021Cr 2  AC rr rr             LDY     sadr+1
00021Fr 2               wrtmre:
00021Fr 2  8D rr rr             STA     dskbuf          ;set
000222r 2  8C rr rr             STY     dskbuf+1        ;buffer
000225r 2  20 rr rr             JSR     mv128           ;move data to buffer
000228r 2  20 rr rr             JSR     setone          ;point to fcb
00022Br 2  20 rr rr             JSR     wrrcrd          ;write record
00022Er 2  D0 27                BNE     wrterr          ;exit if error
000230r 2  18                   CLC                     ;else
000231r 2  AD rr rr             LDA     dskbuf          ;get old
000234r 2  AC rr rr             LDY     dskbuf+1        ;buffer
000237r 2  69 80                ADC     #128            ;add 128
000239r 2  90 03                BCC     donotc          ;if carry
00023Br 2  C8                   INY                     ;bump upper
00023Cr 2  F0 05                BEQ     clssav          ;done if page zero
00023Er 2               donotc:
00023Er 2  CC rr rr             CPY     length          ;loop if upper
000241r 2  D0 DC                BNE     wrtmre          ;not at limit
000243r 2               clssav:
000243r 2  20 rr rr             JSR     setone          ;else point to
000246r 2  20 rr rr             JSR     clsefl          ;and close file
000249r 2  30 10                BMI     cantcl          ;say so if error
00024Br 2               extera:
00024Br 2  60                   RTS
00024Cr 2               ;save error handler
00024Cr 2               saverr:
00024Cr 2  4C rr rr             JMP     cmderr          ;do error
00024Fr 2               ;save no room error handler
00024Fr 2               noroom:
00024Fr 2  A0 01                LDY     #nospms         ;point to
000251r 2  D0 0A                BNE     semsg           ;and send
000253r 2               ;save can not open error handler
000253r 2               noopen:
000253r 2  A0 55                LDY     #cnnoms         ;point to
000255r 2  D0 06                BNE     semsg           ;and send
000257r 2               ;save write error handler
000257r 2               wrterr:
000257r 2  A0 62                LDY     #wrerms         ;point
000259r 2  D0 02                BNE     semsg           ;to and send
00025Br 2               ;save can not close error
00025Br 2               cantcl:
00025Br 2  A0 0A                LDY     #ntclms         ;point to
00025Dr 2               semsg:
00025Dr 2  4C rr rr             JMP     sndmsg          ;and send
000260r 2               ;execute era command
000260r 2               ; era <afn>
000260r 2               era:
000260r 2  20 rr rr             JSR     prslin          ;get file name
000263r 2  C9 0B                CMP     #11             ;if not all ?
000265r 2  D0 13                BNE     nteral          ;then skip verify
000267r 2  A0 18                LDY     #alflms         ;else point to
000269r 2  20 rr rr             JSR     sndmsg          ;and send all files
00026Cr 2  20 rr rr             JSR     cnsrde          ;get an input
00026Fr 2  48                   PHA                     ;and save
000270r 2  20 rr rr             JSR     ccrlf           ;do a cr lf
000273r 2  68                   PLA                     ;restore char
000274r 2  29 5F                AND     #$5f            ;convert to upper case
000276r 2  C9 59                CMP     #'Y'            ;if not y
000278r 2  D0 D1                BNE     extera          ;then quit
00027Ar 2               nteral:
00027Ar 2  20 rr rr             JSR     clrslt          ;clear auto and select
00027Dr 2  4C rr rr             JMP     dlt1            ;delete first
000280r 2               ;execute type command
000280r 2               ; type d:ufn
000280r 2               type:
000280r 2  20 rr rr             JSR     prslin          ;get file
000283r 2  D0 30                BNE     typafn          ;error if afn
000285r 2  20 rr rr             JSR     casdo1          ;clear - select - open file 1
000288r 2  30 32                BMI     notype          ;error if not found
00028Ar 2  20 rr rr             JSR     ccrlf           ;else do cr lf
00028Dr 2               typmre:
00028Dr 2  20 rr rr             JSR     read1           ;read record
000290r 2  F0 04                BEQ     okread          ;if ok continue
000292r 2  10 20                BPL     exttyp          ;exit if just end
000294r 2  30 22                BMI     typerr          ;else error
000296r 2               okread:
000296r 2  A2 00                LDX     #0              ;clear index
000298r 2               typlpe:
000298r 2  BD 28 01             LDA     dflbuf,x        ;get char
00029Br 2  C9 1A                CMP     #eof            ;if eof
00029Dr 2  F0 15                BEQ     exttyp          ;then exit
00029Fr 2  20 rr rr             JSR     cotsxy          ;else send
0002A2r 2  20 rr rr             JSR     chkcst          ;if key down
0002A5r 2  D0 08                BNE     exttok          ;then exit
0002A7r 2  AE rr rr             LDX     savx            ;else get index
0002AAr 2  E8                   INX                     ;bump it
0002ABr 2  10 EB                BPL     typlpe          ;and loop if < 128
0002ADr 2  30 DE                BMI     typmre          ;else read more
0002AFr 2               exttok:
0002AFr 2  A2 06                LDX     #6              ;clear console
0002B1r 2  20 03 01             JSR     pemjmp          ;with no echo
0002B4r 2               exttyp:
0002B4r 2  60                   RTS
0002B5r 2               ;type syntax error handler
0002B5r 2               typafn:
0002B5r 2  4C rr rr             JMP     cmderr          ;error return
0002B8r 2               ;type read error handler
0002B8r 2               typerr:
0002B8r 2  A0 29                LDY     #rderms         ;point to
0002BAr 2  D0 02                BNE     temsg           ;and send
0002BCr 2               ;type not found error handler
0002BCr 2               notype:
0002BCr 2  A0 34                LDY     #ntfnms         ;point to
0002BEr 2               temsg:
0002BEr 2  4C rr rr             JMP     sndmsg          ;and send
0002C1r 2               ;execute load command
0002C1r 2               ; load <ufn> (<address>)
0002C1r 2               load:
0002C1r 2  20 rr rr             JSR     setddb          ;set load start to tea start
0002C4r 2  20 rr rr             JSR     prslin          ;build fcb
0002C7r 2  D0 EC                BNE     typafn          ;error if afn
0002C9r 2  20 rr rr             JSR     frssec          ;save in second half
0002CCr 2  20 rr rr             JSR     tmpold          ;save file
0002CFr 2  20 rr rr             JSR     bldnum          ;find start address
0002D2r 2  AE rr rr             LDX     fcbone+1        ;see if number
0002D5r 2  E0 20                CPX     #' '
0002D7r 2  F0 03                BEQ     usedfl          ;if none use default
0002D9r 2  20 rr rr             JSR     setdb           ;and set
0002DCr 2               usedfl:
0002DCr 2  20 rr rr             JSR     secfrs          ;move name back
0002DFr 2  20 rr rr             JSR     casdo1          ;clear - select - open file 1
0002E2r 2  30 D8                BMI     notype          ;exit if not found
0002E4r 2  AD rr rr             LDA     dskbuf          ;get load start
0002E7r 2  AC rr rr             LDY     dskbuf+1
0002EAr 2               lcmdlp:
0002EAr 2  20 rr rr             JSR     setbuf          ;set as disk buffer
0002EDr 2  20 rr rr             JSR     read1           ;read record
0002F0r 2  D0 06                BNE     loadnd          ;done if not zero
0002F2r 2  20 rr rr             JSR     adjdb           ;bump address
0002F5r 2  4C rr rr             JMP     lcmdlp          ;and loop
0002F8r 2               loadnd:
0002F8r 2  30 BE                BMI     typerr          ;if error say so
0002FAr 2  4C rr rr             JMP     stdflb          ;back to default buffer
0002FDr 2               ;execute go command
0002FDr 2               ; go (<address>)
0002FDr 2               go:
0002FDr 2  20 rr rr             JSR     bldnum          ;get address
000300r 2  AE rr rr             LDX     fcbone+1        ;get first char
000303r 2  E0 20                CPX     #' '            ;see if nothing
000305r 2  F0 03                BEQ     nolnum          ;nothing so use tea
000307r 2  4C rr rr             JMP     godoit          ;then execute
00030Ar 2               nolnum:
00030Ar 2  4C rr rr             JMP     gotea
00030Dr 2               ;execute trns (transient) command
00030Dr 2               ; <ufn> (<fn>) (<fn>)
00030Dr 2               trns:
00030Dr 2  AD rr rr             LDA     fcbone+1        ;get first char
000310r 2  C9 20                CMP     #' '            ;if not space
000312r 2  D0 11                BNE     chktyp          ;check type
000314r 2  AD rr rr             LDA     tmpdsk          ;else test temp
000317r 2  F0 09                BEQ     skpdrv          ;if none skip
000319r 2  38                   SEC                     ;else convert
00031Ar 2  E9 01                SBC     #1              ;to number
00031Cr 2  8D rr rr             STA     dfldsk          ;set default
00031Fr 2  20 rr rr             JSR     slctds          ;and select
000322r 2               skpdrv:
000322r 2  4C rr rr             JMP     extwod          ;return
000325r 2               chktyp:
000325r 2  AD rr rr             LDA     fcbone+9        ;get type
000328r 2  C9 20                CMP     #' '            ;if space
00032Ar 2  F0 03                BEQ     typemp          ;then ok
00032Cr 2  4C rr rr             JMP     trnerr          ;else error
00032Fr 2               typemp:
00032Fr 2  A2 02                LDX     #2              ;make
000331r 2               setcom:
000331r 2  BD rr rr             LDA     typcom,x        ;type
000334r 2  9D rr rr             STA     fcbone+9,x      ;com
000337r 2  CA                   DEX                     ;then
000338r 2  10 F7                BPL     setcom          ;continue
00033Ar 2  20 rr rr             JSR     casdo1          ;clear - select - open file one
00033Dr 2  10 03                BPL     gottrn          ;jump if ok
00033Fr 2  4C rr rr             JMP     topner          ;else do error
000342r 2               gottrn:
000342r 2  20 rr rr             JSR     setddb          ;set start to tea
000345r 2               nxtrcr:
000345r 2  20 rr rr             JSR     setbuf          ;set address
000348r 2  20 rr rr             JSR     read1           ;read fcb 1
00034Br 2  D0 1E                BNE     endlde          ;branch if error or eof
00034Dr 2  20 rr rr             JSR     adjdb           ;adjust address up by 128
000350r 2  CD rr rr             CMP     ccmvc           ;if new low
000353r 2  90 07                BCC     tryhig          ;ok try high
000355r 2  CC rr rr             CPY     ccmvc+1         ;else if high
000358r 2  90 EB                BCC     nxtrcr          ;ok do more
00035Ar 2  B0 07                BCS     chklnd          ;else check for end
00035Cr 2               tryhig:
00035Cr 2  CC rr rr             CPY     ccmvc+1         ;if high less
00035Fr 2  90 E4                BCC     nxtrcr          ;then ok
000361r 2  F0 E2                BEQ     nxtrcr          ;or ok if same
000363r 2               chklnd:
000363r 2  20 rr rr             JSR     stdflb          ;set buffer to default
000366r 2  20 rr rr             JSR     read1           ;read (should be eof)
000369r 2  F0 6C                BEQ     tlderr          ;error if more
00036Br 2               endlde:
00036Br 2  30 6A                BMI     tlderr          ;do error
00036Dr 2               gotea:
00036Dr 2  A9 00                LDA     #<tea           ;set go address to tea start
00036Fr 2  A0 08                LDY     #>tea
000371r 2               godoit:
000371r 2  8D rr rr             STA     do+1            ;set to ay
000374r 2  8C rr rr             STY     do+2
000377r 2  20 rr rr             JSR     rstddr          ;else restore default
00037Ar 2  20 rr rr             JSR     prslin          ;parse file
00037Dr 2  AD rr rr             LDA     tmpdsk          ;set auto
000380r 2  8D rr rr             STA     fcbone          ;select position
000383r 2  A2 10                LDX     #16             ;do a second
000385r 2  20 rr rr             JSR     prsmre          ;fcb if there
000388r 2  AD rr rr             LDA     tmpdsk          ;set auto select
00038Br 2  8D rr rr             STA     fcbone+16       ;again
00038Er 2  A0 00                LDY     #0              ;clear record
000390r 2  8C rr rr             STY     fcbone+32       ;counter
000393r 2  A2 20                LDX     #32             ;move
000395r 2               movfcb:
000395r 2  BD rr rr             LDA     fcbone,x        ;all
000398r 2  9D 07 01             STA     dflfcb,x        ;to
00039Br 2  CA                   DEX                     ;default
00039Cr 2  10 F7                BPL     movfcb          ;fcb
00039Er 2  E8                   INX                     ;set x to zero
00039Fr 2               tstbuf:
00039Fr 2  B9 rr rr             LDA     cnstxt,y        ;get char
0003A2r 2  F0 07                BEQ     isnull          ;if null jump
0003A4r 2  C9 20                CMP     #' '            ;or if space
0003A6r 2  F0 03                BEQ     isnull          ;jump
0003A8r 2  C8                   INY                     ;else bump pointer
0003A9r 2  D0 F4                BNE     tstbuf          ;and loop
0003ABr 2               isnull:
0003ABr 2  A9 00                LDA     #0              ;clear
0003ADr 2  8D 28 01             STA     dflbuf          ;count
0003B0r 2               movbuf:
0003B0r 2  B9 rr rr             LDA     cnstxt,y        ;get char
0003B3r 2  9D 29 01             STA     dflbuf+1,x      ;and move
0003B6r 2  F0 07                BEQ     fillov          ;exit if null
0003B8r 2  E8                   INX                     ;increment
0003B9r 2  C8                   INY                     ;counters
0003BAr 2  EE 28 01             INC     dflbuf          ;and length
0003BDr 2  D0 F1                BNE     movbuf          ;and loop
0003BFr 2               fillov:
0003BFr 2  20 rr rr             JSR     ccrlf           ;do a cr lf
0003C2r 2  20 rr rr             JSR     stdflb          ;set default
0003C5r 2               do:
0003C5r 2  20 00 08             JSR     tea             ;execute
0003C8r 2  AD rr rr             LDA     dfldsk          ;get default
0003CBr 2  20 rr rr             JSR     slctds          ;and set
0003CEr 2  4C rr rr             JMP     ccmlpe          ;then loop
0003D1r 2               ;trns syntax error handler
0003D1r 2               topner:
0003D1r 2  20 rr rr             JSR     rstddr          ;restore default
0003D4r 2               trnerr:
0003D4r 2  4C rr rr             JMP     cmderr          ;do error
0003D7r 2               ;trns load error
0003D7r 2               tlderr:
0003D7r 2  A0 4A                LDY     #lderms         ;point to
0003D9r 2  4C rr rr             JMP     sndmsg          ;and send
0003DCr 2               ;carriage return and linefeed
0003DCr 2               ccrlf:
0003DCr 2  A9 0D                LDA     #cr             ;get a cr
0003DEr 2  20 rr rr             JSR     chrout          ;send
0003E1r 2  A9 0A                LDA     #lf             ;get a lf
0003E3r 2  D0 06                BNE     chrout          ;and send
0003E5r 2               ;pem entry routines
0003E5r 2               cnsrde:
0003E5r 2  A2 01                LDX     #1              ;console read
0003E7r 2  D0 43                BNE     pemgo
0003E9r 2               spcout:
0003E9r 2  A9 20                LDA     #' '            ;output space
0003EBr 2               chrout:
0003EBr 2  A2 02                LDX     #2              ;console output
0003EDr 2  D0 3D                BNE     pemgo
0003EFr 2               rdebuf:
0003EFr 2  A2 0A                LDX     #10             ;buffered input
0003F1r 2  D0 39                BNE     pemgo
0003F3r 2               chkcst:
0003F3r 2  A2 0B                LDX     #11             ;check console
0003F5r 2  D0 35                BNE     pemgo
0003F7r 2               rstdsk:
0003F7r 2  A2 0D                LDX     #13             ;initialize system
0003F9r 2  D0 31                BNE     pemgo
0003FBr 2               slctds:
0003FBr 2  A2 0E                LDX     #14             ;select drive
0003FDr 2  D0 2D                BNE     pemgo
0003FFr 2               openfl:
0003FFr 2  A2 0F                LDX     #15             ;open file
000401r 2  D0 29                BNE     pemgo
000403r 2               clsefl:
000403r 2  A2 10                LDX     #16             ;close file
000405r 2  D0 25                BNE     pemgo
000407r 2               srchfr:
000407r 2  A2 11                LDX     #17             ;first match
000409r 2  D0 21                BNE     pemgo
00040Br 2               srchnx:
00040Br 2  A2 12                LDX     #18             ;next match
00040Dr 2  D0 1D                BNE     pemgo
00040Fr 2               ;delete file one
00040Fr 2               dlt1:
00040Fr 2  20 rr rr             JSR     setone          ;point to fcb
000412r 2               dltfil:
000412r 2  A2 13                LDX     #19             ;delete file
000414r 2  D0 16                BNE     pemgo
000416r 2               rdrcrd:
000416r 2  A2 14                LDX     #20             ;read record
000418r 2  D0 12                BNE     pemgo
00041Ar 2               wrrcrd:
00041Ar 2  A2 15                LDX     #21             ;write record
00041Cr 2  D0 0E                BNE     pemgo
00041Er 2               cratfl:
00041Er 2  A2 16                LDX     #22             ;create file
000420r 2  D0 0A                BNE     pemgo
000422r 2               renmfl:
000422r 2  A2 17                LDX     #23             ;rename file
000424r 2  D0 06                BNE     pemgo
000426r 2               intdsk:
000426r 2  A2 19                LDX     #25             ;read drive num
000428r 2  D0 02                BNE     pemgo
00042Ar 2               setbuf:
00042Ar 2  A2 1A                LDX     #26             ;set buffer add
00042Cr 2               pemgo:
00042Cr 2  4C 03 01             JMP     pemjmp          ;go to pem
00042Fr 2               ;restore default drive
00042Fr 2               rstddr:
00042Fr 2  AD rr rr             LDA     tmpdsk          ;if temp drive
000432r 2  F0 1F                BEQ     extddr          ;zero then exit
000434r 2  38                   SEC                     ;else
000435r 2  E9 01                SBC     #1              ;subtract one
000437r 2  CD rr rr             CMP     dfldsk          ;compare to default
00043Ar 2  F0 17                BEQ     extddr          ;exit if same
00043Cr 2               seldfl:
00043Cr 2  AD rr rr             LDA     dfldsk          ;else get default
00043Fr 2  4C rr rr             JMP     slctds          ;select
000442r 2               ;clear auto - select disk - open file at fcbone
000442r 2               casdo1:
000442r 2  20 rr rr             JSR     clrslt          ;clear auto and select
000445r 2               ;open file one
000445r 2               ; returns:n=1 if not found
000445r 2               open1:
000445r 2  A9 00                LDA     #0              ;clear
000447r 2  8D rr rr             STA     fcbone+32       ;record number
00044Ar 2  20 rr rr             JSR     setone          ;point to fcb
00044Dr 2  20 rr rr             JSR     openfl          ;open it
000450r 2  8D rr rr             STA     diradd          ;save number
000453r 2               extddr:
000453r 2  60                   RTS
000454r 2               ;read file one
000454r 2               read1:
000454r 2  20 rr rr             JSR     setone          ;point to fcb
000457r 2  4C rr rr             JMP     rdrcrd          ;do read
00045Ar 2               ;search for first file one
00045Ar 2               ; returns:n=1 if not found
00045Ar 2               srchf1:
00045Ar 2  20 rr rr             JSR     setone          ;point to fcb
00045Dr 2  20 rr rr             JSR     srchfr          ;search for first
000460r 2  8D rr rr             STA     diradd          ;save number
000463r 2  60                   RTS
000464r 2               ;header output
000464r 2               hdrout:
000464r 2  20 rr rr             JSR     ccrlf           ;do cr lf
000467r 2               hdr:
000467r 2  20 rr rr             JSR     intdsk          ;get drive number
00046Ar 2  18                   CLC                     ;make
00046Br 2  69 41                ADC     #'A'            ;a letter
00046Dr 2               ;output with save of x and y
00046Dr 2               ;this routine calls the pem resident routine
00046Dr 2               ;tstchr to see if a char is a printing char.
00046Dr 2               ;if it is then c=1 upon return from tstchr.
00046Dr 2               cotsxy:
00046Dr 2  8E rr rr             STX     savx            ;save x
000470r 2  8C rr rr             STY     savy            ;and y
000473r 2  20 rr rr             JSR     tstchr          ;see if printing
000476r 2  B0 10                BCS     isprnt          ;jump if is
000478r 2  48                   PHA                     ;else save
000479r 2  AD rr rr             LDA     sysdef+4        ;get invert
00047Cr 2  20 rr rr             JSR     chrout          ;send it
00047Fr 2  68                   PLA                     ;get char
000480r 2  09 40                ORA     #'@'            ;make printing
000482r 2  20 rr rr             JSR     chrout          ;send it
000485r 2  AD rr rr             LDA     sysdef+3        ;get normal
000488r 2               isprnt:
000488r 2  20 rr rr             JSR     chrout          ;do output
00048Br 2  AC rr rr             LDY     savy            ;get y
00048Er 2  AE rr rr             LDX     savx            ;and x
000491r 2  60                   RTS
000492r 2               ;set up fcb one pointer
000492r 2               setone:
000492r 2  AD rr rr             LDA     fcb1vc          ;low
000495r 2  AC rr rr             LDY     fcb1vc+1        ;and high
000498r 2  60                   RTS
000499r 2               ;save tmpdsk in oldtmp
000499r 2               tmpold:
000499r 2  AD rr rr             LDA     tmpdsk
00049Cr 2  8D rr rr             STA     oldtmp
00049Fr 2  60                   RTS
0004A0r 2               ;parse command line
0004A0r 2               prslin:
0004A0r 2  A2 00                LDX     #0              ;clear index
0004A2r 2               prsmre:
0004A2r 2  8A                   TXA                     ;save
0004A3r 2  48                   PHA                     ;index
0004A4r 2  A9 00                LDA     #0              ;clear temp
0004A6r 2  8D rr rr             STA     tmpdsk          ;drive flag
0004A9r 2  AC rr rr             LDY     cnbfpt          ;get buffer pointer
0004ACr 2  20 rr rr             JSR     skpspc          ;find first non-space
0004AFr 2  8C rr rr             STY     curpnt          ;save index
0004B2r 2  F0 0D                BEQ     nulchr          ;jump if null
0004B4r 2  29 0F                AND     #%00001111      ;else look at 4 lsbs
0004B6r 2  48                   PHA                     ;and save
0004B7r 2  C8                   INY                     ;point to next char
0004B8r 2  B9 rr rr             LDA     cnstxt,y        ;and get it
0004BBr 2  C9 3A                CMP     #':'            ;if a colon
0004BDr 2  F0 0A                BEQ     drvinp          ;jump and set drive
0004BFr 2  68                   PLA                     ;else clear stack
0004C0r 2  88                   DEY                     ;backup index
0004C1r 2               nulchr:
0004C1r 2  AD rr rr             LDA     dfldsk          ;set automatic
0004C4r 2  9D rr rr             STA     fcbone,x        ;to default
0004C7r 2  10 08                BPL     trynme          ;then parse name
0004C9r 2               drvinp:
0004C9r 2  68                   PLA                     ;get number
0004CAr 2  8D rr rr             STA     tmpdsk          ;set temp flag
0004CDr 2  9D rr rr             STA     fcbone,x        ;and fcb
0004D0r 2  C8                   INY                     ;point past colon
0004D1r 2               trynme:
0004D1r 2  A9 08                LDA     #8              ;set name count
0004D3r 2  8D rr rr             STA     ccmcount        ;to eight
0004D6r 2               tstnme:
0004D6r 2  20 rr rr             JSR     tstlgl          ;test for illegal
0004D9r 2  F0 1D                BEQ     flnmsp          ;if illegal jump
0004DBr 2  E8                   INX                     ;bump pointer
0004DCr 2  C9 2A                CMP     #'*'            ;if not *
0004DEr 2  D0 07                BNE     notafn          ;skip ? fill
0004E0r 2  A9 3F                LDA     #'?'            ;get a ?
0004E2r 2  9D rr rr             STA     fcbone,x        ;store
0004E5r 2  D0 04                BNE     nxtout          ;and jump
0004E7r 2               notafn:
0004E7r 2  9D rr rr             STA     fcbone,x        ;store char
0004EAr 2  C8                   INY                     ;bump source
0004EBr 2               nxtout:
0004EBr 2  CE rr rr             DEC     ccmcount        ;drop counter down
0004EEr 2  D0 E6                BNE     tstnme          ;and loop
0004F0r 2               skpmre:
0004F0r 2  20 rr rr             JSR     tstlgl          ;if illegal
0004F3r 2  F0 11                BEQ     trytyp          ;try type
0004F5r 2  C8                   INY                     ;else bump index
0004F6r 2  D0 F8                BNE     skpmre          ;and loop
0004F8r 2               flnmsp:
0004F8r 2  E8                   INX                     ;next position
0004F9r 2  A9 20                LDA     #' '            ;get a space
0004FBr 2  9D rr rr             STA     fcbone,x        ;store
0004FEr 2  CE rr rr             DEC     ccmcount        ;count down
000501r 2  D0 F5                BNE     flnmsp          ;and loop
000503r 2  B9 rr rr             LDA     cnstxt,y        ;get char again
000506r 2               trytyp:
000506r 2  48                   PHA                     ;save char
000507r 2  A9 03                LDA     #3              ;set count
000509r 2  8D rr rr             STA     ccmcount        ;to three
00050Cr 2  68                   PLA                     ;get char
00050Dr 2  C9 2E                CMP     #'.'            ;if not .
00050Fr 2  D0 23                BNE     fltysp          ;then fill spaces
000511r 2  C8                   INY                     ;else bump source
000512r 2               tsttyp:
000512r 2  20 rr rr             JSR     tstlgl          ;if not legal
000515r 2  F0 1D                BEQ     fltysp          ;then fill spaces
000517r 2  E8                   INX                     ;else bump index
000518r 2  C9 2A                CMP     #'*'            ;if not *
00051Ar 2  D0 07                BNE     notaft          ;then skip fill
00051Cr 2  A9 3F                LDA     #'?'            ;else get ?
00051Er 2  9D rr rr             STA     fcbone,x        ;move to fcb
000521r 2  D0 04                BNE     mrtyfl          ;and loop
000523r 2               notaft:
000523r 2  9D rr rr             STA     fcbone,x        ;move char to fcb
000526r 2  C8                   INY                     ;bump source
000527r 2               mrtyfl:
000527r 2  CE rr rr             DEC     ccmcount        ;count down
00052Ar 2  D0 E6                BNE     tsttyp          ;and loop
00052Cr 2               nttype:
00052Cr 2  20 rr rr             JSR     tstlgl          ;if illegal
00052Fr 2  F0 0E                BEQ     filnul          ;fill out nulls
000531r 2  C8                   INY                     ;else bump source
000532r 2  D0 F8                BNE     nttype          ;and loop
000534r 2               fltysp:
000534r 2  E8                   INX                     ;bump fcb pointer
000535r 2  A9 20                LDA     #' '            ;get space
000537r 2  9D rr rr             STA     fcbone,x        ;put in fcb
00053Ar 2  CE rr rr             DEC     ccmcount        ;count down
00053Dr 2  D0 F5                BNE     fltysp          ;and continue
00053Fr 2               filnul:
00053Fr 2  A9 03                LDA     #3              ;clear
000541r 2  8D rr rr             STA     ccmcount        ;three
000544r 2               mrnlty:
000544r 2  E8                   INX                     ;bump fcb pointer
000545r 2  A9 00                LDA     #0              ;get a zero
000547r 2  9D rr rr             STA     fcbone,x        ;move to fcb
00054Ar 2  CE rr rr             DEC     ccmcount        ;count down
00054Dr 2  D0 F5                BNE     mrnlty          ;loop until done
00054Fr 2  8C rr rr             STY     cnbfpt          ;update start pointer
000552r 2  A9 00                LDA     #0              ;clear
000554r 2  8D rr rr             STA     ccmcount        ;count
000557r 2  68                   PLA                     ;restore stack
000558r 2  A8                   TAY                     ;move to index
000559r 2  A2 0B                LDX     #11             ;counter to 11
00055Br 2               tstqus:
00055Br 2  C8                   INY                     ;point to
00055Cr 2  B9 rr rr             LDA     fcbone,y        ;and get char
00055Fr 2  C9 3F                CMP     #'?'            ;if not a ?
000561r 2  D0 03                BNE     nxtqus          ;then jump
000563r 2  EE rr rr             INC     ccmcount        ;else bump count
000566r 2               nxtqus:
000566r 2  CA                   DEX                     ;loop until
000567r 2  D0 F2                BNE     tstqus          ;11 tested
000569r 2  AD rr rr             LDA     ccmcount        ;get count
00056Cr 2  60                   RTS                     ;and return
00056Dr 2               ;skip space
00056Dr 2               skpspc:
00056Dr 2  B9 rr rr             LDA     cnstxt,y        ;get char
000570r 2  F0 07                BEQ     extskp          ;jump if null
000572r 2  C9 20                CMP     #' '            ;if not space
000574r 2  D0 03                BNE     extskp          ;then exit
000576r 2  C8                   INY                     ;else go to next
000577r 2  D0 F4                BNE     skpspc          ;and test
000579r 2               extskp:
000579r 2  60                   RTS
00057Ar 2               ;test legal
00057Ar 2               tstlgl:
00057Ar 2  B9 rr rr             LDA     cnstxt,y        ;get char
00057Dr 2  F0 1C                BEQ     extlgl
00057Fr 2  C9 20                CMP     #' '            ;if space
000581r 2  90 19                BCC     badinp          ;ok - less is error
000583r 2  F0 16                BEQ     extlgl
000585r 2  C9 3D                CMP     #'='
000587r 2  F0 12                BEQ     extlgl
000589r 2  C9 2E                CMP     #'.'
00058Br 2  F0 0E                BEQ     extlgl
00058Dr 2  C9 3A                CMP     #':'
00058Fr 2  F0 0A                BEQ     extlgl
000591r 2  C9 3B                CMP     #semico
000593r 2  F0 06                BEQ     extlgl
000595r 2  C9 3C                CMP     #'<'
000597r 2  F0 02                BEQ     extlgl
000599r 2  C9 3E                CMP     #'>'
00059Br 2               extlgl:
00059Br 2  60                   RTS
00059Cr 2               badinp:
00059Cr 2  4C rr rr             JMP     cmderr
00059Fr 2               ;set default buffer address
00059Fr 2               stdflb:
00059Fr 2  A9 28                LDA     #<dflbuf        ;point to
0005A1r 2  A0 01                LDY     #>dflbuf        ;location
0005A3r 2  4C rr rr             JMP     setbuf          ;and set
0005A6r 2               ;clear automatic and select
0005A6r 2               clrslt:
0005A6r 2  A9 00                LDA     #0              ;clear auto
0005A8r 2  8D rr rr             STA     fcbone          ;select
0005ABr 2               slttmp:
0005ABr 2  AD rr rr             LDA     tmpdsk          ;get temp
0005AEr 2  F0 1F                BEQ     extsnd          ;if zero exit
0005B0r 2  38                   SEC                     ;else subtract
0005B1r 2  E9 01                SBC     #1              ;one
0005B3r 2  CD rr rr             CMP     dfldsk          ;if same as default
0005B6r 2  F0 17                BEQ     extsnd          ;then quit
0005B8r 2  4C rr rr             JMP     slctds          ;else set
0005BBr 2               ;send message
0005BBr 2               sndmsg:
0005BBr 2  8C rr rr             STY     savy            ;save index
0005BEr 2  20 rr rr             JSR     ccrlf           ;do cr and lf
0005C1r 2  AC rr rr             LDY     savy            ;get index
0005C4r 2               lpesnd:
0005C4r 2  B9 rr rr             LDA     msgtbl,y        ;get char
0005C7r 2  F0 06                BEQ     extsnd          ;if null quit
0005C9r 2  20 rr rr             JSR     cotsxy          ;else send
0005CCr 2  C8                   INY                     ;point to next
0005CDr 2  D0 F5                BNE     lpesnd          ;and loop
0005CFr 2               extsnd:
0005CFr 2  60                   RTS
0005D0r 2               ;set load start address
0005D0r 2               setddb:
0005D0r 2  A9 00                LDA     #<tea           ;to tea start
0005D2r 2  A0 08                LDY     #>tea
0005D4r 2               setdb:
0005D4r 2  8D rr rr             STA     dskbuf          ;to ay
0005D7r 2  8C rr rr             STY     dskbuf+1
0005DAr 2  60                   RTS
0005DBr 2               ;move first part of fcb to second half
0005DBr 2               ;and move second part to first part.
0005DBr 2               ;only ren depends upon this routine to actually
0005DBr 2               ;swap fcb halves.
0005DBr 2               ;alters:a,x,p
0005DBr 2               ;returns:x=$ff
0005DBr 2               frssec:
0005DBr 2  A2 0F                LDX     #15             ;set index to last
0005DDr 2               frsclp:
0005DDr 2  BD rr rr             LDA     fcbone,x        ;get byte
0005E0r 2  BC rr rr             LDY     fcbone+16,x
0005E3r 2  9D rr rr             STA     fcbone+16,x     ;move it
0005E6r 2  98                   TYA
0005E7r 2  9D rr rr             STA     fcbone,x
0005EAr 2  CA                   DEX
0005EBr 2  10 F0                BPL     frsclp          ;until 16 moved
0005EDr 2  60                   RTS
0005EEr 2               ;move second part of fcb to first half
0005EEr 2               ;restore tmpdsk from save location
0005EEr 2               ;alters:a,x,p
0005EEr 2               ;returns:x=$ff
0005EEr 2               secfrs:
0005EEr 2  A2 0F                LDX     #15             ;set index to last
0005F0r 2               scfrlp:
0005F0r 2  BD rr rr             LDA     fcbone+16,x     ;get byte
0005F3r 2  9D rr rr             STA     fcbone,x        ;move it
0005F6r 2  CA                   DEX
0005F7r 2  10 F7                BPL     scfrlp          ;loop until done
0005F9r 2  AD rr rr             LDA     oldtmp          ;get old flag
0005FCr 2  8D rr rr             STA     tmpdsk          ;and set
0005FFr 2  60                   RTS
000600r 2               ;build a number from command line and leave in num
000600r 2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
000600r 2               ;move parse index past number
000600r 2               ;modifies:all
000600r 2               ;returns:a,y set to low and high of number
000600r 2               ;	 flags set according to y which is high part of number
000600r 2               bldnum:
000600r 2  A9 09                LDA     #9              ;preset to decimal
000602r 2  8D rr rr             STA     moduls
000605r 2  20 rr rr             JSR     prslin          ;put in fcb
000608r 2  AD rr rr             LDA     tmpdsk          ;if temp
00060Br 2  D0 67                BNE     numerr          ;is error
00060Dr 2  8D rr rr             STA     num             ;else clear num
000610r 2  8D rr rr             STA     num+1
000613r 2  A8                   TAY                     ;and index
000614r 2  B9 rr rr             LDA     fcbone+1,y      ;get first char
000617r 2  C9 24                CMP     #'$'            ;see if hex signal
000619r 2  D0 06                BNE     bnumlp          ;skip if not
00061Br 2  A9 0F                LDA     #15             ;set for modulus
00061Dr 2  8D rr rr             STA     moduls
000620r 2  C8                   INY                     ;bump past $
000621r 2               bnumlp:
000621r 2  C8                   INY                     ;next char
000622r 2  B9 rr rr             LDA     fcbone,y        ;get digit
000625r 2  C9 20                CMP     #' '            ;see if space
000627r 2  F0 4E                BEQ     endnlp          ;done if is
000629r 2  20 rr rr             JSR     tstdec          ;see if decimal
00062Cr 2  90 0E                BCC     usedig          ;use if is
00062Er 2  20 rr rr             JSR     tsthex          ;see if hex
000631r 2  B0 41                BCS     numerr          ;error if not
000633r 2  E9 06                SBC     #6              ;remove offset
000635r 2  A2 0F                LDX     #15             ;test for hex modulus
000637r 2  EC rr rr             CPX     moduls
00063Ar 2  D0 38                BNE     numerr          ;error if not
00063Cr 2               usedig:
00063Cr 2  29 0F                AND     #%00001111      ;eliminate ascii bias
00063Er 2  48                   PHA                     ;save result
00063Fr 2  AD rr rr             LDA     num             ;move number to temp
000642r 2  8D rr rr             STA     tnum
000645r 2  AD rr rr             LDA     num+1
000648r 2  8D rr rr             STA     tnum+1
00064Br 2  AE rr rr             LDX     moduls          ;get modulus
00064Er 2  18                   CLC
00064Fr 2               addlpe:
00064Fr 2  AD rr rr             LDA     num             ;add number to itself
000652r 2  6D rr rr             ADC     tnum
000655r 2  8D rr rr             STA     num
000658r 2  AD rr rr             LDA     num+1           ;modulus times
00065Br 2  6D rr rr             ADC     tnum+1
00065Er 2  8D rr rr             STA     num+1
000661r 2  B0 11                BCS     numerr          ;error if carry out
000663r 2  CA                   DEX
000664r 2  D0 E9                BNE     addlpe          ;loop if more
000666r 2  68                   PLA                     ;get input back
000667r 2  6D rr rr             ADC     num             ;add in
00066Ar 2  8D rr rr             STA     num
00066Dr 2  90 B2                BCC     bnumlp          ;loop if no carry
00066Fr 2  EE rr rr             INC     num+1           ;else bump high
000672r 2  D0 AD                BNE     bnumlp          ;and loop for more
000674r 2               ;error in bldnum - handle and quit
000674r 2               numerr:
000674r 2  4C rr rr             JMP     cmderr          ;do general error
000677r 2               ;end of use of name part - check type
000677r 2               endnlp:
000677r 2  AD rr rr             LDA     fcbone+9        ;get first
00067Ar 2  C9 20                CMP     #' '            ;see if space
00067Cr 2  D0 F6                BNE     numerr          ;error if not
00067Er 2  AD rr rr             LDA     num             ;return with result
000681r 2  AC rr rr             LDY     num+1
000684r 2  60                   RTS
000685r 2               ;relocatable vectors
000685r 2  4C                   .BYTE   $4c
000686r 2               cnsbvc:
000686r 2  rr rr                .WORD   cnsbuf
000688r 2  4C                   .BYTE   $4c
000689r 2               extcvc:
000689r 2  rr rr                .WORD   extcmd-1
00068Br 2  4C                   .BYTE   $4c
00068Cr 2               ccmvc:
00068Cr 2  rr rr                .WORD   ccm
00068Er 2  4C                   .BYTE   $4c
00068Fr 2               fcb1vc:
00068Fr 2  rr rr                .WORD   fcbone
000691r 2               ;function entry vector
000691r 2               xqfntb:
000691r 2  4C rr rr             JMP     dir
000694r 2  4C rr rr             JMP     save
000697r 2  4C rr rr             JMP     era
00069Ar 2  4C rr rr             JMP     type
00069Dr 2  4C rr rr             JMP     ren
0006A0r 2  4C rr rr             JMP     go
0006A3r 2  4C rr rr             JMP     load
0006A6r 2  4C rr rr             JMP     trns
0006A9r 2               ;terminator for relocation
0006A9r 2  FF                   .BYTE   $ff
0006AAr 2               ;messages
0006AAr 2               msgtbl:
0006AAr 2  00                   .BYTE   0
0006ABr 2               nospms          = *-msgtbl
0006ABr 2  4E 4F 20 53          .BYTE   "NO SPACE",0
0006AFr 2  50 41 43 45  
0006B3r 2  00           
0006B4r 2               ntclms          = *-msgtbl
0006B4r 2  43 41 4E 20          .BYTE   "CAN NOT CLOSE",0
0006B8r 2  4E 4F 54 20  
0006BCr 2  43 4C 4F 53  
0006C2r 2               alflms          = *-msgtbl
0006C2r 2  41 4C 4C 20          .BYTE   "ALL FILES (Y/N)?",0
0006C6r 2  46 49 4C 45  
0006CAr 2  53 20 28 59  
0006D3r 2               rderms          = *-msgtbl
0006D3r 2  52 45 41 44          .BYTE   "READ ERROR",0
0006D7r 2  20 45 52 52  
0006DBr 2  4F 52 00     
0006DEr 2               ntfnms          = *-msgtbl
0006DEr 2  4E 4F 54 20          .BYTE   "NOT FOUND",0
0006E2r 2  46 4F 55 4E  
0006E6r 2  44 00        
0006E8r 2               flexms          = *-msgtbl
0006E8r 2  46 49 4C 45          .BYTE   "FILE EXISTS",0
0006ECr 2  20 45 58 49  
0006F0r 2  53 54 53 00  
0006F4r 2               lderms          = *-msgtbl
0006F4r 2  4C 4F 41 44          .BYTE   "LOAD ERROR",0
0006F8r 2  20 45 52 52  
0006FCr 2  4F 52 00     
0006FFr 2               cnnoms          = *-msgtbl
0006FFr 2  43 41 4E 20          .BYTE   "CAN NOT OPEN",0
000703r 2  4E 4F 54 20  
000707r 2  4F 50 45 4E  
00070Cr 2               wrerms          = *-msgtbl
00070Cr 2  57 52 49 54          .BYTE   "WRITE ERROR",0
000710r 2  45 20 45 52  
000714r 2  52 4F 52 00  
000718r 2               ;function name table
000718r 2               fnctbl:
000718r 2  44 49 52 20          .BYTE   "DIR ",0
00071Cr 2  00           
00071Dr 2  53 41 56 45          .BYTE   "SAVE ",0
000721r 2  20 00        
000723r 2  45 52 41 20          .BYTE   "ERA ",0
000727r 2  00           
000728r 2  54 59 50 45          .BYTE   "TYPE ",0
00072Cr 2  20 00        
00072Er 2  52 45 4E 20          .BYTE   "REN ",0
000732r 2  00           
000733r 2  47 4F 20 00          .BYTE   "GO ",0
000737r 2  4C 4F 41 44          .BYTE   "LOAD ",0
00073Br 2  20 00        
00073Dr 2               ;input buffer
00073Dr 2               cnsbuf:
00073Dr 2               cnsmax:
00073Dr 2  7F                   .BYTE   127
00073Er 2               cnslng:
00073Er 2  00                   .BYTE   0
00073Fr 2               cnstxt:
00073Fr 2  xx xx xx xx          .RES    127
000743r 2  xx xx xx xx  
000747r 2  xx xx xx xx  
0007BEr 2               ;fcb one
0007BEr 2               fcbone:
0007BEr 2  xx xx xx xx          .RES    33
0007C2r 2  xx xx xx xx  
0007C6r 2  xx xx xx xx  
0007DFr 2               ;com type field
0007DFr 2               
0007DFr 2               typcom:
0007DFr 2  43 4F 36             .BYTE   COMSUFFIX
0007E2r 2               
0007E2r 2               ;variable storage
0007E2r 2               cnbfpt:
0007E2r 2  00                   .BYTE   0               ;buffer index
0007E3r 2               dfldsk:
0007E3r 2  00                   .BYTE   0               ;default drive
0007E4r 2               tmpdsk:
0007E4r 2  00                   .BYTE   0               ;temporary dvive
0007E5r 2               ;align vector on word boundary
0007E5r 2  xx                   .ALIGN  2
0007E6r 2               vector:
0007E6r 2  00 00                .WORD   0               ;execution vector
0007E8r 2               ccmcount:
0007E8r 2  00                   .BYTE   0               ;counter
0007E9r 2               curpnt:
0007E9r 2  00                   .BYTE   0               ;input parse start
0007EAr 2               diradd:
0007EAr 2  00                   .BYTE   0               ;directory number
0007EBr 2               savx:
0007EBr 2  00                   .BYTE   0               ;save x location
0007ECr 2               savy:
0007ECr 2  00                   .BYTE   0               ;save y location
0007EDr 2               length:
0007EDr 2  00                   .BYTE   0               ;number tages to save
0007EEr 2               oldtmp:
0007EEr 2  00                   .BYTE   0               ;temp drive in ren
0007EFr 2               dskbuf:
0007EFr 2  00 08                .WORD   tea             ;disk buffer start
0007F1r 2               across:
0007F1r 2  00                   .BYTE   0               ;dir count on line
0007F2r 2               sixten:
0007F2r 2  00                   .BYTE   0               ;line length div 16
0007F3r 2               moduls:
0007F3r 2  09                   .BYTE   9               ;modulus-1 for number input
0007F4r 2               num:
0007F4r 2  00 00                .WORD   0               ;input number
0007F6r 2               tnum:
0007F6r 2  00 00                .WORD   0               ;temp in bldnum
0007F8r 2               sadr:
0007F8r 2  00 08                .WORD   tea             ;save start address
0007FAr 2               
0007FAr 1                       .INCLUDE "../dos65_os/pemrbc.asm"
0007FAr 2               ;________________________________________________________________________________________________________________________________
0007FAr 2               ;
0007FAr 2               ;	DOS/65 primitive execution module (pem)
0007FAr 2               ;
0007FAr 2               ;
0007FAr 2               ;________________________________________________________________________________________________________________________________
0007FAr 2               
0007FAr 2               ;main program
0007FAr 2               ; input:x=command,a=value,a&y=address
0007FAr 2               ; returns:a=value,a&y=address
0007FAr 2               ; alters:all
0007FAr 2               
0007FAr 2               pem:
0007FAr 2  D8                   CLD                     ;set binary mode
0007FBr 2  8D rr rr             STA     bytinp          ;save input
0007FEr 2  8D rr rr             STA     lowin           ;value and
000801r 2  8C rr rr             STY     bytinp+1        ;save high
000804r 2  8C rr rr             STY     lowin+1         ;address
000807r 2  8E rr rr             STX     cmdinp          ;and command
00080Ar 2  E0 24                CPX     #numcmd         ;if invalid
00080Cr 2  B0 50                BCS     extpem          ;then exit
00080Er 2  BD rr rr             LDA     swctbl,x        ;if flag zero
000811r 2  F0 08                BEQ     noswin          ;skip switch
000813r 2  A9 FF                LDA     #255            ;else set
000815r 2  8D rr rr             STA     swcflg          ;memory switch flag
000818r 2  20 rr rr             JSR     switch          ;move data to page zero
00081Br 2               noswin:
00081Br 2  A9 00                LDA     #0              ;clear drive
00081Dr 2  8D rr rr             STA     tmpdrv          ;switch flag
000820r 2  AD rr rr             LDA     cmdinp          ;get command
000823r 2  0A                   ASL     a               ;multiply by two
000824r 2  6D rr rr             ADC     cmdinp          ;then add to get x3
000827r 2  AA                   TAX                     ;and make a pointer
000828r 2  E8                   INX                     ;bump to pass jmp
000829r 2  BD rr rr             LDA     cmdtbl,x        ;get command
00082Cr 2  BC rr rr             LDY     cmdtbl+1,x      ;address
00082Fr 2  8D rr rr             STA     xqtvec          ;and put
000832r 2  8C rr rr             STY     xqtvec+1        ;in vector
000835r 2  AD rr rr             LDA     extevc+1        ;get return
000838r 2  48                   PHA                     ;address
000839r 2  AD rr rr             LDA     extevc          ;and push
00083Cr 2  48                   PHA                     ;as return
00083Dr 2  AD rr rr             LDA     bytinp          ;get input value
000840r 2  AC rr rr             LDY     bytinp+1
000843r 2                       .IFDEF DUODYNE
000843r 2                       ldx     #$00
000843r 2                       JMP     (xqtvec,x)        ;then execute
000843r 2                       .ELSE
000843r 2  6C rr rr             JMP     (xqtvec)        ;then execute
000846r 2                       .ENDIF
000846r 2               extexq:
000846r 2  8D rr rr             STA     bytout          ;save value
000849r 2  8C rr rr             STY     addout+1        ;and address
00084Cr 2  AD rr rr             LDA     tmpdrv          ;get temp drive
00084Fr 2  F0 0D                BEQ     extpem          ;if zero skip switch
000851r 2  A0 00                LDY     #0              ;else
000853r 2  91 02                STA     (addinp),y      ;put back in fcb
000855r 2  AD rr rr             LDA     olddrv          ;get old drive number
000858r 2  8D rr rr             STA     bytinp          ;set input value
00085Br 2  20 rr rr             JSR     chgdrv          ;then switch back
00085Er 2               extpem:
00085Er 2  2C rr rr             BIT     swcflg          ;test memory switch
000861r 2  10 08                BPL     noswot          ;if not set skip
000863r 2  20 rr rr             JSR     switch          ;else do memory switch
000866r 2  A9 00                LDA     #0              ;clear
000868r 2  8D rr rr             STA     swcflg          ;flag
00086Br 2               noswot:
00086Br 2  AC rr rr             LDY     addout+1        ;get address
00086Er 2  AD rr rr             LDA     bytout          ;and value (address low)
000871r 2  60                   RTS
000872r 2               ;command vector table
000872r 2               cmdtbl:
000872r 2  4C rr rr             JMP     xwboot          ;warm boot
000875r 2  4C rr rr             JMP     xcnsin          ;console input with echo
000878r 2  4C rr rr             JMP     sndchr          ;console output
00087Br 2  4C rr rr             JMP     sim+21          ;tape reader
00087Er 2  4C rr rr             JMP     sim+18          ;tape punch
000881r 2  4C rr rr             JMP     sim+15          ;printer output
000884r 2  4C rr rr             JMP     getcon          ;console input w/o echo
000887r 2  4C rr rr             JMP     xgtios          ;read i/o status
00088Ar 2  4C rr rr             JMP     xstios          ;set i/o status
00088Dr 2  4C rr rr             JMP     sndstr          ;print buffer
000890r 2  4C rr rr             JMP     bufinp          ;read buffer
000893r 2  4C rr rr             JMP     kbdsts          ;test console ready
000896r 2  4C rr rr             JMP     sim+45          ;read list status
000899r 2  4C rr rr             JMP     xintds          ;initialize system
00089Cr 2  4C rr rr             JMP     chgdrv          ;log in drive
00089Fr 2  4C rr rr             JMP     xopen           ;open file
0008A2r 2  4C rr rr             JMP     xclose          ;close file
0008A5r 2  4C rr rr             JMP     xfndfr          ;find first match
0008A8r 2  4C rr rr             JMP     xfndnx          ;find next match
0008ABr 2  4C rr rr             JMP     xdltfl          ;delete file
0008AEr 2  4C rr rr             JMP     xread           ;read record
0008B1r 2  4C rr rr             JMP     xwrite          ;write record
0008B4r 2  4C rr rr             JMP     xmake           ;create file
0008B7r 2  4C rr rr             JMP     xrenme          ;rename file
0008BAr 2  4C rr rr             JMP     xintlg          ;interrogate log in status
0008BDr 2  4C rr rr             JMP     xintdr          ;interrogate current drive
0008C0r 2  4C rr rr             JMP     chgdma          ;set buffer address
0008C3r 2  4C rr rr             JMP     xrdalv          ;read allocation map start
0008C6r 2  4C rr rr             JMP     setron          ;set r/w status
0008C9r 2  4C rr rr             JMP     xrdros          ;read r/w status
0008CCr 2  4C rr rr             JMP     setlst          ;set list echo status
0008CFr 2  4C rr rr             JMP     lststs          ;read list echo status
0008D2r 2  4C rr rr             JMP     xrtclo          ;read low clock
0008D5r 2  4C rr rr             JMP     xrtchi          ;read high clock
0008D8r 2  4C rr rr             JMP     xrddcb          ;read dcb address
0008DBr 2  4C rr rr             JMP     sim+51          ;translate sector
0008DEr 2               ;set list echo status
0008DEr 2               setlst:
0008DEr 2  8D rr rr             STA     lstflg          ;set flag
0008E1r 2  60                   RTS
0008E2r 2               ;read list echo status
0008E2r 2               lststs:
0008E2r 2  AD rr rr             LDA     lstflg          ;read flag
0008E5r 2  60                   RTS
0008E6r 2               ;execute warm boot
0008E6r 2               ; ***this command does not return to pem***
0008E6r 2               ; ***instead it jumps to sim, resets	***
0008E6r 2               ; ***system and stack and jumps to ccm. ***
0008E6r 2               xwboot:
0008E6r 2  2C rr rr             BIT     swcflg          ;test memory switch flag
0008E9r 2  10 08                BPL     dowmbt          ;if clear do not
0008EBr 2  20 rr rr             JSR     switch          ;switch memory
0008EEr 2  A9 00                LDA     #0              ;clear
0008F0r 2  8D rr rr             STA     swcflg          ;flag
0008F3r 2               dowmbt:
0008F3r 2  4C rr rr             JMP     sim+3           ;go to sim
0008F6r 2               
0008F6r 2               ;execute read real time clock
0008F6r 2               xrtclo:
0008F6r 2  20 rr rr             JSR     sim+48          ;read clock
0008F9r 2               
0008F9r 2  8D rr rr             STA     rtclk           ;save low
0008FCr 2  8C rr rr             STY     rtclk+1         ;middle
0008FFr 2  8E rr rr             STX     rtclk+2         ;high
000902r 2  8A                   TXA
000903r 2  29 80                AND     #%10000000      ;test for valid
000905r 2  A8                   TAY
000906r 2  AD rr rr             LDA     rtclk           ;get low
000909r 2  60                   RTS
00090Ar 2               ;execute read real time clock high
00090Ar 2               xrtchi:
00090Ar 2  AD rr rr             LDA     rtclk+2         ;get high
00090Dr 2  29 7F                AND     #%01111111      ;clear status
00090Fr 2  A8                   TAY
000910r 2  AD rr rr             LDA     rtclk+1         ;get middle
000913r 2  60                   RTS
000914r 2               ;execute read dcb address
000914r 2               xrddcb:
000914r 2  AD rr rr             LDA     cptdcb+1        ;get address
000917r 2  AC rr rr             LDY     cptdcb+2
00091Ar 2  60                   RTS
00091Br 2               ;execute read i/o status
00091Br 2               xgtios:
00091Br 2  AD 06 01             LDA     iostat          ;get status byte
00091Er 2  60                   RTS
00091Fr 2               ;execute read allocation map starting address
00091Fr 2               xrdalv:
00091Fr 2  AD rr rr             LDA     alcmap          ;get
000922r 2  AC rr rr             LDY     alcmap+1        ;starting address
000925r 2  60                   RTS                     ;then return
000926r 2               ;execute set i/o status
000926r 2               xstios:
000926r 2  8D 06 01             STA     iostat          ;set status
000929r 2  60                   RTS
00092Ar 2               ;execute interrogate current drive
00092Ar 2               xintdr:
00092Ar 2  AD rr rr             LDA     curdrv          ;get number
00092Dr 2  60                   RTS
00092Er 2               ;execute read log in status
00092Er 2               xintlg:
00092Er 2  AD rr rr             LDA     lginvc          ;get status
000931r 2  60                   RTS
000932r 2               ;execute read read/write status
000932r 2               xrdros:
000932r 2  AD rr rr             LDA     ronlst          ;get status
000935r 2  60                   RTS
000936r 2               ;execute find next match
000936r 2               xfndnx:
000936r 2  20 rr rr             JSR     autodr          ;auto drive select
000939r 2  A9 0D                LDA     #13             ;match including
00093Br 2  4C rr rr             JMP     search          ;extent
00093Er 2               ;execute read next record
00093Er 2               xread:
00093Er 2  20 rr rr             JSR     autodr          ;auto drive select
000941r 2  20 rr rr             JSR     inrcct          ;initialize record counters
000944r 2  AD rr rr             LDA     nxtrec          ;if next record less
000947r 2  CD rr rr             CMP     numrec          ;then number records
00094Ar 2  90 13                BCC     tryrde          ;then try to read
00094Cr 2  C9 80                CMP     #128            ;but if not and
00094Er 2  F0 03                BEQ     tryext          ;is max try to extend
000950r 2               rdeeof:
000950r 2  A9 01                LDA     #1              ;else set eof
000952r 2  60                   RTS                     ;code and return
000953r 2               tryext:
000953r 2  A2 01                LDX     #1              ;try for a read
000955r 2  20 rr rr             JSR     extend          ;file extension
000958r 2  C9 00                CMP     #0              ;if not ok exit eof
00095Ar 2  D0 F4                BNE     rdeeof          ;with jump back
00095Cr 2  8D rr rr             STA     nxtrec          ;clear next record
00095Fr 2               tryrde:
00095Fr 2  20 rr rr             JSR     getblk          ;and get block
000962r 2  AD rr rr             LDA     blknum          ;if block not zero
000965r 2  0D rr rr             ORA     blknum+1
000968r 2  D0 03                BNE     dorde           ;do the read
00096Ar 2  A9 02                LDA     #2              ;else set unwritten
00096Cr 2  60                   RTS                     ;code and exit
00096Dr 2               dorde:
00096Dr 2  20 rr rr             JSR     calrcn          ;calculate record number
000970r 2  20 rr rr             JSR     sttrsc          ;set track and sector
000973r 2  20 rr rr             JSR     rdesec          ;do sector read
000976r 2  20 rr rr             JSR     updtrc          ;update counters
000979r 2  A9 00                LDA     #0              ;return w/o error
00097Br 2               extrde:
00097Br 2  60                   RTS
00097Cr 2               ;execute file rename
00097Cr 2               xrenme:
00097Cr 2  20 rr rr             JSR     autodr          ;automatic drive select
00097Fr 2  20 rr rr             JSR     tstron          ;test for r/o
000982r 2  A9 0C                LDA     #12             ;match name
000984r 2  20 rr rr             JSR     frstsr          ;and type
000987r 2  30 14                BMI     extren          ;exit if not found
000989r 2               doren:
000989r 2  A9 00                LDA     #0              ;clear drive select
00098Br 2  A0 10                LDY     #16             ;in new name
00098Dr 2  91 02                STA     (addinp),y      ;part of fcb
00098Fr 2  A9 0C                LDA     #12             ;then move
000991r 2  A2 10                LDX     #16             ;new name
000993r 2  20 rr rr             JSR     dirchg          ;to directory
000996r 2  A9 0C                LDA     #12             ;see if
000998r 2  20 rr rr             JSR     search          ;another match
00099Br 2  10 EC                BPL     doren           ;loop if found
00099Dr 2               extren:
00099Dr 2  60                   RTS                     ;number
00099Er 2               ;execute delete file
00099Er 2               xdltfl:
00099Er 2  20 rr rr             JSR     autodr          ;automatic drive select
0009A1r 2  20 rr rr             JSR     tstron          ;test for r/o
0009A4r 2  A9 0C                LDA     #12             ;match name
0009A6r 2  20 rr rr             JSR     frstsr          ;and type
0009A9r 2  30 17                BMI     extdlt          ;done if not found
0009ABr 2               dodlt:
0009ABr 2  A2 00                LDX     #0              ;else do a
0009ADr 2  20 rr rr             JSR     mapdir          ;delete
0009B0r 2  AC rr rr             LDY     subrec          ;then change
0009B3r 2  AD rr rr             LDA     empty           ;byte zero to
0009B6r 2  91 04                STA     (bufadd),y      ;empty code
0009B8r 2  20 rr rr             JSR     updtck          ;then update directory
0009BBr 2  A9 0C                LDA     #12             ;search
0009BDr 2  20 rr rr             JSR     search          ;for next
0009C0r 2  10 E9                BPL     dodlt           ;loop if found
0009C2r 2               extdlt:
0009C2r 2  60                   RTS                     ;exit
0009C3r 2               ;execute write next record
0009C3r 2               xwrite:
0009C3r 2  20 rr rr             JSR     autodr          ;automatic drive select
0009C6r 2  20 rr rr             JSR     tstron          ;test for r/o
0009C9r 2  20 rr rr             JSR     inrcct          ;initialize counters
0009CCr 2  AD rr rr             LDA     nxtrec          ;get next record
0009CFr 2  C9 80                CMP     #128            ;compare to max
0009D1r 2  90 03                BCC     ntexte          ;continue if less
0009D3r 2  A9 01                LDA     #1              ;else flag as extend
0009D5r 2  60                   RTS                     ;error and exit
0009D6r 2               ntexte:
0009D6r 2  20 rr rr             JSR     getblk          ;calculate block num
0009D9r 2  A9 00                LDA     #0              ;say normal write
0009DBr 2  8D rr rr             STA     pemwrtype       ;for now
0009DEr 2  AD rr rr             LDA     blknum          ;get it and if
0009E1r 2  0D rr rr             ORA     blknum+1
0009E4r 2  F0 03                BEQ     *+5             ;zero then get number
0009E6r 2  4C rr rr             JMP     blkopn          ;else go write
0009E9r 2  A9 02                LDA     #2              ;say unalloc write
0009EBr 2  8D rr rr             STA     pemwrtype
0009EEr 2  AD rr rr             LDA     fcbind          ;get index from prior
0009F1r 2  48                   PHA                     ;and save
0009F2r 2  C9 10                CMP     #16             ;if first block
0009F4r 2  F0 1A                BEQ     isfrst          ;then don't change
0009F6r 2  A8                   TAY                     ;else make an index
0009F7r 2  88                   DEY                     ;point to last
0009F8r 2  2C rr rr             BIT     blmode          ;test mode
0009FBr 2  10 01                BPL     *+3             ;done if byte
0009FDr 2  88                   DEY                     ;else drop for word
0009FEr 2  B1 02                LDA     (addinp),y      ;and get that number
000A00r 2  8D rr rr             STA     blknum          ;store as starting
000A03r 2  C8                   INY                     ;bump for word
000A04r 2  A9 00                LDA     #0              ;preset for byte
000A06r 2  2C rr rr             BIT     blmode          ;test mode
000A09r 2  10 02                BPL     *+4             ;done if byte
000A0Br 2  B1 02                LDA     (addinp),y      ;else get high
000A0Dr 2  8D rr rr             STA     blknum+1        ;then set high
000A10r 2               isfrst:
000A10r 2  AD rr rr             LDA     blknum          ;get block
000A13r 2  8D rr rr             STA     lkdown          ;set lower and
000A16r 2  8D rr rr             STA     lookup          ;upper pointers
000A19r 2  AD rr rr             LDA     blknum+1        ;now set high part
000A1Cr 2  8D rr rr             STA     lkdown+1
000A1Fr 2  8D rr rr             STA     lookup+1
000A22r 2               srblag:
000A22r 2  AD rr rr             LDA     lookup          ;if upper pointer
000A25r 2  CD rr rr             CMP     maxblk          ;not at max
000A28r 2  D0 08                BNE     upnemx          ;then keep going
000A2Ar 2  AC rr rr             LDY     lookup+1        ;now check high
000A2Dr 2  CC rr rr             CPY     maxblk+1
000A30r 2  F0 12                BEQ     tstdwn          ;go test down
000A32r 2               upnemx:
000A32r 2  EE rr rr             INC     lookup          ;else bump upper
000A35r 2  D0 03                BNE     *+5
000A37r 2  EE rr rr             INC     lookup+1
000A3Ar 2  AD rr rr             LDA     lkdown          ;then if lower
000A3Dr 2  0D rr rr             ORA     lkdown+1
000A40r 2  F0 18                BEQ     dotest          ;is zero start test
000A42r 2  D0 0B                BNE     dcdown          ;else drop lower
000A44r 2               tstdwn:
000A44r 2  AD rr rr             LDA     lkdown          ;if upper & lower at
000A47r 2  0D rr rr             ORA     lkdown+1
000A4Ar 2  D0 03                BNE     dcdown          ;drop if not zero
000A4Cr 2  A8                   TAY                     ;also set y
000A4Dr 2  F0 30                BEQ     extsbl          ;then exit
000A4Fr 2               dcdown:
000A4Fr 2  AD rr rr             LDA     lkdown          ;drop lower
000A52r 2  D0 03                BNE     *+5
000A54r 2  CE rr rr             DEC     lkdown+1
000A57r 2  CE rr rr             DEC     lkdown
000A5Ar 2               dotest:
000A5Ar 2  AD rr rr             LDA     lkdown          ;get lower
000A5Dr 2  AC rr rr             LDY     lkdown+1
000A60r 2  20 rr rr             JSR     tstblk          ;and test
000A63r 2  D0 09                BNE     trylup          ;if full try upper
000A65r 2  AD rr rr             LDA     lkdown          ;else use lower
000A68r 2  AC rr rr             LDY     lkdown+1
000A6Br 2  4C rr rr             JMP     extsbl          ;as result
000A6Er 2               trylup:
000A6Er 2  AD rr rr             LDA     lookup          ;get upper
000A71r 2  AC rr rr             LDY     lookup+1
000A74r 2  20 rr rr             JSR     tstblk          ;if full
000A77r 2  D0 A9                BNE     srblag          ;then loop
000A79r 2  AD rr rr             LDA     lookup          ;else use upper
000A7Cr 2  AC rr rr             LDY     lookup+1
000A7Fr 2               extsbl:
000A7Fr 2  8D rr rr             STA     blknum          ;then save number
000A82r 2  8C rr rr             STY     blknum+1
000A85r 2  0D rr rr             ORA     blknum+1        ;see if zero
000A88r 2  D0 04                BNE     gtgood          ;then proceed
000A8Ar 2  68                   PLA                     ;clear stack
000A8Br 2  A9 02                LDA     #2              ;set end
000A8Dr 2  60                   RTS                     ;of data return
000A8Er 2               gtgood:
000A8Er 2  AD rr rr             LDA     blknum          ;get low again
000A91r 2  20 rr rr             JSR     setblk          ;set allocation map
000A94r 2  68                   PLA                     ;get block
000A95r 2  A8                   TAY                     ;pointer back
000A96r 2  AD rr rr             LDA     blknum          ;get number
000A99r 2  91 02                STA     (addinp),y      ;and put in fcb
000A9Br 2  AD rr rr             LDA     blknum+1        ;get high
000A9Er 2  C8                   INY
000A9Fr 2  2C rr rr             BIT     blmode          ;test mode
000AA2r 2  10 02                BPL     *+4             ;done if byte
000AA4r 2  91 02                STA     (addinp),y      ;else set high
000AA6r 2               blkopn:
000AA6r 2  20 rr rr             JSR     calrcn          ;calculate record num
000AA9r 2  20 rr rr             JSR     sttrsc          ;set track and sector
000AACr 2  20 rr rr             JSR     wrtsec          ;do write
000AAFr 2  AE rr rr             LDX     nxtrec          ;get next record
000AB2r 2  EC rr rr             CPX     numrec          ;if less than max
000AB5r 2  90 05                BCC     notful          ;then ok
000AB7r 2  E8                   INX                     ;else bump count
000AB8r 2  8E rr rr             STX     numrec          ;and save
000ABBr 2  CA                   DEX                     ;back down
000ABCr 2               notful:
000ABCr 2  E0 7F                CPX     #127            ;if not at max
000ABEr 2  D0 11                BNE     noawex          ;skip extending
000AC0r 2  20 rr rr             JSR     updtrc          ;update record counters
000AC3r 2  A2 00                LDX     #0              ;do write
000AC5r 2  20 rr rr             JSR     extend          ;file extension
000AC8r 2  C9 00                CMP     #0              ;if not ok
000ACAr 2  D0 0A                BNE     extwrt          ;exit
000ACCr 2  A9 FF                LDA     #255            ;else start counter
000ACEr 2  8D rr rr             STA     nxtrec          ;at one short
000AD1r 2               noawex:
000AD1r 2  20 rr rr             JSR     updtrc          ;then update counters
000AD4r 2  A9 00                LDA     #0              ;good return
000AD6r 2               extwrt:
000AD6r 2  60                   RTS                     ;exit
000AD7r 2               ;execute console input
000AD7r 2               xcnsin:
000AD7r 2  20 rr rr             JSR     getcon          ;get input
000ADAr 2  20 rr rr             JSR     tstchr          ;test it and
000ADDr 2  90 05                BCC     extxci          ;if control exit
000ADFr 2  48                   PHA                     ;else save
000AE0r 2  20 rr rr             JSR     sndchr          ;echo
000AE3r 2  68                   PLA                     ;restore
000AE4r 2               extxci:
000AE4r 2  60                   RTS                     ;return
000AE5r 2               ;switch memory
000AE5r 2               ;page zero block begins at $02 and is numvar bytes long.
000AE5r 2               switch:
000AE5r 2  A2 4F                LDX     #numvar-1       ;get number to switch
000AE7r 2               nxtswh:
000AE7r 2  B5 02                LDA     2,x             ;get zero page
000AE9r 2  BC rr rr             LDY     varblk,x        ;and save area
000AECr 2  9D rr rr             STA     varblk,x        ;save zero
000AEFr 2  94 02                STY     2,x             ;and high
000AF1r 2  CA                   DEX                     ;count down
000AF2r 2  10 F3                BPL     nxtswh          ;and loop until done
000AF4r 2               drvsme:
000AF4r 2  60                   RTS                     ;then return
000AF5r 2               ;change dma address
000AF5r 2               ; input:addinp=address
000AF5r 2               ; returns:none
000AF5r 2               ; alters:all
000AF5r 2               chgdma:
000AF5r 2  A5 02                LDA     addinp          ;get low
000AF7r 2  A4 03                LDY     addinp+1        ;and high address
000AF9r 2  85 04                STA     bufadd          ;then store
000AFBr 2  84 05                STY     bufadd+1        ;in address
000AFDr 2  4C rr rr             JMP     sim+36          ;then go to sim
000B00r 2               
000B00r 2               ;change drive
000B00r 2               ; input:bytinp
000B00r 2               ; returns:none
000B00r 2               ; alters:all
000B00r 2               chgdrv:
000B00r 2  AD rr rr             LDA     bytinp          ;get input
000B03r 2  CD rr rr             CMP     curdrv          ;if same as current
000B06r 2  F0 EC                BEQ     drvsme          ;do nothing
000B08r 2  8D rr rr             STA     curdrv          ;else change current
000B0Br 2  4C rr rr             JMP     mapdrv          ;then log it in
000B0Er 2               ;automatic drive select
000B0Er 2               ; input:(addinp) 0=no change
000B0Er 2               ; 1-8 or 'A'-'H' = change
000B0Er 2               ; returns:none
000B0Er 2               ; alters:all
000B0Er 2               autodr:
000B0Er 2  A0 00                LDY     #0              ;get
000B10r 2  B1 02                LDA     (addinp),y      ;first byte of fcb
000B12r 2  F0 19                BEQ     qtatdr          ;if zero quit
000B14r 2  38                   SEC                     ;set carry for
000B15r 2  E9 01                SBC     #1              ;subtract one
000B17r 2  29 07                AND     #%00000111      ;look at three lsbs
000B19r 2  8D rr rr             STA     bytinp          ;make parameter
000B1Cr 2  AD rr rr             LDA     curdrv          ;get current
000B1Fr 2  8D rr rr             STA     olddrv          ;and save
000B22r 2  B1 02                LDA     (addinp),y      ;get fcb entry
000B24r 2  8D rr rr             STA     tmpdrv          ;and save as flag
000B27r 2  98                   TYA                     ;set a to 0
000B28r 2  91 02                STA     (addinp),y      ;clear byte zero in fcb
000B2Ar 2  20 rr rr             JSR     chgdrv          ;then select new drive
000B2Dr 2               qtatdr:
000B2Dr 2  60                   RTS                     ;and return
000B2Er 2               ;execute initialize system
000B2Er 2               ; input:none
000B2Er 2               ; returns:none
000B2Er 2               ; alters:all,curdrv,lginvc,bufadd
000B2Er 2               xintds:
000B2Er 2  A9 00                LDA     #DEFDRV         ;set current
000B30r 2  8D rr rr             STA     curdrv          ;drive to a
000B33r 2  8D rr rr             STA     lginvc          ;clear log in status
000B36r 2  A9 28                LDA     #<dflbuf        ;get default buffer
000B38r 2  A0 01                LDY     #>dflbuf        ;address
000B3Ar 2  85 02                STA     addinp          ;and set up
000B3Cr 2  84 03                STY     addinp+1        ;parameters
000B3Er 2  20 rr rr             JSR     chgdma          ;change address
000B41r 2               
000B41r 2               ;log in drive and set pointers and maps
000B41r 2               ; input:curdrv
000B41r 2               ; returns:none
000B41r 2               ; alters:all
000B41r 2               mapdrv:
000B41r 2  AD rr rr             LDA     curdrv          ;if current drive
000B44r 2  C9 08                CMP     #8              ;is 0 to 7
000B46r 2  90 0F                BCC     vlddrv          ;then log it in
000B48r 2               drserr:
000B48r 2  20 rr rr             JSR     errout          ;send error message
000B4Br 2  AD rr rr             LDA     sltmvc          ;point to
000B4Er 2  AC rr rr             LDY     sltmvc+1        ;select message
000B51r 2  20 rr rr             JSR     sndstr          ;and send it
000B54r 2               
000B54r 2  4C rr rr             JMP     xwboot          ;and abort
000B57r 2               
000B57r 2               vlddrv:
000B57r 2               ; meep meep meep -- SELF MODIFYING CODE ALERT!
000B57r 2  20 rr rr             JSR     sim+27          ;go to sim to set
000B5Ar 2  8D rr rr             STA     cptdcb+1        ;save
000B5Dr 2  8C rr rr             STY     cptdcb+2
000B60r 2  0D rr rr             ORA     cptdcb+2        ;see if invalid
000B63r 2               
000B63r 2  F0 E3                BEQ     drserr          ;error if is
000B65r 2               ;capture dcb
000B65r 2  A0 0D                LDY     #14-1           ;do 14 bytes
000B67r 2               cptdcb:
000B67r 2  B9 FF FF             LDA     $ffff,y         ;get value from sim
000B6Ar 2  99 rr rr             STA     dcb,y           ;store it
000B6Dr 2  88                   DEY
000B6Er 2  10 F7                BPL     cptdcb          ;loop for more
000B70r 2  AD rr rr             LDA     blkscd          ;get block size code
000B73r 2  A8                   TAY                     ;save in y
000B74r 2  18                   CLC
000B75r 2  69 03                ADC     #3              ;convert to sxb
000B77r 2  8D rr rr             STA     sxb             ;and save
000B7Ar 2  B9 rr rr             LDA     sabtbl,y        ;get sab
000B7Dr 2  8D rr rr             STA     sab             ;and set
000B80r 2  AD rr rr             LDA     maxdir          ;get max dir
000B83r 2  8D rr rr             STA     maxdrc          ;set max dir record
000B86r 2  AD rr rr             LDA     maxdir+1
000B89r 2  4A                   LSR     a               ;divide by 4
000B8Ar 2  6E rr rr             ROR     maxdrc
000B8Dr 2  4A                   LSR     a
000B8Er 2  6E rr rr             ROR     maxdrc
000B91r 2  8D rr rr             STA     maxdrc+1        ;then save high
000B94r 2  A9 00                LDA     #0              ;set mode to byte
000B96r 2  8D rr rr             STA     blmode
000B99r 2  AD rr rr             LDA     maxblk+1        ;branch if max block
000B9Cr 2  F0 05                BEQ     ntm255          ;not over 255
000B9Er 2               ;if y=0 when the following line is executed it means
000B9Er 2               ;that the user has put an illegal combination into
000B9Er 2               ;the disk definition table. may want to consider
000B9Er 2               ;putting some error checking here in the future if
000B9Er 2               ;there is space in pem.
000B9Er 2  88                   DEY                     ;back up index
000B9Fr 2  38                   SEC                     ;else set mode to word
000BA0r 2  6E rr rr             ROR     blmode
000BA3r 2               ntm255:
000BA3r 2  B9 rr rr             LDA     exmtbl,y        ;get extent mask
000BA6r 2  8D rr rr             STA     exm
000BA9r 2               
000BA9r 2  38                   SEC                     ;now calculate cexm1f
000BAAr 2  A9 1F                LDA     #31
000BACr 2  F9 rr rr             SBC     exmtbl,y
000BAFr 2  8D rr rr             STA     cexm1f
000BB2r 2  AE rr rr             LDX     curdrv          ;get drive as pointer
000BB5r 2  BD rr rr             LDA     bitmap,x        ;get bit
000BB8r 2  2D rr rr             AND     lginvc          ;if logged in
000BBBr 2  D0 0C                BNE     extstm          ;then exit
000BBDr 2  BD rr rr             LDA     bitmap,x        ;get bit back
000BC0r 2  0D rr rr             ORA     lginvc          ;set in log-in
000BC3r 2  8D rr rr             STA     lginvc          ;and update
000BC6r 2  4C rr rr             JMP     flinal          ;then fill in maps
000BC9r 2               
000BC9r 2               extstm:
000BC9r 2  60                   RTS                     ;and return
000BCAr 2               ;fill in allocation map
000BCAr 2               flinal:
000BCAr 2  20 rr rr             JSR     setrw           ;set to read/write
000BCDr 2  AD rr rr             LDA     maxblk          ;divide max block by
000BD0r 2  8D rr rr             STA     gpcnt           ;eight to get max
000BD3r 2  AD rr rr             LDA     maxblk+1
000BD6r 2  A2 03                LDX     #3
000BD8r 2               clcnab:
000BD8r 2  4A                   LSR     a               ;use a for speed
000BD9r 2  6E rr rr             ROR     gpcnt
000BDCr 2  CA                   DEX
000BDDr 2  D0 F9                BNE     clcnab          ;loop if more
000BDFr 2  8D rr rr             STA     gpcnt+1         ;save high
000BE2r 2  EE rr rr             INC     gpcnt           ;bump by one
000BE5r 2  D0 03                BNE     *+5
000BE7r 2  EE rr rr             INC     gpcnt+1         ;with carry
000BEAr 2  AD rr rr             LDA     alcmap          ;get map start
000BEDr 2  AC rr rr             LDY     alcmap+1
000BF0r 2  85 06                STA     alcpnt          ;set pointer to start
000BF2r 2  84 07                STY     alcpnt+1
000BF4r 2  A0 00                LDY     #0              ;clear index
000BF6r 2               clraml:
000BF6r 2  A9 00                LDA     #0              ;clear byte
000BF8r 2  91 06                STA     (alcpnt),y      ;put in map
000BFAr 2  E6 06                INC     alcpnt          ;bump pointer
000BFCr 2  D0 02                BNE     *+4
000BFEr 2  E6 07                INC     alcpnt+1        ;with carry
000C00r 2  AD rr rr             LDA     gpcnt           ;get low of count
000C03r 2  D0 03                BNE     *+5             ;skip if not zero
000C05r 2  CE rr rr             DEC     gpcnt+1         ;else drop high
000C08r 2  CE rr rr             DEC     gpcnt           ;always drop low
000C0Br 2  AD rr rr             LDA     gpcnt           ;test for zero
000C0Er 2  0D rr rr             ORA     gpcnt+1
000C11r 2  D0 E3                BNE     clraml          ;loop if more
000C13r 2               ;at this point complete map is cleared
000C13r 2  AD rr rr             LDA     maxdrc          ;get low of max dir record
000C16r 2  8D rr rr             STA     gpcnt
000C19r 2  AD rr rr             LDA     maxdrc+1        ;high in a
000C1Cr 2  AE rr rr             LDX     sxb             ;set x according to block size
000C1Fr 2               clcmdb:
000C1Fr 2  4A                   LSR     a               ;do division
000C20r 2  6E rr rr             ROR     gpcnt
000C23r 2  CA                   DEX
000C24r 2  D0 F9                BNE     clcmdb          ;until x is zero
000C26r 2  8D rr rr             STA     gpcnt+1         ;set high
000C29r 2  EE rr rr             INC     gpcnt           ;then bump by one
000C2Cr 2  D0 03                BNE     *+5
000C2Er 2  EE rr rr             INC     gpcnt+1
000C31r 2  8E rr rr             STX     blknum          ;clear block number
000C34r 2  8E rr rr             STX     blknum+1
000C37r 2               fildal:
000C37r 2  AD rr rr             LDA     blknum          ;get block number
000C3Ar 2  AC rr rr             LDY     blknum+1
000C3Dr 2  20 rr rr             JSR     setblk          ;set bit
000C40r 2  EE rr rr             INC     blknum          ;bump block number
000C43r 2  D0 03                BNE     *+5
000C45r 2  EE rr rr             INC     blknum+1
000C48r 2  AD rr rr             LDA     gpcnt           ;get low of count
000C4Br 2  D0 03                BNE     *+5             ;skip if not zero
000C4Dr 2  CE rr rr             DEC     gpcnt+1         ;else drop high
000C50r 2  CE rr rr             DEC     gpcnt           ;always do low
000C53r 2  AD rr rr             LDA     gpcnt           ;test for zero
000C56r 2  0D rr rr             ORA     gpcnt+1
000C59r 2  D0 DC                BNE     fildal          ;loop if more
000C5Br 2               ;at this point directory space is mapped
000C5Br 2  20 rr rr             JSR     intdrv          ;initialize drive
000C5Er 2  20 rr rr             JSR     cldrnm          ;clear directory number
000C61r 2               
000C61r 2               fillpe:
000C61r 2  A2 01                LDX     #1              ;parameter for fill
000C63r 2  20 rr rr             JSR     nxtdir          ;execute for next directory
000C66r 2  30 11                BMI     extfil          ;done if invalid
000C68r 2  AC rr rr             LDY     subrec          ;get offset
000C6Br 2  B1 04                LDA     (bufadd),y      ;get empty/valid flag
000C6Dr 2  C9 E5                CMP     #$e5            ;if empty
000C6Fr 2  F0 F0                BEQ     fillpe          ;try next
000C71r 2  A2 01                LDX     #1              ;parameter for fill in
000C73r 2  20 rr rr             JSR     mapdir          ;do directory map
000C76r 2  4C rr rr             JMP     fillpe          ;then loop
000C79r 2               extfil:
000C79r 2  60                   RTS                     ;return
000C7Ar 2               ;initialize drive
000C7Ar 2               ; input:nsystr
000C7Ar 2               ; returns:none
000C7Ar 2               ; alters:all
000C7Ar 2               intdrv:
000C7Ar 2  20 rr rr             JSR     sim+24          ;home then
000C7Dr 2  AD rr rr             LDA     nsystr          ;get number of system tracks
000C80r 2  AC rr rr             LDY     nsystr+1
000C83r 2  4C rr rr             JMP     sim+30          ;and set in sim
000C86r 2               
000C86r 2               ;directory record set up
000C86r 2               ; input:dirnum
000C86r 2               ; returns:none
000C86r 2               ; alters:all,recnum,dirrec
000C86r 2               drrcsu:
000C86r 2  AD rr rr             LDA     dirnum+1        ;move high dir number
000C89r 2  8D rr rr             STA     recnum+1        ;to record number
000C8Cr 2  AD rr rr             LDA     dirnum          ;divide
000C8Fr 2  4E rr rr             LSR     recnum+1        ;directory by four
000C92r 2  6A                   ROR     a
000C93r 2  4E rr rr             LSR     recnum+1
000C96r 2  6A                   ROR     a
000C97r 2  8D rr rr             STA     dirrec          ;and save
000C9Ar 2  8D rr rr             STA     recnum          ;set low record number
000C9Dr 2  AD rr rr             LDA     recnum+1        ;get high
000CA0r 2  8D rr rr             STA     dirrec+1        ;and set
000CA3r 2  A9 00                LDA     #0              ;clear top byte
000CA5r 2  8D rr rr             STA     recnum+2
000CA8r 2               ;set track and sector
000CA8r 2               ; input:recnum
000CA8r 2               ; returns:none
000CA8r 2               ; alters:all,countr,trkctr
000CA8r 2               sttrsc:
000CA8r 2  A2 00                LDX     #0              ;clear track counter
000CAAr 2  8E rr rr             STX     trkctr
000CADr 2  8E rr rr             STX     countr          ;and record
000CB0r 2  8E rr rr             STX     countr+1        ;counter
000CB3r 2  8E rr rr             STX     countr+2
000CB6r 2               trnxtr:
000CB6r 2  AD rr rr             LDA     recnum          ;from
000CB9r 2  CD rr rr             CMP     countr          ;record number
000CBCr 2  AD rr rr             LDA     recnum+1        ;and if a
000CBFr 2  ED rr rr             SBC     countr+1        ;borrow then
000CC2r 2  AD rr rr             LDA     recnum+2
000CC5r 2  ED rr rr             SBC     countr+2
000CC8r 2  90 21                BCC     higher          ;gone too far
000CCAr 2  18                   CLC                     ;else
000CCBr 2  AD rr rr             LDA     countr          ;get counter
000CCEr 2  6D rr rr             ADC     sectrk          ;add sectors per track
000CD1r 2  8D rr rr             STA     countr          ;sectors per track
000CD4r 2  AD rr rr             LDA     countr+1
000CD7r 2  6D rr rr             ADC     sectrk+1
000CDAr 2  8D rr rr             STA     countr+1
000CDDr 2  90 03                BCC     bumptr          ;done if no carry
000CDFr 2  EE rr rr             INC     countr+2        ;else bump high
000CE2r 2               bumptr:
000CE2r 2  E8                   INX                     ;increase track count
000CE3r 2  D0 D1                BNE     trnxtr          ;with carry
000CE5r 2  EE rr rr             INC     trkctr
000CE8r 2  4C rr rr             JMP     trnxtr          ;then loop
000CEBr 2               higher:
000CEBr 2  CA                   DEX                     ;back up track
000CECr 2  E0 FF                CPX     #$ff            ;see if wrap around
000CEEr 2  D0 03                BNE     *+5             ;wasn't
000CF0r 2  CE rr rr             DEC     trkctr          ;else drop high
000CF3r 2  8A                   TXA                     ;move to a
000CF4r 2  18                   CLC                     ;add starting track
000CF5r 2  6D rr rr             ADC     nsystr
000CF8r 2  AA                   TAX                     ;save in x
000CF9r 2  AD rr rr             LDA     trkctr
000CFCr 2  6D rr rr             ADC     nsystr+1
000CFFr 2  A8                   TAY                     ;move to correct registers
000D00r 2  8A                   TXA
000D01r 2  20 rr rr             JSR     sim+30          ;then set in sim
000D04r 2               
000D04r 2  38                   SEC                     ;back
000D05r 2  AD rr rr             LDA     countr          ;counter down
000D08r 2  ED rr rr             SBC     sectrk          ;by sectors per track
000D0Br 2  8D rr rr             STA     countr          ;and save
000D0Er 2  AD rr rr             LDA     countr+1
000D11r 2  ED rr rr             SBC     sectrk+1
000D14r 2  8D rr rr             STA     countr+1
000D17r 2  38                   SEC                     ;now
000D18r 2  AD rr rr             LDA     recnum          ;find difference
000D1Br 2  ED rr rr             SBC     countr          ;as sector
000D1Er 2  AA                   TAX                     ;save in x
000D1Fr 2  AD rr rr             LDA     recnum+1
000D22r 2  ED rr rr             SBC     countr+1
000D25r 2  A8                   TAY                     ;move to correct registers
000D26r 2  8A                   TXA
000D27r 2  20 rr rr             JSR     sim+51          ;translate
000D2Ar 2               
000D2Ar 2  4C rr rr             JMP     sim+33          ;and set through sim
000D2Dr 2               
000D2Dr 2               ;get block bit mask and index
000D2Dr 2               ; input:a&y=block number
000D2Dr 2               ; returns:a=bit mask and y=0
000D2Dr 2               ; alters:all and alcpnt
000D2Dr 2               blkmsk:
000D2Dr 2  48                   PHA                     ;save block number
000D2Er 2  84 07                STY     alcpnt+1        ;including high
000D30r 2  A0 03                LDY     #3              ;divide by eight
000D32r 2               blkmlp:
000D32r 2  46 07                LSR     alcpnt+1        ;shift high
000D34r 2  6A                   ROR     a
000D35r 2  88                   DEY                     ;loop until done
000D36r 2  D0 FA                BNE     blkmlp
000D38r 2  18                   CLC                     ;now add map start
000D39r 2  6D rr rr             ADC     alcmap
000D3Cr 2  85 06                STA     alcpnt
000D3Er 2  A5 07                LDA     alcpnt+1
000D40r 2  6D rr rr             ADC     alcmap+1
000D43r 2  85 07                STA     alcpnt+1
000D45r 2  68                   PLA                     ;get number back
000D46r 2  29 07                AND     #%00000111      ;look at 3 lsbs
000D48r 2  AA                   TAX                     ;get
000D49r 2  BD rr rr             LDA     bitmsk,x        ;mask
000D4Cr 2  60                   RTS                     ;and return
000D4Dr 2               ;test block
000D4Dr 2               ; input:a&y=block number
000D4Dr 2               ; returns:z=1 if unassigned
000D4Dr 2               ; 	   =0 if assigned and bit in a is set
000D4Dr 2               ; alters:all
000D4Dr 2               tstblk:
000D4Dr 2  20 rr rr             JSR     blkmsk          ;get mask and index
000D50r 2  31 06                AND     (alcpnt),y      ;mask with map entry
000D52r 2  60                   RTS                     ;then return
000D53r 2               ;alter block status
000D53r 2               ; input:a&y=block number,x=1 if set
000D53r 2               ;		   	  =0 if reset
000D53r 2               ; returns:none
000D53r 2               ; alters:all and allocation map
000D53r 2               altalc:
000D53r 2  E0 01                CPX     #1              ;if set
000D55r 2  F0 0A                BEQ     setblk          ;go do it
000D57r 2               clrblk:
000D57r 2  20 rr rr             JSR     blkmsk          ;else get mask
000D5Ar 2  49 FF                EOR     #$ff            ;and complement
000D5Cr 2  31 06                AND     (alcpnt),y      ;preserve others
000D5Er 2  91 06                STA     (alcpnt),y      ;and save
000D60r 2  60                   RTS                     ;then return
000D61r 2               setblk:
000D61r 2  20 rr rr             JSR     blkmsk          ;get mask
000D64r 2  11 06                ORA     (alcpnt),y      ;set bit
000D66r 2  91 06                STA     (alcpnt),y      ;and put back
000D68r 2  60                   RTS                     ;then return
000D69r 2               ;set current drive to read only
000D69r 2               ; input:curdrv,ronlst,bitmap
000D69r 2               ; returns:none
000D69r 2               ; alters:a,x,p and ronlst
000D69r 2               setron:
000D69r 2  AE rr rr             LDX     curdrv          ;get number
000D6Cr 2  BD rr rr             LDA     bitmap,x        ;and get mask
000D6Fr 2  0D rr rr             ORA     ronlst          ;or with status
000D72r 2  8D rr rr             STA     ronlst          ;and put back
000D75r 2  60                   RTS                     ;then return
000D76r 2               ;calculate checksum of buffer @ bufadd
000D76r 2               ; input: buffer@(bufadd)
000D76r 2               ; returns:a=checksum
000D76r 2               ; alters:a,y,p
000D76r 2               clcchk:
000D76r 2  A9 00                LDA     #0              ;clear accumulator
000D78r 2  A0 7F                LDY     #127            ;start at end
000D7Ar 2               chkmre:
000D7Ar 2  18                   CLC                     ;no carry
000D7Br 2  71 04                ADC     (bufadd),y      ;add byte
000D7Dr 2  88                   DEY                     ;count down
000D7Er 2  10 FA                BPL     chkmre          ;and loop until done
000D80r 2  60                   RTS                     ;then return
000D81r 2               ;check read/write status
000D81r 2               ; input:curdrv,ronlst
000D81r 2               ; returns:z=0 if r/o or z=1 if r/w
000D81r 2               ; alters:a,x,p
000D81r 2               chkron:
000D81r 2  AE rr rr             LDX     curdrv          ;get current drive
000D84r 2  BD rr rr             LDA     bitmap,x        ;get mask
000D87r 2  2D rr rr             AND     ronlst          ;and test status
000D8Ar 2  60                   RTS
000D8Br 2               ;initialize record counters from fcb
000D8Br 2               ; input:fcb@(addinp)
000D8Br 2               ; returns:none
000D8Br 2               ; alters:a,y,p,nxtrec,numrec
000D8Br 2               inrcct:
000D8Br 2  A0 20                LDY     #32             ;next record offset
000D8Dr 2  B1 02                LDA     (addinp),y      ;get next record
000D8Fr 2  8D rr rr             STA     nxtrec          ;and save
000D92r 2  A0 0F                LDY     #15             ;number records offset
000D94r 2  B1 02                LDA     (addinp),y      ;get number
000D96r 2  8D rr rr             STA     numrec          ;and save
000D99r 2  60                   RTS                     ;and return
000D9Ar 2               ;update record counters in fcb
000D9Ar 2               ; input:nxtrec,numrec
000D9Ar 2               ; returns:none
000D9Ar 2               ; alters:all,fcb@(addinp)
000D9Ar 2               updtrc:
000D9Ar 2  AE rr rr             LDX     nxtrec          ;get next record
000D9Dr 2  E8                   INX                     ;bump it
000D9Er 2  8A                   TXA                     ;transfer
000D9Fr 2  A0 20                LDY     #32             ;set offset
000DA1r 2  91 02                STA     (addinp),y      ;and store in fcb
000DA3r 2  AD rr rr             LDA     numrec          ;get number
000DA6r 2  A0 0F                LDY     #15             ;and its offset
000DA8r 2  91 02                STA     (addinp),y      ;and store
000DAAr 2  60                   RTS                     ;then return
000DABr 2               ;execute open file
000DABr 2               xopen:
000DABr 2  20 rr rr             JSR     autodr          ;auto drive select
000DAEr 2               ;open file
000DAEr 2               ; input:fcb @ (addinp)
000DAEr 2               ; returns:n=1 if not found,a=dirmod (255 if not found)
000DAEr 2               ; alters:all
000DAEr 2               opnfle:
000DAEr 2  20 rr rr             JSR     fndf13          ;match all including extent
000DB1r 2  30 32                BMI     extopn          ;done if not found
000DB3r 2  A9 0C                LDA     #12             ;point to first char
000DB5r 2  0D rr rr             ORA     subrec          ;add offset
000DB8r 2  A8                   TAY                     ;make it a pointer
000DB9r 2               nxopmv:
000DB9r 2  B1 04                LDA     (bufadd),y      ;get buffer contents
000DBBr 2  AA                   TAX                     ;and save
000DBCr 2  98                   TYA                     ;save index
000DBDr 2  29 1F                AND     #%00011111      ;remove offset
000DBFr 2  A8                   TAY                     ;back to index
000DC0r 2  8A                   TXA                     ;get byte back
000DC1r 2  91 02                STA     (addinp),y      ;and store in fcb
000DC3r 2  98                   TYA                     ;get index
000DC4r 2  0D rr rr             ORA     subrec          ;add offset back
000DC7r 2  A8                   TAY                     ;and make index again
000DC8r 2  C8                   INY                     ;next position
000DC9r 2  98                   TYA                     ;if index
000DCAr 2  29 1F                AND     #%00011111      ;not gone past
000DCCr 2  D0 EB                BNE     nxopmv          ;end then loop
000DCEr 2               ;now correct extent and max records
000DCEr 2  A0 0C                LDY     #12             ;point at extent in fcb
000DD0r 2  AD rr rr             LDA     savext          ;get save from search
000DD3r 2  D1 02                CMP     (addinp),y      ;compare
000DD5r 2  F0 0B                BEQ     extsme          ;jump ahead if same
000DD7r 2  91 02                STA     (addinp),y      ;else change extent
000DD9r 2  A9 80                LDA     #128            ;assume fcb ext < dir ext
000DDBr 2  90 01                BCC     fcbxls          ;jump ahead if true
000DDDr 2  0A                   ASL     a               ;clear a
000DDEr 2               fcbxls:
000DDEr 2  A0 0F                LDY     #15             ;point to max
000DE0r 2  91 02                STA     (addinp),y      ;and set
000DE2r 2               extsme:
000DE2r 2  AD rr rr             LDA     dirmod          ;else get number
000DE5r 2               extopn:
000DE5r 2  60                   RTS                     ;and return
000DE6r 2               ;execute close file
000DE6r 2               xclose:
000DE6r 2  20 rr rr             JSR     autodr          ;auto drive select
000DE9r 2               ;close file
000DE9r 2               ;if file is r/o then no actual close
000DE9r 2               ;operation is performed.
000DE9r 2               ; input:fcb @ (addinp)
000DE9r 2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
000DE9r 2               ; alters:all
000DE9r 2               clsfle:
000DE9r 2  20 rr rr             JSR     fndf13          ;match including extent
000DECr 2  30 1B                BMI     extcls          ;exit if not found
000DEEr 2  20 rr rr             JSR     chkron          ;see if r/o
000DF1r 2  D0 13                BNE     noclse          ;branch if is
000DF3r 2               ;now set flag to ensure directory extent and number of
000DF3r 2               ;records fields are only changed if necessary.
000DF3r 2               ;The decision to change is determined by whether or
000DF3r 2               ;not the system is closing an extent less than the
000DF3r 2               ;maximum extent in the directory entry. If that is
000DF3r 2               ;the case, the directory extent and number of record
000DF3r 2               ;fields are not changed.
000DF3r 2  A0 0C                LDY     #12             ;get extent
000DF5r 2  B1 02                LDA     (addinp),y
000DF7r 2  48                   PHA                     ;save it
000DF8r 2  98                   TYA                     ;now look in directory
000DF9r 2  0D rr rr             ORA     subrec
000DFCr 2  A8                   TAY
000DFDr 2  68                   PLA                     ;get extent back
000DFEr 2  D1 04                CMP     (bufadd),y
000E00r 2  6E rr rr             ROR     skpdir          ;save result
000E03r 2               ;now go do it
000E03r 2  20 rr rr             JSR     updtdr          ;update directory
000E06r 2               noclse:
000E06r 2  AD rr rr             LDA     dirmod          ;get directory number
000E09r 2               extcls:
000E09r 2  60                   RTS                     ;and return
000E0Ar 2               ;execute find first match
000E0Ar 2               xfndfr:
000E0Ar 2  20 rr rr             JSR     autodr          ;auto drive select
000E0Dr 2               fndf13:
000E0Dr 2  A9 0D                LDA     #13             ;match including extent
000E0Fr 2               ;search for first match
000E0Fr 2               ; input:a=number char to match
000E0Fr 2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
000E0Fr 2               ; alters:all
000E0Fr 2               frstsr:
000E0Fr 2  48                   PHA                     ;save number to match
000E10r 2  20 rr rr             JSR     cldrnm          ;clear directory number to -1
000E13r 2  20 rr rr             JSR     intdrv          ;and drive
000E16r 2  68                   PLA                     ;get number to match
000E17r 2               ;search for directory match
000E17r 2               ; input:a=number char to match
000E17r 2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
000E17r 2               ; alters:all
000E17r 2               search:
000E17r 2  8D rr rr             STA     chrcnt          ;save number
000E1Ar 2               newtry:
000E1Ar 2  A2 00                LDX     #0              ;set for search
000E1Cr 2  8E rr rr             STX     cmppnt          ;clear pointer
000E1Fr 2  20 rr rr             JSR     nxtdir          ;get next entry
000E22r 2  30 37                BMI     exitsr          ;exit if not found
000E24r 2  AE rr rr             LDX     chrcnt          ;get count
000E27r 2               mremch:
000E27r 2  AC rr rr             LDY     cmppnt          ;get pointer
000E2Ar 2  EE rr rr             INC     cmppnt          ;and bump
000E2Dr 2  B1 02                LDA     (addinp),y      ;get fcb entry
000E2Fr 2  C0 0C                CPY     #12             ;see if at extent
000E31r 2  D0 13                BNE     notaex          ;jump if not
000E33r 2  8D rr rr             STA     savext          ;save for later use
000E36r 2  48                   PHA                     ;save extent
000E37r 2  98                   TYA                     ;change to directory
000E38r 2  0D rr rr             ORA     subrec          ;coordinates
000E3Br 2  A8                   TAY
000E3Cr 2  68                   PLA                     ;get extent back
000E3Dr 2  51 04                EOR     (bufadd),y      ;exclusive or with dir
000E3Fr 2  2D rr rr             AND     cexm1f          ;and with exm complement + 1f
000E42r 2  F0 11                BEQ     trynxt          ;ok if zero
000E44r 2  D0 D4                BNE     newtry          ;else get next directory
000E46r 2               notaex:
000E46r 2  C9 3F                CMP     #'?'            ;if a ? then
000E48r 2  F0 0B                BEQ     trynxt          ;is a match
000E4Ar 2  48                   PHA                     ;save char
000E4Br 2  98                   TYA                     ;then add
000E4Cr 2  0D rr rr             ORA     subrec          ;offset to
000E4Fr 2  A8                   TAY                     ;make pointer
000E50r 2  68                   PLA                     ;get char back
000E51r 2               ;        sta     savex
000E51r 2               ;        lda	(bufadd),y	;if not same
000E51r 2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
000E51r 2               ;	cmp	savex	        ;if not same
000E51r 2  D1 04                CMP     (bufadd),y      ;if not same
000E53r 2  D0 C5                BNE     newtry          ;try next directory
000E55r 2               trynxt:
000E55r 2  CA                   DEX                     ;else count number down
000E56r 2  D0 CF                BNE     mremch          ;and loop if more
000E58r 2  AD rr rr             LDA     dirmod          ;return with directory
000E5Br 2               exitsr:
000E5Br 2  60                   RTS                     ;number mod 4
000E5Cr 2               ;calculate logical record number
000E5Cr 2               ; input:blknum
000E5Cr 2               ; returns:none
000E5Cr 2               ; alters:a,x,p,recnum
000E5Cr 2               calrcn:
000E5Cr 2  AE rr rr             LDX     sxb             ;set x according to blkscd
000E5Fr 2               mulmre:
000E5Fr 2  0E rr rr             ASL     blknum          ;multiply block
000E62r 2  2E rr rr             ROL     blknum+1        ;number
000E65r 2  2E rr rr             ROL     blknum+2
000E68r 2  CA                   DEX                     ;by code
000E69r 2  D0 F4                BNE     mulmre
000E6Br 2  AD rr rr             LDA     sab             ;set mask in a
000E6Er 2  2D rr rr             AND     nxtrec          ;and with next record
000E71r 2  0D rr rr             ORA     recnum          ;or with number
000E74r 2  8D rr rr             STA     recnum          ;and save
000E77r 2  60                   RTS
000E78r 2               ;update directory
000E78r 2               updtdr:
000E78r 2  A9 20                LDA     #32             ;change all
000E7Ar 2  A2 00                LDX     #0              ;from start
000E7Cr 2               ;change directory entry
000E7Cr 2               ; input:a=number char to change,x=starting position,fcb@(addinp)
000E7Cr 2               ; returns:none
000E7Cr 2               ; alters:all,directory,checksums
000E7Cr 2               dirchg:
000E7Cr 2  8D rr rr             STA     chrcnt          ;save count
000E7Fr 2  CE rr rr             DEC     chrcnt          ;back up
000E82r 2               mrechg:
000E82r 2  18                   CLC                     ;clear carry
000E83r 2  8A                   TXA                     ;get offset
000E84r 2  6D rr rr             ADC     chrcnt          ;compute index
000E87r 2  A8                   TAY                     ;and set
000E88r 2  C0 0C                CPY     #12             ;see if at extent
000E8Ar 2  F0 04                BEQ     docare          ;if so do special
000E8Cr 2  C0 0F                CPY     #15             ;see if at number rec
000E8Er 2  D0 05                BNE     dntcar          ;if not skip
000E90r 2               docare:
000E90r 2  2C rr rr             BIT     skpdir          ;check flag
000E93r 2  10 0D                BPL     nochng          ;skip if ok
000E95r 2               dntcar:
000E95r 2  B1 02                LDA     (addinp),y      ;get char
000E97r 2  48                   PHA                     ;save it
000E98r 2  AD rr rr             LDA     chrcnt          ;get count
000E9Br 2  0D rr rr             ORA     subrec          ;add offset
000E9Er 2  A8                   TAY                     ;make an index
000E9Fr 2  68                   PLA                     ;get char back
000EA0r 2  91 04                STA     (bufadd),y      ;and put in buffer
000EA2r 2               nochng:
000EA2r 2  CE rr rr             DEC     chrcnt          ;count down
000EA5r 2  10 DB                BPL     mrechg          ;and loop
000EA7r 2  20 rr rr             JSR     drrcsu          ;set it up
000EAAr 2  4C rr rr             JMP     updtck          ;and do change
000EADr 2               ;execute create file
000EADr 2               xmake:
000EADr 2  20 rr rr             JSR     autodr          ;auto drive select
000EB0r 2               ;create file
000EB0r 2               ; input:fcb@(addinp)
000EB0r 2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
000EB0r 2               ; alters:dirnum,dirmod,fcb@(addinp)
000EB0r 2               mkefle:
000EB0r 2  20 rr rr             JSR     tstron          ;test for r/o
000EB3r 2  A5 02                LDA     addinp          ;save fcb
000EB5r 2  48                   PHA                     ;address
000EB6r 2  A5 03                LDA     addinp+1        ;on
000EB8r 2  48                   PHA                     ;stack
000EB9r 2  AD rr rr             LDA     empdvc          ;then point
000EBCr 2  AC rr rr             LDY     empdvc+1        ;to empty
000EBFr 2  85 02                STA     addinp          ;dummy
000EC1r 2  84 03                STY     addinp+1        ;fcb
000EC3r 2  A9 01                LDA     #1              ;match only
000EC5r 2  20 rr rr             JSR     frstsr          ;first char
000EC8r 2  68                   PLA                     ;restore
000EC9r 2  85 03                STA     addinp+1        ;fcb
000ECBr 2  68                   PLA                     ;address
000ECCr 2  85 02                STA     addinp          ;from stack
000ECEr 2  AD rr rr             LDA     dirmod          ;get number mod 4
000ED1r 2  30 15                BMI     extmke          ;quit if not found
000ED3r 2  A0 0D                LDY     #13             ;else set up
000ED5r 2  A9 00                LDA     #0              ;to clear
000ED7r 2               mkeagn:
000ED7r 2  91 02                STA     (addinp),y      ;rest of
000ED9r 2  C8                   INY                     ;fcb
000EDAr 2  C0 21                CPY     #33             ;including next
000EDCr 2  D0 F9                BNE     mkeagn          ;record
000EDEr 2               ;the next two lines ensure that the extent and
000EDEr 2               ;number of records fields are updated
000EDEr 2  38                   SEC
000EDFr 2  6E rr rr             ROR     skpdir
000EE2r 2  20 rr rr             JSR     updtdr          ;update directory
000EE5r 2  AD rr rr             LDA     dirmod          ;get number
000EE8r 2               extmke:
000EE8r 2  60                   RTS                     ;and quit
000EE9r 2               
000EE9r 2               
000EE9r 2               ;extend file
000EE9r 2               ; input:fcb@(addinp), x=1 read
000EE9r 2               ;		        0 write
000EE9r 2               extend:
000EE9r 2  8E rr rr             STX     exrwfl          ;save parameter
000EECr 2  20 rr rr             JSR     clsfle          ;close current extent
000EEFr 2  30 2A                BMI     extext          ;exit if not found
000EF1r 2  A0 0C                LDY     #12             ;else
000EF3r 2  B1 02                LDA     (addinp),y      ;get extent
000EF5r 2  18                   CLC                     ;and
000EF6r 2  69 01                ADC     #1              ;add one
000EF8r 2  29 1F                AND     #%00011111      ;see if overflow
000EFAr 2  F0 17                BEQ     exteof          ;eof if so
000EFCr 2  91 02                STA     (addinp),y      ;and save
000EFEr 2  20 rr rr             JSR     fndf13          ;see if next extent exists
000F01r 2  10 0B                BPL     opnext          ;if so open
000F03r 2  AD rr rr             LDA     exrwfl          ;if not and is write then create
000F06r 2  D0 13                BNE     extext          ;else return as eof
000F08r 2               dwrtex:
000F08r 2  20 rr rr             JSR     mkefle          ;create file
000F0Br 2  4C rr rr             JMP     tstext          ;and test
000F0Er 2               opnext:
000F0Er 2  20 rr rr             JSR     opnfle          ;open
000F11r 2               tstext:
000F11r 2  10 03                BPL     extnok          ;continue if ok
000F13r 2               exteof:
000F13r 2  A9 01                LDA     #1              ;else set eof
000F15r 2  60                   RTS                     ;and return
000F16r 2               extnok:
000F16r 2  20 rr rr             JSR     inrcct          ;initialize counters
000F19r 2  A9 00                LDA     #0              ;good
000F1Br 2               extext:
000F1Br 2  60                   RTS                     ;return
000F1Cr 2               ;set up next directory block
000F1Cr 2               ; input:dirnum,x=1 for update checksum
000F1Cr 2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
000F1Cr 2               ; alters:alll,dirnum,dirmod
000F1Cr 2               nxtdir:
000F1Cr 2  8A                   TXA                     ;save operation
000F1Dr 2  48                   PHA                     ;on stack
000F1Er 2  EE rr rr             INC     dirnum          ;bump directory
000F21r 2  D0 03                BNE     *+5
000F23r 2  EE rr rr             INC     dirnum+1
000F26r 2               
000F26r 2  AD rr rr             LDA     maxdir          ;if not at limit continue
000F29r 2  CD rr rr             CMP     dirnum
000F2Cr 2  AD rr rr             LDA     maxdir+1
000F2Fr 2  ED rr rr             SBC     dirnum+1
000F32r 2  B0 05                BCS     gtnxdr          ;then continue
000F34r 2  68                   PLA                     ;else clear stack
000F35r 2  AA                   TAX                     ;and set x
000F36r 2  4C rr rr             JMP     cldrnm          ;set to invalid
000F39r 2               gtnxdr:
000F39r 2  AD rr rr             LDA     dirnum          ;get low again
000F3Cr 2  29 03                AND     #%00000011      ;look at 2 lsbs
000F3Er 2  8D rr rr             STA     dirmod          ;save mod 4
000F41r 2  0A                   ASL     a               ;multiply
000F42r 2  0A                   ASL     a               ;by
000F43r 2  0A                   ASL     a               ;32 to
000F44r 2  0A                   ASL     a               ;get pointer
000F45r 2  0A                   ASL     a               ;offset
000F46r 2  8D rr rr             STA     subrec          ;and save
000F49r 2  F0 05                BEQ     getdir          ;if zero read new
000F4Br 2  68                   PLA                     ;else clear stack
000F4Cr 2  AA                   TAX                     ;set x
000F4Dr 2  4C rr rr             JMP     gotdir          ;and exit
000F50r 2               getdir:
000F50r 2  20 rr rr             JSR     drrcsu          ;set up to read
000F53r 2  20 rr rr             JSR     rdesec          ;do read
000F56r 2  68                   PLA                     ;get operation
000F57r 2  AA                   TAX                     ;code
000F58r 2               ;;;;;;	jsr	chksop		;do it
000F58r 2               gotdir:
000F58r 2  AD rr rr             LDA     dirmod          ;and return
000F5Br 2               exnxdr:
000F5Br 2  60                   RTS                     ;with number
000F5Cr 2               ;checksum operation
000F5Cr 2               ;this routine assumes calling routine has checked for
000F5Cr 2               ;valid dirnum and hence valid dirrec
000F5Cr 2               ; input:chkflg,dirrec,x (1=update else check)
000F5Cr 2               ; returns:none
000F5Cr 2               ; alters:map@(chkmap)
000F5Cr 2               chksop:
000F5Cr 2  60                   rts
000F5Dr 2  2C rr rr             BIT     chkflg          ;check flag
000F60r 2  30 F9                BMI     exnxdr          ;done if set
000F62r 2  CA                   DEX                     ;dec code
000F63r 2  D0 09                BNE     tstchk          ;if not zero test
000F65r 2  20 rr rr             JSR     clcchk          ;else calculate
000F68r 2  20 rr rr             JSR     clcckp          ;calculate pointer
000F6Br 2  91 08                STA     (chkpnt),y      ;and save
000F6Dr 2  60                   RTS                     ;then return
000F6Er 2               tstchk:
000F6Er 2  20 rr rr             JSR     clcchk          ;do calculation
000F71r 2  20 rr rr             JSR     clcckp          ;calculate pointer
000F74r 2  D1 08                CMP     (chkpnt),y      ;compare to old
000F76r 2  F0 E3                BEQ     exnxdr          ;if equal ok
000F78r 2  4C rr rr             JMP     setron          ;else set to r/o
000F7Br 2               ;get block number
000F7Br 2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
000F7Br 2               ; returns:none
000F7Br 2               ; alters:all,blknum
000F7Br 2               getblk:
000F7Br 2  AE rr rr             LDX     sxb             ;set x according to blkscd
000F7Er 2  AD rr rr             LDA     nxtrec          ;get next record
000F81r 2               gblp:
000F81r 2  4A                   LSR     a               ;divide by 2 x times
000F82r 2  CA                   DEX
000F83r 2  D0 FC                BNE     gblp
000F85r 2  8D rr rr             STA     blknum          ;save previous as temp
000F88r 2               ;use extent as offset but first use sxb to create param
000F88r 2  38                   SEC
000F89r 2  A9 08                LDA     #8
000F8Br 2  ED rr rr             SBC     sxb
000F8Er 2  AA                   TAX
000F8Fr 2               ;now get extent from fcb
000F8Fr 2  A0 0C                LDY     #12
000F91r 2  B1 02                LDA     (addinp),y
000F93r 2  2D rr rr             AND     exm             ;and with mask
000F96r 2  4A                   LSR     a               ;shift with lsb to c
000F97r 2               gbxlp:
000F97r 2  2A                   ROL     a               ;now go other way
000F98r 2  CA                   DEX
000F99r 2  D0 FC                BNE     gbxlp
000F9Br 2  18                   CLC                     ;now add saved value
000F9Cr 2  6D rr rr             ADC     blknum          ;back
000F9Fr 2  2C rr rr             BIT     blmode          ;test mode
000FA2r 2  10 01                BPL     *+3             ;skip if byte
000FA4r 2  0A                   ASL     a               ;else times two
000FA5r 2  18                   CLC                     ;then add
000FA6r 2  69 10                ADC     #16             ;offset into fcb
000FA8r 2  8D rr rr             STA     fcbind          ;save for later
000FABr 2  A8                   TAY                     ;set index
000FACr 2  B1 02                LDA     (addinp),y      ;get number
000FAEr 2  8D rr rr             STA     blknum          ;store
000FB1r 2  C8                   INY
000FB2r 2  A9 00                LDA     #0              ;clear
000FB4r 2  2C rr rr             BIT     blmode          ;test mode
000FB7r 2  10 02                BPL     *+4             ;skip if byte
000FB9r 2  B1 02                LDA     (addinp),y      ;else get high
000FBBr 2  8D rr rr             STA     blknum+1        ;high byte
000FBEr 2  60                   RTS                     ;and return
000FBFr 2               
000FBFr 2                       .IFDEF  DUODYNE
000FBFr 2                       .RES    100
000FBFr 2                       .ENDIF
000FBFr 2               
000FBFr 2               ;calculate chkpnt as function of dirrec and chkmap
000FBFr 2               ; input:dirrec,chkmap
000FBFr 2               ; returns:y=0
000FBFr 2               ; alters:y,p,chkpnt
000FBFr 2               clcckp:
000FBFr 2  48                   PHA                     ;save a
000FC0r 2  18                   CLC
000FC1r 2  AD rr rr             LDA     dirrec          ;add record number
000FC4r 2  6D rr rr             ADC     chkmap          ;to start
000FC7r 2  85 08                STA     chkpnt
000FC9r 2  AD rr rr             LDA     dirrec+1
000FCCr 2  6D rr rr             ADC     chkmap+1
000FCFr 2  85 09                STA     chkpnt+1
000FD1r 2  A0 00                LDY     #0
000FD3r 2  68                   PLA                     ;get a back
000FD4r 2  60                   RTS
000FD5r 2               ;clear directory number to $ffff
000FD5r 2               ; input:none
000FD5r 2               ; returns:a=$ff,n=1,z=0
000FD5r 2               ; alters:a,p,dirnum,dirmod
000FD5r 2               cldrnm:
000FD5r 2  A9 FF                LDA     #$ff            ;set to $ff
000FD7r 2  8D rr rr             STA     dirnum
000FDAr 2  8D rr rr             STA     dirnum+1
000FDDr 2  8D rr rr             STA     dirmod
000FE0r 2  60                   RTS
000FE1r 2               ;change allocation map
000FE1r 2               ; input:subrec,directory record @ (bufadd)
000FE1r 2               ; returns:none
000FE1r 2               ; alters:all,allocation map
000FE1r 2               mapdir:
000FE1r 2  18                   CLC                     ;add 16 to
000FE2r 2  AD rr rr             LDA     subrec          ;to subrec to point
000FE5r 2  69 10                ADC     #16             ;to block number field
000FE7r 2  A8                   TAY                     ;make index
000FE8r 2               lpmpdr:
000FE8r 2  8C rr rr             STY     mpdrsy          ;save index
000FEBr 2  8A                   TXA                     ;save x
000FECr 2  48                   PHA                     ;operation
000FEDr 2  B1 04                LDA     (bufadd),y      ;get block number
000FEFr 2  8D rr rr             STA     mpdrtm          ;save in temp
000FF2r 2  C8                   INY                     ;bump index for word
000FF3r 2  20 rr rr             JSR     gthibn          ;get high part of number
000FF6r 2               mpdrnw:
000FF6r 2  0D rr rr             ORA     mpdrtm          ;see if zero
000FF9r 2  F0 0A                BEQ     skpedr          ;skip if zero
000FFBr 2  20 rr rr             JSR     gthibn          ;get high again
000FFEr 2  A8                   TAY                     ;move to y
000FFFr 2  AD rr rr             LDA     mpdrtm          ;get low again
001002r 2  20 rr rr             JSR     altalc          ;else alter map
001005r 2               skpedr:
001005r 2  68                   PLA                     ;get operation
001006r 2  AA                   TAX                     ;back
001007r 2  AC rr rr             LDY     mpdrsy          ;get index back
00100Ar 2  C8                   INY                     ;bump it
00100Br 2  98                   TYA                     ;if still
00100Cr 2  29 0F                AND     #%00001111      ;in field
00100Er 2  D0 D8                BNE     lpmpdr          ;then loop
001010r 2  60                   RTS                     ;else quit
001011r 2               ;test r/w status
001011r 2               ;does warm boot if r/o
001011r 2               ; input:curdrv,ronlst
001011r 2               ; returns:none
001011r 2               ; alters:a,x,p
001011r 2               tstron:
001011r 2  20 rr rr             JSR     chkron          ;test bit
001014r 2  F0 1D                BEQ     exttro          ;exit if r/w
001016r 2  20 rr rr             JSR     errout          ;else send error
001019r 2  AD rr rr             LDA     rommvc          ;point to r/o
00101Cr 2  AC rr rr             LDY     rommvc+1        ;message
00101Fr 2  20 rr rr             JSR     sndstr          ;send it
001022r 2  4C rr rr             JMP     xwboot          ;then abort
001025r 2               ;set current drive to r/w
001025r 2               ; input:curdrv,ronlst
001025r 2               ; returns:ronlst
001025r 2               ; alters:a,x,p,ronlst
001025r 2               setrw:
001025r 2  AE rr rr             LDX     curdrv          ;get drive
001028r 2  BD rr rr             LDA     bitmap,x        ;and mask
00102Br 2  49 FF                EOR     #$ff            ;complement
00102Dr 2  2D rr rr             AND     ronlst          ;and with status
001030r 2  8D rr rr             STA     ronlst          ;save
001033r 2               exttro:
001033r 2  60                   RTS                     ;return
001034r 2               ;read sector
001034r 2               rdesec:
001034r 2  20 rr rr             JSR     sim+39          ;do read
001037r 2               
001037r 2  4C rr rr             JMP     chkrwe          ;check for error
00103Ar 2               ;update checksum and directory
00103Ar 2               updtck:
00103Ar 2  A2 01                LDX     #1              ;set for update
00103Cr 2               ;;;;;	jsr	chksop		;do it
00103Cr 2  A9 01                LDA     #1              ;say is directory op
00103Er 2  D0 03                BNE     secwrt          ;do it
001040r 2               ;write sector
001040r 2               wrtsec:
001040r 2  AD rr rr             LDA     pemwrtype       ;get write type
001043r 2               secwrt:
001043r 2  20 rr rr             JSR     sim+42          ;do write
001046r 2               
001046r 2               chkrwe:
001046r 2  C9 00                CMP     #0              ;if not ok
001048r 2  F0 E9                BEQ     exttro          ;done if zero
00104Ar 2               ;read/write error
00104Ar 2               rwerrt:
00104Ar 2  20 rr rr             JSR     errout          ;send error message
00104Dr 2  AD rr rr             LDA     bdsmvc          ;point to
001050r 2  AC rr rr             LDY     bdsmvc+1        ;bad sector message
001053r 2  20 rr rr             JSR     sndstr          ;and send
001056r 2  20 rr rr             JSR     getcon          ;get input
001059r 2  C9 0D                CMP     #cr             ;if a cr
00105Br 2  F0 03                BEQ     ignerr          ;then continue
00105Dr 2  4C rr rr             JMP     xwboot          ;else abort
001060r 2               ignerr:
001060r 2  4C rr rr             JMP     pcrlf           ;crlf and return
001063r 2               ;error output routine
001063r 2               ; input:curdrv,pemmvc
001063r 2               ; returns:none
001063r 2               ; alters:all
001063r 2               errout:
001063r 2  AD rr rr             LDA     pemmvc          ;point to
001066r 2  AC rr rr             LDY     pemmvc+1        ;error message
001069r 2  20 rr rr             JSR     sndstr          ;send it
00106Cr 2  AD rr rr             LDA     curdrv          ;get drive number
00106Fr 2  18                   CLC                     ;add
001070r 2  69 41                ADC     #'A'            ;ascii a
001072r 2  4C rr rr             JMP     sndchr          ;and send it
001075r 2               ;get high part of block number if word (zero if byte)
001075r 2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
001075r 2               ; returns:a=high part of block number
001075r 2               ; alters:a,p,mpdrsy iff word
001075r 2               gthibn:
001075r 2  A9 00                LDA     #0              ;preset for byte
001077r 2  2C rr rr             BIT     blmode          ;test mode
00107Ar 2  10 05                BPL     gthiex          ;done if byte
00107Cr 2  B1 04                LDA     (bufadd),y      ;get high
00107Er 2  8C rr rr             STY     mpdrsy          ;alter y
001081r 2               gthiex:
001081r 2  60                   RTS
001082r 2               ;get console input
001082r 2               ; input:pndkey
001082r 2               ; returns:a=character
001082r 2               ; alters:all,pndkey
001082r 2               getcon:
001082r 2  AD rr rr             LDA     pndkey          ;get pending
001085r 2  48                   PHA                     ;save it
001086r 2  A9 00                LDA     #0              ;clear
001088r 2  8D rr rr             STA     pndkey          ;pending
00108Br 2  68                   PLA                     ;restore
00108Cr 2  D0 03                BNE     extget          ;exit if not null
00108Er 2  20 rr rr             JSR     sim+9           ;else get new
001091r 2               
001091r 2               extget:
001091r 2  60                   RTS                     ;and return
001092r 2               ;check keyboard status
001092r 2               ;handles <ctl-s> for freeze and <ctl-c> for boot
001092r 2               ; input:pndkey
001092r 2               ; returns:a=0 if no input or <>0 if input
001092r 2               ; alters:all,pndkey
001092r 2               kbdsts:
001092r 2  AD rr rr             LDA     pndkey          ;get pending
001095r 2  D0 20                BNE     extkbd          ;if there quit
001097r 2  20 rr rr             JSR     sim+6           ;else test
00109Ar 2  C9 00                CMP     #$00            ;if zero
00109Cr 2  F0 19                BEQ     extkbd          ;exit
00109Er 2  20 rr rr             JSR     sim+9           ;else get input
0010A1r 2  C9 13                CMP     #ctls           ;if not freeze
0010A3r 2  D0 0D                BNE     newpnd          ;save input
0010A5r 2  20 rr rr             JSR     sim+9           ;else wait for more
0010A8r 2  C9 03                CMP     #ctlc           ;if not abort
0010AAr 2  D0 03                BNE     nowarm          ;then jump
0010ACr 2  4C rr rr             JMP     xwboot          ;else do warm boot
0010AFr 2               nowarm:
0010AFr 2  A9 00                LDA     #0              ;clear
0010B1r 2  60                   RTS                     ;and return
0010B2r 2               newpnd:
0010B2r 2  8D rr rr             STA     pndkey          ;save
0010B5r 2  A9 FF                LDA     #$ff            ;set ready
0010B7r 2               extkbd:
0010B7r 2  60                   RTS                     ;and return
0010B8r 2               ;test character
0010B8r 2               ; input:a=character
0010B8r 2               ; returns:c=0 if control or c=1 if printing
0010B8r 2               ; alters:p
0010B8r 2               tstchr:
0010B8r 2  C9 0D                CMP     #cr             ;if cr
0010BAr 2  F0 0A                BEQ     chtext          ;quit
0010BCr 2  C9 0A                CMP     #lf             ;if linefeed
0010BEr 2  F0 06                BEQ     chtext          ;quit
0010C0r 2  C9 09                CMP     #ctli           ;if tab
0010C2r 2  F0 02                BEQ     chtext          ;quit
0010C4r 2  C9 20                CMP     #' '            ;see if control
0010C6r 2               chtext:
0010C6r 2  60                   RTS                     ;and return
0010C7r 2               ;send string ending in $
0010C7r 2               ; input:ay=string address
0010C7r 2               ; returns:none
0010C7r 2               ; alters:all,index,sndlpe+1 and +2
0010C7r 2               sndstr:
0010C7r 2  8D rr rr             STA     sndlpe+1        ;set pointer
0010CAr 2  8C rr rr             STY     sndlpe+2
0010CDr 2  A0 00                LDY     #0
0010CFr 2               sndlpe:
0010CFr 2  B9 FF FF             LDA     $ffff,y         ;get char
0010D2r 2  C9 24                CMP     #'$'            ;if terminator
0010D4r 2  F0 0C                BEQ     sndext          ;then exit
0010D6r 2  C8                   INY                     ;else bump
0010D7r 2  8C rr rr             STY     index           ;and save
0010DAr 2  20 rr rr             JSR     sndchr          ;send char
0010DDr 2  AC rr rr             LDY     index           ;get index
0010E0r 2  D0 ED                BNE     sndlpe          ;and loop
0010E2r 2               sndext:
0010E2r 2  60                   RTS                     ;return
0010E3r 2               ;send char to printer if enabled
0010E3r 2               ; input:a=character,lstflg
0010E3r 2               ; returns:a=character
0010E3r 2               ; alters:x,y,p
0010E3r 2               lstout:
0010E3r 2  2C rr rr             BIT     lstflg          ;test flag
0010E6r 2  10 0A                BPL     extlst          ;exit if off
0010E8r 2  2C rr rr             BIT     outflg          ;test output flag
0010EBr 2  30 05                BMI     extlst          ;done if set
0010EDr 2  48                   PHA                     ;save char
0010EEr 2  20 rr rr             JSR     sim+15          ;send
0010F1r 2  68                   PLA                     ;get char
0010F2r 2               extlst:
0010F2r 2  60                   RTS                     ;and done
0010F3r 2               ;output a character
0010F3r 2               ; input:a=character,console definition block in sim
0010F3r 2               ; returns:none
0010F3r 2               ; alters:all,positn
0010F3r 2               output:
0010F3r 2  20 rr rr             JSR     tstchr          ;test it
0010F6r 2  B0 18                BCS     sndchr          ;if not control jump
0010F8r 2  48                   PHA                     ;else save
0010F9r 2  AD rr rr             LDA     sysdef+4        ;get invert
0010FCr 2  20 rr rr             JSR     nolist          ;send to console
0010FFr 2  A9 5E                LDA     #'^'            ;get arrow
001101r 2  20 rr rr             JSR     lstout          ;send to printer
001104r 2  68                   PLA                     ;get character
001105r 2  09 40                ORA     #'A'-1          ;convert to ascii
001107r 2  20 rr rr             JSR     pchrot          ;send to all
00110Ar 2  AD rr rr             LDA     sysdef+3        ;get normal
00110Dr 2  4C rr rr             JMP     nolist          ;to console
001110r 2               sndchr:
001110r 2  C9 09                CMP     #ctli           ;if not tab
001112r 2  D0 0D                BNE     pchrot          ;send
001114r 2               tabspc:
001114r 2  A9 20                LDA     #' '            ;else get space
001116r 2  20 rr rr             JSR     pchrot          ;send
001119r 2  AD rr rr             LDA     positn          ;get count
00111Cr 2  29 07                AND     #7              ;if not mod 8
00111Er 2  D0 F4                BNE     tabspc          ;loop
001120r 2  60                   RTS                     ;else exit
001121r 2               pchrot:
001121r 2  48                   PHA                     ;save char
001122r 2  20 rr rr             JSR     kbdsts          ;test input
001125r 2  68                   PLA                     ;restore
001126r 2  20 rr rr             JSR     lstout          ;to printer if on
001129r 2               nolist:
001129r 2  48                   PHA                     ;save again
00112Ar 2  2C rr rr             BIT     outflg          ;test flag
00112Dr 2  30 03                BMI     *+5             ;done if set
00112Fr 2  20 rr rr             JSR     sim+12          ;to console
001132r 2  68                   PLA                     ;restore
001133r 2  EE rr rr             INC     positn          ;bump col
001136r 2  C9 20                CMP     #' '            ;if space or more
001138r 2  B0 26                BCS     extchr          ;is ok
00113Ar 2  CD rr rr             CMP     sysdef+2        ;also ok
00113Dr 2  F0 21                BEQ     extchr          ;if forward
00113Fr 2  CE rr rr             DEC     positn          ;else drop back
001142r 2  CD rr rr             CMP     sysdef+0        ;see if bs
001145r 2  D0 06                BNE     tryotr          ;branch if not
001147r 2  CE rr rr             DEC     positn          ;else drop again
00114Ar 2  30 0F                BMI     zrocol          ;zero if <0
00114Cr 2  60                   RTS                     ;else ok
00114Dr 2               tryotr:
00114Dr 2  C9 0D                CMP     #cr             ;if a cr
00114Fr 2  F0 0A                BEQ     zrocol          ;clear col
001151r 2  CD rr rr             CMP     sysdef+7        ;if a formfeed
001154r 2  F0 05                BEQ     zrocol          ;also clear
001156r 2  CD rr rr             CMP     sysdef+8        ;if not home
001159r 2  D0 05                BNE     extchr          ;then done
00115Br 2               zrocol:
00115Br 2  A9 00                LDA     #0              ;clear
00115Dr 2  8D rr rr             STA     positn          ;column
001160r 2               extchr:
001160r 2  60                   RTS                     ;and exit
001161r 2               ;go to left and space past prompt
001161r 2               ; input:frscol,positn
001161r 2               ; returns:none
001161r 2               ; alters:positn
001161r 2               spcovr:
001161r 2  A9 0D                LDA     #cr             ;get cr
001163r 2  20 rr rr             JSR     pchrot          ;send to all
001166r 2  A9 0A                LDA     #lf             ;send lf
001168r 2  20 rr rr             JSR     lstout          ;only to printer
00116Br 2               mreovr:
00116Br 2  AD rr rr             LDA     frscol          ;get first
00116Er 2  CD rr rr             CMP     positn          ;see if there
001171r 2  F0 ED                BEQ     extchr          ;done if is
001173r 2  AD rr rr             LDA     sysdef+2        ;get forward
001176r 2  20 rr rr             JSR     nolist          ;send it
001179r 2  4C rr rr             JMP     mreovr          ;and loop
00117Cr 2               ;buffered read
00117Cr 2               ; input:buffer@(addinp)
00117Cr 2               ; returns:none
00117Cr 2               ; alters:all,buffer@(addinp)
00117Cr 2               bufinp:
00117Cr 2  A9 00                LDA     #0              ;clear
00117Er 2  A0 01                LDY     #1              ;length
001180r 2  91 02                STA     (addinp),y      ;position in buffer
001182r 2  8C rr rr             STY     bufpsn          ;set point to 1
001185r 2  AD rr rr             LDA     positn          ;get current
001188r 2  8D rr rr             STA     frscol          ;and save
00118Br 2               nxtinp:
00118Br 2  20 rr rr             JSR     getcon          ;get input
00118Er 2  AC rr rr             LDY     bufpsn          ;get index
001191r 2  C9 0D                CMP     #cr             ;if not a cr
001193r 2  D0 03                BNE     notcr           ;then jump
001195r 2  4C rr rr             JMP     endlin          ;else done
001198r 2               notcr:
001198r 2  C9 08                CMP     #delete         ;if not delete
00119Ar 2  D0 5E                BNE     ntdelt          ;then jump
00119Cr 2  C0 01                CPY     #1              ;else if start
00119Er 2  F0 EB                BEQ     nxtinp          ;then loop
0011A0r 2  B1 02                LDA     (addinp),y      ;get last
0011A2r 2  48                   PHA                     ;save char
0011A3r 2  A0 01                LDY     #1              ;point to count
0011A5r 2  38                   SEC                     ;set carry
0011A6r 2  B1 02                LDA     (addinp),y      ;get count
0011A8r 2  E9 01                SBC     #1              ;decrement
0011AAr 2  91 02                STA     (addinp),y      ;then save
0011ACr 2  68                   PLA                     ;restore char
0011ADr 2  CE rr rr             DEC     bufpsn          ;backup pointer
0011B0r 2  C9 20                CMP     #' '            ;if space or more
0011B2r 2  B0 40                BCS     nrmbs           ;just backspace
0011B4r 2  C9 09                CMP     #ctli           ;see if tab
0011B6r 2  D0 30                BNE     ctlbs           ;if not is control
0011B8r 2  38                   SEC                     ;set flag
0011B9r 2  6E rr rr             ROR     outflg
0011BCr 2  AD rr rr             LDA     positn          ;get position and save
0011BFr 2  8D rr rr             STA     lstcol
0011C2r 2  20 rr rr             JSR     spcovr          ;else go back
0011C5r 2  20 rr rr             JSR     rptlne          ;and retype
0011C8r 2  AD rr rr             LDA     positn          ;get new last position
0011CBr 2  48                   PHA                     ;save on stack
0011CCr 2  38                   SEC                     ;subtract to get delta
0011CDr 2  AD rr rr             LDA     lstcol
0011D0r 2  ED rr rr             SBC     positn
0011D3r 2  8D rr rr             STA     lstcol          ;and save
0011D6r 2  0E rr rr             ASL     outflg          ;clear flag
0011D9r 2               bstab:
0011D9r 2  20 rr rr             JSR     dobs            ;do one
0011DCr 2  CE rr rr             DEC     lstcol          ;drop count
0011DFr 2  D0 F8                BNE     bstab           ;loop if more
0011E1r 2  68                   PLA                     ;get position
0011E2r 2  8D rr rr             STA     positn          ;and set
0011E5r 2  4C rr rr             JMP     nxtinp          ;then loop
0011E8r 2               ctlbs:
0011E8r 2  AD rr rr             LDA     sysdef+3        ;get normal
0011EBr 2  20 rr rr             JSR     chkbs           ;bs if printing
0011EEr 2  AD rr rr             LDA     sysdef+4        ;same for invert
0011F1r 2  20 rr rr             JSR     chkbs           ;then delete char itself
0011F4r 2               nrmbs:
0011F4r 2  20 rr rr             JSR     dobs            ;do a backspace
0011F7r 2  4C rr rr             JMP     nxtinp          ;and loop
0011FAr 2               ntdelt:
0011FAr 2  C9 10                CMP     #ctlp           ;if not ctl-p
0011FCr 2  D0 0B                BNE     ntctlp          ;then jump
0011FEr 2  AD rr rr             LDA     lstflg          ;else get printer flag
001201r 2  49 FF                EOR     #$ff            ;complement
001203r 2  8D rr rr             STA     lstflg          ;save
001206r 2  4C rr rr             JMP     nxtinp          ;and loop
001209r 2               ntctlp:
001209r 2  C9 18                CMP     #ctlx           ;if not ctl-x
00120Br 2  D0 0C                BNE     ntctlx          ;then jump
00120Dr 2  20 rr rr             JSR     spcovr          ;restart
001210r 2  AD rr rr             LDA     sysdef+1        ;get clear to eol
001213r 2  20 rr rr             JSR     nolist          ;send it
001216r 2  4C rr rr             JMP     bufinp          ;and start over
001219r 2               ntctlx:
001219r 2  C9 12                CMP     #ctlr           ;if not ctl-r
00121Br 2  D0 09                BNE     ntctlr          ;then jump
00121Dr 2  20 rr rr             JSR     spcovr          ;restart
001220r 2  20 rr rr             JSR     rptlne          ;retype line
001223r 2  4C rr rr             JMP     nxtinp          ;and start over
001226r 2               ntctlr:
001226r 2  C8                   INY                     ;next position
001227r 2  91 02                STA     (addinp),y      ;store char
001229r 2  48                   PHA                     ;and save
00122Ar 2  8C rr rr             STY     bufpsn          ;index
00122Dr 2  A0 01                LDY     #1              ;point to count
00122Fr 2  98                   TYA                     ;set a to 1
001230r 2  18                   CLC                     ;then
001231r 2  71 02                ADC     (addinp),y      ;add count
001233r 2  91 02                STA     (addinp),y      ;and save
001235r 2  68                   PLA                     ;restore char
001236r 2               dontsv:
001236r 2  20 rr rr             JSR     output          ;send char
001239r 2  AC rr rr             LDY     bufpsn          ;get index
00123Cr 2  B1 02                LDA     (addinp),y      ;get char
00123Er 2  C9 03                CMP     #ctlc           ;if not ctl-c
001240r 2  D0 0B                BNE     ignrcc          ;ignore
001242r 2  A0 01                LDY     #1              ;get count
001244r 2  B1 02                LDA     (addinp),y      ;from buffer
001246r 2  C9 01                CMP     #1              ;if not at start
001248r 2  D0 03                BNE     ignrcc          ;ignore
00124Ar 2  4C rr rr             JMP     xwboot          ;else do warm boot
00124Dr 2               ignrcc:
00124Dr 2  A0 01                LDY     #1              ;get
00124Fr 2  B1 02                LDA     (addinp),y      ;count
001251r 2  88                   DEY                     ;point to max
001252r 2  D1 02                CMP     (addinp),y      ;if length
001254r 2  B0 03                BCS     lineen          ;at max jump
001256r 2  4C rr rr             JMP     nxtinp          ;else loop
001259r 2               lineen:
001259r 2  A9 0D                LDA     #cr             ;get a cr
00125Br 2               endlin:
00125Br 2  4C rr rr             JMP     pchrot          ;and send
00125Er 2               ;cr and lf
00125Er 2               pcrlf:
00125Er 2  A9 0D                LDA     #cr             ;then a
001260r 2  20 rr rr             JSR     pchrot          ;cr
001263r 2  A9 0A                LDA     #lf             ;and a
001265r 2  4C rr rr             JMP     pchrot          ;lf
001268r 2               ;retype line
001268r 2               rptlne:
001268r 2  AD rr rr             LDA     bufpsn          ;save point
00126Br 2  8D rr rr             STA     numcnt          ;as count
00126Er 2  A9 01                LDA     #1              ;start position
001270r 2  48                   PHA                     ;save
001271r 2               mrerpt:
001271r 2  68                   PLA                     ;get position
001272r 2  CE rr rr             DEC     numcnt          ;count down
001275r 2  D0 01                BNE     *+3             ;continue if more
001277r 2  60                   RTS                     ;else done
001278r 2  A8                   TAY                     ;else make index
001279r 2  C8                   INY                     ;and bump
00127Ar 2  98                   TYA                     ;save
00127Br 2  48                   PHA                     ;on stack
00127Cr 2  B1 02                LDA     (addinp),y      ;get char
00127Er 2  20 rr rr             JSR     output          ;send
001281r 2  4C rr rr             JMP     mrerpt          ;and loop
001284r 2               ;check for printing and backspace if needed
001284r 2               chkbs:
001284r 2  C9 20                CMP     #' '            ;compare to space
001286r 2  90 19                BCC     extdec          ;not printing so done
001288r 2               ;do a backspace
001288r 2               dobs:
001288r 2  AD rr rr             LDA     sysdef+0        ;get backspace
00128Br 2  48                   PHA                     ;save it
00128Cr 2  20 rr rr             JSR     nolist          ;send
00128Fr 2  A9 20                LDA     #' '            ;get space
001291r 2  20 rr rr             JSR     nolist          ;send
001294r 2  68                   PLA                     ;get backspace
001295r 2  4C rr rr             JMP     nolist          ;send it
001298r 2               ;test for decimal digit
001298r 2               ;if decimal then c=0 else c=1
001298r 2               tstdec:
001298r 2  C9 30                CMP     #'0'            ;if under 0
00129Ar 2  90 04                BCC     notdec          ;then not decimal
00129Cr 2  C9 3A                CMP     #'9'+1          ;if 9 or under is ok
00129Er 2  90 01                BCC     extdec
0012A0r 2               notdec:
0012A0r 2  38                   SEC                     ;else not a match
0012A1r 2               extdec:
0012A1r 2  60                   RTS
0012A2r 2               ;test for hexadecimal digit
0012A2r 2               ;if hex then c=0 else c=1
0012A2r 2               tsthex:
0012A2r 2  20 rr rr             JSR     tstdec          ;first try decimal
0012A5r 2  90 FA                BCC     extdec          ;ok if dec
0012A7r 2  C9 41                CMP     #'A'            ;if under A
0012A9r 2  90 F5                BCC     notdec          ;then not hex
0012ABr 2  C9 47                CMP     #'F'+1          ;set c in F compare
0012ADr 2  60                   RTS
0012AEr 2               ;bump load address by 128 and return in ay
0012AEr 2               adjdb:
0012AEr 2  AD rr rr             LDA     dskbuf          ;get old
0012B1r 2  AC rr rr             LDY     dskbuf+1        ;address
0012B4r 2  18                   CLC                     ;and bump
0012B5r 2  69 80                ADC     #128            ;by 128
0012B7r 2  8D rr rr             STA     dskbuf          ;save low
0012BAr 2  90 04                BCC     *+6             ;then bump
0012BCr 2  C8                   INY                     ;and save
0012BDr 2  8C rr rr             STY     dskbuf+1        ;high as needed
0012C0r 2  60                   RTS
0012C1r 2               ;move record from disk buffer to default buffer
0012C1r 2               mv128:
0012C1r 2  AD rr rr             LDA     dskbuf          ;get address
0012C4r 2  AC rr rr             LDY     dskbuf+1
0012C7r 2  8D rr rr             STA     mvfrom+1        ;and set pointer
0012CAr 2  8C rr rr             STY     mvfrom+2
0012CDr 2  A2 00                LDX     #0              ;clear index
0012CFr 2               mvfrom:
0012CFr 2  BD FF FF             LDA     $ffff,x         ;get byte
0012D2r 2  9D 28 01             STA     dflbuf,x        ;move it
0012D5r 2  E8                   INX
0012D6r 2  10 F7                BPL     mvfrom          ;loop until done
0012D8r 2  60                   RTS
0012D9r 2               
0012D9r 2               ;relocatable vectors
0012D9r 2  4C                   .BYTE   $4c
0012DAr 2               extevc:
0012DAr 2  rr rr                .WORD   extexq-1
0012DCr 2  4C                   .BYTE   $4c
0012DDr 2               sltmvc:
0012DDr 2  rr rr                .WORD   sltmsg
0012DFr 2  4C                   .BYTE   $4c
0012E0r 2               empdvc:
0012E0r 2  rr rr                .WORD   empty
0012E2r 2  4C                   .BYTE   $4c
0012E3r 2               rommvc:
0012E3r 2  rr rr                .WORD   romsg
0012E5r 2  4C                   .BYTE   $4c
0012E6r 2               bdsmvc:
0012E6r 2  rr rr                .WORD   bdsmsg
0012E8r 2  4C                   .BYTE   $4c
0012E9r 2               pemmvc:
0012E9r 2  rr rr                .WORD   pemmsg
0012EBr 2  4C                   .BYTE   $4c
0012ECr 2               dcbevc:
0012ECr 2  rr rr                .WORD   dcb
0012EEr 2               ;relocation stopper
0012EEr 2  FF                   .BYTE   $ff
0012EFr 2               ;messages
0012EFr 2               romsg:
0012EFr 2  20 2D 20 52          .BYTE   " - R/O$"
0012F3r 2  2F 4F 24     
0012F6r 2               bdsmsg:
0012F6r 2  20 2D 20 42          .BYTE   " - BAD SECTOR"
0012FAr 2  41 44 20 53  
0012FEr 2  45 43 54 4F  
001303r 2  0D 0A 3C 52          .BYTE   cr,lf,"<RET> TO IGNORE -- <OTHER> "
001307r 2  45 54 3E 20  
00130Br 2  54 4F 20 49  
001320r 2  54 4F 20 41          .BYTE   "TO ABORT$"
001324r 2  42 4F 52 54  
001328r 2  24           
001329r 2               pemmsg:
001329r 2  0D 0A 50 45          .BYTE   cr,lf,"PEM ERROR ON $"
00132Dr 2  4D 20 45 52  
001331r 2  52 4F 52 20  
001339r 2               sltmsg:
001339r 2  20 2D 20 49          .BYTE   " - INVALID DRIVE$"
00133Dr 2  4E 56 41 4C  
001341r 2  49 44 20 44  
00134Ar 2               
00134Ar 2               ;dummy fcb
00134Ar 2               empty:
00134Ar 2  E5                   .BYTE   $e5
00134Br 2               ;zero page switch enable table
00134Br 2               swctbl:
00134Br 2  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0
00134Fr 2  00 00 00 00  
001353r 2  00 00 01 00          .BYTE   0,0,1,0,0,1,1,1
001357r 2  00 01 01 01  
00135Br 2  01 01 01 01          .BYTE   1,1,1,1,1,1,1,1
00135Fr 2  01 01 01 01  
001363r 2  00 00 01 00          .BYTE   0,0,1,0,0,0,0,0
001367r 2  00 00 00 00  
00136Br 2  00 00 00 00          .BYTE   0,0,0,0
00136Fr 2               ;bit mask table
00136Fr 2               bitmsk:
00136Fr 2  80 40 20 10          .BYTE   128,64,32,16,8,4,2,1
001373r 2  08 04 02 01  
001377r 2               ;bit map table
001377r 2               bitmap:
001377r 2  01 02 04 08          .BYTE   1,2,4,8,16,32,64,128
00137Br 2  10 20 40 80  
00137Fr 2               ;extent mask table (also uses 3 bytes in sabtbl
00137Fr 2               exmtbl:
00137Fr 2  00 01 03             .BYTE   0,1,3
001382r 2               ;sab table
001382r 2               sabtbl:
001382r 2  07 0F 1F 3F          .BYTE   7,15,31,63,127
001386r 2  7F           
001387r 2               ;variable storage
001387r 2               skpdir:
001387r 2  00                   .BYTE   0               ;positive if no change
001388r 2               fcbind:
001388r 2  00                   .BYTE   0               ;index to block number
001389r 2               savext:
001389r 2  00                   .BYTE   0               ;save extent
00138Ar 2               frscol:
00138Ar 2  00                   .BYTE   0               ;first col
00138Br 2               pndkey:
00138Br 2  00                   .BYTE   0               ;pending input
00138Cr 2               lstflg:
00138Cr 2  00                   .BYTE   0               ;printer flag
00138Dr 2               positn:
00138Dr 2  00                   .BYTE   0               ;print position
00138Er 2               swcflg:
00138Er 2  00                   .BYTE   0               ;zero page switch flag
00138Fr 2               bytinp:
00138Fr 2  00 00                .WORD   0               ;input value
001391r 2               cmdinp:
001391r 2  00                   .BYTE   0               ;input command
001392r 2               addout:
001392r 2  00 00                .WORD   0               ;output address
001394r 2               bytout          = addout        ;output value
001394r 2               bufpsn:
001394r 2  00                   .BYTE   0               ;input buffer position
001395r 2               exrwfl:
001395r 2  00                   .BYTE   0               ;extend flag
001396r 2               tmpdrv:
001396r 2  00                   .BYTE   0               ;temporary drive number
001397r 2               ;align xqtvec on word boundary
001397r 2  xx                   .ALIGN  2
001398r 2               xqtvec:
001398r 2  00 00                .WORD   0               ;command vector
00139Ar 2               countr:
00139Ar 2  00 00                .WORD   0               ;record counter
00139Cr 2  00                   .BYTE   0               ;overflow
00139Dr 2               lkdown:
00139Dr 2  00 00                .WORD   0               ;down pnt. for block search
00139Fr 2               lookup:
00139Fr 2  00 00                .WORD   0               ;up pnt. for block search
0013A1r 2               olddrv:
0013A1r 2  00                   .BYTE   0               ;old drive number
0013A2r 2               curdrv:
0013A2r 2  00                   .BYTE   0               ;current drive
0013A3r 2               lginvc:
0013A3r 2  00                   .BYTE   0               ;log in status
0013A4r 2               ronlst:
0013A4r 2  00                   .BYTE   0               ;read write status
0013A5r 2               dirnum:
0013A5r 2  00 00                .WORD   0               ;directory number
0013A7r 2               subrec:
0013A7r 2  00                   .BYTE   0               ;directory offset
0013A8r 2               recnum:
0013A8r 2  00 00                .WORD   0               ;record number
0013AAr 2               blknum          = recnum        ;block number
0013AAr 2  00                   .BYTE   0               ;overflow
0013ABr 2               chrcnt:
0013ABr 2  00                   .BYTE   0               ;character count
0013ACr 2               cmppnt:
0013ACr 2  00                   .BYTE   0               ;comparison pointer
0013ADr 2               nxtrec:
0013ADr 2  00                   .BYTE   0               ;next record
0013AEr 2               numrec:
0013AEr 2  00                   .BYTE   0               ;number records
0013AFr 2               dirrec:
0013AFr 2  00 00                .WORD   0               ;directory record
0013B1r 2               dirmod:
0013B1r 2  00                   .BYTE   0               ;directory mod 4
0013B2r 2               index:
0013B2r 2  00                   .BYTE   0               ;buffer index
0013B3r 2               numcnt:
0013B3r 2  00                   .BYTE   0               ;counter
0013B4r 2               outflg:
0013B4r 2  00                   .BYTE   0               ;output enable flag
0013B5r 2               lstcol:
0013B5r 2  00                   .BYTE   0               ;last column
0013B6r 2               mpdrsy:
0013B6r 2  00                   .BYTE   0               ;save for y in mapdir
0013B7r 2               mpdrtm:
0013B7r 2  00                   .BYTE   0               ;temp in mapdir
0013B8r 2               blmode:
0013B8r 2  00                   .BYTE   0               ;<128 if byte else word
0013B9r 2               maxdrc:
0013B9r 2  00 00                .WORD   0               ;max directory record
0013BBr 2               sab:
0013BBr 2  00                   .BYTE   0               ;mask for block
0013BCr 2               sxb:
0013BCr 2  00                   .BYTE   0               ;shift for block
0013BDr 2               rtclk:
0013BDr 2  00 00 00             .BYTE   0,0,0           ;real time clock
0013C0r 2               gpcnt:
0013C0r 2  00 00                .WORD   0               ;gp counter
0013C2r 2               trkctr:
0013C2r 2  00                   .BYTE   0               ;track counter
0013C3r 2               ;following region is used to capture dcb
0013C3r 2               dcb:
0013C3r 2               maxblk:
0013C3r 2  00 00                .WORD   0               ;maximum block number
0013C5r 2               sectrk:
0013C5r 2  00 00                .WORD   0               ;sectors per track
0013C7r 2               nsystr:
0013C7r 2  00 00                .WORD   0               ;number system tracks
0013C9r 2               blkscd:
0013C9r 2  00                   .BYTE   0               ;block size code
0013CAr 2               maxdir:
0013CAr 2  00 00                .WORD   0               ;maximum directory number
0013CCr 2               alcmap:
0013CCr 2  00 00                .WORD   0               ;address of allocation map
0013CEr 2               chkflg:
0013CEr 2  00                   .BYTE   0               ;check flag
0013CFr 2               chkmap:
0013CFr 2  00 00                .WORD   0               ;address of checksum map
0013D1r 2               pemwrtype:
0013D1r 2  00                   .BYTE   0               ;write type 0=norm,1=dir,2=unalloc
0013D2r 2               exm:
0013D2r 2  00                   .BYTE   0               ;extent mask
0013D3r 2               cexm1f:
0013D3r 2  00                   .BYTE   0               ;exm complemented and 1f
0013D4r 2               ;zero page save block
0013D4r 2               varblk:
0013D4r 2               lowin:
0013D4r 2  xx xx xx xx          .RES    numvar
0013D8r 2  xx xx xx xx  
0013DCr 2  xx xx xx xx  
001424r 2               
001424r 1                       .INCLUDE "../dos65_os/simrbc.asm"
001424r 2               ;--------------------------------
001424r 2               ;dos/65 system interface module (sim)
001424r 2               ;--------------------------------
001424r 2               
001424r 2               
001424r 2               ;dos/65 system interface module (sim)
001424r 2               ;version 3.00
001424r 2               ;this version is designed to work with the 6x0x
001424r 2               
001424r 2               ;fixed parameters
001424r 2               simstart:
001424r 2               
001424r 2               ;main program
001424r 2               ;jump vector used by pem
001424r 2               sim:
001424r 2  4C rr rr             JMP     boot            ;from cold start
001427r 2               wboote:
001427r 2  4C rr rr             JMP     wboot           ;from warm boot
00142Ar 2  4C rr rr             JMP     consts          ;check for input
00142Dr 2  4C rr rr             JMP     conrde          ;get input
001430r 2  4C rr rr             JMP     conwrt          ;send to terminal
001433r 2  4C rr rr             JMP     prnwrt          ;printer output
001436r 2  4C rr rr             JMP     punwrt          ;punch output
001439r 2  4C rr rr             JMP     rdrinp          ;reader input
00143Cr 2  4C rr rr             JMP     home            ;home drive
00143Fr 2  4C rr rr             JMP     seldsk          ;select disk
001442r 2  4C rr rr             JMP     seltrk          ;set track
001445r 2  4C rr rr             JMP     selsec          ;set sector
001448r 2  4C rr rr             JMP     setdma          ;set buffer address
00144Br 2  4C rr rr             JMP     read            ;read sector
00144Er 2  4C rr rr             JMP     write           ;write sector
001451r 2  A9 01                LDA     #1              ;printer always ready
001453r 2  60                   RTS
001454r 2  4C rr rr             JMP     rdtime          ;clock entry
001457r 2  4C rr rr             JMP     xlate           ;translate
00145Ar 2               
00145Ar 2               ;console definition block
00145Ar 2               sysdef:
00145Ar 2  08                   .BYTE   8               ;backspace
00145Br 2  01                   .BYTE   1               ;clear to end of line
00145Cr 2  0C                   .BYTE   $c              ;forward space
00145Dr 2  00                   .BYTE   0               ;normal video
00145Er 2  5E                   .BYTE   '^'             ;invert video
00145Fr 2  18                   .BYTE   24              ;lines per screen
001460r 2  50                   .BYTE   80              ;char per line
001461r 2  0C                   .BYTE   $c              ;formfeed
001462r 2  1E                   .BYTE   $1e             ;home
001463r 2  02                   .BYTE   2               ;clear to end of screen
001464r 2               
001464r 2               ;opening id message
001464r 2               opnmsg:
001464r 2  0D 0A                .BYTE   cr, lf
001466r 2               
001466r 2  64 38 38 38          .BYTE   "d8888b.  .d88b.  .d8888.    dD     ooooo", cr, lf
00146Ar 2  38 62 2E 20  
00146Er 2  20 2E 64 38  
001490r 2  38 38 20 20          .BYTE   "88  `8D .8P  Y8. 88'  YP   d8'    8P~~~~", cr, lf
001494r 2  60 38 44 20  
001498r 2  2E 38 50 20  
0014BAr 2  38 38 20 20          .BYTE   "88   88 88    88 `8bo.    d8'    dP", cr, lf
0014BEr 2  20 38 38 20  
0014C2r 2  38 38 20 20  
0014DFr 2  38 38 20 20          .BYTE   "88   88 88    88   `Y8b. d8888b. V8888b.", cr, lf,0
0014E3r 2  20 38 38 20  
0014E7r 2  38 38 20 20  
00150Ar 2               opnmsg1:
00150Ar 2  38 38 20 20          .BYTE   "88  .8D `8b  d8' db   8D 88' `8D     `8D ", cr, lf
00150Er 2  2E 38 44 20  
001512r 2  60 38 62 20  
001535r 2  59 38 38 38          .BYTE   "Y8888D'  `Y88P'  `8888Y' `8888P  88oobY'", cr, lf
001539r 2  38 44 27 20  
00153Dr 2  20 60 59 38  
00155Fr 2  44 4F 53 2F          .BYTE   "DOS/65 V3.00", cr, lf, 0
001563r 2  36 35 20 56  
001567r 2  33 2E 30 30  
00156Er 2               
00156Er 2               DSKYMSG:
00156Er 2  54 6E 5C 5E          .BYTE   $54, $6E, $5C, $5E, $6E, $54, $79, $40
001572r 2  6E 54 79 40  
001576r 2               
001576r 2               ;cold entry from loader
001576r 2               boot:
001576r 2  A9 rr                LDA     #<opnmsg        ;point to message
001578r 2  A0 rr                LDY     #>opnmsg
00157Ar 2  20 rr rr             JSR     outmsg          ;send it
00157Dr 2  A9 rr                LDA     #<opnmsg1       ;point to message
00157Fr 2  A0 rr                LDY     #>opnmsg1
001581r 2  20 rr rr             JSR     outmsg          ;send it
001584r 2               ;set up jumps into dos/65 in page one
001584r 2               
001584r 2               ; setup diskconfig table
001584r 2  A2 00                LDX     #0
001586r 2               :
001586r 2  BD rr rr             LDA     dftdskcfg, x
001589r 2  9D 17 06             STA     dskcfg, x
00158Cr 2  E8                   INX
00158Dr 2  E0 10                CPX     #$10
00158Fr 2  D0 F5                BNE     :-
001591r 2               
001591r 2  A9 28                LDA     #40             ; DSKY INITIALIZE
001593r 2  85 32                STA     farfunct
001595r 2  20 00 02             JSR     DO_FARCALL
001598r 2               
001598r 2  A9 34                LDA     #52             ; RTC_RESET
00159Ar 2  85 32                STA     farfunct
00159Cr 2  20 00 02             JSR     DO_FARCALL
00159Fr 2               
00159Fr 2  A9 3C                LDA     #60             ; IDE INITIALIZE
0015A1r 2  85 32                STA     farfunct
0015A3r 2  20 00 02             JSR     DO_FARCALL
0015A6r 2               
0015A6r 2  A9 3F                LDA     #63             ; SD INITIALIZE
0015A8r 2  85 32                STA     farfunct
0015AAr 2  20 00 02             JSR     DO_FARCALL
0015ADr 2               
0015ADr 2  A9 42                LDA     #66             ; FLOPPY INITIALIZE
0015AFr 2  85 32                STA     farfunct
0015B1r 2  20 00 02             JSR     DO_FARCALL
0015B4r 2               
0015B4r 2               wboot:
0015B4r 2                       .IFDEF  DUODYNE
0015B4r 2                       CLD                     ; VERIFY DECIMAL MODE IS OFF
0015B4r 2                       CLC                     ;
0015B4r 2                       XCE                     ; SET NATIVE MODE
0015B4r 2                       ACCUMULATORINDEX16
0015B4r 2                       LDA     #STACK          ; get the stack address
0015B4r 2                       TCS                     ; and set the stack to it
0015B4r 2                       ACCUMULATORINDEX8
0015B4r 2                       PHK
0015B4r 2                       PLB
0015B4r 2                       .ELSE
0015B4r 2  78                   SEI
0015B5r 2  A2 FF                LDX     #$ff            ;set stack
0015B7r 2  9A                   TXS                     ;pointer
0015B8r 2  D8                   CLD                     ;set binary mode
0015B9r 2                       .ENDIF
0015B9r 2               
0015B9r 2  A9 rr                LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
0015BBr 2  85 30                STA     cmdlnp
0015BDr 2  A9 rr                LDA     #>cnstxt
0015BFr 2  85 31                STA     cmdlnp + 1
0015C1r 2               
0015C1r 2  A9 17                LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
0015C3r 2  85 2E                STA     dskcfpc
0015C5r 2  A9 06                LDA     #>dskcfg
0015C7r 2  85 2F                STA     dskcfpc + 1
0015C9r 2               
0015C9r 2  A9 rr                LDA     #<dcba          ; STORE POINTER TO DCB TABLES FOR APPS
0015CBr 2  85 2C                STA     dcbpc
0015CDr 2  A9 rr                LDA     #>dcba
0015CFr 2  85 2D                STA     dcbpc + 1
0015D1r 2               ;
0015D1r 2  A2 00                LDX     #0              ;clear index
0015D3r 2               ;
0015D3r 2               setupl:
0015D3r 2  BD rr rr             LDA     inttbl,x        ;get byte
0015D6r 2  9D 00 01             STA     $100,x          ;insert at start
0015D9r 2  E8                   INX
0015DAr 2  E0 06                CPX     #6
0015DCr 2  D0 F5                BNE     setupl          ;loop until done
0015DEr 2  A9 28                LDA     #<dflbuf        ;get low buffer
0015E0r 2  A0 01                LDY     #>dflbuf        ;and high
0015E2r 2  20 rr rr             JSR     setdma          ;and set
0015E5r 2  A5 48                LDA     sekdsk          ;get disk
0015E7r 2               
0015E7r 2  A2 00                LDX     #$00            ; SHOW A STARTUP MESSAGE ON DSKY
0015E9r 2               :
0015E9r 2  BD rr rr             LDA     DSKYMSG,x
0015ECr 2  9D 00 06             STA     DSKY_BUF,x
0015EFr 2  E8                   INX
0015F0r 2  E0 08                CPX     #8
0015F2r 2  D0 F5                BNE     :-
0015F4r 2  A9 29                LDA     #41             ; DSKY_SHOW
0015F6r 2  85 32                STA     farfunct
0015F8r 2  20 00 02             JSR     DO_FARCALL
0015FBr 2               
0015FBr 2  A9 00                LDA     #DEFDRV         ;set zero
0015FDr 2  20 rr rr             JSR     seldsk          ;and select drive zero
001600r 2  20 rr rr             JSR     home            ;home that drive
001603r 2  A9 00                LDA     #DEFDRV         ;set zero
001605r 2  4C rr rr             JMP     ccm             ;and go to ccm
001608r 2               ;initialization table
001608r 2               inttbl:
001608r 2  4C rr rr 4C          .BYTE   $4c,<wboote,>wboote,$4c,<pem,>pem
00160Cr 2  rr rr        
00160Er 2               ;warm boot-read dos/65 back except sim and then
00160Er 2               ; jump to ccm.
00160Er 2               
00160Er 2               
00160Er 2               
00160Er 2               ;__SELDSK_________________________________________________________________________________________________
00160Er 2               ;
00160Er 2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
00160Er 2               ;________________________________________________________________________________________________________
00160Er 2               ;select disk
00160Er 2               seldsk:
00160Er 2  29 07                AND     #7              ;eight drives only
001610r 2  85 48                STA     sekdsk          ;save for later
001612r 2  0A                   ASL     a               ;multiply by two
001613r 2  AA                   TAX                     ;make an Index
001614r 2  BD rr rr             LDA     dcbtbl,x        ;get address
001617r 2  BC rr rr             LDY     dcbtbl+1,x
00161Ar 2  60                   RTS
00161Br 2               
00161Br 2               ;table of dcb addresses
00161Br 2               dcbtbl:
00161Br 2  rr rr                .WORD   dcba
00161Dr 2  rr rr                .WORD   dcbb
00161Fr 2  rr rr                .WORD   dcbc
001621r 2  rr rr                .WORD   dcbd
001623r 2  rr rr                .WORD   dcbe
001625r 2  rr rr                .WORD   dcbf
001627r 2  rr rr                .WORD   dcbg
001629r 2  rr rr                .WORD   dcbh
00162Br 2               
00162Br 2               
00162Br 2               
00162Br 2               ;__HOME__________________________________________________________________________________________________
00162Br 2               ;
00162Br 2               ; 	PERFORM DOS/65 HEAD HOME
00162Br 2               ;________________________________________________________________________________________________________
00162Br 2               home:
00162Br 2  A9 00                LDA     #$00
00162Dr 2  A0 00                LDY     #$00
00162Fr 2               
00162Fr 2               ;__SELTRK________________________________________________________________________________________________
00162Fr 2               ;
00162Fr 2               ; 	PERFORM DOS/65 SELECT TRACK
00162Fr 2               ;
00162Fr 2               ;	A=TRACK LOW BYTE
00162Fr 2               ;	Y=TRACK HIGH BYTE
00162Fr 2               ;________________________________________________________________________________________________________
00162Fr 2               seltrk:
00162Fr 2  85 44                STA     sektrk          ;save number
001631r 2  84 45                STY     sektrk+1
001633r 2  60                   RTS
001634r 2               
001634r 2               ;__SELSEC________________________________________________________________________________________________
001634r 2               ;
001634r 2               ; 	PERFORM DOS/65 SECTOR SELECT
001634r 2               ;
001634r 2               ;	A=SECTOR LOW BYTE
001634r 2               ;	Y=SECTOR HIGH BYTE
001634r 2               ;________________________________________________________________________________________________________
001634r 2               selsec:
001634r 2  85 46                STA     seksec          ;save low and high
001636r 2  84 47                STY     seksec+1
001638r 2  60                   RTS
001639r 2               
001639r 2               ;__READ__________________________________________________________________________________________________
001639r 2               ;
001639r 2               ; PERFORM DOS / 65 SECTOR READ
001639r 2               ;________________________________________________________________________________________________________
001639r 2               read:
001639r 2  20 rr rr             JSR     GET_DRIVE_DEVICE;
00163Cr 2  29 F0                AND     #$F0            ; only want first nybble
00163Er 2  C9 00                CMP     #$00
001640r 2  D0 0B                BNE     :+              ; not MD drive
001642r 2               ;MD
001642r 2  A9 40                LDA     #64             ; md read sector
001644r 2  85 32                STA     farfunct
001646r 2  20 00 02             JSR     DO_FARCALL
001649r 2  20 rr rr             JSR     DEBSECR
00164Cr 2  60                   RTS
00164Dr 2               :
00164Dr 2  C9 10                CMP     #$10
00164Fr 2  D0 0E                BNE     :+              ; not SD drive
001651r 2               ;SD
001651r 2                       .IFDEF  DUODYNE
001651r 2                       .ELSE
001651r 2  20 rr rr             JSR     CONVERT_SECTOR_LBA
001654r 2                       .ENDIF
001654r 2  A9 40                LDA     #64             ; sd read sector
001656r 2  85 32                STA     farfunct
001658r 2  20 00 02             JSR     DO_FARCALL
00165Br 2  20 rr rr             JSR     DEBSECR
00165Er 2  60                   RTS
00165Fr 2               :
00165Fr 2  C9 20                CMP     #$20
001661r 2  D0 0E                BNE     :+              ; not floppy drive
001663r 2               ;FD
001663r 2                       .IFDEF  DUODYNE
001663r 2                       .ELSE
001663r 2  20 rr rr             JSR     SETUP_FD_CHS
001666r 2                       .ENDIF
001666r 2  A9 43                LDA     #67             ; floppy read sector
001668r 2  85 32                STA     farfunct
00166Ar 2  20 00 02             JSR     DO_FARCALL
00166Dr 2  20 rr rr             JSR     DEBSECR
001670r 2  60                   RTS
001671r 2               :
001671r 2  C9 30                CMP     #$30
001673r 2  D0 0E                BNE     :+              ; invalid drive
001675r 2               ;PPIDE
001675r 2                       .IFDEF  DUODYNE
001675r 2                       .ELSE
001675r 2  20 rr rr             JSR     CONVERT_SECTOR_LBA
001678r 2                       .ENDIF
001678r 2  A9 3D                LDA     #61             ; IDE_READ_SECTOR
00167Ar 2  85 32                STA     farfunct
00167Cr 2  20 00 02             JSR     DO_FARCALL
00167Fr 2  20 rr rr             JSR     DEBSECR
001682r 2  60                   RTS
001683r 2               :
001683r 2  A9 FF                LDA     #$FF            ; signal error
001685r 2  60                   RTS                     ;
001686r 2               
001686r 2               
001686r 2               ;__WRITE_________________________________________________________________________________________________
001686r 2               ;
001686r 2               ; PERFORM DOS / 65 SECTOR WRITE
001686r 2               ;________________________________________________________________________________________________________
001686r 2               write:
001686r 2  20 rr rr             JSR     GET_DRIVE_DEVICE;
001689r 2  29 F0                AND     #$F0            ; only want first nybble
00168Br 2               
00168Br 2  C9 00                CMP     #$00
00168Dr 2  D0 12                BNE     :+              ; not MD drive
00168Fr 2               ;MD
00168Fr 2  A9 40                LDA     #64             ;PPP_READ_SECTOR
001691r 2  85 32                STA     farfunct
001693r 2  20 00 02             JSR     DO_FARCALL
001696r 2  20 rr rr             JSR     BLKSECR
001699r 2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
00169Br 2  85 32                STA     farfunct
00169Dr 2  20 00 02             JSR     DO_FARCALL
0016A0r 2  60                   RTS
0016A1r 2               :
0016A1r 2  C9 10                CMP     #$10
0016A3r 2  D0 15                BNE     :+              ; not SD drive
0016A5r 2               ;SD
0016A5r 2                       .IFDEF  DUODYNE
0016A5r 2                       .ELSE
0016A5r 2  20 rr rr             JSR     CONVERT_SECTOR_LBA
0016A8r 2                       .ENDIF
0016A8r 2               
0016A8r 2  A9 40                LDA     #64             ;PPP_READ_SECTOR
0016AAr 2  85 32                STA     farfunct
0016ACr 2  20 00 02             JSR     DO_FARCALL
0016AFr 2  20 rr rr             JSR     BLKSECR
0016B2r 2  A9 41                LDA     #65             ;PPP_WRITE_SECTOR
0016B4r 2  85 32                STA     farfunct
0016B6r 2  20 00 02             JSR     DO_FARCALL
0016B9r 2  60                   RTS
0016BAr 2               :
0016BAr 2               
0016BAr 2  C9 20                CMP     #$20
0016BCr 2  D0 15                BNE     :+              ; not floppy drive
0016BEr 2               ;FD
0016BEr 2                       .IFDEF  DUODYNE
0016BEr 2                       .ELSE
0016BEr 2  20 rr rr             JSR     SETUP_FD_CHS
0016C1r 2                       .ENDIF
0016C1r 2  A9 43                LDA     #67             ; floppy read sector
0016C3r 2  85 32                STA     farfunct
0016C5r 2  20 00 02             JSR     DO_FARCALL
0016C8r 2  20 rr rr             JSR     BLKSECR
0016CBr 2  A9 44                LDA     #68             ; floppy write sector
0016CDr 2  85 32                STA     farfunct
0016CFr 2  20 00 02             JSR     DO_FARCALL
0016D2r 2  60                   RTS
0016D3r 2               :
0016D3r 2  C9 30                CMP     #$30
0016D5r 2  D0 15                BNE     :+              ; invalid drive
0016D7r 2               ;PPIDE
0016D7r 2                       .IFDEF  DUODYNE
0016D7r 2                       .ELSE
0016D7r 2  20 rr rr             JSR     CONVERT_SECTOR_LBA
0016DAr 2                       .ENDIF
0016DAr 2               
0016DAr 2  A9 3D                LDA     #61             ; IDE read sector
0016DCr 2  85 32                STA     farfunct
0016DEr 2  20 00 02             JSR     DO_FARCALL
0016E1r 2  20 rr rr             JSR     BLKSECR
0016E4r 2  A9 3E                LDA     #62             ; IDE_WRITE_SECTOR
0016E6r 2  85 32                STA     farfunct
0016E8r 2  20 00 02             JSR     DO_FARCALL
0016EBr 2  60                   RTS
0016ECr 2               :
0016ECr 2  A9 FF                LDA     #$FF            ; signal error
0016EEr 2  60                   RTS                     ;
0016EFr 2               
0016EFr 2               
0016EFr 2               ;__SETDMA________________________________________________________________________________________________
0016EFr 2               ;
0016EFr 2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
0016EFr 2               ;
0016EFr 2               ;	A=BUFFER LOW BYTE
0016EFr 2               ;	Y=BUFFER HIGH BYTE
0016EFr 2               ;________________________________________________________________________________________________________
0016EFr 2               setdma:
0016EFr 2  85 F4                STA     dmaadr          ;store low
0016F1r 2  84 F5                STY     dmaadr+1        ;and high
0016F3r 2  60                   RTS
0016F4r 2               
0016F4r 2               
0016F4r 2               ;__CONSTS________________________________________________________________________________________________
0016F4r 2               ;
0016F4r 2               ; 	GET DOS/65 CONSOLE STATUS
0016F4r 2               ;________________________________________________________________________________________________________
0016F4r 2               consts:
0016F4r 2  A9 03                LDA     #03
0016F6r 2  85 32                STA     farfunct
0016F8r 2  4C 00 02             JMP     DO_FARCALL
0016FBr 2               
0016FBr 2               ;__CONRDE________________________________________________________________________________________________
0016FBr 2               ;
0016FBr 2               ; 	PERFORM DOS/65 CONSOLE READ
0016FBr 2               ;________________________________________________________________________________________________________
0016FBr 2               conrde:
0016FBr 2  A9 02                LDA     #02
0016FDr 2  85 32                STA     farfunct
0016FFr 2  4C 00 02             JMP     DO_FARCALL      ;console read
001702r 2               
001702r 2               ;__CONWRT________________________________________________________________________________________________
001702r 2               ;
001702r 2               ; 	PERFORM DOS/65 CONSOLE WRITE
001702r 2               ;________________________________________________________________________________________________________
001702r 2               conwrt:
001702r 2  48                   PHA
001703r 2  A9 00                LDA     #00
001705r 2  85 32                STA     farfunct
001707r 2  68                   PLA
001708r 2  4C 00 02             JMP     DO_FARCALL
00170Br 2               
00170Br 2               prnwrt:
00170Br 2  60                   RTS                     ;printer
00170Cr 2               punwrt:
00170Cr 2  60                   RTS                     ;punch output
00170Dr 2               rdrinp:
00170Dr 2  60                   RTS                     ;reader input
00170Er 2               rdtime:
00170Er 2  A2 80                LDX     #128
001710r 2  60                   RTS                     ;read clock
001711r 2               xlate:
001711r 2  60                   RTS                     ;sector translate
001712r 2               
001712r 2               
001712r 2               ;__OUTMSG________________________________________________________________________________________________
001712r 2               ;
001712r 2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
001712r 2               ;
001712r 2               ;	A=POINTER LOW BYTE
001712r 2               ;	Y=POINTER HIGH BYTE
001712r 2               ;________________________________________________________________________________________________________
001712r 2               outmsg: ;output message
001712r 2  85 F0                STA     OUTMSG_W
001714r 2  84 F1                STY     OUTMSG_W+1
001716r 2  A0 00                LDY     #$00
001718r 2               OUTSTRLP:
001718r 2  B1 F0                LDA     (OUTMSG_W),Y    ; LOAD NEXT CHAR FROM STRING INTO ACC
00171Ar 2  C9 00                CMP     #$00            ; IS NULL?
00171Cr 2  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00171Er 2  20 rr rr             JSR     conwrt          ; PRINT CHAR IN ACC
001721r 2  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
001722r 2  4C rr rr             JMP     OUTSTRLP        ; DO NEXT CHAR
001725r 2               ENDOUTSTR:
001725r 2  60                   RTS                     ; RETURN
001726r 2               
001726r 2                       .IFDEF  DUODYNE
001726r 2                       .ELSE
001726r 2               
001726r 2               ;___CONVERT_SECTOR_LBA___________________________________________________________________________________
001726r 2               ;
001726r 2               ; 	TRANSLATE LBA SECTORS
001726r 2               ;________________________________________________________________________________________________________
001726r 2               CONVERT_SECTOR_LBA:
001726r 2  A5 44                LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
001728r 2  29 0F                AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
00172Ar 2  0A                   ASL     a               ; MOVE TO HIGH BYTE
00172Br 2  0A                   ASL     a
00172Cr 2  0A                   ASL     a
00172Dr 2  0A                   ASL     a
00172Er 2  AA                   TAX                     ; PARK IN X
00172Fr 2  A5 46                LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
001731r 2  4A                   LSR     A               ;
001732r 2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
001733r 2  29 0F                AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
001735r 2  8D 10 06             STA     debsehd         ; STORE IN SECTOR/HEAD
001738r 2  8A                   TXA                     ; GET HEAD BACK
001739r 2  0D 10 06             ORA     debsehd
00173Cr 2  8D 10 06             STA     debsehd         ; STORE IN SECTOR/HEAD
00173Fr 2               
00173Fr 2  A5 44                LDA     sektrk
001741r 2  8D 11 06             STA     debcyll         ; STORE IN TRACK (lsb)
001744r 2  A5 45                LDA     sektrk+1
001746r 2  8D 12 06             STA     debcylm         ; STORE IN TRACK (msb)
001749r 2               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
001749r 2  AD 12 06             LDA     debcylm
00174Cr 2  4A                   LSR     A
00174Dr 2  8D 12 06             STA     debcylm
001750r 2  AD 11 06             LDA     debcyll
001753r 2  6A                   ROR     A
001754r 2  8D 11 06             STA     debcyll
001757r 2               
001757r 2  AD 12 06             LDA     debcylm
00175Ar 2  4A                   LSR     A
00175Br 2  8D 12 06             STA     debcylm
00175Er 2  AD 11 06             LDA     debcyll
001761r 2  6A                   ROR     A
001762r 2  8D 11 06             STA     debcyll
001765r 2               
001765r 2  AD 12 06             LDA     debcylm
001768r 2  4A                   LSR     A
001769r 2  8D 12 06             STA     debcylm
00176Cr 2  AD 11 06             LDA     debcyll
00176Fr 2  6A                   ROR     A
001770r 2  8D 11 06             STA     debcyll
001773r 2               
001773r 2  AD 12 06             LDA     debcylm
001776r 2  4A                   LSR     A
001777r 2  8D 12 06             STA     debcylm
00177Ar 2  AD 11 06             LDA     debcyll
00177Dr 2  6A                   ROR     A
00177Er 2  8D 11 06             STA     debcyll
001781r 2               ;	ADD SLICE OFFSET
001781r 2  A5 48                LDA     sekdsk          ; GET DRIVE#
001783r 2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
001785r 2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
001786r 2  AA                   TAX                     ; MOVE TO X REGISTER
001787r 2  E8                   INX                     ; WANT SECOND BYTE OF ENTRY
001788r 2  BD 17 06             LDA     dskcfg,X        ; GET SLICE#
00178Br 2  8D 32 06             STA     slicetmp+1      ; SLICE OFFSET MSB
00178Er 2  A9 00                LDA     #0              ; GET SLICE#
001790r 2  8D 31 06             STA     slicetmp        ; SLICE OFFSET LSB
001793r 2  18                   CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
001794r 2  6E 32 06             ROR     slicetmp+1
001797r 2  6E 31 06             ROR     slicetmp
00179Ar 2  6E 32 06             ROR     slicetmp+1
00179Dr 2  6E 31 06             ROR     slicetmp
0017A0r 2               
0017A0r 2  BD 17 06             LDA     dskcfg,X        ; GET SLICE#
0017A3r 2  18                   CLC
0017A4r 2  6D 31 06             ADC     slicetmp
0017A7r 2  8D 31 06             STA     slicetmp
0017AAr 2  A9 00                LDA     #$00            ; LOGIC ERROR FOR SLICES THAT CARRY?
0017ACr 2  6D 32 06             ADC     slicetmp+1      ;
0017AFr 2  8D 32 06             STA     slicetmp+1      ;
0017B2r 2               
0017B2r 2               ; ADD SLICE OFFSET TO TRACK #
0017B2r 2  18                   CLC                     ; clear carry
0017B3r 2  AD 31 06             LDA     slicetmp
0017B6r 2  6D 11 06             ADC     debcyll
0017B9r 2  8D 11 06             STA     debcyll         ; store sum of LSBs
0017BCr 2  AD 32 06             LDA     slicetmp+1
0017BFr 2  6D 12 06             ADC     debcylm         ; add the MSBs using carry from
0017C2r 2  8D 12 06             STA     debcylm         ; the previous calculation
0017C5r 2               
0017C5r 2               
0017C5r 2               ; DISPLAY ON DSKY IF PRESENT
0017C5r 2  A5 48                LDA     sekdsk
0017C7r 2  8D 08 06             STA     DSKY_HEXBUF
0017CAr 2  AD 12 06             LDA     debcylm
0017CDr 2  8D 09 06             STA     DSKY_HEXBUF+1
0017D0r 2  AD 11 06             LDA     debcyll
0017D3r 2  8D 0A 06             STA     DSKY_HEXBUF+2
0017D6r 2  AD 10 06             LDA     debsehd
0017D9r 2  8D 0B 06             STA     DSKY_HEXBUF+3
0017DCr 2  A9 2A                LDA     #42             ; DSKY_BIN2SEG
0017DEr 2  85 32                STA     farfunct
0017E0r 2  20 00 02             JSR     DO_FARCALL
0017E3r 2  A9 29                LDA     #41             ; DSKY_SHOW
0017E5r 2  85 32                STA     farfunct
0017E7r 2  20 00 02             JSR     DO_FARCALL
0017EAr 2  60                   RTS
0017EBr 2               
0017EBr 2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
0017EBr 2               ;
0017EBr 2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
0017EBr 2               ;________________________________________________________________________________________________________________________________
0017EBr 2               ;
0017EBr 2               SETUP_FD_CHS:
0017EBr 2  A5 44                LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0017EDr 2  29 01                AND     #$01            ; FILTER OUT HEAD
0017EFr 2  8D 12 06             STA     debcylm         ; STORE HEAD
0017F2r 2  A5 44                LDA     sektrk          ; SAVE TRACK IN A
0017F4r 2  4A                   LSR     A               ; REMOVE HEAD BIT
0017F5r 2  8D 11 06             STA     debcyll         ; STORE IN TRACK
0017F8r 2  A5 46                LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
0017FAr 2  4A                   LSR     A               ;
0017FBr 2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
0017FCr 2  8D 10 06             STA     debsehd         ; STORE IN SECTOR
0017FFr 2               
0017FFr 2  A5 48                LDA     sekdsk
001801r 2  8D 08 06             STA     DSKY_HEXBUF
001804r 2  AD 12 06             LDA     debcylm
001807r 2  8D 09 06             STA     DSKY_HEXBUF+1
00180Ar 2  AD 11 06             LDA     debcyll
00180Dr 2  8D 0A 06             STA     DSKY_HEXBUF+2
001810r 2  AD 10 06             LDA     debsehd
001813r 2  8D 0B 06             STA     DSKY_HEXBUF+3
001816r 2  A9 2A                LDA     #42             ; DSKY_BIN2SEG
001818r 2  85 32                STA     farfunct
00181Ar 2  20 00 02             JSR     DO_FARCALL
00181Dr 2  A9 29                LDA     #41             ; DSKY_SHOW
00181Fr 2  85 32                STA     farfunct
001821r 2  20 00 02             JSR     DO_FARCALL
001824r 2  60                   RTS
001825r 2               
001825r 2                       .ENDIF
001825r 2               
001825r 2               
001825r 2               ;___DEBSECR______________________________________________________________________________________________
001825r 2               ;
001825r 2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
001825r 2               ;
001825r 2               ;________________________________________________________________________________________________________
001825r 2               DEBSECR:
001825r 2  08                   PHP
001826r 2  48                   PHA
001827r 2  A5 46                LDA     seksec          ;
001829r 2  29 03                AND     #$03            ; GET SECTOR INDEX
00182Br 2  18                   CLC                     ;
00182Cr 2  2A                   ROL     A               ;
00182Dr 2  AA                   TAX                     ;
00182Er 2  BD rr rr             LDA     DEBTAB,X        ;
001831r 2  85 EE                STA     SRC
001833r 2  E8                   INX
001834r 2  BD rr rr             LDA     DEBTAB,X        ;
001837r 2  85 EF                STA     SRC+1           ;
001839r 2  A5 F4                LDA     dmaadr          ;
00183Br 2  85 EC                STA     DEST            ;
00183Dr 2  A5 F5                LDA     dmaadr+1        ;
00183Fr 2  85 ED                STA     DEST+1          ;
001841r 2  20 rr rr             JSR     COPY_DOS_SECTOR ;
001844r 2  68                   PLA
001845r 2  28                   PLP
001846r 2  60                   RTS
001847r 2               
001847r 2               DEBTAB:
001847r 2  00 04                .WORD   hstbuf          ;
001849r 2  80 04                .WORD   hstbuf+128      ;
00184Br 2  00 05                .WORD   hstbuf+256      ;
00184Dr 2  80 05                .WORD   hstbuf+384      ;
00184Fr 2               
00184Fr 2               
00184Fr 2               ;___BLKSECR______________________________________________________________________________________________
00184Fr 2               ;
00184Fr 2               ;	BLOCK 512 BYTE SECTOR FOR DOS/65
00184Fr 2               ;
00184Fr 2               ;________________________________________________________________________________________________________
00184Fr 2               BLKSECR:
00184Fr 2  08                   PHP
001850r 2  A5 46                LDA     seksec          ;
001852r 2  29 03                AND     #$03            ; GET SECTOR INDEX
001854r 2  18                   CLC                     ;
001855r 2  2A                   ROL     A               ;
001856r 2  AA                   TAX                     ;
001857r 2  BD rr rr             LDA     DEBTAB,X        ;
00185Ar 2  85 EC                STA     DEST
00185Cr 2  E8                   INX
00185Dr 2  BD rr rr             LDA     DEBTAB,X        ;
001860r 2  85 ED                STA     DEST+1          ;
001862r 2  A5 F4                LDA     dmaadr          ;
001864r 2  85 EE                STA     SRC             ;
001866r 2  A5 F5                LDA     dmaadr+1        ;
001868r 2  85 EF                STA     SRC+1           ;
00186Ar 2  20 rr rr             JSR     COPY_DOS_SECTOR ;
00186Dr 2  28                   PLP
00186Er 2  60                   RTS
00186Fr 2               
00186Fr 2               
00186Fr 2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00186Fr 2               ;
00186Fr 2               ;	COPY 128 BYTE SECTOR FOR DOS/65
00186Fr 2               ;
00186Fr 2               ;________________________________________________________________________________________________________
00186Fr 2               COPY_DOS_SECTOR:
00186Fr 2  A0 00                LDY     #$00            ;
001871r 2               COPY_DOS_SECTOR1:
001871r 2  B1 EE                LDA     (SRC),Y         ;
001873r 2  91 EC                STA     (DEST),Y        ;
001875r 2  C8                   INY                     ;
001876r 2  98                   TYA                     ;
001877r 2  C9 80                CMP     #$80            ;
001879r 2  D0 F6                BNE     COPY_DOS_SECTOR1;
00187Br 2  60                   RTS
00187Cr 2               
00187Cr 2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00187Cr 2               ;
00187Cr 2               ; GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00187Cr 2               ;
00187Cr 2               ;________________________________________________________________________________________________________
00187Cr 2               GET_DRIVE_DEVICE:
00187Cr 2  8E rr rr             STX     GET_DRIVE_DEVICE_TMP
00187Fr 2  A5 48                LDA     sekdsk          ; GET DRIVE
001881r 2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
001883r 2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
001884r 2  AA                   TAX                     ; MOVE TO X REGISTER
001885r 2  BD 17 06             LDA     dskcfg, X       ; GET device
001888r 2  29 0F                AND     #$0F
00188Ar 2  85 49                STA     currentDrive
00188Cr 2  BD 17 06             LDA     dskcfg, X       ; GET device
00188Fr 2               ; SETUP FLOPPY CONTROL WHILE WE ARE HERE
00188Fr 2  29 01                AND     #$01
001891r 2  8D 28 06             STA     DSKUNIT
001894r 2  BD 17 06             LDA     dskcfg, X       ; GET device
001897r 2  AE rr rr             LDX     GET_DRIVE_DEVICE_TMP
00189Ar 2  60                   RTS
00189Br 2               
00189Br 2               GET_DRIVE_DEVICE_TMP:
00189Br 2  00                   .BYTE   00
00189Cr 2               ;------------------------------------------------------------------------------------
00189Cr 2               
00189Cr 2                       .IFDEF  RBC6X0X
00189Cr 2               ;disk control blocks
00189Cr 2               dcba:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpa           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbb:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpb           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbc:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpc           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbd:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpd           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbe:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpe           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbf:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpf           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbg:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpg           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbh:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almph           ;address of map for a
00189Cr 2                       .BYTE   128             ;no checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               
00189Cr 2               ; See Platform Documentation for Drive Types.
00189Cr 2               dftdskcfg:
00189Cr 2                       .BYTE   $10, $00        ; disk A: unit, slice (invalid for floppy disks) SD
00189Cr 2                       .BYTE   $30, $00        ; disk B: unit, slice (invalid for floppy disks) PPIDE
00189Cr 2                       .BYTE   $90, $00        ; disk C: unit, slice (invalid for floppy disks)
00189Cr 2                       .BYTE   $90, $00        ; disk D: unit, slice (invalid for floppy disks)
00189Cr 2                       .BYTE   $90, $00        ; disk E: unit, slice (invalid for floppy disks)
00189Cr 2                       .BYTE   $90, $00        ; disk F: unit, slice (invalid for floppy disks)
00189Cr 2                       .BYTE   $90, $00        ; disk G: unit, slice (invalid for floppy disks)
00189Cr 2                       .BYTE   $90, $00        ; disk H: unit, slice (invalid for floppy disks)
00189Cr 2               
00189Cr 2               
00189Cr 2               
00189Cr 2                       .ENDIF
00189Cr 2               
00189Cr 2               ;__________________________________________________________________________________________________________________________________
00189Cr 2                       .IFDEF  NHYODYNE
00189Cr 2               dcba:
00189Cr 2                       .WORD   127             ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   0               ;number system tracks
00189Cr 2                       .BYTE   1               ;block size = 2048
00189Cr 2                       .WORD   255             ;max directory number
00189Cr 2                       .WORD   almpa           ;address of map for a
00189Cr 2                       .BYTE   00              ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbb:
00189Cr 2                       .WORD   191             ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   0               ;number system tracks
00189Cr 2                       .BYTE   1               ;block size = 2048
00189Cr 2                       .WORD   155             ;max directory number
00189Cr 2                       .WORD   almpb           ;address of map for b
00189Cr 2                       .BYTE   00              ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbc:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpc           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbd:
00189Cr 2                       .WORD   350             ;max block number
00189Cr 2                       .WORD   36              ;sectors per track
00189Cr 2                       .WORD   4               ;number system tracks
00189Cr 2                       .BYTE   1               ;block size = 2048
00189Cr 2                       .WORD   127             ;max directory number
00189Cr 2                       .WORD   almpd           ;address of map for d
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbe:
00189Cr 2                       .WORD   350             ;max block number
00189Cr 2                       .WORD   36              ;sectors per track
00189Cr 2                       .WORD   4               ;number system tracks
00189Cr 2                       .BYTE   1               ;block size = 2048
00189Cr 2                       .WORD   127             ;max directory number
00189Cr 2                       .WORD   almpe           ;address of map for e
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbf:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpf           ;address of map for f
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbg:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpg           ;address of map for g
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbh:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almph           ;address of map for h
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               
00189Cr 2               dftdskcfg:
00189Cr 2                       .BYTE   $00, $00        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00189Cr 2                       .BYTE   $01, $00        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00189Cr 2                       .BYTE   $30, $06        ; disk C: unit, slice IDE
00189Cr 2                       .BYTE   $20, $00        ; disk D: unit, slice FLOPPY A
00189Cr 2                       .BYTE   $21, $00        ; disk E: unit, slice FLOPPY B
00189Cr 2                       .BYTE   $30, $03        ; disk F: unit, slice IDE
00189Cr 2                       .BYTE   $30, $04        ; disk G: unit, slice IDE
00189Cr 2                       .BYTE   $30, $00        ; disk H: unit, slice IDE
00189Cr 2               
00189Cr 2                       .ENDIF
00189Cr 2               
00189Cr 2               ;__________________________________________________________________________________________________________________________________
00189Cr 2                       .IFDEF  DUODYNE
00189Cr 2               dcba:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpc           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbb:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpc           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbc:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpc           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbd:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpd           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbe:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpe           ;address of map for C
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbf:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpf           ;address of map for f
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbg:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almpg           ;address of map for g
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               dcbh:
00189Cr 2                       .WORD   2047            ;max block number
00189Cr 2                       .WORD   64              ;sectors per track
00189Cr 2                       .WORD   16              ;number system tracks
00189Cr 2                       .BYTE   2               ;block size = 4096
00189Cr 2                       .WORD   511             ;max directory number
00189Cr 2                       .WORD   almph           ;address of map for h
00189Cr 2                       .BYTE   0               ;do checksums
00189Cr 2                       .WORD   ckmp            ;checksum map
00189Cr 2               
00189Cr 2               dftdskcfg:
00189Cr 2                       .BYTE   $30, $02        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00189Cr 2                       .BYTE   $30, $00        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
00189Cr 2                       .BYTE   $30, $01        ; disk C: unit, slice
00189Cr 2                       .BYTE   $30, $02        ; disk D: unit, slice
00189Cr 2                       .BYTE   $30, $03        ; disk E: unit, slice
00189Cr 2                       .BYTE   $30, $04        ; disk F: unit, slice
00189Cr 2                       .BYTE   $30, $05        ; disk G: unit, slice
00189Cr 2                       .BYTE   $30, $06        ; disk H: unit, slice
00189Cr 2                       .ENDIF
00189Cr 2               
00189Cr 2               ;__________________________________________________________________________________________________________________________________
00189Cr 2                       .IFDEF  DUODYNE02
00189Cr 2               dcba:
00189Cr 2  FF 07                .WORD   2047            ;max block number
00189Er 2  40 00                .WORD   64              ;sectors per track
0018A0r 2  10 00                .WORD   16              ;number system tracks
0018A2r 2  02                   .BYTE   2               ;block size = 4096
0018A3r 2  FF 01                .WORD   511             ;max directory number
0018A5r 2  rr rr                .WORD   almpc           ;address of map for C
0018A7r 2  00                   .BYTE   0               ;do checksums
0018A8r 2  rr rr                .WORD   ckmp            ;checksum map
0018AAr 2               dcbb:
0018AAr 2  FF 07                .WORD   2047            ;max block number
0018ACr 2  40 00                .WORD   64              ;sectors per track
0018AEr 2  10 00                .WORD   16              ;number system tracks
0018B0r 2  02                   .BYTE   2               ;block size = 4096
0018B1r 2  FF 01                .WORD   511             ;max directory number
0018B3r 2  rr rr                .WORD   almpc           ;address of map for C
0018B5r 2  00                   .BYTE   0               ;do checksums
0018B6r 2  rr rr                .WORD   ckmp            ;checksum map
0018B8r 2               dcbc:
0018B8r 2  FF 07                .WORD   2047            ;max block number
0018BAr 2  40 00                .WORD   64              ;sectors per track
0018BCr 2  10 00                .WORD   16              ;number system tracks
0018BEr 2  02                   .BYTE   2               ;block size = 4096
0018BFr 2  FF 01                .WORD   511             ;max directory number
0018C1r 2  rr rr                .WORD   almpc           ;address of map for C
0018C3r 2  00                   .BYTE   0               ;do checksums
0018C4r 2  rr rr                .WORD   ckmp            ;checksum map
0018C6r 2               dcbd:
0018C6r 2  FF 07                .WORD   2047            ;max block number
0018C8r 2  40 00                .WORD   64              ;sectors per track
0018CAr 2  10 00                .WORD   16              ;number system tracks
0018CCr 2  02                   .BYTE   2               ;block size = 4096
0018CDr 2  FF 01                .WORD   511             ;max directory number
0018CFr 2  rr rr                .WORD   almpd           ;address of map for C
0018D1r 2  00                   .BYTE   0               ;do checksums
0018D2r 2  rr rr                .WORD   ckmp            ;checksum map
0018D4r 2               dcbe:
0018D4r 2  FF 07                .WORD   2047            ;max block number
0018D6r 2  40 00                .WORD   64              ;sectors per track
0018D8r 2  10 00                .WORD   16              ;number system tracks
0018DAr 2  02                   .BYTE   2               ;block size = 4096
0018DBr 2  FF 01                .WORD   511             ;max directory number
0018DDr 2  rr rr                .WORD   almpe           ;address of map for C
0018DFr 2  00                   .BYTE   0               ;do checksums
0018E0r 2  rr rr                .WORD   ckmp            ;checksum map
0018E2r 2               dcbf:
0018E2r 2  FF 07                .WORD   2047            ;max block number
0018E4r 2  40 00                .WORD   64              ;sectors per track
0018E6r 2  10 00                .WORD   16              ;number system tracks
0018E8r 2  02                   .BYTE   2               ;block size = 4096
0018E9r 2  FF 01                .WORD   511             ;max directory number
0018EBr 2  rr rr                .WORD   almpf           ;address of map for f
0018EDr 2  00                   .BYTE   0               ;do checksums
0018EEr 2  rr rr                .WORD   ckmp            ;checksum map
0018F0r 2               dcbg:
0018F0r 2  FF 07                .WORD   2047            ;max block number
0018F2r 2  40 00                .WORD   64              ;sectors per track
0018F4r 2  10 00                .WORD   16              ;number system tracks
0018F6r 2  02                   .BYTE   2               ;block size = 4096
0018F7r 2  FF 01                .WORD   511             ;max directory number
0018F9r 2  rr rr                .WORD   almpg           ;address of map for g
0018FBr 2  00                   .BYTE   0               ;do checksums
0018FCr 2  rr rr                .WORD   ckmp            ;checksum map
0018FEr 2               dcbh:
0018FEr 2  FF 07                .WORD   2047            ;max block number
001900r 2  40 00                .WORD   64              ;sectors per track
001902r 2  10 00                .WORD   16              ;number system tracks
001904r 2  02                   .BYTE   2               ;block size = 4096
001905r 2  FF 01                .WORD   511             ;max directory number
001907r 2  rr rr                .WORD   almph           ;address of map for h
001909r 2  00                   .BYTE   0               ;do checksums
00190Ar 2  rr rr                .WORD   ckmp            ;checksum map
00190Cr 2               
00190Cr 2               dftdskcfg:
00190Cr 2  30 02                .BYTE   $30, $02        ; disk A: unit, slice (invalid for floppy and RAM disks) MD RAM
00190Er 2  30 00                .BYTE   $30, $00        ; disk B: unit, slice (invalid for floppy and RAM disks) MD ROM
001910r 2  30 01                .BYTE   $30, $01        ; disk C: unit, slice
001912r 2  30 02                .BYTE   $30, $02        ; disk D: unit, slice
001914r 2  30 03                .BYTE   $30, $03        ; disk E: unit, slice
001916r 2  30 04                .BYTE   $30, $04        ; disk F: unit, slice
001918r 2  30 05                .BYTE   $30, $05        ; disk G: unit, slice
00191Ar 2  30 06                .BYTE   $30, $06        ; disk H: unit, slice
00191Cr 2                       .ENDIF
00191Cr 2               
00191Cr 2               
00191Cr 2               ;allocation maps
00191Cr 2               almpa:
00191Cr 2  xx xx xx xx          .RES    256
001920r 2  xx xx xx xx  
001924r 2  xx xx xx xx  
001A1Cr 2               almpb:
001A1Cr 2  xx xx xx xx          .RES    256
001A20r 2  xx xx xx xx  
001A24r 2  xx xx xx xx  
001B1Cr 2               almpc:
001B1Cr 2  xx xx xx xx          .RES    256
001B20r 2  xx xx xx xx  
001B24r 2  xx xx xx xx  
001C1Cr 2               almpd:
001C1Cr 2  xx xx xx xx          .RES    256
001C20r 2  xx xx xx xx  
001C24r 2  xx xx xx xx  
001D1Cr 2               almpe:
001D1Cr 2  xx xx xx xx          .RES    256
001D20r 2  xx xx xx xx  
001D24r 2  xx xx xx xx  
001E1Cr 2               almpf:
001E1Cr 2  xx xx xx xx          .RES    256
001E20r 2  xx xx xx xx  
001E24r 2  xx xx xx xx  
001F1Cr 2               almpg:
001F1Cr 2  xx xx xx xx          .RES    256
001F20r 2  xx xx xx xx  
001F24r 2  xx xx xx xx  
00201Cr 2               almph:
00201Cr 2  xx xx xx xx          .RES    256
002020r 2  xx xx xx xx  
002024r 2  xx xx xx xx  
00211Cr 2               
00211Cr 2               ;checksum maps
00211Cr 2               ;drive a
00211Cr 2               ckmp:
00211Cr 2  xx xx xx xx          .RES    128
002120r 2  xx xx xx xx  
002124r 2  xx xx xx xx  
00219Cr 2               
00219Cr 1               
00219Cr 1               ;       Page Align
00219Cr 1  xx xx xx xx          .ALIGN  256
0021A0r 1  xx xx xx xx  
0021A4r 1  xx xx xx xx  
002200r 1               OSEND:
002200r 1               
002200r 1               
002200r 1               DRIVERBEGIN:
002200r 1                       .INCLUDE "dos65drv.asm"
002200r 2               ;________________________________________________________________________________________________________________________________
002200r 2               ;
002200r 2               ;	Nhyodyne dos/65 banked driver code
002200r 2               ;       Intended for RAM BANK $85
002200r 2               ;
002200r 2               ;  DWERNER 05/3/2025 	Initial
002200r 2               ;________________________________________________________________________________________________________________________________
002200r 2               
002200r 2               DSKYOSC         = 1000000       ; Set DSKY NG Osc frequency
002200r 2               
002200r 2                       .SEGMENT "DRIVERS"
000000r 2                       .ORG    $8800
008800  2               ;       Area from $85:8000 to $85:8800 reserved for work RAM for drivers
008800  2               ;
008800  2               
008800  2               ;__DISPATCHER________________________________________________________________________________________
008800  2               ;
008800  2               ;  Function dispatcher
008800  2               ;  function to call is located in "farfunct"
008800  2               ;____________________________________________________________________________________________________
008800  2               ;
008800  2               FUNCTION_DISPATCHER:
008800  2  48                   PHA
008801  2  8A                   TXA
008802  2  48                   PHA
008803  2  A5 32                LDA     farfunct
008805  2  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
008806  2  AA                   TAX
008807  2  BD 17 88             LDA     DISPATCHTABLE,X
00880A  2  85 33                STA     farpointer
00880C  2  BD 18 88             LDA     DISPATCHTABLE+1,X
00880F  2  85 34                STA     farpointer+1
008811  2               
008811  2  68                   PLA
008812  2  AA                   TAX
008813  2  68                   PLA
008814  2  6C 33 00             JMP     (farpointer)
008817  2               
008817  2               
008817  2               DISPATCHTABLE:
008817  2  E1 92                .WORD   DFT_CONSOLE     ; FUNCTION 00 - WRITE CONSOLE
008819  2  E1 92                .WORD   DFT_CONSOLE     ; FUNCTION 01 - READ CONSOLE
00881B  2  E1 92                .WORD   DFT_CONSOLE     ; FUNCTION 02 - READ CONSOLE (BLOCKING)
00881D  2  E1 92                .WORD   DFT_CONSOLE     ; FUNCTION 03 - GET CONSOLE STATUS
00881F  2               
00881F  2  41 89                .WORD   WRSER1          ; FUNCTION 04 - WRITE SERIAL PORT
008821  2  50 89                .WORD   RDSER1          ; FUNCTION 05 - READ SERIAL PORT
008823  2  60 89                .WORD   RDSER1W         ; FUNCTION 06 - READ SERIAL PORT (BLOCKING)
008825  2  6F 89                .WORD   SERIALSTATUS    ; FUNCTION 07 - GET SERIAL STATUS
008827  2  36 89                .WORD   SERIALINIT      ; FUNCTION 08 - SERIAL PORT INIT
008829  2               
008829  2  41 89                .WORD   WRSER1          ; FUNCTION 09 - WRITE VIDEO
00882B  2  50 89                .WORD   RDSER1          ; FUNCTION 10 - READ KEYBOARD
00882D  2  60 89                .WORD   RDSER1W         ; FUNCTION 11 - READ KEYBOARD (BLOCKING)
00882F  2  6F 89                .WORD   SERIALSTATUS    ; FUNCTION 12 - GET KEYBOARD STATUS
008831  2  36 89                .WORD   SERIALINIT      ; FUNCTION 13 - INIT INTERFACE
008833  2               
008833  2  EE 92                .WORD   drv_noop        ; FUNCTION 14
008835  2  EE 92                .WORD   drv_noop        ; FUNCTION 15
008837  2  EE 92                .WORD   drv_noop        ; FUNCTION 16
008839  2  EE 92                .WORD   drv_noop        ; FUNCTION 17
00883B  2  EE 92                .WORD   drv_noop        ; FUNCTION 18
00883D  2  EE 92                .WORD   drv_noop        ; FUNCTION 19
00883F  2  EE 92                .WORD   drv_noop        ; FUNCTION 20
008841  2  EE 92                .WORD   drv_noop        ; FUNCTION 21
008843  2  EE 92                .WORD   drv_noop        ; FUNCTION 22
008845  2  EE 92                .WORD   drv_noop        ; FUNCTION 23
008847  2  EE 92                .WORD   drv_noop        ; FUNCTION 24
008849  2  EE 92                .WORD   drv_noop        ; FUNCTION 25
00884B  2  EE 92                .WORD   drv_noop        ; FUNCTION 26
00884D  2  EE 92                .WORD   drv_noop        ; FUNCTION 27
00884F  2  EE 92                .WORD   drv_noop        ; FUNCTION 28
008851  2  EE 92                .WORD   drv_noop        ; FUNCTION 29
008853  2  EE 92                .WORD   drv_noop        ; FUNCTION 30
008855  2  EE 92                .WORD   drv_noop        ; FUNCTION 31
008857  2  EE 92                .WORD   drv_noop        ; FUNCTION 32
008859  2  EE 92                .WORD   drv_noop        ; FUNCTION 33
00885B  2  EE 92                .WORD   drv_noop        ; FUNCTION 34
00885D  2  EE 92                .WORD   drv_noop        ; FUNCTION 35
00885F  2  EE 92                .WORD   drv_noop        ; FUNCTION 36
008861  2  EE 92                .WORD   drv_noop        ; FUNCTION 37
008863  2  EE 92                .WORD   drv_noop        ; FUNCTION 38
008865  2  EE 92                .WORD   drv_noop        ; FUNCTION 39
008867  2               ;
008867  2  EE 92                .WORD   drv_noop        ;DSKY_INIT       ; FUNCTION 40 -
008869  2  EE 92                .WORD   drv_noop        ;DSKY_SHOW       ; FUNCTION 41 -
00886B  2  EE 92                .WORD   drv_noop        ;DSKY_BIN2SEG    ; FUNCTION 42 -
00886D  2  EE 92                .WORD   drv_noop        ;DSKY_RESET      ; FUNCTION 43 -
00886F  2  EE 92                .WORD   drv_noop        ;DSKY_STAT       ; FUNCTION 44 -
008871  2  EE 92                .WORD   drv_noop        ;DSKY_GETKEY     ; FUNCTION 45 -
008873  2  EE 92                .WORD   drv_noop        ;DSKY_BEEP       ; FUNCTION 46 -
008875  2  EE 92                .WORD   drv_noop        ;DSKY_DSPL       ; FUNCTION 47 -
008877  2  EE 92                .WORD   drv_noop        ;DSKY_PUTLED     ; FUNCTION 48 -
008879  2  EE 92                .WORD   drv_noop        ;DSKY_BLANK      ; FUNCTION 49 -
00887B  2               ;
00887B  2  92 8E                .WORD   RTC_WRITE       ; FUNCTION 50 - WRITE RTC REGISTER
00887D  2  93 8E                .WORD   RTC_READ        ; FUNCTION 51 - READ RTC REGISTER
00887F  2  39 8E                .WORD   RTC_INIT        ; FUNCTION 52 - INIT RTC
008881  2  94 8E                .WORD   RTC_LED         ; FUNCTION 53 - CONTROL LEDS
008883  2  95 8E                .WORD   RTC_BUTTON      ; FUNCTION 54 - READ BUTTON
008885  2  96 8E                .WORD   RTC_BEEP        ; FUNCTION 55 - MAKE SOME NOISE
008887  2               ;
008887  2  EE 92                .WORD   drv_noop        ; FUNCTION 56
008889  2  EE 92                .WORD   drv_noop        ; FUNCTION 57
00888B  2  EE 92                .WORD   drv_noop        ; FUNCTION 58
00888D  2  EE 92                .WORD   drv_noop        ; FUNCTION 59
00888F  2               
00888F  2  7E 89                .WORD   PPIDE_INIT      ; FUNCTION 60 - called during OS init
008891  2  46 8C                .WORD   IDE_READ_SECTOR ; FUNCTION 61 - read a sector from drive
008893  2  9A 8C                .WORD   IDE_WRITE_SECTOR; FUNCTION 62 - write a sector to drive
008895  2               
008895  2  EE 92                .WORD   drv_noop        ; FUNCTION 63 - init the mem device
008897  2  EE 92                .WORD   drv_noop        ; FUNCTION 64 - read a sector from the memory device
008899  2  EE 92                .WORD   drv_noop        ; FUNCTION 65 - write a sector to the memory device
00889B  2               
00889B  2  9E 8E                .WORD   FL_SETUP        ; FUNCTION 66 - init floppy device
00889D  2  C9 8F                .WORD   FL_READ_SECTOR  ; FUNCTION 67 - read a sector from floppy device
00889F  2  54 90                .WORD   FL_WRITE_SECTOR ; FUNCTION 68 - write a sector to floppy device
0088A1  2               
0088A1  2               
0088A1  2               ;__DRIVERS___________________________________________________________________________________________
0088A1  2               ;
0088A1  2                       .INCLUDE "drvmacros.asm"
0088A1  3               ;___________________________________________________________________________________________________
0088A1  3               ;
0088A1  3               ;	USEFUL MACROS
0088A1  3               ;__________________________________________________________________________________________________
0088A1  3               .macro          PRTDBG      message
0088A1  3               .LOCAL p1
0088A1  3               .LOCAL p2
0088A1  3               .LOCAL p3
0088A1  3               .LOCAL p4
0088A1  3               .LOCAL p5
0088A1  3                 .if     .paramcount <> 1
0088A1  3                       .error  "Too few parameters for macro PRTDBG"
0088A1  3                       .endif
0088A1  3                       .if DEBUG=1
0088A1  3                       PHA
0088A1  3                       txa
0088A1  3                       PHA
0088A1  3                       tya
0088A1  3                       PHA
0088A1  3                       LDX #$00
0088A1  3               p1:
0088A1  3                       LDA p4,x
0088A1  3                       INX
0088A1  3                       CMP #'$'
0088A1  3                       BEQ p2
0088A1  3                       JSR MACRO_OUTCH
0088A1  3                       JMP p1
0088A1  3               p2:
0088A1  3                       LDA #13
0088A1  3                       jsr MACRO_OUTCH
0088A1  3                       LDA #10
0088A1  3                       jsr MACRO_OUTCH
0088A1  3                       PLA
0088A1  3                       tay
0088A1  3                       PLA
0088A1  3                       tax
0088A1  3                       pla
0088A1  3                       JMP p5
0088A1  3               p4:
0088A1  3                       .BYTE message
0088A1  3               p5:
0088A1  3                       .endif
0088A1  3               .endmacro
0088A1  3               
0088A1  3               .macro          PRTS      message
0088A1  3               .LOCAL p1
0088A1  3               .LOCAL p2
0088A1  3               .LOCAL p3
0088A1  3               .LOCAL p4
0088A1  3               .LOCAL p5
0088A1  3                 .if     .paramcount <> 1
0088A1  3                       .error  "Too few parameters for macro PRTS"
0088A1  3                       .endif
0088A1  3                       PHA
0088A1  3                       TXA
0088A1  3                       PHA
0088A1  3                       TYA
0088A1  3                       PHA
0088A1  3                       LDX #$00
0088A1  3               p1:
0088A1  3                       LDA p4,x
0088A1  3                       INX
0088A1  3                       CMP #'$'
0088A1  3                       BEQ p2
0088A1  3                       JSR MACRO_OUTCH
0088A1  3                       JMP p1
0088A1  3               p2:
0088A1  3                       PLA
0088A1  3                       TAY
0088A1  3                       PLA
0088A1  3                       TAX
0088A1  3                       PLA
0088A1  3                       JMP p5
0088A1  3               p4:
0088A1  3                       .BYTE message
0088A1  3               p5:
0088A1  3               .endmacro
0088A1  3               
0088A1  3               .macro          DBGFLAG      character
0088A1  3                 .if     .paramcount <> 1
0088A1  3                       .error  "Too few parameters for macro DBGFLAG"
0088A1  3                       .endif
0088A1  3                       .if DEBUG=1
0088A1  3                       PHA
0088A1  3                       LDA #character
0088A1  3                       JSR MACRO_OUTCH
0088A1  3                       pla
0088A1  3                       .endif
0088A1  3               .endmacro
0088A1  3               
0088A1  3               
0088A1  3               ;__PRTHEXBYTE__________________________________________________
0088A1  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0088A1  3               ;______________________________________________________________
0088A1  3               PRTHEXBYTE:
0088A1  3  48                   PHA
0088A2  3  8D 35 06             sta     STACKA
0088A5  3  8A                   txa
0088A6  3  48                   PHa
0088A7  3  98                   tya
0088A8  3  48                   PHA
0088A9  3  AD 35 06             lda     STACKA
0088AC  3  AA                   TAX				; SAVE A REGISTER
0088AD  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
0088AE  3  4A                   LSR 				;
0088AF  3  4A                   LSR 				;
0088B0  3  4A                   LSR 				;
0088B1  3  18                   CLC               		; CLEAR CARRY
0088B2  3  20 BF 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0088B5  3  8A                   TXA				; RESTORE ACCUMULATOR
0088B6  3  20 BF 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0088B9  3  68                   pla
0088BA  3  A8                   TAY
0088BB  3  68                   pla
0088BC  3  AA                   TAX
0088BD  3  68                   PLA
0088BE  3  60                   RTS
0088BF  3               
0088BF  3               ;__PRINT_DIGIT_________________________________________________
0088BF  3               ;
0088BF  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0088BF  3               ;
0088BF  3               ;______________________________________________________________
0088BF  3               PRINT_DIGIT:
0088BF  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
0088C1  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
0088C3  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
0088C5  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0088C7  3  18                          CLC				; CLEAR CARRY
0088C8  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
0088CA  3               PRINT_DIGIT_OUT:					;
0088CA  3  4C 2C 89                    JMP MACRO_OUTCH              		; PRINT OUT CHAR
0088CD  3               
0088CD  3               NEWLINE:
0088CD  3  48                           pha
0088CE  3  A9 0D                        LDA #$0D
0088D0  3  20 2C 89                     JSR MACRO_OUTCH
0088D3  3  A9 0A                        LDA #$0A
0088D5  3  20 2C 89                     Jsr MACRO_OUTCH
0088D8  3  68                           pla
0088D9  3  60                           rts
0088DA  3               SPACE:
0088DA  3  48                           pha
0088DB  3  A9 20                        LDA #' '
0088DD  3  20 2C 89                     JSR MACRO_OUTCH
0088E0  3  68                           pla
0088E1  3  60                           rts
0088E2  3               
0088E2  3               
0088E2  3               PRTDEC:
0088E2  3  48                           PHA
0088E3  3  8D 35 06                     STA     STACKA
0088E6  3  98                           TYA
0088E7  3  48                           phA
0088E8  3  8A                           TXA
0088E9  3  48                           PHA
0088EA  3  AD 35 06                     LDA     STACKA
0088ED  3  48                           PHA
0088EE  3  A0 00                        ldy #00
0088F0  3  A2 FF                        LDX #$FF
0088F2  3  38                           SEC
0088F3  3               PrDec100:
0088F3  3  E8                           INX
0088F4  3  E9 64                        SBC #100
0088F6  3  B0 FB                        BCS PrDec100            ;Count how many 100s
0088F8  3  69 64                        ADC #100
0088FA  3  20 16 89                     JSR PrDecDigit          ;Print the 100s
0088FD  3  A2 FF                        LDX #$FF
0088FF  3  38                           SEC                     ;Prepare for subtraction
008900  3               PrDec10:
008900  3  E8                           INX
008901  3  E9 0A                        SBC #10
008903  3  B0 FB                        BCS PrDec10             ;Count how many 10s
008905  3  69 0A                        ADC #10
008907  3  20 16 89                     JSR PrDecDigit          ;Print the 10s
00890A  3  AA                           TAX                     ;Pass 1s into X
00890B  3  A0 01                        ldy #1
00890D  3  20 16 89                     JSR PrDecDigit          ;Print the 1s
008910  3  68                           PLA
008911  3  68                           pla
008912  3  AA                           TAX
008913  3  68                           pla
008914  3  A8                           TAY
008915  3  60                           RTS
008916  3               PrDecDigit:
008916  3  48                           PHA
008917  3  C0 00                        cpy #$00
008919  3  D0 09                        bne PrDecDigit1
00891B  3  8A                           txa
00891C  3  A8                           tay
00891D  3  C0 00                        cpy #$00
00891F  3  D0 03                        bne PrDecDigit1
008921  3  4C 2A 89                     jmp PrDecDigit2
008924  3               PrDecDigit1:
008924  3  8A                           TXA                     ;Save A, pass digit to A
008925  3  09 30                        ORA #'0'
008927  3  20 2C 89                     JSR  MACRO_OUTCH        ;Convert to character and print it
00892A  3               PrDecDigit2:
00892A  3  68                           PLA
00892B  3  60                           RTS                     ;Restore A and return
00892C  3               
00892C  3               
00892C  3               MACRO_OUTCH:
00892C  3  48                   PHA
00892D  3  AD 0F 06             LDA     CONSOLE
008930  3  85 32                STA     farfunct
008932  3  68                   PLA
008933  3  4C 00 88             JMP     FUNCTION_DISPATCHER
008936  3               ;
008936  3               
008936  2                       .INCLUDE "dosser.asm"
008936  3               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
008936  3               ;
008936  3               ; 	Nhyodyne serial drivers for single serial port card
008936  3               ;
008936  3               ;	Entry points:
008936  3               ;		SERIALINIT  - called during OS init
008936  3               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
008936  3               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
008936  3               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
008936  3               ;		SERIALSTATUS- GET UART STATUS
008936  3               ;________________________________________________________________________________________________________________________________
008936  3               ;
008936  3               
008936  3               
008936  3               ;*
008936  3               ;* HARDWARE I/O ADDRESSES
008936  3               ;*
008936  3               
008936  3               
008936  3               ;__________________________________________________________________________________________________
008936  3               ; $8000-$8007 UART 16C550
008936  3               ;__________________________________________________________________________________________________
008936  3               UART0           = IO+$58        ;   DATA IN/OUT
008936  3               UART1           = IO+$59        ;   CHECK RX
008936  3               UART2           = IO+$5A        ;   INTERRUPTS
008936  3               UART3           = IO+$5B        ;   LINE CONTROL
008936  3               UART4           = IO+$5C        ;   MODEM CONTROL
008936  3               UART5           = IO+$5D        ;   LINE STATUS
008936  3               UART6           = IO+$5E        ;   MODEM STATUS
008936  3               UART7           = IO+$5F        ;   SCRATCH REG.
008936  3               
008936  3               
008936  3               ;__SERIALINIT____________________________________________________________________________________________________________________
008936  3               ;
008936  3               ;	INITIALIZE SERIAL PORTS
008936  3               ;________________________________________________________________________________________________________________________________
008936  3               ;
008936  3               SERIALINIT:
008936  3               ;	LDA	#$80		;
008936  3               ;	STA	UART3		; SET DLAB FLAG
008936  3               ;	LDA	#12		; SET TO 12 = 9600 BAUD
008936  3               ;	STA	UART0		; save baud rate
008936  3               ;	LDA	#00		;
008936  3               ;	STA	UART1		;
008936  3               ;	LDA	#03		;
008936  3               ;	STA	UART3		; SET 8 BIT DATA, 1 STOPBIT
008936  3  A9 81                LDA     #$81            ; Enable FIFOs
008938  3  8D 5A 03             STA     UART2           ;
00893B  3  A9 2B                LDA     #$2B            ; Enable Auto Flow Control $03 to disable AFC
00893D  3  8D 5C 03             STA     UART4
008940  3  60                   RTS
008941  3               
008941  3               
008941  3               
008941  3               ;__WRSER1________________________________________________________________________________________________________________________
008941  3               ;
008941  3               ;	WRITE CHARACTER(A) TO UART
008941  3               ;________________________________________________________________________________________________________________________________
008941  3               ;
008941  3               WRSER1:
008941  3  48                   PHA
008942  3               WRSER1a:
008942  3  AD 5D 03             LDA     UART5           ; Is the destination ready?
008945  3  29 20                AND     #$20
008947  3  C9 00                CMP     #$00
008949  3  F0 F7                BEQ     WRSER1a         ; NO, WAIT FOR IT
00894B  3  68                   PLA
00894C  3  8D 58 03             STA     UART0           ; THEN WRITE THE CHAR TO UART
00894F  3  60                   RTS
008950  3               
008950  3               ;__RDSER1________________________________________________________________________________________________________________________
008950  3               ;
008950  3               ;	READ CHARACTER FROM UART TO (A)
008950  3               ;________________________________________________________________________________________________________________________________
008950  3               ;
008950  3               RDSER1:
008950  3  AD 5D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008953  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008955  3  C9 00                CMP     #$00
008957  3  F0 04                BEQ     RDSER1N         ; LOOP UNTIL DATA IS READY
008959  3  AD 58 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
00895C  3  60                   RTS
00895D  3               RDSER1N:
00895D  3  A9 00                LDA     #$00            ;
00895F  3  60                   RTS                     ;
008960  3               
008960  3               ;__RDSER1W_______________________________________________________________________________________________________________________
008960  3               ;
008960  3               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
008960  3               ;________________________________________________________________________________________________________________________________
008960  3               ;
008960  3               
008960  3               RDSER1W:
008960  3  AD 5D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008963  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008965  3  C9 00                CMP     #$00
008967  3  F0 F7                BEQ     RDSER1W         ; LOOP UNTIL DATA IS READY
008969  3  AD 58 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
00896C  3  29 7F                AND     #$7F
00896E  3  60                   RTS
00896F  3               
00896F  3               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00896F  3               ;
00896F  3               ;	READ UARD STATUS
00896F  3               ;________________________________________________________________________________________________________________________________
00896F  3               ;
00896F  3               SERIALSTATUS:
00896F  3  AD 5D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008972  3  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008974  3  C9 00                CMP     #$00
008976  3  F0 03                BEQ     RDSTAT1         ; NO, INDICATE NO CHAR
008978  3  A9 FF                LDA     #$FF            ; GET DATA CHAR
00897A  3  60                   RTS
00897B  3               RDSTAT1:
00897B  3  A9 00                LDA     #$00            ; GET DATA CHAR
00897D  3  60                   RTS
00897E  3               
00897E  3               ; end
00897E  3               
00897E  2                       .INCLUDE "doside.asm"
00897E  3               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00897E  3               ;
00897E  3               ; 	Duoodyne IDE disk drivers for DiskIO card
00897E  3               ;
00897E  3               ;	Entry points:
00897E  3               ;		PPIDE_INIT   	- called during OS init
00897E  3               ;		IDE_READ_SECTOR - read a sector from drive
00897E  3               ;		IDE_WRITE_SECTOR- write a sector to drive
00897E  3               ;________________________________________________________________________________________________________________________________
00897E  3               ;
00897E  3               PPIDE_PPI       = IO+$88        ; PORT A
00897E  3               ;
00897E  3               PPIDELO         = PPIDE_PPI+0   ; LSB
00897E  3               PPIDEHI         = PPIDE_PPI+1   ; MSB
00897E  3               PPIDECNTRL      = PPIDE_PPI+2   ; Control Signals
00897E  3               PPIDEPPIC       = PPIDE_PPI+3   ; CONTROL BYTE PPI 82C55
00897E  3               
00897E  3               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
00897E  3               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
00897E  3               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
00897E  3               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00897E  3               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00897E  3               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00897E  3               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00897E  3               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
00897E  3               
00897E  3               PPIDE_DATA      = PPIDE_CS0_LINE
00897E  3               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
00897E  3               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
00897E  3               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00897E  3               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
00897E  3               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
00897E  3               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00897E  3               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00897E  3               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00897E  3               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00897E  3               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00897E  3               
00897E  3               
00897E  3               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00897E  3               PPIDE_CMD_RECAL = $10
00897E  3               PPIDE_CMD_READ  = $20
00897E  3               PPIDE_CMD_WRITE = $30
00897E  3               PPIDE_CMD_INIT  = $91
00897E  3               PPIDE_CMD_ID    = $EC
00897E  3               PPIDE_CMD_SPINDOWN = $E0
00897E  3               PPIDE_CMD_SPINUP = $E1
00897E  3               
00897E  3               
00897E  3               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00897E  3               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
00897E  3               
00897E  3               
00897E  3               ;__PPIDE_INIT_________________________________________________________________________________________
00897E  3               ;
00897E  3               ;  INIT AND DISPLAY IDE INFO
00897E  3               ;____________________________________________________________________________________________________
00897E  3               ;
00897E  3               PPIDE_INIT:
00897E  3                       PRTDBG  "PPIDE INIT:$"
00897E  3  48 8A 48 98          PRTS    "PPIDE :$"
008982  3  48 A2 00 BD  
008986  3  9B 89 E8 C9  
0089A3  3  20 CD 88             JSR     NEWLINE
0089A6  3  20 38 8C             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
0089A9  3  D0 39                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
0089AB  3               ;
0089AB  3  48 8A 48 98          PRTS    " IO=0x$"
0089AF  3  48 A2 00 BD  
0089B3  3  C8 89 E8 C9  
0089CF  3  A9 03                LDA     #>PPIDE_PPI     ; GET BASE PORT
0089D1  3  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0089D4  3  A9 88                LDA     #<PPIDE_PPI     ; GET BASE PORT
0089D6  3  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
0089D9  3               ;
0089D9  3  20 C9 8C             JSR     PPIDE_RESET     ; RESET THE BUS
0089DC  3  20 7E 8A             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
0089DF  3  B0 03                BCS     IDE_ABORT
0089E1  3  4C 11 8A             JMP     IDE_PRINT_INFO
0089E4  3               IDE_ABORT:
0089E4  3  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT PRESENT
0089E8  3  48 A2 00 BD  
0089EC  3  01 8A E8 C9  
008A0E  3  4C 7A 8A             JMP     IDE_INITA
008A11  3               IDE_PRINT_INFO:
008A11  3  20 CD 88             JSR     NEWLINE
008A14  3  48 8A 48 98          PRTS    " PPIDE0: Blocks=$"
008A18  3  48 A2 00 BD  
008A1C  3  31 8A E8 C9  
008A42  3  A9 00                LDA     #$00
008A44  3  20 07 8B             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A47  3  48 8A 48 98          PRTS    " PPIDE1: Blocks=$"
008A4B  3  48 A2 00 BD  
008A4F  3  64 8A E8 C9  
008A75  3  A9 01                LDA     #$01
008A77  3  20 07 8B             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A7A  3               IDE_INITA:
008A7A  3  20 CD 88             JSR     NEWLINE
008A7D  3  60                   RTS                     ; DONE
008A7E  3               ;
008A7E  3               ;__PPIDE_PROBE_______________________________________________________________________________________
008A7E  3               ;
008A7E  3               ;  PROBE FOR IDE HARDWARE
008A7E  3               ;____________________________________________________________________________________________________
008A7E  3               ;
008A7E  3               PPIDE_PROBE:
008A7E  3               ;
008A7E  3               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008A7E  3               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008A7E  3               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008A7E  3               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008A7E  3               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008A7E  3               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008A7E  3               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008A7E  3               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008A7E  3               
008A7E  3  A9 00                LDA     #$00
008A80  3  8D 88 03             STA     PPIDELO         ; PPI PORT A, DATALO
008A83  3               
008A83  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
008A86  3  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
008A88  3  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
008A8A  3  20 F1 8D             JSR     IDE_READ
008A8D  3  8A                   TXA
008A8E  3  29 40                AND     #%01000000
008A90  3  C9 00                CMP     #$00
008A92  3  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008A94  3               
008A94  3               ; CHECK SIGNATURE
008A94  3  A9 0A                LDA     #PPIDE_SEC_CNT
008A96  3  20 F1 8D             JSR     IDE_READ
008A99  3  E0 01                CPX     #$01
008A9B  3  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A9D  3  A9 0B                LDA     #PPIDE_LBALOW
008A9F  3  20 F1 8D             JSR     IDE_READ
008AA2  3  E0 01                CPX     #$01
008AA4  3  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008AA6  3  A9 0C                LDA     #PPIDE_LBAMID
008AA8  3  20 F1 8D             JSR     IDE_READ
008AAB  3  E0 00                CPX     #$00
008AAD  3  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008AAF  3  A9 0D                LDA     #PPIDE_LBAHI
008AB1  3  20 F1 8D             JSR     IDE_READ
008AB4  3  E0 00                CPX     #$00
008AB6  3  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008AB8  3  18                   CLC
008AB9  3  4C BD 8A             JMP     PPIDE_PROBE_SUCCESS
008ABC  3               PPIDE_PROBE_FAIL:
008ABC  3  38                   SEC
008ABD  3               PPIDE_PROBE_SUCCESS:
008ABD  3  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
008ABE  3               
008ABE  3               
008ABE  3               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008ABE  3               ;
008ABE  3               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008ABE  3               ; 	A=IDE DEVICE (0=MST,1=SLV)
008ABE  3               ;________________________________________________________________________________________________________
008ABE  3               
008ABE  3               IDE_IDENTIFY_TYPE:
008ABE  3  48                   PHA
008ABF  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008AC2  3  B0 40                BCS     IDE_IDENTIFY_TYPE_ERROR; IF TIMEOUT, REPORT ERROR
008AC4  3  A9 00                LDA     #$00
008AC6  3  8D 10 06             STA     debsehd
008AC9  3  8D 11 06             STA     debcyll         ; STORE IN TRACK (lsb)
008ACC  3  8D 12 06             STA     debcylm         ; STORE IN TRACK (msb)
008ACF  3  68                   PLA                     ; GET DRIVE TYPE
008AD0  3  20 6C 8C             JSR     IDE_READ_SECTOR_DIRTY1
008AD3  3  C9 FF                CMP     #$FF            ; IS THERE A READ ERROR?
008AD5  3  F0 2D                BEQ     IDE_IDENTIFY_TYPE_ERROR
008AD7  3  AD FE 05             LDA     hstbuf+$01FE
008ADA  3  C9 55                CMP     #$55
008ADC  3  D0 23                BNE     IDE_IDENTIFY_TYPE_OK
008ADE  3  AD FF 05             LDA     hstbuf+$01FF
008AE1  3  C9 AA                CMP     #$AA
008AE3  3  D0 1C                BNE     IDE_IDENTIFY_TYPE_OK
008AE5  3  AD C2 05             LDA     hstbuf+$01C2
008AE8  3  C9 00                CMP     #$00
008AEA  3  D0 18                BNE     IDE_IDENTIFY_TYPE_ERROR
008AEC  3  AD D2 05             LDA     hstbuf+$01D2
008AEF  3  C9 00                CMP     #$00
008AF1  3  D0 11                BNE     IDE_IDENTIFY_TYPE_ERROR
008AF3  3  AD E2 05             LDA     hstbuf+$01E2
008AF6  3  C9 00                CMP     #$00
008AF8  3  D0 0A                BNE     IDE_IDENTIFY_TYPE_ERROR
008AFA  3  AD F2 05             LDA     hstbuf+$01F2
008AFD  3  C9 00                CMP     #$00
008AFF  3  D0 03                BNE     IDE_IDENTIFY_TYPE_ERROR
008B01  3               IDE_IDENTIFY_TYPE_OK:
008B01  3  A9 00                LDA     #$00            ; EVERYTHING IS AWESOME
008B03  3  60                   RTS
008B04  3               IDE_IDENTIFY_TYPE_ERROR:
008B04  3  A9 FF                LDA     #$FF            ; SIGNIFY ERROR
008B06  3  60                   RTS
008B07  3               
008B07  3               
008B07  3               ;*__IDE_READ_INFO___________________________________________________________________________________
008B07  3               ;*
008B07  3               ;*  READ IDE INFORMATION
008B07  3               ;*	CARRY SET ON ERROR
008B07  3               ;* 	A=MST/SLV
008B07  3               ;*____________________________________________________________________________________________________
008B07  3               IDE_READ_INFO:
008B07  3                       PRTDBG  "IDE Read INFORMATION$"
008B07  3  48                   PHA
008B08  3  48                   PHA
008B09  3               ; SET DRIVE BIT
008B09  3  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
008B0B  3  0A                   ASL     a               ; SHIFT 4
008B0C  3  0A                   ASL     a               ;
008B0D  3  0A                   ASL     a               ;
008B0E  3  0A                   ASL     a               ;
008B0F  3  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008B11  3  AA                   TAX
008B12  3  A0 00                LDY     #$00
008B14  3  A9 0E                LDA     #PPIDE_DEVICE
008B16  3  20 0D 8E             JSR     IDE_WRITE
008B19  3               
008B19  3               
008B19  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008B1C  3  B0 52                BCS     IDE_READ_INFO_ABORT
008B1E  3  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008B20  3  A2 EC                LDX     #PPIDE_CMD_ID
008B22  3  20 0D 8E             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008B25  3  20 1F 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008B28  3  B0 46                BCS     IDE_READ_INFO_ABORT
008B2A  3  20 53 8D             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008B2D  3  48 8A 48 98          PRTS    "0x$"
008B31  3  48 A2 00 BD  
008B35  3  4A 8B E8 C9  
008B4D  3  AD 7B 04             LDA     hstbuf+123
008B50  3  20 A1 88             JSR     PRTHEXBYTE
008B53  3  AD 7A 04             LDA     hstbuf+122
008B56  3  20 A1 88             JSR     PRTHEXBYTE
008B59  3  AD 79 04             LDA     hstbuf+121
008B5C  3  20 A1 88             JSR     PRTHEXBYTE
008B5F  3  AD 78 04             LDA     hstbuf+120
008B62  3  20 A1 88             JSR     PRTHEXBYTE
008B65  3  68                   PLA
008B66  3  20 BE 8A             JSR     IDE_IDENTIFY_TYPE
008B69  3  C9 00                CMP     #$00
008B6B  3  D0 36                BNE     IDE_READ_INFO_BADFS
008B6D  3  4C D9 8B             JMP     IDE_READ_INFO_OK
008B70  3               IDE_READ_INFO_ABORT:
008B70  3  68                   PLA
008B71  3  48 8A 48 98          PRTS    "NOT PRESENT$"  ; NOT PRESENT
008B75  3  48 A2 00 BD  
008B79  3  8E 8B E8 C9  
008B9A  3  20 CD 88             JSR     NEWLINE
008B9D  3  68                   PLA
008B9E  3  20 14 8C             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008BA1  3  38                   SEC
008BA2  3  60                   RTS                     ;
008BA3  3               IDE_READ_INFO_BADFS:
008BA3  3  48 8A 48 98          PRTS    " BAD FILESYSTEM$"; NOT PRESENT
008BA7  3  48 A2 00 BD  
008BAB  3  C0 8B E8 C9  
008BD0  3  20 CD 88             JSR     NEWLINE
008BD3  3  68                   PLA
008BD4  3  20 14 8C             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008BD7  3  38                   SEC
008BD8  3  60                   RTS                     ;
008BD9  3               IDE_READ_INFO_OK:
008BD9  3  48 8A 48 98          PRTS    " FILE SYSTEM COMPATIBLE$"; NOT PRESENT
008BDD  3  48 A2 00 BD  
008BE1  3  F6 8B E8 C9  
008C0E  3  20 CD 88             JSR     NEWLINE
008C11  3  68                   PLA
008C12  3  18                   CLC
008C13  3  60                   RTS
008C14  3               
008C14  3               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008C14  3  18                   CLC
008C15  3  69 30                ADC     #$30
008C17  3  A2 00                LDX     #$00
008C19  3               @1:
008C19  3  DD 17 06             CMP     dskcfg,X        ; GET device
008C1C  3  F0 09                BEQ     @2
008C1E  3  E8                   INX
008C1F  3  E8                   INX
008C20  3  E0 10                CPX     #16
008C22  3  D0 F5                BNE     @1
008C24  3  4C 37 8C             JMP     @3
008C27  3               @2:
008C27  3  48                   PHA
008C28  3  A9 00                LDA     #$00
008C2A  3  9D 17 06             STA     dskcfg,X        ; SET device
008C2D  3  E8                   INX
008C2E  3  9D 17 06             STA     dskcfg,X        ; SET device
008C31  3  68                   PLA
008C32  3  E8                   INX
008C33  3  E0 10                CPX     #16
008C35  3  D0 E2                BNE     @1
008C37  3               @3:
008C37  3  60                   RTS
008C38  3               
008C38  3               ;__IDE_PPIDETECT____________________________________________________________________________________
008C38  3               ;
008C38  3               ;  PROBE FOR PPI HARDWARE
008C38  3               ;____________________________________________________________________________________________________
008C38  3               ;
008C38  3               IDE_PPIDETECT:
008C38  3               ;
008C38  3               ; TEST FOR PPI EXISTENCE
008C38  3               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008C38  3               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008C38  3               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008C38  3               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008C38  3               ; INTERFERE WITH THE VALUE BEING READ.
008C38  3  20 31 8E             JSR     SET_PPI_WR
008C3B  3               ;
008C3B  3  A9 00                LDA     #$00            ; VALUE ZERO
008C3D  3  8D 88 03             STA     PPIDELO         ; PUSH VALUE TO PORT
008C40  3  AD 88 03             LDA     PPIDELO         ; GET PORT VALUE
008C43  3  C9 00                CMP     #$00
008C45  3  60                   RTS                     ; AND RETURN
008C46  3               ;
008C46  3               
008C46  3               
008C46  3               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008C46  3               ;*
008C46  3               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008C46  3               ;*
008C46  3               ;*____________________________________________________________________________________________________
008C46  3               IDE_READ_SECTOR:
008C46  3  AD 10 06             LDA     debsehd         ; STORE CURRENT PARMS
008C49  3  CD 43 06             CMP     Cdebsehd        ;
008C4C  3  D0 19                BNE     IDE_READ_SECTOR_DIRTY
008C4E  3  AD 12 06             LDA     debcylm         ;
008C51  3  CD 45 06             CMP     Cdebcylm        ;
008C54  3  D0 11                BNE     IDE_READ_SECTOR_DIRTY
008C56  3  AD 11 06             LDA     debcyll         ;
008C59  3  CD 44 06             CMP     Cdebcyll        ;
008C5C  3  D0 09                BNE     IDE_READ_SECTOR_DIRTY
008C5E  3  A5 48                LDA     sekdsk          ;
008C60  3  C5 49                CMP     currentDrive    ;
008C62  3  D0 03                BNE     IDE_READ_SECTOR_DIRTY
008C64  3  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C66  3  60                   RTS
008C67  3               
008C67  3               IDE_READ_SECTOR_DIRTY:
008C67  3                       PRTDBG  "IDE Read Sector Buffer Dirty$"
008C67  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C6A  3  B0 2B                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C6C  3               IDE_READ_SECTOR_DIRTY1:
008C6C  3  20 BF 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C6F  3  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008C71  3  A2 20                LDX     #PPIDE_CMD_READ
008C73  3  20 0D 8E             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008C76  3  20 1F 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008C79  3  B0 1C                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C7B  3  20 53 8D             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008C7E  3  AD 10 06             LDA     debsehd         ; STORE CURRENT PARMS
008C81  3  8D 43 06             STA     Cdebsehd        ;
008C84  3  AD 11 06             LDA     debcyll         ;
008C87  3  8D 44 06             STA     Cdebcyll        ;
008C8A  3  AD 12 06             LDA     debcylm         ;
008C8D  3  8D 45 06             STA     Cdebcylm        ;
008C90  3  A5 48                LDA     sekdsk          ;
008C92  3  85 49                STA     currentDrive    ;
008C94  3               
008C94  3  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C96  3  60                   RTS
008C97  3               IDE_READ_SECTOR_DIRTY_ERROR:
008C97  3  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
008C99  3  60                   RTS
008C9A  3               
008C9A  3               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008C9A  3               ;*
008C9A  3               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008C9A  3               ;*
008C9A  3               ;*____________________________________________________________________________________________________
008C9A  3               IDE_WRITE_SECTOR:
008C9A  3                       PRTDBG  "IDE Write Sector$"
008C9A  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C9D  3  B0 27                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C9F  3               IDE_WRITE_SECTOR_RAW:
008C9F  3  20 BF 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008CA2  3  A9 0F                LDA     #PPIDE_COMMAND
008CA4  3  A2 30                LDX     #PPIDE_CMD_WRITE
008CA6  3  20 0D 8E             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
008CA9  3  20 1F 8D             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
008CAC  3  B0 18                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008CAE  3  20 88 8D             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
008CB1  3  20 F3 8C             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
008CB4  3  B0 10                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008CB6  3  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
008CB8  3  8D 43 06             STA     Cdebsehd        ;
008CBB  3  8D 44 06             STA     Cdebcyll        ;
008CBE  3  8D 45 06             STA     Cdebcylm        ;
008CC1  3  85 49                STA     currentDrive    ;
008CC3  3               
008CC3  3  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008CC5  3  60                   RTS
008CC6  3               IDE_WRITE_SECTOR_ERROR:
008CC6  3  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008CC8  3  60                   RTS
008CC9  3               
008CC9  3               ;*__PPIDE_RESET____________________________________________________________________________________
008CC9  3               ;*
008CC9  3               ;*  SOFT RESET IDE CHANNEL
008CC9  3               ;*
008CC9  3               ;*____________________________________________________________________________________________________
008CC9  3               PPIDE_RESET:
008CC9  3                       PRTDBG  "IDE Reset$"
008CC9  3  A9 00                LDA     #$00
008CCB  3  8D 10 06             STA     debsehd
008CCE  3  8D 11 06             STA     debcyll
008CD1  3  8D 12 06             STA     debcylm
008CD4  3  A9 FF                LDA     #$FF            ;
008CD6  3  8D 43 06             STA     Cdebsehd        ;
008CD9  3  8D 44 06             STA     Cdebcyll        ;
008CDC  3  8D 45 06             STA     Cdebcylm        ;
008CDF  3  85 49                STA     currentDrive    ;
008CE1  3               
008CE1  3  A9 80                LDA     #PPIDE_RST_LINE
008CE3  3  8D 8A 03             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
008CE6  3  A2 00                LDX     #$00
008CE8  3                       PRTDBG  "IDE Reset Delay$"
008CE8  3               RST_DLY:
008CE8  3  CA                   DEX
008CE9  3  E0 00                CPX     #$00
008CEB  3  D0 FB                BNE     RST_DLY
008CED  3  A9 00                LDA     #$00
008CEF  3  8D 8A 03             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
008CF2  3               
008CF2  3               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008CF2  3               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008CF2  3               ;     JSR     DSKY_REINIT
008CF2  3               
008CF2  3  60                   RTS
008CF3  3               
008CF3  3               
008CF3  3               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008CF3  3               ;*
008CF3  3               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008CF3  3               ;*
008CF3  3               ;*____________________________________________________________________________________________________
008CF3  3               IDE_WAIT_NOT_BUSY:
008CF3  3  48                   PHA
008CF4  3  8A                   TXA
008CF5  3  48                   PHA
008CF6  3  98                   TYA
008CF7  3  48                   PHA
008CF8  3  A9 00                LDA     #$00
008CFA  3  8D 37 06             STA     FLRETRY
008CFD  3  8D 38 06             STA     FLRETRY+1
008D00  3               IDE_WAIT_NOT_BUSY1:
008D00  3  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
008D02  3  20 F1 8D             JSR     IDE_READ
008D05  3  8A                   TXA
008D06  3  29 80                AND     #$80
008D08  3  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
008D0A  3  EE 37 06             INC     FLRETRY
008D0D  3  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
008D0F  3  EE 38 06             INC     FLRETRY+1
008D12  3  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
008D14  3  38                   SEC
008D15  3  4C 19 8D             JMP     IDE_WAIT_NOT_BUSY3
008D18  3               IDE_WAIT_NOT_BUSY2:
008D18  3  18                   CLC
008D19  3               IDE_WAIT_NOT_BUSY3:
008D19  3  68                   PLA
008D1A  3  A8                   TAY
008D1B  3  68                   PLA
008D1C  3  AA                   TAX
008D1D  3  68                   PLA
008D1E  3  60                   RTS
008D1F  3               
008D1F  3               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008D1F  3               ;*
008D1F  3               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008D1F  3               ;*
008D1F  3               ;*____________________________________________________________________________________________________
008D1F  3               IDE_WAIT_DRQ:
008D1F  3  48                   PHA
008D20  3  8A                   TXA
008D21  3  48                   PHA
008D22  3  98                   TYA
008D23  3  48                   PHA
008D24  3  A9 00                LDA     #$00
008D26  3  8D 37 06             STA     FLRETRY
008D29  3  8D 38 06             STA     FLRETRY+1
008D2C  3               IDE_WAIT_DRQ1:
008D2C  3  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
008D2E  3  20 F1 8D             JSR     IDE_READ
008D31  3  8A                   TXA
008D32  3  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
008D34  3  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008D36  3  F0 14                BEQ     IDE_WAIT_DRQ2
008D38  3  29 01                AND     #%00000001      ; IS ERROR?
008D3A  3  C9 01                CMP     #%00000001      ;
008D3C  3  F0 0A                BEQ     IDE_WAIT_DRQE
008D3E  3  EE 37 06             INC     FLRETRY
008D41  3  D0 E9                BNE     IDE_WAIT_DRQ1
008D43  3  EE 38 06             INC     FLRETRY+1
008D46  3  D0 E4                BNE     IDE_WAIT_DRQ1
008D48  3               IDE_WAIT_DRQE:
008D48  3  38                   SEC
008D49  3  4C 4D 8D             JMP     IDE_WAIT_DRQ3
008D4C  3               IDE_WAIT_DRQ2:
008D4C  3  18                   CLC
008D4D  3               IDE_WAIT_DRQ3:
008D4D  3  68                   PLA
008D4E  3  A8                   TAY
008D4F  3  68                   PLA
008D50  3  AA                   TAX
008D51  3  68                   PLA
008D52  3  60                   RTS
008D53  3               
008D53  3               
008D53  3               
008D53  3               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008D53  3               ;*
008D53  3               ;*  READ IDE BUFFER LITTLE ENDIAN
008D53  3               ;*
008D53  3               ;*____________________________________________________________________________________________________
008D53  3               IDE_READ_BUFFER:
008D53  3  A2 00                LDX     #$00            ; INDEX
008D55  3               IDEBUFRD:
008D55  3  8E 3C 06             STX     PPIDEINDEX
008D58  3  A9 08                LDA     #PPIDE_DATA
008D5A  3  20 F1 8D             JSR     IDE_READ
008D5D  3  8A                   TXA
008D5E  3  AE 3C 06             LDX     PPIDEINDEX
008D61  3  9D 00 04             STA     hstbuf,X        ;
008D64  3  E8                   INX                     ;
008D65  3  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D66  3  9D 00 04             STA     hstbuf,X        ;
008D69  3  E8                   INX
008D6A  3  E0 00                CPX     #$00            ;
008D6C  3  D0 E7                BNE     IDEBUFRD        ;
008D6E  3               IDEBUFRD1:
008D6E  3  8E 3C 06             STX     PPIDEINDEX
008D71  3  A9 08                LDA     #PPIDE_DATA
008D73  3  20 F1 8D             JSR     IDE_READ
008D76  3  8A                   TXA
008D77  3  AE 3C 06             LDX     PPIDEINDEX
008D7A  3  9D 00 05             STA     hstbuf+256,X    ;
008D7D  3  E8                   INX                     ;
008D7E  3  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D7F  3  9D 00 05             STA     hstbuf+256,X    ;
008D82  3  E8                   INX                     ;
008D83  3  E0 00                CPX     #$00            ;
008D85  3  D0 E7                BNE     IDEBUFRD1       ;
008D87  3  60                   RTS                     ;
008D88  3               
008D88  3               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008D88  3               ;*
008D88  3               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008D88  3               ;*
008D88  3               ;*____________________________________________________________________________________________________
008D88  3               IDE_WRITE_BUFFER:
008D88  3  A2 00                LDX     #$00            ; INDEX
008D8A  3               IDEBUFWT:
008D8A  3  8E 3C 06             STX     PPIDEINDEX
008D8D  3  BD 01 04             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
008D90  3  A8                   TAY                     ;
008D91  3  BD 00 04             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
008D94  3  AA                   TAX
008D95  3  A9 08                LDA     #PPIDE_DATA
008D97  3  20 0D 8E             JSR     IDE_WRITE
008D9A  3  AE 3C 06             LDX     PPIDEINDEX
008D9D  3  E8                   INX                     ;
008D9E  3  E8                   INX                     ;
008D9F  3  E0 00                CPX     #$00            ;
008DA1  3  D0 E7                BNE     IDEBUFWT        ;
008DA3  3  A2 00                LDX     #$00            ; INDEX
008DA5  3               IDEBUFWT1:
008DA5  3  8E 3C 06             STX     PPIDEINDEX
008DA8  3  BD 01 05             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
008DAB  3  A8                   TAY
008DAC  3  BD 00 05             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
008DAF  3  AA                   TAX
008DB0  3  A9 08                LDA     #PPIDE_DATA
008DB2  3  20 0D 8E             JSR     IDE_WRITE
008DB5  3  AE 3C 06             LDX     PPIDEINDEX
008DB8  3  E8                   INX                     ;
008DB9  3  E8                   INX                     ;
008DBA  3  E0 00                CPX     #$00            ;
008DBC  3  D0 E7                BNE     IDEBUFWT1       ;
008DBE  3  60                   RTS                     ;
008DBF  3               
008DBF  3               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008DBF  3               ;*
008DBF  3               ;*  SETUP LBA DATA
008DBF  3               ;*  A= DRIVE DEVICE
008DBF  3               ;*____________________________________________________________________________________________________
008DBF  3               IDE_SETUP_LBA:
008DBF  3                       PRTDBG  "PPIDE SETUP LBA$"
008DBF  3  A5 49                LDA     currentDrive
008DC1  3  29 01                AND     #$01            ; only want drive cfg
008DC3  3  0A                   ASL     a               ; SHIFT 4
008DC4  3  0A                   ASL     a               ;
008DC5  3  0A                   ASL     a               ;
008DC6  3  0A                   ASL     a               ;
008DC7  3  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008DC9  3  AA                   TAX
008DCA  3  A0 00                LDY     #$00
008DCC  3  A9 0E                LDA     #PPIDE_DEVICE
008DCE  3  20 0D 8E             JSR     IDE_WRITE
008DD1  3               
008DD1  3  AE 12 06             LDX     debcylm
008DD4  3  A9 0D                LDA     #PPIDE_LBAHI
008DD6  3  20 0D 8E             JSR     IDE_WRITE
008DD9  3               
008DD9  3  AE 11 06             LDX     debcyll         ;
008DDC  3  A9 0C                LDA     #PPIDE_LBAMID
008DDE  3  20 0D 8E             JSR     IDE_WRITE
008DE1  3               
008DE1  3  AE 10 06             LDX     debsehd         ;
008DE4  3  A9 0B                LDA     #PPIDE_LBALOW
008DE6  3  20 0D 8E             JSR     IDE_WRITE
008DE9  3               
008DE9  3  A2 01                LDX     #$01
008DEB  3  A9 0A                LDA     #PPIDE_SEC_CNT
008DED  3  20 0D 8E             JSR     IDE_WRITE
008DF0  3               
008DF0  3  60                   RTS
008DF1  3               
008DF1  3               
008DF1  3               ;-------------------------------------------------------------------------------
008DF1  3               
008DF1  3               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008DF1  3               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008DF1  3               ; PROGRAM WOULD NOT CALL TO THESE.
008DF1  3               
008DF1  3               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008DF1  3               ;INPUT A = IDE REGSITER ADDRESS
008DF1  3               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008DF1  3               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008DF1  3               
008DF1  3               IDE_READ:
008DF1  3  20 29 8E             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
008DF4  3  8D 8A 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008DF7  3  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
008DF9  3  8D 8A 03             STA     PPIDECNTRL
008DFC  3  AE 88 03             LDX     PPIDELO         ; READ LOWER BYTE
008DFF  3  AC 89 03             LDY     PPIDEHI         ; READ UPPER BYTE
008E02  3  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
008E04  3  8D 8A 03             STA     PPIDECNTRL
008E07  3  A9 00                LDA     #$00
008E09  3  8D 8A 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008E0C  3  60                   RTS
008E0D  3               
008E0D  3               
008E0D  3               
008E0D  3               
008E0D  3               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008E0D  3               ;INPUT A = IDE REGISTER ADDRESS
008E0D  3               ;INPUT REGISTER X = LSB TO WRITE
008E0D  3               ;INPUT REGISTER Y = MSB TO WRITE
008E0D  3               ;
008E0D  3               
008E0D  3               
008E0D  3               IDE_WRITE:
008E0D  3  20 31 8E             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
008E10  3               
008E10  3  8E 88 03             STX     PPIDELO         ; WRITE LOWER BYTE
008E13  3  8C 89 03             STY     PPIDEHI         ; WRITE UPPER BYTE
008E16  3               
008E16  3  8D 8A 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008E19  3               
008E19  3  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
008E1B  3  8D 8A 03             STA     PPIDECNTRL
008E1E  3               
008E1E  3  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
008E20  3  8D 8A 03             STA     PPIDECNTRL
008E23  3               
008E23  3  A9 00                LDA     #$00
008E25  3  8D 8A 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008E28  3  60                   RTS
008E29  3               
008E29  3               
008E29  3               ;-----------------------------------------------------------------------------------
008E29  3               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008E29  3               ;
008E29  3               ;------------------------------------------------------------------------------------
008E29  3               
008E29  3               SET_PPI_RD:
008E29  3  48                   PHA
008E2A  3  A9 92                LDA     #PPRD_IDE_8255
008E2C  3  8D 8B 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
008E2F  3  68                   PLA
008E30  3  60                   RTS
008E31  3               
008E31  3               SET_PPI_WR:
008E31  3  48                   PHA
008E32  3  A9 80                LDA     #PPWR_IDE_8255
008E34  3  8D 8B 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
008E37  3  68                   PLA
008E38  3  60                   RTS
008E39  3               
008E39  2                       .INCLUDE "dosrtc.asm"
008E39  3               ;__RTC DRIVERS____________________________________________________________________________________________________________________
008E39  3               ;
008E39  3               ; 	Duodyne Real Time Clock drivers (ROMRAM Card)
008E39  3               ;
008E39  3               ;	Entry points:
008E39  3               ;		RTC_INIT        - called during OS init
008E39  3               ;		RTC_READ        - read a sector from drive
008E39  3               ;		RTC_WRITE       - write a sector to drive
008E39  3               ;		RTC_LED         - UPDATE LEDS
008E39  3               ;               RTC_BUTTON      - GET BUTTON STATUS
008E39  3               ;               RTC_BEEP        - BEEP RTC SPEAKER
008E39  3               ;
008E39  3               ;________________________________________________________________________________________________________________________________
008E39  3               ;
008E39  3               ; RAM BANK $1E is RAM area for Drivers
008E39  3               ; RAM BANK $1D is operating bank for DOS/65 $8000-$FFFF
008E39  3               ;
008E39  3               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
008E39  3               ; ROM Drive starts in bank $22
008E39  3               ; RAM Drive starts in bank $02
008E39  3               ;
008E39  3               ;
008E39  3               ;
008E39  3               RTCIO           = IO+$94        ; PORT A
008E39  3               ;
008E39  3               ; Write Bits
008E39  3               ; Latch IO   MSB   7 6 5 4 3 2 1 0  LSB
008E39  3               ;                  | | | | | | | |-- USER LED 0
008E39  3               ;                  | | | | | | |---- USER LED 1
008E39  3               ;                  | | | | | |------ SPEAKER
008E39  3               ;                  | | | | |-------- /MEMORY ENABLE
008E39  3               ;                  | | | |---------- RTC RESET
008E39  3               ;                  | | |------------ RTC WRITE
008E39  3               ;                  | |-------------- RTC CLK
008E39  3               ;                  |---------------- RTC DATA
008E39  3               ;
008E39  3               ; Read Bits
008E39  3               ; Latch IO   MSB   7 6 5 4 3 2 1 0  LSB
008E39  3               ;                  X | X X X X | |-- RTC DQ
008E39  3               ;                    |         |---- /MEMORY ENABLE
008E39  3               ;                    |-------------- USER BUTTON
008E39  3               ;
008E39  3               ;
008E39  3               ;
008E39  3               
008E39  3               
008E39  3               mask_data_out   = $01           ; RTC data line
008E39  3               mask_data_in    = $80           ; RTC data line
008E39  3               mask_clk        = $40           ; RTC Serial Clock line
008E39  3               mask_wrt_en     = $20           ; RTC Serial Clock line
008E39  3               mask_ce         = $10           ; RTC CHIP ENABLE
008E39  3               
008E39  3               mask_mem_en     = $08
008E39  3               mask_spk        = $04
008E39  3               mask_led1       = $02
008E39  3               mask_led0       = $01
008E39  3               
008E39  3               mask_button     = $40
008E39  3               
008E39  3               ;__RTC_INIT__________________________________________________________________________________________
008E39  3               ;
008E39  3               ;  INIT RTC
008E39  3               ;____________________________________________________________________________________________________
008E39  3               ;
008E39  3               RTC_INIT:
008E39  3                       PRTDBG  "RTC INIT:$"
008E39  3  48 8A 48 98          PRTS    "RTC: $"
008E3D  3  48 A2 00 BD  
008E41  3  56 8E E8 C9  
008E5C  3  20 CD 88             JSR     NEWLINE
008E5F  3  48 8A 48 98          PRTS    " IO=0x$"
008E63  3  48 A2 00 BD  
008E67  3  7C 8E E8 C9  
008E83  3  A9 03                LDA     #>RTCIO         ; GET BASE PORT
008E85  3  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008E88  3  A9 94                LDA     #<RTCIO         ; GET BASE PORT
008E8A  3  20 A1 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008E8D  3  20 CD 88             JSR     NEWLINE         ;
008E90  3               ;        LDA     RTCVALUE        ; RESET PORT VALUE
008E90  3               ;        STA     RTCIO
008E90  3               ;        LDY     #$80
008E90  3               ;        LDX     #$40
008E90  3               ;        JSR     RTC_BEEP
008E90  3               
008E90  3  60                   RTS
008E91  3               
008E91  3               RTCVALUE:
008E91  3  00                   .BYTE   $00
008E92  3               
008E92  3               
008E92  3               ;__RTC_WRITE____________________________________________________
008E92  3               ; write a value to the DS1302
008E92  3               ; address in X
008E92  3               ; value in Y
008E92  3               ;_______________________________________________________________
008E92  3               RTC_WRITE:
008E92  3               ;        PHA
008E92  3               ;        JSR     RTC_CE_ENABLE
008E92  3               ;        TXA                     ; bring into A the address from X
008E92  3               ;        AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
008E92  3               ;        CLC
008E92  3               ;        ASL     A
008E92  3               ;        ORA     #%10000000      ; set MSB to one for DS1302 COMMAND BYTE (WRITE)
008E92  3               ;        JSR     RTC_WR          ; write address to DS1302
008E92  3               ;        TYA                     ; start processing value
008E92  3               ;        JSR     RTC_WR          ; write value to DS1302
008E92  3               ;        JSR     RTC_CE_DISABLE
008E92  3               ;        PLA
008E92  3  60                   RTS
008E93  3               
008E93  3               ;__RTC_READ______________________________________________________
008E93  3               ; read a value from the DS1302
008E93  3               ; address in X
008E93  3               ; value in Y
008E93  3               ;_______________________________________________________________
008E93  3               RTC_READ:
008E93  3               ;        PHA
008E93  3               ;        JSR     RTC_CE_ENABLE
008E93  3               ;        TXA                     ; bring into A the address from X
008E93  3               ;        AND     #%00111111      ; keep only bits 6 LSBs, discard 2 MSBs
008E93  3               ;        CLC
008E93  3               ;        ASL     A               ; rotate address bits to the left
008E93  3               ;        ORA     #%10000001      ; set MSB to one for DS1302 COMMAND BYTE (READ)
008E93  3               ;        JSR     RTC_WR          ; write address to DS1302
008E93  3               ;        JSR     RTC_RD          ; read value from DS1302 (value is in reg A)
008E93  3               ;        TAY
008E93  3               ;        JSR     RTC_CE_DISABLE
008E93  3               ;        PLA
008E93  3  60                   RTS
008E94  3               
008E94  3               
008E94  3               ;__RTC_LED______________________________________________________
008E94  3               ; Control the LEDs on the RomRam card
008E94  3               ; LED#  in X
008E94  3               ; value in Y
008E94  3               ;_______________________________________________________________
008E94  3               RTC_LED:
008E94  3               ;        PHA
008E94  3               ;        TXA
008E94  3               ;        AND     #$01
008E94  3               ;        CMP     #00
008E94  3               ;        BNE     :+
008E94  3               ;        TYA                     ; LED 00
008E94  3               ;        AND     #$01
008E94  3               ;        ORA     RTCVALUE
008E94  3               ;        STA     RTCVALUE
008E94  3               ;        STA     RTCIO
008E94  3  60                   RTS
008E95  3               ;:
008E95  3               ;        TYA                     ; LED 01
008E95  3               ;        AND     #$01
008E95  3               ;        ASL
008E95  3               ;        ORA     RTCVALUE
008E95  3               ;        STA     RTCVALUE
008E95  3               ;        STA     RTCIO
008E95  3               ;        RTS
008E95  3               ;__RTC_BUTTON___________________________________________________
008E95  3               ; read the button state on the RomRam card
008E95  3               ; button value in A
008E95  3               ;_______________________________________________________________
008E95  3               RTC_BUTTON:
008E95  3               
008E95  3               ;        LDA     RTCIO
008E95  3               ;        AND     mask_button
008E95  3  60                   RTS
008E96  3               
008E96  3               ;__RTC_BEEP_____________________________________________________
008E96  3               ; Produce a tone on the RomRam Speaker
008E96  3               ; frequency in X (*FF)
008E96  3               ; length in Y (*FF)
008E96  3               ;_______________________________________________________________
008E96  3               RTC_BEEP:
008E96  3  60                   RTS
008E97  3               ;        PHA
008E97  3               ;        STX     TEMPWORD
008E97  3               ;        STY     TEMPWORD1+1
008E97  3               ;        LDA     #$00
008E97  3               ;        STA     TEMPWORD+1
008E97  3               ;        STA     TEMPWORD1
008E97  3               ;        LDA     RTCVALUE
008E97  3               ;        STA     RTC_BEEP_TEMP
008E97  3               
008E97  3               ;        LDY     TEMPWORD1
008E97  3               ;        LDX     TEMPWORD
008E97  3               ;RTC_BEEP1:
008E97  3               ;        DEX
008E97  3               ;        CPX     #$00
008E97  3               ;        BNE     :+
008E97  3               ;        LDX     TEMPWORD
008E97  3               ;        LDA     RTC_BEEP_TEMP
008E97  3               ;        EOR     #mask_spk
008E97  3               ;        STA     RTC_BEEP_TEMP
008E97  3               ;        AND     #$F7
008E97  3               ;        STA     RTCIO
008E97  3               ;:
008E97  3               ;        DEY
008E97  3               ;        CPY     #$0000
008E97  3               ;        BNE     RTC_BEEP1
008E97  3               ;
008E97  3               ;        INDEX8
008E97  3               ;        LDA     RTCVALUE
008E97  3               ;        STA     RTCIO
008E97  3               ;        PLA
008E97  3  60                   RTS
008E98  3               
008E98  3               RTC_BEEP_TEMP:
008E98  3  00                   .BYTE   00
008E99  3               
008E99  3               
008E99  3               
008E99  3               ;_______________________________________________________________
008E99  3               ;
008E99  3               ; RTC Internal Functions
008E99  3               ;_______________________________________________________________
008E99  3               RTC_CE_ENABLE:
008E99  3               ;        LDA     RTCVALUE
008E99  3               ;        ORA     #mask_ce
008E99  3               ;        STA     RTCVALUE
008E99  3               ;        STA     RTCIO
008E99  3  60                   RTS
008E9A  3               
008E9A  3               RTC_CE_DISABLE:
008E9A  3               ;        LDA     RTCVALUE
008E9A  3               ;        AND     #mask_ce^$ff
008E9A  3               ;        STA     RTCVALUE
008E9A  3               ;        STA     RTCIO
008E9A  3  60                   RTS
008E9B  3               
008E9B  3               ; function RTC_WR
008E9B  3               ; send value in A
008E9B  3               ; uses X
008E9B  3               RTC_WR:
008E9B  3               ;        STA     TEMPWORD1       ; save accumulator as it is the DATA
008E9B  3               ;        LDX     #$00            ; set X index counter of FOR loop
008E9B  3               ;RTC_WR1:
008E9B  3               ;        LDA     TEMPWORD1
008E9B  3               ;        AND     #$01
008E9B  3               ;        CMP     #$00            ; is LSB a 0 or 1?
008E9B  3               ;        BEQ     :+              ; if its a 0, do not set data.
008E9B  3               ;; LSB is a 1, handle it below
008E9B  3               ;        LDA     RTCVALUE
008E9B  3               ;        ORA     #mask_data_in
008E9B  3               ;        STA     RTCIO
008E9B  3               ;        JSR     RTC_BIT_DELAY   ; let it settle a while
008E9B  3               ;:
008E9B  3               ;        ORA     #mask_clk
008E9B  3               ;        STA     RTCIO
008E9B  3               ;        JSR     RTC_BIT_DELAY   ; let it settle a while
008E9B  3               ;        LDA     RTCVALUE
008E9B  3               ;        STA     RTCIO
008E9B  3               ;        JSR     RTC_BIT_DELAY   ; let it settle a while
008E9B  3               
008E9B  3               ;        LSR     TEMPWORD1       ; move next bit into LSB position for processing to RTC
008E9B  3               ;        INX                     ; increment A in FOR loop (A=A+1)
008E9B  3               ;        CPX     #$08            ; is A < $08 ?
008E9B  3               ;        BNE     RTC_WR1         ; No, do FOR loop again
008E9B  3  60                   RTS                     ; Yes, end function and return
008E9C  3               
008E9C  3               
008E9C  3               ; function RTC_RD
008E9C  3               ; get value into A
008E9C  3               ; uses X
008E9C  3               RTC_RD:
008E9C  3               ;        LDA     RTCVALUE
008E9C  3               ;        ORA     #mask_wrt_en
008E9C  3               ;        STA     RTCVALUE
008E9C  3               ;        STA     RTCIO
008E9C  3               ;        LDA     #$00            ; set A=0 output of RTC_RD is passed in A
008E9C  3               ;        STA     TEMPWORD1
008E9C  3               ;        LDX     #$00            ; set X index counter of FOR loop
008E9C  3               ;RTC_RD1:
008E9C  3               ;        LDA     RTCVALUE
008E9C  3               ;        ORA     #mask_clk
008E9C  3               ;        STA     RTCIO
008E9C  3               ;        JSR     RTC_BIT_DELAY   ; let it settle a while
008E9C  3               ;        LDA     RTCIO
008E9C  3               ;        AND     #mask_data_out
008E9C  3               ;        CMP     #$00
008E9C  3               ;        BEQ     :+
008E9C  3               ;        LDA     TEMPWORD1
008E9C  3               ;        ORA     #1
008E9C  3               ;        STA     TEMPWORD1
008E9C  3               ;:
008E9C  3               ;        LDA     RTCVALUE
008E9C  3               ;        AND     #mask_wrt_en^$ff
008E9C  3               ;        STA     RTCVALUE
008E9C  3               ;        STA     RTCIO
008E9C  3               ;        JSR     RTC_BIT_DELAY   ; let it settle a while
008E9C  3               ;        ASL     TEMPWORD1       ; SHIFT
008E9C  3               ;        INX                     ; increment FOR loop (A=A+1)
008E9C  3               ;        CPX     #$08            ; is A < $08 ?
008E9C  3               ;        BNE     RTC_RD1         ; No, do FOR loop again
008E9C  3               ;        LDA     TEMPWORD1
008E9C  3  60                   RTS                     ; Yes, end function and return.  Read RTC value is in A
008E9D  3               
008E9D  3               RTC_BIT_DELAY:                  ; purpose is to delay ~36 uS
008E9D  3               ; (6) JSR INTO
008E9D  3               ;        PHA                     ; 3
008E9D  3               ;        LDA     #$02            ; 2  (1 REP AT 1 MHZ 6 REPS AT 2MHZ)
008E9D  3               ;        STA     TEMPWORD        ; 3
008E9D  3               ;RTC_BIT_DELAY1:
008E9D  3               ;        DEC     TEMPWORD        ;5
008E9D  3               ;        BNE     RTC_BIT_DELAY1  ;3
008E9D  3               
008E9D  3               ;        NOP                     ; 2
008E9D  3               ;        NOP                     ; 2
008E9D  3               ;        PLA                     ; 4
008E9D  3  60                   RTS                     ; 6
008E9E  3               
008E9E  2               ;        .INCLUDE "dosdskyn.asm"
008E9E  2                       .INCLUDE "dosflp.asm"
008E9E  3               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
008E9E  3               ;
008E9E  3               ; 	DOS/65 floppy drivers for MBC FDC card
008E9E  3               ;
008E9E  3               ;	Entry points:
008E9E  3               ;		FL_SETUP        - called during OS init
008E9E  3               ;		FL_READ_SECTOR	- read a sector from drive
008E9E  3               ;		FL_WRITE_SECTOR	- write a sector to drive
008E9E  3               ;
008E9E  3               ;________________________________________________________________________________________________________________________________
008E9E  3               ;
008E9E  3               ;*
008E9E  3               ;* HARDWARE I/O ADDRESSES
008E9E  3               ;*
008E9E  3               FDC_MSR         = $0330         ; ADDRESS OF MAIN STATUS REGISTER
008E9E  3               FDC_DATA        = $0331         ; FLOPPY DATA REGISTER
008E9E  3               FDC_RESET       = $0333         ; FLOPPY RESET
008E9E  3               FDC_DCR         = $0335         ; LOAD CONTROL REGISTER
008E9E  3               FDC_DOR         = $0336         ; CONFIGURATION CONTROL REGISTER
008E9E  3               FDC_TC          = $0337         ; TERMINAL COUNT
008E9E  3               
008E9E  3               ;
008E9E  3               ; FDC COMMANDS
008E9E  3               ;
008E9E  3               CFD_READ        = %00000110     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_READDEL     = %00001100     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_WRITE       = %00000101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_WRITEDEL    = %00001001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_READTRK     = %00000010     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_READID      = %00001010     ; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_FMTTRK      = %00001101     ; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_SCANEQ      = %00010001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_SCANLOEQ    = %00011001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_SCANHIEQ    = %00011101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
008E9E  3               CFD_RECAL       = %00000111     ; CMD,DS --> <EMPTY>
008E9E  3               CFD_SENSEINT    = %00001000     ; CMD --> ST0,PCN
008E9E  3               CFD_SPECIFY     = %00000011     ; CMD,SRT/HUT,HLT/ND --> <EMPTY>
008E9E  3               CFD_DRVSTAT     = %00000100     ; CMD,HDS/DS --> ST3
008E9E  3               CFD_SEEK        = %00001111     ; CMD,HDS/DS --> <EMPTY>
008E9E  3               CFD_VERSION     = %00010000     ; CMD --> ST0
008E9E  3               
008E9E  3               CFD_MFM         = %01000000     ;
008E9E  3               
008E9E  3               ;
008E9E  3               ;
008E9E  3               ; Specify Command:
008E9E  3               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
008E9E  3               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
008E9E  3               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
008E9E  3               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
008E9E  3               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
008E9E  3               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
008E9E  3               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
008E9E  3               ;
008E9E  3               ;
008E9E  3               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
008E9E  3               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
008E9E  3               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
008E9E  3               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
008E9E  3               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
008E9E  3               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
008E9E  3               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
008E9E  3               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
008E9E  3               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
008E9E  3               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
008E9E  3               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
008E9E  3               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
008E9E  3               ;
008E9E  3               ; IBM PS/2 CALLS FOR:
008E9E  3               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
008E9E  3               ;   HEAD LOAD TIME: 15ms
008E9E  3               
008E9E  3               DOR_INIT        = %00001100     ; SOFT RESET INACTIVE, DMA ENABLED
008E9E  3               DOR_BR250       = DOR_INIT
008E9E  3               DOR_BR500       = DOR_INIT
008E9E  3               
008E9E  3               
008E9E  3               
008E9E  3               FLOPPY_RETRIES  = 6             ; HOW ABOUT SIX RETIRES?
008E9E  3               FLOPPY_RETRIES1 = 2             ; TWO ITERATIONS OF RECAL?
008E9E  3               
008E9E  3               ;__FL_SETUP______________________________________________________________________________________________________________________
008E9E  3               ;
008E9E  3               ;	SETUP FLOPPY DRIVE SETTINGS
008E9E  3               ;________________________________________________________________________________________________________________________________
008E9E  3               ;
008E9E  3               FL_SETUP:
008E9E  3  A9 00                LDA     #$00            ; RESET TRACK/CYL/SEC STORAGE
008EA0  3  8D 12 06             STA     debcylm         ;
008EA3  3  8D 11 06             STA     debcyll         ;
008EA6  3  8D 10 06             STA     debsehd         ;
008EA9  3  A9 FF                LDA     #$FF            ; SET CACHE TO INVALID
008EAB  3  8D 45 06             STA     Cdebcylm        ;
008EAE  3  8D 44 06             STA     Cdebcyll        ;
008EB1  3  8D 43 06             STA     Cdebsehd        ;
008EB4  3               
008EB4  3  48 8A 48 98          PRTS    "FD: MODE=MBC$"
008EB8  3  48 A2 00 BD  
008EBC  3  D1 8E E8 C9  
008EDE  3               ;
008EDE  3  48 8A 48 98          PRTS    " IO=0x$"
008EE2  3  48 A2 00 BD  
008EE6  3  FB 8E E8 C9  
008F02  3  A9 03                LDA     #>FDC_MSR
008F04  3  20 A1 88             JSR     PRTHEXBYTE
008F07  3  A9 30                LDA     #<FDC_MSR
008F09  3  20 A1 88             JSR     PRTHEXBYTE
008F0C  3  20 86 92             JSR     FD_DETECT       ; CHECK FOR FDC
008F0F  3  C9 00                CMP     #$00
008F11  3  F0 30                BEQ     :+              ; CONTINUE IF FOUND
008F13  3  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT ZERO, H/W NOT PRESENT
008F17  3  48 A2 00 BD  
008F1B  3  30 8F E8 C9  
008F3D  3  20 CD 88             JSR     NEWLINE
008F40  3  A9 FF                LDA     #$FF
008F42  3  60                   RTS                     ; BAIL OUT
008F43  3               :
008F43  3  48 8A 48 98          PRTS    " PRESENT$"     ; NOT ZERO, H/W NOT PRESENT
008F47  3  48 A2 00 BD  
008F4B  3  60 8F E8 C9  
008F69  3  20 CD 88             JSR     NEWLINE
008F6C  3  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
008F6E  3  8D 36 03             STA     FDC_DOR
008F71  3               
008F71  3  20 24 92             JSR     CHECKINT        ;
008F74  3  A9 03                LDA     #CFD_SPECIFY    ; SPECIFY COMMAND
008F76  3  20 E0 91             JSR     PFDATA          ; OUTPUT TO FDC
008F79  3  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
008F7B  3  20 E0 91             JSR     PFDATA          ; OUTPUT TO FDC
008F7E  3  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
008F80  3  20 E0 91             JSR     PFDATA          ; OUTPUT TO FDC
008F83  3               
008F83  3  20 24 92             JSR     CHECKINT        ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
008F86  3  20 24 92             JSR     CHECKINT        ;
008F89  3  20 24 92             JSR     CHECKINT        ;
008F8C  3  20 24 92             JSR     CHECKINT        ;
008F8F  3  20 24 92             JSR     CHECKINT        ;
008F92  3  20 24 92             JSR     CHECKINT        ;
008F95  3               
008F95  3  A9 00                LDA     #$00
008F97  3  85 48                STA     sekdsk
008F99  3  A9 10                LDA     #%00010000
008F9B  3  8D 28 06             STA     DSKUNIT
008F9E  3  20 B5 91             JSR     RECAL           ;
008FA1  3  A9 27                LDA     #39             ;
008FA3  3  8D 11 06             STA     debcyll         ;
008FA6  3  20 98 91             JSR     SETTRK1
008FA9  3  20 B5 91             JSR     RECAL           ;
008FAC  3               
008FAC  3  A9 01                LDA     #$01
008FAE  3  85 48                STA     sekdsk
008FB0  3  A9 21                LDA     #%00100001
008FB2  3  8D 28 06             STA     DSKUNIT
008FB5  3  20 B5 91             JSR     RECAL           ;
008FB8  3  A9 27                LDA     #39             ;
008FBA  3  8D 11 06             STA     debcyll         ;
008FBD  3  20 98 91             JSR     SETTRK1
008FC0  3  20 B5 91             JSR     RECAL           ;
008FC3  3  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
008FC5  3  8D 36 03             STA     FDC_DOR
008FC8  3  60                   RTS
008FC9  3               
008FC9  3               
008FC9  3               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
008FC9  3               ;
008FC9  3               ; 	READ A FLOPPY SECTOR
008FC9  3               ;________________________________________________________________________________________________________________________________
008FC9  3               ;
008FC9  3               ;
008FC9  3               FL_READ_SECTOR:
008FC9  3  AD 41 06             LDA     FLOPPY_DETCT
008FCC  3  C9 00                CMP     #$00
008FCE  3  F0 01                BEQ     :+
008FD0  3  60                   RTS
008FD1  3               :
008FD1  3  A9 00                LDA     #$00
008FD3  3  8D 37 06             STA     FLRETRY         ; BLANK RETRIES
008FD6  3  8D 38 06             STA     FLRETRY1
008FD9  3  A9 0C                LDA     #DOR_INIT
008FDB  3  0D 28 06             ORA     DSKUNIT         ;
008FDE  3  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
008FE1  3  AD 12 06             LDA     debcylm         ;
008FE4  3  CD 45 06             CMP     Cdebcylm        ;
008FE7  3  D0 19                BNE     READFL_DIRTY
008FE9  3  AD 11 06             LDA     debcyll         ;
008FEC  3  CD 44 06             CMP     Cdebcyll        ;
008FEF  3  D0 11                BNE     READFL_DIRTY
008FF1  3  AD 10 06             LDA     debsehd         ;
008FF4  3  CD 43 06             CMP     Cdebsehd        ;
008FF7  3  D0 09                BNE     READFL_DIRTY
008FF9  3  A5 48                LDA     sekdsk
008FFB  3  C5 49                CMP     currentDrive    ;
008FFD  3  D0 03                BNE     READFL_DIRTY
008FFF  3               ; SECTOR ALREADY IN CACHE, DEBLOCK
008FFF  3  A9 00                LDA     #$00
009001  3  60                   RTS
009002  3               READFL_DIRTY:
009002  3  AD 12 06             LDA     debcylm         ; STORE CURRENT PARMS
009005  3  8D 45 06             STA     Cdebcylm        ;
009008  3  AD 11 06             LDA     debcyll         ;
00900B  3  8D 44 06             STA     Cdebcyll        ;
00900E  3  AD 10 06             LDA     debsehd         ;
009011  3  8D 43 06             STA     Cdebsehd        ;
009014  3  A5 48                LDA     sekdsk
009016  3  85 49                STA     currentDrive    ;
009018  3               
009018  3               
009018  3               READFL1:
009018  3  A9 46                LDA     #CFD_READ|CFD_MFM; BIT 6 SETS MFM, 06H IS READ COMMAND
00901A  3  8D 3B 06             STA     FCMD            ; SET COMMAND
00901D  3  20 A9 90             JSR     DSKOP           ; DO DISK OPERATION
009020  3               
009020  3  C9 00                CMP     #$00
009022  3  F0 2D                BEQ     READFLDONE      ; OPERATION SUCCESSFUL
009024  3  EE 37 06             INC     FLRETRY         ; LET'S RETRY
009027  3  AD 37 06             LDA     FLRETRY
00902A  3  C9 06                CMP     #FLOPPY_RETRIES
00902C  3  D0 EA                BNE     READFL1
00902E  3  20 B5 91             JSR     RECAL           ; AFTER X RETRIES, LET'S RECAL THE HEAD
009031  3  20 86 91             JSR     SETTRACK        ;
009034  3  A9 00                LDA     #$00            ;
009036  3  8D 37 06             STA     FLRETRY         ; MORE RETRIES!
009039  3  EE 38 06             INC     FLRETRY1
00903C  3  AD 38 06             LDA     FLRETRY1
00903F  3  C9 02                CMP     #FLOPPY_RETRIES1
009041  3  D0 D5                BNE     READFL1
009043  3               
009043  3  A9 FF                LDA     #$FF            ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
009045  3  8D 45 06             STA     Cdebcylm        ;
009048  3  8D 44 06             STA     Cdebcyll        ;
00904B  3  8D 43 06             STA     Cdebsehd        ;
00904E  3  85 49                STA     currentDrive    ;
009050  3  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
009051  3               READFLDONE:
009051  3  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
009053  3  60                   RTS
009054  3               
009054  3               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
009054  3               ;
009054  3               ; 	WRITE A FLOPPY SECTOR
009054  3               ;________________________________________________________________________________________________________________________________
009054  3               ;
009054  3               FL_WRITE_SECTOR:
009054  3  AD 41 06             LDA     FLOPPY_DETCT
009057  3  C9 00                CMP     #$00
009059  3  F0 01                BEQ     :+
00905B  3  60                   RTS
00905C  3               :
00905C  3  A9 00                LDA     #$00
00905E  3  8D 37 06             STA     FLRETRY         ; BLANK RETRIES
009061  3  8D 38 06             STA     FLRETRY1
009064  3  A9 FF                LDA     #$FF
009066  3  8D 45 06             STA     Cdebcylm        ; INVALIDATE CACHE
009069  3  8D 44 06             STA     Cdebcyll        ;
00906C  3  8D 43 06             STA     Cdebsehd        ;
00906F  3               
00906F  3               WRITEFL1:
00906F  3  A9 45                LDA     #CFD_WRITE|CFD_MFM; BIT 6 SETS MFM, 05H IS WRITE COMMAND
009071  3  8D 3B 06             STA     FCMD
009074  3  20 A9 90             JSR     DSKOP
009077  3               
009077  3  C9 00                CMP     #$00
009079  3  F0 2B                BEQ     WRITEFLDONE
00907B  3  EE 37 06             INC     FLRETRY
00907E  3  AD 37 06             LDA     FLRETRY
009081  3  C9 06                CMP     #FLOPPY_RETRIES
009083  3  D0 EA                BNE     WRITEFL1
009085  3  20 B5 91             JSR     RECAL
009088  3  20 86 91             JSR     SETTRACK
00908B  3  A9 00                LDA     #$00
00908D  3  8D 37 06             STA     FLRETRY
009090  3  EE 38 06             INC     FLRETRY1
009093  3  AD 38 06             LDA     FLRETRY1
009096  3  C9 02                CMP     #FLOPPY_RETRIES1
009098  3  D0 D5                BNE     WRITEFL1
00909A  3  A9 FF                LDA     #$FF            ; INVALIDATE CACHE
00909C  3  8D 45 06             STA     Cdebcylm        ;
00909F  3  8D 44 06             STA     Cdebcyll        ;
0090A2  3  8D 43 06             STA     Cdebsehd        ;
0090A5  3  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
0090A6  3               WRITEFLDONE:
0090A6  3  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
0090A8  3  60                   RTS
0090A9  3               
0090A9  3               
0090A9  3               ;__DSKOP__________________________________________________________________________________________________________________________
0090A9  3               ;
0090A9  3               ; 	PERFORM A DISK OPERATION
0090A9  3               ;________________________________________________________________________________________________________________________________
0090A9  3               ;
0090A9  3               DSKOP:
0090A9  3  78                   SEI
0090AA  3  20 24 92             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
0090AD  3  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
0090AF  3  F0 10                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
0090B1  3               ;
0090B1  3  20 86 91             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
0090B4  3               ;
0090B4  3  AD 3B 06             LDA     FCMD            ; WHAT COMMAND IS PENDING?
0090B7  3  C9 46                CMP     #CFD_READ|CFD_MFM; IS IT A READ COMMAND?
0090B9  3  D0 03                BNE     GWRR_POLL       ;
0090BB  3  4C 16 91             JMP     RDD_POLL        ;
0090BE  3               GWRR_POLL:
0090BE  3  4C 5C 91             JMP     WRR_POLL        ;
0090C1  3               DSKEXIT:
0090C1  3  A9 00                LDA     #0              ; SET MOTOR OFF
0090C3  3  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
0090C6  3  A9 FF                LDA     #$FF            ; SET IF ERROR
0090C8  3  58                   CLI
0090C9  3  60                   RTS
0090CA  3               
0090CA  3               SNDFDWR:
0090CA  3  18                   CLC
0090CB  3  AD 28 06             LDA     DSKUNIT         ; GET DISK UNIT NUMBER
0090CE  3  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
0090D0  3  8D 31 06             STA     slicetmp        ; PARK IT IN TEMP
0090D3  3  AD 12 06             LDA     debcylm         ; GET HEAD SELECTION
0090D6  3  29 01                AND     #$01            ; INSURE SINGLE BIT
0090D8  3  0A                   ASL     A               ;
0090D9  3  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
0090DA  3  0D 31 06             ORA     slicetmp        ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
0090DD  3  8D 31 06             STA     slicetmp        ; STORE IN UNIT
0090E0  3  AD 3B 06             LDA     FCMD            ;
0090E3  3  20 E0 91             JSR     PFDATA          ; PUSH COMMAND TO I8272
0090E6  3  AD 31 06             LDA     slicetmp        ;
0090E9  3  20 E0 91             JSR     PFDATA          ;
0090EC  3  AD 11 06             LDA     debcyll         ;
0090EF  3  20 E0 91             JSR     PFDATA          ;
0090F2  3  AD 12 06             LDA     debcylm         ;
0090F5  3  20 E0 91             JSR     PFDATA          ;
0090F8  3  18                   CLC                     ;
0090F9  3  AD 10 06             LDA     debsehd         ;
0090FC  3  69 01                ADC     #$01            ;
0090FE  3  20 E0 91             JSR     PFDATA          ;
009101  3  A9 02                LDA     #$02            ;
009103  3  20 E0 91             JSR     PFDATA          ; WHAT DENSITY
009106  3  A9 09                LDA     #$09            ;
009108  3  20 E0 91             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
00910B  3  A9 1B                LDA     #$1B            ;
00910D  3  20 E0 91             JSR     PFDATA          ; WHAT GAP IS NEEDED
009110  3  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
009112  3  20 0B 92             JSR     PFDATAS
009115  3  60                   RTS
009116  3               
009116  3               
009116  3               ; PERFORM READ
009116  3               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
009116  3               ;
009116  3               RDD_POLL:
009116  3  A2 00                LDX     #$00
009118  3  A0 00                LDY     #$00
00911A  3  20 CA 90             JSR     SNDFDWR         ;
00911D  3               RDS1:
00911D  3  AD 30 03             LDA     FDC_MSR         ; GET STATUS  (4 CYCLES)
009120  3  10 FB                BPL     RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
009122  3  29 20                AND     #%00100000      ; EXECUTION MODE? (2 CYCLES)
009124  3  F0 1D                BEQ     DSKOPEND        ; NO, ERROR
009126  3               RDS1A:
009126  3  AD 31 03             LDA     FDC_DATA        ; GET DATA (4 CYCLES)
009129  3  99 00 04             STA     hstbuf,Y        ; WRITE IT (5 CYCLES)
00912C  3  C8                   INY                     ; (2 CYCLES)
00912D  3  D0 EE                BNE     RDS1            ; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
00912F  3  A2 00                LDX     #$00
009131  3               RDS2:
009131  3  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009134  3  10 FB                BPL     RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
009136  3  29 20                AND     #%00100000      ; EXECUTION MODE?
009138  3  F0 09                BEQ     DSKOPEND        ; NO, ERROR
00913A  3               RDS2A:
00913A  3  AD 31 03             LDA     FDC_DATA        ; GET DATA
00913D  3  99 00 05             STA     hstbuf+256,Y    ; WRITE IT
009140  3  C8                   INY
009141  3  D0 EE                BNE     RDS2            ; KEEP GOING
009143  3               DSKOPEND:
009143  3  AD 37 03             LDA     FDC_TC
009146  3  20 D2 92             JSR     FDDELAY
009149  3               ;
009149  3  20 6D 92             JSR     GFDATA          ;GET ERROR TYPE
00914C  3  8D 3A 06             STA     FLERR
00914F  3               ;* CLEAR OUT ANY REMAINING DATA
00914F  3               RESUL3:
00914F  3  20 6D 92             JSR     GFDATA          ;READ BYTE FROM FDC
009152  3  C9 00                CMP     #$00
009154  3  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
009156  3  AD 3A 06             LDA     FLERR           ;
009159  3  29 C0                AND     #%11000000      ;
00915B  3  60                   RTS
00915C  3               
00915C  3               
00915C  3               WRR_POLL:
00915C  3  20 CA 90             JSR     SNDFDWR         ;
00915F  3               WRS1:   ;
00915F  3  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009162  3  10 FB                BPL     WRS1            ; NOT READY
009164  3  29 20                AND     #%00100000      ; EXECUTION MODE?
009166  3  F0 1B                BEQ     WRS3            ; NO, ERROR
009168  3  B9 00 04             LDA     hstbuf,Y        ; WRITE IT
00916B  3  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
00916E  3  C8                   INY
00916F  3  D0 EE                BNE     WRS1            ; DO NEXT
009171  3               WRS2:   ;
009171  3  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009174  3  10 FB                BPL     WRS2            ; NOT READY
009176  3  29 20                AND     #%00100000      ; EXECUTION MODE?
009178  3  F0 09                BEQ     WRS3            ; NO, ERROR
00917A  3  B9 00 05             LDA     hstbuf+256,Y    ; WRITE IT
00917D  3  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009180  3  C8                   INY
009181  3  D0 EE                BNE     WRS2            ; DO NEXT
009183  3               WRS3:
009183  3  4C 43 91             JMP     DSKOPEND        ;
009186  3               
009186  3               
009186  3               ;__SETTRACK__________________________________________________________________________________________________________________________
009186  3               ;
009186  3               ; 	SEEK TO A TRACK ON GIVEN UNIT
009186  3               ; 	A: TRACK #
009186  3               ;________________________________________________________________________________________________________________________________
009186  3               ;
009186  3               SETTRACK:
009186  3  A9 0C                LDA     #DOR_INIT
009188  3  0D 28 06             ORA     DSKUNIT         ; SET MOTOR ON
00918B  3  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
00918E  3               
00918E  3               ; ANY INTERUPT PENDING
00918E  3               ; IF YES FIND OUT WHY/CLEAR
00918E  3  20 24 92             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009191  3  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
009193  3  D0 03                BNE     SETTRK1
009195  3  4C DF 91             JMP     SETTRKEXIT      ;
009198  3               
009198  3               ;
009198  3               SETTRK1:
009198  3  AD 11 06             LDA     debcyll         ; GET TRACK
00919B  3  C9 00                CMP     #$00            ;
00919D  3  F0 16                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
00919F  3  A9 0F                LDA     #CFD_SEEK       ; SEEK COMMAND
0091A1  3  20 E0 91             JSR     PFDATA          ; PUSH COMMAND
0091A4  3  AD 28 06             LDA     DSKUNIT         ; SAY WHICH UNIT
0091A7  3  29 01                AND     #$01
0091A9  3  20 E0 91             JSR     PFDATA          ; SEND THAT
0091AC  3  AD 11 06             LDA     debcyll         ; TO WHAT TRACK
0091AF  3  20 E0 91             JSR     PFDATA          ; SEND THAT TOO
0091B2  3  4C CA 91             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
0091B5  3               RECAL:
0091B5  3  A9 0C                LDA     #DOR_INIT
0091B7  3  0D 28 06             ORA     DSKUNIT         ; SET MOTOR ON
0091BA  3  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
0091BD  3  A9 07                LDA     #CFD_RECAL      ; RECAL TO TRACK 0
0091BF  3  20 E0 91             JSR     PFDATA          ; SEND IT
0091C2  3  AD 28 06             LDA     DSKUNIT         ; SAY WHICH UNIT
0091C5  3  29 01                AND     #$01
0091C7  3  20 E0 91             JSR     PFDATA          ; SEND THAT TOO
0091CA  3               ;
0091CA  3               WAINT:
0091CA  3  48                   PHA
0091CB  3  8A                   TXA
0091CC  3  48                   PHA
0091CD  3  A2 64                LDX     #100
0091CF  3  20 D7 92             JSR     FDVDELAY
0091D2  3  68                   PLA
0091D3  3  AA                   TAX
0091D4  3  68                   PLA
0091D5  3               :
0091D5  3  20 24 92             JSR     CHECKINT
0091D8  3  AD 30 03             LDA     FDC_MSR         ; READ SEEK STATUS
0091DB  3  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
0091DD  3  D0 F6                BNE     :-              ; YES, WAIT FOR THEM
0091DF  3               ;
0091DF  3               SETTRKEXIT:
0091DF  3  60                   RTS
0091E0  3               
0091E0  3               ;__PFDATA__________________________________________________________________________________________________________________________
0091E0  3               ;
0091E0  3               ; WRITE A COMMAND OR PARAMETER SEQUENCE
0091E0  3               ;
0091E0  3               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
0091E0  3               ;	RQM  DIO
0091E0  3               ;	0	0	BUSY
0091E0  3               ;	1	0	WRITE TO DATA REGISTER PERMITTED
0091E0  3               ;	1	1	BYTE FOR READ BY HOST PENDING
0091E0  3               ;	0	1	BUSY
0091E0  3               ;
0091E0  3               ;________________________________________________________________________________________________________________________________
0091E0  3               ;
0091E0  3               PFDATA:
0091E0  3  48                   PHA                     ; SAVE DATA BYTE
0091E1  3  A0 00                LDY     #$00
0091E3  3               WRF1:
0091E3  3  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
0091E6  3  AA                   TAX
0091E7  3  29 80                AND     #$80            ;
0091E9  3  D0 07                BNE     :+
0091EB  3  C8                   INY
0091EC  3  D0 F5                BNE     WRF1            ; FDC IS NOT READY, WAIT FOR IT
0091EE  3  68                   PLA
0091EF  3  A9 FF                LDA     #$FF
0091F1  3  60                   RTS
0091F2  3               :
0091F2  3  8A                   TXA
0091F3  3  29 40                AND     #$40            ; TEST DIO BIT
0091F5  3  D0 0E                BNE     WRF2            ; FDC IS OUT OF SYNC
0091F7  3  68                   PLA                     ; RESTORE DATA
0091F8  3  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0091FB  3  20 D2 92             JSR     FDDELAY
0091FE  3  20 D2 92             JSR     FDDELAY
009201  3  20 D2 92             JSR     FDDELAY
009204  3  60                   RTS
009205  3               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009205  3               WRF2:
009205  3  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009208  3  4C E3 91             JMP     WRF1            ; AND CONTINUE
00920B  3               
00920B  3               ;__PFDATAS_________________________________________________________________________________________________________________________
00920B  3               ;
00920B  3               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
00920B  3               ;
00920B  3               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
00920B  3               ;	RQM  DIO
00920B  3               ;	0	0	BUSY
00920B  3               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00920B  3               ;	1	1	BYTE FOR READ BY HOST PENDING
00920B  3               ;	0	1	BUSY
00920B  3               ;
00920B  3               ;________________________________________________________________________________________________________________________________
00920B  3               ;
00920B  3               PFDATAS:
00920B  3  48                   PHA                     ; SAVE DATA BYTE
00920C  3               WRF1S:
00920C  3  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
00920F  3  AA                   TAX
009210  3  29 80                AND     #$80            ;
009212  3  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
009214  3  8A                   TXA
009215  3  29 40                AND     #$40            ; TEST DIO BIT
009217  3  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
009219  3  68                   PLA                     ; RESTORE DATA
00921A  3  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
00921D  3  60                   RTS
00921E  3               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
00921E  3               WRF2S:
00921E  3  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009221  3  4C 0C 92             JMP     WRF1S           ; AND CONTINUE
009224  3               
009224  3               
009224  3               
009224  3               ;__CHECKINT__________________________________________________________________________________________________________________________
009224  3               ;
009224  3               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
009224  3               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
009224  3               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
009224  3               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
009224  3               ;________________________________________________________________________________________________________________________________
009224  3               ;
009224  3               CHECKINT:
009224  3  A0 00                LDY     #$00
009226  3               :
009226  3  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009229  3  29 80                AND     #$80
00922B  3  D0 09                BNE     :+              ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
00922D  3  20 D2 92             JSR     FDDELAY
009230  3  C8                   INY
009231  3  D0 F3                BNE     :-
009233  3  4C 3E 92             JMP     ERRCLR
009236  3               
009236  3               :
009236  3  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009239  3  29 40                AND     #$40            ; WAITING FOR INPUT?
00923B  3  F0 16                BEQ     SENDINT
00923D  3  60                   RTS
00923E  3               
00923E  3               ERRCLR:
00923E  3  A0 00                LDY     #$00
009240  3               :
009240  3  AD 31 03             LDA     FDC_DATA        ; CLEAR THE JUNK OUT OF DATA REGISTER
009243  3  AD 30 03             LDA     FDC_MSR         ; CHECK WITH RQM
009246  3  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
009248  3  D0 06                BNE     :+              ;
00924A  3  20 D2 92             JSR     FDDELAY
00924D  3  C8                   INY
00924E  3  D0 F0                BNE     :-
009250  3               :
009250  3  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
009252  3               ;
009252  3  60                   RTS
009253  3               
009253  3               ;__SENDINT__________________________________________________________________________________________________________________________
009253  3               ;
009253  3               ; SENSE INTERRUPT COMMAND
009253  3               ;________________________________________________________________________________________________________________________________
009253  3               ;
009253  3               SENDINT:
009253  3  A9 08                LDA     #CFD_SENSEINT   ; SENSE INTERRUPT COMMAND
009255  3  20 E0 91             JSR     PFDATA          ; SEND IT
009258  3  20 6D 92             JSR     GFDATA          ; GET RESULTS
00925B  3  8D 39 06             STA     ST0             ; STORE THAT
00925E  3  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
009260  3  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
009262  3  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
009264  3  20 6D 92             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
009267  3  AD 39 06             LDA     ST0             ; GET FIRST ONE
00926A  3  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
00926C  3               ENDSENDINT:
00926C  3  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
00926D  3               
00926D  3               
00926D  3               ;__GFDATA__________________________________________________________________________________________________________________________
00926D  3               ;
00926D  3               ; GET DATA FROM FLOPPY CONTROLLER
00926D  3               ;
00926D  3               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
00926D  3               ;	RQM  DIO
00926D  3               ;	0	0	BUSY
00926D  3               ;	1	0	WRITE TO DATA REGISTER PERMITTED
00926D  3               ;	1	1	BYTE FOR READ BY HOST PENDING
00926D  3               ;	0	1	BUSY
00926D  3               ;
00926D  3               ;________________________________________________________________________________________________________________________________
00926D  3               ;
00926D  3               GFDATA:
00926D  3  A0 00                LDY     #$00
00926F  3               :
00926F  3  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009272  3  AA                   TAX                     ;
009273  3  29 80                AND     #%10000000      ; NOT READY, WAIT
009275  3  D0 06                BNE     :+              ;
009277  3  C8                   INY
009278  3  D0 F5                BNE     :-
00927A  3  A9 00                LDA     #$00
00927C  3  60                   RTS
00927D  3               :
00927D  3  8A                   TXA
00927E  3  29 40                AND     #%01000000      ; ANY DATA FOR US?
009280  3  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
009282  3  AD 31 03             LDA     FDC_DATA        ; GET FDC DATA
009285  3               GFDATA1:
009285  3  60                   RTS
009286  3               
009286  3               ;__FD_DETECT______________________________________________________________________________________________________________________
009286  3               ;
009286  3               ; 	DETECT FLOPPY HARDWARE
009286  3               ;________________________________________________________________________________________________________________________________
009286  3               FD_DETECT:
009286  3               ; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
009286  3  20 B4 92             JSR     FC_RESETFDC     ; RESET FDC
009289  3               
009289  3  AD 30 03             LDA     FDC_MSR         ; READ MSR
00928C  3  C9 80                CMP     #$80
00928E  3  F0 0A                BEQ     FD_DETECT1      ; $80 IS OK
009290  3  C9 D0                CMP     #$D0
009292  3  F0 06                BEQ     FD_DETECT1      ; $D0 IS OK
009294  3  A9 FF                LDA     #$FF            ; NOT OK
009296  3  8D 41 06             STA     FLOPPY_DETCT
009299  3  60                   RTS
00929A  3               ;
00929A  3               FD_DETECT1:
00929A  3  A2 64                LDX     #100
00929C  3  20 D7 92             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
00929F  3  AD 30 03             LDA     FDC_MSR         ; READ MSR AGAIN
0092A2  3  C9 80                CMP     #$80
0092A4  3  F0 08                BEQ     :+              ; $80 IS OK
0092A6  3  C9 D0                CMP     #$D0
0092A8  3  A9 FF                LDA     #$FF            ; NOT OK
0092AA  3  8D 41 06             STA     FLOPPY_DETCT
0092AD  3  60                   RTS
0092AE  3               :
0092AE  3  A9 00                LDA     #$00            ; OK
0092B0  3  8D 41 06             STA     FLOPPY_DETCT
0092B3  3  60                   RTS
0092B4  3               
0092B4  3               FC_RESETFDC:
0092B4  3  AD 33 03             LDA     FDC_RESET
0092B7  3  AD 33 03             LDA     FDC_RESET
0092BA  3  A2 96                LDX     #150
0092BC  3  20 D7 92             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
0092BF  3               
0092BF  3  A9 00                LDA     #$00
0092C1  3  8D 36 03             STA     FDC_DOR
0092C4  3  20 D2 92             JSR     FDDELAY
0092C7  3  A9 0C                LDA     #DOR_INIT
0092C9  3  8D 36 03             STA     FDC_DOR
0092CC  3  A2 96                LDX     #150            ;
0092CE  3  20 D7 92             JSR     FDVDELAY
0092D1  3  60                   RTS
0092D2  3               
0092D2  3               
0092D2  3               FDDELAY:
0092D2  3  48                   PHA
0092D3  3  68                   PLA
0092D4  3  48                   PHA
0092D5  3  68                   PLA
0092D6  3  60                   RTS
0092D7  3               FDVDELAY:
0092D7  3  48                   PHA
0092D8  3  68                   PLA
0092D9  3  48                   PHA
0092DA  3  68                   PLA
0092DB  3  CA                   DEX
0092DC  3  E0 00                CPX     #$00
0092DE  3  D0 F7                BNE     FDVDELAY
0092E0  3  60                   RTS
0092E1  3               
0092E1  2               
0092E1  2               
0092E1  2               
0092E1  2               ;__DFT_CONSOLE___________________________________________________________________________________________________________________
0092E1  2               ;
0092E1  2               ;	      TRANSFER CONSOLE COMMAND TO DESIGNATED CONSOLE
0092E1  2               ;________________________________________________________________________________________________________________________________
0092E1  2               DFT_CONSOLE:
0092E1  2  48                   PHA
0092E2  2  AD 0F 06             LDA     CONSOLE
0092E5  2  18                   CLC
0092E6  2  65 32                ADC     farfunct
0092E8  2  85 32                STA     farfunct
0092EA  2  68                   PLA
0092EB  2  4C 00 88             JMP     FUNCTION_DISPATCHER
0092EE  2               
0092EE  2               
0092EE  2               drv_noop:
0092EE  2  60                   RTS
0092EF  2               
0092EF  1               DRIVEREND:
0092EF  1                       .END
