ca65 V2.18 - Ubuntu 2.19-1
Main file   : compl203.asm
Current file: compl203.asm

000000r 1                       .INCLUDE "macro816.asm"
000000r 2                .IFDEF  DUODYNE
000000r 2               .P816
000000r 2               
000000r 2                       .MACRO  INDEX16         ; Set 16bit Index Registers
000000r 2                       REP     #$10            ; 16 bit Index registers
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2                       .MACRO  INDEX8          ; Set 8bit Index Registers
000000r 2                       SEP     #$10            ; 8 bit Index registers
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR16   ; Set 16bit Index Registers
000000r 2                       REP     #$20            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR8    ; Set 8bit Index Registers
000000r 2                       SEP     #$20            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX16; Set 16bit Index Registers
000000r 2                       REP     #$30            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX8; Set 8bit Index Registers
000000r 2                       SEP     #$30            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLB
000000r 2                       LDA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       PHA
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLA
000000r 2                       PLX
000000r 2                       STA     (<PARM1),Y      ;
000000r 2                       PLB
000000r 2                       STA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CMP     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ADC     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ORA     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BNE     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE PARM1
000000r 2                       BEQ     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ELSE
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       STA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       CMP     (<PARM1),Y      ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       ADC     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       ORA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BEQ     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE  PARM1
000000r 2                       BNE     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ENDIF
000000r 2               
000000r 1               ;COMPILE
000000r 1               ;BASIC-E/65 Compiler
000000r 1               ;Version 2.03-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;released:	18 october 1982
000000r 1               ;last revision:
000000r 1               ;	24 december 1983
000000r 1               ;		added chkule for prod 5
000000r 1               ;		modified error to print line
000000r 1               ;		added code to set seprtr
000000r 1               ;	12 january 1984
000000r 1               ;		deleted error0 bit and branch
000000r 1               ;		fixed first blank line list for $b option
000000r 1               ;		fixed buffer overwrite on error
000000r 1               ;	4 april 2008
000000r 1               ;		reformatted for ASM211 & TASM
000000r 1               ;		eliminated page zero 0 & 1
000000r 1               ;		moved some variables from page zero
000000r 1               ;A translation of Gordon Eubanks BASIC-E to operate under DOS/65.  This is a
000000r 1               ;compile-interpret systems invoked against a source file of type .BAS.  The
000000r 1               ;compiler produces an intermediate code file of type .INT which is executed
000000r 1               ;by the program RUN.
000000r 1               ;external references
000000r 1               BOOT            = $100          ;boot entry
000000r 1               PEM             = $103          ;pem entry
000000r 1               FCB             = $107          ;default fcb
000000r 1               TEA             = $800          ;load address
000000r 1               ;fixed parameters and constants
000000r 1               ;CAUTION: When a register is set to TRUE, Z is set to 0 (i.e. NE).  If a
000000r 1               ;register is set to FALSE then Z is set to 1 (i.e. EQ).
000000r 1               TRUE            = $FF
000000r 1               FALSE           = 0
000000r 1               ;ascii characters
000000r 1               TAB             = 9             ;tab
000000r 1               LF              = 10            ;linefeed
000000r 1               CR              = 13            ;return and eol
000000r 1               EOF             = 26            ;eof char
000000r 1               SPACE           = 32            ;ascii blank
000000r 1               semico          = 59            ;semicolon
000000r 1               backsl          = 92            ;backslash
000000r 1               ;other
000000r 1               IDNTSZ          = 32            ;max identifier size + 1
000000r 1               VARCSZ          = 100           ;varc stack size
000000r 1               PSTKSZ          = 32            ;parse stack size
000000r 1               SRCRSZ          = 128           ;source file record size
000000r 1               INTRSZ          = 128           ;int file record size
000000r 1               CBUFSZ          = 82            ;console buffer size
000000r 1               HSHTSZ          = 64            ;hash table size
000000r 1               HSHMSK          = HSHTSZ-1      ;hashing mask
000000r 1               MAXOCT          = 15            ;max number on statements
000000r 1               MAXRWL          = 9             ;max reserved word length
000000r 1               MAXRNO          = 120           ;max read count
000000r 1               MAXLNO          = 175           ;max look count
000000r 1               MAXPNO          = 189           ;max push count
000000r 1               MAXSNO          = 341           ;max state count
000000r 1               STARTS          = 121           ;start state
000000r 1               PRODNO          = 152           ;number productions
000000r 1               SIMVAR          = 0
000000r 1               SUBVAR          = 2
000000r 1               CONST           = 4
000000r 1               LABLE           = 8
000000r 1               UNFUNC          = $A
000000r 1               ;mnemonics for basic-e machine
000000r 1               FAD             = 0
000000r 1               FMI             = 1
000000r 1               FMU             = 2
000000r 1               FDI             = 3
000000r 1               EXP             = 4
000000r 1               LSS             = 5
000000r 1               GTR             = 6
000000r 1               EQU             = 7
000000r 1               NEQ             = 8
000000r 1               GEQ             = 9
000000r 1               LEQ             = 10
000000r 1               NOT             = 11
000000r 1               ANDO            = 12
000000r 1               BOR             = 13
000000r 1               LOD             = 14
000000r 1               STO             = 15
000000r 1               XIT             = 16
000000r 1               DEL             = 17
000000r 1               DUP             = 18
000000r 1               XCH             = 19
000000r 1               STD             = 20
000000r 1               SLT             = 21
000000r 1               SGT             = 22
000000r 1               SEQ             = 23
000000r 1               SNE             = 24
000000r 1               SGE             = 25
000000r 1               SLE             = 26
000000r 1               STS             = 27
000000r 1               ILS             = 28
000000r 1               CAT             = 29
000000r 1               PRO             = 30
000000r 1               RTN             = 31
000000r 1               ROW             = 32
000000r 1               SUB             = 33
000000r 1               RDV             = 34
000000r 1               WRV             = 35
000000r 1               WST             = 36
000000r 1               RDF             = 37
000000r 1               RDB             = 38
000000r 1               ECR             = 39
000000r 1               POT             = 40
000000r 1               WRB             = 40
000000r 1               RDN             = 41
000000r 1               RDS             = 42
000000r 1               WRN             = 43
000000r 1               WRS             = 44
000000r 1               OPN             = 45
000000r 1               CON             = 46
000000r 1               RST             = 47
000000r 1               NEG             = 48
000000r 1               RES             = 49
000000r 1               NOPO            = 50
000000r 1               DAT             = 51
000000r 1               DBF             = 52
000000r 1               NSP             = 53
000000r 1               BRS             = 54
000000r 1               BRC             = 55
000000r 1               BFC             = 56
000000r 1               BFN             = 57
000000r 1               CVB             = 58
000000r 1               RCN             = 59
000000r 1               DRS             = 60
000000r 1               DRF             = 61
000000r 1               EDR             = 62
000000r 1               EDW             = 63
000000r 1               CLS             = 64
000000r 1               IRN             = 77
000000r 1               RON             = 91
000000r 1               CKO             = 92
000000r 1               EXR             = 93
000000r 1               DEF             = 94
000000r 1               BOL             = 95
000000r 1               ADJ             = 96
000000r 1               ;token definitions
000000r 1               POUND           = 12
000000r 1               ASTRK           = 4
000000r 1               LESST           = 1
000000r 1               EXPON           = 14
000000r 1               TDATA           = 99
000000r 1               TELSE           = 34
000000r 1               TFOR            = 28
000000r 1               TIF             = 17
000000r 1               TNEXT           = 37
000000r 1               SLASH           = 8
000000r 1               TOR             = 21
000000r 1               TREST           = 48
000000r 1               TSTOP           = 40
000000r 1               FUNCT           = 53
000000r 1               TLEQ            = 18
000000r 1               TNE             = 19
000000r 1               TOUT            = 31
000000r 1               IDENT           = 52
000000r 1               UDFUNC          = 54
000000r 1               LPARN           = 2
000000r 1               TPLUS           = 3
000000r 1               TCOLIN          = 11
000000r 1               EQUAL           = 13
000000r 1               TAND            = 24
000000r 1               TDEF            = 25
000000r 1               TEND            = 27
000000r 1               TGOSB           = 43
000000r 1               TINPT           = 44
000000r 1               TNOT            = 30
000000r 1               TPRNT           = 45
000000r 1               TRETN           = 46
000000r 1               TTHEN           = 41
000000r 1               TGEQ            = 15
000000r 1               COMMA           = 9
000000r 1               TCLOS           = 42
000000r 1               TIRN            = 51
000000r 1               RPARN           = 5
000000r 1               TMINUS          = 7
000000r 1               SCOLN           = 6
000000r 1               GTRT            = 10
000000r 1               TCR             = 23
000000r 1               TDIM            = 26
000000r 1               TFILE           = 35
000000r 1               TGOTO           = 36
000000r 1               TLET            = 29
000000r 1               TON             = 20
000000r 1               TREAD           = 38
000000r 1               TSTEP           = 39
000000r 1               TTO             = 22
000000r 1               TSUB            = 32
000000r 1               TGO             = 16
000000r 1               TXOR            = 33
000000r 1               STRING          = 50
000000r 1               FLOTPT          = 49
000000r 1               TREM            = 0
000000r 1               ;page zero variables
000000r 1               ;all non-zero initial values are shown as i=xxxx where xxxx is the initial
000000r 1               ;value. PL/M name is shown if significantly different.
000000r 1               GPIND           = $02+$40       ;INDEX IN GETCHR
000000r 1               ERRCNT          = $03+$40       ;ERROR COUNT (ERRORCOUNT)
000000r 1               DATACT          = $05+$40       ;COUNT DATA AREA SIZE
000000r 1               INPSTM          = $07+$40       ;(INPUTSTMT)
000000r 1               GSBSTM          = $08+$40       ;(GOSUBSTMT)
000000r 1               TOKEN           = $09+$40       ;TYPE OF TOKEN
000000r 1               SUBTYP          = $0A+$40       ;SUBTYPE OF TOKEN (SUBTYPE)
000000r 1               FUNCOP          = $0B+$40       ;FUNCTION NUMBER IF FUNCTION
000000r 1               HSHCDE          = $0C+$40       ;HASH OF CURRENT TOKEN (HASHCODE)
000000r 1               NXTCHR          = $0D+$40       ;CURRENT CHAR FROM GETCHR (NEXTCHAR)
000000r 1               ACCUM           = $0E+$40       ;CURRENT TOKEN
000000r 1               ACCLEN          = ACCUM         ;LENGTH IS FIRST BYTE
000000r 1               CONT            = $2E+$40       ;ACCUM FULL FLAG
000000r 1               COLUMN          = $2F+$40       ;CURRENT COLUMN
000000r 1               LINENO          = $30+$40       ;CURRENT LINE NUMBER
000000r 1               OUTIND          = $32+$40       ;INT BUFFER INDEX (BUFFPTR)
000000r 1               LENGTH          = $33+$40       ;OUTPUT LINE LENGTH
000000r 1               SEPRTR          = $34+$40       ;SEPARATOR I=':'
000000r 1               SRCIND          = $35+$40       ;SOURCE INDEX I=SRCRSZ (SOURCEPTR)
000000r 1               LNEPTR          = $36+$40       ;LINE POINTER
000000r 1               POINTR          = $37+$40       ;POINTER IN ERROR
000000r 1               ERRCDE          = $38+$40       ;COMPILER ERROR CODE
000000r 1               STATE           = $39+$40       ;STATE
000000r 1               SP              = $3B+$40       ;STACK POINTER
000000r 1               MP              = $3C+$40       ;
000000r 1               MPP1            = $3D+$40       ;MP + 1
000000r 1               NOLOOK          = $3E+$40       ;
000000r 1               VARIND          = $3F+$40       ;INDEX INTO VAR
000000r 1               TYPESP          = $40+$40       ;GROUP OF
000000r 1               TYPEM1          = $41+$40       ;VARIABLES
000000r 1               TYPEMP          = $42+$40       ;TO HOLD
000000r 1               STYPSP          = $43+$40       ;PARSER STACK
000000r 1               STYPM1          = $44+$40       ;CONTENTS
000000r 1               STYPMP          = $45+$40       ;DURING
000000r 1               SYMLSP          = $46+$40       ;ACTION
000000r 1               SYMLM1          = $48+$40       ;OF SYNTHESIZE
000000r 1               SYMLMP          = $4A+$40       ;IN
000000r 1               HASHSP          = $4C+$40       ;ORDER TO
000000r 1               HASHM1          = $4D+$40       ;REDUCE
000000r 1               HASHMP          = $4E+$40       ;THE AMOUNT
000000r 1               SRLOSP          = $4F+$40       ;OF INDEXING
000000r 1               SRLOMP          = $51+$40       ;IN SYNTHE
000000r 1               DECOUT          = $53+$40       ;DECIMAL WORD
000000r 1               LZFLAG          = $55+$40       ;LEADING ZERO FLAG IN PRNDEC
000000r 1               FIELD           = $56+$40       ;POINTER IN COMPARE
000000r 1               I               = $58+$40       ;PARSER VAR
000000r 1               J               = $5A+$40       ;SAME
000000r 1               K               = $5C+$40       ;EVEN MORE
000000r 1               INDEX           = $5E+$40       ;
000000r 1               I2              = $5F+$40       ;I*2 AND WORD POINTER
000000r 1               IC              = $61+$40       ;INDEX IN COMPAR
000000r 1               PTR             = $62+$40       ;POINTER IN LOOKUP AND COMPAR
000000r 1               IL              = $64+$40       ;INDEX IN LOOKUP
000000r 1               SBTTOP          = $65+$40       ;TOP OF FOR/NEXT STACK
000000r 1               BASE            = $67+$40       ;BASE OF CURRENT ENTRY
000000r 1               FORCNT          = $69+$40       ;FOR COUNT
000000r 1               SBTBL           = $6A+$40       ;TOP OF SYMBOL TABLE
000000r 1               APTADD          = $6C+$40       ;UTILITY VAR TO ACCESS TABLE
000000r 1               PRTCT           = $6E+$40       ;COUNT PRT ENTRIES
000000r 1               FDACT           = $70+$40       ;COUNT FDA ENTRIES
000000r 1               CODESI          = $72+$40       ;COUNT SIZE OF CODE AREA
000000r 1               ULERFL          = $74+$40       ;
000000r 1               PRNTNM          = $75+$40       ;POINTER SET BEFORE SLOOKU OR ENTER
000000r 1               SYMHSH          = $77+$40       ;HASH OF TOKEN REFERENCE
000000r 1               PRODCT          = $78+$40       ;PRODUCTION NUMBER (0 TO PRODNO)
000000r 1               NXSTPT          = $79+$40       ;NEXT STATEMENT POINTER
000000r 1               TMPHSH          = $7B+$40       ;LOCAL HASH IN GETHSH
000000r 1               TMPPTR          = $7C+$40       ;LOCAL PTR IN GETHSH
000000r 1               LEN             = $7D+$40       ;TEMP IN SLOOKU
000000r 1               NUMPRM          = $7E+$40       ;TEMP IN UNLINK/RELINK
000000r 1               LINKI           = $7F+$40       ;TEMP IN UNLINK/RELINK
000000r 1               TMPADR          = $80+$40       ;TEMP IN UNLINK/RELINK
000000r 1               WHERE           = $82+$40       ;TEMP IN GENILS
000000r 1               STRPTR          = $84+$40       ;TEMP IN GINILS
000000r 1               IGEN            = $85+$40       ;TEMP IN GENCON
000000r 1               LZ              = $86+$40       ;
000000r 1               TMPFLG          = $87+$40       ;
000000r 1               
000000r 1               ;entry point
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 27 22             JMP     MAIN
000803  1               ;copyright notice
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT - RICHARD"
000807  1  52 49 47 48  
00080B  1  54 20 2D 20  
000816  1  20 41 2E 20          .BYTE   " A. LEARY - 2008"
00081A  1  4C 45 41 52  
00081E  1  59 20 2D 20  
000826  1               ;SUBROUTINES
000826  1               ;subroutine to point to source fcb and go to pem
000826  1               RFCBX
000826  1  A9 07                LDA     #<FCB           ;point
000828  1  A0 01                LDY     #>FCB           ;to fcb
00082A  1  4C 03 01             JMP     PEM             ;and go
00082D  1               ;point to int fcb and go to pem
00082D  1               WFCBX
00082D  1  A9 23                LDA     #<WFCB          ;point
00082F  1  A0 34                LDY     #>WFCB          ;to fcb
000831  1  4C 03 01             JMP     PEM             ;and go
000834  1               ;send cr and lf to console/list
000834  1               CRLF
000834  1  A9 0D                LDA     #CR             ;get
000836  1  20 4F 08             JSR     PRNCHR          ;a cr
000839  1  A9 0A                LDA     #LF             ;and
00083B  1  4C 4F 08             JMP     PRNCHR          ;then a lf
00083E  1               ;output char in A to console or list device as a function of LSTFLG
00083E  1               SPCOUT
00083E  1  A9 20                LDA     #SPACE          ;get space
000840  1               CHROUT
000840  1  2C 1D 34             BIT     LSTFLG          ;test flag
000843  1  30 05                BMI     *+7             ;use list if set
000845  1  A2 02                LDX     #2              ;else set
000847  1  4C 03 01             JMP     PEM             ;and do console
00084A  1  A2 05                LDX     #5              ;set list
00084C  1  4C 03 01             JMP     PEM             ;and do
00084F  1               ;print char in A and handle tabs and linefeeds
00084F  1               PRNCHR
00084F  1  C9 09                CMP     #TAB            ;see if tab
000851  1  D0 0C                BNE     NOTTAB          ;branch if not
000853  1               TABOVR
000853  1  20 3E 08             JSR     SPCOUT          ;send a space
000856  1  E6 6F                INC     COLUMN          ;bump column
000858  1  A5 6F                LDA     COLUMN          ;get it
00085A  1  29 07                AND     #7              ;see if mod 8
00085C  1  D0 F5                BNE     TABOVR          ;loop if not
00085E  1  60                   RTS                     ;else done
00085F  1               NOTTAB
00085F  1  48                   PHA                     ;save char
000860  1  20 40 08             JSR     CHROUT          ;send it
000863  1  E6 6F                INC     COLUMN          ;bump column
000865  1  68                   PLA                     ;get char
000866  1  C9 0A                CMP     #LF             ;if a lf
000868  1  F0 01                BEQ     *+3             ;then branch
00086A  1  60                   RTS                     ;else done
00086B  1  A9 00                LDA     #0              ;clear column
00086D  1  85 6F                STA     COLUMN          ;and then
00086F  1  60                   RTS                     ;done
000870  1               ;convert AY to decimal number and print on console
000870  1               PRNDEC
000870  1  85 93                STA     DECOUT          ;save
000872  1  84 94                STY     DECOUT+1        ;value
000874  1  A9 00                LDA     #FALSE          ;set flag
000876  1  85 95                STA     LZFLAG          ;to false
000878  1  A2 2F                LDX     #'0'-1          ;set digit to '0' - 1
00087A  1  38                   SEC                     ;now
00087B  1               P10000
00087B  1  A5 93                LDA     DECOUT          ;subtract
00087D  1  E9 10                SBC     #<10000         ;10000
00087F  1  85 93                STA     DECOUT          ;from
000881  1  A5 94                LDA     DECOUT+1        ;value
000883  1  E9 27                SBC     #>10000         ;and
000885  1  85 94                STA     DECOUT+1        ;save
000887  1  E8                   INX                     ;bump digit
000888  1  B0 F1                BCS     P10000          ;loop if no borrow
00088A  1  A5 93                LDA     DECOUT          ;else
00088C  1  69 10                ADC     #<10000         ;add
00088E  1  85 93                STA     DECOUT          ;10000
000890  1  A5 94                LDA     DECOUT+1        ;back
000892  1  69 27                ADC     #>10000         ;in to
000894  1  85 94                STA     DECOUT+1        ;correct
000896  1  20 E6 08             JSR     DIGOUT          ;send digit
000899  1               P1000
000899  1  A5 93                LDA     DECOUT          ;now
00089B  1  E9 E8                SBC     #<1000          ;drop
00089D  1  85 93                STA     DECOUT          ;by
00089F  1  A5 94                LDA     DECOUT+1        ;1000
0008A1  1  E9 03                SBC     #>1000          ;until
0008A3  1  85 94                STA     DECOUT+1        ;a borrow
0008A5  1  E8                   INX                     ;bump digit
0008A6  1  B0 F1                BCS     P1000           ;loop if more
0008A8  1  A5 93                LDA     DECOUT          ;now
0008AA  1  69 E8                ADC     #<1000          ;add
0008AC  1  85 93                STA     DECOUT          ;1000
0008AE  1  A5 94                LDA     DECOUT+1        ;back
0008B0  1  69 03                ADC     #>1000          ;in to
0008B2  1  85 94                STA     DECOUT+1        ;correct
0008B4  1  20 E6 08             JSR     DIGOUT          ;send 1000s
0008B7  1               P100
0008B7  1  A5 93                LDA     DECOUT          ;now
0008B9  1  E9 64                SBC     #100            ;do
0008BB  1  85 93                STA     DECOUT          ;subtract
0008BD  1  A5 94                LDA     DECOUT+1        ;for
0008BF  1  E9 00                SBC     #0              ;100
0008C1  1  85 94                STA     DECOUT+1        ;with
0008C3  1  E8                   INX                     ;digit bump
0008C4  1  B0 F1                BCS     P100            ;loop if more
0008C6  1  A5 93                LDA     DECOUT          ;else
0008C8  1  69 64                ADC     #100            ;add back
0008CA  1  85 93                STA     DECOUT          ;to correct
0008CC  1  20 E6 08             JSR     DIGOUT          ;send 100s
0008CF  1               P10
0008CF  1  A5 93                LDA     DECOUT          ;now
0008D1  1  E9 0A                SBC     #10             ;drop
0008D3  1  85 93                STA     DECOUT          ;by 10
0008D5  1  E8                   INX                     ;bump digit
0008D6  1  B0 F7                BCS     P10             ;loop if more
0008D8  1  69 0A                ADC     #10             ;correct
0008DA  1  85 93                STA     DECOUT          ;save
0008DC  1  20 E6 08             JSR     DIGOUT          ;and send 10s
0008DF  1  A9 30                LDA     #'0'            ;get zero
0008E1  1  05 93                ORA     DECOUT          ;add number
0008E3  1  4C 4F 08             JMP     PRNCHR          ;and print always
0008E6  1               ;send a single digit in X and handle leading zeros
0008E6  1               DIGOUT
0008E6  1  A9 20                LDA     #SPACE          ;preset for blank
0008E8  1  24 95                BIT     LZFLAG          ;test flag
0008EA  1  30 08                BMI     D2              ;branch if set
0008EC  1  E0 30                CPX     #'0'            ;else test current
0008EE  1  F0 05                BEQ     D3              ;branch if '0'
0008F0  1  A9 FF                LDA     #TRUE           ;else set
0008F2  1  85 95                STA     LZFLAG          ;flag
0008F4  1               D2
0008F4  1  8A                   TXA                     ;get char
0008F5  1               D3
0008F5  1  20 4F 08             JSR     PRNCHR          ;print it
0008F8  1  A2 2F                LDX     #'0'-1          ;now preset
0008FA  1  38                   SEC                     ;for next
0008FB  1  60                   RTS
0008FC  1               ;print message pointed to by AY until a $ is encountered
0008FC  1               PRNMSG
0008FC  1  8D 03 09             STA     PRN0+1          ;save message
0008FF  1  8C 04 09             STY     PRN0+2          ;address
000902  1               PRN0
000902  1  AD FF FF             LDA     $FFFF           ;get byte
000905  1  C9 24                CMP     #'$'            ;see if end
000907  1  D0 01                BNE     *+3             ;branch if not
000909  1  60                   RTS                     ;else done
00090A  1  20 4F 08             JSR     PRNCHR          ;print it
00090D  1  EE 03 09             INC     PRN0+1          ;bump low
000910  1  D0 F0                BNE     PRN0            ;loop if no carry
000912  1  EE 04 09             INC     PRN0+2          ;bump high
000915  1  4C 02 09             JMP     PRN0            ;and loop
000918  1               ;disk error exit
000918  1               DSKERR
000918  1  A9 BC                LDA     #<DEMSG         ;point to
00091A  1  A0 33                LDY     #>DEMSG         ;message
00091C  1               DSKER0
00091C  1  20 FC 08             JSR     PRNMSG          ;print it
00091F  1  4C 00 01             JMP     BOOT            ;and boot
000922  1               ;open source file
000922  1               OPNSRC
000922  1  A2 03                LDX     #3              ;first
000924  1               OPN1
000924  1  BD D2 33             LDA     BASSTR-1,X      ;move
000927  1  9D 0F 01             STA     FCB+8,X         ;BAS to
00092A  1  CA                   DEX                     ;type part
00092B  1  D0 F7                BNE     OPN1            ;of fcb
00092D  1  8E 13 01             STX     FCB+12          ;clear extent
000930  1  8E 14 01             STX     FCB+13
000933  1  8E 27 01             STX     FCB+32          ;and record
000936  1  A9 83                LDA     #<INPBUF        ;point to
000938  1  A0 36                LDY     #>INPBUF        ;buffer
00093A  1  A2 1A                LDX     #26             ;and set
00093C  1  20 03 01             JSR     PEM             ;as buffer location
00093F  1  A2 0F                LDX     #15             ;open code
000941  1  20 26 08             JSR     RFCBX           ;do it
000944  1  30 01                BMI     *+3             ;branch if bad
000946  1  60                   RTS                     ;else done
000947  1  A9 D6                LDA     #<NSMSG         ;point to
000949  1  A0 33                LDY     #>NSMSG         ;no source message
00094B  1  4C 1C 09             JMP     DSKER0          ;send and quit
00094E  1               ;close output (INT) file
00094E  1               CLSINT
00094E  1  A2 10                LDX     #16             ;close code
000950  1  20 2D 08             JSR     WFCBX           ;do it
000953  1  30 01                BMI     *+3             ;branch if bad
000955  1  60                   RTS                     ;else done
000956  1  4C 18 09             JMP     DSKERR          ;error exit
000959  1               ;set-up INT file
000959  1               SUPINT
000959  1  2C 1C 34             BIT     NINTFL          ;test no-int flag
00095C  1  10 01                BPL     *+3             ;branch if false
00095E  1  60                   RTS                     ;else done
00095F  1  A2 08                LDX     #8              ;move 9
000961  1               SUP0
000961  1  BD 07 01             LDA     FCB,X           ;char including drive
000964  1  9D 23 34             STA     WFCB,X          ;to write fcb
000967  1  CA                   DEX                     ;drop count
000968  1  10 F7                BPL     SUP0            ;loop if more
00096A  1  E8                   INX
00096B  1  8E 2F 34             STX     WFCB+12
00096E  1  8E 30 34             STX     WFCB+13
000971  1  8E 43 34             STX     WFCB+32         ;clear extent and record
000974  1  A2 13                LDX     #19             ;now delete
000976  1  20 2D 08             JSR     WFCBX           ;it if there
000979  1  A2 16                LDX     #22             ;now try
00097B  1  20 2D 08             JSR     WFCBX           ;to create
00097E  1  10 03                BPL     *+5             ;branch if ok
000980  1  4C 18 09             JMP     DSKERR          ;else error
000983  1  60                   RTS                     ;and quit
000984  1               ;reset compiler flags
000984  1               SETFLG
000984  1  A9 00                LDA     #FALSE
000986  1  8D 22 34             STA     RNDFLE          ;random file
000989  1  8D 21 34             STA     FILEIO          ;file io
00098C  1  85 47                STA     INPSTM          ;input statement
00098E  1  8D 20 34             STA     FORSTM          ;for statement
000991  1  85 48                STA     GSBSTM          ;gosub statement
000993  1  60                   RTS
000994  1               ;write INT record
000994  1               WRTINT
000994  1  2C 1C 34             BIT     NINTFL          ;test flag
000997  1  10 01                BPL     *+3             ;ok if false
000999  1  60                   RTS                     ;else done
00099A  1  A9 03                LDA     #<OUTBUF        ;point to
00099C  1  A0 37                LDY     #>OUTBUF        ;buffer
00099E  1  A2 1A                LDX     #26             ;and set
0009A0  1  20 03 01             JSR     PEM             ;as dma
0009A3  1  A2 15                LDX     #21             ;now do
0009A5  1  20 2D 08             JSR     WFCBX           ;write op
0009A8  1  F0 03                BEQ     *+5             ;ok if zero
0009AA  1  4C 18 09             JMP     DSKERR          ;else error
0009AD  1  A9 83                LDA     #<INPBUF        ;point back
0009AF  1  A0 36                LDY     #>INPBUF        ;to input
0009B1  1  A2 1A                LDX     #26             ;and set
0009B3  1  4C 03 01             JMP     PEM             ;as default
0009B6  1               ;emit byte in A to INT file
0009B6  1               EMIT
0009B6  1  A6 72                LDX     OUTIND          ;get index
0009B8  1  10 09                BPL     EMIT0           ;ok if < 128
0009BA  1  48                   PHA                     ;else save
0009BB  1  20 94 09             JSR     WRTINT          ;write buffer
0009BE  1  68                   PLA                     ;get byte
0009BF  1  A2 00                LDX     #0              ;now clear
0009C1  1  86 72                STX     OUTIND          ;index
0009C3  1               EMIT0
0009C3  1  E6 72                INC     OUTIND          ;bump for next
0009C5  1  9D 03 37             STA     OUTBUF,X        ;save byte
0009C8  1  60                   RTS                     ;and done
0009C9  1               ;read source file record
0009C9  1               RDESRC
0009C9  1  A2 14                LDX     #20             ;get code
0009CB  1  20 26 08             JSR     RFCBX           ;do it
0009CE  1  C9 02                CMP     #2              ;see if ok
0009D0  1  90 03                BCC     *+5             ;branch if was
0009D2  1  4C 18 09             JMP     DSKERR          ;else error
0009D5  1  60                   RTS
0009D6  1               ;clear output line buffer
0009D6  1               CLLNBF
0009D6  1  A2 51                LDX     #CBUFSZ-1       ;get length - 1
0009D8  1  A9 20                LDA     #SPACE          ;use space
0009DA  1               CLLN0
0009DA  1  9D 83 37             STA     CONBUF,X        ;store
0009DD  1  CA                   DEX                     ;drop index
0009DE  1  E0 FF                CPX     #255            ;see if wrap
0009E0  1  D0 F8                BNE     CLLN0           ;loop if not
0009E2  1  60                   RTS
0009E3  1               ;list line of length LENGTH
0009E3  1               ;note that this routine also sets seprtr to : (just in case!!)
0009E3  1               LSTLNE
0009E3  1  A5 70                LDA     LINENO          ;get line
0009E5  1  A4 71                LDY     LINENO+1        ;number
0009E7  1  20 70 08             JSR     PRNDEC          ;print it
0009EA  1  A5 74                LDA     SEPRTR          ;then print
0009EC  1  20 4F 08             JSR     PRNCHR          ;separator
0009EF  1  A9 20                LDA     #SPACE          ;and a
0009F1  1  20 4F 08             JSR     PRNCHR          ;space
0009F4  1  A9 00                LDA     #0              ;now clear
0009F6  1  85 42                STA     GPIND           ;index
0009F8  1               LSTL0
0009F8  1  A6 42                LDX     GPIND           ;get index
0009FA  1  BD 83 37             LDA     CONBUF,X        ;get char
0009FD  1  20 4F 08             JSR     PRNCHR          ;print it
000A00  1  E6 42                INC     GPIND           ;bump index
000A02  1  A5 42                LDA     GPIND           ;get index
000A04  1  C5 73                CMP     LENGTH          ;compare to length
000A06  1  90 F0                BCC     LSTL0           ;loop if more
000A08  1  F0 EE                BEQ     LSTL0           ;or if same
000A0A  1  20 34 08             JSR     CRLF            ;do cr and lf
000A0D  1  20 D6 09             JSR     CLLNBF          ;clear buffer
000A10  1  A9 3A                LDA     #':'            ;and set
000A12  1  85 74                STA     SEPRTR          ;separator
000A14  1  60                   RTS
000A15  1               ;set global variable NXTCHR to next source file character and return with
000A15  1               ;NXTCHR in A. Replace TAB with SPACE and if LSTSRC is TRUE or an error
000A15  1               ;occurs send the line to the console.
000A15  1               GETCHR
000A15  1  20 70 0A             JSR     CHKFLE          ;go get char
000A18  1  D0 06                BNE     GETEOF          ;branch if eof
000A1A  1  A5 4D                LDA     NXTCHR          ;get nextchar
000A1C  1  C9 1A                CMP     #EOF            ;see if eof char
000A1E  1  D0 13                BNE     NTEOF           ;branch if not
000A20  1               GETEOF
000A20  1  A2 04                LDX     #4              ;move 5
000A22  1               GETE0
000A22  1  BD EC 33             LDA     ADDEND,X        ;from ADDEND
000A25  1  9D 83 36             STA     INPBUF,X        ;to input buffer
000A28  1  CA                   DEX                     ;drop count
000A29  1  10 F7                BPL     GETE0           ;loop if more
000A2B  1  E8                   INX                     ;clear X
000A2C  1  86 75                STX     SRCIND          ;and then index
000A2E  1  20 6A 0A             JSR     NXTSRC          ;get next
000A31  1  85 4D                STA     NXTCHR          ;save it
000A33  1               NTEOF
000A33  1  A6 76                LDX     LNEPTR          ;get pointer
000A35  1  E0 52                CPX     #CBUFSZ         ;compare to max
000A37  1  B0 08                BCS     LTOBIG          ;branch if too big
000A39  1  E8                   INX                     ;else bump
000A3A  1  86 76                STX     LNEPTR          ;and save
000A3C  1  A5 4D                LDA     NXTCHR          ;get char
000A3E  1  9D 83 37             STA     CONBUF,X        ;and save
000A41  1               LTOBIG
000A41  1  A5 4D                LDA     NXTCHR          ;get char
000A43  1  C9 0D                CMP     #CR             ;see if a cr
000A45  1  D0 19                BNE     NTEOL           ;branch if not
000A47  1  E6 70                INC     LINENO          ;else bump
000A49  1  D0 02                BNE     *+4             ;line
000A4B  1  E6 71                INC     LINENO+1        ;number
000A4D  1  A6 76                LDX     LNEPTR          ;get pointer
000A4F  1  CA                   DEX                     ;drop it
000A50  1  86 73                STX     LENGTH          ;put in length
000A52  1  AD 19 34             LDA     LSTSRC          ;get flag
000A55  1  F0 03                BEQ     NOLSLN          ;branch if not true
000A57  1  20 E3 09             JSR     LSTLNE          ;list it
000A5A  1               NOLSLN
000A5A  1  A9 00                LDA     #0              ;then clear
000A5C  1  85 76                STA     LNEPTR          ;pointer
000A5E  1  A5 4D                LDA     NXTCHR          ;get char
000A60  1               NTEOL
000A60  1  C9 09                CMP     #TAB            ;see it tab
000A62  1  F0 01                BEQ     *+3             ;branch if is
000A64  1  60                   RTS
000A65  1  A9 20                LDA     #SPACE          ;else get space
000A67  1  85 4D                STA     NXTCHR          ;set
000A69  1  60                   RTS                     ;and done
000A6A  1               ;get byte from source file
000A6A  1               NXTSRC
000A6A  1  A6 75                LDX     SRCIND          ;get index
000A6C  1  BD 83 36             LDA     INPBUF,X        ;then byte
000A6F  1  60                   RTS
000A70  1               ;maintain source buffer full and check for eof. if eof is detected then
000A70  1               ;A:=TRUE else A:=FALSE
000A70  1               CHKFLE
000A70  1  E6 75                INC     SRCIND          ;bump index
000A72  1  10 0E                BPL     CHKFL0          ;branch if ok
000A74  1  A9 00                LDA     #0              ;else clear
000A76  1  85 75                STA     SRCIND          ;index
000A78  1  20 C9 09             JSR     RDESRC          ;read record
000A7B  1  C9 01                CMP     #1              ;see if eof
000A7D  1  D0 03                BNE     CHKFL0          ;branch if not
000A7F  1  A9 FF                LDA     #TRUE           ;else set
000A81  1  60                   RTS                     ;eof=true
000A82  1               CHKFL0
000A82  1  20 6A 0A             JSR     NXTSRC          ;get next
000A85  1  85 4D                STA     NXTCHR          ;save it
000A87  1  C9 0A                CMP     #LF             ;if a lf
000A89  1  F0 E5                BEQ     CHKFLE          ;loop for more
000A8B  1  A9 00                LDA     #FALSE          ;else say
000A8D  1  60                   RTS                     ;wasn't eof
000A8E  1               ;get non-blank from source. will also skip past eof to reach physical eof.
000A8E  1               GTNBLK
000A8E  1  20 15 0A             JSR     GETCHR          ;get new char
000A91  1  C9 20                CMP     #SPACE          ;if a space
000A93  1  F0 F9                BEQ     GTNBLK          ;try again
000A95  1  C9 1A                CMP     #EOF            ;if an eof
000A97  1  F0 F5                BEQ     GTNBLK          ;try again
000A99  1  60                   RTS
000A9A  1               ;check for continuation character. if it is will get first char from next line.
000A9A  1               CHKCNT
000A9A  1  A5 4D                LDA     NXTCHR          ;get next
000A9C  1  C9 5C                CMP     #backsl         ;see if continue
000A9E  1  F0 01                BEQ     *+3             ;branch if is
000AA0  1  60                   RTS
000AA1  1               CHKCN0
000AA1  1  20 15 0A             JSR     GETCHR          ;get next
000AA4  1  C9 0D                CMP     #CR             ;see if eol
000AA6  1  D0 F9                BNE     CHKCN0          ;loop if isn't
000AA8  1  4C 8E 0A             JMP     GTNBLK          ;now get first non-blank
000AAB  1               ;compiler error handler
000AAB  1               ;at entry a contains error number
000AAB  1               ERROR
000AAB  1  85 78                STA     ERRCDE          ;save
000AAD  1  A5 76                LDA     LNEPTR          ;get index
000AAF  1  85 77                STA     POINTR          ;move to pointer
000AB1  1  E6 77                INC     POINTR          ;and bump
000AB3  1  E6 77                INC     POINTR          ;by two
000AB5  1  A5 49                LDA     TOKEN           ;get token
000AB7  1  C9 17                CMP     #TCR            ;see if for eol
000AB9  1  F0 0F                BEQ     ERROR3          ;branch if is
000ABB  1  A5 4D                LDA     NXTCHR          ;else get next
000ABD  1               ERROR1
000ABD  1  C9 0D                CMP     #CR             ;if a cr
000ABF  1  F0 09                BEQ     ERROR3          ;then done
000AC1  1  20 9A 0A             JSR     CHKCNT          ;else see if continue
000AC4  1  20 15 0A             JSR     GETCHR          ;get another char
000AC7  1  4C BD 0A             JMP     ERROR1          ;and loop
000ACA  1               ERROR3
000ACA  1  2C 17 34             BIT     PASS2           ;test pass 2 flag
000ACD  1  10 43                BPL     ERROR6          ;branch if clear
000ACF  1  2C 19 34             BIT     LSTSRC          ;see if source already listed
000AD2  1  30 03                BMI     *+5             ;skip list if was
000AD4  1  20 E3 09             JSR     LSTLNE          ;else list
000AD7  1  E6 43                INC     ERRCNT          ;bump
000AD9  1  D0 02                BNE     *+4             ;error
000ADB  1  E6 44                INC     ERRCNT+1        ;count
000ADD  1  A9 3F                LDA     #'?'            ;print a ?
000ADF  1  20 4F 08             JSR     PRNCHR
000AE2  1  A9 2D                LDA     #'-'
000AE4  1  20 4F 08             JSR     PRNCHR          ;print two -
000AE7  1  A9 2D                LDA     #'-'
000AE9  1  20 4F 08             JSR     PRNCHR
000AEC  1               ERROR4
000AEC  1  C6 77                DEC     POINTR          ;drop pointer
000AEE  1  F0 0A                BEQ     ERROR5          ;done if zero
000AF0  1  30 08                BMI     ERROR5          ;or <0
000AF2  1  A9 2D                LDA     #'-'            ;else get -
000AF4  1  20 4F 08             JSR     PRNCHR          ;print it
000AF7  1  4C EC 0A             JMP     ERROR4          ;and loop
000AFA  1               ERROR5
000AFA  1  A9 5E                LDA     #'^'            ;get up arrow
000AFC  1  20 4F 08             JSR     PRNCHR          ;print it
000AFF  1  20 34 08             JSR     CRLF            ;then a cr and lf
000B02  1  A5 78                LDA     ERRCDE          ;get error code
000B04  1  0A                   ASL     A               ;mult by two
000B05  1  AA                   TAX
000B06  1  BD 73 33             LDA     ERMTBL,X
000B09  1  BC 74 33             LDY     ERMTBL+1,X      ;get message address
000B0C  1  20 FC 08             JSR     PRNMSG          ;print it
000B0F  1  20 34 08             JSR     CRLF
000B12  1               ERROR6
000B12  1  A9 00                LDA     #FALSE          ;now clear
000B14  1  8D 1F 34             STA     CMPLNG          ;compiling flag
000B17  1  4C 84 09             JMP     SETFLG          ;and then other flags
000B1A  1               ;initialize scanner by setting NXTCHR to the first non-blank character from the
000B1A  1               ;input file and by setting the line number and pointer
000B1A  1               INSCAN
000B1A  1  2C 16 34             BIT     PASS1           ;test for pass 1
000B1D  1  10 0B                BPL     NOGTPR          ;branch if not
000B1F  1  A2 08                LDX     #8              ;move 8 parms
000B21  1               INSCA0
000B21  1  BD 17 01             LDA     FCB+16,X        ;from fcb
000B24  1  9D 43 34             STA     PRMLST-1,X      ;to save area
000B27  1  CA                   DEX                     ;drop count
000B28  1  D0 F7                BNE     INSCA0          ;loop if more
000B2A  1               NOGTPR
000B2A  1  20 22 09             JSR     OPNSRC          ;open file
000B2D  1  A9 00                LDA     #0              ;now
000B2F  1  85 6E                STA     CONT            ;clear
000B31  1  85 6F                STA     COLUMN          ;variables
000B33  1  85 70                STA     LINENO          ;for start
000B35  1  85 71                STA     LINENO+1        ;of a
000B37  1  85 76                STA     LNEPTR          ;pass
000B39  1  20 D6 09             JSR     CLLNBF          ;clear output buffer
000B3C  1  A9 80                LDA     #SRCRSZ         ;now set source
000B3E  1  85 75                STA     SRCIND          ;index to invalid
000B40  1  A9 3A                LDA     #':'            ;set separator
000B42  1  85 74                STA     SEPRTR          ;to a colon
000B44  1  AD 44 34             LDA     PRMLST          ;get first parm
000B47  1  C9 24                CMP     #'$'            ;see if start
000B49  1  D0 44                BNE     INSDNE          ;not so exit
000B4B  1  A2 01                LDX     #1              ;set index to first
000B4D  1               INSCAP
000B4D  1  BD 44 34             LDA     PRMLST,X        ;get parm
000B50  1  E8                   INX                     ;bump index
000B51  1  C9 20                CMP     #SPACE          ;if not a space
000B53  1  F0 3A                BEQ     INSDNE          ;done if space
000B55  1  A0 FF                LDY     #TRUE           ;set true
000B57  1  C9 41                CMP     #'A'            ;if not A
000B59  1  D0 05                BNE     PNOTA           ;try next
000B5B  1  8C 18 34             STY     LSTPRD          ;else set
000B5E  1  F0 ED                BEQ     INSCAP          ;and loop
000B60  1               PNOTA
000B60  1  C9 43                CMP     #'C'            ;if not C
000B62  1  D0 05                BNE     PNOTC           ;try next
000B64  1  8C 1C 34             STY     NINTFL          ;else set
000B67  1  F0 E4                BEQ     INSCAP          ;and loop
000B69  1               PNOTC
000B69  1  C9 45                CMP     #'E'            ;see if E
000B6B  1  D0 05                BNE     PNOTE           ;branch if not
000B6D  1  8C 1A 34             STY     DEBUGL          ;else set
000B70  1  F0 DB                BEQ     INSCAP          ;and loop
000B72  1               PNOTE
000B72  1  C9 46                CMP     #'F'            ;see if F
000B74  1  D0 05                BNE     PNOTF           ;branch if not
000B76  1  8C 1D 34             STY     LSTFLG          ;else set
000B79  1  F0 D2                BEQ     INSCAP          ;and loop
000B7B  1               PNOTF
000B7B  1  A0 00                LDY     #FALSE          ;now use false
000B7D  1  C9 42                CMP     #'B'            ;if not B
000B7F  1  D0 05                BNE     PNOTB           ;try next
000B81  1  8C 19 34             STY     LSTSRC          ;else set
000B84  1  F0 C7                BEQ     INSCAP          ;and loop
000B86  1               PNOTB
000B86  1  C9 44                CMP     #'D'            ;if not D
000B88  1  D0 C3                BNE     INSCAP          ;then not valid
000B8A  1  8C 1B 34             STY     LWRUPR          ;else set
000B8D  1  F0 BE                BEQ     INSCAP          ;and loop
000B8F  1               ;done with INSCAN so get first non-blank
000B8F  1               INSDNE
000B8F  1  A9 00                LDA     #0              ;clear eol flag
000B91  1  8D 1E 34             STA     EOLSTS
000B94  1  4C 8E 0A             JMP     GTNBLK
000B97  1               ;put NXTCHR in ACCUM
000B97  1               PUTACC
000B97  1  24 6E                BIT     CONT            ;test for continue
000B99  1  10 01                BPL     *+3             ;do if not
000B9B  1  60                   RTS                     ;else done
000B9C  1  E6 4E                INC     ACCLEN          ;bump length
000B9E  1  A6 4E                LDX     ACCLEN          ;get it as index
000BA0  1  A5 4D                LDA     NXTCHR          ;get next
000BA2  1                       .IFDEF  DUODYNE
000BA2  1  9F 4E 00 00          STA     F:ACCUM,X         ;store it
000BA6  1                       .ELSE
000BA6  1                       STA     ACCUM,X         ;store it
000BA6  1                       .ENDIF
000BA6  1  18                   CLC                     ;clear carry
000BA7  1  65 4C                ADC     HSHCDE          ;add hashcde
000BA9  1  29 3F                AND     #HSHMSK         ;mask it
000BAB  1  85 4C                STA     HSHCDE          ;and save
000BAD  1  E0 1F                CPX     #IDNTSZ-1       ;compare to max
000BAF  1  B0 01                BCS     *+3             ;branch if too big
000BB1  1  60                   RTS                     ;else done
000BB2  1  A9 FF                LDA     #TRUE           ;set CONT
000BB4  1  85 6E                STA     CONT            ;flag
000BB6  1  60                   RTS
000BB7  1               ;put NXTCHR in ACCUM and get another non-blank
000BB7  1               PUTGET
000BB7  1  20 97 0B             JSR     PUTACC          ;put
000BBA  1  4C 8E 0A             JMP     GTNBLK          ;and get
000BBD  1               ;put NXTCHR in ACCUM and get another char
000BBD  1               PUTCHR
000BBD  1  20 97 0B             JSR     PUTACC          ;put
000BC0  1  4C 15 0A             JMP     GETCHR          ;and get
000BC3  1               ;test for numeric NXTCHR. return with A:=TRUE iff NXTCHR in '0' to '9'
000BC3  1               NUMRIC
000BC3  1  A5 4D                LDA     NXTCHR          ;get char
000BC5  1  C9 30                CMP     #'0'            ;see if less than 0
000BC7  1  90 07                BCC     NOTNUM          ;branch if is
000BC9  1  C9 3A                CMP     #'9'+1          ;see if over 9
000BCB  1  B0 03                BCS     NOTNUM          ;branch if is
000BCD  1  A9 FF                LDA     #TRUE           ;else set
000BCF  1  60                   RTS                     ;for numeric
000BD0  1               NOTNUM
000BD0  1  A9 00                LDA     #FALSE          ;set false
000BD2  1  60                   RTS
000BD3  1               ;test for lower case NXTCHR. return with A:=TRUE iff NXTCHR in 'a' to 'z'
000BD3  1               LWRCSE
000BD3  1  A5 4D                LDA     NXTCHR          ;get chat
000BD5  1  C9 61                CMP     #'a'            ;see if < a
000BD7  1  90 07                BCC     NOTLWR          ;branch if is
000BD9  1  C9 7B                CMP     #'z'+1          ;see if > z
000BDB  1  B0 03                BCS     NOTLWR          ;branch if is
000BDD  1  A9 FF                LDA     #TRUE           ;else
000BDF  1  60                   RTS                     ;is lower
000BE0  1               NOTLWR
000BE0  1  A9 00                LDA     #FALSE          ;not lower
000BE2  1  60                   RTS
000BE3  1               ;test for NXTCHR a decimal point
000BE3  1               DCMLPT
000BE3  1  A5 4D                LDA     NXTCHR          ;get char
000BE5  1  C9 2E                CMP     #'.'            ;test it
000BE7  1  D0 03                BNE     NTDCML          ;branch if not
000BE9  1  A9 FF                LDA     #TRUE           ;set for true
000BEB  1  60                   RTS
000BEC  1               NTDCML
000BEC  1  A9 00                LDA     #FALSE          ;false
000BEE  1  60                   RTS
000BEF  1               ;convert lowercase to uppercase
000BEF  1               CNVLWR
000BEF  1  20 D3 0B             JSR     LWRCSE          ;see if lower
000BF2  1  2D 1B 34             AND     LWRUPR          ;and with flag
000BF5  1  D0 01                BNE     *+3             ;ok if both true
000BF7  1  60                   RTS                     ;else done
000BF8  1  A5 4D                LDA     NXTCHR          ;get char
000BFA  1  29 5F                AND     #$5F            ;convert
000BFC  1  85 4D                STA     NXTCHR          ;and save
000BFE  1  60                   RTS
000BFF  1               ;test for letter. set A:=TRUE if lowercase or uppercase letter
000BFF  1               LETTER
000BFF  1  20 EF 0B             JSR     CNVLWR          ;covert if all set
000C02  1  20 D3 0B             JSR     LWRCSE          ;see if still lowercase
000C05  1  F0 01                BEQ     *+3             ;branch if not
000C07  1  60                   RTS                     ;else is TRUE
000C08  1  A5 4D                LDA     NXTCHR          ;get char
000C0A  1  C9 41                CMP     #'A'            ;if < A
000C0C  1  90 07                BCC     NOTLTR          ;is not letter
000C0E  1  C9 5B                CMP     #'Z'+1          ;if > Z
000C10  1  B0 03                BCS     NOTLTR          ;is not letter
000C12  1  A9 FF                LDA     #TRUE           ;else is
000C14  1  60                   RTS
000C15  1               NOTLTR
000C15  1  A9 00                LDA     #FALSE          ;not letter
000C17  1  60                   RTS
000C18  1               ;test for letter, number or decimal point. return A:=TRUE if either
000C18  1               ALPNUM
000C18  1  20 FF 0B             JSR     LETTER          ;first try letter
000C1B  1  F0 01                BEQ     *+3             ;branch if not
000C1D  1  60                   RTS
000C1E  1  20 C3 0B             JSR     NUMRIC          ;now try number
000C21  1  F0 01                BEQ     *+3             ;branch if not
000C23  1  60                   RTS
000C24  1  4C E3 0B             JMP     DCMLPT          ;finally try decimal point
000C27  1               ;spool numeric data into ACCUM
000C27  1               SPLNUM
000C27  1  20 C3 0B             JSR     NUMRIC          ;see if number
000C2A  1  D0 01                BNE     *+3             ;branch if is
000C2C  1  60                   RTS                     ;else done
000C2D  1  20 BD 0B             JSR     PUTCHR          ;stuff it
000C30  1  4C 27 0C             JMP     SPLNUM          ;and loop
000C33  1               ;set up next call
000C33  1               SUPNCL
000C33  1  A5 4D                LDA     NXTCHR          ;get next
000C35  1  C9 20                CMP     #SPACE          ;see if blank
000C37  1  D0 03                BNE     *+5             ;branch if not
000C39  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000C3C  1  A9 00                LDA     #FALSE          ;set continue
000C3E  1  85 6E                STA     CONT            ;to false
000C40  1  60                   RTS
000C41  1               ;procedure called by SYNTHE to reduce the amount of indexing
000C41  1               SCOPY
000C41  1  A6 7B                LDX     SP              ;get stack pointer
000C43  1  BD 10 35             LDA     TYPE,X          ;do
000C46  1  85 80                STA     TYPESP          ;byte
000C48  1  BD 30 35             LDA     STYPE,X         ;values
000C4B  1  85 83                STA     STYPSP          ;first
000C4D  1  BD D0 34             LDA     HASH,X
000C50  1  85 8C                STA     HASHSP
000C52  1  8A                   TXA                     ;now
000C53  1  0A                   ASL     A               ;make a
000C54  1  AA                   TAX                     ;word index
000C55  1  BD 90 35             LDA     SYMLOC,X
000C58  1  BC 91 35             LDY     SYMLOC+1,X
000C5B  1  85 86                STA     SYMLSP
000C5D  1  84 87                STY     SYMLSP+1
000C5F  1  BD 50 35             LDA     SRLOC,X
000C62  1  BC 51 35             LDY     SRLOC+1,X
000C65  1  85 8F                STA     SRLOSP
000C67  1  84 90                STY     SRLOSP+1
000C69  1  A6 7C                LDX     MP              ;now get MP
000C6B  1  BD 10 35             LDA     TYPE,X
000C6E  1  85 82                STA     TYPEMP
000C70  1  BD 30 35             LDA     STYPE,X
000C73  1  85 85                STA     STYPMP
000C75  1  BD D0 34             LDA     HASH,X
000C78  1  85 8E                STA     HASHMP
000C7A  1  8A                   TXA                     ;now
000C7B  1  0A                   ASL     A               ;make a
000C7C  1  AA                   TAX                     ;word index
000C7D  1  BD 90 35             LDA     SYMLOC,X
000C80  1  BC 91 35             LDY     SYMLOC+1,X
000C83  1  85 8A                STA     SYMLMP
000C85  1  84 8B                STY     SYMLMP+1
000C87  1  BD 50 35             LDA     SRLOC,X
000C8A  1  BC 51 35             LDY     SRLOC+1,X
000C8D  1  85 91                STA     SRLOMP
000C8F  1  84 92                STY     SRLOMP+1
000C91  1  A6 7D                LDX     MPP1            ;now get MP+1
000C93  1  BD 10 35             LDA     TYPE,X
000C96  1  85 81                STA     TYPEM1
000C98  1  BD 30 35             LDA     STYPE,X
000C9B  1  85 84                STA     STYPM1
000C9D  1  BD D0 34             LDA     HASH,X
000CA0  1  85 8D                STA     HASHM1
000CA2  1  8A                   TXA                     ;now
000CA3  1  0A                   ASL     A               ;make a
000CA4  1  AA                   TAX                     ;word index
000CA5  1  BD 90 35             LDA     SYMLOC,X
000CA8  1  BC 91 35             LDY     SYMLOC+1,X
000CAB  1  85 88                STA     SYMLM1
000CAD  1  84 89                STY     SYMLM1+1
000CAF  1  60                   RTS
000CB0  1               ;called by SYNTHE to set SYMLOC(SP) to AY
000CB0  1               STSLSP
000CB0  1  48                   PHA                     ;save A part
000CB1  1  A5 7B                LDA     SP              ;get SP
000CB3  1               STSL
000CB3  1  0A                   ASL     A               ;mult by two
000CB4  1  AA                   TAX                     ;make index
000CB5  1  68                   PLA                     ;get byte
000CB6  1  9D 90 35             STA     SYMLOC,X        ;save it
000CB9  1  98                   TYA                     ;get high
000CBA  1  9D 91 35             STA     SYMLOC+1,X      ;save it
000CBD  1  60                   RTS
000CBE  1               ;called by SYNTHE to set SYMLOC(MP) to AY
000CBE  1               STSLMP
000CBE  1  48                   PHA                     ;save low
000CBF  1  A5 7C                LDA     MP              ;get MP
000CC1  1  4C B3 0C             JMP     STSL            ;go do
000CC4  1               ;called by SYNTHE to set TYPE(SP) to A
000CC4  1               STTYSP
000CC4  1  A6 7B                LDX     SP              ;get SP
000CC6  1  9D 10 35             STA     TYPE,X          ;save
000CC9  1  60                   RTS
000CCA  1               ;called by SYNTHE to set STYPE(SP) to A
000CCA  1               STSTSP
000CCA  1  A6 7B                LDX     SP              ;get SP
000CCC  1  9D 30 35             STA     STYPE,X         ;save
000CCF  1  60                   RTS
000CD0  1               ;set STYPE(MP) to A
000CD0  1               STSTMP
000CD0  1  A6 7C                LDX     MP              ;get MP
000CD2  1  9D 30 35             STA     STYPE,X         ;save
000CD5  1  60                   RTS
000CD6  1               ;set TYPE(MP) to A
000CD6  1               STTYMP
000CD6  1  A6 7C                LDX     MP              ;get MP
000CD8  1  9D 10 35             STA     TYPE,X          ;save
000CDB  1  60                   RTS
000CDC  1               ;set HASH(MP) to A
000CDC  1               STHAMP
000CDC  1  A6 7C                LDX     MP              ;get MP
000CDE  1  9D D0 34             STA     HASH,X          ;insert
000CE1  1  60                   RTS
000CE2  1               ;set HASH(SP) to A
000CE2  1               STHASP
000CE2  1  A6 7B                LDX     SP              ;get SP
000CE4  1  9D D0 34             STA     HASH,X          ;insert
000CE7  1  60                   RTS
000CE8  1               ;set SRLOC(SP) to AY
000CE8  1               STSRSP
000CE8  1  48                   PHA                     ;save low
000CE9  1  A5 7B                LDA     SP              ;get SP
000CEB  1  0A                   ASL     A               ;mult by two
000CEC  1  AA                   TAX                     ;make index
000CED  1  68                   PLA                     ;get low
000CEE  1  9D 50 35             STA     SRLOC,X         ;save ir
000CF1  1  98                   TYA                     ;get high
000CF2  1  9D 51 35             STA     SRLOC+1,X       ;save it
000CF5  1  60                   RTS
000CF6  1               ;write generated code in A and count size of code area
000CF6  1               GENERT
000CF6  1  E6 B2                INC     CODESI          ;bump
000CF8  1  D0 02                BNE     *+4             ;code
000CFA  1  E6 B3                INC     CODESI+1        ;size
000CFC  1  2C 16 34             BIT     PASS1           ;test for pass 1
000CFF  1  30 03                BMI     *+5             ;branch if
000D01  1  4C B6 09             JMP     EMIT            ;else go emit
000D04  1  60                   RTS
000D05  1               ;write data in A during pass 2 and count size of data area
000D05  1               EMITDT
000D05  1  E6 45                INC     DATACT          ;bump
000D07  1  D0 02                BNE     *+4             ;data
000D09  1  E6 46                INC     DATACT+1        ;size
000D0B  1  2C 17 34             BIT     PASS2           ;test for pass 2
000D0E  1  10 03                BPL     *+5             ;branch if not
000D10  1  4C B6 09             JMP     EMIT            ;else go emit
000D13  1  60                   RTS
000D14  1               ;compare ACCUM to reserved word string
000D14  1               COMPAR
000D14  1  A9 00                LDA     #0
000D16  1  85 A1                STA     IC
000D18  1               COMPA0
000D18  1  A4 A1                LDY     IC
000D1A  1  8B DA A2 01          LDAINDIRECTY PTR        ;a=field(i)
000D1E  1  B5 A2 C9 00  
000D22  1  D0 04 A2 00  
000D30  1  E6 A1                INC     IC
000D32  1  A4 A1                LDY     IC              ;i=i+1
000D34  1                       .IFDEF DUODYNE
000D34  1  DA                   PHX
000D35  1  BB                   TYX
000D36  1  85 C7                STA     TMPFLG
000D38  1  BF 4E 00 00          LDA     F:ACCUM,X         ;compare field(i) to accum(i=i+1)
000D3C  1  FA                   PLX
000D3D  1  C5 C7                CMP     TMPFLG
000D3F  1                       .ELSE
000D3F  1                       CMP     ACCUM,Y         ;compare field(i) to accum(i=i+1)
000D3F  1                       .ENDIF
000D3F  1  D0 09                BNE     COMPAX          ;exit if different
000D41  1  A5 4E                LDA     ACCLEN
000D43  1  C5 A1                CMP     IC              ;if i<=acclen
000D45  1  B0 D1                BCS     COMPA0          ;then loop
000D47  1               COMPAT
000D47  1  A9 FF                LDA     #TRUE           ;was a match
000D49  1  60                   RTS
000D4A  1               COMPAX
000D4A  1  A5 4E                LDA     ACCLEN          ;check termination condition
000D4C  1  C5 A1                CMP     IC
000D4E  1  90 F7                BCC     COMPAT          ;if i>acclen is true
000D50  1  A9 00                LDA     #FALSE
000D52  1  60                   RTS
000D53  1               ;attempt to match reserved word
000D53  1               LOOKUP
000D53  1  A9 09                LDA     #MAXRWL         ;compare max word length
000D55  1  C5 4E                CMP     ACCLEN          ;to length
000D57  1  90 5A                BCC     LOOKFL          ;exit as false if too big
000D59  1  A6 4E                LDX     ACCLEN          ;get length
000D5B  1  BD 07 30             LDA     OFFSET,X        ;and offset
000D5E  1  18                   CLC                     ;in reserved word table
000D5F  1  69 C6                ADC     #<LNG1          ;now add to
000D61  1  85 A2                STA     PTR             ;start to
000D63  1  A9 00                LDA     #0              ;get
000D65  1  69 2E                ADC     #>LNG1          ;indirect
000D67  1  85 A3                STA     PTR+1           ;pointer
000D69  1  A9 00                LDA     #0              ;set index
000D6B  1  85 A4                STA     IL              ;to zero
000D6D  1               LOOKU0
000D6D  1  E6 A4                INC     IL              ;bump index
000D6F  1  A6 4E                LDX     ACCLEN          ;see if count
000D71  1  BD 11 30             LDA     COUNT,X         ;bigger than
000D74  1  C5 A4                CMP     IL              ;number words
000D76  1  90 3B                BCC     LOOKFL          ;no match if is
000D78  1  20 14 0D             JSR     COMPAR          ;try to match
000D7B  1  D0 0E                BNE     LOOKMT          ;branch if did
000D7D  1  18                   CLC                     ;else
000D7E  1  A5 A2                LDA     PTR             ;bump
000D80  1  65 4E                ADC     ACCLEN          ;pointer
000D82  1  85 A2                STA     PTR             ;by length
000D84  1  90 E7                BCC     LOOKU0          ;of word
000D86  1  E6 A3                INC     PTR+1           ;and try
000D88  1  4C 6D 0D             JMP     LOOKU0          ;next
000D8B  1               LOOKMT
000D8B  1  A6 4E                LDX     ACCLEN          ;get length
000D8D  1  BD 1B 30             LDA     TKOS,X          ;and token offset
000D90  1  18                   CLC                     ;add to
000D91  1  65 A4                ADC     IL              ;index
000D93  1  AA                   TAX                     ;make an index
000D94  1  BD B7 2F             LDA     TK,X            ;get token
000D97  1  85 49                STA     TOKEN           ;and save
000D99  1  C9 41                CMP     #64+1           ;see if over 64
000D9B  1  90 13                BCC     LOOKTR          ;branch if not
000D9D  1  C9 63                CMP     #TDATA          ;see if TDATA
000D9F  1  F0 0F                BEQ     LOOKTR          ;branch if is
000DA1  1  85 4B                STA     FUNCOP          ;else save as FUNCOP
000DA3  1  38                   SEC                     ;now subtract
000DA4  1  E9 41                SBC     #65             ;65 to
000DA6  1  AA                   TAX                     ;make index
000DA7  1  BD 25 30             LDA     ST,X            ;get subtype
000DAA  1  85 4A                STA     SUBTYP          ;and save
000DAC  1  A9 35                LDA     #FUNCT
000DAE  1  85 49                STA     TOKEN           ;token=funct
000DB0  1               LOOKTR
000DB0  1  A9 FF                LDA     #TRUE           ;match
000DB2  1  60                   RTS
000DB3  1               LOOKFL
000DB3  1  A9 00                LDA     #FALSE          ;no match
000DB5  1  60                   RTS
000DB6  1               ;scanner accepts input characters from the source file returning tokens to the
000DB6  1               ;parser.  conversion to uppercase is performed if LWRUPR is set.  each token is
000DB6  1               ;placed in ACCUM and ACCLEN is the length of the token.  the token is hashed by
000DB6  1               ;summing each ASCII character modulo HSHTSZ (hashtablesize) and is stored in
000DB6  1               ;HSHCDE (hashcode).  SUBTYP and FUNCOP are set if the token is a predefined
000DB6  1               ;function.  REM and DATA statements are handled completely by the scanner. REM
000DB6  1               ;and REMARK statements cause the input to be scanned until the end of the
000DB6  1               ;current input line is located.  the cr is then scanned and returned.  DATA
000DB6  1               ;statements are similar except data is output using EMITDT.
000DB6  1               SCANNR
000DB6  1  A9 00                LDA     #0              ;clear
000DB8  1  85 4E                STA     ACCLEN          ;these
000DBA  1  85 4C                STA     HSHCDE          ;variables
000DBC  1  85 49                STA     TOKEN           ;at
000DBE  1  85 4A                STA     SUBTYP          ;start
000DC0  1  24 6E                BIT     CONT            ;test continue flag
000DC2  1  30 13                BMI     SCAN1           ;branch if set
000DC4  1  2C 1E 34             BIT     EOLSTS          ;test eol status
000DC7  1  10 08                BPL     SCAN28          ;skip if char ready
000DC9  1  20 8E 0A             JSR     GTNBLK          ;else go read
000DCC  1  A9 00                LDA     #0              ;then clear flag
000DCE  1  8D 1E 34             STA     EOLSTS
000DD1  1               SCAN28
000DD1  1  A5 4D                LDA     NXTCHR          ;else get next
000DD3  1  C9 22                CMP     #'"'            ;see if "
000DD5  1  D0 2E                BNE     SCAN5           ;branch if not
000DD7  1               ;first case is string or string continuation
000DD7  1               SCAN1
000DD7  1  A9 32                LDA     #STRING         ;get token
000DD9  1  85 49                STA     TOKEN           ;and set
000DDB  1  A9 00                LDA     #FALSE          ;and set
000DDD  1  85 6E                STA     CONT            ;CONT as false
000DDF  1               SCAN2
000DDF  1  20 15 0A             JSR     GETCHR          ;get char
000DE2  1  C9 22                CMP     #'"'            ;see if delimiter
000DE4  1  F0 11                BEQ     SCAN4           ;branch if is
000DE6  1  C9 0D                CMP     #CR             ;see if eol
000DE8  1  D0 05                BNE     SCAN3           ;branch if not
000DEA  1  A9 16                LDA     #22             ;else is unterminated string
000DEC  1  4C AB 0A             JMP     ERROR           ;do error and quit
000DEF  1               SCAN3
000DEF  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000DF2  1  24 6E                BIT     CONT            ;test for continue
000DF4  1  10 E9                BPL     SCAN2           ;loop if not
000DF6  1  60                   RTS                     ;else done
000DF7  1               SCAN4
000DF7  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000DFA  1  C9 22                CMP     #'"'            ;see if another delimiter
000DFC  1  F0 01                BEQ     *+3             ;branch if is
000DFE  1  60                   RTS                     ;else done
000DFF  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000E02  1  4C DF 0D             JMP     SCAN2           ;and loop
000E05  1               SCAN5
000E05  1  20 C3 0B             JSR     NUMRIC          ;see if number
000E08  1  D0 05                BNE     SCAN6           ;branch if is
000E0A  1  20 E3 0B             JSR     DCMLPT          ;see if decimal point
000E0D  1  F0 51                BEQ     SCAN15          ;branch if not
000E0F  1               ;is a numeric of up to IDNTSZ-1 characters
000E0F  1               SCAN6
000E0F  1  A9 31                LDA     #FLOTPT         ;get token
000E11  1  85 49                STA     TOKEN           ;and set
000E13  1  A5 4D                LDA     NXTCHR          ;get next char
000E15  1               SCAN7
000E15  1  C9 30                CMP     #'0'            ;see if leading zero
000E17  1  D0 06                BNE     SCAN8           ;branch if not
000E19  1  20 15 0A             JSR     GETCHR          ;else get next
000E1C  1  4C 15 0E             JMP     SCAN7           ;and loop to flush
000E1F  1               SCAN8
000E1F  1  20 27 0C             JSR     SPLNUM          ;spool numeric
000E22  1  20 E3 0B             JSR     DCMLPT          ;test for decimal point
000E25  1  F0 06                BEQ     SCAN9           ;branch if not
000E27  1  20 BD 0B             JSR     PUTCHR          ;insert it
000E2A  1  20 27 0C             JSR     SPLNUM          ;spool rest
000E2D  1               SCAN9
000E2D  1  20 EF 0B             JSR     CNVLWR          ;convert next to upper
000E30  1  A5 4D                LDA     NXTCHR          ;get it
000E32  1  C9 45                CMP     #'E'            ;see if e for exponent
000E34  1  D0 1B                BNE     SCAN13          ;branch if not
000E36  1  20 B7 0B             JSR     PUTGET          ;else insert and get another
000E39  1  C9 2B                CMP     #'+'            ;if a +
000E3B  1  F0 04                BEQ     SCAN10          ;go insert and get another
000E3D  1  C9 2D                CMP     #'-'            ;if not a -
000E3F  1  D0 03                BNE     SCAN11          ;skip ahead
000E41  1               SCAN10
000E41  1  20 B7 0B             JSR     PUTGET          ;insert and get
000E44  1               SCAN11
000E44  1  20 C3 0B             JSR     NUMRIC          ;test for number
000E47  1  D0 05                BNE     SCAN12          ;branch if is
000E49  1  A9 09                LDA     #9              ;else illegal floating point format
000E4B  1  20 AB 0A             JSR     ERROR           ;error
000E4E  1               SCAN12
000E4E  1  20 27 0C             JSR     SPLNUM          ;spool numbers
000E51  1               SCAN13
000E51  1  A5 4E                LDA     ACCLEN          ;get length
000E53  1  D0 08                BNE     SCAN14          ;branch if not zero
000E55  1  E6 4E                INC     ACCLEN          ;else bump
000E57  1  A9 30                LDA     #'0'            ;and insert a '0'
000E59  1  85 4F                STA     ACCUM+1         ;in ACCUM
000E5B  1  85 4C                STA     HSHCDE          ;and hashcode
000E5D  1               SCAN14
000E5D  1  4C 33 0C             JMP     SUPNCL          ;setupnextcall and return
000E60  1               SCAN15
000E60  1  20 FF 0B             JSR     LETTER          ;see if letter
000E63  1  D0 03                BNE     *+5             ;continue if is
000E65  1  4C FC 0E             JMP     SCAN26          ;else go to next section
000E68  1               ;is an identifier or may be REM, REMARK, or DATA statements. these two are
000E68  1               ;handled here
000E68  1               SCAN16
000E68  1  20 18 0C             JSR     ALPNUM          ;test for alphanumeric
000E6B  1  F0 06                BEQ     SCAN17          ;branch if not
000E6D  1  20 BD 0B             JSR     PUTCHR          ;else insert and get
000E70  1  4C 68 0E             JMP     SCAN16          ;and loop
000E73  1               SCAN17
000E73  1  A5 4D                LDA     NXTCHR          ;get next char
000E75  1  C9 24                CMP     #'$'            ;if not a $
000E77  1  D0 0A                BNE     SCAN18          ;is floating
000E79  1  A9 32                LDA     #STRING         ;else set string
000E7B  1  85 4A                STA     SUBTYP          ;as subtype
000E7D  1  20 BD 0B             JSR     PUTCHR          ;put and get
000E80  1  4C 87 0E             JMP     SCAN19          ;and continue
000E83  1               SCAN18
000E83  1  A9 31                LDA     #FLOTPT         ;set floating
000E85  1  85 4A                STA     SUBTYP          ;as subtype
000E87  1               SCAN19
000E87  1  20 53 0D             JSR     LOOKUP          ;try to match
000E8A  1  D0 20                BNE     SCAN21          ;branch if reserved
000E8C  1  A5 4F                LDA     ACCUM+1         ;check for user
000E8E  1  C9 46                CMP     #'F'            ;defined function
000E90  1  D0 13                BNE     SCAN20          ;branch if not
000E92  1  A5 50                LDA     ACCUM+2         ;same for next
000E94  1  C9 4E                CMP     #'N'            ;char in ACCUM
000E96  1  D0 0D                BNE     SCAN20
000E98  1  A5 4E                LDA     ACCLEN          ;get length
000E9A  1  C9 01                CMP     #1              ;must not be 1
000E9C  1  F0 07                BEQ     SCAN20          ;branch if is
000E9E  1  A9 36                LDA     #UDFUNC         ;ah!ah! is FN--
000EA0  1  85 49                STA     TOKEN           ;set token
000EA2  1  4C 33 0C             JMP     SUPNCL          ;exit with setupnextcall
000EA5  1               SCAN20
000EA5  1  A9 34                LDA     #IDENT          ;is identifier
000EA7  1  85 49                STA     TOKEN           ;set token
000EA9  1  4C 33 0C             JMP     SUPNCL          ;exit with setupnextcall
000EAC  1               SCAN21
000EAC  1  A5 49                LDA     TOKEN           ;is a reserved
000EAE  1  C9 00                CMP     #TREM           ;see if REM
000EB0  1  D0 12                BNE     SCAN23          ;branch if not
000EB2  1               SCAN22
000EB2  1  A5 4D                LDA     NXTCHR          ;get next
000EB4  1  C9 0D                CMP     #CR             ;see if eol
000EB6  1  D0 03                BNE     *+5             ;branch if not
000EB8  1  4C B6 0D             JMP     SCANNR          ;else loop to start
000EBB  1  20 15 0A             JSR     GETCHR          ;get char
000EBE  1  20 9A 0A             JSR     CHKCNT          ;check for continue
000EC1  1  4C B2 0E             JMP     SCAN22          ;and loop
000EC4  1               SCAN23
000EC4  1  C9 63                CMP     #TDATA          ;see if DATA
000EC6  1  F0 03                BEQ     *+5             ;branch if is
000EC8  1  4C 33 0C             JMP     SUPNCL          ;else setupnextcall and exit
000ECB  1  A9 33                LDA     #DAT            ;emit DAT opcode
000ECD  1  20 05 0D             JSR     EMITDT          ;to start
000ED0  1  A5 4D                LDA     NXTCHR          ;get next
000ED2  1  20 05 0D             JSR     EMITDT          ;emit it
000ED5  1               SCAN24
000ED5  1  20 15 0A             JSR     GETCHR          ;get another
000ED8  1  C9 0D                CMP     #CR             ;see if eol
000EDA  1  F0 0B                BEQ     SCAN25          ;branch if is
000EDC  1  20 9A 0A             JSR     CHKCNT          ;else check for continue
000EDF  1  A5 4D                LDA     NXTCHR          ;get char
000EE1  1  20 05 0D             JSR     EMITDT          ;emit it
000EE4  1  4C D5 0E             JMP     SCAN24          ;and loop
000EE7  1               SCAN25
000EE7  1  A9 2C                LDA     #','            ;now emit
000EE9  1  20 05 0D             JSR     EMITDT          ;a comma
000EEC  1  A9 00                LDA     #0              ;and a
000EEE  1  20 05 0D             JSR     EMITDT          ;zero
000EF1  1  A5 45                LDA     DATACT          ;now
000EF3  1  D0 02                BNE     *+4             ;drop
000EF5  1  C6 46                DEC     DATACT+1        ;data count
000EF7  1  C6 45                DEC     DATACT          ;by one
000EF9  1  4C B6 0D             JMP     SCANNR          ;and loop to start
000EFC  1               ;final case is a special character -- it may be continuation char in which case
000EFC  1               ;just go to next line and scan somemore
000EFC  1               SCAN26
000EFC  1  A5 4D                LDA     NXTCHR          ;get char
000EFE  1  C9 5C                CMP     #backsl         ;see if continue
000F00  1  D0 06                BNE     SCAN27          ;branch if not
000F02  1  20 9A 0A             JSR     CHKCNT          ;check it
000F05  1  4C B6 0D             JMP     SCANNR          ;and loop
000F08  1               SCAN27
000F08  1  20 97 0B             JSR     PUTACC          ;put in accum
000F0B  1  A5 4D                LDA     NXTCHR          ;get last char
000F0D  1  C9 0D                CMP     #CR             ;see if eol
000F0F  1  D0 07                BNE     SCAN29          ;not so skip
000F11  1  A9 FF                LDA     #$FF            ;set flag to read
000F13  1  8D 1E 34             STA     EOLSTS
000F16  1  30 03                BMI     SCAN30          ;then jump ahead
000F18  1               SCAN29
000F18  1  20 8E 0A             JSR     GTNBLK          ;get non blank
000F1B  1               SCAN30
000F1B  1  20 53 0D             JSR     LOOKUP          ;see if match
000F1E  1  F0 01                BEQ     *+3             ;branch if not
000F20  1  60                   RTS                     ;else done
000F21  1  A9 07                LDA     #7              ;illegal character error
000F23  1  4C AB 0A             JMP     ERROR           ;and quit
000F26  1               ;adjust base for next entry
000F26  1               NXTENT
000F26  1  A0 00                LDY     #0              ;clear index
000F28  1  8B DA A2 01          LDAINDIRECTY BASE       ;get name length
000F2C  1  B5 A7 C9 00  
000F30  1  D0 04 A2 00  
000F3E  1  18                   CLC                     ;now
000F3F  1  65 A7                ADC     BASE            ;add to current
000F41  1  85 A7                STA     BASE            ;and update
000F43  1  90 02                BCC     *+4             ;don't forget
000F45  1  E6 A8                INC     BASE+1          ;carry
000F47  1  18                   CLC                     ;now
000F48  1  A5 A7                LDA     BASE            ;add
000F4A  1  69 07                ADC     #7              ;seven for
000F4C  1  85 A7                STA     BASE            ;overhead
000F4E  1  90 02                BCC     *+4             ;to get
000F50  1  E6 A8                INC     BASE+1          ;new base
000F52  1  60                   RTS
000F53  1               ;get length of printname
000F53  1               GETLEN
000F53  1  A0 00                LDY     #0              ;clear index
000F55  1  8B DA A2 01          LDAINDIRECTY BASE       ;get length
000F59  1  B5 A7 C9 00  
000F5D  1  D0 04 A2 00  
000F6B  1  60                   RTS
000F6C  1               ;write numeric constant during pass 1
000F6C  1               EMITCN
000F6C  1  2C 16 34             BIT     PASS1           ;test for pass 1
000F6F  1  30 01                BMI     *+3             ;branch if is
000F71  1  60                   RTS                     ;else done
000F72  1  4C B6 09             JMP     EMIT            ;write byte
000F75  1               ;write two bytes of object code on disk for literals
000F75  1               GENTWO
000F75  1  48                   PHA                     ;save low
000F76  1  98                   TYA                     ;get high
000F77  1  20 F6 0C             JSR     GENERT          ;write it
000F7A  1  68                   PLA                     ;get low
000F7B  1  4C F6 0C             JMP     GENERT          ;do it
000F7E  1               ;
000F7E  1               LITERL
000F7E  1  48                   PHA                     ;save low
000F7F  1  98                   TYA                     ;get high
000F80  1  09 80                ORA     #$80            ;set msb
000F82  1  A8                   TAY                     ;back to Y
000F83  1  68                   PLA                     ;get low
000F84  1  4C 75 0F             JMP     GENTWO          ;send it
000F87  1               ;
000F87  1               LITLOD
000F87  1  48                   PHA                     ;save low
000F88  1  98                   TYA                     ;get high
000F89  1  09 C0                ORA     #$C0            ;or with mask
000F8B  1  A8                   TAY                     ;back to Y
000F8C  1  68                   PLA                     ;get low
000F8D  1  4C 75 0F             JMP     GENTWO          ;write it
000F90  1               ;
000F90  1               LINENU
000F90  1  2C 1A 34             BIT     DEBUGL          ;test debug flag
000F93  1  30 01                BMI     *+3             ;branch if set
000F95  1  60                   RTS                     ;else do nothing
000F96  1  A5 70                LDA     LINENO          ;get low
000F98  1  A4 71                LDY     LINENO+1        ;and high number
000F9A  1  20 7E 0F             JSR     LITERL          ;send as literal
000F9D  1  A9 5F                LDA     #BOL            ;then send BOL
000F9F  1  4C F6 0C             JMP     GENERT          ;opcode
000FA2  1               ;fill hashtable with 0's and initialize pointer to top of symbol table
000FA2  1               INSYMT
000FA2  1  2C 16 34             BIT     PASS1           ;see if pass 1
000FA5  1  10 14                BPL     INSYM1          ;branch if not
000FA7  1  A2 7F                LDX     #HSHTSZ*2-1     ;get number to clear
000FA9  1  A9 00                LDA     #0              ;then value
000FAB  1               INSYM0
000FAB  1  9D 50 34             STA     HSHTBL,X        ;store it
000FAE  1  CA                   DEX                     ;drop count
000FAF  1  E0 FF                CPX     #255            ;see if wrap
000FB1  1  D0 F8                BNE     INSYM0          ;loop if not
000FB3  1  A9 D7                LDA     #<MEMORY        ;get memory
000FB5  1  A0 37                LDY     #>MEMORY        ;start
000FB7  1  85 AA                STA     SBTBL           ;and set
000FB9  1  84 AB                STY     SBTBL+1         ;table start
000FBB  1               INSYM1
000FBB  1  AD 04 01             LDA     PEM+1           ;get limit
000FBE  1  AC 05 01             LDY     PEM+2           ;of memory
000FC1  1  38                   SEC                     ;drop
000FC2  1  E9 02                SBC     #2              ;two
000FC4  1  85 A5                STA     SBTTOP          ;to get
000FC6  1  85 B9                STA     NXSTPT          ;top starting
000FC8  1  B0 01                BCS     *+3             ;branch if no borrow
000FCA  1  88                   DEY                     ;else drop Y
000FCB  1  84 A6                STY     SBTTOP+1        ;set high
000FCD  1  84 BA                STY     NXSTPT+1        ;and set
000FCF  1  A9 00                LDA     #0              ;clear A
000FD1  1  A0 01                LDY     #1              ;set index to 1
000FD3  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put in memory
000FD7  1  01 B5 B9 C9  
000FDB  1  00 D0 04 A2  
000FE9  1  60                   RTS
000FEA  1               ;
000FEA  1               GETHSH
000FEA  1  A0 00                LDY     #0              ;get
000FEC  1  8B DA A2 01          LDAINDIRECTY BASE       ;PTR
000FF0  1  B5 A7 C9 00  
000FF4  1  D0 04 A2 00  
001002  1  85 BC                STA     TMPPTR          ;and save
001004  1  84 BB                STY     TMPHSH          ;clear internal hash
001006  1  A5 A7                LDA     BASE            ;get
001008  1  A4 A8                LDY     BASE+1          ;base
00100A  1  18                   CLC                     ;now
00100B  1  69 02                ADC     #2              ;add 2
00100D  1  85 AC                STA     APTADD          ;and save
00100F  1  90 01                BCC     *+3             ;branch if
001011  1  C8                   INY                     ;no carry
001012  1  84 AD                STY     APTADD+1        ;save high
001014  1  A0 01                LDY     #1              ;set starting index
001016  1               GETHS0
001016  1  C4 BC                CPY     TMPPTR          ;compare to limit
001018  1  F0 05                BEQ     GETHS1          ;continue if equal
00101A  1  90 03                BCC     GETHS1          ;branch if less
00101C  1  A5 BB                LDA     TMPHSH          ;else get HASH
00101E  1  60                   RTS                     ;and quit
00101F  1               GETHS1
00101F  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get value
001023  1  B5 AC C9 00  
001027  1  D0 04 A2 00  
001035  1  18                   CLC                     ;now add
001036  1  65 BB                ADC     TMPHSH          ;in old hash
001038  1  29 3F                AND     #HSHMSK         ;and mask
00103A  1  85 BB                STA     TMPHSH          ;and save
00103C  1  C8                   INY                     ;bump loop index
00103D  1  4C 16 10             JMP     GETHS0          ;then loop
001040  1               ;
001040  1               HSOSYM
001040  1  A5 B7                LDA     SYMHSH          ;get symhsh
001042  1  0A                   ASL     A               ;mult by two
001043  1  AA                   TAX                     ;make index
001044  1  BD 50 34             LDA     HSHTBL,X        ;get value
001047  1  BC 51 34             LDY     HSHTBL+1,X      ;in table
00104A  1  60                   RTS
00104B  1               ;
00104B  1               SETLNK
00104B  1  A6 A7                LDX     BASE            ;get
00104D  1  A4 A8                LDY     BASE+1          ;base
00104F  1  E8                   INX                     ;bump
001050  1  86 AC                STX     APTADD          ;by
001052  1  D0 01                BNE     *+3             ;one
001054  1  C8                   INY                     ;and
001055  1  84 AD                STY     APTADD+1        ;save
001057  1  60                   RTS
001058  1               ;set pointer for addr reference with offset in A
001058  1               SETADP
001058  1  A0 00                LDY     #0              ;clear index
00105A  1  18                   CLC                     ;and carry
00105B  1  8B 48 DA A2          ADCINDIRECTY BASE       ;add PTR
00105F  1  01 B5 A7 C9  
001063  1  00 D0 04 A2  
001074  1  90 01                BCC     *+3             ;branch if no carry
001076  1  C8                   INY                     ;else set Y to 1
001077  1  18                   CLC                     ;clear carry
001078  1  65 A7                ADC     BASE            ;add base
00107A  1  85 AC                STA     APTADD          ;to low
00107C  1  98                   TYA                     ;now add
00107D  1  65 A8                ADC     BASE+1          ;with carry to high
00107F  1  85 AD                STA     APTADD+1        ;and save
001081  1  60                   RTS
001082  1               ;check to see if additional SBTBL entry will overflow limits of memory. if
001082  1               ;so then abort else return. at entry A contains amount to be added (COUNT)
001082  1               LIMITS
001082  1  18                   CLC                     ;add count
001083  1  65 AA                ADC     SBTBL           ;to start
001085  1  A4 AB                LDY     SBTBL+1         ;with
001087  1  90 01                BCC     *+3             ;carry to
001089  1  C8                   INY                     ;high
00108A  1  C5 A5                CMP     SBTTOP          ;compare to limit
00108C  1  98                   TYA                     ;including
00108D  1  E5 A6                SBC     SBTTOP+1        ;high
00108F  1  B0 01                BCS     *+3             ;whoops! no borrow
001091  1  60                   RTS                     ;else ok
001092  1  A9 FF                LDA     #TRUE           ;set to
001094  1  8D 17 34             STA     PASS2           ;pass 2
001097  1  A9 13                LDA     #19             ;symbol table error
001099  1  20 AB 0A             JSR     ERROR           ;send it
00109C  1  4C 00 01             JMP     BOOT            ;and abort
00109F  1               ;set the address field at location LOC in AY and resolved bit
00109F  1               SETRSV
00109F  1  48                   PHA                     ;save
0010A0  1  98                   TYA                     ;A
0010A1  1  48                   PHA                     ;and Y
0010A2  1  A9 04                LDA     #4              ;set offset
0010A4  1  20 58 10             JSR     SETADP          ;of four
0010A7  1  A0 01                LDY     #1              ;set index to 1
0010A9  1  68                   PLA                     ;get high
0010AA  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and save
0010AE  1  01 B5 AC C9  
0010B2  1  00 D0 04 A2  
0010C0  1  88                   DEY                     ;drop Y to 0
0010C1  1  68                   PLA                     ;get low
0010C2  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
0010C6  1  01 B5 AC C9  
0010CA  1  00 D0 04 A2  
0010D8  1  A5 AC                LDA     APTADD          ;now
0010DA  1  D0 02                BNE     *+4             ;drop
0010DC  1  C6 AD                DEC     APTADD+1        ;pointer
0010DE  1  C6 AC                DEC     APTADD          ;by one
0010E0  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now set
0010E4  1  B5 AC C9 00  
0010E8  1  D0 04 A2 00  
0010F6  1  09 80                ORA     #$80            ;resolved
0010F8  1  8B DA 48 A2          STAINDIRECTY APTADD     ;bit
0010FC  1  01 B5 AC C9  
001100  1  00 D0 04 A2  
00110E  1  60                   RTS
00110F  1               ;return type of variable
00110F  1               GETTYP
00110F  1  A9 03                LDA     #3              ;build
001111  1  20 58 10             JSR     SETADP          ;new indirect
001114  1  A0 00                LDY     #0              ;clear index
001116  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get
00111A  1  B5 AC C9 00  
00111E  1  D0 04 A2 00  
00112C  1  29 7F                AND     #$7F            ;mask out set bit
00112E  1  60                   RTS
00112F  1               ;set type of variable to A and preserve resolved bit
00112F  1               SETTYP
00112F  1  48                   PHA                     ;save type
001130  1  A9 03                LDA     #3              ;calculate
001132  1  20 58 10             JSR     SETADP          ;new pointer
001135  1  A0 00                LDY     #0              ;clear index
001137  1  68                   PLA                     ;get type
001138  1  8B 48 DA A2          ORAINDIRECTY APTADD     ;or with contents
00113C  1  01 B5 AC C9  
001140  1  00 D0 04 A2  
001151  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
001155  1  01 B5 AC C9  
001159  1  00 D0 04 A2  
001167  1  60                   RTS
001168  1               ;get resolved bit A:=TRUE iff bit=1 else A:=FALSE
001168  1               GETRES
001168  1  A9 03                LDA     #3              ;build
00116A  1  20 58 10             JSR     SETADP          ;pointer
00116D  1  A0 00                LDY     #0              ;clear index
00116F  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get byte
001173  1  B5 AC C9 00  
001177  1  D0 04 A2 00  
001185  1  30 03                BMI     *+5             ;branch if set
001187  1  A9 00                LDA     #FALSE          ;else set
001189  1  60                   RTS                     ;false
00118A  1  A9 FF                LDA     #TRUE           ;was set
00118C  1  60                   RTS
00118D  1               ;get the address of the printname location in AY
00118D  1               GETADR
00118D  1  A9 04                LDA     #4              ;build
00118F  1  20 58 10             JSR     SETADP          ;pointer
001192  1  A0 00                LDY     #0              ;clear index
001194  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now get low
001198  1  B5 AC C9 00  
00119C  1  D0 04 A2 00  
0011AA  1  48                   PHA                     ;save
0011AB  1  C8                   INY                     ;set Y to 1
0011AC  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
0011B0  1  B5 AC C9 00  
0011B4  1  D0 04 A2 00  
0011C2  1  A8                   TAY                     ;move to Y
0011C3  1  68                   PLA                     ;get low
0011C4  1  60                   RTS
0011C5  1               ;check to see if printname located at address in PRNTNM is in SBTBL. if is
0011C5  1               ;then A:=TRUE and BASE:=address else A:=FALSE
0011C5  1               SLOOKU
0011C5  1  20 40 10             JSR     HSOSYM          ;find base
0011C8  1               SLOOKX
0011C8  1  85 A7                STA     BASE            ;and
0011CA  1  84 A8                STY     BASE+1          ;save
0011CC  1               SLOOK0
0011CC  1  A5 A7                LDA     BASE            ;see if
0011CE  1  05 A8                ORA     BASE+1          ;base = 0
0011D0  1  D0 03 4C 7C          LBEQ     SLOOFL         ;false if is
0011D4  1  12           
0011D5  1  A0 00                LDY     #0              ;clear index
0011D7  1  8B DA A2 01          LDAINDIRECTY BASE       ;get PTR
0011DB  1  B5 A7 C9 00  
0011DF  1  D0 04 A2 00  
0011ED  1  85 BD                STA     LEN             ;save as length
0011EF  1  8B 48 DA A2          CMPINDIRECTY PRNTNM     ;compare
0011F3  1  01 B5 B5 C9  
0011F7  1  00 D0 04 A2  
001207  1  D0 3B                BNE     SLOOK2          ;branch if different
001209  1               SLOOK1
001209  1  A4 BD                LDY     LEN             ;get length
00120B  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
00120F  1  B5 B5 C9 00  
001213  1  D0 04 A2 00  
001221  1  C8                   INY                     ;bump index
001222  1  C8                   INY                     ;by two
001223  1  8B 48 DA A2          CMPINDIRECTY BASE       ;compare to entry
001227  1  01 B5 A7 C9  
00122B  1  00 D0 04 A2  
00123B  1  D0 07                BNE     SLOOK2          ;branch if different
00123D  1  C6 BD                DEC     LEN             ;drop length
00123F  1  D0 C8                BNE     SLOOK1          ;loop for more
001241  1  A9 FF                LDA     #TRUE           ;else say true
001243  1  60                   RTS
001244  1               SLOOK2
001244  1  20 4B 10             JSR     SETLNK          ;set link
001247  1  A0 00                LDY     #0              ;clear index
001249  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
00124D  1  B5 AC C9 00  
001251  1  D0 04 A2 00  
00125F  1  48                   PHA                     ;save it
001260  1  C8                   INY                     ;set y to 1
001261  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
001265  1  B5 AC C9 00  
001269  1  D0 04 A2 00  
001277  1  A8                   TAY                     ;move to Y
001278  1  68                   PLA                     ;get low
001279  1  4C C8 11             JMP     SLOOKX          ;and loop
00127C  1               SLOOFL
00127C  1  A9 00                LDA     #FALSE          ;was not
00127E  1  60                   RTS                     ;found
00127F  1               ;enter token reference by PRNTNM and SYMHSH into next available location in the
00127F  1               ;symbol table.  set BASE to beginning of this entry and increment SBTBL. check
00127F  1               ;for symbol table full
00127F  1               ENTER
00127F  1  A0 00                LDY     #0              ;clear index
001281  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get length
001285  1  B5 B5 C9 00  
001289  1  D0 04 A2 00  
001297  1  18                   CLC                     ;now
001298  1  69 07                ADC     #7              ;add seven
00129A  1  48                   PHA                     ;save on stack
00129B  1  20 82 10             JSR     LIMITS          ;test limits
00129E  1  A5 AA                LDA     SBTBL           ;update
0012A0  1  A4 AB                LDY     SBTBL+1         ;base
0012A2  1  85 A7                STA     BASE
0012A4  1  84 A8                STY     BASE+1
0012A6  1  A0 00                LDY     #0              ;get
0012A8  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;length
0012AC  1  B5 B5 C9 00  
0012B0  1  D0 04 A2 00  
0012BE  1  8B DA 48 A2          STAINDIRECTY BASE       ;move to table
0012C2  1  01 B5 A7 C9  
0012C6  1  00 D0 04 A2  
0012D4  1  AA                   TAX                     ;make a counter
0012D5  1  F0 33                BEQ     ENTER1          ;done if zero
0012D7  1  C8                   INY                     ;start with Y=1
0012D8  1               ENTER0
0012D8  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
0012DC  1  B5 B5 C9 00  
0012E0  1  D0 04 A2 00  
0012EE  1  C8                   INY                     ;bump index
0012EF  1  C8                   INY                     ;by two
0012F0  1  8B DA 48 A2          STAINDIRECTY SBTBL      ;insert
0012F4  1  01 B5 AA C9  
0012F8  1  00 D0 04 A2  
001306  1  88                   DEY                     ;drop y by one
001307  1  CA                   DEX                     ;drop count
001308  1  D0 CE                BNE     ENTER0          ;loop if more
00130A  1               ENTER1
00130A  1  A9 03                LDA     #3              ;clear resolve bit
00130C  1  20 58 10             JSR     SETADP          ;by getting pointer
00130F  1  A0 00                LDY     #0              ;clear index
001311  1  98                   TYA                     ;and A
001312  1  8B DA 48 A2          STAINDIRECTY APTADD     ;insert
001316  1  01 B5 AC C9  
00131A  1  00 D0 04 A2  
001328  1  20 4B 10             JSR     SETLNK          ;set link
00132B  1  20 40 10             JSR     HSOSYM          ;find address
00132E  1  48                   PHA                     ;save low on stack
00132F  1  98                   TYA                     ;high to A
001330  1  A0 01                LDY     #1              ;do high
001332  1  8B DA 48 A2          STAINDIRECTY APTADD     ;first
001336  1  01 B5 AC C9  
00133A  1  00 D0 04 A2  
001348  1  88                   DEY                     ;drop Y
001349  1  68                   PLA                     ;get low
00134A  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and set
00134E  1  01 B5 AC C9  
001352  1  00 D0 04 A2  
001360  1  A5 B7                LDA     SYMHSH          ;get hash
001362  1  0A                   ASL     A               ;mult by two
001363  1  AA                   TAX                     ;make index
001364  1  A5 A7                LDA     BASE            ;get
001366  1  9D 50 34             STA     HSHTBL,X        ;and move
001369  1  A5 A8                LDA     BASE+1          ;to
00136B  1  9D 51 34             STA     HSHTBL+1,X      ;table
00136E  1  68                   PLA                     ;get new length
00136F  1  18                   CLC                     ;now
001370  1  65 AA                ADC     SBTBL           ;to start
001372  1  85 AA                STA     SBTBL           ;to get
001374  1  90 02                BCC     *+4             ;new
001376  1  E6 AB                INC     SBTBL+1         ;table address
001378  1  60                   RTS
001379  1               ;insert subtype in SBTBL
001379  1               SETSUB
001379  1  48                   PHA                     ;save code
00137A  1  A9 06                LDA     #6              ;offset pointer
00137C  1  20 58 10             JSR     SETADP          ;get pointer
00137F  1  A0 00                LDY     #0              ;clear index
001381  1  68                   PLA                     ;get code
001382  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save
001386  1  01 B5 AC C9  
00138A  1  00 D0 04 A2  
001398  1  60                   RTS
001399  1               ;return the subtype
001399  1               GETSUB
001399  1  A9 06                LDA     #6              ;build
00139B  1  20 58 10             JSR     SETADP          ;pointer
00139E  1  A0 00                LDY     #0              ;clear pointer
0013A0  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get subtype
0013A4  1  B5 AC C9 00  
0013A8  1  D0 04 A2 00  
0013B6  1  60                   RTS
0013B7  1               ;
0013B7  1               UNLINK
0013B7  1  20 0F 11             JSR     GETTYP          ;get type
0013BA  1  85 BE                STA     NUMPRM          ;save it
0013BC  1  A9 01                LDA     #1              ;set index
0013BE  1  85 BF                STA     LINKI           ;to one
0013C0  1               UNLNK0
0013C0  1  A5 BE                LDA     NUMPRM          ;compare limit
0013C2  1  C5 BF                CMP     LINKI           ;to count
0013C4  1  B0 01                BCS     *+3             ;continue if ok
0013C6  1  60                   RTS                     ;else done
0013C7  1  20 26 0F             JSR     NXTENT          ;get next
0013CA  1  20 EA 0F             JSR     GETHSH          ;and hash
0013CD  1  0A                   ASL     A               ;mult
0013CE  1  18                   CLC                     ;by two
0013CF  1  69 50                ADC     #<HSHTBL        ;and add
0013D1  1  85 C0                STA     TMPADR          ;hash table start
0013D3  1  A0 34                LDY     #>HSHTBL        ;get high
0013D5  1  90 01                BCC     *+3             ;with carry
0013D7  1  C8                   INY                     ;bump
0013D8  1  84 C1                STY     TMPADR+1        ;and save
0013DA  1               UNLNK1
0013DA  1  A0 00                LDY     #0              ;clear index
0013DC  1  A5 A7                LDA     BASE            ;compare base low
0013DE  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;to byte
0013E2  1  01 B5 C0 C9  
0013E6  1  00 D0 04 A2  
0013F6  1  D0 1D                BNE     UNLNK2          ;branch if different
0013F8  1  C8                   INY                     ;set y to 1
0013F9  1  A5 A8                LDA     BASE+1          ;do same
0013FB  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;for high
0013FF  1  01 B5 C0 C9  
001403  1  00 D0 04 A2  
001413  1  F0 3E                BEQ     UNLNK3          ;branch if all same
001415  1               UNLNK2
001415  1  A0 00                LDY     #0              ;y back to zero
001417  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get low
00141B  1  B5 C0 C9 00  
00141F  1  D0 04 A2 00  
00142D  1  48                   PHA                     ;save it
00142E  1  C8                   INY                     ;bump index
00142F  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get high
001433  1  B5 C0 C9 00  
001437  1  D0 04 A2 00  
001445  1  85 C1                STA     TMPADR+1        ;change address
001447  1  68                   PLA                     ;get low
001448  1  85 C0                STA     TMPADR          ;save it
00144A  1  E6 C0                INC     TMPADR
00144C  1  D0 8C                BNE     UNLNK1
00144E  1  E6 C1                INC     TMPADR+1
001450  1  4C DA 13             JMP     UNLNK1          ;and loop
001453  1               UNLNK3
001453  1  20 4B 10             JSR     SETLNK          ;set link
001456  1  A0 00                LDY     #0              ;clear index
001458  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
00145C  1  B5 AC C9 00  
001460  1  D0 04 A2 00  
00146E  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;and move
001472  1  01 B5 C0 C9  
001476  1  00 D0 04 A2  
001484  1  C8                   INY                     ;now
001485  1  8B DA A2 01          LDAINDIRECTY APTADD     ;same
001489  1  B5 AC C9 00  
00148D  1  D0 04 A2 00  
00149B  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;for high
00149F  1  01 B5 C0 C9  
0014A3  1  00 D0 04 A2  
0014B1  1  E6 BF                INC     LINKI           ;bump loop index
0014B3  1  4C C0 13             JMP     UNLNK0          ;and loop
0014B6  1               ;
0014B6  1               RELINK
0014B6  1  20 0F 11             JSR     GETTYP          ;get type
0014B9  1  85 BE                STA     NUMPRM          ;save it
0014BB  1  A9 01                LDA     #1              ;set count
0014BD  1  85 BF                STA     LINKI           ;to one
0014BF  1               RELNK0
0014BF  1  A5 BE                LDA     NUMPRM          ;get limit and
0014C1  1  C5 BF                CMP     LINKI           ;compare to count
0014C3  1  B0 01                BCS     *+3             ;branch if >=
0014C5  1  60                   RTS                     ;else done
0014C6  1  20 26 0F             JSR     NXTENT          ;do next entry
0014C9  1  A5 A7                LDA     BASE            ;now set
0014CB  1  A4 A8                LDY     BASE+1          ;temp
0014CD  1  85 C0                STA     TMPADR
0014CF  1  E6 C0                INC     TMPADR          ;bump low
0014D1  1  D0 01                BNE     *+3
0014D3  1  C8                   INY
0014D4  1  84 C1                STY     TMPADR+1        ;save high
0014D6  1  20 EA 0F             JSR     GETHSH          ;get hash
0014D9  1  0A                   ASL     A               ;mult by two
0014DA  1  AA                   TAX                     ;make index
0014DB  1  A0 00                LDY     #0              ;clear Y
0014DD  1  BD 50 34             LDA     HSHTBL,X        ;get low
0014E0  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014E4  1  01 B5 C0 C9  
0014E8  1  00 D0 04 A2  
0014F6  1  C8                   INY                     ;now high
0014F7  1  BD 51 34             LDA     HSHTBL+1,X      ;get it
0014FA  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014FE  1  01 B5 C0 C9  
001502  1  00 D0 04 A2  
001510  1  20 EA 0F             JSR     GETHSH          ;gethash
001513  1  0A                   ASL     A
001514  1  AA                   TAX
001515  1  A5 A7                LDA     BASE            ;now get
001517  1  9D 50 34             STA     HSHTBL,X        ;and put
00151A  1  A5 A8                LDA     BASE+1          ;new base
00151C  1  9D 51 34             STA     HSHTBL+1,X      ;in table
00151F  1  E6 BF                INC     LINKI           ;bump loop index
001521  1  4C BF 14             JMP     RELNK0          ;and loop
001524  1               ;initialize SYNTHE
001524  1               ;data definitions for initialization
001524  1               CONZER
001524  1  01 30                .BYTE   1,"0"
001526  1               CONONE
001526  1  01 31                .BYTE   1,"1"
001528  1               INSYN
001528  1  A9 00                LDA     #0              ;first
00152A  1  85 B2                STA     CODESI          ;clear
00152C  1  85 B3                STA     CODESI+1        ;variables
00152E  1  85 45                STA     DATACT
001530  1  85 46                STA     DATACT+1
001532  1  8D 74 36             STA     ONSP
001535  1  8D 4F 34             STA     IFLABL
001538  1  85 B1                STA     FDACT+1         ;set fda
00153A  1  A9 01                LDA     #1              ;count to
00153C  1  85 B0                STA     FDACT           ;one
00153E  1  A9 FF                LDA     #$FF            ;set prt
001540  1  85 AE                STA     PRTCT           ;count
001542  1  85 AF                STA     PRTCT+1         ;to -1
001544  1  20 84 09             JSR     SETFLG          ;set flags
001547  1  2C 16 34             BIT     PASS1           ;see if pass 1
00154A  1  30 01                BMI     *+3             ;branch if is
00154C  1  60                   RTS                     ;else done
00154D  1  20 59 09             JSR     SUPINT          ;setup int file
001550  1  A9 26                LDA     #<CONONE        ;initialize
001552  1  A0 15                LDY     #>CONONE        ;printname
001554  1  85 B5                STA     PRNTNM          ;pointer
001556  1  84 B6                STY     PRNTNM+1
001558  1  A9 31                LDA     #'1'            ;then
00155A  1  85 B7                STA     SYMHSH          ;symbol hash
00155C  1  20 7F 12             JSR     ENTER           ;put in table
00155F  1  A9 31                LDA     #'1'            ;emit
001561  1  20 6C 0F             JSR     EMITCN          ;emit
001564  1  A9 24                LDA     #'$'            ;do a $
001566  1  20 6C 0F             JSR     EMITCN
001569  1  A9 00                LDA     #0              ;constant 1
00156B  1  A8                   TAY                     ;is at fda position 0
00156C  1  20 9F 10             JSR     SETRSV          ;set
00156F  1  A9 04                LDA     #CONST          ;set type
001571  1  20 2F 11             JSR     SETTYP          ;as constant
001574  1  A9 24                LDA     #<CONZER        ;now
001576  1  A0 15                LDY     #>CONZER        ;point
001578  1  85 B5                STA     PRNTNM          ;to
00157A  1  84 B6                STY     PRNTNM+1        ;zero
00157C  1  A9 30                LDA     #'0'            ;set hash
00157E  1  85 B7                STA     SYMHSH          ;to '0'
001580  1  20 7F 12             JSR     ENTER           ;enter it
001583  1  A9 30                LDA     #'0'            ;now
001585  1  20 6C 0F             JSR     EMITCN          ;output it
001588  1  A9 24                LDA     #'$'            ;do $
00158A  1  20 6C 0F             JSR     EMITCN
00158D  1  A9 01                LDA     #1              ;set address
00158F  1  A0 00                LDY     #0
001591  1  20 9F 10             JSR     SETRSV
001594  1  A9 04                LDA     #CONST          ;and type = const
001596  1  4C 2F 11             JMP     SETTYP          ;then exit
001599  1               ;calculate var(a)+.varc
001599  1               CALVRC
001599  1  AA                   TAX                     ;make index
00159A  1  BD F0 34             LDA     VAR,X           ;get var contents
00159D  1  18                   CLC                     ;now add
00159E  1  69 10                ADC     #<VARC          ;varc start
0015A0  1  A0 36                LDY     #>VARC          ;with carry
0015A2  1  90 01                BCC     *+3
0015A4  1  C8                   INY
0015A5  1  60                   RTS
0015A6  1               ;setlookup
0015A6  1               STLKUP
0015A6  1  48                   PHA                     ;save param
0015A7  1  20 99 15             JSR     CALVRC          ;calculate varc
0015AA  1  85 B5                STA     PRNTNM          ;save as printname
0015AC  1  84 B6                STY     PRNTNM+1        ;position
0015AE  1  68                   PLA                     ;get param
0015AF  1  AA                   TAX                     ;make index
0015B0  1  BD D0 34             LDA     HASH,X          ;get entry
0015B3  1  85 B7                STA     SYMHSH          ;and set symbols
0015B5  1  60                   RTS
0015B6  1               ;lookup$only
0015B6  1               LKONLY
0015B6  1  20 A6 15             JSR     STLKUP          ;set up
0015B9  1  4C C5 11             JMP     SLOOKU          ;try to lookup
0015BC  1               ;normal$lookup
0015BC  1               NRMLKU
0015BC  1  20 B6 15             JSR     LKONLY          ;call lookup$only
0015BF  1  F0 01                BEQ     *+3             ;if false
0015C1  1  60                   RTS                     ;else done
0015C2  1  20 7F 12             JSR     ENTER           ;enter in table
0015C5  1  A9 00                LDA     #FALSE          ;then done
0015C7  1  60                   RTS
0015C8  1               ;count size of the prt and return with count in AY
0015C8  1               CNTPRT
0015C8  1  E6 AE                INC     PRTCT           ;bump
0015CA  1  D0 02                BNE     *+4
0015CC  1  E6 AF                INC     PRTCT+1
0015CE  1  A5 AE                LDA     PRTCT           ;and get
0015D0  1  A4 AF                LDY     PRTCT+1
0015D2  1  60                   RTS
0015D3  1               ;setifname
0015D3  1               SETIFN
0015D3  1  A9 4D                LDA     #<IFLBLN        ;point to printname
0015D5  1  A0 34                LDY     #>IFLBLN
0015D7  1  85 B5                STA     PRNTNM
0015D9  1  84 B6                STY     PRNTNM+1
0015DB  1  AD 4F 34             LDA     IFLABL          ;set symhash
0015DE  1  29 3F                AND     #HSHMSK
0015E0  1  85 B7                STA     SYMHSH
0015E2  1  60                   RTS
0015E3  1               ;enter$compiler$label(a)
0015E3  1               ENCMLB
0015E3  1  2C 16 34             BIT     PASS1           ;test for pass 1
0015E6  1  30 01                BMI     *+3             ;branch if is
0015E8  1  60                   RTS
0015E9  1  48                   PHA                     ;save parameter
0015EA  1  20 D3 15             JSR     SETIFN          ;call setifname
0015ED  1  20 7F 12             JSR     ENTER           ;call enter
0015F0  1  68                   PLA                     ;get param
0015F1  1  18                   CLC                     ;add to codesize
0015F2  1  65 B2                ADC     CODESI
0015F4  1  A4 B3                LDY     CODESI+1
0015F6  1  90 01                BCC     *+3
0015F8  1  C8                   INY                     ;with carry
0015F9  1  4C 9F 10             JMP     SETRSV          ;call setaddr(codesize+a)
0015FC  1               ;set$compiler$label
0015FC  1               STCMLB
0015FC  1  EE 4F 34             INC     IFLABL          ;bump iflable
0015FF  1  20 D3 15             JSR     SETIFN          ;call setifname
001602  1  4C C5 11             JMP     SLOOKU          ;call "s"lookup
001605  1               ;compiler$label
001605  1               COMLBL
001605  1  20 FC 15             JSR     STCMLB          ;call set$compiler$label
001608  1  20 8D 11             JSR     GETADR
00160B  1  4C 75 0F             JMP     GENTWO          ;call gen$two(getaddr)
00160E  1               ;check for mp and sp both floating point
00160E  1               CHKTY1
00160E  1  A5 85                LDA     STYPMP          ;get stypemp
001610  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
001612  1  D0 09                BNE     DOC1MF          ;error if not
001614  1  A5 83                LDA     STYPSP          ;get stypesp
001616  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
001618  1  D0 03                BNE     DOC1MF          ;error if not
00161A  1  A9 FF                LDA     #TRUE
00161C  1  60                   RTS
00161D  1               DOC1MF
00161D  1  20 48 16             JSR     MFERR           ;error
001620  1  A9 00                LDA     #FALSE
001622  1  60                   RTS
001623  1               ;check mp and sp both same type
001623  1               CHKTY2
001623  1  A5 83                LDA     STYPSP          ;get stypesp
001625  1  C5 85                CMP     STYPMP          ;see if stypemp same
001627  1  D0 03                BNE     *+5             ;error if not
001629  1  A9 FF                LDA     #TRUE
00162B  1  60                   RTS
00162C  1  A9 0D                LDA     #13             ;mixed mode error
00162E  1  20 AB 0A             JSR     ERROR
001631  1  A9 00                LDA     #FALSE
001633  1  60                   RTS
001634  1               ;chktyp3
001634  1               CHKTY3
001634  1  A5 83                LDA     STYPSP          ;get stypesp
001636  1  20 D0 0C             JSR     STSTMP          ;call setstypemp(stypesp)
001639  1  A5 83                LDA     STYPSP          ;get stypesp
00163B  1  C9 31                CMP     #FLOTPT         ;see if floating
00163D  1  D0 03                BNE     *+5             ;error if not
00163F  1  A9 FF                LDA     #TRUE
001641  1  60                   RTS
001642  1  20 48 16             JSR     MFERR           ;must be floating error
001645  1  A9 00                LDA     #FALSE
001647  1  60                   RTS
001648  1               ;must be floating point error
001648  1               MFERR
001648  1  A9 0C                LDA     #12
00164A  1  4C AB 0A             JMP     ERROR
00164D  1               ;chktyp4
00164D  1               CHKTY4
00164D  1  A5 84                LDA     STYPM1          ;get stypemp1
00164F  1  C9 32                CMP     #STRING         ;see if string
001651  1  D0 03                BNE     *+5             ;ok if not
001653  1  20 48 16             JSR     MFERR           ;else must be floating error
001656  1  A9 5B                LDA     #RON
001658  1  4C F6 0C             JMP     GENERT          ;call generate(ron)
00165B  1               ;chktyp5
00165B  1               CHKTY5
00165B  1  20 4D 16             JSR     CHKTY4          ;call chktyp4
00165E  1  E6 82                INC     TYPEMP          ;bump typemp
001660  1  A5 82                LDA     TYPEMP
001662  1  4C D6 0C             JMP     STTYMP          ;call settypemp(typemp:=typemp+1)
001665  1               ;subcalc
001665  1               SUBCAL
001665  1  A5 80                LDA     TYPESP          ;get type
001667  1  20 79 13             JSR     SETSUB          ;call setsubtype(typesp)
00166A  1  A9 20                LDA     #ROW
00166C  1  20 F6 0C             JSR     GENERT          ;call generate(row)
00166F  1  A5 80                LDA     TYPESP
001671  1  20 F6 0C             JSR     GENERT          ;call generate(typesp)
001674  1  A9 14                LDA     #STD
001676  1  4C F6 0C             JMP     GENERT          ;call generate(std)
001679  1               ;gen$store
001679  1               GENSTR
001679  1  A5 84                LDA     STYPM1          ;get stypemp1
00167B  1  C9 31                CMP     #FLOTPT         ;see if floating
00167D  1  D0 05                BNE     *+7             ;branch if not
00167F  1  A9 14                LDA     #STD
001681  1  4C F6 0C             JMP     GENERT          ;call generate(std)
001684  1  A9 1B                LDA     #STS
001686  1  4C F6 0C             JMP     GENERT          ;call generate(sts)
001689  1               ;setup$input
001689  1               SEINPU
001689  1  A9 FF                LDA     #TRUE
00168B  1  85 47                STA     INPSTM          ;inputstmt=true
00168D  1  A9 3B                LDA     #RCN
00168F  1  4C F6 0C             JMP     GENERT          ;call generate(rcn)
001692  1               ;gen$read(a,y)
001692  1               GENRDE
001692  1  A6 83                LDX     STYPSP          ;get stypesp
001694  1  E0 32                CPX     #STRING         ;see if string
001696  1  D0 08                BNE     *+10            ;branch if not
001698  1  20 F6 0C             JSR     GENERT          ;call generate(i)
00169B  1  A9 1B                LDA     #STS
00169D  1  4C F6 0C             JMP     GENERT          ;call generate(sts)
0016A0  1  98                   TYA
0016A1  1  20 F6 0C             JSR     GENERT          ;call generate(y)
0016A4  1  A9 14                LDA     #STD
0016A6  1  4C F6 0C             JMP     GENERT          ;call generate(std)
0016A9  1               ;get$field
0016A9  1               GETFLD
0016A9  1  A5 80                LDA     TYPESP          ;get typesp
0016AB  1  C9 00                CMP     #SIMVAR         ;see if simple variable
0016AD  1  D0 07                BNE     *+9             ;skip if not
0016AF  1  A5 86                LDA     SYMLSP
0016B1  1  A4 87                LDY     SYMLSP+1
0016B3  1  20 7E 0F             JSR     LITERL          ;call literal(symlocsp)
0016B6  1  24 47                BIT     INPSTM          ;test inputstmt
0016B8  1  10 07                BPL     *+9             ;branch if not
0016BA  1  A9 31                LDA     #RES
0016BC  1  A0 22                LDY     #RDV
0016BE  1  4C 92 16             JMP     GENRDE          ;call gen$read(res,rdv)
0016C1  1  2C 21 34             BIT     FILEIO          ;see if file io
0016C4  1  10 07                BPL     *+9             ;branch if not
0016C6  1  A9 2A                LDA     #RDS
0016C8  1  A0 29                LDY     #RDN
0016CA  1  4C 92 16             JMP     GENRDE          ;call gen$read(rds,rdn)
0016CD  1  A9 3C                LDA     #DRS
0016CF  1  A0 3D                LDY     #DRF
0016D1  1  4C 92 16             JMP     GENRDE          ;call gen$read(drs,drf)
0016D4  1               ;gen$on
0016D4  1               GENON
0016D4  1  A9 5B                LDA     #RON
0016D6  1  20 F6 0C             JSR     GENERT          ;call generate(ron)
0016D9  1  EE 74 36             INC     ONSP
0016DC  1  AE 74 36             LDX     ONSP            ;get as index
0016DF  1  BD 74 36             LDA     ONSTAK,X        ;get entry
0016E2  1  A0 00                LDY     #0              ;high always clear
0016E4  1  20 7E 0F             JSR     LITERL          ;call(onstack(onsp:=onsp+1))
0016E7  1  A9 5C                LDA     #CKO
0016E9  1  20 F6 0C             JSR     GENERT          ;call generate(cko)
0016EC  1  A9 39                LDA     #BFN
0016EE  1  4C F6 0C             JMP     GENERT          ;call generate(bfn)
0016F1  1               ;gen$on$2
0016F1  1               GENON2
0016F1  1  A5 80                LDA     TYPESP
0016F3  1  AE 74 36             LDX     ONSP
0016F6  1  9D 74 36             STA     ONSTAK,X
0016F9  1  60                   RTS
0016FA  1               ;gennext
0016FA  1               GENNXT
0016FA  1  C6 A9                DEC     FORCNT          ;drop forcount
0016FC  1  A5 A9                LDA     FORCNT          ;get it
0016FE  1  C9 FF                CMP     #255            ;see if wrap
001700  1  D0 07                BNE     *+9             ;branch if ok
001702  1  E6 A9                INC     FORCNT          ;set to 0
001704  1  A9 10                LDA     #16             ;next w/o for error
001706  1  4C AB 0A             JMP     ERROR
001709  1  A9 36                LDA     #BRS
00170B  1  20 F6 0C             JSR     GENERT          ;call generate(brs)
00170E  1  A0 04                LDY     #2*2            ;word addressing
001710  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
001714  1  B5 B9 C9 00  
001718  1  D0 04 A2 00  
001726  1  48                   PHA                     ;save
001727  1  C8                   INY
001728  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get high
00172C  1  B5 B9 C9 00  
001730  1  D0 04 A2 00  
00173E  1  A8                   TAY                     ;move to Y
00173F  1  68                   PLA                     ;get low
001740  1  20 75 0F             JSR     GENTWO          ;call gen$two(nextaddress(2))
001743  1  A0 00                LDY     #0*2            ;still word addressing
001745  1  A5 B2                LDA     CODESI
001747  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put
00174B  1  01 B5 B9 C9  
00174F  1  00 D0 04 A2  
00175D  1  C8                   INY
00175E  1  A5 B3                LDA     CODESI+1        ;do high
001760  1  09 80                ORA     #$80            ;set msb
001762  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;insert
001766  1  01 B5 B9 C9  
00176A  1  00 D0 04 A2  
001778  1               GENNX0
001778  1  A0 01                LDY     #1              ;set index to 1
00177A  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get nextbytev(1)
00177E  1  B5 B9 C9 00  
001782  1  D0 04 A2 00  
001790  1  30 01                BMI     *+3             ;continue if > 127
001792  1  60                   RTS
001793  1  18                   CLC                     ;now add 8 to nextstmtptr
001794  1  A5 B9                LDA     NXSTPT
001796  1  69 08                ADC     #8
001798  1  85 B9                STA     NXSTPT
00179A  1  90 DC                BCC     GENNX0
00179C  1  E6 BA                INC     NXSTPT+1
00179E  1  4C 78 17             JMP     GENNX0
0017A1  1               ;gen$next$with$ident
0017A1  1               GENWID
0017A1  1  A5 7D                LDA     MPP1            ;get mpp1
0017A3  1  20 B6 15             JSR     LKONLY
0017A6  1  F0 3A                BEQ     GENWIE          ;branch if false
0017A8  1  A0 06                LDY     #3*2            ;word addressing
0017AA  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
0017AE  1  B5 B9 C9 00  
0017B2  1  D0 04 A2 00  
0017C0  1  C5 A7                CMP     BASE            ;compare to low base
0017C2  1  D0 1E                BNE     GENWIE          ;error if different
0017C4  1  C8                   INY
0017C5  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;same for high
0017C9  1  B5 B9 C9 00  
0017CD  1  D0 04 A2 00  
0017DB  1  C5 A8                CMP     BASE+1
0017DD  1  D0 03                BNE     GENWIE
0017DF  1  4C FA 16             JMP     GENNXT          ;else ok
0017E2  1               GENWIE
0017E2  1  A9 0E                LDA     #14             ;next does not match for
0017E4  1  4C AB 0A             JMP     ERROR
0017E7  1               ;check$ul$error
0017E7  1               CHKULE
0017E7  1  24 B4                BIT     ULERFL          ;test flag
0017E9  1  10 05                BPL     *+7             ;branch if clear
0017EB  1  A9 14                LDA     #20             ;else undefined label
0017ED  1  20 AB 0A             JSR     ERROR
0017F0  1  A9 00                LDA     #FALSE          ;now clear flag
0017F2  1  85 B4                STA     ULERFL
0017F4  1  60                   RTS
0017F5  1               ;findlabel
0017F5  1               FNDLBL
0017F5  1  A5 7B                LDA     SP              ;get sp
0017F7  1  20 BC 15             JSR     NRMLKU          ;normal$lookup(sp)
0017FA  1  D0 01                BNE     *+3             ;if true
0017FC  1  60                   RTS
0017FD  1  2C 17 34             BIT     PASS2           ;if pass2
001800  1  30 01                BMI     *+3             ;then
001802  1  60                   RTS
001803  1  20 68 11             JSR     GETRES          ;if not getres
001806  1  F0 01                BEQ     *+3             ;then
001808  1  60                   RTS
001809  1  A9 FF                LDA     #TRUE
00180B  1  85 B4                STA     ULERFL          ;ulerrorflag=true
00180D  1  60                   RTS
00180E  1               ;resolve$label
00180E  1               RESLBL
00180E  1  20 F5 17             JSR     FNDLBL          ;findlabel
001811  1  A9 1E                LDA     #PRO            ;preset for true
001813  1  24 48                BIT     GSBSTM          ;test gosubstmt
001815  1  30 02                BMI     *+4             ;if true
001817  1  A9 36                LDA     #BRS            ;else
001819  1  20 F6 0C             JSR     GENERT          ;generate( )
00181C  1  20 8D 11             JSR     GETADR
00181F  1  4C 75 0F             JMP     GENTWO          ;gen$two(getaddr)
001822  1               ;process$simple$variable
001822  1               PSIMPV
001822  1  20 BC 15             JSR     NRMLKU          ;normal$lookup
001825  1  F0 0F                BEQ     PSIMP0          ;if false then
001827  1  20 0F 11             JSR     GETTYP          ;if getype
00182A  1  C9 00                CMP     #SIMVAR         ;= simvar
00182C  1  F0 13                BEQ     PSIMP1          ;then
00182E  1  A9 0B                LDA     #11             ;array name used as simple variable
001830  1  20 AB 0A             JSR     ERROR
001833  1  4C 41 18             JMP     PSIMP1          ;continue
001836  1               PSIMP0
001836  1  20 C8 15             JSR     CNTPRT
001839  1  20 9F 10             JSR     SETRSV          ;setaddr(countprt)
00183C  1  A9 00                LDA     #SIMVAR
00183E  1  20 2F 11             JSR     SETTYP          ;setype(simvar)
001841  1               PSIMP1
001841  1  20 8D 11             JSR     GETADR
001844  1  85 86                STA     SYMLSP
001846  1  84 87                STY     SYMLSP+1        ;symlocsp=getaddr
001848  1  20 B0 0C             JSR     STSLSP          ;setsymlocsp( )
00184B  1  A9 00                LDA     #SIMVAR
00184D  1  20 C4 0C             JSR     STTYSP          ;settypesp(simvar)
001850  1  2C 20 34             BIT     FORSTM          ;if forstmt
001853  1  30 01                BMI     *+3             ;then
001855  1  60                   RTS
001856  1  A9 00                LDA     #FALSE
001858  1  8D 20 34             STA     FORSTM          ;forstmt=false
00185B  1  A0 06                LDY     #3*2            ;word addressing
00185D  1  A5 A7                LDA     BASE
00185F  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001863  1  01 B5 A5 C9  
001867  1  00 D0 04 A2  
001875  1  C8                   INY
001876  1  A5 A8                LDA     BASE+1
001878  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(3)=base
00187C  1  01 B5 A5 C9  
001880  1  00 D0 04 A2  
00188E  1  60                   RTS
00188F  1               ;gen$ils
00188F  1               GENILS
00188F  1  85 C2                STA     WHERE
001891  1  84 C3                STY     WHERE+1         ;save parameter
001893  1  A9 32                LDA     #STRING
001895  1  20 CA 0C             JSR     STSTSP          ;setstypesp(string)
001898  1  A9 1C                LDA     #ILS
00189A  1  20 F6 0C             JSR     GENERT          ;generate(ils)
00189D  1               GENIL0
00189D  1  A9 01                LDA     #1
00189F  1  85 C4                STA     STRPTR          ;strptr=1
0018A1  1               GENIL1
0018A1  1  A0 00                LDY     #0
0018A3  1  8B DA A2 01          LDAINDIRECTY WHERE      ;if stringtospool(0)
0018A7  1  B5 C2 C9 00  
0018AB  1  D0 04 A2 00  
0018B9  1  C5 C4                CMP     STRPTR          ;< strptr
0018BB  1  90 20                BCC     GENIL2          ;then
0018BD  1  A4 C4                LDY     STRPTR
0018BF  1  8B DA A2 01          LDAINDIRECTY WHERE      ;stringtospool(strptr)
0018C3  1  B5 C2 C9 00  
0018C7  1  D0 04 A2 00  
0018D5  1  20 F6 0C             JSR     GENERT          ;generate
0018D8  1  E6 C4                INC     STRPTR          ;strptr=strptr+1
0018DA  1  4C A1 18             JMP     GENIL1
0018DD  1               GENIL2
0018DD  1  24 6E                BIT     CONT            ;if not cont
0018DF  1  10 06                BPL     *+8             ;then
0018E1  1  20 B6 0D             JSR     SCANNR          ;scanner
0018E4  1  4C 9D 18             JMP     GENIL0
0018E7  1  A9 00                LDA     #0
0018E9  1  4C F6 0C             JMP     GENERT          ;generate(0)
0018EC  1               ;gencon
0018EC  1               GENCON
0018EC  1  A9 2E                LDA     #CON
0018EE  1  20 F6 0C             JSR     GENERT          ;generate(con)
0018F1  1  A9 04                LDA     #CONST
0018F3  1  20 C4 0C             JSR     STTYSP          ;settypesp(const)
0018F6  1  A9 31                LDA     #FLOTPT
0018F8  1  20 CA 0C             JSR     STSTSP          ;setstypesp(floatpt)
0018FB  1  A5 7B                LDA     SP
0018FD  1  20 B6 15             JSR     LKONLY          ;lookup$only(sp)
001900  1  F0 0D                BEQ     GENCO0          ;if false then
001902  1  20 0F 11             JSR     GETTYP          ;if getype
001905  1  C9 04                CMP     #CONST          ;<> const
001907  1  D0 06                BNE     GENCO0          ;then
001909  1  20 8D 11             JSR     GETADR
00190C  1  4C 75 0F             JMP     GENTWO          ;gen$two(getaddr)
00190F  1               GENCO0
00190F  1  A9 01                LDA     #1
001911  1  85 C5                STA     IGEN            ;igen=1
001913  1               GENCO1
001913  1  A5 4E                LDA     ACCLEN
001915  1  C5 C5                CMP     IGEN            ;if igen>acclen
001917  1  90 0E                BCC     GENCO2          ;then
001919  1  A6 C5                LDX     IGEN
00191B  1                       .IFDEF  DUODYNE
00191B  1  9F 4E 00 00          STA     F:ACCUM,X         ;store it
00191F  1                       .ELSE
00191F  1                       STA     ACCUM,X         ;store it
00191F  1                       .ENDIF
00191F  1  20 6C 0F             JSR     EMITCN          ;emitcon(accum(i))
001922  1  E6 C5                INC     IGEN            ;i=i+1
001924  1  4C 13 19             JMP     GENCO1
001927  1               GENCO2
001927  1  A9 24                LDA     #'$'
001929  1  20 6C 0F             JSR     EMITCN          ;emitcon('$')
00192C  1  E6 B0                INC     FDACT
00192E  1  D0 02                BNE     *+4
001930  1  E6 B1                INC     FDACT+1         ;fdact=fdact+1
001932  1  A5 B0                LDA     FDACT
001934  1  A4 B1                LDY     FDACT+1
001936  1  4C 75 0F             JMP     GENTWO          ;gen$two(fdact)
001939  1               ;put$field
001939  1               PUTFLD
001939  1  2C 21 34             BIT     FILEIO          ;if not fileio
00193C  1  10 10                BPL     NTFLIO          ;then
00193E  1  A5 83                LDA     STYPSP          ;if stypesp
001940  1  C9 31                CMP     #FLOTPT         ;<> floatpt
001942  1  D0 05                BNE     *+7             ;then
001944  1  A9 2B                LDA     #WRN
001946  1  4C F6 0C             JMP     GENERT          ;generate(wrn)
001949  1  A9 2C                LDA     #WRS
00194B  1  4C F6 0C             JMP     GENERT          ;generate(wrs)
00194E  1               NTFLIO
00194E  1  A5 83                LDA     STYPSP          ;if stypesp
001950  1  C9 31                CMP     #FLOTPT         ;= floatpt
001952  1  F0 05                BEQ     *+7             ;then
001954  1  A9 24                LDA     #WST
001956  1  4C F6 0C             JMP     GENERT          ;generate(wst)
001959  1  A5 80                LDA     TYPESP          ;if typesp
00195B  1  C9 4A                CMP     #74             ;not a tab
00195D  1  D0 01                BNE     *+3             ;then
00195F  1  60                   RTS
001960  1  A9 23                LDA     #WRV
001962  1  4C F6 0C             JMP     GENERT          ;generate(wrv)
001965  1               ;gen$parm
001965  1               GENPRM
001965  1  A5 82                LDA     TYPEMP
001967  1  C9 0A                CMP     #UNFUNC         ;if typemp = unfunc
001969  1  F0 01                BEQ     *+3             ;then
00196B  1  60                   RTS
00196C  1  A5 8A                LDA     SYMLMP
00196E  1  A4 8B                LDY     SYMLMP+1
001970  1  85 A7                STA     BASE
001972  1  84 A8                STY     BASE+1          ;base=symlocmp
001974  1  20 26 0F             JSR     NXTENT          ;nextentry
001977  1  A5 A7                LDA     BASE
001979  1  A4 A8                LDY     BASE+1
00197B  1  20 BE 0C             JSR     STSLMP          ;setsymlocmp(base)
00197E  1  C6 8E                DEC     HASHMP
001980  1  A5 8E                LDA     HASHMP
001982  1  20 DC 0C             JSR     STHAMP          ;sethashmp(hashmp:=hashmp-1)
001985  1  20 8D 11             JSR     GETADR
001988  1  4C 7E 0F             JMP     LITERL          ;literal(getaddr)
00198B  1               ;checkparm
00198B  1               CHKPRM
00198B  1  A5 82                LDA     TYPEMP
00198D  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
00198F  1  D0 17                BNE     NTUNFN          ;then
001991  1  A5 8A                LDA     SYMLMP
001993  1  A4 8B                LDY     SYMLMP+1
001995  1  85 A7                STA     BASE
001997  1  84 A8                STY     BASE+1          ;base=symlocmp
001999  1  20 99 13             JSR     GETSUB          ;getsubtype
00199C  1  C5 84                CMP     STYPM1          ;if = stypemp1
00199E  1  F0 05                BEQ     *+7             ;then
0019A0  1  A9 05                LDA     #5              ;else invalid parameter type in function ref
0019A2  1  20 AB 0A             JSR     ERROR
0019A5  1  4C 79 16             JMP     GENSTR          ;gen$store
0019A8  1               NTUNFN
0019A8  1  A9 01                LDA     #1
0019AA  1  A4 84                LDY     STYPM1          ;if stypemp1
0019AC  1  C0 31                CPY     #FLOTPT         ;<> floatpt
0019AE  1  D0 02                BNE     *+4             ;then
0019B0  1  A9 00                LDA     #FALSE
0019B2  1  45 8E                EOR     HASHMP          ;xor hashmp
0019B4  1  29 01                AND     #1              ;test lsb only
0019B6  1  F0 05                BEQ     *+7             ;if true
0019B8  1  A9 05                LDA     #5              ;invalid type in function parameter list
0019BA  1  20 AB 0A             JSR     ERROR
0019BD  1  A5 8E                LDA     HASHMP
0019BF  1  4A                   LSR     A               ;shr(hashmp,1)
0019C0  1  20 DC 0C             JSR     STHAMP          ;sethashmp
0019C3  1  C6 85                DEC     STYPMP
0019C5  1  A5 85                LDA     STYPMP
0019C7  1  4C D0 0C             JMP     STSTMP          ;setstypemp(stypemp=stypemp-1)
0019CA  1               ;funcgen
0019CA  1               FNCGEN
0019CA  1  A5 82                LDA     TYPEMP
0019CC  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
0019CE  1  D0 1C                BNE     NOFNGN          ;then
0019D0  1  A5 8E                LDA     HASHMP          ;if hashmp=0
0019D2  1  F0 05                BEQ     *+7             ;then
0019D4  1  A9 04                LDA     #4              ;incorrect number parameters
0019D6  1  20 AB 0A             JSR     ERROR
0019D9  1  A9 1E                LDA     #PRO
0019DB  1  20 F6 0C             JSR     GENERT          ;generate(pro)
0019DE  1  A5 8F                LDA     SRLOSP
0019E0  1  A4 90                LDY     SRLOSP+1
0019E2  1  85 A7                STA     BASE
0019E4  1  84 A8                STY     BASE+1          ;base=srlocsp
0019E6  1  20 8D 11             JSR     GETADR
0019E9  1  4C 75 0F             JMP     GENTWO          ;gen$two(getaddr)
0019EC  1               NOFNGN
0019EC  1  A5 85                LDA     STYPMP
0019EE  1  29 03                AND     #3              ;if stypemp and 3 = 0
0019F0  1  F0 05                BEQ     *+7             ;then
0019F2  1  A9 04                LDA     #4              ;incorrect number parameters
0019F4  1  20 AB 0A             JSR     ERROR
0019F7  1  A5 82                LDA     TYPEMP
0019F9  1  20 F6 0C             JSR     GENERT          ;generate(typemp)
0019FC  1  A5 85                LDA     STYPMP
0019FE  1  29 40                AND     #%01000000      ;if not rol(stypemp,2)
001A00  1  F0 05                BEQ     *+7             ;then
001A02  1  A9 32                LDA     #STRING
001A04  1  4C D0 0C             JMP     STSTMP          ;setstypemp(string)
001A07  1  A9 31                LDA     #FLOTPT
001A09  1  4C D0 0C             JMP     STSTMP          ;setstypemp(floatpt)
001A0C  1               ;enter$parm
001A0C  1               ENTRPR
001A0C  1  2C 16 34             BIT     PASS1           ;if pass 1
001A0F  1  30 01                BMI     *+3             ;then
001A11  1  60                   RTS
001A12  1  A5 7D                LDA     MPP1
001A14  1  20 A6 15             JSR     STLKUP          ;setlookup(mpp1)
001A17  1  20 7F 12             JSR     ENTER
001A1A  1  20 C8 15             JSR     CNTPRT
001A1D  1  20 9F 10             JSR     SETRSV          ;setaddr(countprt)
001A20  1  A5 84                LDA     STYPM1
001A22  1  20 79 13             JSR     SETSUB          ;setsubtype(stypemp1)
001A25  1  A9 00                LDA     #SIMVAR
001A27  1  20 2F 11             JSR     SETTYP          ;setype(simvar)
001A2A  1  A6 82                LDX     TYPEMP
001A2C  1  E8                   INX
001A2D  1  8A                   TXA
001A2E  1  4C D6 0C             JMP     STTYMP          ;settypemp(typemp+1)
001A31  1               ;synthesis
001A31  1               ;main code generation routine
001A31  1               SYNTHE
001A31  1  85 B8                STA     PRODCT          ;save production
001A33  1  AD 17 34             LDA     PASS2           ;if not pass 2
001A36  1  2D 18 34             AND     LSTPRD          ;and listprod
001A39  1  F0 11                BEQ     NPPROD          ;then
001A3B  1  A9 A5                LDA     #<PRDMSG
001A3D  1  A0 33                LDY     #>PRDMSG
001A3F  1  20 FC 08             JSR     PRNMSG          ;print message
001A42  1  A5 B8                LDA     PRODCT
001A44  1  A0 00                LDY     #0
001A46  1  20 70 08             JSR     PRNDEC          ;print number
001A49  1  20 34 08             JSR     CRLF
001A4C  1               NPPROD
001A4C  1  20 41 0C             JSR     SCOPY           ;set up simple variables
001A4F  1  A5 B8                LDA     PRODCT          ;get number
001A51  1  0A                   ASL     A               ;make word index
001A52  1  AA                   TAX                     ;make index
001A53  1  B0 0F                BCS     GT127           ;branch if > 127
001A55  1  BD 73 1A             LDA     PRODL,X
001A58  1  8D 62 1A             STA     JPROD+1
001A5B  1  BD 74 1A             LDA     PRODL+1,X
001A5E  1  8D 63 1A             STA     JPROD+2         ;set address
001A61  1               JPROD
001A61  1  4C FF FF             JMP     $FFFF           ;do it
001A64  1               GT127
001A64  1  BD 73 1B             LDA     PRODH,X
001A67  1  8D 62 1A             STA     JPROD+1
001A6A  1  BD 74 1B             LDA     PRODH+1,X
001A6D  1  8D 63 1A             STA     JPROD+2
001A70  1  4C 61 1A             JMP     JPROD           ;same for high
001A73  1               ;production jump table for 0 - 127
001A73  1               PRODL
001A73  1  A5 1B A5 1B          .WORD   PRN,PRN,PR2,PR3,CHKULE,CHKULE,PRN,PRN
001A77  1  A6 1B DB 1B  
001A7B  1  E7 17 E7 17  
001A83  1  A5 1B A5 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A87  1  A5 1B A5 1B  
001A8B  1  A5 1B A5 1B  
001A93  1  A5 1B A5 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A97  1  A5 1B A5 1B  
001A9B  1  A5 1B A5 1B  
001AA3  1  A5 1B A5 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PR30,PR31
001AA7  1  A5 1B A5 1B  
001AAB  1  A5 1B A5 1B  
001AB3  1  A5 1B F9 1B          .WORD   PRN,PR33,PR34,PR35,PRN,PR37,PRN,PR39
001AB7  1  04 1C 09 1C  
001ABB  1  A5 1B 0E 1C  
001AC3  1  A5 1B 24 1C          .WORD   PRN,PR41,PRN,PR43,PR44,CHKTY3,PR46,PRN
001AC7  1  A5 1B 42 1C  
001ACB  1  55 1C 34 16  
001AD3  1  6B 1C 76 1C          .WORD   PR48,PR49,PRN,PR51,PR52,PRN,PRN,PR55
001AD7  1  A5 1B 81 1C  
001ADB  1  8C 1C A5 1B  
001AE3  1  A3 1C A8 1C          .WORD   PR56,PR57,PR58,CHKTY5,PR60,FNCGEN,GENPRM,PR63
001AE7  1  D9 1C 5B 16  
001AEB  1  F8 1C CA 19  
001AF3  1  0C 1D 31 1D          .WORD   PR64,PR65,GENCON,PR67,PR68,PR69,PR69,PR71
001AF7  1  EC 18 3F 1D  
001AFB  1  46 1D 4B 1D  
001B03  1  50 1D 55 1D          .WORD   PR71,PR73,PR74,PR75,PR75,PR77,PR78,PR79
001B07  1  5A 1D 5F 1D  
001B0B  1  5F 1D 64 1D  
001B13  1  23 1F 28 1F          .WORD   PR80,PR81,PR82,PR82,PR84,PRN,RESLBL,PR87
001B17  1  71 1F 71 1F  
001B1B  1  76 1F A5 1B  
001B23  1  96 1F A9 1F          .WORD   PR88,PR89,PR90,ENTRPR,PR92,PR92,ENTRPR,PRN
001B27  1  CE 1F 0C 1A  
001B2B  1  00 20 00 20  
001B33  1  A5 1B A5 1B          .WORD   PRN,PRN,PR98,CHKTY4,PR100,PRN,SUBCAL,SUBCAL
001B37  1  05 20 4D 16  
001B3B  1  21 20 A5 1B  
001B43  1  27 20 33 20          .WORD   PR104,PR105,CHKTY5,PRN,PR108,PR108,PR110,PRN
001B47  1  5B 16 A5 1B  
001B4B  1  66 20 66 20  
001B53  1  89 20 93 20          .WORD   PR112,PR113,SEINPU,GETFLD,GETFLD,PR117,PRN,PR119
001B57  1  89 16 A9 16  
001B5B  1  A9 16 83 20  
001B63  1  39 19 39 19          .WORD   PUTFLD,PUTFLD,PRN,PUTFLD,PUTFLD,PRN,PR126,PR127
001B67  1  A5 1B 39 19  
001B6B  1  39 19 A5 1B  
001B73  1               ;production jump table for 128 - 255
001B73  1               PRODH
001B73  1  B8 20 A5 1B          .WORD   PR128,PRN,PR130,RESLBL,GENON2,PR133,GENON,PR135
001B77  1  D1 20 0E 18  
001B7B  1  F1 16 DC 20  
001B83  1  FA 20 02 21          .WORD   PR136,PR137,PR138,PRN,PRN,PRN,PRN,GENWID
001B87  1  0C 21 A5 1B  
001B8B  1  A5 1B A5 1B  
001B93  1  FA 16 A5 1B          .WORD   GENNXT,PRN,GENWID,PR147,PR148,PR149,PR150,PR151
001B97  1  A1 17 18 21  
001B9B  1  39 21 3E 21  
001BA3  1  B0 21                .WORD   PR152
001BA5  1               ;productions not already defined by single no-parameter subroutines
001BA5  1               PRN
001BA5  1  60                   RTS                     ;do nothing - used a lot !!!!
001BA6  1               ;2	<line number>::=<number>
001BA6  1               PR2
001BA6  1  A5 7B                LDA     SP
001BA8  1  20 B6 15             JSR     LKONLY          ;lookup$only(sp)
001BAB  1  F0 27                BEQ     PR2D            ;if false
001BAD  1  20 68 11             JSR     GETRES          ;see if resolved
001BB0  1  F0 13                BEQ     PR2C            ;if not
001BB2  1  20 8D 11             JSR     GETADR          ;getaddr
001BB5  1  C5 B2                CMP     CODESI          ;try low
001BB7  1  D0 04                BNE     PR2A            ;error if <>
001BB9  1  C4 B3                CPY     CODESI+1
001BBB  1  F0 05                BEQ     *+7             ;ok if same
001BBD  1               PR2A
001BBD  1  A9 00                LDA     #0              ;duplicate labels
001BBF  1  20 AB 0A             JSR     ERROR
001BC2  1  4C 90 0F             JMP     LINENU
001BC5  1               PR2C
001BC5  1  A5 B2                LDA     CODESI
001BC7  1  A4 B3                LDY     CODESI+1
001BC9  1  20 9F 10             JSR     SETRSV          ;setaddr(codesize)
001BCC  1  A9 08                LDA     #LABLE
001BCE  1  20 2F 11             JSR     SETTYP          ;setype(lable)
001BD1  1  4C 90 0F             JMP     LINENU
001BD4  1               PR2D
001BD4  1  A9 2A                LDA     #'*'
001BD6  1  85 74                STA     SEPRTR          ;separator=astrik
001BD8  1  4C 90 0F             JMP     LINENU
001BDB  1               ;3	|
001BDB  1               PR3
001BDB  1  A9 3A                LDA     #':'            ;set separator
001BDD  1  85 74                STA     SEPRTR
001BDF  1  4C 90 0F             JMP     LINENU          ;then do line number
001BE2  1               ;30	<assignmemt>::=<assign head><expression>
001BE2  1               PR30
001BE2  1  20 23 16             JSR     CHKTY2          ;if not chktyp2
001BE5  1  F0 03                BEQ     *+5             ;then
001BE7  1  4C 79 16             JMP     GENSTR          ;else gen$store
001BEA  1  60                   RTS
001BEB  1               ;31	<assign head>::=<variable>=
001BEB  1               PR31
001BEB  1  A5 82                LDA     TYPEMP
001BED  1  C9 00                CMP     #SIMVAR         ;if typemp=simvar
001BEF  1  F0 01                BEQ     *+3             ;then
001BF1  1  60                   RTS
001BF2  1  A5 8A                LDA     SYMLMP
001BF4  1  A4 8B                LDY     SYMLMP+1
001BF6  1  4C 7E 0F             JMP     LITERL          ;literal(symlocmp)
001BF9  1               ;33	|<expression><or><logical factor>
001BF9  1               PR33
001BF9  1  20 0E 16             JSR     CHKTY1          ;if chktyp1
001BFC  1  D0 01                BNE     *+3             ;then
001BFE  1  60                   RTS
001BFF  1  A5 81                LDA     TYPEM1
001C01  1  4C F6 0C             JMP     GENERT          ;generate(typemp1)
001C04  1               ;34	<or>::=or
001C04  1               PR34
001C04  1  A9 0D                LDA     #BOR
001C06  1  4C C4 0C             JMP     STTYSP          ;settypesp(bor)
001C09  1               ;35	|xor
001C09  1               PR35
001C09  1  A9 5D                LDA     #EXR
001C0B  1  4C C4 0C             JMP     STTYSP          ;sttysp
001C0E  1               ;37	<logical secondary>
001C0E  1               PR37
001C0E  1  20 0E 16             JSR     CHKTY1          ;if chktyp1
001C11  1  D0 01                BNE     *+3             ;then
001C13  1  60                   RTS
001C14  1  A9 0C                LDA     #ANDO
001C16  1  4C F6 0C             JMP     GENERT          ;generate(ando)
001C19  1               ;39	|not <logical primary>
001C19  1               PR39
001C19  1  20 34 16             JSR     CHKTY3          ;if chktyp3
001C1C  1  D0 01                BNE     *+3             ;then
001C1E  1  60                   RTS
001C1F  1  A9 0B                LDA     #NOT
001C21  1  4C F6 0C             JMP     GENERT          ;generate(not)
001C24  1               ;41	<arithmetic expression>
001C24  1               PR41
001C24  1  20 23 16             JSR     CHKTY2          ;if chktyp2
001C27  1  D0 01                BNE     *+3             ;then
001C29  1  60                   RTS
001C2A  1  A5 83                LDA     STYPSP
001C2C  1  C9 31                CMP     #FLOTPT         ;if stypesp<>floatpt
001C2E  1  D0 05                BNE     PR41A           ;then
001C30  1  A5 81                LDA     TYPEM1
001C32  1  4C F6 0C             JMP     GENERT          ;generate(typemp1)
001C35  1               PR41A
001C35  1  18                   CLC
001C36  1  A5 81                LDA     TYPEM1
001C38  1  69 10                ADC     #16
001C3A  1  20 F6 0C             JSR     GENERT          ;generate(typemp1+16)
001C3D  1  A9 31                LDA     #FLOTPT
001C3F  1  4C D0 0C             JMP     STSTMP          ;setstypemp(floatpt)
001C42  1               ;43	|<arithmetic expression>+<term>
001C42  1               PR43
001C42  1  20 23 16             JSR     CHKTY2          ;if chktyp2
001C45  1  D0 01                BNE     *+3             ;then
001C47  1  60                   RTS
001C48  1  A9 00                LDA     #FAD
001C4A  1  A4 83                LDY     STYPSP
001C4C  1  C0 31                CPY     #FLOTPT         ;if stypesp=floatpt
001C4E  1  F0 02                BEQ     *+4             ;then generate(fad)
001C50  1  A9 1D                LDA     #CAT
001C52  1  4C F6 0C             JMP     GENERT          ;else generate(cat)
001C55  1               ;44	|<arithmetic expression>-<term>
001C55  1               PR44
001C55  1  20 0E 16             JSR     CHKTY1          ;if chktyp1
001C58  1  D0 01                BNE     *+3             ;then
001C5A  1  60                   RTS
001C5B  1  A9 01                LDA     #FMI
001C5D  1  4C F6 0C             JMP     GENERT          ;generate(fmi)
001C60  1               ;46	|-<term>
001C60  1               PR46
001C60  1  20 34 16             JSR     CHKTY3          ;if chktyp3
001C63  1  D0 01                BNE     *+3             ;then
001C65  1  60                   RTS
001C66  1  A9 30                LDA     #NEG
001C68  1  4C F6 0C             JMP     GENERT          ;generate(neg)
001C6B  1               ;48	|<term>*<primary>
001C6B  1               PR48
001C6B  1  20 0E 16             JSR     CHKTY1          ;if chktyp1
001C6E  1  D0 01                BNE     *+3             ;then
001C70  1  60                   RTS
001C71  1  A9 02                LDA     #FMU
001C73  1  4C F6 0C             JMP     GENERT          ;generate(fmu)
001C76  1               ;49	|<term>/<primary>
001C76  1               PR49
001C76  1  20 0E 16             JSR     CHKTY1          ;if chktyp1
001C79  1  D0 01                BNE     *+3             ;then
001C7B  1  60                   RTS
001C7C  1  A9 03                LDA     #FDI
001C7E  1  4C F6 0C             JMP     GENERT          ;generate(fdi)
001C81  1               ;51	|<primary>**<element>
001C81  1               PR51
001C81  1  20 0E 16             JSR     CHKTY1          ;the chktyp1
001C84  1  D0 01                BNE     *+3             ;then
001C86  1  60                   RTS
001C87  1  A9 04                LDA     #EXP
001C89  1  4C F6 0C             JMP     GENERT          ;generate(exp)
001C8C  1               ;52	<element>::=<variable>
001C8C  1               PR52
001C8C  1  A5 80                LDA     TYPESP          ;if typesp
001C8E  1  C9 00                CMP     #SIMVAR         ;= simvar
001C90  1  F0 05                BEQ     *+7             ;then
001C92  1  A9 0E                LDA     #LOD
001C94  1  4C F6 0C             JMP     GENERT          ;else generate(lod)
001C97  1  A5 86                LDA     SYMLSP
001C99  1  A4 87                LDY     SYMLSP+1
001C9B  1  4C 87 0F             JMP     LITLOD          ;litload(symlocsp)
001C9E  1               ;55	|(<expression>)
001C9E  1               PR55
001C9E  1  A5 84                LDA     STYPM1
001CA0  1  4C D0 0C             JMP     STSTMP          ;setstypemp(stypemp1)
001CA3  1               ;56	<variable>::=<identifier>
001CA3  1               PR56
001CA3  1  A5 7B                LDA     SP
001CA5  1  4C 22 18             JMP     PSIMPV          ;process$simple$variable(sp)
001CA8  1               ;57	|<subscript head><expression>
001CA8  1               PR57
001CA8  1  2C 20 34             BIT     FORSTM          ;if not forstmt
001CAB  1  10 05                BPL     *+7             ;then
001CAD  1  A9 03                LDA     #3              ;for index not simple variable
001CAF  1  20 AB 0A             JSR     ERROR
001CB2  1  20 5B 16             JSR     CHKTY5          ;chktyp5
001CB5  1  A5 8A                LDA     SYMLMP
001CB7  1  A4 8B                LDY     SYMLMP+1
001CB9  1  85 A7                STA     BASE
001CBB  1  84 A8                STY     BASE+1          ;base=symlocsp
001CBD  1  20 99 13             JSR     GETSUB          ;if getsubtype
001CC0  1  C5 82                CMP     TYPEMP          ;= typemp
001CC2  1  F0 05                BEQ     *+7             ;then
001CC4  1  A9 11                LDA     #17             ;incorrect number subscripts
001CC6  1  20 AB 0A             JSR     ERROR
001CC9  1  20 8D 11             JSR     GETADR
001CCC  1  20 87 0F             JSR     LITLOD          ;litload(getaddr)
001CCF  1  A9 21                LDA     #SUB
001CD1  1  20 F6 0C             JSR     GENERT          ;generate(subo)
001CD4  1  A9 02                LDA     #SUBVAR
001CD6  1  4C D6 0C             JMP     STTYMP          ;settypemp(subvar)
001CD9  1               ;58	<subscript head>::=<identifier>(
001CD9  1               PR58
001CD9  1  A5 7C                LDA     MP
001CDB  1  20 B6 15             JSR     LKONLY          ;lookup$only(mp)
001CDE  1  F0 07                BEQ     PR58A           ;if not then error
001CE0  1  20 0F 11             JSR     GETTYP          ;if getype
001CE3  1  C9 02                CMP     #SUBVAR         ;= subvar
001CE5  1  F0 05                BEQ     *+7             ;then ok
001CE7  1               PR58A
001CE7  1  A9 0A                LDA     #10             ;subscripted variable not dimensioned
001CE9  1  20 AB 0A             JSR     ERROR
001CEC  1  A9 00                LDA     #0
001CEE  1  20 D6 0C             JSR     STTYMP          ;settypemp(0)
001CF1  1  A5 A7                LDA     BASE
001CF3  1  A4 A8                LDY     BASE+1
001CF5  1  4C BE 0C             JMP     STSLMP          ;setsymlocmp(base)
001CF8  1               ;60	<function call>::=<function heading><expression>
001CF8  1               PR60
001CF8  1  20 8B 19             JSR     CHKPRM          ;checkparm
001CFB  1  A5 91                LDA     SRLOMP
001CFD  1  A4 92                LDY     SRLOMP+1
001CFF  1  85 8F                STA     SRLOSP
001D01  1  84 90                STY     SRLOSP+1        ;srlocsp=srlocmp
001D03  1  4C CA 19             JMP     FNCGEN          ;funcgen
001D06  1               ;63	|<function heading><expression>
001D06  1               PR63
001D06  1  20 8B 19             JSR     CHKPRM          ;check$parm
001D09  1  4C 65 19             JMP     GENPRM          ;gen$parm
001D0C  1               ;64	<function name>::=<user defined name>
001D0C  1               PR64
001D0C  1  A5 7B                LDA     SP
001D0E  1  20 B6 15             JSR     LKONLY          ;if lookup$only(sp)
001D11  1  D0 05                BNE     *+7             ;then
001D13  1  A9 06                LDA     #6              ;function undefined
001D15  1  4C AB 0A             JMP     ERROR
001D18  1  A5 A7                LDA     BASE
001D1A  1  A4 A8                LDY     BASE+1
001D1C  1  20 E8 0C             JSR     STSRSP          ;setsrlocsp(base)
001D1F  1  A5 A7                LDA     BASE
001D21  1  A4 A8                LDY     BASE+1
001D23  1  20 B0 0C             JSR     STSLSP          ;setsymlocsp(base)
001D26  1  A9 0A                LDA     #UNFUNC
001D28  1  20 C4 0C             JSR     STTYSP          ;settypesp(unfunc)
001D2B  1  20 0F 11             JSR     GETTYP
001D2E  1  4C E2 0C             JMP     STHASP          ;sethashsp(getype)
001D31  1               ;65	|<predefined name>
001D31  1               PR65
001D31  1  A5 4B                LDA     FUNCOP
001D33  1  20 C4 0C             JSR     STTYSP          ;settypesp(funcop)
001D36  1  A5 83                LDA     STYPSP
001D38  1  4A                   LSR     A
001D39  1  4A                   LSR     A               ;shr(stypesp,2)
001D3A  1  29 07                AND     #7
001D3C  1  4C E2 0C             JMP     STHASP          ;sethashsp( )
001D3F  1               ;67	|<string>
001D3F  1               PR67
001D3F  1  A9 4E                LDA     #<ACCUM
001D41  1  A0 00                LDY     #>ACCUM
001D43  1  4C 8F 18             JMP     GENILS          ;gen$ils(.accum)
001D46  1               ;68	<relation>::= =
001D46  1               PR68
001D46  1  A9 07                LDA     #7
001D48  1  4C C4 0C             JMP     STTYSP          ;settypesp(7)
001D4B  1               ;69	| >= | GE
001D4B  1               PR69
001D4B  1  A9 09                LDA     #9
001D4D  1  4C D6 0C             JMP     STTYMP          ;settypemp(9)
001D50  1               ;71	| <= | LE
001D50  1               PR71
001D50  1  A9 0A                LDA     #10
001D52  1  4C D6 0C             JMP     STTYMP          ;settypemp(10)
001D55  1               ;73	| >
001D55  1               PR73
001D55  1  A9 06                LDA     #6
001D57  1  4C C4 0C             JMP     STTYSP          ;settypesp(6)
001D5A  1               ;74	| <
001D5A  1               PR74
001D5A  1  A9 05                LDA     #5
001D5C  1  4C C4 0C             JMP     STTYSP          ;settypesp(5)
001D5F  1               ;75	| <> | NE
001D5F  1               PR75
001D5F  1  A9 08                LDA     #8
001D61  1  4C D6 0C             JMP     STTYMP          ;settypemp(8)
001D64  1               ;77	<for statement>::=<for head> to <expression> <step clause>
001D64  1               PR77
001D64  1  A0 06                LDY     #3*2            ;word addressing
001D66  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D6A  1  B5 A5 C9 00  
001D6E  1  D0 04 A2 00  
001D7C  1  85 A7                STA     BASE
001D7E  1  C8                   INY
001D7F  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D83  1  B5 A5 C9 00  
001D87  1  D0 04 A2 00  
001D95  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001D97  1  A5 80                LDA     TYPESP          ;if not typesp
001D99  1  4A                   LSR     A
001D9A  1  90 05                BCC     *+7             ;then
001D9C  1  A9 12                LDA     #DUP
001D9E  1  20 F6 0C             JSR     GENERT          ;generate(dup)
001DA1  1  20 8D 11             JSR     GETADR
001DA4  1  20 87 0F             JSR     LITLOD          ;litload(getaddr)
001DA7  1  A9 00                LDA     #FAD
001DA9  1  20 F6 0C             JSR     GENERT          ;generate(fad)
001DAC  1  A5 80                LDA     TYPESP          ;if not
001DAE  1  4A                   LSR     A               ;typesp
001DAF  1  90 0B                BCC     PR77A           ;then
001DB1  1  20 8D 11             JSR     GETADR
001DB4  1  20 7E 0F             JSR     LITERL          ;literal(getaddr)
001DB7  1  A9 13                LDA     #XCH
001DB9  1  20 F6 0C             JSR     GENERT          ;generate(xch)
001DBC  1               PR77A
001DBC  1  A9 0F                LDA     #STO
001DBE  1  20 F6 0C             JSR     GENERT          ;generate(sto)
001DC1  1  A5 80                LDA     TYPESP          ;if not
001DC3  1  4A                   LSR     A               ;typesp
001DC4  1  90 2D                BCC     PR77B           ;then
001DC6  1  A9 13                LDA     #XCH
001DC8  1  20 F6 0C             JSR     GENERT          ;generate(xch)
001DCB  1  A9 00                LDA     #0
001DCD  1  A8                   TAY
001DCE  1  20 7E 0F             JSR     LITERL          ;literal(0)
001DD1  1  A9 05                LDA     #LSS
001DD3  1  20 F6 0C             JSR     GENERT          ;generate(lss)
001DD6  1  A9 05                LDA     #5
001DD8  1  A0 00                LDY     #0
001DDA  1  20 7E 0F             JSR     LITERL          ;literal(5)
001DDD  1  A9 38                LDA     #BFC
001DDF  1  20 F6 0C             JSR     GENERT          ;generate(bfc)
001DE2  1  A9 0A                LDA     #LEQ
001DE4  1  20 F6 0C             JSR     GENERT          ;generate(leq)
001DE7  1  A9 02                LDA     #2
001DE9  1  A0 00                LDY     #0
001DEB  1  20 7E 0F             JSR     LITERL          ;literal(2)
001DEE  1  A9 39                LDA     #BFN
001DF0  1  20 F6 0C             JSR     GENERT          ;generate(bfn)
001DF3  1               PR77B
001DF3  1  A9 09                LDA     #GEQ
001DF5  1  20 F6 0C             JSR     GENERT          ;generate(beq)
001DF8  1  A9 37                LDA     #BRC
001DFA  1  20 F6 0C             JSR     GENERT          ;generate(brc)
001DFD  1  A0 00                LDY     #0*2            ;word address
001DFF  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E03  1  B5 A5 C9 00  
001E07  1  D0 04 A2 00  
001E15  1  48                   PHA
001E16  1  C8                   INY
001E17  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E1B  1  B5 A5 C9 00  
001E1F  1  D0 04 A2 00  
001E2D  1  A8                   TAY
001E2E  1  68                   PLA
001E2F  1  20 75 0F             JSR     GENTWO          ;gen$two(foraddress(0))
001E32  1  A0 02                LDY     #1*2            ;word addressing
001E34  1  A5 B2                LDA     CODESI
001E36  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001E3A  1  01 B5 A5 C9  
001E3E  1  00 D0 04 A2  
001E4C  1  C8                   INY
001E4D  1  A5 B3                LDA     CODESI+1
001E4F  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(1)=codesize
001E53  1  01 B5 A5 C9  
001E57  1  00 D0 04 A2  
001E65  1  60                   RTS
001E66  1               ;78	<for head>::=<for><assignment>
001E66  1               PR78
001E66  1  A9 36                LDA     #BRS
001E68  1  20 F6 0C             JSR     GENERT          ;generate(brs)
001E6B  1  A0 02                LDY     #1*2            ;word addressing
001E6D  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E71  1  B5 A5 C9 00  
001E75  1  D0 04 A2 00  
001E83  1  48                   PHA
001E84  1  C8                   INY
001E85  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E89  1  B5 A5 C9 00  
001E8D  1  D0 04 A2 00  
001E9B  1  A8                   TAY
001E9C  1  68                   PLA
001E9D  1  20 75 0F             JSR     GENTWO          ;gen$two(foraddress(1))
001EA0  1  A0 04                LDY     #2*2            ;word addressing
001EA2  1  A5 B2                LDA     CODESI
001EA4  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001EA8  1  01 B5 A5 C9  
001EAC  1  00 D0 04 A2  
001EBA  1  C8                   INY
001EBB  1  A5 B3                LDA     CODESI+1
001EBD  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(2)=codesize
001EC1  1  01 B5 A5 C9  
001EC5  1  00 D0 04 A2  
001ED3  1  60                   RTS
001ED4  1               ;79	<for>::= for
001ED4  1               PR79
001ED4  1  A9 FF                LDA     #TRUE
001ED6  1  8D 20 34             STA     FORSTM          ;forstmt=true
001ED9  1  38                   SEC
001EDA  1  A5 A5                LDA     SBTTOP
001EDC  1  E9 08                SBC     #8
001EDE  1  85 A5                STA     SBTTOP
001EE0  1  85 B9                STA     NXSTPT
001EE2  1  A4 A6                LDY     SBTTOP+1
001EE4  1  B0 01                BCS     *+3
001EE6  1  88                   DEY
001EE7  1  84 A6                STY     SBTTOP+1
001EE9  1  84 BA                STY     NXSTPT+1        ;sbtbltop,nextstmtptr=sbtbltop-8
001EEB  1  A0 01                LDY     #1
001EED  1  8B DA A2 01          LDAINDIRECTY NXSTPT
001EF1  1  B5 B9 C9 00  
001EF5  1  D0 04 A2 00  
001F03  1  29 7F                AND     #$7F
001F05  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;nextbytev(1)=nextbytev(1) and $7f
001F09  1  01 B5 B9 C9  
001F0D  1  00 D0 04 A2  
001F1B  1  A9 00                LDA     #0
001F1D  1  20 82 10             JSR     LIMITS          ;limits(0)
001F20  1  E6 A9                INC     FORCNT          ;forcount=forcount+1
001F22  1  60                   RTS
001F23  1               ;80	<step clause>::= step <expression>
001F23  1               PR80
001F23  1  A9 01                LDA     #1
001F25  1  4C D6 0C             JMP     STTYMP          ;settypemp(true)
001F28  1               ;81	|
001F28  1               PR81
001F28  1  A0 06                LDY     #3*2            ;word addressing
001F2A  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F2E  1  B5 A5 C9 00  
001F32  1  D0 04 A2 00  
001F40  1  85 A7                STA     BASE
001F42  1  C8                   INY
001F43  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F47  1  B5 A5 C9 00  
001F4B  1  D0 04 A2 00  
001F59  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001F5B  1  20 8D 11             JSR     GETADR
001F5E  1  20 7E 0F             JSR     LITERL          ;literal(getaddr)
001F61  1  A9 00                LDA     #FALSE
001F63  1  20 C4 0C             JSR     STTYSP          ;settypesp(false)
001F66  1  A9 2E                LDA     #CON
001F68  1  20 F6 0C             JSR     GENERT          ;generate(con)
001F6B  1  A9 00                LDA     #0
001F6D  1  A8                   TAY
001F6E  1  4C 75 0F             JMP     GENTWO          ;gen$two(0)
001F71  1               ;82	<if statement>::=<if group>
001F71  1               PR82
001F71  1  A9 00                LDA     #0
001F73  1  4C E3 15             JMP     ENCMLB          ;enter$compiler$label(0)
001F76  1               ;84	| if end # <expression> then <number>
001F76  1               PR84
001F76  1  A9 5B                LDA     #RON
001F78  1  20 F6 0C             JSR     GENERT          ;generate(ron)
001F7B  1  A9 5E                LDA     #DEF
001F7D  1  20 F6 0C             JSR     GENERT          ;generate(def)
001F80  1  20 F5 17             JSR     FNDLBL          ;findlabel
001F83  1  20 8D 11             JSR     GETADR
001F86  1  4C 75 0F             JMP     GENTWO          ;gen$two(getaddr)
001F89  1               ;87	<if else group>::=<if head><statement list> else
001F89  1               PR87
001F89  1  A9 03                LDA     #3
001F8B  1  20 E3 15             JSR     ENCMLB          ;emter$compiler$label(3)
001F8E  1  A9 36                LDA     #BRS
001F90  1  20 F6 0C             JSR     GENERT          ;generate(brs)
001F93  1  4C 05 16             JMP     COMLBL          ;compiler$label
001F96  1               ;88	<if head>::=if <expression> then
001F96  1               PR88
001F96  1  A5 84                LDA     STYPM1          ;if stypemp1
001F98  1  C9 32                CMP     #STRING         ;<> string
001F9A  1  D0 05                BNE     *+7             ;then
001F9C  1  A9 08                LDA     #8              ;else if expression is not floating point
001F9E  1  20 AB 0A             JSR     ERROR
001FA1  1  A9 37                LDA     #BRC
001FA3  1  20 F6 0C             JSR     GENERT          ;generate(brc)
001FA6  1  4C 05 16             JMP     COMLBL          ;compiler$label
001FA9  1               ;89	<dummy argument list>::=<expresssion>
001FA9  1               PR89
001FA9  1  20 23 16             JSR     CHKTY2          ;if chkty2
001FAC  1  D0 01                BNE     *+3             ;the
001FAE  1  60                   RTS
001FAF  1  A5 8A                LDA     SYMLMP
001FB1  1  A4 8B                LDY     SYMLMP+1
001FB3  1  85 A7                STA     BASE
001FB5  1  84 A8                STY     BASE+1
001FB7  1  A5 81                LDA     TYPEM1
001FB9  1  20 2F 11             JSR     SETTYP          ;setype(typemp1)
001FBC  1  20 B7 13             JSR     UNLINK
001FBF  1  A9 13                LDA     #XCH
001FC1  1  20 F6 0C             JSR     GENERT          ;generate(xch)
001FC4  1  A9 1F                LDA     #RTN
001FC6  1  20 F6 0C             JSR     GENERT          ;generate(rtn)
001FC9  1  A9 00                LDA     #0
001FCB  1  4C E3 15             JMP     ENCMLB          ;enter$compiler$label(0)
001FCE  1               ;90	(ud function name>::= def <user defined name>
001FCE  1               PR90
001FCE  1  A9 36                LDA     #BRS
001FD0  1  20 F6 0C             JSR     GENERT          ;generate(brs)
001FD3  1  20 05 16             JSR     COMLBL          ;compiler$label
001FD6  1  A5 7B                LDA     SP
001FD8  1  20 BC 15             JSR     NRMLKU          ;normal$lookup(sp)
001FDB  1  48                   PHA                     ;save result
001FDC  1  A5 83                LDA     STYPSP
001FDE  1  20 D0 0C             JSR     STSTMP          ;setstypemp(stypesp)
001FE1  1  A5 A7                LDA     BASE
001FE3  1  A4 A8                LDY     BASE+1
001FE5  1  20 BE 0C             JSR     STSLMP          ;setsymlocmp(base)
001FE8  1  2C 16 34             BIT     PASS1           ;if pass 1
001FEB  1  30 04                BMI     *+6             ;then
001FED  1  68                   PLA                     ;clear stack
001FEE  1  4C B6 14             JMP     RELINK
001FF1  1  68                   PLA                     ;if not flag
001FF2  1  F0 05                BEQ     *+7             ;then
001FF4  1  A9 02                LDA     #2              ;else function name previously defined
001FF6  1  20 AB 0A             JSR     ERROR
001FF9  1  A5 B2                LDA     CODESI
001FFB  1  A4 B3                LDY     CODESI+1
001FFD  1  4C 9F 10             JMP     SETRSV          ;setaddr(codesize)
002000  1               ;92	|
002000  1               PR92
002000  1  A9 00                LDA     #0
002002  1  4C D6 0C             JMP     STTYMP          ;settypemp(0)
002005  1               ;98	<file decleration>::=<identifier><file rec size>
002005  1               PR98
002005  1  A5 7C                LDA     MP
002007  1  20 22 18             JSR     PSIMPV          ;process$simple$variable(mp)
00200A  1  A5 85                LDA     STYPMP          ;if stypemp
00200C  1  C9 31                CMP     #FLOTPT         ;<> floatpt
00200E  1  D0 05                BNE     *+7             ;then
002010  1  A9 17                LDA     #23             ;invalid type in file
002012  1  20 AB 0A             JSR     ERROR
002015  1  A5 86                LDA     SYMLSP
002017  1  A4 87                LDY     SYMLSP+1
002019  1  20 87 0F             JSR     LITLOD          ;litload(symlocsp)
00201C  1  A9 2D                LDA     #OPN
00201E  1  4C F6 0C             JMP     GENERT          ;generate(opn)
002021  1               ;100	|
002021  1               PR100
002021  1  A9 00                LDA     #0
002023  1  A8                   TAY
002024  1  4C 7E 0F             JMP     LITERL          ;literal(0)
002027  1               ;104	<dimension variable>::=<dim var head><expression>
002027  1               PR104
002027  1  20 5B 16             JSR     CHKTY5          ;chktyp5
00202A  1  A5 8A                LDA     SYMLMP
00202C  1  A4 8B                LDY     SYMLMP+1
00202E  1  85 A7                STA     BASE
002030  1  84 A8                STY     BASE+1          ;base=symlocsp
002032  1  60                   RTS
002033  1               ;105	<dim var head>::=<identifier>(
002033  1               PR105
002033  1  A5 7C                LDA     MP
002035  1  20 BC 15             JSR     NRMLKU          ;if not normal$lookup(mp)
002038  1  F0 0A                BEQ     PR105A          ;then
00203A  1  2C 16 34             BIT     PASS1           ;if not pass 1
00203D  1  10 05                BPL     PR105A          ;then
00203F  1  A9 01                LDA     #1              ;identifier in dim previously defined
002041  1  20 AB 0A             JSR     ERROR
002044  1               PR105A
002044  1  A9 02                LDA     #SUBVAR
002046  1  20 2F 11             JSR     SETTYP          ;setype(subvar)
002049  1  2C 16 34             BIT     PASS1           ;if not pass 1
00204C  1  10 06                BPL     *+8             ;then
00204E  1  20 C8 15             JSR     CNTPRT
002051  1  20 9F 10             JSR     SETRSV          ;setaddr(countprt)
002054  1  20 8D 11             JSR     GETADR
002057  1  20 7E 0F             JSR     LITERL          ;literal(getaddr)
00205A  1  A9 00                LDA     #0
00205C  1  20 D6 0C             JSR     STTYMP          ;settypemp(0)
00205F  1  A5 A7                LDA     BASE
002061  1  A4 A8                LDY     BASE+1
002063  1  4C BE 0C             JMP     STSLMP          ;setsymlocmp(base)
002066  1               ;108	<close list>::=<expression>
002066  1               PR108
002066  1  A5 83                LDA     STYPSP          ;if stypesp
002068  1  C9 32                CMP     #STRING         ;<> string
00206A  1  D0 03                BNE     *+5             ;then
00206C  1  20 48 16             JSR     MFERR           ;must be floating
00206F  1  A9 5B                LDA     #RON
002071  1  20 F6 0C             JSR     GENERT          ;generate(ron)
002074  1  A9 40                LDA     #CLS
002076  1  4C F6 0C             JMP     GENERT          ;generate(cls)
002079  1               ;110	<read statement>::= read <file option><read list>
002079  1               PR110
002079  1  2C 21 34             BIT     FILEIO          ;if not fileio
00207C  1  10 0A                BPL     PR110A          ;then
00207E  1  A9 3E                LDA     #EDR
002080  1  20 F6 0C             JSR     GENERT          ;generate(edr)
002083  1               ;117	|
002083  1               PR117
002083  1  A9 00                LDA     #FALSE
002085  1  8D 21 34             STA     FILEIO          ;fileio=false
002088  1               PR110A
002088  1  60                   RTS
002089  1               ;112	<input statement>::=input <prompt option><read list>
002089  1               PR112
002089  1  A9 27                LDA     #ECR
00208B  1  20 F6 0C             JSR     GENERT          ;generate(ecr)
00208E  1  A9 00                LDA     #FALSE
002090  1  85 47                STA     INPSTM          ;inputstmt=false
002092  1  60                   RTS
002093  1               ;113	<prompt option>::=<constant>
002093  1               PR113
002093  1  20 39 19             JSR     PUTFLD          ;put$field
002096  1  4C 89 16             JMP     SEINPU          ;setup$input
002099  1               ;119	|print <file option><file list>
002099  1               PR119
002099  1  A9 3F                LDA     #EDW
00209B  1  20 F6 0C             JSR     GENERT          ;generate(edw)
00209E  1  A9 00                LDA     #FALSE
0020A0  1  8D 21 34             STA     FILEIO          ;fileio=false
0020A3  1  60                   RTS
0020A4  1               ;126	|
0020A4  1               PR126
0020A4  1  A9 34                LDA     #DBF
0020A6  1  4C F6 0C             JMP     GENERT          ;generate(dbf)
0020A9  1               ;127	<file option>::= # <expression>
0020A9  1               PR127
0020A9  1  A9 FF                LDA     #TRUE
0020AB  1  8D 21 34             STA     FILEIO          ;fileio=true
0020AE  1  A9 5B                LDA     #RON
0020B0  1  20 F6 0C             JSR     GENERT          ;generate(ron)
0020B3  1  A9 26                LDA     #RDB
0020B5  1  4C F6 0C             JMP     GENERT          ;generate(rdb)
0020B8  1               ;128	| # <expression>,<expression>;
0020B8  1               PR128
0020B8  1  A9 FF                LDA     #TRUE
0020BA  1  8D 21 34             STA     FILEIO          ;fileio=true
0020BD  1  A9 5B                LDA     #RON
0020BF  1  20 F6 0C             JSR     GENERT          ;generate(ron)
0020C2  1  A9 13                LDA     #XCH
0020C4  1  20 F6 0C             JSR     GENERT          ;generate(xch)
0020C7  1  A9 5B                LDA     #RON
0020C9  1  20 F6 0C             JSR     GENERT          ;generate(ron)
0020CC  1  A9 25                LDA     #RDF
0020CE  1  4C F6 0C             JMP     GENERT          ;generate(rdf)
0020D1  1               ;130	| ,
0020D1  1               PR130
0020D1  1  2C 21 34             BIT     FILEIO          ;if not fileio
0020D4  1  10 01                BPL     *+3             ;then
0020D6  1  60                   RTS
0020D7  1  A9 35                LDA     #NSP
0020D9  1  4C F6 0C             JMP     GENERT          ;generate(nsp)
0020DC  1               ;133	|<on gosub> <label list>
0020DC  1               PR133
0020DC  1  20 F1 16             JSR     GENON2          ;gen$on$2
0020DF  1  A9 00                LDA     #0
0020E1  1  4C E3 15             JMP     ENCMLB          ;enter$compiler$label(0)
0020E4  1               ;135	<on gosub>::= on <expression> <gosub>
0020E4  1               PR135
0020E4  1  20 FC 15             JSR     STCMLB          ;set$compiler$label
0020E7  1  20 8D 11             JSR     GETADR
0020EA  1  20 7E 0F             JSR     LITERL          ;literal(getaddr)
0020ED  1  A9 60                LDA     #ADJ
0020EF  1  20 F6 0C             JSR     GENERT          ;generate(adj)
0020F2  1  A9 13                LDA     #XCH
0020F4  1  20 F6 0C             JSR     GENERT          ;generate(xch)
0020F7  1  4C D4 16             JMP     GENON           ;gen$on
0020FA  1               ;136	<label list>::=<number>
0020FA  1               PR136
0020FA  1  20 0E 18             JSR     RESLBL          ;resolve$label
0020FD  1  A9 01                LDA     #1
0020FF  1  4C C4 0C             JMP     STTYSP          ;settypesp(1)
002102  1               ;137	|<label list>,<number>
002102  1               PR137
002102  1  20 0E 18             JSR     RESLBL          ;resolve$label
002105  1  A6 82                LDX     TYPEMP
002107  1  E8                   INX
002108  1  8A                   TXA
002109  1  4C D6 0C             JMP     STTYMP          ;settypemp(typemp+1)
00210C  1               ;138	<gosub statement>::=<gosub><number>
00210C  1               PR138
00210C  1  A9 FF                LDA     #TRUE
00210E  1  85 48                STA     GSBSTM          ;gosubstmt=true
002110  1  20 0E 18             JSR     RESLBL          ;resolve$label
002113  1  A9 00                LDA     #FALSE
002115  1  85 48                STA     GSBSTM          ;gosubstmt=false
002117  1  60                   RTS
002118  1               ;147	<out statement>::= out <expression>,<expression>
002118  1               PR147
002118  1  A9 31                LDA     #FLOTPT         ;if stypemp1
00211A  1  C5 84                CMP     STYPM1          ;<> floatpt
00211C  1  D0 04                BNE     *+6             ;then
00211E  1  C5 83                CMP     STYPSP          ;if stypesp = floatpt
002120  1  F0 03                BEQ     *+5             ;then ok
002122  1  4C 48 16             JMP     MFERR           ;must be floating error
002125  1  A9 5B                LDA     #RON
002127  1  20 F6 0C             JSR     GENERT          ;generate(ron)
00212A  1  A9 13                LDA     #XCH
00212C  1  20 F6 0C             JSR     GENERT          ;generate(xch)
00212F  1  A9 5B                LDA     #RON
002131  1  20 F6 0C             JSR     GENERT          ;generate(ron)
002134  1  A9 28                LDA     #POT
002136  1  4C F6 0C             JMP     GENERT          ;generate(pot)
002139  1               ;148	<return statement>::= return
002139  1               PR148
002139  1  A9 1F                LDA     #RTN
00213B  1  4C F6 0C             JMP     GENERT          ;generate(rtn)
00213E  1               ;149	<stop statement>::= stop
00213E  1               PR149
00213E  1  A9 10                LDA     #XIT
002140  1  4C F6 0C             JMP     GENERT          ;generate(xit)
002143  1               ;150	<end statement>::= end
002143  1               PR150
002143  1  2C 16 34             BIT     PASS1           ;if not pass 1
002146  1  10 33                BPL     PR150B          ;then
002148  1  A9 00                LDA     #FALSE
00214A  1  8D 16 34             STA     PASS1           ;pass1=false
00214D  1  A5 A9                LDA     FORCNT          ;if forcount
00214F  1  F0 09                BEQ     PR150A          ;= zero then ok
002151  1  A9 18                LDA     #24             ;else for without next error
002153  1  20 AB 0A             JSR     ERROR
002156  1  A9 00                LDA     #0
002158  1  85 A9                STA     FORCNT          ;forcount=0
00215A  1               PR150A
00215A  1  A9 2A                LDA     #'*'
00215C  1  20 F6 0C             JSR     GENERT          ;generate('*')
00215F  1  18                   CLC
002160  1  A5 B2                LDA     CODESI
002162  1  A4 B3                LDY     CODESI+1
002164  1  69 03                ADC     #3
002166  1  90 01                BCC     *+3
002168  1  C8                   INY
002169  1  29 FC                AND     #$FC
00216B  1  20 75 0F             JSR     GENTWO          ;gen$two((codesize+3) and $fffc)
00216E  1  A5 45                LDA     DATACT
002170  1  A4 46                LDY     DATACT+1
002172  1  20 75 0F             JSR     GENTWO          ;gen$two(datact)
002175  1  20 C8 15             JSR     CNTPRT
002178  1  4C 75 0F             JMP     GENTWO          ;gen$two(countprt)
00217B  1               PR150B
00217B  1  A5 4D                LDA     NXTCHR
00217D  1  C9 0D                CMP     #CR
00217F  1  F0 06                BEQ     *+8
002181  1  20 15 0A             JSR     GETCHR
002184  1  4C 7B 21             JMP     PR150B          ;while not eol
002187  1  A9 10                LDA     #XIT
002189  1  20 F6 0C             JSR     GENERT          ;generate(xit)
00218C  1  A9 7F                LDA     #$7F
00218E  1  20 F6 0C             JSR     GENERT          ;generate($7f)
002191  1  20 94 09             JSR     WRTINT          ;write$int$file
002194  1  20 4E 09             JSR     CLSINT          ;close$int$file
002197  1  A5 43                LDA     ERRCNT
002199  1  A4 44                LDY     ERRCNT+1
00219B  1  20 70 08             JSR     PRNDEC          ;printdec(errorcount)
00219E  1  A9 AB                LDA     #<ERDMSG
0021A0  1  A0 33                LDY     #>ERDMSG
0021A2  1  20 FC 08             JSR     PRNMSG          ;print('errors detected')
0021A5  1  20 34 08             JSR     CRLF
0021A8  1  4C 00 01             JMP     BOOT
0021AB  1               ;151	<restore statement>::= restore
0021AB  1               PR151
0021AB  1  A9 2F                LDA     #RST
0021AD  1  4C F6 0C             JMP     GENERT          ;generate(rst)
0021B0  1               ;152	<randomize statement>::= randomize
0021B0  1               PR152
0021B0  1  A9 4D                LDA     #IRN
0021B2  1  4C F6 0C             JMP     GENERT          ;generate(irn)
0021B5  1               ;getin1  (does ay=index1(state))
0021B5  1               GETIN1
0021B5  1  A5 79                LDA     STATE
0021B7  1  A4 7A                LDY     STATE+1         ;get state
0021B9  1  0A                   ASL     A
0021BA  1  AA                   TAX
0021BB  1  98                   TYA
0021BC  1  2A                   ROL     A
0021BD  1  A8                   TAY
0021BE  1  18                   CLC
0021BF  1  8A                   TXA
0021C0  1  69 C4                ADC     #<INDEX1        ;add state*2 since is word addressing
0021C2  1  8D D9 21             STA     GT+1
0021C5  1  98                   TYA
0021C6  1  69 2A                ADC     #>INDEX1
0021C8  1  8D DA 21             STA     GT+2
0021CB  1  A2 00                LDX     #0
0021CD  1  20 D8 21             JSR     GT              ;get low
0021D0  1  48                   PHA
0021D1  1  E8                   INX
0021D2  1  20 D8 21             JSR     GT              ;get high
0021D5  1  A8                   TAY
0021D6  1  68                   PLA
0021D7  1  60                   RTS
0021D8  1               ;general purpose lda abs,x routine
0021D8  1               GT
0021D8  1  BD FF FF             LDA     $FFFF,X
0021DB  1  60                   RTS
0021DC  1               ;getin2 (does ay=index2(state))
0021DC  1               GETIN2
0021DC  1  A5 79                LDA     STATE
0021DE  1  A4 7A                LDY     STATE+1
0021E0  1  18                   CLC
0021E1  1  69 70                ADC     #<INDEX2
0021E3  1  8D ED 21             STA     G2+1
0021E6  1  98                   TYA
0021E7  1  69 2D                ADC     #>INDEX2
0021E9  1  8D EE 21             STA     G2+2
0021EC  1               G2
0021EC  1  AD FF FF             LDA     $FFFF
0021EF  1  A0 00                LDY     #0              ;y always zero
0021F1  1  60                   RTS
0021F2  1               ;incsp
0021F2  1               INCSP
0021F2  1  E6 7B                INC     SP
0021F4  1  A5 7B                LDA     SP              ;bump and get
0021F6  1  C9 20                CMP     #PSTKSZ         ;compare to max
0021F8  1  F0 01                BEQ     *+3             ;if = then
0021FA  1  60                   RTS                     ;else ok
0021FB  1  A9 12                LDA     #18             ;stack overflow error
0021FD  1  4C AB 0A             JMP     ERROR
002200  1               ;lookahead
002200  1               LAHEAD
002200  1  24 7E                BIT     NOLOOK          ;if not nolook
002202  1  10 07                BPL     LAHEAX          ;then done
002204  1  20 B6 0D             JSR     SCANNR          ;scanner
002207  1  A9 00                LDA     #FALSE
002209  1  85 7E                STA     NOLOOK          ;nolook=false
00220B  1               LAHEAX
00220B  1  60                   RTS
00220C  1               ;set$varc$i ---- set varc and increment varindex
00220C  1               STVRCI
00220C  1  A6 7F                LDX     VARIND
00220E  1  9D 10 36             STA     VARC,X          ;save
002211  1  E8                   INX
002212  1  86 7F                STX     VARIND          ;bump index
002214  1  E0 65                CPX     #VARCSZ+1       ;if too big
002216  1  B0 01                BCS     *+3             ;then error
002218  1  60                   RTS
002219  1  A9 15                LDA     #21             ;varc overflow
00221B  1  4C AB 0A             JMP     ERROR
00221E  1               ;initialize all of system
00221E  1               INTLZ
00221E  1  20 A2 0F             JSR     INSYMT          ;in$symtbl
002221  1  20 28 15             JSR     INSYN           ;in$syn
002224  1  4C 1A 0B             JMP     INSCAN
002227  1               ;MAIN PROGRAM
002227  1               MAIN
002227  1  A2 02                LDX     #2              ;clear page zero
002229  1  A9 00                LDA     #0
00222B  1               PZC
00222B  1                       .IFDEF   DUODYNE
00222B  1  9F 00 00 00          STA     f:0,X
00222F  1                       .ELSE
00222F  1                       STA     0,X
00222F  1                       .ENDIF
00222F  1  E8                   INX
002230  1  E0 C6                CPX     #LZ
002232  1  D0 F7                BNE     PZC
002234  1  A9 FF                LDA     #TRUE           ;initialize once
002236  1  8D 16 34             STA     PASS1
002239  1  8D 1B 34             STA     LWRUPR
00223C  1  A9 3A                LDA     #':'
00223E  1  85 74                STA     SEPRTR
002240  1  A9 80                LDA     #SRCRSZ
002242  1  85 75                STA     SRCIND
002244  1  A9 F1                LDA     #<OPNMSG
002246  1  A0 33                LDY     #>OPNMSG
002248  1  20 FC 08             JSR     PRNMSG          ;print opening message
00224B  1  20 34 08             JSR     CRLF
00224E  1  20 1E 22             JSR     INTLZ           ;initialize all
002251  1               ;do forever
002251  1               ;do while (pass1 or pass2)
002251  1               M10
002251  1  2C 16 34             BIT     PASS1           ;if pass 1
002254  1  30 08                BMI     M12             ;then go
002256  1  2C 17 34             BIT     PASS2           ;or if
002259  1  30 03                BMI     M12             ;pass2 go
00225B  1  4C 08 25             JMP     EWP1P2          ;else end of do while pass1 or pass2
00225E  1               M12
00225E  1  A9 FF                LDA     #TRUE
002260  1  85 7E                STA     NOLOOK          ;nolook=true
002262  1  8D 1F 34             STA     CMPLNG          ;compiling=true
002265  1  A9 79                LDA     #<STARTS
002267  1  A0 00                LDY     #>STARTS
002269  1  85 79                STA     STATE
00226B  1  84 7A                STY     STATE+1         ;state=startstate
00226D  1  A9 FF                LDA     #255
00226F  1  85 7B                STA     SP              ;sp=255
002271  1  A9 00                LDA     #0
002273  1  85 7F                STA     VARIND          ;varind=0
002275  1  8D F0 34             STA     VAR
002278  1               ;do while compiling
002278  1               M14
002278  1  2C 1F 34             BIT     CMPLNG          ;test for compiling
00227B  1  10 D4                BPL     M10             ;branch if not
00227D  1  A9 78                LDA     #<MAXRNO
00227F  1  C5 79                CMP     STATE
002281  1  A9 00                LDA     #>MAXRNO
002283  1  E5 7A                SBC     STATE+1         ;if state>maxrno
002285  1  B0 03                BCS     *+5             ;continue if ok
002287  1  4C 8B 23             JMP     M30             ;else try next
00228A  1  20 F2 21             JSR     INCSP
00228D  1  A5 7B                LDA     SP
00228F  1  0A                   ASL     A               ;word addressing
002290  1  AA                   TAX
002291  1  A5 79                LDA     STATE
002293  1  9D D0 35             STA     STSTAK,X
002296  1  A5 7A                LDA     STATE+1
002298  1  9D D1 35             STA     STSTAK+1,X      ;statestack(sp)=state
00229B  1  20 B5 21             JSR     GETIN1
00229E  1  85 98                STA     I
0022A0  1  84 99                STY     I+1             ;i=getin1
0022A2  1  20 00 22             JSR     LAHEAD          ;lookahead
0022A5  1  20 DC 21             JSR     GETIN2          ;index2(state)
0022A8  1  18                   CLC
0022A9  1  65 98                ADC     I
0022AB  1  85 9A                STA     J
0022AD  1  98                   TYA
0022AE  1  65 99                ADC     I+1
0022B0  1  85 9B                STA     J+1
0022B2  1  A5 9A                LDA     J
0022B4  1  D0 02                BNE     *+4
0022B6  1  C6 9B                DEC     J+1
0022B8  1  C6 9A                DEC     J               ;j=i-1+getin2
0022BA  1               M20
0022BA  1  A5 9A                LDA     J
0022BC  1  C5 98                CMP     I
0022BE  1  A5 9B                LDA     J+1
0022C0  1  E5 99                SBC     I+1             ;if i>j
0022C2  1  90 B4                BCC     M14             ;go to while compiling
0022C4  1  18                   CLC
0022C5  1  A5 98                LDA     I
0022C7  1  69 18                ADC     #<READ1
0022C9  1  85 9F                STA     I2
0022CB  1  A5 99                LDA     I+1
0022CD  1  69 25                ADC     #>READ1
0022CF  1  85 A0                STA     I2+1
0022D1  1  A0 00                LDY     #0
0022D3  1  8B DA A2 01          LDAINDIRECTY I2         ;a=read(i)
0022D7  1  B5 9F C9 00  
0022DB  1  D0 04 A2 00  
0022E9  1  C5 49                CMP     TOKEN           ;if not token
0022EB  1  F0 03 4C 71          LBNE    M23             ;then
0022EF  1  23           
0022F0  1  A5 7F                LDA     VARIND          ;get varindex
0022F2  1  A6 7B                LDX     SP
0022F4  1  9D F0 34             STA     VAR,X           ;set var(sp)
0022F7  1  A2 00                LDX     #0
0022F9  1  86 9E                STX     INDEX           ;index=0
0022FB  1               M22
0022FB  1                       .IFDEF  DUODYNE
0022FB  1  9F 4E 00 00          STA     F:ACCUM,X         ;store it
0022FF  1                       .ELSE
0022FF  1                       STA     ACCUM,X         ;store it
0022FF  1                       .ENDIF
0022FF  1  20 0C 22             JSR     STVRCI
002302  1  E6 9E                INC     INDEX           ;index=index+1
002304  1  A6 9E                LDX     INDEX
002306  1  E4 4E                CPX     ACCLEN          ;if < length
002308  1  90 F1                BCC     M22             ;then loop
00230A  1  F0 EF                BEQ     M22             ;loop also if equal
00230C  1  A6 7B                LDX     SP
00230E  1  A5 4C                LDA     HSHCDE
002310  1  9D D0 34             STA     HASH,X          ;hash(sp)=hashcode
002313  1  A5 4A                LDA     SUBTYP
002315  1  9D 30 35             STA     STYPE,X         ;stype(sp)=subtype
002318  1  A5 98                LDA     I
00231A  1  0A                   ASL     A
00231B  1  85 9F                STA     I2
00231D  1  A5 99                LDA     I+1
00231F  1  2A                   ROL     A
002320  1  85 A0                STA     I2+1            ;i2=i*2
002322  1  18                   CLC
002323  1  A5 9F                LDA     I2
002325  1  69 FC                ADC     #<READ2
002327  1  85 9F                STA     I2
002329  1  A5 A0                LDA     I2+1
00232B  1  69 26                ADC     #>READ2
00232D  1  85 A0                STA     I2+1            ;read2(i)
00232F  1  A0 00                LDY     #0
002331  1  8B DA A2 01          LDAINDIRECTY I2         ;low
002335  1  B5 9F C9 00  
002339  1  D0 04 A2 00  
002347  1  85 79                STA     STATE
002349  1  C8                   INY
00234A  1  8B DA A2 01          LDAINDIRECTY I2
00234E  1  B5 9F C9 00  
002352  1  D0 04 A2 00  
002360  1  85 7A                STA     STATE+1         ;state=read2(i)
002362  1  A9 FF                LDA     #TRUE
002364  1  85 7E                STA     NOLOOK          ;nolook=true
002366  1  A5 9A                LDA     J
002368  1  A4 9B                LDY     J+1
00236A  1  85 98                STA     I
00236C  1  84 99                STY     I+1
00236E  1  4C 82 23             JMP     M24
002371  1               M23
002371  1  A5 98                LDA     I
002373  1  C5 9A                CMP     J               ;ok if different
002375  1  D0 0B                BNE     M24
002377  1  A5 99                LDA     I+1
002379  1  C5 9B                CMP     J+1
00237B  1  D0 05                BNE     M24             ;ok if different
00237D  1  A9 0F                LDA     #15             ;no legal production
00237F  1  20 AB 0A             JSR     ERROR
002382  1               M24
002382  1  E6 98                INC     I               ;bump i and loop
002384  1  D0 02                BNE     *+4
002386  1  E6 99                INC     I+1
002388  1  4C BA 22             JMP     M20
00238B  1               M30
00238B  1  A9 BD                LDA     #<MAXPNO        ;if state <= maxpno
00238D  1  C5 79                CMP     STATE
00238F  1  A9 00                LDA     #>MAXPNO
002391  1  E5 7A                SBC     STATE+1
002393  1  90 03                BCC     *+5
002395  1  4C 4B 24             JMP     M40
002398  1  20 DC 21             JSR     GETIN2          ;index2(state)
00239B  1  85 98                STA     I               ;ignore high
00239D  1  38                   SEC
00239E  1  A5 7B                LDA     SP
0023A0  1  E5 98                SBC     I
0023A2  1  85 7C                STA     MP              ;mp=sp-getin2
0023A4  1  A8                   TAY
0023A5  1  C8                   INY
0023A6  1  84 7D                STY     MPP1            ;mpp1=mp+1
0023A8  1  38                   SEC
0023A9  1  A5 79                LDA     STATE
0023AB  1  E9 BD                SBC     #<MAXPNO        ;parameter=state-maxpno
0023AD  1  20 31 1A             JSR     SYNTHE          ;synthesize(state-maxpno)
0023B0  1  2C 1F 34             BIT     CMPLNG          ;if compiling
0023B3  1  30 03                BMI     *+5             ;then go
0023B5  1  4C 51 22             JMP     M10             ;else go to do while pass 1 or pass 2
0023B8  1  A5 7C                LDA     MP
0023BA  1  85 7B                STA     SP              ;sp=mp
0023BC  1  20 B5 21             JSR     GETIN1
0023BF  1  85 98                STA     I
0023C1  1  84 99                STY     I+1             ;i=getin1
0023C3  1  A6 7B                LDX     SP
0023C5  1  BD F0 34             LDA     VAR,X
0023C8  1  85 7F                STA     VARIND          ;varindex=var(sp)
0023CA  1  8A                   TXA
0023CB  1  0A                   ASL     A
0023CC  1  AA                   TAX                     ;word addressing
0023CD  1  BD D0 35             LDA     STSTAK,X
0023D0  1  85 9A                STA     J
0023D2  1  BD D1 35             LDA     STSTAK+1,X
0023D5  1  85 9B                STA     J+1             ;j=statestack(sp)
0023D7  1               M31
0023D7  1  A2 00                LDX     #0
0023D9  1  86 9D                STX     K+1             ;high must be zero
0023DB  1  A6 98                LDX     I
0023DD  1  BD 7C 26             LDA     APPLY1,X
0023E0  1  85 9C                STA     K
0023E2  1  F0 11                BEQ     M33             ;exit if k=0
0023E4  1  C5 9A                CMP     J
0023E6  1  D0 04                BNE     M32             ;ok if low k <> low j
0023E8  1  A5 9B                LDA     J+1
0023EA  1  F0 09                BEQ     M33             ;if =0 then j=k
0023EC  1               M32
0023EC  1  E6 98                INC     I
0023EE  1  D0 E7                BNE     M31             ;loop
0023F0  1  E6 99                INC     I+1
0023F2  1  4C D7 23             JMP     M31
0023F5  1               M33
0023F5  1  A5 98                LDA     I               ;ignore high i
0023F7  1  0A                   ASL     A
0023F8  1  85 9F                STA     I2
0023FA  1  A5 99                LDA     I+1
0023FC  1  2A                   ROL     A
0023FD  1  85 A0                STA     I2+1
0023FF  1  18                   CLC
002400  1  A5 9F                LDA     I2
002402  1  69 C4                ADC     #<APPLY2
002404  1  85 9F                STA     I2
002406  1  A5 A0                LDA     I2+1
002408  1  69 29                ADC     #>APPLY2
00240A  1  85 A0                STA     I2+1
00240C  1  A0 00                LDY     #0
00240E  1  8B DA A2 01          LDAINDIRECTY I2
002412  1  B5 9F C9 00  
002416  1  D0 04 A2 00  
002424  1  85 79                STA     STATE
002426  1  C8                   INY
002427  1  8B DA A2 01          LDAINDIRECTY I2
00242B  1  B5 9F C9 00  
00242F  1  D0 04 A2 00  
00243D  1  85 7A                STA     STATE+1         ;state=apply2(i)
00243F  1  05 79                ORA     STATE
002441  1  D0 05                BNE     *+7             ;if not zero then
002443  1  A9 00                LDA     #FALSE
002445  1  8D 1F 34             STA     CMPLNG          ;compiling=false
002448  1  4C 78 22             JMP     M14
00244B  1               M40
00244B  1  A9 AF                LDA     #<MAXLNO        ;if state
00244D  1  C5 79                CMP     STATE
00244F  1  A9 00                LDA     #>MAXLNO
002451  1  E5 7A                SBC     STATE+1         ;> maxlno
002453  1  90 02 80 03          LBCC     M50            ;then go to next
002457  1  4C EB 24     
00245A  1  20 B5 21             JSR     GETIN1
00245D  1  85 98                STA     I
00245F  1  84 99                STY     I+1             ;i=getin1
002461  1  20 00 22             JSR     LAHEAD          ;lookahead
002464  1               M41
002464  1  A2 00                LDX     #0
002466  1  86 9D                STX     K+1
002468  1  18                   CLC
002469  1  A5 98                LDA     I
00246B  1  69 E5                ADC     #<LOOK1
00246D  1  85 9F                STA     I2
00246F  1  A5 99                LDA     I+1
002471  1  69 25                ADC     #>LOOK1
002473  1  85 A0                STA     I2+1
002475  1  A0 00                LDY     #0
002477  1  8B DA A2 01          LDAINDIRECTY I2         ;a=look1(i)
00247B  1  B5 9F C9 00  
00247F  1  D0 04 A2 00  
00248D  1  85 9C                STA     K
00248F  1  F0 0D                BEQ     M42             ;exit if k=0
002491  1  C5 49                CMP     TOKEN
002493  1  F0 09                BEQ     M42             ;or if =token
002495  1  E6 98                INC     I               ;bump and loop
002497  1  D0 CB                BNE     M41
002499  1  E6 99                INC     I+1
00249B  1  4C 64 24             JMP     M41
00249E  1               M42
00249E  1  A5 98                LDA     I               ;word addressing
0024A0  1  0A                   ASL     A
0024A1  1  85 9F                STA     I2
0024A3  1  A5 99                LDA     I+1
0024A5  1  2A                   ROL     A
0024A6  1  85 A0                STA     I2+1
0024A8  1  18                   CLC
0024A9  1  A5 9F                LDA     I2              ;add start
0024AB  1  69 96                ADC     #<LOOK2
0024AD  1  85 9F                STA     I2
0024AF  1  A5 A0                LDA     I2+1
0024B1  1  69 28                ADC     #>LOOK2
0024B3  1  85 A0                STA     I2+1
0024B5  1  A0 00                LDY     #0
0024B7  1  8B DA A2 01          LDAINDIRECTY I2         ;low
0024BB  1  B5 9F C9 00  
0024BF  1  D0 04 A2 00  
0024CD  1  85 79                STA     STATE
0024CF  1  C8                   INY
0024D0  1  8B DA A2 01          LDAINDIRECTY I2
0024D4  1  B5 9F C9 00  
0024D8  1  D0 04 A2 00  
0024E6  1  85 7A                STA     STATE+1
0024E8  1  4C 78 22             JMP     M14
0024EB  1               M50
0024EB  1  20 F2 21             JSR     INCSP
0024EE  1  20 DC 21             JSR     GETIN2
0024F1  1  48                   PHA                     ;save low
0024F2  1  A5 7B                LDA     SP
0024F4  1  0A                   ASL     A               ;word addressing
0024F5  1  AA                   TAX
0024F6  1  68                   PLA
0024F7  1  9D D0 35             STA     STSTAK,X        ;statestack(sp)=getin2
0024FA  1  98                   TYA
0024FB  1  9D D1 35             STA     STSTAK+1,X
0024FE  1  20 B5 21             JSR     GETIN1
002501  1  85 79                STA     STATE
002503  1  84 7A                STY     STATE+1         ;state=getin1
002505  1  4C 78 22             JMP     M14
002508  1               ;end of do while pass 1 or pass 2
002508  1               EWP1P2
002508  1  A9 FF                LDA     #TRUE
00250A  1  8D 19 34             STA     LSTSRC          ;listsource=true
00250D  1  20 1E 22             JSR     INTLZ           ;initialize
002510  1  A9 FF                LDA     #TRUE
002512  1  8D 17 34             STA     PASS2           ;pass2=true
002515  1  4C 51 22             JMP     M10             ;do forever
002518  1               ;parser state tables
002518  1               READ1
002518  1  00 31 0A 0D          .BYTE   0,49,10,13,2,49,50,52,53,54,49,13,22,32,2,3,7,27,30,49,50,52,53
00251C  1  02 31 32 34  
002520  1  35 36 31 0D  
00252F  1  36 02 03 07          .BYTE   54,2,3,7,30,49,50,52,53,54,54,52,12,52,2,3,7,49,50,52,53,54,12
002533  1  1E 31 32 34  
002537  1  35 36 36 34  
002546  1  34 31 31 32          .BYTE   52,49,49,50,2,3,7,12,30,49,50,52,53,54,2,2,2,9,5,9,49,4,8,49,16
00254A  1  02 03 07 0C  
00254E  1  1E 31 32 34  
00255F  1  14 1C 1D 1F          .BYTE   20,28,29,31,35,36,37,38,40,42,43,44,45,46,48,49,51,52,49,14,6
002563  1  23 24 25 26  
002567  1  28 2A 2B 2C  
002574  1  16 0D 34 09          .BYTE   22,13,52,9,52,9,23,9,21,33,41,16,21,33,36,43,9,21,33,5,9,21,33
002578  1  34 09 17 09  
00257C  1  15 21 29 10  
00258B  1  05 15 21 05          .BYTE   5,21,33,5,9,21,33,5,9,21,33,6,9,21,33,21,33,39,21,33,41,5,21,33
00258F  1  09 15 21 05  
002593  1  09 15 21 06  
0025A3  1  06 15 21 09          .BYTE   6,21,33,9,6,9,16,17,20,25,26,27,28,29,31,35,36,37,38,40,42,43
0025A7  1  06 09 10 11  
0025AB  1  14 19 1A 1B  
0025B9  1  2C 2D 2E 30          .BYTE   44,45,46,48,51,52,2,16,20,28,29,31,35,36,37,38,40,42,43,44,45
0025BD  1  33 34 02 10  
0025C1  1  14 1C 1D 1F  
0025CE  1  2E 30 33 34          .BYTE   46,48,51,52,52,13,24,11,34,9,2,1,3,7,10,13,15,18,19,3,7,9,0
0025D2  1  34 0D 18 0B  
0025D6  1  22 09 02 01  
0025E5  1               LOOK1
0025E5  1  00 31 00 0A          .BYTE   0,49,0,10,13,0,13,0,11,23,34,0,52,0,12,52,0,49,50,0,6,9,11,23
0025E9  1  0D 00 0D 00  
0025ED  1  0B 17 22 00  
0025FD  1  22 00 02 00          .BYTE   34,0,2,0,2,0,9,0,4,8,0,4,8,0,4,8,0,4,8,0,4,8,0,11,23,34,0,14,0
002601  1  02 00 09 00  
002605  1  04 08 00 04  
00261A  1  0E 00 0E 00          .BYTE   14,0,14,0,9,0,9,0,9,0,9,0,9,0,21,33,0,21,33,0,21,33,0,21,33,0
00261E  1  09 00 09 00  
002622  1  09 00 09 00  
002634  1  15 21 27 00          .BYTE   21,33,39,0,21,33,0,21,33,0,21,33,0,23,0,21,33,0,21,33,0,9,0,9
002638  1  15 21 00 15  
00263C  1  21 00 15 21  
00264C  1  00 06 09 00          .BYTE   0,6,9,0,52,0,11,23,0,11,23,34,0,2,0,11,23,0,52,0,24,0,24,0,11
002650  1  34 00 0B 17  
002654  1  00 0B 17 22  
002665  1  00 17 00 0B          .BYTE   0,23,0,11,0,9,0,2,0,1,3,7,10,13,15,18,19,0,3,7,0,9,0
002669  1  00 09 00 02  
00266D  1  00 01 03 07  
00267C  1               APPLY1
00267C  1  00 00 00 00          .BYTE   0,0,0,0,55,105,0,19,0,0,32,47,0,0,3,4,12,14,16,17,20,21,22,26
002680  1  37 69 00 13  
002684  1  00 00 20 2F  
002694  1  1B 22 24 26          .BYTE   27,34,36,38,40,98,100,102,103,114,116,0,0,46,0,28,0,33,0,63,0,5
002698  1  28 62 64 66  
00269C  1  67 72 74 00  
0026AA  1  06 08 09 00          .BYTE   6,8,9,0,7,10,0,23,0,13,19,32,35,47,55,99,101,105,106,0,0,0,0,0
0026AE  1  07 0A 00 17  
0026B2  1  00 0D 13 20  
0026C2  1  27 00 00 00          .BYTE   39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,99
0026C6  1  00 00 00 00  
0026CA  1  00 00 00 00  
0026E0  1  6A 00 00 00          .BYTE   106,0,0,0,0,0,40,0,0,0,0,0,0,62,0,0,74,0,74,0,0,0,0,0,0,0,0,0
0026E4  1  00 00 28 00  
0026E8  1  00 00 00 00  
0026FC  1               READ2
0026FC  1  00 00 BF 00          .WORD   0,191,264,260,3,255,256,129,254,253,326,258,329,331,3,5,8,31
002700  1  08 01 04 01  
002704  1  03 00 FF 00  
002720  1  21 00 FF 00          .WORD   33,255,256,129,254,253,3,5,8,33,255,256,129,254,253,279,42,21
002724  1  00 01 81 00  
002728  1  FE 00 FD 00  
002744  1  81 00 03 00          .WORD   129,3,5,8,255,256,129,254,253,20,129,273,255,256,3,5,8,20,33
002748  1  05 00 08 00  
00274C  1  FF 00 00 01  
00276A  1  FF 00 00 01          .WORD   255,256,129,254,253,247,294,4,335,280,283,320,7,10,327,24,26
00276E  1  81 00 FE 00  
002772  1  FD 00 F7 00  
00278C  1  0C 01 20 00          .WORD   268,32,34,285,328,125,126,338,38,330,127,128,337,340,275,341
002790  1  22 00 1D 01  
002794  1  48 01 7D 00  
0027AC  1  81 00 45 01          .WORD   129,325,23,302,27,220,130,17,131,13,190,14,223,224,277,24,223
0027B0  1  17 00 2E 01  
0027B4  1  1B 00 DC 00  
0027CE  1  E0 00 48 01          .WORD   224,328,330,12,223,224,246,248,223,224,244,223,224,249,252,223
0027D2  1  4A 01 0C 00  
0027D6  1  DF 00 E0 00  
0027EE  1  E0 00 25 01          .WORD   224,293,295,223,224,316,16,223,224,223,224,36,223,224,37,288
0027F2  1  27 01 DF 00  
0027F6  1  E0 00 3C 01  
00280E  1  DF 00 E0 00          .WORD   223,224,317,223,224,15,318,319,24,25,26,29,30,339,268,32,34,285
002812  1  3D 01 DF 00  
002816  1  E0 00 0F 00  
002832  1  48 01 7D 00          .WORD   328,125,126,338,38,330,127,128,337,340,341,129,251,24,26,268,32
002836  1  7E 00 52 01  
00283A  1  26 00 4A 01  
002854  1  22 00 1D 01          .WORD   34,285,328,125,126,338,38,330,127,128,337,340,341,129,45,22,28
002858  1  48 01 7D 00  
00285C  1  7E 00 52 01  
002876  1  7C 00 14 01          .WORD   124,276,286,282,122,6,9,123,257,259,261,265,6,9,11,0
00287A  1  1E 01 1A 01  
00287E  1  7A 00 06 00  
002896  1               LOOK2
002896  1  00 00 01 00          .WORD   0,1,176,2,2,263,18,262,177,177,177,19,334,333,35,35,178,39,39
00289A  1  B0 00 02 00  
00289E  1  02 00 07 01  
0028BC  1  B3 00 B4 00          .WORD   179,180,180,180,180,180,40,41,245,43,181,44,332,49,49,231,50,50
0028C0  1  B4 00 B4 00  
0028C4  1  B4 00 B4 00  
0028E0  1  EA 00 33 00          .WORD   234,51,51,235,52,52,232,53,53,233,182,182,182,55,57,236,58,237
0028E4  1  33 00 EB 00  
0028E8  1  34 00 34 00  
002904  1  3B 00 EE 00          .WORD   59,238,66,308,68,300,69,299,70,301,72,296,76,76,297,77,77,309
002908  1  42 00 34 01  
00290C  1  44 00 2C 01  
002928  1  4E 00 4E 00          .WORD   78,78,219,84,84,312,85,85,85,183,87,87,336,88,88,298,89,89,310
00292C  1  DB 00 54 00  
002930  1  54 00 38 01  
00294E  1  16 01 5B 00          .WORD   278,91,93,93,313,94,94,269,95,321,96,322,97,97,184,99,185,186
002952  1  5D 00 5D 00  
002956  1  39 01 5E 00  
002972  1  BA 00 65 00          .WORD   186,101,314,314,314,102,104,250,187,187,105,106,188,109,221,110
002976  1  3A 01 3A 01  
00297A  1  3A 01 66 00  
002992  1  DE 00 6F 00          .WORD   222,111,193,274,112,113,272,115,284,117,189,118,118,118,118,118
002996  1  C1 00 12 01  
00299A  1  70 00 71 00  
0029B2  1  76 00 76 00          .WORD   118,118,118,229,119,119,230,120,290
0029B6  1  76 00 E5 00  
0029BA  1  77 00 77 00  
0029C4  1               APPLY2
0029C4  1  00 00 00 00          .WORD   0,0,161,71,169,170,168,199,198,200,218,267,201,98,80,90,151,152
0029C8  1  A1 00 47 00  
0029CC  1  A9 00 AA 00  
0029E8  1  5C 00 9B 00          .WORD   92,155,83,86,154,74,150,75,156,146,147,148,149,153,82,79,81,73
0029EC  1  53 00 56 00  
0029F0  1  9A 00 4A 00  
002A0C  1  2E 00 A7 00          .WORD   46,167,166,226,225,228,227,174,173,133,135,134,136,132,139,140
002A10  1  A6 00 E2 00  
002A14  1  E1 00 E4 00  
002A2C  1  8A 00 F0 00          .WORD   138,240,239,305,64,64,304,64,64,304,64,64,304,241,114,243,116
002A30  1  EF 00 31 01  
002A34  1  40 00 40 00  
002A4E  1  A3 00 3C 00          .WORD   163,60,242,63,202,61,47,266,194,271,164,137,197,172,108,107,204
002A52  1  F2 00 3F 00  
002A56  1  CA 00 3D 00  
002A70  1  41 00 AB 00          .WORD   65,171,287,196,175,292,291,103,205,145,206,210,165,143,144,142
002A74  1  1F 01 C4 00  
002A78  1  AF 00 24 01  
002A90  1  CF 00 9F 00          .WORD   207,159,141,307,100,160,162,208,213,56,62,158,157,209,323,48
002A94  1  8D 00 33 01  
002A98  1  64 00 A0 00  
002AB0  1  44 01 36 00          .WORD   324,54,203,67,216,212,211,195,214,215
002AB4  1  CB 00 43 00  
002AB8  1  D8 00 D4 00  
002AC4  1               INDEX1
002AC4  1  00 00 01 00          .WORD   0,1,2,24,24,4,4,4,4,4,4,34,24,36,24,10,24,24,11,168,24,24,24,4
002AC8  1  02 00 18 00  
002ACC  1  18 00 04 00  
002AF4  1  0C 00 0E 00          .WORD   12,14,24,24,24,33,34,35,36,37,24,45,24,47,24,48,50,60,61,62,63
002AF8  1  18 00 18 00  
002AFC  1  18 00 21 00  
002B1E  1  40 00 18 00          .WORD   64,24,36,66,67,67,67,67,67,69,70,89,90,90,90,91,92,89,37,93,94
002B22  1  24 00 42 00  
002B26  1  43 00 43 00  
002B48  1  5F 00 60 00          .WORD   95,96,97,97,97,98,99,100,103,108,100,100,100,111,115,118,122
002B4C  1  61 00 61 00  
002B50  1  61 00 62 00  
002B6A  1  7E 00 64 00          .WORD   126,100,130,133,100,100,100,136,100,139,100,100,142,142,143,24
002B6E  1  82 00 85 00  
002B72  1  64 00 64 00  
002B8A  1  24 00 18 00          .WORD   36,24,145,24,24,167,168,36,186,187,188,188,189,189,189,24,191
002B8E  1  91 00 18 00  
002B92  1  18 00 A7 00  
002BAC  1  18 00 C0 00          .WORD   24,192,193,201,203,1,3,6,8,12,14,17,20,26,28,30,32,35,38,41,44
002BB0  1  C1 00 C9 00  
002BB4  1  CB 00 01 00  
002BD6  1  2F 00 33 00          .WORD   47,51,53,55,57,59,61,63,65,67,70,73,76,79,83,86,89,92,94,97,100
002BDA  1  35 00 37 00  
002BDE  1  39 00 3B 00  
002C00  1  66 00 68 00          .WORD   102,104,107,109,112,116,118,121,123,125,127,129,131,133,135,137
002C04  1  6B 00 6D 00  
002C08  1  70 00 74 00  
002C20  1  92 00 95 00          .WORD   146,149,192,217,306,303,311,289,217,270,315,306,217,217,306,281
002C24  1  C0 00 D9 00  
002C28  1  32 01 2F 01  
002C40  1  01 00 02 00          .WORD   1,2,2,3,3,3,3,3,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,13
002C44  1  02 00 03 00  
002C48  1  03 00 03 00  
002C7E  1  0E 00 0E 00          .WORD   14,14,36,36,37,37,39,39,41,41,43,43,43,43,43,45,45,45,50,50,53
002C82  1  24 00 24 00  
002C86  1  25 00 25 00  
002CA8  1  35 00 35 00          .WORD   53,53,53,55,55,66,66,67,67,68,68,69,69,70,70,72,72,72,72,72,72
002CAC  1  35 00 37 00  
002CB0  1  37 00 42 00  
002CD2  1  48 00 48 00          .WORD   72,72,72,73,74,75,76,76,77,77,77,78,78,79,80,81,82,83,83,84,84
002CD6  1  48 00 49 00  
002CDA  1  4A 00 4B 00  
002CFC  1  55 00 56 00          .WORD   85,86,86,87,88,88,89,90,90,91,93,93,94,95,95,96,96,97,98,98,99
002D00  1  56 00 57 00  
002D04  1  58 00 58 00  
002D26  1  63 00 63 00          .WORD   99,99,102,102,103,103,103,104,104,105,105,106,106,108,108,109
002D2A  1  66 00 66 00  
002D2E  1  67 00 67 00  
002D46  1  6E 00 6E 00          .WORD   110,110,111,112,113,113,115,116,116,118,118,120,120,121,121,122
002D4A  1  6F 00 70 00  
002D4E  1  71 00 71 00  
002D66  1  7B 00 7C 00          .WORD   123,124,125,126,127
002D6A  1  7D 00 7E 00  
002D6E  1  7F 00        
002D70  1               INDEX2
002D70  1  00 01 02 09          .BYTE   0,1,2,9,9,6,6,6,6,6,6,1,9,1,9,1
002D74  1  09 06 06 06  
002D78  1  06 06 06 01  
002D80  1  09 09 01 12          .BYTE   9,9,1,18,9,9,9,6,2,10,9,9,9,1,1
002D84  1  09 09 09 06  
002D88  1  02 0A 09 09  
002D8F  1  01 01 08 09          .BYTE   1,1,8,9,2,9,1,9,2,10,1,1,1,1,2
002D93  1  02 09 01 09  
002D97  1  02 0A 01 01  
002D9E  1  09 01 01 02          .BYTE   9,1,1,2,2,2,2,2,1,19,1,1,1,1,1,1
002DA2  1  02 02 02 02  
002DA6  1  01 13 01 01  
002DAE  1  01 08 01 01          .BYTE   1,8,1,1,1,1,1,1,1,1,1,3,5,3,2,2
002DB2  1  01 01 01 01  
002DB6  1  01 01 01 03  
002DBE  1  02 04 03 04          .BYTE   2,4,3,4,4,4,2,3,3,2,2,2,3,2,3,2
002DC2  1  04 04 02 03  
002DC6  1  03 02 02 02  
002DCE  1  02 01 01 02          .BYTE   2,1,1,2,9,1,9,22,9,9,1,18,1,1,1
002DD2  1  09 01 09 16  
002DD6  1  09 09 01 12  
002DDD  1  01 01 01 02          .BYTE   1,1,1,2,1,9,1,9,1,8,2,1,2,3,2,4
002DE1  1  01 09 01 09  
002DE5  1  01 08 02 01  
002DED  1  02 03 03 06          .BYTE   2,3,3,6,2,2,2,3,3,3,3,3,4,2,2,2
002DF1  1  02 02 02 03  
002DF5  1  03 03 03 03  
002DFD  1  02 02 02 02          .BYTE   2,2,2,2,2,3,3,3,3,4,3,3,3,2,3,3
002E01  1  02 03 03 03  
002E05  1  03 04 03 03  
002E0D  1  02 02 03 02          .BYTE   2,2,3,2,3,4,2,3,2,2,2,2,2,2,2,2
002E11  1  03 04 02 03  
002E15  1  02 02 02 02  
002E1D  1  09 03 02 01          .BYTE   9,3,2,1,19,35,39,40,43,55,85,97
002E21  1  13 23 27 28  
002E25  1  2B 37 55 61  
002E29  1  63 65 69 6A          .BYTE   99,101,105,106,117,2,0,0,0,0,0,0
002E2D  1  75 02 00 00  
002E31  1  00 00 00 00  
002E35  1  00 00 02 00          .BYTE   0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
002E39  1  00 00 00 00  
002E3D  1  00 00 00 00  
002E44  1  00 00 00 00          .BYTE   0,0,0,0,0,0,1,1,1,0,2,0,0,0,2,0
002E48  1  00 00 01 01  
002E4C  1  01 00 02 00  
002E54  1  01 00 02 00          .BYTE   1,0,2,0,2,2,1,1,0,2,2,0,2,0,0,0
002E58  1  02 02 01 01  
002E5C  1  00 02 02 00  
002E64  1  02 00 02 01          .BYTE   2,0,2,1,2,2,0,1,2,0,0,0,0,0,1,0
002E68  1  02 02 00 01  
002E6C  1  02 00 00 00  
002E74  1  01 00 00 00          .BYTE   1,0,0,0,1,0,3,1,0,1,0,0,1,5,1,1
002E78  1  01 00 03 01  
002E7C  1  00 01 00 00  
002E84  1  02 02 03 01          .BYTE   2,2,3,1,2,0,0,2,1,0,2,1,2,0,1,0
002E88  1  02 00 00 02  
002E8C  1  01 00 02 01  
002E94  1  02 02 01 02          .BYTE   2,2,1,2,1,0,2,2,1,2,1,0,0,2,0,2
002E98  1  01 00 02 02  
002E9C  1  01 02 01 00  
002EA4  1  02 00 02 00          .BYTE   2,0,2,0,0,2,0,0,2,4,0,0,1,1,1,2
002EA8  1  00 02 00 00  
002EAC  1  02 04 00 00  
002EB4  1  02 00 02 01          .BYTE   2,0,2,1,0,1,0,1,1,0,0,2,3,0,0,0
002EB8  1  00 01 00 01  
002EBC  1  01 00 00 02  
002EC4  1  00 00                .BYTE   0,0
002EC6  1               ;reserved word tables
002EC6  1               ;length=1
002EC6  1               LNG1
002EC6  1  0D 3C 28 2B          .BYTE   CR,"<(+*)-,=/",semico,">:#^"
002ECA  1  2A 29 2D 2C  
002ECE  1  3D 2F 3B 3E  
002ED5  1               ;length=2
002ED5  1               LNG2
002ED5  1  49 46 54 4F          .BYTE   "IFTOGOONOREQLTGTLEGENE"
002ED9  1  47 4F 4F 4E  
002EDD  1  4F 52 45 51  
002EEB  1               ;length=3
002EEB  1               LNG3
002EEB  1  46 4F 52 4C          .BYTE   "FORLETREMDIMDEFNOTAND"
002EEF  1  45 54 52 45  
002EF3  1  4D 44 49 4D  
002F00  1  54 41 4E 53          .BYTE   "TANSINCOSSQRTABLOGLEN"
002F04  1  49 4E 43 4F  
002F08  1  53 53 51 52  
002F15  1  46 52 45 41          .BYTE   "FREATNABSEXPINTEND"
002F19  1  54 4E 41 42  
002F1D  1  53 45 58 50  
002F27  1  50 4F 53 52          .BYTE   "POSRNDSGNASCVALXORSUB"
002F2B  1  4E 44 53 47  
002F2F  1  4E 41 53 43  
002F3C  1               ;length=4
002F3C  1               LNG4
002F3C  1  50 45 45 4B          .BYTE   "PEEKPOKE"
002F40  1  50 4F 4B 45  
002F44  1  54 48 45 4E          .BYTE   "THENREADGOTOELSENEXTSTOPDATA"
002F48  1  52 45 41 44  
002F4C  1  47 4F 54 4F  
002F60  1  46 49 4C 45          .BYTE   "FILECHR$MID$STEPSTR$CALLSINH"
002F64  1  43 48 52 24  
002F68  1  4D 49 44 24  
002F7C  1               ;length=5
002F7C  1               LNG5
002F7C  1  50 52 49 4E          .BYTE   "PRINTINPUTGOSUBCLOSELEFT$"
002F80  1  54 49 4E 50  
002F84  1  55 54 47 4F  
002F95  1               ;length=6
002F95  1               LNG6
002F95  1  52 45 54 55          .BYTE   "RETURNRIGHT$REMARK"
002F99  1  52 4E 52 49  
002F9D  1  47 48 54 24  
002FA7  1               ;length=7
002FA7  1               LNG7
002FA7  1  52 45 53 54          .BYTE   "RESTORE"
002FAB  1  4F 52 45     
002FAE  1               ;length=9
002FAE  1               LNG9
002FAE  1  52 41 4E 44          .BYTE   "RANDOMIZE"
002FB2  1  4F 4D 49 5A  
002FB6  1  45           
002FB7  1               ;token table
002FB7  1               ;this table must be ordered in the same order as the reserved word table.  the
002FB7  1               ;first entry does not correspond to any valid token.
002FB7  1               TK
002FB7  1  00                   .BYTE   0
002FB8  1               ;length=1
002FB8  1  17 01 02 03          .BYTE   TCR,LESST,LPARN,TPLUS,ASTRK,RPARN,TMINUS,COMMA,EQUAL,SLASH
002FBC  1  04 05 07 09  
002FC0  1  0D 08        
002FC2  1  06 0A 0B 0C          .BYTE   SCOLN,GTRT,TCOLIN,POUND,EXPON
002FC6  1  0E           
002FC7  1               ;length=2
002FC7  1  11 16 10 14          .BYTE   TIF,TTO,TGO,TON,TOR,EQUAL,LESST,GTRT,TLEQ,TGEQ,TNE
002FCB  1  15 0D 01 0A  
002FCF  1  12 0F 13     
002FD2  1               ;length=3
002FD2  1  1C 1D 00 1A          .BYTE   TFOR,TLET,TREM,TDIM,TDEF,TNOT,TAND,72,69,70,73,74,78,84,76,71
002FD6  1  19 1E 18 48  
002FDA  1  45 46 49 4A  
002FE2  1  41 4B 42 1B          .BYTE   65,75,66,TEND,79,67,68,81,88,TXOR,TSUB
002FE6  1  4F 43 44 51  
002FEA  1  58 21 20     
002FED  1               ;length=4
002FED  1  50 1F                .BYTE   80,TOUT
002FEF  1  29 26 24 22          .BYTE   TTHEN,TREAD,TGOTO,TELSE,TNEXT,TSTOP,TDATA,TFILE,82,85,TSTEP
002FF3  1  25 28 63 23  
002FF7  1  52 55 27     
002FFA  1  57 59 5A             .BYTE   87,89,90
002FFD  1               ;length=5
002FFD  1  2D 2C 2B 2A          .BYTE   TPRNT,TINPT,TGOSB,TCLOS,83
003001  1  53           
003002  1               ;length=6
003002  1  2E 56 00             .BYTE   TRETN,86,TREM
003005  1               ;length=7
003005  1  30                   .BYTE   TREST
003006  1               ;length=9
003006  1  33                   .BYTE   TIRN
003007  1               ;token offset table
003007  1               OFFSET
003007  1  00 00 0F 25          .BYTE   0,0,15,37,118,182,207,225,232,232
00300B  1  76 B6 CF E1  
00300F  1  E8 E8        
003011  1               ;reserved word count table
003011  1               ;each entry is the number of reserved words of the associated length (0 and up)
003011  1               COUNT
003011  1  00 0F 0B 1B          .BYTE   0,15,11,27,16,5,3,1,0,1
003015  1  10 05 03 01  
003019  1  00 01        
00301B  1               ;each entry is the index into the token table for the first token of the
00301B  1               ;associated length (0 and up)
00301B  1               TKOS
00301B  1  00 00 0F 1A          .BYTE   0,0,15,26,53,69,74,77,78,78
00301F  1  35 45 4A 4D  
003023  1  4E 4E        
003025  1               ;
003025  1               ST
003025  1  01 01 00 01          .BYTE   1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,5,65,70,5,71,70,65,5,1,1
003029  1  01 01 01 01  
00302D  1  01 01 01 00  
00303F  1               ;error messages
00303F  1               ERM0
00303F  1  44 55 50 4C          .BYTE   "DUPLICATE LABELS OR "
003043  1  49 43 41 54  
003047  1  45 20 4C 41  
003053  1  53 59 4E 43          .BYTE   "SYNCHRONIZATION ERROR$"
003057  1  48 52 4F 4E  
00305B  1  49 5A 41 54  
003069  1               ERM1
003069  1  49 44 45 4E          .BYTE   "IDENTIFIER IN DIM "
00306D  1  54 49 46 49  
003071  1  45 52 20 49  
00307B  1  50 52 45 56          .BYTE   "PREVIOUSLY DEFINED$"
00307F  1  49 4F 55 53  
003083  1  4C 59 20 44  
00308E  1               ERM2
00308E  1  50 52 45 44          .BYTE   "PREDEFINED FUNCTION "
003092  1  45 46 49 4E  
003096  1  45 44 20 46  
0030A2  1  4E 41 4D 45          .BYTE   "NAME PREVIOUSLY DEFINED$"
0030A6  1  20 50 52 45  
0030AA  1  56 49 4F 55  
0030BA  1               ERM3
0030BA  1  46 4F 52 20          .BYTE   "FOR LOOP INDEX NOT SIMPLE"
0030BE  1  4C 4F 4F 50  
0030C2  1  20 49 4E 44  
0030D3  1  20 46 4C 4F          .BYTE   " FLOATING POINT VARIABLE$"
0030D7  1  41 54 49 4E  
0030DB  1  47 20 50 4F  
0030EC  1               ERM4
0030EC  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF PARAMETERS"
0030F0  1  52 52 45 43  
0030F4  1  54 20 4E 55  
00310A  1  20 49 4E 20          .BYTE   " IN FUNCTION REFERENCE$"
00310E  1  46 55 4E 43  
003112  1  54 49 4F 4E  
003121  1               ERM5
003121  1  49 4E 56 41          .BYTE   "INVALID PARAMETER TYPE IN "
003125  1  4C 49 44 20  
003129  1  50 41 52 41  
00313B  1  46 55 4E 43          .BYTE   "FUNCTION REFERENCE$"
00313F  1  54 49 4F 4E  
003143  1  20 52 45 46  
00314E  1               ERM6
00314E  1  55 4E 44 45          .BYTE   "UNDEFINED FUNCTION$"
003152  1  46 49 4E 45  
003156  1  44 20 46 55  
003161  1               ERM7
003161  1  49 4E 56 41          .BYTE   "INVALID CHARACTER$"
003165  1  4C 49 44 20  
003169  1  43 48 41 52  
003173  1               ERM8
003173  1  45 58 50 52          .BYTE   "EXPRESSION IN IF STATEMENT"
003177  1  45 53 53 49  
00317B  1  4F 4E 20 49  
00318D  1  20 4E 4F 54          .BYTE   " NOT FLOATING POINT$"
003191  1  20 46 4C 4F  
003195  1  41 54 49 4E  
0031A1  1               ERM9
0031A1  1  49 4C 4C 45          .BYTE   "ILLEGAL FLOATING POINT FORMAT$"
0031A5  1  47 41 4C 20  
0031A9  1  46 4C 4F 41  
0031BF  1               ERM10
0031BF  1  53 55 42 53          .BYTE   "SUBSCRIPTED VARIABLE NOT "
0031C3  1  43 52 49 50  
0031C7  1  54 45 44 20  
0031D8  1  50 52 45 56          .BYTE   "PREVIOUSLY DIMENSIONED$"
0031DC  1  49 4F 55 53  
0031E0  1  4C 59 20 44  
0031EF  1               ERM11
0031EF  1  41 52 52 41          .BYTE   "ARRAY NAME USED AS SIMPLE"
0031F3  1  59 20 4E 41  
0031F7  1  4D 45 20 55  
003208  1  20 56 41 52          .BYTE   " VARAIBLE$"
00320C  1  41 49 42 4C  
003210  1  45 24        
003212  1               ERM12
003212  1  53 54 52 49          .BYTE   "STRING EXPRESSION NOT ALLOWED$"
003216  1  4E 47 20 45  
00321A  1  58 50 52 45  
003230  1               ERM13
003230  1  4D 49 58 45          .BYTE   "MIXED MODE (STRING - FLOATING)"
003234  1  44 20 4D 4F  
003238  1  44 45 20 28  
00324E  1  20 45 58 50          .BYTE   " EXPRESSION$"
003252  1  52 45 53 53  
003256  1  49 4F 4E 24  
00325A  1               ERM14
00325A  1  4E 45 58 54          .BYTE   "NEXT VARIABLE DOES NOT "
00325E  1  20 56 41 52  
003262  1  49 41 42 4C  
003271  1  4D 41 54 43          .BYTE   "MATCH FOR$"
003275  1  48 20 46 4F  
003279  1  52 24        
00327B  1               ERM15
00327B  1  4E 4F 20 50          .BYTE   "NO PRODUCTION EXISTS$"
00327F  1  52 4F 44 55  
003283  1  43 54 49 4F  
003290  1               ERM16
003290  1  4E 45 58 54          .BYTE   "NEXT STATEMENT WITHOUT "
003294  1  20 53 54 41  
003298  1  54 45 4D 45  
0032A7  1  4D 41 54 43          .BYTE   "MATCHING FOR$"
0032AB  1  48 49 4E 47  
0032AF  1  20 46 4F 52  
0032B4  1               ERM17
0032B4  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF "
0032B8  1  52 52 45 43  
0032BC  1  54 20 4E 55  
0032C8  1  53 55 42 53          .BYTE   "SUBSCRIPTS$"
0032CC  1  43 52 49 50  
0032D0  1  54 53 24     
0032D3  1               ERM18
0032D3  1  43 4F 4D 50          .BYTE   "COMPILER STACK OVERFLOW$"
0032D7  1  49 4C 45 52  
0032DB  1  20 53 54 41  
0032EB  1               ERM19
0032EB  1  53 59 4D 42          .BYTE   "SYMBOL TABLE OVERFLOW$"
0032EF  1  4F 4C 20 54  
0032F3  1  41 42 4C 45  
003301  1               ERM20
003301  1  55 4E 44 45          .BYTE   "UNDEFINED LABEL$"
003305  1  46 49 4E 45  
003309  1  44 20 4C 41  
003311  1               ERM21
003311  1  56 41 52 43          .BYTE   "VARC TABLE OVERFLOW$"
003315  1  20 54 41 42  
003319  1  4C 45 20 4F  
003325  1               ERM22
003325  1  55 4E 54 45          .BYTE   "UNTERMINATED STRING$"
003329  1  52 4D 49 4E  
00332D  1  41 54 45 44  
003339  1               ERM23
003339  1  49 4E 56 41          .BYTE   "INVALID TYPE IN FILE"
00333D  1  4C 49 44 20  
003341  1  54 59 50 45  
00334D  1  20 49 44 45          .BYTE   " IDENTIFIER$"
003351  1  4E 54 49 46  
003355  1  49 45 52 24  
003359  1               ERM24
003359  1  46 4F 52 20          .BYTE   "FOR WITHOUT MATCHING NEXT$"
00335D  1  57 49 54 48  
003361  1  4F 55 54 20  
003373  1               ;error message table
003373  1               ERMTBL
003373  1  3F 30 69 30          .WORD   ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
003377  1  8E 30 BA 30  
00337B  1  EC 30 21 31  
003383  1  73 31 A1 31          .WORD   ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
003387  1  BF 31 EF 31  
00338B  1  12 32 30 32  
003393  1  90 32 B4 32          .WORD   ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
003397  1  D3 32 EB 32  
00339B  1  01 33 11 33  
0033A3  1  59 33                .WORD   ERM24
0033A5  1               ;messages and strings
0033A5  1               PRDMSG
0033A5  1  50 52 4F 44          .BYTE   "PROD $"
0033A9  1  20 24        
0033AB  1               ERDMSG
0033AB  1  20 45 52 52          .BYTE   " ERRORS DETECTED$"
0033AF  1  4F 52 53 20  
0033B3  1  44 45 54 45  
0033BC  1               DEMSG
0033BC  1  44 49 53 4B          .BYTE   "DISK ERROR - ABORTING $"
0033C0  1  20 45 52 52  
0033C4  1  4F 52 20 2D  
0033D3  1               BASSTR
0033D3  1  42 41 53             .BYTE   "BAS"
0033D6  1               NSMSG
0033D6  1  4E 4F 20 53          .BYTE   "NO SOURCE - ABORTING $"
0033DA  1  4F 55 52 43  
0033DE  1  45 20 2D 20  
0033EC  1               ADDEND
0033EC  1  45 4E 44 0D          .BYTE   "END",CR,LF
0033F0  1  0A           
0033F1  1               OPNMSG
0033F1  1  42 41 53 49          .BYTE   "BASIC-E/65 COMPILER - "
0033F5  1  43 2D 45 2F  
0033F9  1  36 35 20 43  
003407  1  56 45 52 53          .BYTE   "VERSION 2.03-A$"
00340B  1  49 4F 4E 20  
00340F  1  32 2E 30 33  
003416  1               ;variables - this area holds data moved from page zero to save page zero space
003416  1               PASS1
003416  1  00                   .BYTE   0               ;pass 1 if true i=TRUE
003417  1               PASS2
003417  1  00                   .BYTE   0               ;pass 2 if true
003418  1               LSTPRD
003418  1  00                   .BYTE   0               ;list production if true (listprod)
003419  1               LSTSRC
003419  1  00                   .BYTE   0               ;list source if true (listsource)
00341A  1               DEBUGL
00341A  1  00                   .BYTE   0               ;debug line numbers if true (debugln)
00341B  1               LWRUPR
00341B  1  00                   .BYTE   0               ;convert if true i=TRUE (lowertoupper)
00341C  1               NINTFL
00341C  1  00                   .BYTE   0               ;no .INT file if true (nointfile)
00341D  1               LSTFLG
00341D  1  00                   .BYTE   0               ;list device if false (lstflag)
00341E  1               EOLSTS
00341E  1  00                   .BYTE   0               ;flag that eol (cr) read by scan
00341F  1               CMPLNG
00341F  1  00                   .BYTE   0               ;compiling if true (compiling)
003420  1               FORSTM
003420  1  00                   .BYTE   0               ;for statement flag (forstmt)
003421  1               FILEIO
003421  1  00                   .BYTE   0               ;file i/o flag
003422  1               ;next variable is never read or tested - need to check need
003422  1               RNDFLE
003422  1  00                   .BYTE   0               ;random file flag (randomfile)
003423  1               ;fcbs and similar
003423  1               WFCB
003423  1  xx xx xx xx          .RES    9
003427  1  xx xx xx xx  
00342B  1  xx           
00342C  1  49 4E 54             .BYTE   "INT"
00342F  1  xx xx xx xx          .RES    21
003433  1  xx xx xx xx  
003437  1  xx xx xx xx  
003444  1               PRMLST
003444  1  20 20 20 20          .BYTE   "         "
003448  1  20 20 20 20  
00344C  1  20           
00344D  1               ;parser data tables
00344D  1               IFLBLN
00344D  1  02                   .BYTE   2
00344E  1               IFLAB2
00344E  1  17                   .BYTE   23
00344F  1               IFLABL
00344F  1  00                   .BYTE   0
003450  1               HSHTBL
003450  1  xx xx xx xx          .RES    HSHTSZ*2
003454  1  xx xx xx xx  
003458  1  xx xx xx xx  
0034D0  1               HASH
0034D0  1  xx xx xx xx          .RES    PSTKSZ
0034D4  1  xx xx xx xx  
0034D8  1  xx xx xx xx  
0034F0  1               VAR
0034F0  1  xx xx xx xx          .RES    PSTKSZ
0034F4  1  xx xx xx xx  
0034F8  1  xx xx xx xx  
003510  1               TYPE
003510  1  xx xx xx xx          .RES    PSTKSZ
003514  1  xx xx xx xx  
003518  1  xx xx xx xx  
003530  1               STYPE
003530  1  xx xx xx xx          .RES    PSTKSZ
003534  1  xx xx xx xx  
003538  1  xx xx xx xx  
003550  1               SRLOC
003550  1  xx xx xx xx          .RES    PSTKSZ*2
003554  1  xx xx xx xx  
003558  1  xx xx xx xx  
003590  1               SYMLOC
003590  1  xx xx xx xx          .RES    PSTKSZ*2
003594  1  xx xx xx xx  
003598  1  xx xx xx xx  
0035D0  1               STSTAK
0035D0  1  xx xx xx xx          .RES    PSTKSZ*2
0035D4  1  xx xx xx xx  
0035D8  1  xx xx xx xx  
003610  1               VARC
003610  1  xx xx xx xx          .RES    VARCSZ
003614  1  xx xx xx xx  
003618  1  xx xx xx xx  
003674  1               ONSTAK
003674  1  xx xx xx xx          .RES    MAXOCT
003678  1  xx xx xx xx  
00367C  1  xx xx xx xx  
003683  1               ONSP            = ONSTAK
003683  1               ;buffers
003683  1               INPBUF
003683  1  xx xx xx xx          .RES    SRCRSZ
003687  1  xx xx xx xx  
00368B  1  xx xx xx xx  
003703  1               OUTBUF
003703  1  xx xx xx xx          .RES    INTRSZ
003707  1  xx xx xx xx  
00370B  1  xx xx xx xx  
003783  1               CONBUF
003783  1  xx xx xx xx          .RES    CBUFSZ+2
003787  1  xx xx xx xx  
00378B  1  xx xx xx xx  
0037D7  1               ;start of free memory
0037D7  1               MEMORY
0037D7  1                       .END
