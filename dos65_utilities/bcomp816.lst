ca65 V2.18 - Ubuntu 2.19-1
Main file   : compl203.asm
Current file: compl203.asm

000000r 1                       .INCLUDE "macro816.asm"
000000r 2                .IFDEF  DUODYNE
000000r 2               .P816
000000r 2               
000000r 2                       .MACRO  INDEX16         ; Set 16bit Index Registers
000000r 2                       REP     #$10            ; 16 bit Index registers
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2                       .MACRO  INDEX8          ; Set 8bit Index Registers
000000r 2                       SEP     #$10            ; 8 bit Index registers
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR16   ; Set 16bit Index Registers
000000r 2                       REP     #$20            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR8    ; Set 8bit Index Registers
000000r 2                       SEP     #$20            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX16; Set 16bit Index Registers
000000r 2                       REP     #$30            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX8; Set 8bit Index Registers
000000r 2                       SEP     #$30            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLB
000000r 2                       LDA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       PHA
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLA
000000r 2                       PLX
000000r 2                       STA     (<PARM1),Y      ;
000000r 2                       PLB
000000r 2                       STA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CMP     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ADC     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ORA     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BNE     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE PARM1
000000r 2                       BEQ     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ELSE
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       STA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       CMP     (<PARM1),Y      ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       ADC     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       ORA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BEQ     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE  PARM1
000000r 2                       BNE     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ENDIF
000000r 2               
000000r 1               ;COMPILE
000000r 1               ;BASIC-E/65 Compiler
000000r 1               ;Version 2.03-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;released:	18 october 1982
000000r 1               ;last revision:
000000r 1               ;	24 december 1983
000000r 1               ;		added chkule for prod 5
000000r 1               ;		modified error to print line
000000r 1               ;		added code to set seprtr
000000r 1               ;	12 january 1984
000000r 1               ;		deleted error0 bit and branch
000000r 1               ;		fixed first blank line list for $b option
000000r 1               ;		fixed buffer overwrite on error
000000r 1               ;	4 april 2008
000000r 1               ;		reformatted for ASM211 & TASM
000000r 1               ;		eliminated page zero 0 & 1
000000r 1               ;		moved some variables from page zero
000000r 1               ;A translation of Gordon Eubanks BASIC-E to operate under DOS/65.  This is a
000000r 1               ;compile-interpret systems invoked against a source file of type .BAS.  The
000000r 1               ;compiler produces an intermediate code file of type .INT which is executed
000000r 1               ;by the program RUN.
000000r 1               ;external references
000000r 1               BOOT            = $100          ;boot entry
000000r 1               PEM             = $103          ;pem entry
000000r 1               FCB             = $107          ;default fcb
000000r 1               TEA             = $800          ;load address
000000r 1               ;fixed parameters and constants
000000r 1               ;CAUTION: When a register is set to TRUE, Z is set to 0 (i.e. NE).  If a
000000r 1               ;register is set to FALSE then Z is set to 1 (i.e. EQ).
000000r 1               TRUE            = $FF
000000r 1               FALSE           = 0
000000r 1               ;ascii characters
000000r 1               TAB             = 9             ;tab
000000r 1               LF              = 10            ;linefeed
000000r 1               CR              = 13            ;return and eol
000000r 1               EOF             = 26            ;eof char
000000r 1               SPACE           = 32            ;ascii blank
000000r 1               semico          = 59            ;semicolon
000000r 1               backsl          = 92            ;backslash
000000r 1               ;other
000000r 1               IDNTSZ          = 32            ;max identifier size + 1
000000r 1               VARCSZ          = 100           ;varc stack size
000000r 1               PSTKSZ          = 32            ;parse stack size
000000r 1               SRCRSZ          = 128           ;source file record size
000000r 1               INTRSZ          = 128           ;int file record size
000000r 1               CBUFSZ          = 82            ;console buffer size
000000r 1               HSHTSZ          = 64            ;hash table size
000000r 1               HSHMSK          = HSHTSZ-1      ;hashing mask
000000r 1               MAXOCT          = 15            ;max number on statements
000000r 1               MAXRWL          = 9             ;max reserved word length
000000r 1               MAXRNO          = 120           ;max read count
000000r 1               MAXLNO          = 175           ;max look count
000000r 1               MAXPNO          = 189           ;max push count
000000r 1               MAXSNO          = 341           ;max state count
000000r 1               STARTS          = 121           ;start state
000000r 1               PRODNO          = 152           ;number productions
000000r 1               SIMVAR          = 0
000000r 1               SUBVAR          = 2
000000r 1               CONST           = 4
000000r 1               LABLE           = 8
000000r 1               UNFUNC          = $A
000000r 1               ;mnemonics for basic-e machine
000000r 1               FAD             = 0
000000r 1               FMI             = 1
000000r 1               FMU             = 2
000000r 1               FDI             = 3
000000r 1               EXP             = 4
000000r 1               LSS             = 5
000000r 1               GTR             = 6
000000r 1               EQU             = 7
000000r 1               NEQ             = 8
000000r 1               GEQ             = 9
000000r 1               LEQ             = 10
000000r 1               NOT             = 11
000000r 1               ANDO            = 12
000000r 1               BOR             = 13
000000r 1               LOD             = 14
000000r 1               STO             = 15
000000r 1               XIT             = 16
000000r 1               DEL             = 17
000000r 1               DUP             = 18
000000r 1               XCH             = 19
000000r 1               STD             = 20
000000r 1               SLT             = 21
000000r 1               SGT             = 22
000000r 1               SEQ             = 23
000000r 1               SNE             = 24
000000r 1               SGE             = 25
000000r 1               SLE             = 26
000000r 1               STS             = 27
000000r 1               ILS             = 28
000000r 1               CAT             = 29
000000r 1               PRO             = 30
000000r 1               RTN             = 31
000000r 1               ROW             = 32
000000r 1               SUB             = 33
000000r 1               RDV             = 34
000000r 1               WRV             = 35
000000r 1               WST             = 36
000000r 1               RDF             = 37
000000r 1               RDB             = 38
000000r 1               ECR             = 39
000000r 1               POT             = 40
000000r 1               WRB             = 40
000000r 1               RDN             = 41
000000r 1               RDS             = 42
000000r 1               WRN             = 43
000000r 1               WRS             = 44
000000r 1               OPN             = 45
000000r 1               CON             = 46
000000r 1               RST             = 47
000000r 1               NEG             = 48
000000r 1               RES             = 49
000000r 1               NOPO            = 50
000000r 1               DAT             = 51
000000r 1               DBF             = 52
000000r 1               NSP             = 53
000000r 1               BRS             = 54
000000r 1               BRC             = 55
000000r 1               BFC             = 56
000000r 1               BFN             = 57
000000r 1               CVB             = 58
000000r 1               RCN             = 59
000000r 1               DRS             = 60
000000r 1               DRF             = 61
000000r 1               EDR             = 62
000000r 1               EDW             = 63
000000r 1               CLS             = 64
000000r 1               IRN             = 77
000000r 1               RON             = 91
000000r 1               CKO             = 92
000000r 1               EXR             = 93
000000r 1               DEF             = 94
000000r 1               BOL             = 95
000000r 1               ADJ             = 96
000000r 1               ;token definitions
000000r 1               POUND           = 12
000000r 1               ASTRK           = 4
000000r 1               LESST           = 1
000000r 1               EXPON           = 14
000000r 1               TDATA           = 99
000000r 1               TELSE           = 34
000000r 1               TFOR            = 28
000000r 1               TIF             = 17
000000r 1               TNEXT           = 37
000000r 1               SLASH           = 8
000000r 1               TOR             = 21
000000r 1               TREST           = 48
000000r 1               TSTOP           = 40
000000r 1               FUNCT           = 53
000000r 1               TLEQ            = 18
000000r 1               TNE             = 19
000000r 1               TOUT            = 31
000000r 1               IDENT           = 52
000000r 1               UDFUNC          = 54
000000r 1               LPARN           = 2
000000r 1               TPLUS           = 3
000000r 1               TCOLIN          = 11
000000r 1               EQUAL           = 13
000000r 1               TAND            = 24
000000r 1               TDEF            = 25
000000r 1               TEND            = 27
000000r 1               TGOSB           = 43
000000r 1               TINPT           = 44
000000r 1               TNOT            = 30
000000r 1               TPRNT           = 45
000000r 1               TRETN           = 46
000000r 1               TTHEN           = 41
000000r 1               TGEQ            = 15
000000r 1               COMMA           = 9
000000r 1               TCLOS           = 42
000000r 1               TIRN            = 51
000000r 1               RPARN           = 5
000000r 1               TMINUS          = 7
000000r 1               SCOLN           = 6
000000r 1               GTRT            = 10
000000r 1               TCR             = 23
000000r 1               TDIM            = 26
000000r 1               TFILE           = 35
000000r 1               TGOTO           = 36
000000r 1               TLET            = 29
000000r 1               TON             = 20
000000r 1               TREAD           = 38
000000r 1               TSTEP           = 39
000000r 1               TTO             = 22
000000r 1               TSUB            = 32
000000r 1               TGO             = 16
000000r 1               TXOR            = 33
000000r 1               STRING          = 50
000000r 1               FLOTPT          = 49
000000r 1               TREM            = 0
000000r 1               ;page zero variables
000000r 1               ;all non-zero initial values are shown as i=xxxx where xxxx is the initial
000000r 1               ;value. PL/M name is shown if significantly different.
000000r 1               GPIND           = $02+$40       ;INDEX IN GETCHR
000000r 1               ERRCNT          = $03+$40       ;ERROR COUNT (ERRORCOUNT)
000000r 1               DATACT          = $05+$40       ;COUNT DATA AREA SIZE
000000r 1               INPSTM          = $07+$40       ;(INPUTSTMT)
000000r 1               GSBSTM          = $08+$40       ;(GOSUBSTMT)
000000r 1               TOKEN           = $09+$40       ;TYPE OF TOKEN
000000r 1               SUBTYP          = $0A+$40       ;SUBTYPE OF TOKEN (SUBTYPE)
000000r 1               FUNCOP          = $0B+$40       ;FUNCTION NUMBER IF FUNCTION
000000r 1               HSHCDE          = $0C+$40       ;HASH OF CURRENT TOKEN (HASHCODE)
000000r 1               NXTCHR          = $0D+$40       ;CURRENT CHAR FROM GETCHR (NEXTCHAR)
000000r 1               ACCUM           = $0E+$40       ;CURRENT TOKEN
000000r 1               ACCLEN          = ACCUM         ;LENGTH IS FIRST BYTE
000000r 1               CONT            = $2E+$40       ;ACCUM FULL FLAG
000000r 1               COLUMN          = $2F+$40       ;CURRENT COLUMN
000000r 1               LINENO          = $30+$40       ;CURRENT LINE NUMBER
000000r 1               OUTIND          = $32+$40       ;INT BUFFER INDEX (BUFFPTR)
000000r 1               LENGTH          = $33+$40       ;OUTPUT LINE LENGTH
000000r 1               SEPRTR          = $34+$40       ;SEPARATOR I=':'
000000r 1               SRCIND          = $35+$40       ;SOURCE INDEX I=SRCRSZ (SOURCEPTR)
000000r 1               LNEPTR          = $36+$40       ;LINE POINTER
000000r 1               POINTR          = $37+$40       ;POINTER IN ERROR
000000r 1               ERRCDE          = $38+$40       ;COMPILER ERROR CODE
000000r 1               STATE           = $39+$40       ;STATE
000000r 1               SP              = $3B+$40       ;STACK POINTER
000000r 1               MP              = $3C+$40       ;
000000r 1               MPP1            = $3D+$40       ;MP + 1
000000r 1               NOLOOK          = $3E+$40       ;
000000r 1               VARIND          = $3F+$40       ;INDEX INTO VAR
000000r 1               TYPESP          = $40+$40       ;GROUP OF
000000r 1               TYPEM1          = $41+$40       ;VARIABLES
000000r 1               TYPEMP          = $42+$40       ;TO HOLD
000000r 1               STYPSP          = $43+$40       ;PARSER STACK
000000r 1               STYPM1          = $44+$40       ;CONTENTS
000000r 1               STYPMP          = $45+$40       ;DURING
000000r 1               SYMLSP          = $46+$40       ;ACTION
000000r 1               SYMLM1          = $48+$40       ;OF SYNTHESIZE
000000r 1               SYMLMP          = $4A+$40       ;IN
000000r 1               HASHSP          = $4C+$40       ;ORDER TO
000000r 1               HASHM1          = $4D+$40       ;REDUCE
000000r 1               HASHMP          = $4E+$40       ;THE AMOUNT
000000r 1               SRLOSP          = $4F+$40       ;OF INDEXING
000000r 1               SRLOMP          = $51+$40       ;IN SYNTHE
000000r 1               DECOUT          = $53+$40       ;DECIMAL WORD
000000r 1               LZFLAG          = $55+$40       ;LEADING ZERO FLAG IN PRNDEC
000000r 1               FIELD           = $56+$40       ;POINTER IN COMPARE
000000r 1               I               = $58+$40       ;PARSER VAR
000000r 1               J               = $5A+$40       ;SAME
000000r 1               K               = $5C+$40       ;EVEN MORE
000000r 1               INDEX           = $5E+$40       ;
000000r 1               I2              = $5F+$40       ;I*2 AND WORD POINTER
000000r 1               IC              = $61+$40       ;INDEX IN COMPAR
000000r 1               PTR             = $62+$40       ;POINTER IN LOOKUP AND COMPAR
000000r 1               IL              = $64+$40       ;INDEX IN LOOKUP
000000r 1               SBTTOP          = $65+$40       ;TOP OF FOR/NEXT STACK
000000r 1               BASE            = $67+$40       ;BASE OF CURRENT ENTRY
000000r 1               FORCNT          = $69+$40       ;FOR COUNT
000000r 1               SBTBL           = $6A+$40       ;TOP OF SYMBOL TABLE
000000r 1               APTADD          = $6C+$40       ;UTILITY VAR TO ACCESS TABLE
000000r 1               PRTCT           = $6E+$40       ;COUNT PRT ENTRIES
000000r 1               FDACT           = $70+$40       ;COUNT FDA ENTRIES
000000r 1               CODESI          = $72+$40       ;COUNT SIZE OF CODE AREA
000000r 1               ULERFL          = $74+$40       ;
000000r 1               PRNTNM          = $75+$40       ;POINTER SET BEFORE SLOOKU OR ENTER
000000r 1               SYMHSH          = $77+$40       ;HASH OF TOKEN REFERENCE
000000r 1               PRODCT          = $78+$40       ;PRODUCTION NUMBER (0 TO PRODNO)
000000r 1               NXSTPT          = $79+$40       ;NEXT STATEMENT POINTER
000000r 1               TMPHSH          = $7B+$40       ;LOCAL HASH IN GETHSH
000000r 1               TMPPTR          = $7C+$40       ;LOCAL PTR IN GETHSH
000000r 1               LEN             = $7D+$40       ;TEMP IN SLOOKU
000000r 1               NUMPRM          = $7E+$40       ;TEMP IN UNLINK/RELINK
000000r 1               LINKI           = $7F+$40       ;TEMP IN UNLINK/RELINK
000000r 1               TMPADR          = $80+$40       ;TEMP IN UNLINK/RELINK
000000r 1               WHERE           = $82+$40       ;TEMP IN GENILS
000000r 1               STRPTR          = $84+$40       ;TEMP IN GINILS
000000r 1               IGEN            = $85+$40       ;TEMP IN GENCON
000000r 1               LZ              = $86+$40       ;
000000r 1               TMPFLG          = $87+$40       ;
000000r 1               
000000r 1               ;entry point
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 20 22             JMP     MAIN
000803  1               ;copyright notice
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT - RICHARD"
000807  1  52 49 47 48  
00080B  1  54 20 2D 20  
000816  1  20 41 2E 20          .BYTE   " A. LEARY - 2008"
00081A  1  4C 45 41 52  
00081E  1  59 20 2D 20  
000826  1               ;SUBROUTINES
000826  1               ;subroutine to point to source fcb and go to pem
000826  1               RFCBX
000826  1  A9 07                LDA     #<FCB           ;point
000828  1  A0 01                LDY     #>FCB           ;to fcb
00082A  1  4C 03 01             JMP     PEM             ;and go
00082D  1               ;point to int fcb and go to pem
00082D  1               WFCBX
00082D  1  A9 15                LDA     #<WFCB          ;point
00082F  1  A0 34                LDY     #>WFCB          ;to fcb
000831  1  4C 03 01             JMP     PEM             ;and go
000834  1               ;send cr and lf to console/list
000834  1               CRLF
000834  1  A9 0D                LDA     #CR             ;get
000836  1  20 4F 08             JSR     PRNCHR          ;a cr
000839  1  A9 0A                LDA     #LF             ;and
00083B  1  4C 4F 08             JMP     PRNCHR          ;then a lf
00083E  1               ;output char in A to console or list device as a function of LSTFLG
00083E  1               SPCOUT
00083E  1  A9 20                LDA     #SPACE          ;get space
000840  1               CHROUT
000840  1  2C 0F 34             BIT     LSTFLG          ;test flag
000843  1  30 05                BMI     *+7             ;use list if set
000845  1  A2 02                LDX     #2              ;else set
000847  1  4C 03 01             JMP     PEM             ;and do console
00084A  1  A2 05                LDX     #5              ;set list
00084C  1  4C 03 01             JMP     PEM             ;and do
00084F  1               ;print char in A and handle tabs and linefeeds
00084F  1               PRNCHR
00084F  1  C9 09                CMP     #TAB            ;see if tab
000851  1  D0 0C                BNE     NOTTAB          ;branch if not
000853  1               TABOVR
000853  1  20 3E 08             JSR     SPCOUT          ;send a space
000856  1  E6 6F                INC     COLUMN          ;bump column
000858  1  A5 6F                LDA     COLUMN          ;get it
00085A  1  29 07                AND     #7              ;see if mod 8
00085C  1  D0 F5                BNE     TABOVR          ;loop if not
00085E  1  60                   RTS                     ;else done
00085F  1               NOTTAB
00085F  1  48                   PHA                     ;save char
000860  1  20 40 08             JSR     CHROUT          ;send it
000863  1  E6 6F                INC     COLUMN          ;bump column
000865  1  68                   PLA                     ;get char
000866  1  C9 0A                CMP     #LF             ;if a lf
000868  1  F0 01                BEQ     *+3             ;then branch
00086A  1  60                   RTS                     ;else done
00086B  1  A9 00                LDA     #0              ;clear column
00086D  1  85 6F                STA     COLUMN          ;and then
00086F  1  60                   RTS                     ;done
000870  1               ;convert AY to decimal number and print on console
000870  1               PRNDEC
000870  1  85 93                STA     DECOUT          ;save
000872  1  84 94                STY     DECOUT+1        ;value
000874  1  A9 00                LDA     #FALSE          ;set flag
000876  1  85 95                STA     LZFLAG          ;to false
000878  1  A2 2F                LDX     #'0'-1          ;set digit to '0' - 1
00087A  1  38                   SEC                     ;now
00087B  1               P10000
00087B  1  A5 93                LDA     DECOUT          ;subtract
00087D  1  E9 10                SBC     #<10000         ;10000
00087F  1  85 93                STA     DECOUT          ;from
000881  1  A5 94                LDA     DECOUT+1        ;value
000883  1  E9 27                SBC     #>10000         ;and
000885  1  85 94                STA     DECOUT+1        ;save
000887  1  E8                   INX                     ;bump digit
000888  1  B0 F1                BCS     P10000          ;loop if no borrow
00088A  1  A5 93                LDA     DECOUT          ;else
00088C  1  69 10                ADC     #<10000         ;add
00088E  1  85 93                STA     DECOUT          ;10000
000890  1  A5 94                LDA     DECOUT+1        ;back
000892  1  69 27                ADC     #>10000         ;in to
000894  1  85 94                STA     DECOUT+1        ;correct
000896  1  20 E6 08             JSR     DIGOUT          ;send digit
000899  1               P1000
000899  1  A5 93                LDA     DECOUT          ;now
00089B  1  E9 E8                SBC     #<1000          ;drop
00089D  1  85 93                STA     DECOUT          ;by
00089F  1  A5 94                LDA     DECOUT+1        ;1000
0008A1  1  E9 03                SBC     #>1000          ;until
0008A3  1  85 94                STA     DECOUT+1        ;a borrow
0008A5  1  E8                   INX                     ;bump digit
0008A6  1  B0 F1                BCS     P1000           ;loop if more
0008A8  1  A5 93                LDA     DECOUT          ;now
0008AA  1  69 E8                ADC     #<1000          ;add
0008AC  1  85 93                STA     DECOUT          ;1000
0008AE  1  A5 94                LDA     DECOUT+1        ;back
0008B0  1  69 03                ADC     #>1000          ;in to
0008B2  1  85 94                STA     DECOUT+1        ;correct
0008B4  1  20 E6 08             JSR     DIGOUT          ;send 1000s
0008B7  1               P100
0008B7  1  A5 93                LDA     DECOUT          ;now
0008B9  1  E9 64                SBC     #100            ;do
0008BB  1  85 93                STA     DECOUT          ;subtract
0008BD  1  A5 94                LDA     DECOUT+1        ;for
0008BF  1  E9 00                SBC     #0              ;100
0008C1  1  85 94                STA     DECOUT+1        ;with
0008C3  1  E8                   INX                     ;digit bump
0008C4  1  B0 F1                BCS     P100            ;loop if more
0008C6  1  A5 93                LDA     DECOUT          ;else
0008C8  1  69 64                ADC     #100            ;add back
0008CA  1  85 93                STA     DECOUT          ;to correct
0008CC  1  20 E6 08             JSR     DIGOUT          ;send 100s
0008CF  1               P10
0008CF  1  A5 93                LDA     DECOUT          ;now
0008D1  1  E9 0A                SBC     #10             ;drop
0008D3  1  85 93                STA     DECOUT          ;by 10
0008D5  1  E8                   INX                     ;bump digit
0008D6  1  B0 F7                BCS     P10             ;loop if more
0008D8  1  69 0A                ADC     #10             ;correct
0008DA  1  85 93                STA     DECOUT          ;save
0008DC  1  20 E6 08             JSR     DIGOUT          ;and send 10s
0008DF  1  A9 30                LDA     #'0'            ;get zero
0008E1  1  05 93                ORA     DECOUT          ;add number
0008E3  1  4C 4F 08             JMP     PRNCHR          ;and print always
0008E6  1               ;send a single digit in X and handle leading zeros
0008E6  1               DIGOUT
0008E6  1  A9 20                LDA     #SPACE          ;preset for blank
0008E8  1  24 95                BIT     LZFLAG          ;test flag
0008EA  1  30 08                BMI     D2              ;branch if set
0008EC  1  E0 30                CPX     #'0'            ;else test current
0008EE  1  F0 05                BEQ     D3              ;branch if '0'
0008F0  1  A9 FF                LDA     #TRUE           ;else set
0008F2  1  85 95                STA     LZFLAG          ;flag
0008F4  1               D2
0008F4  1  8A                   TXA                     ;get char
0008F5  1               D3
0008F5  1  20 4F 08             JSR     PRNCHR          ;print it
0008F8  1  A2 2F                LDX     #'0'-1          ;now preset
0008FA  1  38                   SEC                     ;for next
0008FB  1  60                   RTS
0008FC  1               ;print message pointed to by AY until a $ is encountered
0008FC  1               PRNMSG
0008FC  1  8D 03 09             STA     PRN0+1          ;save message
0008FF  1  8C 04 09             STY     PRN0+2          ;address
000902  1               PRN0
000902  1  AD FF FF             LDA     $FFFF           ;get byte
000905  1  C9 24                CMP     #'$'            ;see if end
000907  1  D0 01                BNE     *+3             ;branch if not
000909  1  60                   RTS                     ;else done
00090A  1  20 4F 08             JSR     PRNCHR          ;print it
00090D  1  EE 03 09             INC     PRN0+1          ;bump low
000910  1  D0 F0                BNE     PRN0            ;loop if no carry
000912  1  EE 04 09             INC     PRN0+2          ;bump high
000915  1  4C 02 09             JMP     PRN0            ;and loop
000918  1               ;disk error exit
000918  1               DSKERR
000918  1  A9 AE                LDA     #<DEMSG         ;point to
00091A  1  A0 33                LDY     #>DEMSG         ;message
00091C  1               DSKER0
00091C  1  20 FC 08             JSR     PRNMSG          ;print it
00091F  1  4C 00 01             JMP     BOOT            ;and boot
000922  1               ;open source file
000922  1               OPNSRC
000922  1  A2 03                LDX     #3              ;first
000924  1               OPN1
000924  1  BD C4 33             LDA     BASSTR-1,X      ;move
000927  1  9D 0F 01             STA     FCB+8,X         ;BAS to
00092A  1  CA                   DEX                     ;type part
00092B  1  D0 F7                BNE     OPN1            ;of fcb
00092D  1  8E 13 01             STX     FCB+12          ;clear extent
000930  1  8E 14 01             STX     FCB+13
000933  1  8E 27 01             STX     FCB+32          ;and record
000936  1  A9 75                LDA     #<INPBUF        ;point to
000938  1  A0 36                LDY     #>INPBUF        ;buffer
00093A  1  A2 1A                LDX     #26             ;and set
00093C  1  20 03 01             JSR     PEM             ;as buffer location
00093F  1  A2 0F                LDX     #15             ;open code
000941  1  20 26 08             JSR     RFCBX           ;do it
000944  1  30 01                BMI     *+3             ;branch if bad
000946  1  60                   RTS                     ;else done
000947  1  A9 C8                LDA     #<NSMSG         ;point to
000949  1  A0 33                LDY     #>NSMSG         ;no source message
00094B  1  4C 1C 09             JMP     DSKER0          ;send and quit
00094E  1               ;close output (INT) file
00094E  1               CLSINT
00094E  1  A2 10                LDX     #16             ;close code
000950  1  20 2D 08             JSR     WFCBX           ;do it
000953  1  30 01                BMI     *+3             ;branch if bad
000955  1  60                   RTS                     ;else done
000956  1  4C 18 09             JMP     DSKERR          ;error exit
000959  1               ;set-up INT file
000959  1               SUPINT
000959  1  2C 0E 34             BIT     NINTFL          ;test no-int flag
00095C  1  10 01                BPL     *+3             ;branch if false
00095E  1  60                   RTS                     ;else done
00095F  1  A2 08                LDX     #8              ;move 9
000961  1               SUP0
000961  1  BD 07 01             LDA     FCB,X           ;char including drive
000964  1  9D 15 34             STA     WFCB,X          ;to write fcb
000967  1  CA                   DEX                     ;drop count
000968  1  10 F7                BPL     SUP0            ;loop if more
00096A  1  E8                   INX
00096B  1  8E 21 34             STX     WFCB+12
00096E  1  8E 22 34             STX     WFCB+13
000971  1  8E 35 34             STX     WFCB+32         ;clear extent and record
000974  1  A2 13                LDX     #19             ;now delete
000976  1  20 2D 08             JSR     WFCBX           ;it if there
000979  1  A2 16                LDX     #22             ;now try
00097B  1  20 2D 08             JSR     WFCBX           ;to create
00097E  1  10 03                BPL     *+5             ;branch if ok
000980  1  4C 18 09             JMP     DSKERR          ;else error
000983  1  60                   RTS                     ;and quit
000984  1               ;reset compiler flags
000984  1               SETFLG
000984  1  A9 00                LDA     #FALSE
000986  1  8D 14 34             STA     RNDFLE          ;random file
000989  1  8D 13 34             STA     FILEIO          ;file io
00098C  1  85 47                STA     INPSTM          ;input statement
00098E  1  8D 12 34             STA     FORSTM          ;for statement
000991  1  85 48                STA     GSBSTM          ;gosub statement
000993  1  60                   RTS
000994  1               ;write INT record
000994  1               WRTINT
000994  1  2C 0E 34             BIT     NINTFL          ;test flag
000997  1  10 01                BPL     *+3             ;ok if false
000999  1  60                   RTS                     ;else done
00099A  1  A9 F5                LDA     #<OUTBUF        ;point to
00099C  1  A0 36                LDY     #>OUTBUF        ;buffer
00099E  1  A2 1A                LDX     #26             ;and set
0009A0  1  20 03 01             JSR     PEM             ;as dma
0009A3  1  A2 15                LDX     #21             ;now do
0009A5  1  20 2D 08             JSR     WFCBX           ;write op
0009A8  1  F0 03                BEQ     *+5             ;ok if zero
0009AA  1  4C 18 09             JMP     DSKERR          ;else error
0009AD  1  A9 75                LDA     #<INPBUF        ;point back
0009AF  1  A0 36                LDY     #>INPBUF        ;to input
0009B1  1  A2 1A                LDX     #26             ;and set
0009B3  1  4C 03 01             JMP     PEM             ;as default
0009B6  1               ;emit byte in A to INT file
0009B6  1               EMIT
0009B6  1  A6 72                LDX     OUTIND          ;get index
0009B8  1  10 09                BPL     EMIT0           ;ok if < 128
0009BA  1  48                   PHA                     ;else save
0009BB  1  20 94 09             JSR     WRTINT          ;write buffer
0009BE  1  68                   PLA                     ;get byte
0009BF  1  A2 00                LDX     #0              ;now clear
0009C1  1  86 72                STX     OUTIND          ;index
0009C3  1               EMIT0
0009C3  1  E6 72                INC     OUTIND          ;bump for next
0009C5  1  9D F5 36             STA     OUTBUF,X        ;save byte
0009C8  1  60                   RTS                     ;and done
0009C9  1               ;read source file record
0009C9  1               RDESRC
0009C9  1  A2 14                LDX     #20             ;get code
0009CB  1  20 26 08             JSR     RFCBX           ;do it
0009CE  1  C9 02                CMP     #2              ;see if ok
0009D0  1  90 03                BCC     *+5             ;branch if was
0009D2  1  4C 18 09             JMP     DSKERR          ;else error
0009D5  1  60                   RTS
0009D6  1               ;clear output line buffer
0009D6  1               CLLNBF
0009D6  1  A2 51                LDX     #CBUFSZ-1       ;get length - 1
0009D8  1  A9 20                LDA     #SPACE          ;use space
0009DA  1               CLLN0
0009DA  1  9D 75 37             STA     CONBUF,X        ;store
0009DD  1  CA                   DEX                     ;drop index
0009DE  1  E0 FF                CPX     #255            ;see if wrap
0009E0  1  D0 F8                BNE     CLLN0           ;loop if not
0009E2  1  60                   RTS
0009E3  1               ;list line of length LENGTH
0009E3  1               ;note that this routine also sets seprtr to : (just in case!!)
0009E3  1               LSTLNE
0009E3  1  A5 70                LDA     LINENO          ;get line
0009E5  1  A4 71                LDY     LINENO+1        ;number
0009E7  1  20 70 08             JSR     PRNDEC          ;print it
0009EA  1  A5 74                LDA     SEPRTR          ;then print
0009EC  1  20 4F 08             JSR     PRNCHR          ;separator
0009EF  1  A9 20                LDA     #SPACE          ;and a
0009F1  1  20 4F 08             JSR     PRNCHR          ;space
0009F4  1  A9 00                LDA     #0              ;now clear
0009F6  1  85 42                STA     GPIND           ;index
0009F8  1               LSTL0
0009F8  1  A6 42                LDX     GPIND           ;get index
0009FA  1  BD 75 37             LDA     CONBUF,X        ;get char
0009FD  1  20 4F 08             JSR     PRNCHR          ;print it
000A00  1  E6 42                INC     GPIND           ;bump index
000A02  1  A5 42                LDA     GPIND           ;get index
000A04  1  C5 73                CMP     LENGTH          ;compare to length
000A06  1  90 F0                BCC     LSTL0           ;loop if more
000A08  1  F0 EE                BEQ     LSTL0           ;or if same
000A0A  1  20 34 08             JSR     CRLF            ;do cr and lf
000A0D  1  20 D6 09             JSR     CLLNBF          ;clear buffer
000A10  1  A9 3A                LDA     #':'            ;and set
000A12  1  85 74                STA     SEPRTR          ;separator
000A14  1  60                   RTS
000A15  1               ;set global variable NXTCHR to next source file character and return with
000A15  1               ;NXTCHR in A. Replace TAB with SPACE and if LSTSRC is TRUE or an error
000A15  1               ;occurs send the line to the console.
000A15  1               GETCHR
000A15  1  20 73 0A             JSR     CHKFLE          ;go get char
000A18  1  D0 06                BNE     GETEOF          ;branch if eof
000A1A  1  A5 4D                LDA     NXTCHR          ;get nextchar
000A1C  1  C9 1A                CMP     #EOF            ;see if eof char
000A1E  1  D0 14                BNE     NTEOF           ;branch if not
000A20  1               GETEOF
000A20  1  A2 04                LDX     #4              ;move 5
000A22  1               GETE0
000A22  1  BD DE 33             LDA     ADDEND,X        ;from ADDEND
000A25  1  9D 75 36             STA     INPBUF,X        ;to input buffer
000A28  1  CA                   DEX                     ;drop count
000A29  1  10 F7                BPL     GETE0           ;loop if more
000A2B  1  00                   BRK
000A2C  1  E8                   INX                     ;clear X
000A2D  1  86 75                STX     SRCIND          ;and then index
000A2F  1  20 6D 0A             JSR     NXTSRC          ;get next
000A32  1  85 4D                STA     NXTCHR          ;save it
000A34  1               NTEOF
000A34  1  A6 76                LDX     LNEPTR          ;get pointer
000A36  1  E0 52                CPX     #CBUFSZ         ;compare to max
000A38  1  B0 08                BCS     LTOBIG          ;branch if too big
000A3A  1  E8                   INX                     ;else bump
000A3B  1  86 76                STX     LNEPTR          ;and save
000A3D  1  A5 4D                LDA     NXTCHR          ;get char
000A3F  1  9D 75 37             STA     CONBUF,X        ;and save
000A42  1               LTOBIG
000A42  1  00                   BRK
000A43  1  A5 4D                LDA     NXTCHR          ;get char
000A45  1  C9 0D                CMP     #CR             ;see if a cr
000A47  1  D0 1A                BNE     NTEOL           ;branch if not
000A49  1  E6 70                INC     LINENO          ;else bump
000A4B  1  D0 02                BNE     *+4             ;line
000A4D  1  E6 71                INC     LINENO+1        ;number
000A4F  1  A6 76                LDX     LNEPTR          ;get pointer
000A51  1  CA                   DEX                     ;drop it
000A52  1  86 73                STX     LENGTH          ;put in length
000A54  1  AD 0B 34             LDA     LSTSRC          ;get flag
000A57  1  F0 04                BEQ     NOLSLN          ;branch if not true
000A59  1  00                   BRK
000A5A  1  20 E3 09             JSR     LSTLNE          ;list it
000A5D  1               NOLSLN
000A5D  1  A9 00                LDA     #0              ;then clear
000A5F  1  85 76                STA     LNEPTR          ;pointer
000A61  1  A5 4D                LDA     NXTCHR          ;get char
000A63  1               NTEOL
000A63  1  C9 09                CMP     #TAB            ;see it tab
000A65  1  F0 01                BEQ     *+3             ;branch if is
000A67  1  60                   RTS
000A68  1  A9 20                LDA     #SPACE          ;else get space
000A6A  1  85 4D                STA     NXTCHR          ;set
000A6C  1  60                   RTS                     ;and done
000A6D  1               ;get byte from source file
000A6D  1               NXTSRC
000A6D  1  A6 75                LDX     SRCIND          ;get index
000A6F  1  BD 75 36             LDA     INPBUF,X        ;then byte
000A72  1  60                   RTS
000A73  1               ;maintain source buffer full and check for eof. if eof is detected then
000A73  1               ;A:=TRUE else A:=FALSE
000A73  1               CHKFLE
000A73  1  E6 75                INC     SRCIND          ;bump index
000A75  1  10 0E                BPL     CHKFL0          ;branch if ok
000A77  1  A9 00                LDA     #0              ;else clear
000A79  1  85 75                STA     SRCIND          ;index
000A7B  1  20 C9 09             JSR     RDESRC          ;read record
000A7E  1  C9 01                CMP     #1              ;see if eof
000A80  1  D0 03                BNE     CHKFL0          ;branch if not
000A82  1  A9 FF                LDA     #TRUE           ;else set
000A84  1  60                   RTS                     ;eof=true
000A85  1               CHKFL0
000A85  1  20 6D 0A             JSR     NXTSRC          ;get next
000A88  1  85 4D                STA     NXTCHR          ;save it
000A8A  1  C9 0A                CMP     #LF             ;if a lf
000A8C  1  F0 E5                BEQ     CHKFLE          ;loop for more
000A8E  1  A9 00                LDA     #FALSE          ;else say
000A90  1  60                   RTS                     ;wasn't eof
000A91  1               ;get non-blank from source. will also skip past eof to reach physical eof.
000A91  1               GTNBLK
000A91  1  20 15 0A             JSR     GETCHR          ;get new char
000A94  1  C9 20                CMP     #SPACE          ;if a space
000A96  1  F0 F9                BEQ     GTNBLK          ;try again
000A98  1  C9 1A                CMP     #EOF            ;if an eof
000A9A  1  F0 F5                BEQ     GTNBLK          ;try again
000A9C  1  60                   RTS
000A9D  1               ;check for continuation character. if it is will get first char from next line.
000A9D  1               CHKCNT
000A9D  1  A5 4D                LDA     NXTCHR          ;get next
000A9F  1  C9 5C                CMP     #backsl         ;see if continue
000AA1  1  F0 01                BEQ     *+3             ;branch if is
000AA3  1  60                   RTS
000AA4  1               CHKCN0
000AA4  1  20 15 0A             JSR     GETCHR          ;get next
000AA7  1  C9 0D                CMP     #CR             ;see if eol
000AA9  1  D0 F9                BNE     CHKCN0          ;loop if isn't
000AAB  1  4C 91 0A             JMP     GTNBLK          ;now get first non-blank
000AAE  1               ;compiler error handler
000AAE  1               ;at entry a contains error number
000AAE  1               ERROR
000AAE  1  85 78                STA     ERRCDE          ;save
000AB0  1  A5 76                LDA     LNEPTR          ;get index
000AB2  1  85 77                STA     POINTR          ;move to pointer
000AB4  1  E6 77                INC     POINTR          ;and bump
000AB6  1  E6 77                INC     POINTR          ;by two
000AB8  1  A5 49                LDA     TOKEN           ;get token
000ABA  1  C9 17                CMP     #TCR            ;see if for eol
000ABC  1  F0 0F                BEQ     ERROR3          ;branch if is
000ABE  1  A5 4D                LDA     NXTCHR          ;else get next
000AC0  1               ERROR1
000AC0  1  C9 0D                CMP     #CR             ;if a cr
000AC2  1  F0 09                BEQ     ERROR3          ;then done
000AC4  1  20 9D 0A             JSR     CHKCNT          ;else see if continue
000AC7  1  20 15 0A             JSR     GETCHR          ;get another char
000ACA  1  4C C0 0A             JMP     ERROR1          ;and loop
000ACD  1               ERROR3
000ACD  1  2C 09 34             BIT     PASS2           ;test pass 2 flag
000AD0  1  10 43                BPL     ERROR6          ;branch if clear
000AD2  1  2C 0B 34             BIT     LSTSRC          ;see if source already listed
000AD5  1  30 03                BMI     *+5             ;skip list if was
000AD7  1  20 E3 09             JSR     LSTLNE          ;else list
000ADA  1  E6 43                INC     ERRCNT          ;bump
000ADC  1  D0 02                BNE     *+4             ;error
000ADE  1  E6 44                INC     ERRCNT+1        ;count
000AE0  1  A9 3F                LDA     #'?'            ;print a ?
000AE2  1  20 4F 08             JSR     PRNCHR
000AE5  1  A9 2D                LDA     #'-'
000AE7  1  20 4F 08             JSR     PRNCHR          ;print two -
000AEA  1  A9 2D                LDA     #'-'
000AEC  1  20 4F 08             JSR     PRNCHR
000AEF  1               ERROR4
000AEF  1  C6 77                DEC     POINTR          ;drop pointer
000AF1  1  F0 0A                BEQ     ERROR5          ;done if zero
000AF3  1  30 08                BMI     ERROR5          ;or <0
000AF5  1  A9 2D                LDA     #'-'            ;else get -
000AF7  1  20 4F 08             JSR     PRNCHR          ;print it
000AFA  1  4C EF 0A             JMP     ERROR4          ;and loop
000AFD  1               ERROR5
000AFD  1  A9 5E                LDA     #'^'            ;get up arrow
000AFF  1  20 4F 08             JSR     PRNCHR          ;print it
000B02  1  20 34 08             JSR     CRLF            ;then a cr and lf
000B05  1  A5 78                LDA     ERRCDE          ;get error code
000B07  1  0A                   ASL     A               ;mult by two
000B08  1  AA                   TAX
000B09  1  BD 65 33             LDA     ERMTBL,X
000B0C  1  BC 66 33             LDY     ERMTBL+1,X      ;get message address
000B0F  1  20 FC 08             JSR     PRNMSG          ;print it
000B12  1  20 34 08             JSR     CRLF
000B15  1               ERROR6
000B15  1  A9 00                LDA     #FALSE          ;now clear
000B17  1  8D 11 34             STA     CMPLNG          ;compiling flag
000B1A  1  4C 84 09             JMP     SETFLG          ;and then other flags
000B1D  1               ;initialize scanner by setting NXTCHR to the first non-blank character from the
000B1D  1               ;input file and by setting the line number and pointer
000B1D  1               INSCAN
000B1D  1  2C 08 34             BIT     PASS1           ;test for pass 1
000B20  1  10 0B                BPL     NOGTPR          ;branch if not
000B22  1  A2 08                LDX     #8              ;move 8 parms
000B24  1               INSCA0
000B24  1  BD 17 01             LDA     FCB+16,X        ;from fcb
000B27  1  9D 35 34             STA     PRMLST-1,X      ;to save area
000B2A  1  CA                   DEX                     ;drop count
000B2B  1  D0 F7                BNE     INSCA0          ;loop if more
000B2D  1               NOGTPR
000B2D  1  20 22 09             JSR     OPNSRC          ;open file
000B30  1  A9 00                LDA     #0              ;now
000B32  1  85 6E                STA     CONT            ;clear
000B34  1  85 6F                STA     COLUMN          ;variables
000B36  1  85 70                STA     LINENO          ;for start
000B38  1  85 71                STA     LINENO+1        ;of a
000B3A  1  85 76                STA     LNEPTR          ;pass
000B3C  1  20 D6 09             JSR     CLLNBF          ;clear output buffer
000B3F  1  A9 80                LDA     #SRCRSZ         ;now set source
000B41  1  85 75                STA     SRCIND          ;index to invalid
000B43  1  A9 3A                LDA     #':'            ;set separator
000B45  1  85 74                STA     SEPRTR          ;to a colon
000B47  1  AD 36 34             LDA     PRMLST          ;get first parm
000B4A  1  C9 24                CMP     #'$'            ;see if start
000B4C  1  D0 44                BNE     INSDNE          ;not so exit
000B4E  1  A2 01                LDX     #1              ;set index to first
000B50  1               INSCAP
000B50  1  BD 36 34             LDA     PRMLST,X        ;get parm
000B53  1  E8                   INX                     ;bump index
000B54  1  C9 20                CMP     #SPACE          ;if not a space
000B56  1  F0 3A                BEQ     INSDNE          ;done if space
000B58  1  A0 FF                LDY     #TRUE           ;set true
000B5A  1  C9 41                CMP     #'A'            ;if not A
000B5C  1  D0 05                BNE     PNOTA           ;try next
000B5E  1  8C 0A 34             STY     LSTPRD          ;else set
000B61  1  F0 ED                BEQ     INSCAP          ;and loop
000B63  1               PNOTA
000B63  1  C9 43                CMP     #'C'            ;if not C
000B65  1  D0 05                BNE     PNOTC           ;try next
000B67  1  8C 0E 34             STY     NINTFL          ;else set
000B6A  1  F0 E4                BEQ     INSCAP          ;and loop
000B6C  1               PNOTC
000B6C  1  C9 45                CMP     #'E'            ;see if E
000B6E  1  D0 05                BNE     PNOTE           ;branch if not
000B70  1  8C 0C 34             STY     DEBUGL          ;else set
000B73  1  F0 DB                BEQ     INSCAP          ;and loop
000B75  1               PNOTE
000B75  1  C9 46                CMP     #'F'            ;see if F
000B77  1  D0 05                BNE     PNOTF           ;branch if not
000B79  1  8C 0F 34             STY     LSTFLG          ;else set
000B7C  1  F0 D2                BEQ     INSCAP          ;and loop
000B7E  1               PNOTF
000B7E  1  A0 00                LDY     #FALSE          ;now use false
000B80  1  C9 42                CMP     #'B'            ;if not B
000B82  1  D0 05                BNE     PNOTB           ;try next
000B84  1  8C 0B 34             STY     LSTSRC          ;else set
000B87  1  F0 C7                BEQ     INSCAP          ;and loop
000B89  1               PNOTB
000B89  1  C9 44                CMP     #'D'            ;if not D
000B8B  1  D0 C3                BNE     INSCAP          ;then not valid
000B8D  1  8C 0D 34             STY     LWRUPR          ;else set
000B90  1  F0 BE                BEQ     INSCAP          ;and loop
000B92  1               ;done with INSCAN so get first non-blank
000B92  1               INSDNE
000B92  1  A9 00                LDA     #0              ;clear eol flag
000B94  1  8D 10 34             STA     EOLSTS
000B97  1  4C 91 0A             JMP     GTNBLK
000B9A  1               ;put NXTCHR in ACCUM
000B9A  1               PUTACC
000B9A  1  24 6E                BIT     CONT            ;test for continue
000B9C  1  10 01                BPL     *+3             ;do if not
000B9E  1  60                   RTS                     ;else done
000B9F  1  E6 4E                INC     ACCLEN          ;bump length
000BA1  1  A6 4E                LDX     ACCLEN          ;get it as index
000BA3  1  A5 4D                LDA     NXTCHR          ;get next
000BA5  1  95 4E                STA     ACCUM,X         ;store it
000BA7  1  18                   CLC                     ;clear carry
000BA8  1  65 4C                ADC     HSHCDE          ;add hashcde
000BAA  1  29 3F                AND     #HSHMSK         ;mask it
000BAC  1  85 4C                STA     HSHCDE          ;and save
000BAE  1  E0 1F                CPX     #IDNTSZ-1       ;compare to max
000BB0  1  B0 01                BCS     *+3             ;branch if too big
000BB2  1  60                   RTS                     ;else done
000BB3  1  A9 FF                LDA     #TRUE           ;set CONT
000BB5  1  85 6E                STA     CONT            ;flag
000BB7  1  60                   RTS
000BB8  1               ;put NXTCHR in ACCUM and get another non-blank
000BB8  1               PUTGET
000BB8  1  20 9A 0B             JSR     PUTACC          ;put
000BBB  1  4C 91 0A             JMP     GTNBLK          ;and get
000BBE  1               ;put NXTCHR in ACCUM and get another char
000BBE  1               PUTCHR
000BBE  1  20 9A 0B             JSR     PUTACC          ;put
000BC1  1  4C 15 0A             JMP     GETCHR          ;and get
000BC4  1               ;test for numeric NXTCHR. return with A:=TRUE iff NXTCHR in '0' to '9'
000BC4  1               NUMRIC
000BC4  1  A5 4D                LDA     NXTCHR          ;get char
000BC6  1  C9 30                CMP     #'0'            ;see if less than 0
000BC8  1  90 07                BCC     NOTNUM          ;branch if is
000BCA  1  C9 3A                CMP     #'9'+1          ;see if over 9
000BCC  1  B0 03                BCS     NOTNUM          ;branch if is
000BCE  1  A9 FF                LDA     #TRUE           ;else set
000BD0  1  60                   RTS                     ;for numeric
000BD1  1               NOTNUM
000BD1  1  A9 00                LDA     #FALSE          ;set false
000BD3  1  60                   RTS
000BD4  1               ;test for lower case NXTCHR. return with A:=TRUE iff NXTCHR in 'a' to 'z'
000BD4  1               LWRCSE
000BD4  1  A5 4D                LDA     NXTCHR          ;get chat
000BD6  1  C9 61                CMP     #'a'            ;see if < a
000BD8  1  90 07                BCC     NOTLWR          ;branch if is
000BDA  1  C9 7B                CMP     #'z'+1          ;see if > z
000BDC  1  B0 03                BCS     NOTLWR          ;branch if is
000BDE  1  A9 FF                LDA     #TRUE           ;else
000BE0  1  60                   RTS                     ;is lower
000BE1  1               NOTLWR
000BE1  1  A9 00                LDA     #FALSE          ;not lower
000BE3  1  60                   RTS
000BE4  1               ;test for NXTCHR a decimal point
000BE4  1               DCMLPT
000BE4  1  A5 4D                LDA     NXTCHR          ;get char
000BE6  1  C9 2E                CMP     #'.'            ;test it
000BE8  1  D0 03                BNE     NTDCML          ;branch if not
000BEA  1  A9 FF                LDA     #TRUE           ;set for true
000BEC  1  60                   RTS
000BED  1               NTDCML
000BED  1  A9 00                LDA     #FALSE          ;false
000BEF  1  60                   RTS
000BF0  1               ;convert lowercase to uppercase
000BF0  1               CNVLWR
000BF0  1  20 D4 0B             JSR     LWRCSE          ;see if lower
000BF3  1  2D 0D 34             AND     LWRUPR          ;and with flag
000BF6  1  D0 01                BNE     *+3             ;ok if both true
000BF8  1  60                   RTS                     ;else done
000BF9  1  A5 4D                LDA     NXTCHR          ;get char
000BFB  1  29 5F                AND     #$5F            ;convert
000BFD  1  85 4D                STA     NXTCHR          ;and save
000BFF  1  60                   RTS
000C00  1               ;test for letter. set A:=TRUE if lowercase or uppercase letter
000C00  1               LETTER
000C00  1  20 F0 0B             JSR     CNVLWR          ;covert if all set
000C03  1  20 D4 0B             JSR     LWRCSE          ;see if still lowercase
000C06  1  F0 01                BEQ     *+3             ;branch if not
000C08  1  60                   RTS                     ;else is TRUE
000C09  1  A5 4D                LDA     NXTCHR          ;get char
000C0B  1  C9 41                CMP     #'A'            ;if < A
000C0D  1  90 07                BCC     NOTLTR          ;is not letter
000C0F  1  C9 5B                CMP     #'Z'+1          ;if > Z
000C11  1  B0 03                BCS     NOTLTR          ;is not letter
000C13  1  A9 FF                LDA     #TRUE           ;else is
000C15  1  60                   RTS
000C16  1               NOTLTR
000C16  1  A9 00                LDA     #FALSE          ;not letter
000C18  1  60                   RTS
000C19  1               ;test for letter, number or decimal point. return A:=TRUE if either
000C19  1               ALPNUM
000C19  1  20 00 0C             JSR     LETTER          ;first try letter
000C1C  1  F0 01                BEQ     *+3             ;branch if not
000C1E  1  60                   RTS
000C1F  1  20 C4 0B             JSR     NUMRIC          ;now try number
000C22  1  F0 01                BEQ     *+3             ;branch if not
000C24  1  60                   RTS
000C25  1  4C E4 0B             JMP     DCMLPT          ;finally try decimal point
000C28  1               ;spool numeric data into ACCUM
000C28  1               SPLNUM
000C28  1  20 C4 0B             JSR     NUMRIC          ;see if number
000C2B  1  D0 01                BNE     *+3             ;branch if is
000C2D  1  60                   RTS                     ;else done
000C2E  1  20 BE 0B             JSR     PUTCHR          ;stuff it
000C31  1  4C 28 0C             JMP     SPLNUM          ;and loop
000C34  1               ;set up next call
000C34  1               SUPNCL
000C34  1  A5 4D                LDA     NXTCHR          ;get next
000C36  1  C9 20                CMP     #SPACE          ;see if blank
000C38  1  D0 03                BNE     *+5             ;branch if not
000C3A  1  20 91 0A             JSR     GTNBLK          ;get non-blank
000C3D  1  A9 00                LDA     #FALSE          ;set continue
000C3F  1  85 6E                STA     CONT            ;to false
000C41  1  60                   RTS
000C42  1               ;procedure called by SYNTHE to reduce the amount of indexing
000C42  1               SCOPY
000C42  1  A6 7B                LDX     SP              ;get stack pointer
000C44  1  BD 02 35             LDA     TYPE,X          ;do
000C47  1  85 80                STA     TYPESP          ;byte
000C49  1  BD 22 35             LDA     STYPE,X         ;values
000C4C  1  85 83                STA     STYPSP          ;first
000C4E  1  BD C2 34             LDA     HASH,X
000C51  1  85 8C                STA     HASHSP
000C53  1  8A                   TXA                     ;now
000C54  1  0A                   ASL     A               ;make a
000C55  1  AA                   TAX                     ;word index
000C56  1  BD 82 35             LDA     SYMLOC,X
000C59  1  BC 83 35             LDY     SYMLOC+1,X
000C5C  1  85 86                STA     SYMLSP
000C5E  1  84 87                STY     SYMLSP+1
000C60  1  BD 42 35             LDA     SRLOC,X
000C63  1  BC 43 35             LDY     SRLOC+1,X
000C66  1  85 8F                STA     SRLOSP
000C68  1  84 90                STY     SRLOSP+1
000C6A  1  A6 7C                LDX     MP              ;now get MP
000C6C  1  BD 02 35             LDA     TYPE,X
000C6F  1  85 82                STA     TYPEMP
000C71  1  BD 22 35             LDA     STYPE,X
000C74  1  85 85                STA     STYPMP
000C76  1  BD C2 34             LDA     HASH,X
000C79  1  85 8E                STA     HASHMP
000C7B  1  8A                   TXA                     ;now
000C7C  1  0A                   ASL     A               ;make a
000C7D  1  AA                   TAX                     ;word index
000C7E  1  BD 82 35             LDA     SYMLOC,X
000C81  1  BC 83 35             LDY     SYMLOC+1,X
000C84  1  85 8A                STA     SYMLMP
000C86  1  84 8B                STY     SYMLMP+1
000C88  1  BD 42 35             LDA     SRLOC,X
000C8B  1  BC 43 35             LDY     SRLOC+1,X
000C8E  1  85 91                STA     SRLOMP
000C90  1  84 92                STY     SRLOMP+1
000C92  1  A6 7D                LDX     MPP1            ;now get MP+1
000C94  1  BD 02 35             LDA     TYPE,X
000C97  1  85 81                STA     TYPEM1
000C99  1  BD 22 35             LDA     STYPE,X
000C9C  1  85 84                STA     STYPM1
000C9E  1  BD C2 34             LDA     HASH,X
000CA1  1  85 8D                STA     HASHM1
000CA3  1  8A                   TXA                     ;now
000CA4  1  0A                   ASL     A               ;make a
000CA5  1  AA                   TAX                     ;word index
000CA6  1  BD 82 35             LDA     SYMLOC,X
000CA9  1  BC 83 35             LDY     SYMLOC+1,X
000CAC  1  85 88                STA     SYMLM1
000CAE  1  84 89                STY     SYMLM1+1
000CB0  1  60                   RTS
000CB1  1               ;called by SYNTHE to set SYMLOC(SP) to AY
000CB1  1               STSLSP
000CB1  1  48                   PHA                     ;save A part
000CB2  1  A5 7B                LDA     SP              ;get SP
000CB4  1               STSL
000CB4  1  0A                   ASL     A               ;mult by two
000CB5  1  AA                   TAX                     ;make index
000CB6  1  68                   PLA                     ;get byte
000CB7  1  9D 82 35             STA     SYMLOC,X        ;save it
000CBA  1  98                   TYA                     ;get high
000CBB  1  9D 83 35             STA     SYMLOC+1,X      ;save it
000CBE  1  60                   RTS
000CBF  1               ;called by SYNTHE to set SYMLOC(MP) to AY
000CBF  1               STSLMP
000CBF  1  48                   PHA                     ;save low
000CC0  1  A5 7C                LDA     MP              ;get MP
000CC2  1  4C B4 0C             JMP     STSL            ;go do
000CC5  1               ;called by SYNTHE to set TYPE(SP) to A
000CC5  1               STTYSP
000CC5  1  A6 7B                LDX     SP              ;get SP
000CC7  1  9D 02 35             STA     TYPE,X          ;save
000CCA  1  60                   RTS
000CCB  1               ;called by SYNTHE to set STYPE(SP) to A
000CCB  1               STSTSP
000CCB  1  A6 7B                LDX     SP              ;get SP
000CCD  1  9D 22 35             STA     STYPE,X         ;save
000CD0  1  60                   RTS
000CD1  1               ;set STYPE(MP) to A
000CD1  1               STSTMP
000CD1  1  A6 7C                LDX     MP              ;get MP
000CD3  1  9D 22 35             STA     STYPE,X         ;save
000CD6  1  60                   RTS
000CD7  1               ;set TYPE(MP) to A
000CD7  1               STTYMP
000CD7  1  A6 7C                LDX     MP              ;get MP
000CD9  1  9D 02 35             STA     TYPE,X          ;save
000CDC  1  60                   RTS
000CDD  1               ;set HASH(MP) to A
000CDD  1               STHAMP
000CDD  1  A6 7C                LDX     MP              ;get MP
000CDF  1  9D C2 34             STA     HASH,X          ;insert
000CE2  1  60                   RTS
000CE3  1               ;set HASH(SP) to A
000CE3  1               STHASP
000CE3  1  A6 7B                LDX     SP              ;get SP
000CE5  1  9D C2 34             STA     HASH,X          ;insert
000CE8  1  60                   RTS
000CE9  1               ;set SRLOC(SP) to AY
000CE9  1               STSRSP
000CE9  1  48                   PHA                     ;save low
000CEA  1  A5 7B                LDA     SP              ;get SP
000CEC  1  0A                   ASL     A               ;mult by two
000CED  1  AA                   TAX                     ;make index
000CEE  1  68                   PLA                     ;get low
000CEF  1  9D 42 35             STA     SRLOC,X         ;save ir
000CF2  1  98                   TYA                     ;get high
000CF3  1  9D 43 35             STA     SRLOC+1,X       ;save it
000CF6  1  60                   RTS
000CF7  1               ;write generated code in A and count size of code area
000CF7  1               GENERT
000CF7  1  E6 B2                INC     CODESI          ;bump
000CF9  1  D0 02                BNE     *+4             ;code
000CFB  1  E6 B3                INC     CODESI+1        ;size
000CFD  1  2C 08 34             BIT     PASS1           ;test for pass 1
000D00  1  30 03                BMI     *+5             ;branch if
000D02  1  4C B6 09             JMP     EMIT            ;else go emit
000D05  1  60                   RTS
000D06  1               ;write data in A during pass 2 and count size of data area
000D06  1               EMITDT
000D06  1  E6 45                INC     DATACT          ;bump
000D08  1  D0 02                BNE     *+4             ;data
000D0A  1  E6 46                INC     DATACT+1        ;size
000D0C  1  2C 09 34             BIT     PASS2           ;test for pass 2
000D0F  1  10 03                BPL     *+5             ;branch if not
000D11  1  4C B6 09             JMP     EMIT            ;else go emit
000D14  1  60                   RTS
000D15  1               ;compare ACCUM to reserved word string
000D15  1               COMPAR
000D15  1  A9 00                LDA     #0
000D17  1  85 A1                STA     IC
000D19  1               COMPA0
000D19  1  A4 A1                LDY     IC
000D1B  1  8B DA A2 01          LDAINDIRECTY PTR        ;a=field(i)
000D1F  1  B5 A2 C9 00  
000D23  1  D0 04 A2 00  
000D31  1  E6 A1                INC     IC
000D33  1  A4 A1                LDY     IC              ;i=i+1
000D35  1                       .IFDEF DUODYNE
000D35  1  DA                   PHX
000D36  1  BB                   TYX
000D37  1  D5 4E                CMP     ACCUM,X         ;compare field(i) to accum(i=i+1)
000D39  1  FA                   PLX
000D3A  1                       .ELSE
000D3A  1                       CMP     ACCUM,Y         ;compare field(i) to accum(i=i+1)
000D3A  1                       .ENDIF
000D3A  1  D0 09                BNE     COMPAX          ;exit if different
000D3C  1  A5 4E                LDA     ACCLEN
000D3E  1  C5 A1                CMP     IC              ;if i<=acclen
000D40  1  B0 D7                BCS     COMPA0          ;then loop
000D42  1               COMPAT
000D42  1  A9 FF                LDA     #TRUE           ;was a match
000D44  1  60                   RTS
000D45  1               COMPAX
000D45  1  A5 4E                LDA     ACCLEN          ;check termination condition
000D47  1  C5 A1                CMP     IC
000D49  1  90 F7                BCC     COMPAT          ;if i>acclen is true
000D4B  1  A9 00                LDA     #FALSE
000D4D  1  60                   RTS
000D4E  1               ;attempt to match reserved word
000D4E  1               LOOKUP
000D4E  1  A9 09                LDA     #MAXRWL         ;compare max word length
000D50  1  C5 4E                CMP     ACCLEN          ;to length
000D52  1  90 5A                BCC     LOOKFL          ;exit as false if too big
000D54  1  A6 4E                LDX     ACCLEN          ;get length
000D56  1  BD F9 2F             LDA     OFFSET,X        ;and offset
000D59  1  18                   CLC                     ;in reserved word table
000D5A  1  69 B8                ADC     #<LNG1          ;now add to
000D5C  1  85 A2                STA     PTR             ;start to
000D5E  1  A9 00                LDA     #0              ;get
000D60  1  69 2E                ADC     #>LNG1          ;indirect
000D62  1  85 A3                STA     PTR+1           ;pointer
000D64  1  A9 00                LDA     #0              ;set index
000D66  1  85 A4                STA     IL              ;to zero
000D68  1               LOOKU0
000D68  1  E6 A4                INC     IL              ;bump index
000D6A  1  A6 4E                LDX     ACCLEN          ;see if count
000D6C  1  BD 03 30             LDA     COUNT,X         ;bigger than
000D6F  1  C5 A4                CMP     IL              ;number words
000D71  1  90 3B                BCC     LOOKFL          ;no match if is
000D73  1  20 15 0D             JSR     COMPAR          ;try to match
000D76  1  D0 0E                BNE     LOOKMT          ;branch if did
000D78  1  18                   CLC                     ;else
000D79  1  A5 A2                LDA     PTR             ;bump
000D7B  1  65 4E                ADC     ACCLEN          ;pointer
000D7D  1  85 A2                STA     PTR             ;by length
000D7F  1  90 E7                BCC     LOOKU0          ;of word
000D81  1  E6 A3                INC     PTR+1           ;and try
000D83  1  4C 68 0D             JMP     LOOKU0          ;next
000D86  1               LOOKMT
000D86  1  A6 4E                LDX     ACCLEN          ;get length
000D88  1  BD 0D 30             LDA     TKOS,X          ;and token offset
000D8B  1  18                   CLC                     ;add to
000D8C  1  65 A4                ADC     IL              ;index
000D8E  1  AA                   TAX                     ;make an index
000D8F  1  BD A9 2F             LDA     TK,X            ;get token
000D92  1  85 49                STA     TOKEN           ;and save
000D94  1  C9 41                CMP     #64+1           ;see if over 64
000D96  1  90 13                BCC     LOOKTR          ;branch if not
000D98  1  C9 63                CMP     #TDATA          ;see if TDATA
000D9A  1  F0 0F                BEQ     LOOKTR          ;branch if is
000D9C  1  85 4B                STA     FUNCOP          ;else save as FUNCOP
000D9E  1  38                   SEC                     ;now subtract
000D9F  1  E9 41                SBC     #65             ;65 to
000DA1  1  AA                   TAX                     ;make index
000DA2  1  BD 17 30             LDA     ST,X            ;get subtype
000DA5  1  85 4A                STA     SUBTYP          ;and save
000DA7  1  A9 35                LDA     #FUNCT
000DA9  1  85 49                STA     TOKEN           ;token=funct
000DAB  1               LOOKTR
000DAB  1  A9 FF                LDA     #TRUE           ;match
000DAD  1  60                   RTS
000DAE  1               LOOKFL
000DAE  1  A9 00                LDA     #FALSE          ;no match
000DB0  1  60                   RTS
000DB1  1               ;scanner accepts input characters from the source file returning tokens to the
000DB1  1               ;parser.  conversion to uppercase is performed if LWRUPR is set.  each token is
000DB1  1               ;placed in ACCUM and ACCLEN is the length of the token.  the token is hashed by
000DB1  1               ;summing each ASCII character modulo HSHTSZ (hashtablesize) and is stored in
000DB1  1               ;HSHCDE (hashcode).  SUBTYP and FUNCOP are set if the token is a predefined
000DB1  1               ;function.  REM and DATA statements are handled completely by the scanner. REM
000DB1  1               ;and REMARK statements cause the input to be scanned until the end of the
000DB1  1               ;current input line is located.  the cr is then scanned and returned.  DATA
000DB1  1               ;statements are similar except data is output using EMITDT.
000DB1  1               SCANNR
000DB1  1  A9 00                LDA     #0              ;clear
000DB3  1  85 4E                STA     ACCLEN          ;these
000DB5  1  85 4C                STA     HSHCDE          ;variables
000DB7  1  85 49                STA     TOKEN           ;at
000DB9  1  85 4A                STA     SUBTYP          ;start
000DBB  1  24 6E                BIT     CONT            ;test continue flag
000DBD  1  30 13                BMI     SCAN1           ;branch if set
000DBF  1  2C 10 34             BIT     EOLSTS          ;test eol status
000DC2  1  10 08                BPL     SCAN28          ;skip if char ready
000DC4  1  20 91 0A             JSR     GTNBLK          ;else go read
000DC7  1  A9 00                LDA     #0              ;then clear flag
000DC9  1  8D 10 34             STA     EOLSTS
000DCC  1               SCAN28
000DCC  1  A5 4D                LDA     NXTCHR          ;else get next
000DCE  1  C9 22                CMP     #'"'            ;see if "
000DD0  1  D0 2E                BNE     SCAN5           ;branch if not
000DD2  1               ;first case is string or string continuation
000DD2  1               SCAN1
000DD2  1  A9 32                LDA     #STRING         ;get token
000DD4  1  85 49                STA     TOKEN           ;and set
000DD6  1  A9 00                LDA     #FALSE          ;and set
000DD8  1  85 6E                STA     CONT            ;CONT as false
000DDA  1               SCAN2
000DDA  1  20 15 0A             JSR     GETCHR          ;get char
000DDD  1  C9 22                CMP     #'"'            ;see if delimiter
000DDF  1  F0 11                BEQ     SCAN4           ;branch if is
000DE1  1  C9 0D                CMP     #CR             ;see if eol
000DE3  1  D0 05                BNE     SCAN3           ;branch if not
000DE5  1  A9 16                LDA     #22             ;else is unterminated string
000DE7  1  4C AE 0A             JMP     ERROR           ;do error and quit
000DEA  1               SCAN3
000DEA  1  20 9A 0B             JSR     PUTACC          ;put in ACCUM
000DED  1  24 6E                BIT     CONT            ;test for continue
000DEF  1  10 E9                BPL     SCAN2           ;loop if not
000DF1  1  60                   RTS                     ;else done
000DF2  1               SCAN4
000DF2  1  20 91 0A             JSR     GTNBLK          ;get non-blank
000DF5  1  C9 22                CMP     #'"'            ;see if another delimiter
000DF7  1  F0 01                BEQ     *+3             ;branch if is
000DF9  1  60                   RTS                     ;else done
000DFA  1  20 9A 0B             JSR     PUTACC          ;put in ACCUM
000DFD  1  4C DA 0D             JMP     SCAN2           ;and loop
000E00  1               SCAN5
000E00  1  20 C4 0B             JSR     NUMRIC          ;see if number
000E03  1  D0 05                BNE     SCAN6           ;branch if is
000E05  1  20 E4 0B             JSR     DCMLPT          ;see if decimal point
000E08  1  F0 51                BEQ     SCAN15          ;branch if not
000E0A  1               ;is a numeric of up to IDNTSZ-1 characters
000E0A  1               SCAN6
000E0A  1  A9 31                LDA     #FLOTPT         ;get token
000E0C  1  85 49                STA     TOKEN           ;and set
000E0E  1  A5 4D                LDA     NXTCHR          ;get next char
000E10  1               SCAN7
000E10  1  C9 30                CMP     #'0'            ;see if leading zero
000E12  1  D0 06                BNE     SCAN8           ;branch if not
000E14  1  20 15 0A             JSR     GETCHR          ;else get next
000E17  1  4C 10 0E             JMP     SCAN7           ;and loop to flush
000E1A  1               SCAN8
000E1A  1  20 28 0C             JSR     SPLNUM          ;spool numeric
000E1D  1  20 E4 0B             JSR     DCMLPT          ;test for decimal point
000E20  1  F0 06                BEQ     SCAN9           ;branch if not
000E22  1  20 BE 0B             JSR     PUTCHR          ;insert it
000E25  1  20 28 0C             JSR     SPLNUM          ;spool rest
000E28  1               SCAN9
000E28  1  20 F0 0B             JSR     CNVLWR          ;convert next to upper
000E2B  1  A5 4D                LDA     NXTCHR          ;get it
000E2D  1  C9 45                CMP     #'E'            ;see if e for exponent
000E2F  1  D0 1B                BNE     SCAN13          ;branch if not
000E31  1  20 B8 0B             JSR     PUTGET          ;else insert and get another
000E34  1  C9 2B                CMP     #'+'            ;if a +
000E36  1  F0 04                BEQ     SCAN10          ;go insert and get another
000E38  1  C9 2D                CMP     #'-'            ;if not a -
000E3A  1  D0 03                BNE     SCAN11          ;skip ahead
000E3C  1               SCAN10
000E3C  1  20 B8 0B             JSR     PUTGET          ;insert and get
000E3F  1               SCAN11
000E3F  1  20 C4 0B             JSR     NUMRIC          ;test for number
000E42  1  D0 05                BNE     SCAN12          ;branch if is
000E44  1  A9 09                LDA     #9              ;else illegal floating point format
000E46  1  20 AE 0A             JSR     ERROR           ;error
000E49  1               SCAN12
000E49  1  20 28 0C             JSR     SPLNUM          ;spool numbers
000E4C  1               SCAN13
000E4C  1  A5 4E                LDA     ACCLEN          ;get length
000E4E  1  D0 08                BNE     SCAN14          ;branch if not zero
000E50  1  E6 4E                INC     ACCLEN          ;else bump
000E52  1  A9 30                LDA     #'0'            ;and insert a '0'
000E54  1  85 4F                STA     ACCUM+1         ;in ACCUM
000E56  1  85 4C                STA     HSHCDE          ;and hashcode
000E58  1               SCAN14
000E58  1  4C 34 0C             JMP     SUPNCL          ;setupnextcall and return
000E5B  1               SCAN15
000E5B  1  20 00 0C             JSR     LETTER          ;see if letter
000E5E  1  D0 03                BNE     *+5             ;continue if is
000E60  1  4C F7 0E             JMP     SCAN26          ;else go to next section
000E63  1               ;is an identifier or may be REM, REMARK, or DATA statements. these two are
000E63  1               ;handled here
000E63  1               SCAN16
000E63  1  20 19 0C             JSR     ALPNUM          ;test for alphanumeric
000E66  1  F0 06                BEQ     SCAN17          ;branch if not
000E68  1  20 BE 0B             JSR     PUTCHR          ;else insert and get
000E6B  1  4C 63 0E             JMP     SCAN16          ;and loop
000E6E  1               SCAN17
000E6E  1  A5 4D                LDA     NXTCHR          ;get next char
000E70  1  C9 24                CMP     #'$'            ;if not a $
000E72  1  D0 0A                BNE     SCAN18          ;is floating
000E74  1  A9 32                LDA     #STRING         ;else set string
000E76  1  85 4A                STA     SUBTYP          ;as subtype
000E78  1  20 BE 0B             JSR     PUTCHR          ;put and get
000E7B  1  4C 82 0E             JMP     SCAN19          ;and continue
000E7E  1               SCAN18
000E7E  1  A9 31                LDA     #FLOTPT         ;set floating
000E80  1  85 4A                STA     SUBTYP          ;as subtype
000E82  1               SCAN19
000E82  1  20 4E 0D             JSR     LOOKUP          ;try to match
000E85  1  D0 20                BNE     SCAN21          ;branch if reserved
000E87  1  A5 4F                LDA     ACCUM+1         ;check for user
000E89  1  C9 46                CMP     #'F'            ;defined function
000E8B  1  D0 13                BNE     SCAN20          ;branch if not
000E8D  1  A5 50                LDA     ACCUM+2         ;same for next
000E8F  1  C9 4E                CMP     #'N'            ;char in ACCUM
000E91  1  D0 0D                BNE     SCAN20
000E93  1  A5 4E                LDA     ACCLEN          ;get length
000E95  1  C9 01                CMP     #1              ;must not be 1
000E97  1  F0 07                BEQ     SCAN20          ;branch if is
000E99  1  A9 36                LDA     #UDFUNC         ;ah!ah! is FN--
000E9B  1  85 49                STA     TOKEN           ;set token
000E9D  1  4C 34 0C             JMP     SUPNCL          ;exit with setupnextcall
000EA0  1               SCAN20
000EA0  1  A9 34                LDA     #IDENT          ;is identifier
000EA2  1  85 49                STA     TOKEN           ;set token
000EA4  1  4C 34 0C             JMP     SUPNCL          ;exit with setupnextcall
000EA7  1               SCAN21
000EA7  1  A5 49                LDA     TOKEN           ;is a reserved
000EA9  1  C9 00                CMP     #TREM           ;see if REM
000EAB  1  D0 12                BNE     SCAN23          ;branch if not
000EAD  1               SCAN22
000EAD  1  A5 4D                LDA     NXTCHR          ;get next
000EAF  1  C9 0D                CMP     #CR             ;see if eol
000EB1  1  D0 03                BNE     *+5             ;branch if not
000EB3  1  4C B1 0D             JMP     SCANNR          ;else loop to start
000EB6  1  20 15 0A             JSR     GETCHR          ;get char
000EB9  1  20 9D 0A             JSR     CHKCNT          ;check for continue
000EBC  1  4C AD 0E             JMP     SCAN22          ;and loop
000EBF  1               SCAN23
000EBF  1  C9 63                CMP     #TDATA          ;see if DATA
000EC1  1  F0 03                BEQ     *+5             ;branch if is
000EC3  1  4C 34 0C             JMP     SUPNCL          ;else setupnextcall and exit
000EC6  1  A9 33                LDA     #DAT            ;emit DAT opcode
000EC8  1  20 06 0D             JSR     EMITDT          ;to start
000ECB  1  A5 4D                LDA     NXTCHR          ;get next
000ECD  1  20 06 0D             JSR     EMITDT          ;emit it
000ED0  1               SCAN24
000ED0  1  20 15 0A             JSR     GETCHR          ;get another
000ED3  1  C9 0D                CMP     #CR             ;see if eol
000ED5  1  F0 0B                BEQ     SCAN25          ;branch if is
000ED7  1  20 9D 0A             JSR     CHKCNT          ;else check for continue
000EDA  1  A5 4D                LDA     NXTCHR          ;get char
000EDC  1  20 06 0D             JSR     EMITDT          ;emit it
000EDF  1  4C D0 0E             JMP     SCAN24          ;and loop
000EE2  1               SCAN25
000EE2  1  A9 2C                LDA     #','            ;now emit
000EE4  1  20 06 0D             JSR     EMITDT          ;a comma
000EE7  1  A9 00                LDA     #0              ;and a
000EE9  1  20 06 0D             JSR     EMITDT          ;zero
000EEC  1  A5 45                LDA     DATACT          ;now
000EEE  1  D0 02                BNE     *+4             ;drop
000EF0  1  C6 46                DEC     DATACT+1        ;data count
000EF2  1  C6 45                DEC     DATACT          ;by one
000EF4  1  4C B1 0D             JMP     SCANNR          ;and loop to start
000EF7  1               ;final case is a special character -- it may be continuation char in which case
000EF7  1               ;just go to next line and scan somemore
000EF7  1               SCAN26
000EF7  1  A5 4D                LDA     NXTCHR          ;get char
000EF9  1  C9 5C                CMP     #backsl         ;see if continue
000EFB  1  D0 06                BNE     SCAN27          ;branch if not
000EFD  1  20 9D 0A             JSR     CHKCNT          ;check it
000F00  1  4C B1 0D             JMP     SCANNR          ;and loop
000F03  1               SCAN27
000F03  1  20 9A 0B             JSR     PUTACC          ;put in accum
000F06  1  A5 4D                LDA     NXTCHR          ;get last char
000F08  1  C9 0D                CMP     #CR             ;see if eol
000F0A  1  D0 07                BNE     SCAN29          ;not so skip
000F0C  1  A9 FF                LDA     #$FF            ;set flag to read
000F0E  1  8D 10 34             STA     EOLSTS
000F11  1  30 03                BMI     SCAN30          ;then jump ahead
000F13  1               SCAN29
000F13  1  20 91 0A             JSR     GTNBLK          ;get non blank
000F16  1               SCAN30
000F16  1  20 4E 0D             JSR     LOOKUP          ;see if match
000F19  1  F0 01                BEQ     *+3             ;branch if not
000F1B  1  60                   RTS                     ;else done
000F1C  1  A9 07                LDA     #7              ;illegal character error
000F1E  1  4C AE 0A             JMP     ERROR           ;and quit
000F21  1               ;adjust base for next entry
000F21  1               NXTENT
000F21  1  A0 00                LDY     #0              ;clear index
000F23  1  8B DA A2 01          LDAINDIRECTY BASE       ;get name length
000F27  1  B5 A7 C9 00  
000F2B  1  D0 04 A2 00  
000F39  1  18                   CLC                     ;now
000F3A  1  65 A7                ADC     BASE            ;add to current
000F3C  1  85 A7                STA     BASE            ;and update
000F3E  1  90 02                BCC     *+4             ;don't forget
000F40  1  E6 A8                INC     BASE+1          ;carry
000F42  1  18                   CLC                     ;now
000F43  1  A5 A7                LDA     BASE            ;add
000F45  1  69 07                ADC     #7              ;seven for
000F47  1  85 A7                STA     BASE            ;overhead
000F49  1  90 02                BCC     *+4             ;to get
000F4B  1  E6 A8                INC     BASE+1          ;new base
000F4D  1  60                   RTS
000F4E  1               ;get length of printname
000F4E  1               GETLEN
000F4E  1  A0 00                LDY     #0              ;clear index
000F50  1  8B DA A2 01          LDAINDIRECTY BASE       ;get length
000F54  1  B5 A7 C9 00  
000F58  1  D0 04 A2 00  
000F66  1  60                   RTS
000F67  1               ;write numeric constant during pass 1
000F67  1               EMITCN
000F67  1  2C 08 34             BIT     PASS1           ;test for pass 1
000F6A  1  30 01                BMI     *+3             ;branch if is
000F6C  1  60                   RTS                     ;else done
000F6D  1  4C B6 09             JMP     EMIT            ;write byte
000F70  1               ;write two bytes of object code on disk for literals
000F70  1               GENTWO
000F70  1  48                   PHA                     ;save low
000F71  1  98                   TYA                     ;get high
000F72  1  20 F7 0C             JSR     GENERT          ;write it
000F75  1  68                   PLA                     ;get low
000F76  1  4C F7 0C             JMP     GENERT          ;do it
000F79  1               ;
000F79  1               LITERL
000F79  1  48                   PHA                     ;save low
000F7A  1  98                   TYA                     ;get high
000F7B  1  09 80                ORA     #$80            ;set msb
000F7D  1  A8                   TAY                     ;back to Y
000F7E  1  68                   PLA                     ;get low
000F7F  1  4C 70 0F             JMP     GENTWO          ;send it
000F82  1               ;
000F82  1               LITLOD
000F82  1  48                   PHA                     ;save low
000F83  1  98                   TYA                     ;get high
000F84  1  09 C0                ORA     #$C0            ;or with mask
000F86  1  A8                   TAY                     ;back to Y
000F87  1  68                   PLA                     ;get low
000F88  1  4C 70 0F             JMP     GENTWO          ;write it
000F8B  1               ;
000F8B  1               LINENU
000F8B  1  2C 0C 34             BIT     DEBUGL          ;test debug flag
000F8E  1  30 01                BMI     *+3             ;branch if set
000F90  1  60                   RTS                     ;else do nothing
000F91  1  A5 70                LDA     LINENO          ;get low
000F93  1  A4 71                LDY     LINENO+1        ;and high number
000F95  1  20 79 0F             JSR     LITERL          ;send as literal
000F98  1  A9 5F                LDA     #BOL            ;then send BOL
000F9A  1  4C F7 0C             JMP     GENERT          ;opcode
000F9D  1               ;fill hashtable with 0's and initialize pointer to top of symbol table
000F9D  1               INSYMT
000F9D  1  2C 08 34             BIT     PASS1           ;see if pass 1
000FA0  1  10 14                BPL     INSYM1          ;branch if not
000FA2  1  A2 7F                LDX     #HSHTSZ*2-1     ;get number to clear
000FA4  1  A9 00                LDA     #0              ;then value
000FA6  1               INSYM0
000FA6  1  9D 42 34             STA     HSHTBL,X        ;store it
000FA9  1  CA                   DEX                     ;drop count
000FAA  1  E0 FF                CPX     #255            ;see if wrap
000FAC  1  D0 F8                BNE     INSYM0          ;loop if not
000FAE  1  A9 C9                LDA     #<MEMORY        ;get memory
000FB0  1  A0 37                LDY     #>MEMORY        ;start
000FB2  1  85 AA                STA     SBTBL           ;and set
000FB4  1  84 AB                STY     SBTBL+1         ;table start
000FB6  1               INSYM1
000FB6  1  AD 04 01             LDA     PEM+1           ;get limit
000FB9  1  AC 05 01             LDY     PEM+2           ;of memory
000FBC  1  38                   SEC                     ;drop
000FBD  1  E9 02                SBC     #2              ;two
000FBF  1  85 A5                STA     SBTTOP          ;to get
000FC1  1  85 B9                STA     NXSTPT          ;top starting
000FC3  1  B0 01                BCS     *+3             ;branch if no borrow
000FC5  1  88                   DEY                     ;else drop Y
000FC6  1  84 A6                STY     SBTTOP+1        ;set high
000FC8  1  84 BA                STY     NXSTPT+1        ;and set
000FCA  1  A9 00                LDA     #0              ;clear A
000FCC  1  A0 01                LDY     #1              ;set index to 1
000FCE  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put in memory
000FD2  1  01 B5 B9 C9  
000FD6  1  00 D0 04 A2  
000FE4  1  60                   RTS
000FE5  1               ;
000FE5  1               GETHSH
000FE5  1  A0 00                LDY     #0              ;get
000FE7  1  8B DA A2 01          LDAINDIRECTY BASE       ;PTR
000FEB  1  B5 A7 C9 00  
000FEF  1  D0 04 A2 00  
000FFD  1  85 BC                STA     TMPPTR          ;and save
000FFF  1  84 BB                STY     TMPHSH          ;clear internal hash
001001  1  A5 A7                LDA     BASE            ;get
001003  1  A4 A8                LDY     BASE+1          ;base
001005  1  18                   CLC                     ;now
001006  1  69 02                ADC     #2              ;add 2
001008  1  85 AC                STA     APTADD          ;and save
00100A  1  90 01                BCC     *+3             ;branch if
00100C  1  C8                   INY                     ;no carry
00100D  1  84 AD                STY     APTADD+1        ;save high
00100F  1  A0 01                LDY     #1              ;set starting index
001011  1               GETHS0
001011  1  C4 BC                CPY     TMPPTR          ;compare to limit
001013  1  F0 05                BEQ     GETHS1          ;continue if equal
001015  1  90 03                BCC     GETHS1          ;branch if less
001017  1  A5 BB                LDA     TMPHSH          ;else get HASH
001019  1  60                   RTS                     ;and quit
00101A  1               GETHS1
00101A  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get value
00101E  1  B5 AC C9 00  
001022  1  D0 04 A2 00  
001030  1  18                   CLC                     ;now add
001031  1  65 BB                ADC     TMPHSH          ;in old hash
001033  1  29 3F                AND     #HSHMSK         ;and mask
001035  1  85 BB                STA     TMPHSH          ;and save
001037  1  C8                   INY                     ;bump loop index
001038  1  4C 11 10             JMP     GETHS0          ;then loop
00103B  1               ;
00103B  1               HSOSYM
00103B  1  A5 B7                LDA     SYMHSH          ;get symhsh
00103D  1  0A                   ASL     A               ;mult by two
00103E  1  AA                   TAX                     ;make index
00103F  1  BD 42 34             LDA     HSHTBL,X        ;get value
001042  1  BC 43 34             LDY     HSHTBL+1,X      ;in table
001045  1  60                   RTS
001046  1               ;
001046  1               SETLNK
001046  1  A6 A7                LDX     BASE            ;get
001048  1  A4 A8                LDY     BASE+1          ;base
00104A  1  E8                   INX                     ;bump
00104B  1  86 AC                STX     APTADD          ;by
00104D  1  D0 01                BNE     *+3             ;one
00104F  1  C8                   INY                     ;and
001050  1  84 AD                STY     APTADD+1        ;save
001052  1  60                   RTS
001053  1               ;set pointer for addr reference with offset in A
001053  1               SETADP
001053  1  A0 00                LDY     #0              ;clear index
001055  1  18                   CLC                     ;and carry
001056  1  8B 48 DA A2          ADCINDIRECTY BASE       ;add PTR
00105A  1  01 B5 A7 C9  
00105E  1  00 D0 04 A2  
00106F  1  90 01                BCC     *+3             ;branch if no carry
001071  1  C8                   INY                     ;else set Y to 1
001072  1  18                   CLC                     ;clear carry
001073  1  65 A7                ADC     BASE            ;add base
001075  1  85 AC                STA     APTADD          ;to low
001077  1  98                   TYA                     ;now add
001078  1  65 A8                ADC     BASE+1          ;with carry to high
00107A  1  85 AD                STA     APTADD+1        ;and save
00107C  1  60                   RTS
00107D  1               ;check to see if additional SBTBL entry will overflow limits of memory. if
00107D  1               ;so then abort else return. at entry A contains amount to be added (COUNT)
00107D  1               LIMITS
00107D  1  18                   CLC                     ;add count
00107E  1  65 AA                ADC     SBTBL           ;to start
001080  1  A4 AB                LDY     SBTBL+1         ;with
001082  1  90 01                BCC     *+3             ;carry to
001084  1  C8                   INY                     ;high
001085  1  C5 A5                CMP     SBTTOP          ;compare to limit
001087  1  98                   TYA                     ;including
001088  1  E5 A6                SBC     SBTTOP+1        ;high
00108A  1  B0 01                BCS     *+3             ;whoops! no borrow
00108C  1  60                   RTS                     ;else ok
00108D  1  A9 FF                LDA     #TRUE           ;set to
00108F  1  8D 09 34             STA     PASS2           ;pass 2
001092  1  A9 13                LDA     #19             ;symbol table error
001094  1  20 AE 0A             JSR     ERROR           ;send it
001097  1  4C 00 01             JMP     BOOT            ;and abort
00109A  1               ;set the address field at location LOC in AY and resolved bit
00109A  1               SETRSV
00109A  1  48                   PHA                     ;save
00109B  1  98                   TYA                     ;A
00109C  1  48                   PHA                     ;and Y
00109D  1  A9 04                LDA     #4              ;set offset
00109F  1  20 53 10             JSR     SETADP          ;of four
0010A2  1  A0 01                LDY     #1              ;set index to 1
0010A4  1  68                   PLA                     ;get high
0010A5  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and save
0010A9  1  01 B5 AC C9  
0010AD  1  00 D0 04 A2  
0010BB  1  88                   DEY                     ;drop Y to 0
0010BC  1  68                   PLA                     ;get low
0010BD  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
0010C1  1  01 B5 AC C9  
0010C5  1  00 D0 04 A2  
0010D3  1  A5 AC                LDA     APTADD          ;now
0010D5  1  D0 02                BNE     *+4             ;drop
0010D7  1  C6 AD                DEC     APTADD+1        ;pointer
0010D9  1  C6 AC                DEC     APTADD          ;by one
0010DB  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now set
0010DF  1  B5 AC C9 00  
0010E3  1  D0 04 A2 00  
0010F1  1  09 80                ORA     #$80            ;resolved
0010F3  1  8B DA 48 A2          STAINDIRECTY APTADD     ;bit
0010F7  1  01 B5 AC C9  
0010FB  1  00 D0 04 A2  
001109  1  60                   RTS
00110A  1               ;return type of variable
00110A  1               GETTYP
00110A  1  A9 03                LDA     #3              ;build
00110C  1  20 53 10             JSR     SETADP          ;new indirect
00110F  1  A0 00                LDY     #0              ;clear index
001111  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get
001115  1  B5 AC C9 00  
001119  1  D0 04 A2 00  
001127  1  29 7F                AND     #$7F            ;mask out set bit
001129  1  60                   RTS
00112A  1               ;set type of variable to A and preserve resolved bit
00112A  1               SETTYP
00112A  1  48                   PHA                     ;save type
00112B  1  A9 03                LDA     #3              ;calculate
00112D  1  20 53 10             JSR     SETADP          ;new pointer
001130  1  A0 00                LDY     #0              ;clear index
001132  1  68                   PLA                     ;get type
001133  1  8B 48 DA A2          ORAINDIRECTY APTADD     ;or with contents
001137  1  01 B5 AC C9  
00113B  1  00 D0 04 A2  
00114C  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
001150  1  01 B5 AC C9  
001154  1  00 D0 04 A2  
001162  1  60                   RTS
001163  1               ;get resolved bit A:=TRUE iff bit=1 else A:=FALSE
001163  1               GETRES
001163  1  A9 03                LDA     #3              ;build
001165  1  20 53 10             JSR     SETADP          ;pointer
001168  1  A0 00                LDY     #0              ;clear index
00116A  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get byte
00116E  1  B5 AC C9 00  
001172  1  D0 04 A2 00  
001180  1  30 03                BMI     *+5             ;branch if set
001182  1  A9 00                LDA     #FALSE          ;else set
001184  1  60                   RTS                     ;false
001185  1  A9 FF                LDA     #TRUE           ;was set
001187  1  60                   RTS
001188  1               ;get the address of the printname location in AY
001188  1               GETADR
001188  1  A9 04                LDA     #4              ;build
00118A  1  20 53 10             JSR     SETADP          ;pointer
00118D  1  A0 00                LDY     #0              ;clear index
00118F  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now get low
001193  1  B5 AC C9 00  
001197  1  D0 04 A2 00  
0011A5  1  48                   PHA                     ;save
0011A6  1  C8                   INY                     ;set Y to 1
0011A7  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
0011AB  1  B5 AC C9 00  
0011AF  1  D0 04 A2 00  
0011BD  1  A8                   TAY                     ;move to Y
0011BE  1  68                   PLA                     ;get low
0011BF  1  60                   RTS
0011C0  1               ;check to see if printname located at address in PRNTNM is in SBTBL. if is
0011C0  1               ;then A:=TRUE and BASE:=address else A:=FALSE
0011C0  1               SLOOKU
0011C0  1  20 3B 10             JSR     HSOSYM          ;find base
0011C3  1               SLOOKX
0011C3  1  85 A7                STA     BASE            ;and
0011C5  1  84 A8                STY     BASE+1          ;save
0011C7  1               SLOOK0
0011C7  1  A5 A7                LDA     BASE            ;see if
0011C9  1  05 A8                ORA     BASE+1          ;base = 0
0011CB  1  D0 03 4C 77          LBEQ     SLOOFL         ;false if is
0011CF  1  12           
0011D0  1  A0 00                LDY     #0              ;clear index
0011D2  1  8B DA A2 01          LDAINDIRECTY BASE       ;get PTR
0011D6  1  B5 A7 C9 00  
0011DA  1  D0 04 A2 00  
0011E8  1  85 BD                STA     LEN             ;save as length
0011EA  1  8B 48 DA A2          CMPINDIRECTY PRNTNM     ;compare
0011EE  1  01 B5 B5 C9  
0011F2  1  00 D0 04 A2  
001202  1  D0 3B                BNE     SLOOK2          ;branch if different
001204  1               SLOOK1
001204  1  A4 BD                LDY     LEN             ;get length
001206  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
00120A  1  B5 B5 C9 00  
00120E  1  D0 04 A2 00  
00121C  1  C8                   INY                     ;bump index
00121D  1  C8                   INY                     ;by two
00121E  1  8B 48 DA A2          CMPINDIRECTY BASE       ;compare to entry
001222  1  01 B5 A7 C9  
001226  1  00 D0 04 A2  
001236  1  D0 07                BNE     SLOOK2          ;branch if different
001238  1  C6 BD                DEC     LEN             ;drop length
00123A  1  D0 C8                BNE     SLOOK1          ;loop for more
00123C  1  A9 FF                LDA     #TRUE           ;else say true
00123E  1  60                   RTS
00123F  1               SLOOK2
00123F  1  20 46 10             JSR     SETLNK          ;set link
001242  1  A0 00                LDY     #0              ;clear index
001244  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
001248  1  B5 AC C9 00  
00124C  1  D0 04 A2 00  
00125A  1  48                   PHA                     ;save it
00125B  1  C8                   INY                     ;set y to 1
00125C  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
001260  1  B5 AC C9 00  
001264  1  D0 04 A2 00  
001272  1  A8                   TAY                     ;move to Y
001273  1  68                   PLA                     ;get low
001274  1  4C C3 11             JMP     SLOOKX          ;and loop
001277  1               SLOOFL
001277  1  A9 00                LDA     #FALSE          ;was not
001279  1  60                   RTS                     ;found
00127A  1               ;enter token reference by PRNTNM and SYMHSH into next available location in the
00127A  1               ;symbol table.  set BASE to beginning of this entry and increment SBTBL. check
00127A  1               ;for symbol table full
00127A  1               ENTER
00127A  1  A0 00                LDY     #0              ;clear index
00127C  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get length
001280  1  B5 B5 C9 00  
001284  1  D0 04 A2 00  
001292  1  18                   CLC                     ;now
001293  1  69 07                ADC     #7              ;add seven
001295  1  48                   PHA                     ;save on stack
001296  1  20 7D 10             JSR     LIMITS          ;test limits
001299  1  A5 AA                LDA     SBTBL           ;update
00129B  1  A4 AB                LDY     SBTBL+1         ;base
00129D  1  85 A7                STA     BASE
00129F  1  84 A8                STY     BASE+1
0012A1  1  A0 00                LDY     #0              ;get
0012A3  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;length
0012A7  1  B5 B5 C9 00  
0012AB  1  D0 04 A2 00  
0012B9  1  8B DA 48 A2          STAINDIRECTY BASE       ;move to table
0012BD  1  01 B5 A7 C9  
0012C1  1  00 D0 04 A2  
0012CF  1  AA                   TAX                     ;make a counter
0012D0  1  F0 33                BEQ     ENTER1          ;done if zero
0012D2  1  C8                   INY                     ;start with Y=1
0012D3  1               ENTER0
0012D3  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
0012D7  1  B5 B5 C9 00  
0012DB  1  D0 04 A2 00  
0012E9  1  C8                   INY                     ;bump index
0012EA  1  C8                   INY                     ;by two
0012EB  1  8B DA 48 A2          STAINDIRECTY SBTBL      ;insert
0012EF  1  01 B5 AA C9  
0012F3  1  00 D0 04 A2  
001301  1  88                   DEY                     ;drop y by one
001302  1  CA                   DEX                     ;drop count
001303  1  D0 CE                BNE     ENTER0          ;loop if more
001305  1               ENTER1
001305  1  A9 03                LDA     #3              ;clear resolve bit
001307  1  20 53 10             JSR     SETADP          ;by getting pointer
00130A  1  A0 00                LDY     #0              ;clear index
00130C  1  98                   TYA                     ;and A
00130D  1  8B DA 48 A2          STAINDIRECTY APTADD     ;insert
001311  1  01 B5 AC C9  
001315  1  00 D0 04 A2  
001323  1  20 46 10             JSR     SETLNK          ;set link
001326  1  20 3B 10             JSR     HSOSYM          ;find address
001329  1  48                   PHA                     ;save low on stack
00132A  1  98                   TYA                     ;high to A
00132B  1  A0 01                LDY     #1              ;do high
00132D  1  8B DA 48 A2          STAINDIRECTY APTADD     ;first
001331  1  01 B5 AC C9  
001335  1  00 D0 04 A2  
001343  1  88                   DEY                     ;drop Y
001344  1  68                   PLA                     ;get low
001345  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and set
001349  1  01 B5 AC C9  
00134D  1  00 D0 04 A2  
00135B  1  A5 B7                LDA     SYMHSH          ;get hash
00135D  1  0A                   ASL     A               ;mult by two
00135E  1  AA                   TAX                     ;make index
00135F  1  A5 A7                LDA     BASE            ;get
001361  1  9D 42 34             STA     HSHTBL,X        ;and move
001364  1  A5 A8                LDA     BASE+1          ;to
001366  1  9D 43 34             STA     HSHTBL+1,X      ;table
001369  1  68                   PLA                     ;get new length
00136A  1  18                   CLC                     ;now
00136B  1  65 AA                ADC     SBTBL           ;to start
00136D  1  85 AA                STA     SBTBL           ;to get
00136F  1  90 02                BCC     *+4             ;new
001371  1  E6 AB                INC     SBTBL+1         ;table address
001373  1  60                   RTS
001374  1               ;insert subtype in SBTBL
001374  1               SETSUB
001374  1  48                   PHA                     ;save code
001375  1  A9 06                LDA     #6              ;offset pointer
001377  1  20 53 10             JSR     SETADP          ;get pointer
00137A  1  A0 00                LDY     #0              ;clear index
00137C  1  68                   PLA                     ;get code
00137D  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save
001381  1  01 B5 AC C9  
001385  1  00 D0 04 A2  
001393  1  60                   RTS
001394  1               ;return the subtype
001394  1               GETSUB
001394  1  A9 06                LDA     #6              ;build
001396  1  20 53 10             JSR     SETADP          ;pointer
001399  1  A0 00                LDY     #0              ;clear pointer
00139B  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get subtype
00139F  1  B5 AC C9 00  
0013A3  1  D0 04 A2 00  
0013B1  1  60                   RTS
0013B2  1               ;
0013B2  1               UNLINK
0013B2  1  20 0A 11             JSR     GETTYP          ;get type
0013B5  1  85 BE                STA     NUMPRM          ;save it
0013B7  1  A9 01                LDA     #1              ;set index
0013B9  1  85 BF                STA     LINKI           ;to one
0013BB  1               UNLNK0
0013BB  1  A5 BE                LDA     NUMPRM          ;compare limit
0013BD  1  C5 BF                CMP     LINKI           ;to count
0013BF  1  B0 01                BCS     *+3             ;continue if ok
0013C1  1  60                   RTS                     ;else done
0013C2  1  20 21 0F             JSR     NXTENT          ;get next
0013C5  1  20 E5 0F             JSR     GETHSH          ;and hash
0013C8  1  0A                   ASL     A               ;mult
0013C9  1  18                   CLC                     ;by two
0013CA  1  69 42                ADC     #<HSHTBL        ;and add
0013CC  1  85 C0                STA     TMPADR          ;hash table start
0013CE  1  A0 34                LDY     #>HSHTBL        ;get high
0013D0  1  90 01                BCC     *+3             ;with carry
0013D2  1  C8                   INY                     ;bump
0013D3  1  84 C1                STY     TMPADR+1        ;and save
0013D5  1               UNLNK1
0013D5  1  A0 00                LDY     #0              ;clear index
0013D7  1  A5 A7                LDA     BASE            ;compare base low
0013D9  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;to byte
0013DD  1  01 B5 C0 C9  
0013E1  1  00 D0 04 A2  
0013F1  1  D0 1D                BNE     UNLNK2          ;branch if different
0013F3  1  C8                   INY                     ;set y to 1
0013F4  1  A5 A8                LDA     BASE+1          ;do same
0013F6  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;for high
0013FA  1  01 B5 C0 C9  
0013FE  1  00 D0 04 A2  
00140E  1  F0 3E                BEQ     UNLNK3          ;branch if all same
001410  1               UNLNK2
001410  1  A0 00                LDY     #0              ;y back to zero
001412  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get low
001416  1  B5 C0 C9 00  
00141A  1  D0 04 A2 00  
001428  1  48                   PHA                     ;save it
001429  1  C8                   INY                     ;bump index
00142A  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get high
00142E  1  B5 C0 C9 00  
001432  1  D0 04 A2 00  
001440  1  85 C1                STA     TMPADR+1        ;change address
001442  1  68                   PLA                     ;get low
001443  1  85 C0                STA     TMPADR          ;save it
001445  1  E6 C0                INC     TMPADR
001447  1  D0 8C                BNE     UNLNK1
001449  1  E6 C1                INC     TMPADR+1
00144B  1  4C D5 13             JMP     UNLNK1          ;and loop
00144E  1               UNLNK3
00144E  1  20 46 10             JSR     SETLNK          ;set link
001451  1  A0 00                LDY     #0              ;clear index
001453  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
001457  1  B5 AC C9 00  
00145B  1  D0 04 A2 00  
001469  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;and move
00146D  1  01 B5 C0 C9  
001471  1  00 D0 04 A2  
00147F  1  C8                   INY                     ;now
001480  1  8B DA A2 01          LDAINDIRECTY APTADD     ;same
001484  1  B5 AC C9 00  
001488  1  D0 04 A2 00  
001496  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;for high
00149A  1  01 B5 C0 C9  
00149E  1  00 D0 04 A2  
0014AC  1  E6 BF                INC     LINKI           ;bump loop index
0014AE  1  4C BB 13             JMP     UNLNK0          ;and loop
0014B1  1               ;
0014B1  1               RELINK
0014B1  1  20 0A 11             JSR     GETTYP          ;get type
0014B4  1  85 BE                STA     NUMPRM          ;save it
0014B6  1  A9 01                LDA     #1              ;set count
0014B8  1  85 BF                STA     LINKI           ;to one
0014BA  1               RELNK0
0014BA  1  A5 BE                LDA     NUMPRM          ;get limit and
0014BC  1  C5 BF                CMP     LINKI           ;compare to count
0014BE  1  B0 01                BCS     *+3             ;branch if >=
0014C0  1  60                   RTS                     ;else done
0014C1  1  20 21 0F             JSR     NXTENT          ;do next entry
0014C4  1  A5 A7                LDA     BASE            ;now set
0014C6  1  A4 A8                LDY     BASE+1          ;temp
0014C8  1  85 C0                STA     TMPADR
0014CA  1  E6 C0                INC     TMPADR          ;bump low
0014CC  1  D0 01                BNE     *+3
0014CE  1  C8                   INY
0014CF  1  84 C1                STY     TMPADR+1        ;save high
0014D1  1  20 E5 0F             JSR     GETHSH          ;get hash
0014D4  1  0A                   ASL     A               ;mult by two
0014D5  1  AA                   TAX                     ;make index
0014D6  1  A0 00                LDY     #0              ;clear Y
0014D8  1  BD 42 34             LDA     HSHTBL,X        ;get low
0014DB  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014DF  1  01 B5 C0 C9  
0014E3  1  00 D0 04 A2  
0014F1  1  C8                   INY                     ;now high
0014F2  1  BD 43 34             LDA     HSHTBL+1,X      ;get it
0014F5  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014F9  1  01 B5 C0 C9  
0014FD  1  00 D0 04 A2  
00150B  1  20 E5 0F             JSR     GETHSH          ;gethash
00150E  1  0A                   ASL     A
00150F  1  AA                   TAX
001510  1  A5 A7                LDA     BASE            ;now get
001512  1  9D 42 34             STA     HSHTBL,X        ;and put
001515  1  A5 A8                LDA     BASE+1          ;new base
001517  1  9D 43 34             STA     HSHTBL+1,X      ;in table
00151A  1  E6 BF                INC     LINKI           ;bump loop index
00151C  1  4C BA 14             JMP     RELNK0          ;and loop
00151F  1               ;initialize SYNTHE
00151F  1               ;data definitions for initialization
00151F  1               CONZER
00151F  1  01 30                .BYTE   1,"0"
001521  1               CONONE
001521  1  01 31                .BYTE   1,"1"
001523  1               INSYN
001523  1  A9 00                LDA     #0              ;first
001525  1  85 B2                STA     CODESI          ;clear
001527  1  85 B3                STA     CODESI+1        ;variables
001529  1  85 45                STA     DATACT
00152B  1  85 46                STA     DATACT+1
00152D  1  8D 66 36             STA     ONSP
001530  1  8D 41 34             STA     IFLABL
001533  1  85 B1                STA     FDACT+1         ;set fda
001535  1  A9 01                LDA     #1              ;count to
001537  1  85 B0                STA     FDACT           ;one
001539  1  A9 FF                LDA     #$FF            ;set prt
00153B  1  85 AE                STA     PRTCT           ;count
00153D  1  85 AF                STA     PRTCT+1         ;to -1
00153F  1  20 84 09             JSR     SETFLG          ;set flags
001542  1  2C 08 34             BIT     PASS1           ;see if pass 1
001545  1  30 01                BMI     *+3             ;branch if is
001547  1  60                   RTS                     ;else done
001548  1  20 59 09             JSR     SUPINT          ;setup int file
00154B  1  A9 21                LDA     #<CONONE        ;initialize
00154D  1  A0 15                LDY     #>CONONE        ;printname
00154F  1  85 B5                STA     PRNTNM          ;pointer
001551  1  84 B6                STY     PRNTNM+1
001553  1  A9 31                LDA     #'1'            ;then
001555  1  85 B7                STA     SYMHSH          ;symbol hash
001557  1  20 7A 12             JSR     ENTER           ;put in table
00155A  1  A9 31                LDA     #'1'            ;emit
00155C  1  20 67 0F             JSR     EMITCN          ;emit
00155F  1  A9 24                LDA     #'$'            ;do a $
001561  1  20 67 0F             JSR     EMITCN
001564  1  A9 00                LDA     #0              ;constant 1
001566  1  A8                   TAY                     ;is at fda position 0
001567  1  20 9A 10             JSR     SETRSV          ;set
00156A  1  A9 04                LDA     #CONST          ;set type
00156C  1  20 2A 11             JSR     SETTYP          ;as constant
00156F  1  A9 1F                LDA     #<CONZER        ;now
001571  1  A0 15                LDY     #>CONZER        ;point
001573  1  85 B5                STA     PRNTNM          ;to
001575  1  84 B6                STY     PRNTNM+1        ;zero
001577  1  A9 30                LDA     #'0'            ;set hash
001579  1  85 B7                STA     SYMHSH          ;to '0'
00157B  1  20 7A 12             JSR     ENTER           ;enter it
00157E  1  A9 30                LDA     #'0'            ;now
001580  1  20 67 0F             JSR     EMITCN          ;output it
001583  1  A9 24                LDA     #'$'            ;do $
001585  1  20 67 0F             JSR     EMITCN
001588  1  A9 01                LDA     #1              ;set address
00158A  1  A0 00                LDY     #0
00158C  1  20 9A 10             JSR     SETRSV
00158F  1  A9 04                LDA     #CONST          ;and type = const
001591  1  4C 2A 11             JMP     SETTYP          ;then exit
001594  1               ;calculate var(a)+.varc
001594  1               CALVRC
001594  1  AA                   TAX                     ;make index
001595  1  BD E2 34             LDA     VAR,X           ;get var contents
001598  1  18                   CLC                     ;now add
001599  1  69 02                ADC     #<VARC          ;varc start
00159B  1  A0 36                LDY     #>VARC          ;with carry
00159D  1  90 01                BCC     *+3
00159F  1  C8                   INY
0015A0  1  60                   RTS
0015A1  1               ;setlookup
0015A1  1               STLKUP
0015A1  1  48                   PHA                     ;save param
0015A2  1  20 94 15             JSR     CALVRC          ;calculate varc
0015A5  1  85 B5                STA     PRNTNM          ;save as printname
0015A7  1  84 B6                STY     PRNTNM+1        ;position
0015A9  1  68                   PLA                     ;get param
0015AA  1  AA                   TAX                     ;make index
0015AB  1  BD C2 34             LDA     HASH,X          ;get entry
0015AE  1  85 B7                STA     SYMHSH          ;and set symbols
0015B0  1  60                   RTS
0015B1  1               ;lookup$only
0015B1  1               LKONLY
0015B1  1  20 A1 15             JSR     STLKUP          ;set up
0015B4  1  4C C0 11             JMP     SLOOKU          ;try to lookup
0015B7  1               ;normal$lookup
0015B7  1               NRMLKU
0015B7  1  20 B1 15             JSR     LKONLY          ;call lookup$only
0015BA  1  F0 01                BEQ     *+3             ;if false
0015BC  1  60                   RTS                     ;else done
0015BD  1  20 7A 12             JSR     ENTER           ;enter in table
0015C0  1  A9 00                LDA     #FALSE          ;then done
0015C2  1  60                   RTS
0015C3  1               ;count size of the prt and return with count in AY
0015C3  1               CNTPRT
0015C3  1  E6 AE                INC     PRTCT           ;bump
0015C5  1  D0 02                BNE     *+4
0015C7  1  E6 AF                INC     PRTCT+1
0015C9  1  A5 AE                LDA     PRTCT           ;and get
0015CB  1  A4 AF                LDY     PRTCT+1
0015CD  1  60                   RTS
0015CE  1               ;setifname
0015CE  1               SETIFN
0015CE  1  A9 3F                LDA     #<IFLBLN        ;point to printname
0015D0  1  A0 34                LDY     #>IFLBLN
0015D2  1  85 B5                STA     PRNTNM
0015D4  1  84 B6                STY     PRNTNM+1
0015D6  1  AD 41 34             LDA     IFLABL          ;set symhash
0015D9  1  29 3F                AND     #HSHMSK
0015DB  1  85 B7                STA     SYMHSH
0015DD  1  60                   RTS
0015DE  1               ;enter$compiler$label(a)
0015DE  1               ENCMLB
0015DE  1  2C 08 34             BIT     PASS1           ;test for pass 1
0015E1  1  30 01                BMI     *+3             ;branch if is
0015E3  1  60                   RTS
0015E4  1  48                   PHA                     ;save parameter
0015E5  1  20 CE 15             JSR     SETIFN          ;call setifname
0015E8  1  20 7A 12             JSR     ENTER           ;call enter
0015EB  1  68                   PLA                     ;get param
0015EC  1  18                   CLC                     ;add to codesize
0015ED  1  65 B2                ADC     CODESI
0015EF  1  A4 B3                LDY     CODESI+1
0015F1  1  90 01                BCC     *+3
0015F3  1  C8                   INY                     ;with carry
0015F4  1  4C 9A 10             JMP     SETRSV          ;call setaddr(codesize+a)
0015F7  1               ;set$compiler$label
0015F7  1               STCMLB
0015F7  1  EE 41 34             INC     IFLABL          ;bump iflable
0015FA  1  20 CE 15             JSR     SETIFN          ;call setifname
0015FD  1  4C C0 11             JMP     SLOOKU          ;call "s"lookup
001600  1               ;compiler$label
001600  1               COMLBL
001600  1  20 F7 15             JSR     STCMLB          ;call set$compiler$label
001603  1  20 88 11             JSR     GETADR
001606  1  4C 70 0F             JMP     GENTWO          ;call gen$two(getaddr)
001609  1               ;check for mp and sp both floating point
001609  1               CHKTY1
001609  1  A5 85                LDA     STYPMP          ;get stypemp
00160B  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
00160D  1  D0 09                BNE     DOC1MF          ;error if not
00160F  1  A5 83                LDA     STYPSP          ;get stypesp
001611  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
001613  1  D0 03                BNE     DOC1MF          ;error if not
001615  1  A9 FF                LDA     #TRUE
001617  1  60                   RTS
001618  1               DOC1MF
001618  1  20 43 16             JSR     MFERR           ;error
00161B  1  A9 00                LDA     #FALSE
00161D  1  60                   RTS
00161E  1               ;check mp and sp both same type
00161E  1               CHKTY2
00161E  1  A5 83                LDA     STYPSP          ;get stypesp
001620  1  C5 85                CMP     STYPMP          ;see if stypemp same
001622  1  D0 03                BNE     *+5             ;error if not
001624  1  A9 FF                LDA     #TRUE
001626  1  60                   RTS
001627  1  A9 0D                LDA     #13             ;mixed mode error
001629  1  20 AE 0A             JSR     ERROR
00162C  1  A9 00                LDA     #FALSE
00162E  1  60                   RTS
00162F  1               ;chktyp3
00162F  1               CHKTY3
00162F  1  A5 83                LDA     STYPSP          ;get stypesp
001631  1  20 D1 0C             JSR     STSTMP          ;call setstypemp(stypesp)
001634  1  A5 83                LDA     STYPSP          ;get stypesp
001636  1  C9 31                CMP     #FLOTPT         ;see if floating
001638  1  D0 03                BNE     *+5             ;error if not
00163A  1  A9 FF                LDA     #TRUE
00163C  1  60                   RTS
00163D  1  20 43 16             JSR     MFERR           ;must be floating error
001640  1  A9 00                LDA     #FALSE
001642  1  60                   RTS
001643  1               ;must be floating point error
001643  1               MFERR
001643  1  A9 0C                LDA     #12
001645  1  4C AE 0A             JMP     ERROR
001648  1               ;chktyp4
001648  1               CHKTY4
001648  1  A5 84                LDA     STYPM1          ;get stypemp1
00164A  1  C9 32                CMP     #STRING         ;see if string
00164C  1  D0 03                BNE     *+5             ;ok if not
00164E  1  20 43 16             JSR     MFERR           ;else must be floating error
001651  1  A9 5B                LDA     #RON
001653  1  4C F7 0C             JMP     GENERT          ;call generate(ron)
001656  1               ;chktyp5
001656  1               CHKTY5
001656  1  20 48 16             JSR     CHKTY4          ;call chktyp4
001659  1  E6 82                INC     TYPEMP          ;bump typemp
00165B  1  A5 82                LDA     TYPEMP
00165D  1  4C D7 0C             JMP     STTYMP          ;call settypemp(typemp:=typemp+1)
001660  1               ;subcalc
001660  1               SUBCAL
001660  1  A5 80                LDA     TYPESP          ;get type
001662  1  20 74 13             JSR     SETSUB          ;call setsubtype(typesp)
001665  1  A9 20                LDA     #ROW
001667  1  20 F7 0C             JSR     GENERT          ;call generate(row)
00166A  1  A5 80                LDA     TYPESP
00166C  1  20 F7 0C             JSR     GENERT          ;call generate(typesp)
00166F  1  A9 14                LDA     #STD
001671  1  4C F7 0C             JMP     GENERT          ;call generate(std)
001674  1               ;gen$store
001674  1               GENSTR
001674  1  A5 84                LDA     STYPM1          ;get stypemp1
001676  1  C9 31                CMP     #FLOTPT         ;see if floating
001678  1  D0 05                BNE     *+7             ;branch if not
00167A  1  A9 14                LDA     #STD
00167C  1  4C F7 0C             JMP     GENERT          ;call generate(std)
00167F  1  A9 1B                LDA     #STS
001681  1  4C F7 0C             JMP     GENERT          ;call generate(sts)
001684  1               ;setup$input
001684  1               SEINPU
001684  1  A9 FF                LDA     #TRUE
001686  1  85 47                STA     INPSTM          ;inputstmt=true
001688  1  A9 3B                LDA     #RCN
00168A  1  4C F7 0C             JMP     GENERT          ;call generate(rcn)
00168D  1               ;gen$read(a,y)
00168D  1               GENRDE
00168D  1  A6 83                LDX     STYPSP          ;get stypesp
00168F  1  E0 32                CPX     #STRING         ;see if string
001691  1  D0 08                BNE     *+10            ;branch if not
001693  1  20 F7 0C             JSR     GENERT          ;call generate(i)
001696  1  A9 1B                LDA     #STS
001698  1  4C F7 0C             JMP     GENERT          ;call generate(sts)
00169B  1  98                   TYA
00169C  1  20 F7 0C             JSR     GENERT          ;call generate(y)
00169F  1  A9 14                LDA     #STD
0016A1  1  4C F7 0C             JMP     GENERT          ;call generate(std)
0016A4  1               ;get$field
0016A4  1               GETFLD
0016A4  1  A5 80                LDA     TYPESP          ;get typesp
0016A6  1  C9 00                CMP     #SIMVAR         ;see if simple variable
0016A8  1  D0 07                BNE     *+9             ;skip if not
0016AA  1  A5 86                LDA     SYMLSP
0016AC  1  A4 87                LDY     SYMLSP+1
0016AE  1  20 79 0F             JSR     LITERL          ;call literal(symlocsp)
0016B1  1  24 47                BIT     INPSTM          ;test inputstmt
0016B3  1  10 07                BPL     *+9             ;branch if not
0016B5  1  A9 31                LDA     #RES
0016B7  1  A0 22                LDY     #RDV
0016B9  1  4C 8D 16             JMP     GENRDE          ;call gen$read(res,rdv)
0016BC  1  2C 13 34             BIT     FILEIO          ;see if file io
0016BF  1  10 07                BPL     *+9             ;branch if not
0016C1  1  A9 2A                LDA     #RDS
0016C3  1  A0 29                LDY     #RDN
0016C5  1  4C 8D 16             JMP     GENRDE          ;call gen$read(rds,rdn)
0016C8  1  A9 3C                LDA     #DRS
0016CA  1  A0 3D                LDY     #DRF
0016CC  1  4C 8D 16             JMP     GENRDE          ;call gen$read(drs,drf)
0016CF  1               ;gen$on
0016CF  1               GENON
0016CF  1  A9 5B                LDA     #RON
0016D1  1  20 F7 0C             JSR     GENERT          ;call generate(ron)
0016D4  1  EE 66 36             INC     ONSP
0016D7  1  AE 66 36             LDX     ONSP            ;get as index
0016DA  1  BD 66 36             LDA     ONSTAK,X        ;get entry
0016DD  1  A0 00                LDY     #0              ;high always clear
0016DF  1  20 79 0F             JSR     LITERL          ;call(onstack(onsp:=onsp+1))
0016E2  1  A9 5C                LDA     #CKO
0016E4  1  20 F7 0C             JSR     GENERT          ;call generate(cko)
0016E7  1  A9 39                LDA     #BFN
0016E9  1  4C F7 0C             JMP     GENERT          ;call generate(bfn)
0016EC  1               ;gen$on$2
0016EC  1               GENON2
0016EC  1  A5 80                LDA     TYPESP
0016EE  1  AE 66 36             LDX     ONSP
0016F1  1  9D 66 36             STA     ONSTAK,X
0016F4  1  60                   RTS
0016F5  1               ;gennext
0016F5  1               GENNXT
0016F5  1  C6 A9                DEC     FORCNT          ;drop forcount
0016F7  1  A5 A9                LDA     FORCNT          ;get it
0016F9  1  C9 FF                CMP     #255            ;see if wrap
0016FB  1  D0 07                BNE     *+9             ;branch if ok
0016FD  1  E6 A9                INC     FORCNT          ;set to 0
0016FF  1  A9 10                LDA     #16             ;next w/o for error
001701  1  4C AE 0A             JMP     ERROR
001704  1  A9 36                LDA     #BRS
001706  1  20 F7 0C             JSR     GENERT          ;call generate(brs)
001709  1  A0 04                LDY     #2*2            ;word addressing
00170B  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
00170F  1  B5 B9 C9 00  
001713  1  D0 04 A2 00  
001721  1  48                   PHA                     ;save
001722  1  C8                   INY
001723  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get high
001727  1  B5 B9 C9 00  
00172B  1  D0 04 A2 00  
001739  1  A8                   TAY                     ;move to Y
00173A  1  68                   PLA                     ;get low
00173B  1  20 70 0F             JSR     GENTWO          ;call gen$two(nextaddress(2))
00173E  1  A0 00                LDY     #0*2            ;still word addressing
001740  1  A5 B2                LDA     CODESI
001742  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put
001746  1  01 B5 B9 C9  
00174A  1  00 D0 04 A2  
001758  1  C8                   INY
001759  1  A5 B3                LDA     CODESI+1        ;do high
00175B  1  09 80                ORA     #$80            ;set msb
00175D  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;insert
001761  1  01 B5 B9 C9  
001765  1  00 D0 04 A2  
001773  1               GENNX0
001773  1  A0 01                LDY     #1              ;set index to 1
001775  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get nextbytev(1)
001779  1  B5 B9 C9 00  
00177D  1  D0 04 A2 00  
00178B  1  30 01                BMI     *+3             ;continue if > 127
00178D  1  60                   RTS
00178E  1  18                   CLC                     ;now add 8 to nextstmtptr
00178F  1  A5 B9                LDA     NXSTPT
001791  1  69 08                ADC     #8
001793  1  85 B9                STA     NXSTPT
001795  1  90 DC                BCC     GENNX0
001797  1  E6 BA                INC     NXSTPT+1
001799  1  4C 73 17             JMP     GENNX0
00179C  1               ;gen$next$with$ident
00179C  1               GENWID
00179C  1  A5 7D                LDA     MPP1            ;get mpp1
00179E  1  20 B1 15             JSR     LKONLY
0017A1  1  F0 3A                BEQ     GENWIE          ;branch if false
0017A3  1  A0 06                LDY     #3*2            ;word addressing
0017A5  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
0017A9  1  B5 B9 C9 00  
0017AD  1  D0 04 A2 00  
0017BB  1  C5 A7                CMP     BASE            ;compare to low base
0017BD  1  D0 1E                BNE     GENWIE          ;error if different
0017BF  1  C8                   INY
0017C0  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;same for high
0017C4  1  B5 B9 C9 00  
0017C8  1  D0 04 A2 00  
0017D6  1  C5 A8                CMP     BASE+1
0017D8  1  D0 03                BNE     GENWIE
0017DA  1  4C F5 16             JMP     GENNXT          ;else ok
0017DD  1               GENWIE
0017DD  1  A9 0E                LDA     #14             ;next does not match for
0017DF  1  4C AE 0A             JMP     ERROR
0017E2  1               ;check$ul$error
0017E2  1               CHKULE
0017E2  1  24 B4                BIT     ULERFL          ;test flag
0017E4  1  10 05                BPL     *+7             ;branch if clear
0017E6  1  A9 14                LDA     #20             ;else undefined label
0017E8  1  20 AE 0A             JSR     ERROR
0017EB  1  A9 00                LDA     #FALSE          ;now clear flag
0017ED  1  85 B4                STA     ULERFL
0017EF  1  60                   RTS
0017F0  1               ;findlabel
0017F0  1               FNDLBL
0017F0  1  A5 7B                LDA     SP              ;get sp
0017F2  1  20 B7 15             JSR     NRMLKU          ;normal$lookup(sp)
0017F5  1  D0 01                BNE     *+3             ;if true
0017F7  1  60                   RTS
0017F8  1  2C 09 34             BIT     PASS2           ;if pass2
0017FB  1  30 01                BMI     *+3             ;then
0017FD  1  60                   RTS
0017FE  1  20 63 11             JSR     GETRES          ;if not getres
001801  1  F0 01                BEQ     *+3             ;then
001803  1  60                   RTS
001804  1  A9 FF                LDA     #TRUE
001806  1  85 B4                STA     ULERFL          ;ulerrorflag=true
001808  1  60                   RTS
001809  1               ;resolve$label
001809  1               RESLBL
001809  1  20 F0 17             JSR     FNDLBL          ;findlabel
00180C  1  A9 1E                LDA     #PRO            ;preset for true
00180E  1  24 48                BIT     GSBSTM          ;test gosubstmt
001810  1  30 02                BMI     *+4             ;if true
001812  1  A9 36                LDA     #BRS            ;else
001814  1  20 F7 0C             JSR     GENERT          ;generate( )
001817  1  20 88 11             JSR     GETADR
00181A  1  4C 70 0F             JMP     GENTWO          ;gen$two(getaddr)
00181D  1               ;process$simple$variable
00181D  1               PSIMPV
00181D  1  20 B7 15             JSR     NRMLKU          ;normal$lookup
001820  1  F0 0F                BEQ     PSIMP0          ;if false then
001822  1  20 0A 11             JSR     GETTYP          ;if getype
001825  1  C9 00                CMP     #SIMVAR         ;= simvar
001827  1  F0 13                BEQ     PSIMP1          ;then
001829  1  A9 0B                LDA     #11             ;array name used as simple variable
00182B  1  20 AE 0A             JSR     ERROR
00182E  1  4C 3C 18             JMP     PSIMP1          ;continue
001831  1               PSIMP0
001831  1  20 C3 15             JSR     CNTPRT
001834  1  20 9A 10             JSR     SETRSV          ;setaddr(countprt)
001837  1  A9 00                LDA     #SIMVAR
001839  1  20 2A 11             JSR     SETTYP          ;setype(simvar)
00183C  1               PSIMP1
00183C  1  20 88 11             JSR     GETADR
00183F  1  85 86                STA     SYMLSP
001841  1  84 87                STY     SYMLSP+1        ;symlocsp=getaddr
001843  1  20 B1 0C             JSR     STSLSP          ;setsymlocsp( )
001846  1  A9 00                LDA     #SIMVAR
001848  1  20 C5 0C             JSR     STTYSP          ;settypesp(simvar)
00184B  1  2C 12 34             BIT     FORSTM          ;if forstmt
00184E  1  30 01                BMI     *+3             ;then
001850  1  60                   RTS
001851  1  A9 00                LDA     #FALSE
001853  1  8D 12 34             STA     FORSTM          ;forstmt=false
001856  1  A0 06                LDY     #3*2            ;word addressing
001858  1  A5 A7                LDA     BASE
00185A  1  8B DA 48 A2          STAINDIRECTY SBTTOP
00185E  1  01 B5 A5 C9  
001862  1  00 D0 04 A2  
001870  1  C8                   INY
001871  1  A5 A8                LDA     BASE+1
001873  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(3)=base
001877  1  01 B5 A5 C9  
00187B  1  00 D0 04 A2  
001889  1  60                   RTS
00188A  1               ;gen$ils
00188A  1               GENILS
00188A  1  85 C2                STA     WHERE
00188C  1  84 C3                STY     WHERE+1         ;save parameter
00188E  1  A9 32                LDA     #STRING
001890  1  20 CB 0C             JSR     STSTSP          ;setstypesp(string)
001893  1  A9 1C                LDA     #ILS
001895  1  20 F7 0C             JSR     GENERT          ;generate(ils)
001898  1               GENIL0
001898  1  A9 01                LDA     #1
00189A  1  85 C4                STA     STRPTR          ;strptr=1
00189C  1               GENIL1
00189C  1  A0 00                LDY     #0
00189E  1  8B DA A2 01          LDAINDIRECTY WHERE      ;if stringtospool(0)
0018A2  1  B5 C2 C9 00  
0018A6  1  D0 04 A2 00  
0018B4  1  C5 C4                CMP     STRPTR          ;< strptr
0018B6  1  90 20                BCC     GENIL2          ;then
0018B8  1  A4 C4                LDY     STRPTR
0018BA  1  8B DA A2 01          LDAINDIRECTY WHERE      ;stringtospool(strptr)
0018BE  1  B5 C2 C9 00  
0018C2  1  D0 04 A2 00  
0018D0  1  20 F7 0C             JSR     GENERT          ;generate
0018D3  1  E6 C4                INC     STRPTR          ;strptr=strptr+1
0018D5  1  4C 9C 18             JMP     GENIL1
0018D8  1               GENIL2
0018D8  1  24 6E                BIT     CONT            ;if not cont
0018DA  1  10 06                BPL     *+8             ;then
0018DC  1  20 B1 0D             JSR     SCANNR          ;scanner
0018DF  1  4C 98 18             JMP     GENIL0
0018E2  1  A9 00                LDA     #0
0018E4  1  4C F7 0C             JMP     GENERT          ;generate(0)
0018E7  1               ;gencon
0018E7  1               GENCON
0018E7  1  A9 2E                LDA     #CON
0018E9  1  20 F7 0C             JSR     GENERT          ;generate(con)
0018EC  1  A9 04                LDA     #CONST
0018EE  1  20 C5 0C             JSR     STTYSP          ;settypesp(const)
0018F1  1  A9 31                LDA     #FLOTPT
0018F3  1  20 CB 0C             JSR     STSTSP          ;setstypesp(floatpt)
0018F6  1  A5 7B                LDA     SP
0018F8  1  20 B1 15             JSR     LKONLY          ;lookup$only(sp)
0018FB  1  F0 0D                BEQ     GENCO0          ;if false then
0018FD  1  20 0A 11             JSR     GETTYP          ;if getype
001900  1  C9 04                CMP     #CONST          ;<> const
001902  1  D0 06                BNE     GENCO0          ;then
001904  1  20 88 11             JSR     GETADR
001907  1  4C 70 0F             JMP     GENTWO          ;gen$two(getaddr)
00190A  1               GENCO0
00190A  1  A9 01                LDA     #1
00190C  1  85 C5                STA     IGEN            ;igen=1
00190E  1               GENCO1
00190E  1  A5 4E                LDA     ACCLEN
001910  1  C5 C5                CMP     IGEN            ;if igen>acclen
001912  1  90 0C                BCC     GENCO2          ;then
001914  1  A6 C5                LDX     IGEN
001916  1  B5 4E                LDA     ACCUM,X
001918  1  20 67 0F             JSR     EMITCN          ;emitcon(accum(i))
00191B  1  E6 C5                INC     IGEN            ;i=i+1
00191D  1  4C 0E 19             JMP     GENCO1
001920  1               GENCO2
001920  1  A9 24                LDA     #'$'
001922  1  20 67 0F             JSR     EMITCN          ;emitcon('$')
001925  1  E6 B0                INC     FDACT
001927  1  D0 02                BNE     *+4
001929  1  E6 B1                INC     FDACT+1         ;fdact=fdact+1
00192B  1  A5 B0                LDA     FDACT
00192D  1  A4 B1                LDY     FDACT+1
00192F  1  4C 70 0F             JMP     GENTWO          ;gen$two(fdact)
001932  1               ;put$field
001932  1               PUTFLD
001932  1  2C 13 34             BIT     FILEIO          ;if not fileio
001935  1  10 10                BPL     NTFLIO          ;then
001937  1  A5 83                LDA     STYPSP          ;if stypesp
001939  1  C9 31                CMP     #FLOTPT         ;<> floatpt
00193B  1  D0 05                BNE     *+7             ;then
00193D  1  A9 2B                LDA     #WRN
00193F  1  4C F7 0C             JMP     GENERT          ;generate(wrn)
001942  1  A9 2C                LDA     #WRS
001944  1  4C F7 0C             JMP     GENERT          ;generate(wrs)
001947  1               NTFLIO
001947  1  A5 83                LDA     STYPSP          ;if stypesp
001949  1  C9 31                CMP     #FLOTPT         ;= floatpt
00194B  1  F0 05                BEQ     *+7             ;then
00194D  1  A9 24                LDA     #WST
00194F  1  4C F7 0C             JMP     GENERT          ;generate(wst)
001952  1  A5 80                LDA     TYPESP          ;if typesp
001954  1  C9 4A                CMP     #74             ;not a tab
001956  1  D0 01                BNE     *+3             ;then
001958  1  60                   RTS
001959  1  A9 23                LDA     #WRV
00195B  1  4C F7 0C             JMP     GENERT          ;generate(wrv)
00195E  1               ;gen$parm
00195E  1               GENPRM
00195E  1  A5 82                LDA     TYPEMP
001960  1  C9 0A                CMP     #UNFUNC         ;if typemp = unfunc
001962  1  F0 01                BEQ     *+3             ;then
001964  1  60                   RTS
001965  1  A5 8A                LDA     SYMLMP
001967  1  A4 8B                LDY     SYMLMP+1
001969  1  85 A7                STA     BASE
00196B  1  84 A8                STY     BASE+1          ;base=symlocmp
00196D  1  20 21 0F             JSR     NXTENT          ;nextentry
001970  1  A5 A7                LDA     BASE
001972  1  A4 A8                LDY     BASE+1
001974  1  20 BF 0C             JSR     STSLMP          ;setsymlocmp(base)
001977  1  C6 8E                DEC     HASHMP
001979  1  A5 8E                LDA     HASHMP
00197B  1  20 DD 0C             JSR     STHAMP          ;sethashmp(hashmp:=hashmp-1)
00197E  1  20 88 11             JSR     GETADR
001981  1  4C 79 0F             JMP     LITERL          ;literal(getaddr)
001984  1               ;checkparm
001984  1               CHKPRM
001984  1  A5 82                LDA     TYPEMP
001986  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
001988  1  D0 17                BNE     NTUNFN          ;then
00198A  1  A5 8A                LDA     SYMLMP
00198C  1  A4 8B                LDY     SYMLMP+1
00198E  1  85 A7                STA     BASE
001990  1  84 A8                STY     BASE+1          ;base=symlocmp
001992  1  20 94 13             JSR     GETSUB          ;getsubtype
001995  1  C5 84                CMP     STYPM1          ;if = stypemp1
001997  1  F0 05                BEQ     *+7             ;then
001999  1  A9 05                LDA     #5              ;else invalid parameter type in function ref
00199B  1  20 AE 0A             JSR     ERROR
00199E  1  4C 74 16             JMP     GENSTR          ;gen$store
0019A1  1               NTUNFN
0019A1  1  A9 01                LDA     #1
0019A3  1  A4 84                LDY     STYPM1          ;if stypemp1
0019A5  1  C0 31                CPY     #FLOTPT         ;<> floatpt
0019A7  1  D0 02                BNE     *+4             ;then
0019A9  1  A9 00                LDA     #FALSE
0019AB  1  45 8E                EOR     HASHMP          ;xor hashmp
0019AD  1  29 01                AND     #1              ;test lsb only
0019AF  1  F0 05                BEQ     *+7             ;if true
0019B1  1  A9 05                LDA     #5              ;invalid type in function parameter list
0019B3  1  20 AE 0A             JSR     ERROR
0019B6  1  A5 8E                LDA     HASHMP
0019B8  1  4A                   LSR     A               ;shr(hashmp,1)
0019B9  1  20 DD 0C             JSR     STHAMP          ;sethashmp
0019BC  1  C6 85                DEC     STYPMP
0019BE  1  A5 85                LDA     STYPMP
0019C0  1  4C D1 0C             JMP     STSTMP          ;setstypemp(stypemp=stypemp-1)
0019C3  1               ;funcgen
0019C3  1               FNCGEN
0019C3  1  A5 82                LDA     TYPEMP
0019C5  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
0019C7  1  D0 1C                BNE     NOFNGN          ;then
0019C9  1  A5 8E                LDA     HASHMP          ;if hashmp=0
0019CB  1  F0 05                BEQ     *+7             ;then
0019CD  1  A9 04                LDA     #4              ;incorrect number parameters
0019CF  1  20 AE 0A             JSR     ERROR
0019D2  1  A9 1E                LDA     #PRO
0019D4  1  20 F7 0C             JSR     GENERT          ;generate(pro)
0019D7  1  A5 8F                LDA     SRLOSP
0019D9  1  A4 90                LDY     SRLOSP+1
0019DB  1  85 A7                STA     BASE
0019DD  1  84 A8                STY     BASE+1          ;base=srlocsp
0019DF  1  20 88 11             JSR     GETADR
0019E2  1  4C 70 0F             JMP     GENTWO          ;gen$two(getaddr)
0019E5  1               NOFNGN
0019E5  1  A5 85                LDA     STYPMP
0019E7  1  29 03                AND     #3              ;if stypemp and 3 = 0
0019E9  1  F0 05                BEQ     *+7             ;then
0019EB  1  A9 04                LDA     #4              ;incorrect number parameters
0019ED  1  20 AE 0A             JSR     ERROR
0019F0  1  A5 82                LDA     TYPEMP
0019F2  1  20 F7 0C             JSR     GENERT          ;generate(typemp)
0019F5  1  A5 85                LDA     STYPMP
0019F7  1  29 40                AND     #%01000000      ;if not rol(stypemp,2)
0019F9  1  F0 05                BEQ     *+7             ;then
0019FB  1  A9 32                LDA     #STRING
0019FD  1  4C D1 0C             JMP     STSTMP          ;setstypemp(string)
001A00  1  A9 31                LDA     #FLOTPT
001A02  1  4C D1 0C             JMP     STSTMP          ;setstypemp(floatpt)
001A05  1               ;enter$parm
001A05  1               ENTRPR
001A05  1  2C 08 34             BIT     PASS1           ;if pass 1
001A08  1  30 01                BMI     *+3             ;then
001A0A  1  60                   RTS
001A0B  1  A5 7D                LDA     MPP1
001A0D  1  20 A1 15             JSR     STLKUP          ;setlookup(mpp1)
001A10  1  20 7A 12             JSR     ENTER
001A13  1  20 C3 15             JSR     CNTPRT
001A16  1  20 9A 10             JSR     SETRSV          ;setaddr(countprt)
001A19  1  A5 84                LDA     STYPM1
001A1B  1  20 74 13             JSR     SETSUB          ;setsubtype(stypemp1)
001A1E  1  A9 00                LDA     #SIMVAR
001A20  1  20 2A 11             JSR     SETTYP          ;setype(simvar)
001A23  1  A6 82                LDX     TYPEMP
001A25  1  E8                   INX
001A26  1  8A                   TXA
001A27  1  4C D7 0C             JMP     STTYMP          ;settypemp(typemp+1)
001A2A  1               ;synthesis
001A2A  1               ;main code generation routine
001A2A  1               SYNTHE
001A2A  1  85 B8                STA     PRODCT          ;save production
001A2C  1  AD 09 34             LDA     PASS2           ;if not pass 2
001A2F  1  2D 0A 34             AND     LSTPRD          ;and listprod
001A32  1  F0 11                BEQ     NPPROD          ;then
001A34  1  A9 97                LDA     #<PRDMSG
001A36  1  A0 33                LDY     #>PRDMSG
001A38  1  20 FC 08             JSR     PRNMSG          ;print message
001A3B  1  A5 B8                LDA     PRODCT
001A3D  1  A0 00                LDY     #0
001A3F  1  20 70 08             JSR     PRNDEC          ;print number
001A42  1  20 34 08             JSR     CRLF
001A45  1               NPPROD
001A45  1  20 42 0C             JSR     SCOPY           ;set up simple variables
001A48  1  A5 B8                LDA     PRODCT          ;get number
001A4A  1  0A                   ASL     A               ;make word index
001A4B  1  AA                   TAX                     ;make index
001A4C  1  B0 0F                BCS     GT127           ;branch if > 127
001A4E  1  BD 6C 1A             LDA     PRODL,X
001A51  1  8D 5B 1A             STA     JPROD+1
001A54  1  BD 6D 1A             LDA     PRODL+1,X
001A57  1  8D 5C 1A             STA     JPROD+2         ;set address
001A5A  1               JPROD
001A5A  1  4C FF FF             JMP     $FFFF           ;do it
001A5D  1               GT127
001A5D  1  BD 6C 1B             LDA     PRODH,X
001A60  1  8D 5B 1A             STA     JPROD+1
001A63  1  BD 6D 1B             LDA     PRODH+1,X
001A66  1  8D 5C 1A             STA     JPROD+2
001A69  1  4C 5A 1A             JMP     JPROD           ;same for high
001A6C  1               ;production jump table for 0 - 127
001A6C  1               PRODL
001A6C  1  9E 1B 9E 1B          .WORD   PRN,PRN,PR2,PR3,CHKULE,CHKULE,PRN,PRN
001A70  1  9F 1B D4 1B  
001A74  1  E2 17 E2 17  
001A7C  1  9E 1B 9E 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A80  1  9E 1B 9E 1B  
001A84  1  9E 1B 9E 1B  
001A8C  1  9E 1B 9E 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A90  1  9E 1B 9E 1B  
001A94  1  9E 1B 9E 1B  
001A9C  1  9E 1B 9E 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PR30,PR31
001AA0  1  9E 1B 9E 1B  
001AA4  1  9E 1B 9E 1B  
001AAC  1  9E 1B F2 1B          .WORD   PRN,PR33,PR34,PR35,PRN,PR37,PRN,PR39
001AB0  1  FD 1B 02 1C  
001AB4  1  9E 1B 07 1C  
001ABC  1  9E 1B 1D 1C          .WORD   PRN,PR41,PRN,PR43,PR44,CHKTY3,PR46,PRN
001AC0  1  9E 1B 3B 1C  
001AC4  1  4E 1C 2F 16  
001ACC  1  64 1C 6F 1C          .WORD   PR48,PR49,PRN,PR51,PR52,PRN,PRN,PR55
001AD0  1  9E 1B 7A 1C  
001AD4  1  85 1C 9E 1B  
001ADC  1  9C 1C A1 1C          .WORD   PR56,PR57,PR58,CHKTY5,PR60,FNCGEN,GENPRM,PR63
001AE0  1  D2 1C 56 16  
001AE4  1  F1 1C C3 19  
001AEC  1  05 1D 2A 1D          .WORD   PR64,PR65,GENCON,PR67,PR68,PR69,PR69,PR71
001AF0  1  E7 18 38 1D  
001AF4  1  3F 1D 44 1D  
001AFC  1  49 1D 4E 1D          .WORD   PR71,PR73,PR74,PR75,PR75,PR77,PR78,PR79
001B00  1  53 1D 58 1D  
001B04  1  58 1D 5D 1D  
001B0C  1  1C 1F 21 1F          .WORD   PR80,PR81,PR82,PR82,PR84,PRN,RESLBL,PR87
001B10  1  6A 1F 6A 1F  
001B14  1  6F 1F 9E 1B  
001B1C  1  8F 1F A2 1F          .WORD   PR88,PR89,PR90,ENTRPR,PR92,PR92,ENTRPR,PRN
001B20  1  C7 1F 05 1A  
001B24  1  F9 1F F9 1F  
001B2C  1  9E 1B 9E 1B          .WORD   PRN,PRN,PR98,CHKTY4,PR100,PRN,SUBCAL,SUBCAL
001B30  1  FE 1F 48 16  
001B34  1  1A 20 9E 1B  
001B3C  1  20 20 2C 20          .WORD   PR104,PR105,CHKTY5,PRN,PR108,PR108,PR110,PRN
001B40  1  56 16 9E 1B  
001B44  1  5F 20 5F 20  
001B4C  1  82 20 8C 20          .WORD   PR112,PR113,SEINPU,GETFLD,GETFLD,PR117,PRN,PR119
001B50  1  84 16 A4 16  
001B54  1  A4 16 7C 20  
001B5C  1  32 19 32 19          .WORD   PUTFLD,PUTFLD,PRN,PUTFLD,PUTFLD,PRN,PR126,PR127
001B60  1  9E 1B 32 19  
001B64  1  32 19 9E 1B  
001B6C  1               ;production jump table for 128 - 255
001B6C  1               PRODH
001B6C  1  B1 20 9E 1B          .WORD   PR128,PRN,PR130,RESLBL,GENON2,PR133,GENON,PR135
001B70  1  CA 20 09 18  
001B74  1  EC 16 D5 20  
001B7C  1  F3 20 FB 20          .WORD   PR136,PR137,PR138,PRN,PRN,PRN,PRN,GENWID
001B80  1  05 21 9E 1B  
001B84  1  9E 1B 9E 1B  
001B8C  1  F5 16 9E 1B          .WORD   GENNXT,PRN,GENWID,PR147,PR148,PR149,PR150,PR151
001B90  1  9C 17 11 21  
001B94  1  32 21 37 21  
001B9C  1  A9 21                .WORD   PR152
001B9E  1               ;productions not already defined by single no-parameter subroutines
001B9E  1               PRN
001B9E  1  60                   RTS                     ;do nothing - used a lot !!!!
001B9F  1               ;2	<line number>::=<number>
001B9F  1               PR2
001B9F  1  A5 7B                LDA     SP
001BA1  1  20 B1 15             JSR     LKONLY          ;lookup$only(sp)
001BA4  1  F0 27                BEQ     PR2D            ;if false
001BA6  1  20 63 11             JSR     GETRES          ;see if resolved
001BA9  1  F0 13                BEQ     PR2C            ;if not
001BAB  1  20 88 11             JSR     GETADR          ;getaddr
001BAE  1  C5 B2                CMP     CODESI          ;try low
001BB0  1  D0 04                BNE     PR2A            ;error if <>
001BB2  1  C4 B3                CPY     CODESI+1
001BB4  1  F0 05                BEQ     *+7             ;ok if same
001BB6  1               PR2A
001BB6  1  A9 00                LDA     #0              ;duplicate labels
001BB8  1  20 AE 0A             JSR     ERROR
001BBB  1  4C 8B 0F             JMP     LINENU
001BBE  1               PR2C
001BBE  1  A5 B2                LDA     CODESI
001BC0  1  A4 B3                LDY     CODESI+1
001BC2  1  20 9A 10             JSR     SETRSV          ;setaddr(codesize)
001BC5  1  A9 08                LDA     #LABLE
001BC7  1  20 2A 11             JSR     SETTYP          ;setype(lable)
001BCA  1  4C 8B 0F             JMP     LINENU
001BCD  1               PR2D
001BCD  1  A9 2A                LDA     #'*'
001BCF  1  85 74                STA     SEPRTR          ;separator=astrik
001BD1  1  4C 8B 0F             JMP     LINENU
001BD4  1               ;3	|
001BD4  1               PR3
001BD4  1  A9 3A                LDA     #':'            ;set separator
001BD6  1  85 74                STA     SEPRTR
001BD8  1  4C 8B 0F             JMP     LINENU          ;then do line number
001BDB  1               ;30	<assignmemt>::=<assign head><expression>
001BDB  1               PR30
001BDB  1  20 1E 16             JSR     CHKTY2          ;if not chktyp2
001BDE  1  F0 03                BEQ     *+5             ;then
001BE0  1  4C 74 16             JMP     GENSTR          ;else gen$store
001BE3  1  60                   RTS
001BE4  1               ;31	<assign head>::=<variable>=
001BE4  1               PR31
001BE4  1  A5 82                LDA     TYPEMP
001BE6  1  C9 00                CMP     #SIMVAR         ;if typemp=simvar
001BE8  1  F0 01                BEQ     *+3             ;then
001BEA  1  60                   RTS
001BEB  1  A5 8A                LDA     SYMLMP
001BED  1  A4 8B                LDY     SYMLMP+1
001BEF  1  4C 79 0F             JMP     LITERL          ;literal(symlocmp)
001BF2  1               ;33	|<expression><or><logical factor>
001BF2  1               PR33
001BF2  1  20 09 16             JSR     CHKTY1          ;if chktyp1
001BF5  1  D0 01                BNE     *+3             ;then
001BF7  1  60                   RTS
001BF8  1  A5 81                LDA     TYPEM1
001BFA  1  4C F7 0C             JMP     GENERT          ;generate(typemp1)
001BFD  1               ;34	<or>::=or
001BFD  1               PR34
001BFD  1  A9 0D                LDA     #BOR
001BFF  1  4C C5 0C             JMP     STTYSP          ;settypesp(bor)
001C02  1               ;35	|xor
001C02  1               PR35
001C02  1  A9 5D                LDA     #EXR
001C04  1  4C C5 0C             JMP     STTYSP          ;sttysp
001C07  1               ;37	<logical secondary>
001C07  1               PR37
001C07  1  20 09 16             JSR     CHKTY1          ;if chktyp1
001C0A  1  D0 01                BNE     *+3             ;then
001C0C  1  60                   RTS
001C0D  1  A9 0C                LDA     #ANDO
001C0F  1  4C F7 0C             JMP     GENERT          ;generate(ando)
001C12  1               ;39	|not <logical primary>
001C12  1               PR39
001C12  1  20 2F 16             JSR     CHKTY3          ;if chktyp3
001C15  1  D0 01                BNE     *+3             ;then
001C17  1  60                   RTS
001C18  1  A9 0B                LDA     #NOT
001C1A  1  4C F7 0C             JMP     GENERT          ;generate(not)
001C1D  1               ;41	<arithmetic expression>
001C1D  1               PR41
001C1D  1  20 1E 16             JSR     CHKTY2          ;if chktyp2
001C20  1  D0 01                BNE     *+3             ;then
001C22  1  60                   RTS
001C23  1  A5 83                LDA     STYPSP
001C25  1  C9 31                CMP     #FLOTPT         ;if stypesp<>floatpt
001C27  1  D0 05                BNE     PR41A           ;then
001C29  1  A5 81                LDA     TYPEM1
001C2B  1  4C F7 0C             JMP     GENERT          ;generate(typemp1)
001C2E  1               PR41A
001C2E  1  18                   CLC
001C2F  1  A5 81                LDA     TYPEM1
001C31  1  69 10                ADC     #16
001C33  1  20 F7 0C             JSR     GENERT          ;generate(typemp1+16)
001C36  1  A9 31                LDA     #FLOTPT
001C38  1  4C D1 0C             JMP     STSTMP          ;setstypemp(floatpt)
001C3B  1               ;43	|<arithmetic expression>+<term>
001C3B  1               PR43
001C3B  1  20 1E 16             JSR     CHKTY2          ;if chktyp2
001C3E  1  D0 01                BNE     *+3             ;then
001C40  1  60                   RTS
001C41  1  A9 00                LDA     #FAD
001C43  1  A4 83                LDY     STYPSP
001C45  1  C0 31                CPY     #FLOTPT         ;if stypesp=floatpt
001C47  1  F0 02                BEQ     *+4             ;then generate(fad)
001C49  1  A9 1D                LDA     #CAT
001C4B  1  4C F7 0C             JMP     GENERT          ;else generate(cat)
001C4E  1               ;44	|<arithmetic expression>-<term>
001C4E  1               PR44
001C4E  1  20 09 16             JSR     CHKTY1          ;if chktyp1
001C51  1  D0 01                BNE     *+3             ;then
001C53  1  60                   RTS
001C54  1  A9 01                LDA     #FMI
001C56  1  4C F7 0C             JMP     GENERT          ;generate(fmi)
001C59  1               ;46	|-<term>
001C59  1               PR46
001C59  1  20 2F 16             JSR     CHKTY3          ;if chktyp3
001C5C  1  D0 01                BNE     *+3             ;then
001C5E  1  60                   RTS
001C5F  1  A9 30                LDA     #NEG
001C61  1  4C F7 0C             JMP     GENERT          ;generate(neg)
001C64  1               ;48	|<term>*<primary>
001C64  1               PR48
001C64  1  20 09 16             JSR     CHKTY1          ;if chktyp1
001C67  1  D0 01                BNE     *+3             ;then
001C69  1  60                   RTS
001C6A  1  A9 02                LDA     #FMU
001C6C  1  4C F7 0C             JMP     GENERT          ;generate(fmu)
001C6F  1               ;49	|<term>/<primary>
001C6F  1               PR49
001C6F  1  20 09 16             JSR     CHKTY1          ;if chktyp1
001C72  1  D0 01                BNE     *+3             ;then
001C74  1  60                   RTS
001C75  1  A9 03                LDA     #FDI
001C77  1  4C F7 0C             JMP     GENERT          ;generate(fdi)
001C7A  1               ;51	|<primary>**<element>
001C7A  1               PR51
001C7A  1  20 09 16             JSR     CHKTY1          ;the chktyp1
001C7D  1  D0 01                BNE     *+3             ;then
001C7F  1  60                   RTS
001C80  1  A9 04                LDA     #EXP
001C82  1  4C F7 0C             JMP     GENERT          ;generate(exp)
001C85  1               ;52	<element>::=<variable>
001C85  1               PR52
001C85  1  A5 80                LDA     TYPESP          ;if typesp
001C87  1  C9 00                CMP     #SIMVAR         ;= simvar
001C89  1  F0 05                BEQ     *+7             ;then
001C8B  1  A9 0E                LDA     #LOD
001C8D  1  4C F7 0C             JMP     GENERT          ;else generate(lod)
001C90  1  A5 86                LDA     SYMLSP
001C92  1  A4 87                LDY     SYMLSP+1
001C94  1  4C 82 0F             JMP     LITLOD          ;litload(symlocsp)
001C97  1               ;55	|(<expression>)
001C97  1               PR55
001C97  1  A5 84                LDA     STYPM1
001C99  1  4C D1 0C             JMP     STSTMP          ;setstypemp(stypemp1)
001C9C  1               ;56	<variable>::=<identifier>
001C9C  1               PR56
001C9C  1  A5 7B                LDA     SP
001C9E  1  4C 1D 18             JMP     PSIMPV          ;process$simple$variable(sp)
001CA1  1               ;57	|<subscript head><expression>
001CA1  1               PR57
001CA1  1  2C 12 34             BIT     FORSTM          ;if not forstmt
001CA4  1  10 05                BPL     *+7             ;then
001CA6  1  A9 03                LDA     #3              ;for index not simple variable
001CA8  1  20 AE 0A             JSR     ERROR
001CAB  1  20 56 16             JSR     CHKTY5          ;chktyp5
001CAE  1  A5 8A                LDA     SYMLMP
001CB0  1  A4 8B                LDY     SYMLMP+1
001CB2  1  85 A7                STA     BASE
001CB4  1  84 A8                STY     BASE+1          ;base=symlocsp
001CB6  1  20 94 13             JSR     GETSUB          ;if getsubtype
001CB9  1  C5 82                CMP     TYPEMP          ;= typemp
001CBB  1  F0 05                BEQ     *+7             ;then
001CBD  1  A9 11                LDA     #17             ;incorrect number subscripts
001CBF  1  20 AE 0A             JSR     ERROR
001CC2  1  20 88 11             JSR     GETADR
001CC5  1  20 82 0F             JSR     LITLOD          ;litload(getaddr)
001CC8  1  A9 21                LDA     #SUB
001CCA  1  20 F7 0C             JSR     GENERT          ;generate(subo)
001CCD  1  A9 02                LDA     #SUBVAR
001CCF  1  4C D7 0C             JMP     STTYMP          ;settypemp(subvar)
001CD2  1               ;58	<subscript head>::=<identifier>(
001CD2  1               PR58
001CD2  1  A5 7C                LDA     MP
001CD4  1  20 B1 15             JSR     LKONLY          ;lookup$only(mp)
001CD7  1  F0 07                BEQ     PR58A           ;if not then error
001CD9  1  20 0A 11             JSR     GETTYP          ;if getype
001CDC  1  C9 02                CMP     #SUBVAR         ;= subvar
001CDE  1  F0 05                BEQ     *+7             ;then ok
001CE0  1               PR58A
001CE0  1  A9 0A                LDA     #10             ;subscripted variable not dimensioned
001CE2  1  20 AE 0A             JSR     ERROR
001CE5  1  A9 00                LDA     #0
001CE7  1  20 D7 0C             JSR     STTYMP          ;settypemp(0)
001CEA  1  A5 A7                LDA     BASE
001CEC  1  A4 A8                LDY     BASE+1
001CEE  1  4C BF 0C             JMP     STSLMP          ;setsymlocmp(base)
001CF1  1               ;60	<function call>::=<function heading><expression>
001CF1  1               PR60
001CF1  1  20 84 19             JSR     CHKPRM          ;checkparm
001CF4  1  A5 91                LDA     SRLOMP
001CF6  1  A4 92                LDY     SRLOMP+1
001CF8  1  85 8F                STA     SRLOSP
001CFA  1  84 90                STY     SRLOSP+1        ;srlocsp=srlocmp
001CFC  1  4C C3 19             JMP     FNCGEN          ;funcgen
001CFF  1               ;63	|<function heading><expression>
001CFF  1               PR63
001CFF  1  20 84 19             JSR     CHKPRM          ;check$parm
001D02  1  4C 5E 19             JMP     GENPRM          ;gen$parm
001D05  1               ;64	<function name>::=<user defined name>
001D05  1               PR64
001D05  1  A5 7B                LDA     SP
001D07  1  20 B1 15             JSR     LKONLY          ;if lookup$only(sp)
001D0A  1  D0 05                BNE     *+7             ;then
001D0C  1  A9 06                LDA     #6              ;function undefined
001D0E  1  4C AE 0A             JMP     ERROR
001D11  1  A5 A7                LDA     BASE
001D13  1  A4 A8                LDY     BASE+1
001D15  1  20 E9 0C             JSR     STSRSP          ;setsrlocsp(base)
001D18  1  A5 A7                LDA     BASE
001D1A  1  A4 A8                LDY     BASE+1
001D1C  1  20 B1 0C             JSR     STSLSP          ;setsymlocsp(base)
001D1F  1  A9 0A                LDA     #UNFUNC
001D21  1  20 C5 0C             JSR     STTYSP          ;settypesp(unfunc)
001D24  1  20 0A 11             JSR     GETTYP
001D27  1  4C E3 0C             JMP     STHASP          ;sethashsp(getype)
001D2A  1               ;65	|<predefined name>
001D2A  1               PR65
001D2A  1  A5 4B                LDA     FUNCOP
001D2C  1  20 C5 0C             JSR     STTYSP          ;settypesp(funcop)
001D2F  1  A5 83                LDA     STYPSP
001D31  1  4A                   LSR     A
001D32  1  4A                   LSR     A               ;shr(stypesp,2)
001D33  1  29 07                AND     #7
001D35  1  4C E3 0C             JMP     STHASP          ;sethashsp( )
001D38  1               ;67	|<string>
001D38  1               PR67
001D38  1  A9 4E                LDA     #<ACCUM
001D3A  1  A0 00                LDY     #>ACCUM
001D3C  1  4C 8A 18             JMP     GENILS          ;gen$ils(.accum)
001D3F  1               ;68	<relation>::= =
001D3F  1               PR68
001D3F  1  A9 07                LDA     #7
001D41  1  4C C5 0C             JMP     STTYSP          ;settypesp(7)
001D44  1               ;69	| >= | GE
001D44  1               PR69
001D44  1  A9 09                LDA     #9
001D46  1  4C D7 0C             JMP     STTYMP          ;settypemp(9)
001D49  1               ;71	| <= | LE
001D49  1               PR71
001D49  1  A9 0A                LDA     #10
001D4B  1  4C D7 0C             JMP     STTYMP          ;settypemp(10)
001D4E  1               ;73	| >
001D4E  1               PR73
001D4E  1  A9 06                LDA     #6
001D50  1  4C C5 0C             JMP     STTYSP          ;settypesp(6)
001D53  1               ;74	| <
001D53  1               PR74
001D53  1  A9 05                LDA     #5
001D55  1  4C C5 0C             JMP     STTYSP          ;settypesp(5)
001D58  1               ;75	| <> | NE
001D58  1               PR75
001D58  1  A9 08                LDA     #8
001D5A  1  4C D7 0C             JMP     STTYMP          ;settypemp(8)
001D5D  1               ;77	<for statement>::=<for head> to <expression> <step clause>
001D5D  1               PR77
001D5D  1  A0 06                LDY     #3*2            ;word addressing
001D5F  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D63  1  B5 A5 C9 00  
001D67  1  D0 04 A2 00  
001D75  1  85 A7                STA     BASE
001D77  1  C8                   INY
001D78  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D7C  1  B5 A5 C9 00  
001D80  1  D0 04 A2 00  
001D8E  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001D90  1  A5 80                LDA     TYPESP          ;if not typesp
001D92  1  4A                   LSR     A
001D93  1  90 05                BCC     *+7             ;then
001D95  1  A9 12                LDA     #DUP
001D97  1  20 F7 0C             JSR     GENERT          ;generate(dup)
001D9A  1  20 88 11             JSR     GETADR
001D9D  1  20 82 0F             JSR     LITLOD          ;litload(getaddr)
001DA0  1  A9 00                LDA     #FAD
001DA2  1  20 F7 0C             JSR     GENERT          ;generate(fad)
001DA5  1  A5 80                LDA     TYPESP          ;if not
001DA7  1  4A                   LSR     A               ;typesp
001DA8  1  90 0B                BCC     PR77A           ;then
001DAA  1  20 88 11             JSR     GETADR
001DAD  1  20 79 0F             JSR     LITERL          ;literal(getaddr)
001DB0  1  A9 13                LDA     #XCH
001DB2  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001DB5  1               PR77A
001DB5  1  A9 0F                LDA     #STO
001DB7  1  20 F7 0C             JSR     GENERT          ;generate(sto)
001DBA  1  A5 80                LDA     TYPESP          ;if not
001DBC  1  4A                   LSR     A               ;typesp
001DBD  1  90 2D                BCC     PR77B           ;then
001DBF  1  A9 13                LDA     #XCH
001DC1  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001DC4  1  A9 00                LDA     #0
001DC6  1  A8                   TAY
001DC7  1  20 79 0F             JSR     LITERL          ;literal(0)
001DCA  1  A9 05                LDA     #LSS
001DCC  1  20 F7 0C             JSR     GENERT          ;generate(lss)
001DCF  1  A9 05                LDA     #5
001DD1  1  A0 00                LDY     #0
001DD3  1  20 79 0F             JSR     LITERL          ;literal(5)
001DD6  1  A9 38                LDA     #BFC
001DD8  1  20 F7 0C             JSR     GENERT          ;generate(bfc)
001DDB  1  A9 0A                LDA     #LEQ
001DDD  1  20 F7 0C             JSR     GENERT          ;generate(leq)
001DE0  1  A9 02                LDA     #2
001DE2  1  A0 00                LDY     #0
001DE4  1  20 79 0F             JSR     LITERL          ;literal(2)
001DE7  1  A9 39                LDA     #BFN
001DE9  1  20 F7 0C             JSR     GENERT          ;generate(bfn)
001DEC  1               PR77B
001DEC  1  A9 09                LDA     #GEQ
001DEE  1  20 F7 0C             JSR     GENERT          ;generate(beq)
001DF1  1  A9 37                LDA     #BRC
001DF3  1  20 F7 0C             JSR     GENERT          ;generate(brc)
001DF6  1  A0 00                LDY     #0*2            ;word address
001DF8  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001DFC  1  B5 A5 C9 00  
001E00  1  D0 04 A2 00  
001E0E  1  48                   PHA
001E0F  1  C8                   INY
001E10  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E14  1  B5 A5 C9 00  
001E18  1  D0 04 A2 00  
001E26  1  A8                   TAY
001E27  1  68                   PLA
001E28  1  20 70 0F             JSR     GENTWO          ;gen$two(foraddress(0))
001E2B  1  A0 02                LDY     #1*2            ;word addressing
001E2D  1  A5 B2                LDA     CODESI
001E2F  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001E33  1  01 B5 A5 C9  
001E37  1  00 D0 04 A2  
001E45  1  C8                   INY
001E46  1  A5 B3                LDA     CODESI+1
001E48  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(1)=codesize
001E4C  1  01 B5 A5 C9  
001E50  1  00 D0 04 A2  
001E5E  1  60                   RTS
001E5F  1               ;78	<for head>::=<for><assignment>
001E5F  1               PR78
001E5F  1  A9 36                LDA     #BRS
001E61  1  20 F7 0C             JSR     GENERT          ;generate(brs)
001E64  1  A0 02                LDY     #1*2            ;word addressing
001E66  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E6A  1  B5 A5 C9 00  
001E6E  1  D0 04 A2 00  
001E7C  1  48                   PHA
001E7D  1  C8                   INY
001E7E  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E82  1  B5 A5 C9 00  
001E86  1  D0 04 A2 00  
001E94  1  A8                   TAY
001E95  1  68                   PLA
001E96  1  20 70 0F             JSR     GENTWO          ;gen$two(foraddress(1))
001E99  1  A0 04                LDY     #2*2            ;word addressing
001E9B  1  A5 B2                LDA     CODESI
001E9D  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001EA1  1  01 B5 A5 C9  
001EA5  1  00 D0 04 A2  
001EB3  1  C8                   INY
001EB4  1  A5 B3                LDA     CODESI+1
001EB6  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(2)=codesize
001EBA  1  01 B5 A5 C9  
001EBE  1  00 D0 04 A2  
001ECC  1  60                   RTS
001ECD  1               ;79	<for>::= for
001ECD  1               PR79
001ECD  1  A9 FF                LDA     #TRUE
001ECF  1  8D 12 34             STA     FORSTM          ;forstmt=true
001ED2  1  38                   SEC
001ED3  1  A5 A5                LDA     SBTTOP
001ED5  1  E9 08                SBC     #8
001ED7  1  85 A5                STA     SBTTOP
001ED9  1  85 B9                STA     NXSTPT
001EDB  1  A4 A6                LDY     SBTTOP+1
001EDD  1  B0 01                BCS     *+3
001EDF  1  88                   DEY
001EE0  1  84 A6                STY     SBTTOP+1
001EE2  1  84 BA                STY     NXSTPT+1        ;sbtbltop,nextstmtptr=sbtbltop-8
001EE4  1  A0 01                LDY     #1
001EE6  1  8B DA A2 01          LDAINDIRECTY NXSTPT
001EEA  1  B5 B9 C9 00  
001EEE  1  D0 04 A2 00  
001EFC  1  29 7F                AND     #$7F
001EFE  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;nextbytev(1)=nextbytev(1) and $7f
001F02  1  01 B5 B9 C9  
001F06  1  00 D0 04 A2  
001F14  1  A9 00                LDA     #0
001F16  1  20 7D 10             JSR     LIMITS          ;limits(0)
001F19  1  E6 A9                INC     FORCNT          ;forcount=forcount+1
001F1B  1  60                   RTS
001F1C  1               ;80	<step clause>::= step <expression>
001F1C  1               PR80
001F1C  1  A9 01                LDA     #1
001F1E  1  4C D7 0C             JMP     STTYMP          ;settypemp(true)
001F21  1               ;81	|
001F21  1               PR81
001F21  1  A0 06                LDY     #3*2            ;word addressing
001F23  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F27  1  B5 A5 C9 00  
001F2B  1  D0 04 A2 00  
001F39  1  85 A7                STA     BASE
001F3B  1  C8                   INY
001F3C  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F40  1  B5 A5 C9 00  
001F44  1  D0 04 A2 00  
001F52  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001F54  1  20 88 11             JSR     GETADR
001F57  1  20 79 0F             JSR     LITERL          ;literal(getaddr)
001F5A  1  A9 00                LDA     #FALSE
001F5C  1  20 C5 0C             JSR     STTYSP          ;settypesp(false)
001F5F  1  A9 2E                LDA     #CON
001F61  1  20 F7 0C             JSR     GENERT          ;generate(con)
001F64  1  A9 00                LDA     #0
001F66  1  A8                   TAY
001F67  1  4C 70 0F             JMP     GENTWO          ;gen$two(0)
001F6A  1               ;82	<if statement>::=<if group>
001F6A  1               PR82
001F6A  1  A9 00                LDA     #0
001F6C  1  4C DE 15             JMP     ENCMLB          ;enter$compiler$label(0)
001F6F  1               ;84	| if end # <expression> then <number>
001F6F  1               PR84
001F6F  1  A9 5B                LDA     #RON
001F71  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001F74  1  A9 5E                LDA     #DEF
001F76  1  20 F7 0C             JSR     GENERT          ;generate(def)
001F79  1  20 F0 17             JSR     FNDLBL          ;findlabel
001F7C  1  20 88 11             JSR     GETADR
001F7F  1  4C 70 0F             JMP     GENTWO          ;gen$two(getaddr)
001F82  1               ;87	<if else group>::=<if head><statement list> else
001F82  1               PR87
001F82  1  A9 03                LDA     #3
001F84  1  20 DE 15             JSR     ENCMLB          ;emter$compiler$label(3)
001F87  1  A9 36                LDA     #BRS
001F89  1  20 F7 0C             JSR     GENERT          ;generate(brs)
001F8C  1  4C 00 16             JMP     COMLBL          ;compiler$label
001F8F  1               ;88	<if head>::=if <expression> then
001F8F  1               PR88
001F8F  1  A5 84                LDA     STYPM1          ;if stypemp1
001F91  1  C9 32                CMP     #STRING         ;<> string
001F93  1  D0 05                BNE     *+7             ;then
001F95  1  A9 08                LDA     #8              ;else if expression is not floating point
001F97  1  20 AE 0A             JSR     ERROR
001F9A  1  A9 37                LDA     #BRC
001F9C  1  20 F7 0C             JSR     GENERT          ;generate(brc)
001F9F  1  4C 00 16             JMP     COMLBL          ;compiler$label
001FA2  1               ;89	<dummy argument list>::=<expresssion>
001FA2  1               PR89
001FA2  1  20 1E 16             JSR     CHKTY2          ;if chkty2
001FA5  1  D0 01                BNE     *+3             ;the
001FA7  1  60                   RTS
001FA8  1  A5 8A                LDA     SYMLMP
001FAA  1  A4 8B                LDY     SYMLMP+1
001FAC  1  85 A7                STA     BASE
001FAE  1  84 A8                STY     BASE+1
001FB0  1  A5 81                LDA     TYPEM1
001FB2  1  20 2A 11             JSR     SETTYP          ;setype(typemp1)
001FB5  1  20 B2 13             JSR     UNLINK
001FB8  1  A9 13                LDA     #XCH
001FBA  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001FBD  1  A9 1F                LDA     #RTN
001FBF  1  20 F7 0C             JSR     GENERT          ;generate(rtn)
001FC2  1  A9 00                LDA     #0
001FC4  1  4C DE 15             JMP     ENCMLB          ;enter$compiler$label(0)
001FC7  1               ;90	(ud function name>::= def <user defined name>
001FC7  1               PR90
001FC7  1  A9 36                LDA     #BRS
001FC9  1  20 F7 0C             JSR     GENERT          ;generate(brs)
001FCC  1  20 00 16             JSR     COMLBL          ;compiler$label
001FCF  1  A5 7B                LDA     SP
001FD1  1  20 B7 15             JSR     NRMLKU          ;normal$lookup(sp)
001FD4  1  48                   PHA                     ;save result
001FD5  1  A5 83                LDA     STYPSP
001FD7  1  20 D1 0C             JSR     STSTMP          ;setstypemp(stypesp)
001FDA  1  A5 A7                LDA     BASE
001FDC  1  A4 A8                LDY     BASE+1
001FDE  1  20 BF 0C             JSR     STSLMP          ;setsymlocmp(base)
001FE1  1  2C 08 34             BIT     PASS1           ;if pass 1
001FE4  1  30 04                BMI     *+6             ;then
001FE6  1  68                   PLA                     ;clear stack
001FE7  1  4C B1 14             JMP     RELINK
001FEA  1  68                   PLA                     ;if not flag
001FEB  1  F0 05                BEQ     *+7             ;then
001FED  1  A9 02                LDA     #2              ;else function name previously defined
001FEF  1  20 AE 0A             JSR     ERROR
001FF2  1  A5 B2                LDA     CODESI
001FF4  1  A4 B3                LDY     CODESI+1
001FF6  1  4C 9A 10             JMP     SETRSV          ;setaddr(codesize)
001FF9  1               ;92	|
001FF9  1               PR92
001FF9  1  A9 00                LDA     #0
001FFB  1  4C D7 0C             JMP     STTYMP          ;settypemp(0)
001FFE  1               ;98	<file decleration>::=<identifier><file rec size>
001FFE  1               PR98
001FFE  1  A5 7C                LDA     MP
002000  1  20 1D 18             JSR     PSIMPV          ;process$simple$variable(mp)
002003  1  A5 85                LDA     STYPMP          ;if stypemp
002005  1  C9 31                CMP     #FLOTPT         ;<> floatpt
002007  1  D0 05                BNE     *+7             ;then
002009  1  A9 17                LDA     #23             ;invalid type in file
00200B  1  20 AE 0A             JSR     ERROR
00200E  1  A5 86                LDA     SYMLSP
002010  1  A4 87                LDY     SYMLSP+1
002012  1  20 82 0F             JSR     LITLOD          ;litload(symlocsp)
002015  1  A9 2D                LDA     #OPN
002017  1  4C F7 0C             JMP     GENERT          ;generate(opn)
00201A  1               ;100	|
00201A  1               PR100
00201A  1  A9 00                LDA     #0
00201C  1  A8                   TAY
00201D  1  4C 79 0F             JMP     LITERL          ;literal(0)
002020  1               ;104	<dimension variable>::=<dim var head><expression>
002020  1               PR104
002020  1  20 56 16             JSR     CHKTY5          ;chktyp5
002023  1  A5 8A                LDA     SYMLMP
002025  1  A4 8B                LDY     SYMLMP+1
002027  1  85 A7                STA     BASE
002029  1  84 A8                STY     BASE+1          ;base=symlocsp
00202B  1  60                   RTS
00202C  1               ;105	<dim var head>::=<identifier>(
00202C  1               PR105
00202C  1  A5 7C                LDA     MP
00202E  1  20 B7 15             JSR     NRMLKU          ;if not normal$lookup(mp)
002031  1  F0 0A                BEQ     PR105A          ;then
002033  1  2C 08 34             BIT     PASS1           ;if not pass 1
002036  1  10 05                BPL     PR105A          ;then
002038  1  A9 01                LDA     #1              ;identifier in dim previously defined
00203A  1  20 AE 0A             JSR     ERROR
00203D  1               PR105A
00203D  1  A9 02                LDA     #SUBVAR
00203F  1  20 2A 11             JSR     SETTYP          ;setype(subvar)
002042  1  2C 08 34             BIT     PASS1           ;if not pass 1
002045  1  10 06                BPL     *+8             ;then
002047  1  20 C3 15             JSR     CNTPRT
00204A  1  20 9A 10             JSR     SETRSV          ;setaddr(countprt)
00204D  1  20 88 11             JSR     GETADR
002050  1  20 79 0F             JSR     LITERL          ;literal(getaddr)
002053  1  A9 00                LDA     #0
002055  1  20 D7 0C             JSR     STTYMP          ;settypemp(0)
002058  1  A5 A7                LDA     BASE
00205A  1  A4 A8                LDY     BASE+1
00205C  1  4C BF 0C             JMP     STSLMP          ;setsymlocmp(base)
00205F  1               ;108	<close list>::=<expression>
00205F  1               PR108
00205F  1  A5 83                LDA     STYPSP          ;if stypesp
002061  1  C9 32                CMP     #STRING         ;<> string
002063  1  D0 03                BNE     *+5             ;then
002065  1  20 43 16             JSR     MFERR           ;must be floating
002068  1  A9 5B                LDA     #RON
00206A  1  20 F7 0C             JSR     GENERT          ;generate(ron)
00206D  1  A9 40                LDA     #CLS
00206F  1  4C F7 0C             JMP     GENERT          ;generate(cls)
002072  1               ;110	<read statement>::= read <file option><read list>
002072  1               PR110
002072  1  2C 13 34             BIT     FILEIO          ;if not fileio
002075  1  10 0A                BPL     PR110A          ;then
002077  1  A9 3E                LDA     #EDR
002079  1  20 F7 0C             JSR     GENERT          ;generate(edr)
00207C  1               ;117	|
00207C  1               PR117
00207C  1  A9 00                LDA     #FALSE
00207E  1  8D 13 34             STA     FILEIO          ;fileio=false
002081  1               PR110A
002081  1  60                   RTS
002082  1               ;112	<input statement>::=input <prompt option><read list>
002082  1               PR112
002082  1  A9 27                LDA     #ECR
002084  1  20 F7 0C             JSR     GENERT          ;generate(ecr)
002087  1  A9 00                LDA     #FALSE
002089  1  85 47                STA     INPSTM          ;inputstmt=false
00208B  1  60                   RTS
00208C  1               ;113	<prompt option>::=<constant>
00208C  1               PR113
00208C  1  20 32 19             JSR     PUTFLD          ;put$field
00208F  1  4C 84 16             JMP     SEINPU          ;setup$input
002092  1               ;119	|print <file option><file list>
002092  1               PR119
002092  1  A9 3F                LDA     #EDW
002094  1  20 F7 0C             JSR     GENERT          ;generate(edw)
002097  1  A9 00                LDA     #FALSE
002099  1  8D 13 34             STA     FILEIO          ;fileio=false
00209C  1  60                   RTS
00209D  1               ;126	|
00209D  1               PR126
00209D  1  A9 34                LDA     #DBF
00209F  1  4C F7 0C             JMP     GENERT          ;generate(dbf)
0020A2  1               ;127	<file option>::= # <expression>
0020A2  1               PR127
0020A2  1  A9 FF                LDA     #TRUE
0020A4  1  8D 13 34             STA     FILEIO          ;fileio=true
0020A7  1  A9 5B                LDA     #RON
0020A9  1  20 F7 0C             JSR     GENERT          ;generate(ron)
0020AC  1  A9 26                LDA     #RDB
0020AE  1  4C F7 0C             JMP     GENERT          ;generate(rdb)
0020B1  1               ;128	| # <expression>,<expression>;
0020B1  1               PR128
0020B1  1  A9 FF                LDA     #TRUE
0020B3  1  8D 13 34             STA     FILEIO          ;fileio=true
0020B6  1  A9 5B                LDA     #RON
0020B8  1  20 F7 0C             JSR     GENERT          ;generate(ron)
0020BB  1  A9 13                LDA     #XCH
0020BD  1  20 F7 0C             JSR     GENERT          ;generate(xch)
0020C0  1  A9 5B                LDA     #RON
0020C2  1  20 F7 0C             JSR     GENERT          ;generate(ron)
0020C5  1  A9 25                LDA     #RDF
0020C7  1  4C F7 0C             JMP     GENERT          ;generate(rdf)
0020CA  1               ;130	| ,
0020CA  1               PR130
0020CA  1  2C 13 34             BIT     FILEIO          ;if not fileio
0020CD  1  10 01                BPL     *+3             ;then
0020CF  1  60                   RTS
0020D0  1  A9 35                LDA     #NSP
0020D2  1  4C F7 0C             JMP     GENERT          ;generate(nsp)
0020D5  1               ;133	|<on gosub> <label list>
0020D5  1               PR133
0020D5  1  20 EC 16             JSR     GENON2          ;gen$on$2
0020D8  1  A9 00                LDA     #0
0020DA  1  4C DE 15             JMP     ENCMLB          ;enter$compiler$label(0)
0020DD  1               ;135	<on gosub>::= on <expression> <gosub>
0020DD  1               PR135
0020DD  1  20 F7 15             JSR     STCMLB          ;set$compiler$label
0020E0  1  20 88 11             JSR     GETADR
0020E3  1  20 79 0F             JSR     LITERL          ;literal(getaddr)
0020E6  1  A9 60                LDA     #ADJ
0020E8  1  20 F7 0C             JSR     GENERT          ;generate(adj)
0020EB  1  A9 13                LDA     #XCH
0020ED  1  20 F7 0C             JSR     GENERT          ;generate(xch)
0020F0  1  4C CF 16             JMP     GENON           ;gen$on
0020F3  1               ;136	<label list>::=<number>
0020F3  1               PR136
0020F3  1  20 09 18             JSR     RESLBL          ;resolve$label
0020F6  1  A9 01                LDA     #1
0020F8  1  4C C5 0C             JMP     STTYSP          ;settypesp(1)
0020FB  1               ;137	|<label list>,<number>
0020FB  1               PR137
0020FB  1  20 09 18             JSR     RESLBL          ;resolve$label
0020FE  1  A6 82                LDX     TYPEMP
002100  1  E8                   INX
002101  1  8A                   TXA
002102  1  4C D7 0C             JMP     STTYMP          ;settypemp(typemp+1)
002105  1               ;138	<gosub statement>::=<gosub><number>
002105  1               PR138
002105  1  A9 FF                LDA     #TRUE
002107  1  85 48                STA     GSBSTM          ;gosubstmt=true
002109  1  20 09 18             JSR     RESLBL          ;resolve$label
00210C  1  A9 00                LDA     #FALSE
00210E  1  85 48                STA     GSBSTM          ;gosubstmt=false
002110  1  60                   RTS
002111  1               ;147	<out statement>::= out <expression>,<expression>
002111  1               PR147
002111  1  A9 31                LDA     #FLOTPT         ;if stypemp1
002113  1  C5 84                CMP     STYPM1          ;<> floatpt
002115  1  D0 04                BNE     *+6             ;then
002117  1  C5 83                CMP     STYPSP          ;if stypesp = floatpt
002119  1  F0 03                BEQ     *+5             ;then ok
00211B  1  4C 43 16             JMP     MFERR           ;must be floating error
00211E  1  A9 5B                LDA     #RON
002120  1  20 F7 0C             JSR     GENERT          ;generate(ron)
002123  1  A9 13                LDA     #XCH
002125  1  20 F7 0C             JSR     GENERT          ;generate(xch)
002128  1  A9 5B                LDA     #RON
00212A  1  20 F7 0C             JSR     GENERT          ;generate(ron)
00212D  1  A9 28                LDA     #POT
00212F  1  4C F7 0C             JMP     GENERT          ;generate(pot)
002132  1               ;148	<return statement>::= return
002132  1               PR148
002132  1  A9 1F                LDA     #RTN
002134  1  4C F7 0C             JMP     GENERT          ;generate(rtn)
002137  1               ;149	<stop statement>::= stop
002137  1               PR149
002137  1  A9 10                LDA     #XIT
002139  1  4C F7 0C             JMP     GENERT          ;generate(xit)
00213C  1               ;150	<end statement>::= end
00213C  1               PR150
00213C  1  2C 08 34             BIT     PASS1           ;if not pass 1
00213F  1  10 33                BPL     PR150B          ;then
002141  1  A9 00                LDA     #FALSE
002143  1  8D 08 34             STA     PASS1           ;pass1=false
002146  1  A5 A9                LDA     FORCNT          ;if forcount
002148  1  F0 09                BEQ     PR150A          ;= zero then ok
00214A  1  A9 18                LDA     #24             ;else for without next error
00214C  1  20 AE 0A             JSR     ERROR
00214F  1  A9 00                LDA     #0
002151  1  85 A9                STA     FORCNT          ;forcount=0
002153  1               PR150A
002153  1  A9 2A                LDA     #'*'
002155  1  20 F7 0C             JSR     GENERT          ;generate('*')
002158  1  18                   CLC
002159  1  A5 B2                LDA     CODESI
00215B  1  A4 B3                LDY     CODESI+1
00215D  1  69 03                ADC     #3
00215F  1  90 01                BCC     *+3
002161  1  C8                   INY
002162  1  29 FC                AND     #$FC
002164  1  20 70 0F             JSR     GENTWO          ;gen$two((codesize+3) and $fffc)
002167  1  A5 45                LDA     DATACT
002169  1  A4 46                LDY     DATACT+1
00216B  1  20 70 0F             JSR     GENTWO          ;gen$two(datact)
00216E  1  20 C3 15             JSR     CNTPRT
002171  1  4C 70 0F             JMP     GENTWO          ;gen$two(countprt)
002174  1               PR150B
002174  1  A5 4D                LDA     NXTCHR
002176  1  C9 0D                CMP     #CR
002178  1  F0 06                BEQ     *+8
00217A  1  20 15 0A             JSR     GETCHR
00217D  1  4C 74 21             JMP     PR150B          ;while not eol
002180  1  A9 10                LDA     #XIT
002182  1  20 F7 0C             JSR     GENERT          ;generate(xit)
002185  1  A9 7F                LDA     #$7F
002187  1  20 F7 0C             JSR     GENERT          ;generate($7f)
00218A  1  20 94 09             JSR     WRTINT          ;write$int$file
00218D  1  20 4E 09             JSR     CLSINT          ;close$int$file
002190  1  A5 43                LDA     ERRCNT
002192  1  A4 44                LDY     ERRCNT+1
002194  1  20 70 08             JSR     PRNDEC          ;printdec(errorcount)
002197  1  A9 9D                LDA     #<ERDMSG
002199  1  A0 33                LDY     #>ERDMSG
00219B  1  20 FC 08             JSR     PRNMSG          ;print('errors detected')
00219E  1  20 34 08             JSR     CRLF
0021A1  1  4C 00 01             JMP     BOOT
0021A4  1               ;151	<restore statement>::= restore
0021A4  1               PR151
0021A4  1  A9 2F                LDA     #RST
0021A6  1  4C F7 0C             JMP     GENERT          ;generate(rst)
0021A9  1               ;152	<randomize statement>::= randomize
0021A9  1               PR152
0021A9  1  A9 4D                LDA     #IRN
0021AB  1  4C F7 0C             JMP     GENERT          ;generate(irn)
0021AE  1               ;getin1  (does ay=index1(state))
0021AE  1               GETIN1
0021AE  1  A5 79                LDA     STATE
0021B0  1  A4 7A                LDY     STATE+1         ;get state
0021B2  1  0A                   ASL     A
0021B3  1  AA                   TAX
0021B4  1  98                   TYA
0021B5  1  2A                   ROL     A
0021B6  1  A8                   TAY
0021B7  1  18                   CLC
0021B8  1  8A                   TXA
0021B9  1  69 B6                ADC     #<INDEX1        ;add state*2 since is word addressing
0021BB  1  8D D2 21             STA     GT+1
0021BE  1  98                   TYA
0021BF  1  69 2A                ADC     #>INDEX1
0021C1  1  8D D3 21             STA     GT+2
0021C4  1  A2 00                LDX     #0
0021C6  1  20 D1 21             JSR     GT              ;get low
0021C9  1  48                   PHA
0021CA  1  E8                   INX
0021CB  1  20 D1 21             JSR     GT              ;get high
0021CE  1  A8                   TAY
0021CF  1  68                   PLA
0021D0  1  60                   RTS
0021D1  1               ;general purpose lda abs,x routine
0021D1  1               GT
0021D1  1  BD FF FF             LDA     $FFFF,X
0021D4  1  60                   RTS
0021D5  1               ;getin2 (does ay=index2(state))
0021D5  1               GETIN2
0021D5  1  A5 79                LDA     STATE
0021D7  1  A4 7A                LDY     STATE+1
0021D9  1  18                   CLC
0021DA  1  69 62                ADC     #<INDEX2
0021DC  1  8D E6 21             STA     G2+1
0021DF  1  98                   TYA
0021E0  1  69 2D                ADC     #>INDEX2
0021E2  1  8D E7 21             STA     G2+2
0021E5  1               G2
0021E5  1  AD FF FF             LDA     $FFFF
0021E8  1  A0 00                LDY     #0              ;y always zero
0021EA  1  60                   RTS
0021EB  1               ;incsp
0021EB  1               INCSP
0021EB  1  E6 7B                INC     SP
0021ED  1  A5 7B                LDA     SP              ;bump and get
0021EF  1  C9 20                CMP     #PSTKSZ         ;compare to max
0021F1  1  F0 01                BEQ     *+3             ;if = then
0021F3  1  60                   RTS                     ;else ok
0021F4  1  A9 12                LDA     #18             ;stack overflow error
0021F6  1  4C AE 0A             JMP     ERROR
0021F9  1               ;lookahead
0021F9  1               LAHEAD
0021F9  1  24 7E                BIT     NOLOOK          ;if not nolook
0021FB  1  10 07                BPL     LAHEAX          ;then done
0021FD  1  20 B1 0D             JSR     SCANNR          ;scanner
002200  1  A9 00                LDA     #FALSE
002202  1  85 7E                STA     NOLOOK          ;nolook=false
002204  1               LAHEAX
002204  1  60                   RTS
002205  1               ;set$varc$i ---- set varc and increment varindex
002205  1               STVRCI
002205  1  A6 7F                LDX     VARIND
002207  1  9D 02 36             STA     VARC,X          ;save
00220A  1  E8                   INX
00220B  1  86 7F                STX     VARIND          ;bump index
00220D  1  E0 65                CPX     #VARCSZ+1       ;if too big
00220F  1  B0 01                BCS     *+3             ;then error
002211  1  60                   RTS
002212  1  A9 15                LDA     #21             ;varc overflow
002214  1  4C AE 0A             JMP     ERROR
002217  1               ;initialize all of system
002217  1               INTLZ
002217  1  20 9D 0F             JSR     INSYMT          ;in$symtbl
00221A  1  20 23 15             JSR     INSYN           ;in$syn
00221D  1  4C 1D 0B             JMP     INSCAN
002220  1               ;MAIN PROGRAM
002220  1               MAIN
002220  1  A2 02                LDX     #2              ;clear page zero
002222  1  A9 00                LDA     #0
002224  1               PZC
002224  1  95 00                STA     0,X
002226  1  E8                   INX
002227  1  E0 C6                CPX     #LZ
002229  1  D0 F9                BNE     PZC
00222B  1  A9 FF                LDA     #TRUE           ;initialize once
00222D  1  8D 08 34             STA     PASS1
002230  1  8D 0D 34             STA     LWRUPR
002233  1  A9 3A                LDA     #':'
002235  1  85 74                STA     SEPRTR
002237  1  A9 80                LDA     #SRCRSZ
002239  1  85 75                STA     SRCIND
00223B  1  A9 E3                LDA     #<OPNMSG
00223D  1  A0 33                LDY     #>OPNMSG
00223F  1  20 FC 08             JSR     PRNMSG          ;print opening message
002242  1  20 34 08             JSR     CRLF
002245  1  20 17 22             JSR     INTLZ           ;initialize all
002248  1               ;do forever
002248  1               ;do while (pass1 or pass2)
002248  1               M10
002248  1  2C 08 34             BIT     PASS1           ;if pass 1
00224B  1  30 08                BMI     M12             ;then go
00224D  1  2C 09 34             BIT     PASS2           ;or if
002250  1  30 03                BMI     M12             ;pass2 go
002252  1  4C FA 24             JMP     EWP1P2          ;else end of do while pass1 or pass2
002255  1               M12
002255  1  A9 FF                LDA     #TRUE
002257  1  85 7E                STA     NOLOOK          ;nolook=true
002259  1  8D 11 34             STA     CMPLNG          ;compiling=true
00225C  1  A9 79                LDA     #<STARTS
00225E  1  A0 00                LDY     #>STARTS
002260  1  85 79                STA     STATE
002262  1  84 7A                STY     STATE+1         ;state=startstate
002264  1  A9 FF                LDA     #255
002266  1  85 7B                STA     SP              ;sp=255
002268  1  A9 00                LDA     #0
00226A  1  85 7F                STA     VARIND          ;varind=0
00226C  1  8D E2 34             STA     VAR
00226F  1               ;do while compiling
00226F  1               M14
00226F  1  2C 11 34             BIT     CMPLNG          ;test for compiling
002272  1  10 D4                BPL     M10             ;branch if not
002274  1  A9 78                LDA     #<MAXRNO
002276  1  C5 79                CMP     STATE
002278  1  A9 00                LDA     #>MAXRNO
00227A  1  E5 7A                SBC     STATE+1         ;if state>maxrno
00227C  1  B0 03                BCS     *+5             ;continue if ok
00227E  1  4C 7D 23             JMP     M30             ;else try next
002281  1  20 EB 21             JSR     INCSP
002284  1  A5 7B                LDA     SP
002286  1  0A                   ASL     A               ;word addressing
002287  1  AA                   TAX
002288  1  A5 79                LDA     STATE
00228A  1  9D C2 35             STA     STSTAK,X
00228D  1  A5 7A                LDA     STATE+1
00228F  1  9D C3 35             STA     STSTAK+1,X      ;statestack(sp)=state
002292  1  20 AE 21             JSR     GETIN1
002295  1  85 98                STA     I
002297  1  84 99                STY     I+1             ;i=getin1
002299  1  20 F9 21             JSR     LAHEAD          ;lookahead
00229C  1  20 D5 21             JSR     GETIN2          ;index2(state)
00229F  1  18                   CLC
0022A0  1  65 98                ADC     I
0022A2  1  85 9A                STA     J
0022A4  1  98                   TYA
0022A5  1  65 99                ADC     I+1
0022A7  1  85 9B                STA     J+1
0022A9  1  A5 9A                LDA     J
0022AB  1  D0 02                BNE     *+4
0022AD  1  C6 9B                DEC     J+1
0022AF  1  C6 9A                DEC     J               ;j=i-1+getin2
0022B1  1               M20
0022B1  1  A5 9A                LDA     J
0022B3  1  C5 98                CMP     I
0022B5  1  A5 9B                LDA     J+1
0022B7  1  E5 99                SBC     I+1             ;if i>j
0022B9  1  90 B4                BCC     M14             ;go to while compiling
0022BB  1  18                   CLC
0022BC  1  A5 98                LDA     I
0022BE  1  69 0A                ADC     #<READ1
0022C0  1  85 9F                STA     I2
0022C2  1  A5 99                LDA     I+1
0022C4  1  69 25                ADC     #>READ1
0022C6  1  85 A0                STA     I2+1
0022C8  1  A0 00                LDY     #0
0022CA  1  8B DA A2 01          LDAINDIRECTY I2         ;a=read(i)
0022CE  1  B5 9F C9 00  
0022D2  1  D0 04 A2 00  
0022E0  1  C5 49                CMP     TOKEN           ;if not token
0022E2  1  D0 7F                BNE     M23             ;then
0022E4  1  A5 7F                LDA     VARIND          ;get varindex
0022E6  1  A6 7B                LDX     SP
0022E8  1  9D E2 34             STA     VAR,X           ;set var(sp)
0022EB  1  A2 00                LDX     #0
0022ED  1  86 9E                STX     INDEX           ;index=0
0022EF  1               M22
0022EF  1  B5 4E                LDA     ACCUM,X         ;accum(index)
0022F1  1  20 05 22             JSR     STVRCI
0022F4  1  E6 9E                INC     INDEX           ;index=index+1
0022F6  1  A6 9E                LDX     INDEX
0022F8  1  E4 4E                CPX     ACCLEN          ;if < length
0022FA  1  90 F3                BCC     M22             ;then loop
0022FC  1  F0 F1                BEQ     M22             ;loop also if equal
0022FE  1  A6 7B                LDX     SP
002300  1  A5 4C                LDA     HSHCDE
002302  1  9D C2 34             STA     HASH,X          ;hash(sp)=hashcode
002305  1  A5 4A                LDA     SUBTYP
002307  1  9D 22 35             STA     STYPE,X         ;stype(sp)=subtype
00230A  1  A5 98                LDA     I
00230C  1  0A                   ASL     A
00230D  1  85 9F                STA     I2
00230F  1  A5 99                LDA     I+1
002311  1  2A                   ROL     A
002312  1  85 A0                STA     I2+1            ;i2=i*2
002314  1  18                   CLC
002315  1  A5 9F                LDA     I2
002317  1  69 EE                ADC     #<READ2
002319  1  85 9F                STA     I2
00231B  1  A5 A0                LDA     I2+1
00231D  1  69 26                ADC     #>READ2
00231F  1  85 A0                STA     I2+1            ;read2(i)
002321  1  A0 00                LDY     #0
002323  1  8B DA A2 01          LDAINDIRECTY I2         ;low
002327  1  B5 9F C9 00  
00232B  1  D0 04 A2 00  
002339  1  85 79                STA     STATE
00233B  1  C8                   INY
00233C  1  8B DA A2 01          LDAINDIRECTY I2
002340  1  B5 9F C9 00  
002344  1  D0 04 A2 00  
002352  1  85 7A                STA     STATE+1         ;state=read2(i)
002354  1  A9 FF                LDA     #TRUE
002356  1  85 7E                STA     NOLOOK          ;nolook=true
002358  1  A5 9A                LDA     J
00235A  1  A4 9B                LDY     J+1
00235C  1  85 98                STA     I
00235E  1  84 99                STY     I+1
002360  1  4C 74 23             JMP     M24
002363  1               M23
002363  1  A5 98                LDA     I
002365  1  C5 9A                CMP     J               ;ok if different
002367  1  D0 0B                BNE     M24
002369  1  A5 99                LDA     I+1
00236B  1  C5 9B                CMP     J+1
00236D  1  D0 05                BNE     M24             ;ok if different
00236F  1  A9 0F                LDA     #15             ;no legal production
002371  1  20 AE 0A             JSR     ERROR
002374  1               M24
002374  1  E6 98                INC     I               ;bump i and loop
002376  1  D0 02                BNE     *+4
002378  1  E6 99                INC     I+1
00237A  1  4C B1 22             JMP     M20
00237D  1               M30
00237D  1  A9 BD                LDA     #<MAXPNO        ;if state <= maxpno
00237F  1  C5 79                CMP     STATE
002381  1  A9 00                LDA     #>MAXPNO
002383  1  E5 7A                SBC     STATE+1
002385  1  90 03                BCC     *+5
002387  1  4C 3D 24             JMP     M40
00238A  1  20 D5 21             JSR     GETIN2          ;index2(state)
00238D  1  85 98                STA     I               ;ignore high
00238F  1  38                   SEC
002390  1  A5 7B                LDA     SP
002392  1  E5 98                SBC     I
002394  1  85 7C                STA     MP              ;mp=sp-getin2
002396  1  A8                   TAY
002397  1  C8                   INY
002398  1  84 7D                STY     MPP1            ;mpp1=mp+1
00239A  1  38                   SEC
00239B  1  A5 79                LDA     STATE
00239D  1  E9 BD                SBC     #<MAXPNO        ;parameter=state-maxpno
00239F  1  20 2A 1A             JSR     SYNTHE          ;synthesize(state-maxpno)
0023A2  1  2C 11 34             BIT     CMPLNG          ;if compiling
0023A5  1  30 03                BMI     *+5             ;then go
0023A7  1  4C 48 22             JMP     M10             ;else go to do while pass 1 or pass 2
0023AA  1  A5 7C                LDA     MP
0023AC  1  85 7B                STA     SP              ;sp=mp
0023AE  1  20 AE 21             JSR     GETIN1
0023B1  1  85 98                STA     I
0023B3  1  84 99                STY     I+1             ;i=getin1
0023B5  1  A6 7B                LDX     SP
0023B7  1  BD E2 34             LDA     VAR,X
0023BA  1  85 7F                STA     VARIND          ;varindex=var(sp)
0023BC  1  8A                   TXA
0023BD  1  0A                   ASL     A
0023BE  1  AA                   TAX                     ;word addressing
0023BF  1  BD C2 35             LDA     STSTAK,X
0023C2  1  85 9A                STA     J
0023C4  1  BD C3 35             LDA     STSTAK+1,X
0023C7  1  85 9B                STA     J+1             ;j=statestack(sp)
0023C9  1               M31
0023C9  1  A2 00                LDX     #0
0023CB  1  86 9D                STX     K+1             ;high must be zero
0023CD  1  A6 98                LDX     I
0023CF  1  BD 6E 26             LDA     APPLY1,X
0023D2  1  85 9C                STA     K
0023D4  1  F0 11                BEQ     M33             ;exit if k=0
0023D6  1  C5 9A                CMP     J
0023D8  1  D0 04                BNE     M32             ;ok if low k <> low j
0023DA  1  A5 9B                LDA     J+1
0023DC  1  F0 09                BEQ     M33             ;if =0 then j=k
0023DE  1               M32
0023DE  1  E6 98                INC     I
0023E0  1  D0 E7                BNE     M31             ;loop
0023E2  1  E6 99                INC     I+1
0023E4  1  4C C9 23             JMP     M31
0023E7  1               M33
0023E7  1  A5 98                LDA     I               ;ignore high i
0023E9  1  0A                   ASL     A
0023EA  1  85 9F                STA     I2
0023EC  1  A5 99                LDA     I+1
0023EE  1  2A                   ROL     A
0023EF  1  85 A0                STA     I2+1
0023F1  1  18                   CLC
0023F2  1  A5 9F                LDA     I2
0023F4  1  69 B6                ADC     #<APPLY2
0023F6  1  85 9F                STA     I2
0023F8  1  A5 A0                LDA     I2+1
0023FA  1  69 29                ADC     #>APPLY2
0023FC  1  85 A0                STA     I2+1
0023FE  1  A0 00                LDY     #0
002400  1  8B DA A2 01          LDAINDIRECTY I2
002404  1  B5 9F C9 00  
002408  1  D0 04 A2 00  
002416  1  85 79                STA     STATE
002418  1  C8                   INY
002419  1  8B DA A2 01          LDAINDIRECTY I2
00241D  1  B5 9F C9 00  
002421  1  D0 04 A2 00  
00242F  1  85 7A                STA     STATE+1         ;state=apply2(i)
002431  1  05 79                ORA     STATE
002433  1  D0 05                BNE     *+7             ;if not zero then
002435  1  A9 00                LDA     #FALSE
002437  1  8D 11 34             STA     CMPLNG          ;compiling=false
00243A  1  4C 6F 22             JMP     M14
00243D  1               M40
00243D  1  A9 AF                LDA     #<MAXLNO        ;if state
00243F  1  C5 79                CMP     STATE
002441  1  A9 00                LDA     #>MAXLNO
002443  1  E5 7A                SBC     STATE+1         ;> maxlno
002445  1  90 02 80 03          LBCC     M50            ;then go to next
002449  1  4C DD 24     
00244C  1  20 AE 21             JSR     GETIN1
00244F  1  85 98                STA     I
002451  1  84 99                STY     I+1             ;i=getin1
002453  1  20 F9 21             JSR     LAHEAD          ;lookahead
002456  1               M41
002456  1  A2 00                LDX     #0
002458  1  86 9D                STX     K+1
00245A  1  18                   CLC
00245B  1  A5 98                LDA     I
00245D  1  69 D7                ADC     #<LOOK1
00245F  1  85 9F                STA     I2
002461  1  A5 99                LDA     I+1
002463  1  69 25                ADC     #>LOOK1
002465  1  85 A0                STA     I2+1
002467  1  A0 00                LDY     #0
002469  1  8B DA A2 01          LDAINDIRECTY I2         ;a=look1(i)
00246D  1  B5 9F C9 00  
002471  1  D0 04 A2 00  
00247F  1  85 9C                STA     K
002481  1  F0 0D                BEQ     M42             ;exit if k=0
002483  1  C5 49                CMP     TOKEN
002485  1  F0 09                BEQ     M42             ;or if =token
002487  1  E6 98                INC     I               ;bump and loop
002489  1  D0 CB                BNE     M41
00248B  1  E6 99                INC     I+1
00248D  1  4C 56 24             JMP     M41
002490  1               M42
002490  1  A5 98                LDA     I               ;word addressing
002492  1  0A                   ASL     A
002493  1  85 9F                STA     I2
002495  1  A5 99                LDA     I+1
002497  1  2A                   ROL     A
002498  1  85 A0                STA     I2+1
00249A  1  18                   CLC
00249B  1  A5 9F                LDA     I2              ;add start
00249D  1  69 88                ADC     #<LOOK2
00249F  1  85 9F                STA     I2
0024A1  1  A5 A0                LDA     I2+1
0024A3  1  69 28                ADC     #>LOOK2
0024A5  1  85 A0                STA     I2+1
0024A7  1  A0 00                LDY     #0
0024A9  1  8B DA A2 01          LDAINDIRECTY I2         ;low
0024AD  1  B5 9F C9 00  
0024B1  1  D0 04 A2 00  
0024BF  1  85 79                STA     STATE
0024C1  1  C8                   INY
0024C2  1  8B DA A2 01          LDAINDIRECTY I2
0024C6  1  B5 9F C9 00  
0024CA  1  D0 04 A2 00  
0024D8  1  85 7A                STA     STATE+1
0024DA  1  4C 6F 22             JMP     M14
0024DD  1               M50
0024DD  1  20 EB 21             JSR     INCSP
0024E0  1  20 D5 21             JSR     GETIN2
0024E3  1  48                   PHA                     ;save low
0024E4  1  A5 7B                LDA     SP
0024E6  1  0A                   ASL     A               ;word addressing
0024E7  1  AA                   TAX
0024E8  1  68                   PLA
0024E9  1  9D C2 35             STA     STSTAK,X        ;statestack(sp)=getin2
0024EC  1  98                   TYA
0024ED  1  9D C3 35             STA     STSTAK+1,X
0024F0  1  20 AE 21             JSR     GETIN1
0024F3  1  85 79                STA     STATE
0024F5  1  84 7A                STY     STATE+1         ;state=getin1
0024F7  1  4C 6F 22             JMP     M14
0024FA  1               ;end of do while pass 1 or pass 2
0024FA  1               EWP1P2
0024FA  1  A9 FF                LDA     #TRUE
0024FC  1  8D 0B 34             STA     LSTSRC          ;listsource=true
0024FF  1  20 17 22             JSR     INTLZ           ;initialize
002502  1  A9 FF                LDA     #TRUE
002504  1  8D 09 34             STA     PASS2           ;pass2=true
002507  1  4C 48 22             JMP     M10             ;do forever
00250A  1               ;parser state tables
00250A  1               READ1
00250A  1  00 31 0A 0D          .BYTE   0,49,10,13,2,49,50,52,53,54,49,13,22,32,2,3,7,27,30,49,50,52,53
00250E  1  02 31 32 34  
002512  1  35 36 31 0D  
002521  1  36 02 03 07          .BYTE   54,2,3,7,30,49,50,52,53,54,54,52,12,52,2,3,7,49,50,52,53,54,12
002525  1  1E 31 32 34  
002529  1  35 36 36 34  
002538  1  34 31 31 32          .BYTE   52,49,49,50,2,3,7,12,30,49,50,52,53,54,2,2,2,9,5,9,49,4,8,49,16
00253C  1  02 03 07 0C  
002540  1  1E 31 32 34  
002551  1  14 1C 1D 1F          .BYTE   20,28,29,31,35,36,37,38,40,42,43,44,45,46,48,49,51,52,49,14,6
002555  1  23 24 25 26  
002559  1  28 2A 2B 2C  
002566  1  16 0D 34 09          .BYTE   22,13,52,9,52,9,23,9,21,33,41,16,21,33,36,43,9,21,33,5,9,21,33
00256A  1  34 09 17 09  
00256E  1  15 21 29 10  
00257D  1  05 15 21 05          .BYTE   5,21,33,5,9,21,33,5,9,21,33,6,9,21,33,21,33,39,21,33,41,5,21,33
002581  1  09 15 21 05  
002585  1  09 15 21 06  
002595  1  06 15 21 09          .BYTE   6,21,33,9,6,9,16,17,20,25,26,27,28,29,31,35,36,37,38,40,42,43
002599  1  06 09 10 11  
00259D  1  14 19 1A 1B  
0025AB  1  2C 2D 2E 30          .BYTE   44,45,46,48,51,52,2,16,20,28,29,31,35,36,37,38,40,42,43,44,45
0025AF  1  33 34 02 10  
0025B3  1  14 1C 1D 1F  
0025C0  1  2E 30 33 34          .BYTE   46,48,51,52,52,13,24,11,34,9,2,1,3,7,10,13,15,18,19,3,7,9,0
0025C4  1  34 0D 18 0B  
0025C8  1  22 09 02 01  
0025D7  1               LOOK1
0025D7  1  00 31 00 0A          .BYTE   0,49,0,10,13,0,13,0,11,23,34,0,52,0,12,52,0,49,50,0,6,9,11,23
0025DB  1  0D 00 0D 00  
0025DF  1  0B 17 22 00  
0025EF  1  22 00 02 00          .BYTE   34,0,2,0,2,0,9,0,4,8,0,4,8,0,4,8,0,4,8,0,4,8,0,11,23,34,0,14,0
0025F3  1  02 00 09 00  
0025F7  1  04 08 00 04  
00260C  1  0E 00 0E 00          .BYTE   14,0,14,0,9,0,9,0,9,0,9,0,9,0,21,33,0,21,33,0,21,33,0,21,33,0
002610  1  09 00 09 00  
002614  1  09 00 09 00  
002626  1  15 21 27 00          .BYTE   21,33,39,0,21,33,0,21,33,0,21,33,0,23,0,21,33,0,21,33,0,9,0,9
00262A  1  15 21 00 15  
00262E  1  21 00 15 21  
00263E  1  00 06 09 00          .BYTE   0,6,9,0,52,0,11,23,0,11,23,34,0,2,0,11,23,0,52,0,24,0,24,0,11
002642  1  34 00 0B 17  
002646  1  00 0B 17 22  
002657  1  00 17 00 0B          .BYTE   0,23,0,11,0,9,0,2,0,1,3,7,10,13,15,18,19,0,3,7,0,9,0
00265B  1  00 09 00 02  
00265F  1  00 01 03 07  
00266E  1               APPLY1
00266E  1  00 00 00 00          .BYTE   0,0,0,0,55,105,0,19,0,0,32,47,0,0,3,4,12,14,16,17,20,21,22,26
002672  1  37 69 00 13  
002676  1  00 00 20 2F  
002686  1  1B 22 24 26          .BYTE   27,34,36,38,40,98,100,102,103,114,116,0,0,46,0,28,0,33,0,63,0,5
00268A  1  28 62 64 66  
00268E  1  67 72 74 00  
00269C  1  06 08 09 00          .BYTE   6,8,9,0,7,10,0,23,0,13,19,32,35,47,55,99,101,105,106,0,0,0,0,0
0026A0  1  07 0A 00 17  
0026A4  1  00 0D 13 20  
0026B4  1  27 00 00 00          .BYTE   39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,99
0026B8  1  00 00 00 00  
0026BC  1  00 00 00 00  
0026D2  1  6A 00 00 00          .BYTE   106,0,0,0,0,0,40,0,0,0,0,0,0,62,0,0,74,0,74,0,0,0,0,0,0,0,0,0
0026D6  1  00 00 28 00  
0026DA  1  00 00 00 00  
0026EE  1               READ2
0026EE  1  00 00 BF 00          .WORD   0,191,264,260,3,255,256,129,254,253,326,258,329,331,3,5,8,31
0026F2  1  08 01 04 01  
0026F6  1  03 00 FF 00  
002712  1  21 00 FF 00          .WORD   33,255,256,129,254,253,3,5,8,33,255,256,129,254,253,279,42,21
002716  1  00 01 81 00  
00271A  1  FE 00 FD 00  
002736  1  81 00 03 00          .WORD   129,3,5,8,255,256,129,254,253,20,129,273,255,256,3,5,8,20,33
00273A  1  05 00 08 00  
00273E  1  FF 00 00 01  
00275C  1  FF 00 00 01          .WORD   255,256,129,254,253,247,294,4,335,280,283,320,7,10,327,24,26
002760  1  81 00 FE 00  
002764  1  FD 00 F7 00  
00277E  1  0C 01 20 00          .WORD   268,32,34,285,328,125,126,338,38,330,127,128,337,340,275,341
002782  1  22 00 1D 01  
002786  1  48 01 7D 00  
00279E  1  81 00 45 01          .WORD   129,325,23,302,27,220,130,17,131,13,190,14,223,224,277,24,223
0027A2  1  17 00 2E 01  
0027A6  1  1B 00 DC 00  
0027C0  1  E0 00 48 01          .WORD   224,328,330,12,223,224,246,248,223,224,244,223,224,249,252,223
0027C4  1  4A 01 0C 00  
0027C8  1  DF 00 E0 00  
0027E0  1  E0 00 25 01          .WORD   224,293,295,223,224,316,16,223,224,223,224,36,223,224,37,288
0027E4  1  27 01 DF 00  
0027E8  1  E0 00 3C 01  
002800  1  DF 00 E0 00          .WORD   223,224,317,223,224,15,318,319,24,25,26,29,30,339,268,32,34,285
002804  1  3D 01 DF 00  
002808  1  E0 00 0F 00  
002824  1  48 01 7D 00          .WORD   328,125,126,338,38,330,127,128,337,340,341,129,251,24,26,268,32
002828  1  7E 00 52 01  
00282C  1  26 00 4A 01  
002846  1  22 00 1D 01          .WORD   34,285,328,125,126,338,38,330,127,128,337,340,341,129,45,22,28
00284A  1  48 01 7D 00  
00284E  1  7E 00 52 01  
002868  1  7C 00 14 01          .WORD   124,276,286,282,122,6,9,123,257,259,261,265,6,9,11,0
00286C  1  1E 01 1A 01  
002870  1  7A 00 06 00  
002888  1               LOOK2
002888  1  00 00 01 00          .WORD   0,1,176,2,2,263,18,262,177,177,177,19,334,333,35,35,178,39,39
00288C  1  B0 00 02 00  
002890  1  02 00 07 01  
0028AE  1  B3 00 B4 00          .WORD   179,180,180,180,180,180,40,41,245,43,181,44,332,49,49,231,50,50
0028B2  1  B4 00 B4 00  
0028B6  1  B4 00 B4 00  
0028D2  1  EA 00 33 00          .WORD   234,51,51,235,52,52,232,53,53,233,182,182,182,55,57,236,58,237
0028D6  1  33 00 EB 00  
0028DA  1  34 00 34 00  
0028F6  1  3B 00 EE 00          .WORD   59,238,66,308,68,300,69,299,70,301,72,296,76,76,297,77,77,309
0028FA  1  42 00 34 01  
0028FE  1  44 00 2C 01  
00291A  1  4E 00 4E 00          .WORD   78,78,219,84,84,312,85,85,85,183,87,87,336,88,88,298,89,89,310
00291E  1  DB 00 54 00  
002922  1  54 00 38 01  
002940  1  16 01 5B 00          .WORD   278,91,93,93,313,94,94,269,95,321,96,322,97,97,184,99,185,186
002944  1  5D 00 5D 00  
002948  1  39 01 5E 00  
002964  1  BA 00 65 00          .WORD   186,101,314,314,314,102,104,250,187,187,105,106,188,109,221,110
002968  1  3A 01 3A 01  
00296C  1  3A 01 66 00  
002984  1  DE 00 6F 00          .WORD   222,111,193,274,112,113,272,115,284,117,189,118,118,118,118,118
002988  1  C1 00 12 01  
00298C  1  70 00 71 00  
0029A4  1  76 00 76 00          .WORD   118,118,118,229,119,119,230,120,290
0029A8  1  76 00 E5 00  
0029AC  1  77 00 77 00  
0029B6  1               APPLY2
0029B6  1  00 00 00 00          .WORD   0,0,161,71,169,170,168,199,198,200,218,267,201,98,80,90,151,152
0029BA  1  A1 00 47 00  
0029BE  1  A9 00 AA 00  
0029DA  1  5C 00 9B 00          .WORD   92,155,83,86,154,74,150,75,156,146,147,148,149,153,82,79,81,73
0029DE  1  53 00 56 00  
0029E2  1  9A 00 4A 00  
0029FE  1  2E 00 A7 00          .WORD   46,167,166,226,225,228,227,174,173,133,135,134,136,132,139,140
002A02  1  A6 00 E2 00  
002A06  1  E1 00 E4 00  
002A1E  1  8A 00 F0 00          .WORD   138,240,239,305,64,64,304,64,64,304,64,64,304,241,114,243,116
002A22  1  EF 00 31 01  
002A26  1  40 00 40 00  
002A40  1  A3 00 3C 00          .WORD   163,60,242,63,202,61,47,266,194,271,164,137,197,172,108,107,204
002A44  1  F2 00 3F 00  
002A48  1  CA 00 3D 00  
002A62  1  41 00 AB 00          .WORD   65,171,287,196,175,292,291,103,205,145,206,210,165,143,144,142
002A66  1  1F 01 C4 00  
002A6A  1  AF 00 24 01  
002A82  1  CF 00 9F 00          .WORD   207,159,141,307,100,160,162,208,213,56,62,158,157,209,323,48
002A86  1  8D 00 33 01  
002A8A  1  64 00 A0 00  
002AA2  1  44 01 36 00          .WORD   324,54,203,67,216,212,211,195,214,215
002AA6  1  CB 00 43 00  
002AAA  1  D8 00 D4 00  
002AB6  1               INDEX1
002AB6  1  00 00 01 00          .WORD   0,1,2,24,24,4,4,4,4,4,4,34,24,36,24,10,24,24,11,168,24,24,24,4
002ABA  1  02 00 18 00  
002ABE  1  18 00 04 00  
002AE6  1  0C 00 0E 00          .WORD   12,14,24,24,24,33,34,35,36,37,24,45,24,47,24,48,50,60,61,62,63
002AEA  1  18 00 18 00  
002AEE  1  18 00 21 00  
002B10  1  40 00 18 00          .WORD   64,24,36,66,67,67,67,67,67,69,70,89,90,90,90,91,92,89,37,93,94
002B14  1  24 00 42 00  
002B18  1  43 00 43 00  
002B3A  1  5F 00 60 00          .WORD   95,96,97,97,97,98,99,100,103,108,100,100,100,111,115,118,122
002B3E  1  61 00 61 00  
002B42  1  61 00 62 00  
002B5C  1  7E 00 64 00          .WORD   126,100,130,133,100,100,100,136,100,139,100,100,142,142,143,24
002B60  1  82 00 85 00  
002B64  1  64 00 64 00  
002B7C  1  24 00 18 00          .WORD   36,24,145,24,24,167,168,36,186,187,188,188,189,189,189,24,191
002B80  1  91 00 18 00  
002B84  1  18 00 A7 00  
002B9E  1  18 00 C0 00          .WORD   24,192,193,201,203,1,3,6,8,12,14,17,20,26,28,30,32,35,38,41,44
002BA2  1  C1 00 C9 00  
002BA6  1  CB 00 01 00  
002BC8  1  2F 00 33 00          .WORD   47,51,53,55,57,59,61,63,65,67,70,73,76,79,83,86,89,92,94,97,100
002BCC  1  35 00 37 00  
002BD0  1  39 00 3B 00  
002BF2  1  66 00 68 00          .WORD   102,104,107,109,112,116,118,121,123,125,127,129,131,133,135,137
002BF6  1  6B 00 6D 00  
002BFA  1  70 00 74 00  
002C12  1  92 00 95 00          .WORD   146,149,192,217,306,303,311,289,217,270,315,306,217,217,306,281
002C16  1  C0 00 D9 00  
002C1A  1  32 01 2F 01  
002C32  1  01 00 02 00          .WORD   1,2,2,3,3,3,3,3,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,13
002C36  1  02 00 03 00  
002C3A  1  03 00 03 00  
002C70  1  0E 00 0E 00          .WORD   14,14,36,36,37,37,39,39,41,41,43,43,43,43,43,45,45,45,50,50,53
002C74  1  24 00 24 00  
002C78  1  25 00 25 00  
002C9A  1  35 00 35 00          .WORD   53,53,53,55,55,66,66,67,67,68,68,69,69,70,70,72,72,72,72,72,72
002C9E  1  35 00 37 00  
002CA2  1  37 00 42 00  
002CC4  1  48 00 48 00          .WORD   72,72,72,73,74,75,76,76,77,77,77,78,78,79,80,81,82,83,83,84,84
002CC8  1  48 00 49 00  
002CCC  1  4A 00 4B 00  
002CEE  1  55 00 56 00          .WORD   85,86,86,87,88,88,89,90,90,91,93,93,94,95,95,96,96,97,98,98,99
002CF2  1  56 00 57 00  
002CF6  1  58 00 58 00  
002D18  1  63 00 63 00          .WORD   99,99,102,102,103,103,103,104,104,105,105,106,106,108,108,109
002D1C  1  66 00 66 00  
002D20  1  67 00 67 00  
002D38  1  6E 00 6E 00          .WORD   110,110,111,112,113,113,115,116,116,118,118,120,120,121,121,122
002D3C  1  6F 00 70 00  
002D40  1  71 00 71 00  
002D58  1  7B 00 7C 00          .WORD   123,124,125,126,127
002D5C  1  7D 00 7E 00  
002D60  1  7F 00        
002D62  1               INDEX2
002D62  1  00 01 02 09          .BYTE   0,1,2,9,9,6,6,6,6,6,6,1,9,1,9,1
002D66  1  09 06 06 06  
002D6A  1  06 06 06 01  
002D72  1  09 09 01 12          .BYTE   9,9,1,18,9,9,9,6,2,10,9,9,9,1,1
002D76  1  09 09 09 06  
002D7A  1  02 0A 09 09  
002D81  1  01 01 08 09          .BYTE   1,1,8,9,2,9,1,9,2,10,1,1,1,1,2
002D85  1  02 09 01 09  
002D89  1  02 0A 01 01  
002D90  1  09 01 01 02          .BYTE   9,1,1,2,2,2,2,2,1,19,1,1,1,1,1,1
002D94  1  02 02 02 02  
002D98  1  01 13 01 01  
002DA0  1  01 08 01 01          .BYTE   1,8,1,1,1,1,1,1,1,1,1,3,5,3,2,2
002DA4  1  01 01 01 01  
002DA8  1  01 01 01 03  
002DB0  1  02 04 03 04          .BYTE   2,4,3,4,4,4,2,3,3,2,2,2,3,2,3,2
002DB4  1  04 04 02 03  
002DB8  1  03 02 02 02  
002DC0  1  02 01 01 02          .BYTE   2,1,1,2,9,1,9,22,9,9,1,18,1,1,1
002DC4  1  09 01 09 16  
002DC8  1  09 09 01 12  
002DCF  1  01 01 01 02          .BYTE   1,1,1,2,1,9,1,9,1,8,2,1,2,3,2,4
002DD3  1  01 09 01 09  
002DD7  1  01 08 02 01  
002DDF  1  02 03 03 06          .BYTE   2,3,3,6,2,2,2,3,3,3,3,3,4,2,2,2
002DE3  1  02 02 02 03  
002DE7  1  03 03 03 03  
002DEF  1  02 02 02 02          .BYTE   2,2,2,2,2,3,3,3,3,4,3,3,3,2,3,3
002DF3  1  02 03 03 03  
002DF7  1  03 04 03 03  
002DFF  1  02 02 03 02          .BYTE   2,2,3,2,3,4,2,3,2,2,2,2,2,2,2,2
002E03  1  03 04 02 03  
002E07  1  02 02 02 02  
002E0F  1  09 03 02 01          .BYTE   9,3,2,1,19,35,39,40,43,55,85,97
002E13  1  13 23 27 28  
002E17  1  2B 37 55 61  
002E1B  1  63 65 69 6A          .BYTE   99,101,105,106,117,2,0,0,0,0,0,0
002E1F  1  75 02 00 00  
002E23  1  00 00 00 00  
002E27  1  00 00 02 00          .BYTE   0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
002E2B  1  00 00 00 00  
002E2F  1  00 00 00 00  
002E36  1  00 00 00 00          .BYTE   0,0,0,0,0,0,1,1,1,0,2,0,0,0,2,0
002E3A  1  00 00 01 01  
002E3E  1  01 00 02 00  
002E46  1  01 00 02 00          .BYTE   1,0,2,0,2,2,1,1,0,2,2,0,2,0,0,0
002E4A  1  02 02 01 01  
002E4E  1  00 02 02 00  
002E56  1  02 00 02 01          .BYTE   2,0,2,1,2,2,0,1,2,0,0,0,0,0,1,0
002E5A  1  02 02 00 01  
002E5E  1  02 00 00 00  
002E66  1  01 00 00 00          .BYTE   1,0,0,0,1,0,3,1,0,1,0,0,1,5,1,1
002E6A  1  01 00 03 01  
002E6E  1  00 01 00 00  
002E76  1  02 02 03 01          .BYTE   2,2,3,1,2,0,0,2,1,0,2,1,2,0,1,0
002E7A  1  02 00 00 02  
002E7E  1  01 00 02 01  
002E86  1  02 02 01 02          .BYTE   2,2,1,2,1,0,2,2,1,2,1,0,0,2,0,2
002E8A  1  01 00 02 02  
002E8E  1  01 02 01 00  
002E96  1  02 00 02 00          .BYTE   2,0,2,0,0,2,0,0,2,4,0,0,1,1,1,2
002E9A  1  00 02 00 00  
002E9E  1  02 04 00 00  
002EA6  1  02 00 02 01          .BYTE   2,0,2,1,0,1,0,1,1,0,0,2,3,0,0,0
002EAA  1  00 01 00 01  
002EAE  1  01 00 00 02  
002EB6  1  00 00                .BYTE   0,0
002EB8  1               ;reserved word tables
002EB8  1               ;length=1
002EB8  1               LNG1
002EB8  1  0D 3C 28 2B          .BYTE   CR,"<(+*)-,=/",semico,">:#^"
002EBC  1  2A 29 2D 2C  
002EC0  1  3D 2F 3B 3E  
002EC7  1               ;length=2
002EC7  1               LNG2
002EC7  1  49 46 54 4F          .BYTE   "IFTOGOONOREQLTGTLEGENE"
002ECB  1  47 4F 4F 4E  
002ECF  1  4F 52 45 51  
002EDD  1               ;length=3
002EDD  1               LNG3
002EDD  1  46 4F 52 4C          .BYTE   "FORLETREMDIMDEFNOTAND"
002EE1  1  45 54 52 45  
002EE5  1  4D 44 49 4D  
002EF2  1  54 41 4E 53          .BYTE   "TANSINCOSSQRTABLOGLEN"
002EF6  1  49 4E 43 4F  
002EFA  1  53 53 51 52  
002F07  1  46 52 45 41          .BYTE   "FREATNABSEXPINTEND"
002F0B  1  54 4E 41 42  
002F0F  1  53 45 58 50  
002F19  1  50 4F 53 52          .BYTE   "POSRNDSGNASCVALXORSUB"
002F1D  1  4E 44 53 47  
002F21  1  4E 41 53 43  
002F2E  1               ;length=4
002F2E  1               LNG4
002F2E  1  50 45 45 4B          .BYTE   "PEEKPOKE"
002F32  1  50 4F 4B 45  
002F36  1  54 48 45 4E          .BYTE   "THENREADGOTOELSENEXTSTOPDATA"
002F3A  1  52 45 41 44  
002F3E  1  47 4F 54 4F  
002F52  1  46 49 4C 45          .BYTE   "FILECHR$MID$STEPSTR$CALLSINH"
002F56  1  43 48 52 24  
002F5A  1  4D 49 44 24  
002F6E  1               ;length=5
002F6E  1               LNG5
002F6E  1  50 52 49 4E          .BYTE   "PRINTINPUTGOSUBCLOSELEFT$"
002F72  1  54 49 4E 50  
002F76  1  55 54 47 4F  
002F87  1               ;length=6
002F87  1               LNG6
002F87  1  52 45 54 55          .BYTE   "RETURNRIGHT$REMARK"
002F8B  1  52 4E 52 49  
002F8F  1  47 48 54 24  
002F99  1               ;length=7
002F99  1               LNG7
002F99  1  52 45 53 54          .BYTE   "RESTORE"
002F9D  1  4F 52 45     
002FA0  1               ;length=9
002FA0  1               LNG9
002FA0  1  52 41 4E 44          .BYTE   "RANDOMIZE"
002FA4  1  4F 4D 49 5A  
002FA8  1  45           
002FA9  1               ;token table
002FA9  1               ;this table must be ordered in the same order as the reserved word table.  the
002FA9  1               ;first entry does not correspond to any valid token.
002FA9  1               TK
002FA9  1  00                   .BYTE   0
002FAA  1               ;length=1
002FAA  1  17 01 02 03          .BYTE   TCR,LESST,LPARN,TPLUS,ASTRK,RPARN,TMINUS,COMMA,EQUAL,SLASH
002FAE  1  04 05 07 09  
002FB2  1  0D 08        
002FB4  1  06 0A 0B 0C          .BYTE   SCOLN,GTRT,TCOLIN,POUND,EXPON
002FB8  1  0E           
002FB9  1               ;length=2
002FB9  1  11 16 10 14          .BYTE   TIF,TTO,TGO,TON,TOR,EQUAL,LESST,GTRT,TLEQ,TGEQ,TNE
002FBD  1  15 0D 01 0A  
002FC1  1  12 0F 13     
002FC4  1               ;length=3
002FC4  1  1C 1D 00 1A          .BYTE   TFOR,TLET,TREM,TDIM,TDEF,TNOT,TAND,72,69,70,73,74,78,84,76,71
002FC8  1  19 1E 18 48  
002FCC  1  45 46 49 4A  
002FD4  1  41 4B 42 1B          .BYTE   65,75,66,TEND,79,67,68,81,88,TXOR,TSUB
002FD8  1  4F 43 44 51  
002FDC  1  58 21 20     
002FDF  1               ;length=4
002FDF  1  50 1F                .BYTE   80,TOUT
002FE1  1  29 26 24 22          .BYTE   TTHEN,TREAD,TGOTO,TELSE,TNEXT,TSTOP,TDATA,TFILE,82,85,TSTEP
002FE5  1  25 28 63 23  
002FE9  1  52 55 27     
002FEC  1  57 59 5A             .BYTE   87,89,90
002FEF  1               ;length=5
002FEF  1  2D 2C 2B 2A          .BYTE   TPRNT,TINPT,TGOSB,TCLOS,83
002FF3  1  53           
002FF4  1               ;length=6
002FF4  1  2E 56 00             .BYTE   TRETN,86,TREM
002FF7  1               ;length=7
002FF7  1  30                   .BYTE   TREST
002FF8  1               ;length=9
002FF8  1  33                   .BYTE   TIRN
002FF9  1               ;token offset table
002FF9  1               OFFSET
002FF9  1  00 00 0F 25          .BYTE   0,0,15,37,118,182,207,225,232,232
002FFD  1  76 B6 CF E1  
003001  1  E8 E8        
003003  1               ;reserved word count table
003003  1               ;each entry is the number of reserved words of the associated length (0 and up)
003003  1               COUNT
003003  1  00 0F 0B 1B          .BYTE   0,15,11,27,16,5,3,1,0,1
003007  1  10 05 03 01  
00300B  1  00 01        
00300D  1               ;each entry is the index into the token table for the first token of the
00300D  1               ;associated length (0 and up)
00300D  1               TKOS
00300D  1  00 00 0F 1A          .BYTE   0,0,15,26,53,69,74,77,78,78
003011  1  35 45 4A 4D  
003015  1  4E 4E        
003017  1               ;
003017  1               ST
003017  1  01 01 00 01          .BYTE   1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,5,65,70,5,71,70,65,5,1,1
00301B  1  01 01 01 01  
00301F  1  01 01 01 00  
003031  1               ;error messages
003031  1               ERM0
003031  1  44 55 50 4C          .BYTE   "DUPLICATE LABELS OR "
003035  1  49 43 41 54  
003039  1  45 20 4C 41  
003045  1  53 59 4E 43          .BYTE   "SYNCHRONIZATION ERROR$"
003049  1  48 52 4F 4E  
00304D  1  49 5A 41 54  
00305B  1               ERM1
00305B  1  49 44 45 4E          .BYTE   "IDENTIFIER IN DIM "
00305F  1  54 49 46 49  
003063  1  45 52 20 49  
00306D  1  50 52 45 56          .BYTE   "PREVIOUSLY DEFINED$"
003071  1  49 4F 55 53  
003075  1  4C 59 20 44  
003080  1               ERM2
003080  1  50 52 45 44          .BYTE   "PREDEFINED FUNCTION "
003084  1  45 46 49 4E  
003088  1  45 44 20 46  
003094  1  4E 41 4D 45          .BYTE   "NAME PREVIOUSLY DEFINED$"
003098  1  20 50 52 45  
00309C  1  56 49 4F 55  
0030AC  1               ERM3
0030AC  1  46 4F 52 20          .BYTE   "FOR LOOP INDEX NOT SIMPLE"
0030B0  1  4C 4F 4F 50  
0030B4  1  20 49 4E 44  
0030C5  1  20 46 4C 4F          .BYTE   " FLOATING POINT VARIABLE$"
0030C9  1  41 54 49 4E  
0030CD  1  47 20 50 4F  
0030DE  1               ERM4
0030DE  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF PARAMETERS"
0030E2  1  52 52 45 43  
0030E6  1  54 20 4E 55  
0030FC  1  20 49 4E 20          .BYTE   " IN FUNCTION REFERENCE$"
003100  1  46 55 4E 43  
003104  1  54 49 4F 4E  
003113  1               ERM5
003113  1  49 4E 56 41          .BYTE   "INVALID PARAMETER TYPE IN "
003117  1  4C 49 44 20  
00311B  1  50 41 52 41  
00312D  1  46 55 4E 43          .BYTE   "FUNCTION REFERENCE$"
003131  1  54 49 4F 4E  
003135  1  20 52 45 46  
003140  1               ERM6
003140  1  55 4E 44 45          .BYTE   "UNDEFINED FUNCTION$"
003144  1  46 49 4E 45  
003148  1  44 20 46 55  
003153  1               ERM7
003153  1  49 4E 56 41          .BYTE   "INVALID CHARACTER$"
003157  1  4C 49 44 20  
00315B  1  43 48 41 52  
003165  1               ERM8
003165  1  45 58 50 52          .BYTE   "EXPRESSION IN IF STATEMENT"
003169  1  45 53 53 49  
00316D  1  4F 4E 20 49  
00317F  1  20 4E 4F 54          .BYTE   " NOT FLOATING POINT$"
003183  1  20 46 4C 4F  
003187  1  41 54 49 4E  
003193  1               ERM9
003193  1  49 4C 4C 45          .BYTE   "ILLEGAL FLOATING POINT FORMAT$"
003197  1  47 41 4C 20  
00319B  1  46 4C 4F 41  
0031B1  1               ERM10
0031B1  1  53 55 42 53          .BYTE   "SUBSCRIPTED VARIABLE NOT "
0031B5  1  43 52 49 50  
0031B9  1  54 45 44 20  
0031CA  1  50 52 45 56          .BYTE   "PREVIOUSLY DIMENSIONED$"
0031CE  1  49 4F 55 53  
0031D2  1  4C 59 20 44  
0031E1  1               ERM11
0031E1  1  41 52 52 41          .BYTE   "ARRAY NAME USED AS SIMPLE"
0031E5  1  59 20 4E 41  
0031E9  1  4D 45 20 55  
0031FA  1  20 56 41 52          .BYTE   " VARAIBLE$"
0031FE  1  41 49 42 4C  
003202  1  45 24        
003204  1               ERM12
003204  1  53 54 52 49          .BYTE   "STRING EXPRESSION NOT ALLOWED$"
003208  1  4E 47 20 45  
00320C  1  58 50 52 45  
003222  1               ERM13
003222  1  4D 49 58 45          .BYTE   "MIXED MODE (STRING - FLOATING)"
003226  1  44 20 4D 4F  
00322A  1  44 45 20 28  
003240  1  20 45 58 50          .BYTE   " EXPRESSION$"
003244  1  52 45 53 53  
003248  1  49 4F 4E 24  
00324C  1               ERM14
00324C  1  4E 45 58 54          .BYTE   "NEXT VARIABLE DOES NOT "
003250  1  20 56 41 52  
003254  1  49 41 42 4C  
003263  1  4D 41 54 43          .BYTE   "MATCH FOR$"
003267  1  48 20 46 4F  
00326B  1  52 24        
00326D  1               ERM15
00326D  1  4E 4F 20 50          .BYTE   "NO PRODUCTION EXISTS$"
003271  1  52 4F 44 55  
003275  1  43 54 49 4F  
003282  1               ERM16
003282  1  4E 45 58 54          .BYTE   "NEXT STATEMENT WITHOUT "
003286  1  20 53 54 41  
00328A  1  54 45 4D 45  
003299  1  4D 41 54 43          .BYTE   "MATCHING FOR$"
00329D  1  48 49 4E 47  
0032A1  1  20 46 4F 52  
0032A6  1               ERM17
0032A6  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF "
0032AA  1  52 52 45 43  
0032AE  1  54 20 4E 55  
0032BA  1  53 55 42 53          .BYTE   "SUBSCRIPTS$"
0032BE  1  43 52 49 50  
0032C2  1  54 53 24     
0032C5  1               ERM18
0032C5  1  43 4F 4D 50          .BYTE   "COMPILER STACK OVERFLOW$"
0032C9  1  49 4C 45 52  
0032CD  1  20 53 54 41  
0032DD  1               ERM19
0032DD  1  53 59 4D 42          .BYTE   "SYMBOL TABLE OVERFLOW$"
0032E1  1  4F 4C 20 54  
0032E5  1  41 42 4C 45  
0032F3  1               ERM20
0032F3  1  55 4E 44 45          .BYTE   "UNDEFINED LABEL$"
0032F7  1  46 49 4E 45  
0032FB  1  44 20 4C 41  
003303  1               ERM21
003303  1  56 41 52 43          .BYTE   "VARC TABLE OVERFLOW$"
003307  1  20 54 41 42  
00330B  1  4C 45 20 4F  
003317  1               ERM22
003317  1  55 4E 54 45          .BYTE   "UNTERMINATED STRING$"
00331B  1  52 4D 49 4E  
00331F  1  41 54 45 44  
00332B  1               ERM23
00332B  1  49 4E 56 41          .BYTE   "INVALID TYPE IN FILE"
00332F  1  4C 49 44 20  
003333  1  54 59 50 45  
00333F  1  20 49 44 45          .BYTE   " IDENTIFIER$"
003343  1  4E 54 49 46  
003347  1  49 45 52 24  
00334B  1               ERM24
00334B  1  46 4F 52 20          .BYTE   "FOR WITHOUT MATCHING NEXT$"
00334F  1  57 49 54 48  
003353  1  4F 55 54 20  
003365  1               ;error message table
003365  1               ERMTBL
003365  1  31 30 5B 30          .WORD   ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
003369  1  80 30 AC 30  
00336D  1  DE 30 13 31  
003375  1  65 31 93 31          .WORD   ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
003379  1  B1 31 E1 31  
00337D  1  04 32 22 32  
003385  1  82 32 A6 32          .WORD   ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
003389  1  C5 32 DD 32  
00338D  1  F3 32 03 33  
003395  1  4B 33                .WORD   ERM24
003397  1               ;messages and strings
003397  1               PRDMSG
003397  1  50 52 4F 44          .BYTE   "PROD $"
00339B  1  20 24        
00339D  1               ERDMSG
00339D  1  20 45 52 52          .BYTE   " ERRORS DETECTED$"
0033A1  1  4F 52 53 20  
0033A5  1  44 45 54 45  
0033AE  1               DEMSG
0033AE  1  44 49 53 4B          .BYTE   "DISK ERROR - ABORTING $"
0033B2  1  20 45 52 52  
0033B6  1  4F 52 20 2D  
0033C5  1               BASSTR
0033C5  1  42 41 53             .BYTE   "BAS"
0033C8  1               NSMSG
0033C8  1  4E 4F 20 53          .BYTE   "NO SOURCE - ABORTING $"
0033CC  1  4F 55 52 43  
0033D0  1  45 20 2D 20  
0033DE  1               ADDEND
0033DE  1  45 4E 44 0D          .BYTE   "END",CR,LF
0033E2  1  0A           
0033E3  1               OPNMSG
0033E3  1  42 41 53 49          .BYTE   "BASIC-E/65 COMPILER - "
0033E7  1  43 2D 45 2F  
0033EB  1  36 35 20 43  
0033F9  1  56 45 52 53          .BYTE   "VERSION 2.03-A$"
0033FD  1  49 4F 4E 20  
003401  1  32 2E 30 33  
003408  1               ;variables - this area holds data moved from page zero to save page zero space
003408  1               PASS1
003408  1  00                   .BYTE   0               ;pass 1 if true i=TRUE
003409  1               PASS2
003409  1  00                   .BYTE   0               ;pass 2 if true
00340A  1               LSTPRD
00340A  1  00                   .BYTE   0               ;list production if true (listprod)
00340B  1               LSTSRC
00340B  1  00                   .BYTE   0               ;list source if true (listsource)
00340C  1               DEBUGL
00340C  1  00                   .BYTE   0               ;debug line numbers if true (debugln)
00340D  1               LWRUPR
00340D  1  00                   .BYTE   0               ;convert if true i=TRUE (lowertoupper)
00340E  1               NINTFL
00340E  1  00                   .BYTE   0               ;no .INT file if true (nointfile)
00340F  1               LSTFLG
00340F  1  00                   .BYTE   0               ;list device if false (lstflag)
003410  1               EOLSTS
003410  1  00                   .BYTE   0               ;flag that eol (cr) read by scan
003411  1               CMPLNG
003411  1  00                   .BYTE   0               ;compiling if true (compiling)
003412  1               FORSTM
003412  1  00                   .BYTE   0               ;for statement flag (forstmt)
003413  1               FILEIO
003413  1  00                   .BYTE   0               ;file i/o flag
003414  1               ;next variable is never read or tested - need to check need
003414  1               RNDFLE
003414  1  00                   .BYTE   0               ;random file flag (randomfile)
003415  1               ;fcbs and similar
003415  1               WFCB
003415  1  xx xx xx xx          .RES    9
003419  1  xx xx xx xx  
00341D  1  xx           
00341E  1  49 4E 54             .BYTE   "INT"
003421  1  xx xx xx xx          .RES    21
003425  1  xx xx xx xx  
003429  1  xx xx xx xx  
003436  1               PRMLST
003436  1  20 20 20 20          .BYTE   "         "
00343A  1  20 20 20 20  
00343E  1  20           
00343F  1               ;parser data tables
00343F  1               IFLBLN
00343F  1  02                   .BYTE   2
003440  1               IFLAB2
003440  1  17                   .BYTE   23
003441  1               IFLABL
003441  1  00                   .BYTE   0
003442  1               HSHTBL
003442  1  xx xx xx xx          .RES    HSHTSZ*2
003446  1  xx xx xx xx  
00344A  1  xx xx xx xx  
0034C2  1               HASH
0034C2  1  xx xx xx xx          .RES    PSTKSZ
0034C6  1  xx xx xx xx  
0034CA  1  xx xx xx xx  
0034E2  1               VAR
0034E2  1  xx xx xx xx          .RES    PSTKSZ
0034E6  1  xx xx xx xx  
0034EA  1  xx xx xx xx  
003502  1               TYPE
003502  1  xx xx xx xx          .RES    PSTKSZ
003506  1  xx xx xx xx  
00350A  1  xx xx xx xx  
003522  1               STYPE
003522  1  xx xx xx xx          .RES    PSTKSZ
003526  1  xx xx xx xx  
00352A  1  xx xx xx xx  
003542  1               SRLOC
003542  1  xx xx xx xx          .RES    PSTKSZ*2
003546  1  xx xx xx xx  
00354A  1  xx xx xx xx  
003582  1               SYMLOC
003582  1  xx xx xx xx          .RES    PSTKSZ*2
003586  1  xx xx xx xx  
00358A  1  xx xx xx xx  
0035C2  1               STSTAK
0035C2  1  xx xx xx xx          .RES    PSTKSZ*2
0035C6  1  xx xx xx xx  
0035CA  1  xx xx xx xx  
003602  1               VARC
003602  1  xx xx xx xx          .RES    VARCSZ
003606  1  xx xx xx xx  
00360A  1  xx xx xx xx  
003666  1               ONSTAK
003666  1  xx xx xx xx          .RES    MAXOCT
00366A  1  xx xx xx xx  
00366E  1  xx xx xx xx  
003675  1               ONSP            = ONSTAK
003675  1               ;buffers
003675  1               INPBUF
003675  1  xx xx xx xx          .RES    SRCRSZ
003679  1  xx xx xx xx  
00367D  1  xx xx xx xx  
0036F5  1               OUTBUF
0036F5  1  xx xx xx xx          .RES    INTRSZ
0036F9  1  xx xx xx xx  
0036FD  1  xx xx xx xx  
003775  1               CONBUF
003775  1  xx xx xx xx          .RES    CBUFSZ+2
003779  1  xx xx xx xx  
00377D  1  xx xx xx xx  
0037C9  1               ;start of free memory
0037C9  1               MEMORY
0037C9  1                       .END
