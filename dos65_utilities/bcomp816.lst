ca65 V2.18 - Ubuntu 2.19-1
Main file   : compl203.asm
Current file: compl203.asm

000000r 1                       .INCLUDE "macro816.asm"
000000r 2                .IFDEF  DUODYNE
000000r 2               .P816
000000r 2               
000000r 2                       .MACRO  INDEX16         ; Set 16bit Index Registers
000000r 2                       REP     #$10            ; 16 bit Index registers
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2                       .MACRO  INDEX8          ; Set 8bit Index Registers
000000r 2                       SEP     #$10            ; 8 bit Index registers
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR16   ; Set 16bit Index Registers
000000r 2                       REP     #$20            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR8    ; Set 8bit Index Registers
000000r 2                       SEP     #$20            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX16; Set 16bit Index Registers
000000r 2                       REP     #$30            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX8; Set 8bit Index Registers
000000r 2                       SEP     #$30            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLB
000000r 2                       LDA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       PHA
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLA
000000r 2                       PLX
000000r 2                       STA     (<PARM1),Y      ;
000000r 2                       PLB
000000r 2                       STA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CMP     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ADC     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ORA     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BNE     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE PARM1
000000r 2                       BEQ     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ELSE
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       STA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       CMP     (<PARM1),Y      ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       ADC     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       ORA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BEQ     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE  PARM1
000000r 2                       BNE     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ENDIF
000000r 2               
000000r 1               ;COMPILE
000000r 1               ;BASIC-E/65 Compiler
000000r 1               ;Version 2.03-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;released:	18 october 1982
000000r 1               ;last revision:
000000r 1               ;	24 december 1983
000000r 1               ;		added chkule for prod 5
000000r 1               ;		modified error to print line
000000r 1               ;		added code to set seprtr
000000r 1               ;	12 january 1984
000000r 1               ;		deleted error0 bit and branch
000000r 1               ;		fixed first blank line list for $b option
000000r 1               ;		fixed buffer overwrite on error
000000r 1               ;	4 april 2008
000000r 1               ;		reformatted for ASM211 & TASM
000000r 1               ;		eliminated page zero 0 & 1
000000r 1               ;		moved some variables from page zero
000000r 1               ;A translation of Gordon Eubanks BASIC-E to operate under DOS/65.  This is a
000000r 1               ;compile-interpret systems invoked against a source file of type .BAS.  The
000000r 1               ;compiler produces an intermediate code file of type .INT which is executed
000000r 1               ;by the program RUN.
000000r 1               ;external references
000000r 1               BOOT            = $100          ;boot entry
000000r 1               PEM             = $103          ;pem entry
000000r 1               FCB             = $107          ;default fcb
000000r 1               TEA             = $800          ;load address
000000r 1               ;fixed parameters and constants
000000r 1               ;CAUTION: When a register is set to TRUE, Z is set to 0 (i.e. NE).  If a
000000r 1               ;register is set to FALSE then Z is set to 1 (i.e. EQ).
000000r 1               TRUE            = $FF
000000r 1               FALSE           = 0
000000r 1               ;ascii characters
000000r 1               TAB             = 9             ;tab
000000r 1               LF              = 10            ;linefeed
000000r 1               CR              = 13            ;return and eol
000000r 1               EOF             = 26            ;eof char
000000r 1               SPACE           = 32            ;ascii blank
000000r 1               semico          = 59            ;semicolon
000000r 1               backsl          = 92            ;backslash
000000r 1               ;other
000000r 1               IDNTSZ          = 32            ;max identifier size + 1
000000r 1               VARCSZ          = 100           ;varc stack size
000000r 1               PSTKSZ          = 32            ;parse stack size
000000r 1               SRCRSZ          = 128           ;source file record size
000000r 1               INTRSZ          = 128           ;int file record size
000000r 1               CBUFSZ          = 82            ;console buffer size
000000r 1               HSHTSZ          = 64            ;hash table size
000000r 1               HSHMSK          = HSHTSZ-1      ;hashing mask
000000r 1               MAXOCT          = 15            ;max number on statements
000000r 1               MAXRWL          = 9             ;max reserved word length
000000r 1               MAXRNO          = 120           ;max read count
000000r 1               MAXLNO          = 175           ;max look count
000000r 1               MAXPNO          = 189           ;max push count
000000r 1               MAXSNO          = 341           ;max state count
000000r 1               STARTS          = 121           ;start state
000000r 1               PRODNO          = 152           ;number productions
000000r 1               SIMVAR          = 0
000000r 1               SUBVAR          = 2
000000r 1               CONST           = 4
000000r 1               LABLE           = 8
000000r 1               UNFUNC          = $A
000000r 1               ;mnemonics for basic-e machine
000000r 1               FAD             = 0
000000r 1               FMI             = 1
000000r 1               FMU             = 2
000000r 1               FDI             = 3
000000r 1               EXP             = 4
000000r 1               LSS             = 5
000000r 1               GTR             = 6
000000r 1               EQU             = 7
000000r 1               NEQ             = 8
000000r 1               GEQ             = 9
000000r 1               LEQ             = 10
000000r 1               NOT             = 11
000000r 1               ANDO            = 12
000000r 1               BOR             = 13
000000r 1               LOD             = 14
000000r 1               STO             = 15
000000r 1               XIT             = 16
000000r 1               DEL             = 17
000000r 1               DUP             = 18
000000r 1               XCH             = 19
000000r 1               STD             = 20
000000r 1               SLT             = 21
000000r 1               SGT             = 22
000000r 1               SEQ             = 23
000000r 1               SNE             = 24
000000r 1               SGE             = 25
000000r 1               SLE             = 26
000000r 1               STS             = 27
000000r 1               ILS             = 28
000000r 1               CAT             = 29
000000r 1               PRO             = 30
000000r 1               RTN             = 31
000000r 1               ROW             = 32
000000r 1               SUB             = 33
000000r 1               RDV             = 34
000000r 1               WRV             = 35
000000r 1               WST             = 36
000000r 1               RDF             = 37
000000r 1               RDB             = 38
000000r 1               ECR             = 39
000000r 1               POT             = 40
000000r 1               WRB             = 40
000000r 1               RDN             = 41
000000r 1               RDS             = 42
000000r 1               WRN             = 43
000000r 1               WRS             = 44
000000r 1               OPN             = 45
000000r 1               CON             = 46
000000r 1               RST             = 47
000000r 1               NEG             = 48
000000r 1               RES             = 49
000000r 1               NOPO            = 50
000000r 1               DAT             = 51
000000r 1               DBF             = 52
000000r 1               NSP             = 53
000000r 1               BRS             = 54
000000r 1               BRC             = 55
000000r 1               BFC             = 56
000000r 1               BFN             = 57
000000r 1               CVB             = 58
000000r 1               RCN             = 59
000000r 1               DRS             = 60
000000r 1               DRF             = 61
000000r 1               EDR             = 62
000000r 1               EDW             = 63
000000r 1               CLS             = 64
000000r 1               IRN             = 77
000000r 1               RON             = 91
000000r 1               CKO             = 92
000000r 1               EXR             = 93
000000r 1               DEF             = 94
000000r 1               BOL             = 95
000000r 1               ADJ             = 96
000000r 1               ;token definitions
000000r 1               POUND           = 12
000000r 1               ASTRK           = 4
000000r 1               LESST           = 1
000000r 1               EXPON           = 14
000000r 1               TDATA           = 99
000000r 1               TELSE           = 34
000000r 1               TFOR            = 28
000000r 1               TIF             = 17
000000r 1               TNEXT           = 37
000000r 1               SLASH           = 8
000000r 1               TOR             = 21
000000r 1               TREST           = 48
000000r 1               TSTOP           = 40
000000r 1               FUNCT           = 53
000000r 1               TLEQ            = 18
000000r 1               TNE             = 19
000000r 1               TOUT            = 31
000000r 1               IDENT           = 52
000000r 1               UDFUNC          = 54
000000r 1               LPARN           = 2
000000r 1               TPLUS           = 3
000000r 1               TCOLIN          = 11
000000r 1               EQUAL           = 13
000000r 1               TAND            = 24
000000r 1               TDEF            = 25
000000r 1               TEND            = 27
000000r 1               TGOSB           = 43
000000r 1               TINPT           = 44
000000r 1               TNOT            = 30
000000r 1               TPRNT           = 45
000000r 1               TRETN           = 46
000000r 1               TTHEN           = 41
000000r 1               TGEQ            = 15
000000r 1               COMMA           = 9
000000r 1               TCLOS           = 42
000000r 1               TIRN            = 51
000000r 1               RPARN           = 5
000000r 1               TMINUS          = 7
000000r 1               SCOLN           = 6
000000r 1               GTRT            = 10
000000r 1               TCR             = 23
000000r 1               TDIM            = 26
000000r 1               TFILE           = 35
000000r 1               TGOTO           = 36
000000r 1               TLET            = 29
000000r 1               TON             = 20
000000r 1               TREAD           = 38
000000r 1               TSTEP           = 39
000000r 1               TTO             = 22
000000r 1               TSUB            = 32
000000r 1               TGO             = 16
000000r 1               TXOR            = 33
000000r 1               STRING          = 50
000000r 1               FLOTPT          = 49
000000r 1               TREM            = 0
000000r 1               ;page zero variables
000000r 1               ;all non-zero initial values are shown as i=xxxx where xxxx is the initial
000000r 1               ;value. PL/M name is shown if significantly different.
000000r 1               GPIND           = $02+$40       ;INDEX IN GETCHR
000000r 1               ERRCNT          = $03+$40       ;ERROR COUNT (ERRORCOUNT)
000000r 1               DATACT          = $05+$40       ;COUNT DATA AREA SIZE
000000r 1               INPSTM          = $07+$40       ;(INPUTSTMT)
000000r 1               GSBSTM          = $08+$40       ;(GOSUBSTMT)
000000r 1               TOKEN           = $09+$40       ;TYPE OF TOKEN
000000r 1               SUBTYP          = $0A+$40       ;SUBTYPE OF TOKEN (SUBTYPE)
000000r 1               FUNCOP          = $0B+$40       ;FUNCTION NUMBER IF FUNCTION
000000r 1               HSHCDE          = $0C+$40       ;HASH OF CURRENT TOKEN (HASHCODE)
000000r 1               NXTCHR          = $0D+$40       ;CURRENT CHAR FROM GETCHR (NEXTCHAR)
000000r 1               ACCUM           = $0E+$40       ;CURRENT TOKEN
000000r 1               ACCLEN          = ACCUM         ;LENGTH IS FIRST BYTE
000000r 1               CONT            = $2E+$40       ;ACCUM FULL FLAG
000000r 1               COLUMN          = $2F+$40       ;CURRENT COLUMN
000000r 1               LINENO          = $30+$40       ;CURRENT LINE NUMBER
000000r 1               OUTIND          = $32+$40       ;INT BUFFER INDEX (BUFFPTR)
000000r 1               LENGTH          = $33+$40       ;OUTPUT LINE LENGTH
000000r 1               SEPRTR          = $34+$40       ;SEPARATOR I=':'
000000r 1               SRCIND          = $35+$40       ;SOURCE INDEX I=SRCRSZ (SOURCEPTR)
000000r 1               LNEPTR          = $36+$40       ;LINE POINTER
000000r 1               POINTR          = $37+$40       ;POINTER IN ERROR
000000r 1               ERRCDE          = $38+$40       ;COMPILER ERROR CODE
000000r 1               STATE           = $39+$40       ;STATE
000000r 1               SP              = $3B+$40       ;STACK POINTER
000000r 1               MP              = $3C+$40       ;
000000r 1               MPP1            = $3D+$40       ;MP + 1
000000r 1               NOLOOK          = $3E+$40       ;
000000r 1               VARIND          = $3F+$40       ;INDEX INTO VAR
000000r 1               TYPESP          = $40+$40       ;GROUP OF
000000r 1               TYPEM1          = $41+$40       ;VARIABLES
000000r 1               TYPEMP          = $42+$40       ;TO HOLD
000000r 1               STYPSP          = $43+$40       ;PARSER STACK
000000r 1               STYPM1          = $44+$40       ;CONTENTS
000000r 1               STYPMP          = $45+$40       ;DURING
000000r 1               SYMLSP          = $46+$40       ;ACTION
000000r 1               SYMLM1          = $48+$40       ;OF SYNTHESIZE
000000r 1               SYMLMP          = $4A+$40       ;IN
000000r 1               HASHSP          = $4C+$40       ;ORDER TO
000000r 1               HASHM1          = $4D+$40       ;REDUCE
000000r 1               HASHMP          = $4E+$40       ;THE AMOUNT
000000r 1               SRLOSP          = $4F+$40       ;OF INDEXING
000000r 1               SRLOMP          = $51+$40       ;IN SYNTHE
000000r 1               DECOUT          = $53+$40       ;DECIMAL WORD
000000r 1               LZFLAG          = $55+$40       ;LEADING ZERO FLAG IN PRNDEC
000000r 1               FIELD           = $56+$40       ;POINTER IN COMPARE
000000r 1               I               = $58+$40       ;PARSER VAR
000000r 1               J               = $5A+$40       ;SAME
000000r 1               K               = $5C+$40       ;EVEN MORE
000000r 1               INDEX           = $5E+$40       ;
000000r 1               I2              = $5F+$40       ;I*2 AND WORD POINTER
000000r 1               IC              = $61+$40       ;INDEX IN COMPAR
000000r 1               PTR             = $62+$40       ;POINTER IN LOOKUP AND COMPAR
000000r 1               IL              = $64+$40       ;INDEX IN LOOKUP
000000r 1               SBTTOP          = $65+$40       ;TOP OF FOR/NEXT STACK
000000r 1               BASE            = $67+$40       ;BASE OF CURRENT ENTRY
000000r 1               FORCNT          = $69+$40       ;FOR COUNT
000000r 1               SBTBL           = $6A+$40       ;TOP OF SYMBOL TABLE
000000r 1               APTADD          = $6C+$40       ;UTILITY VAR TO ACCESS TABLE
000000r 1               PRTCT           = $6E+$40       ;COUNT PRT ENTRIES
000000r 1               FDACT           = $70+$40       ;COUNT FDA ENTRIES
000000r 1               CODESI          = $72+$40       ;COUNT SIZE OF CODE AREA
000000r 1               ULERFL          = $74+$40       ;
000000r 1               PRNTNM          = $75+$40       ;POINTER SET BEFORE SLOOKU OR ENTER
000000r 1               SYMHSH          = $77+$40       ;HASH OF TOKEN REFERENCE
000000r 1               PRODCT          = $78+$40       ;PRODUCTION NUMBER (0 TO PRODNO)
000000r 1               NXSTPT          = $79+$40       ;NEXT STATEMENT POINTER
000000r 1               TMPHSH          = $7B+$40       ;LOCAL HASH IN GETHSH
000000r 1               TMPPTR          = $7C+$40       ;LOCAL PTR IN GETHSH
000000r 1               LEN             = $7D+$40       ;TEMP IN SLOOKU
000000r 1               NUMPRM          = $7E+$40       ;TEMP IN UNLINK/RELINK
000000r 1               LINKI           = $7F+$40       ;TEMP IN UNLINK/RELINK
000000r 1               TMPADR          = $80+$40       ;TEMP IN UNLINK/RELINK
000000r 1               WHERE           = $82+$40       ;TEMP IN GENILS
000000r 1               STRPTR          = $84+$40       ;TEMP IN GINILS
000000r 1               IGEN            = $85+$40       ;TEMP IN GENCON
000000r 1               LZ              = $86+$40       ;
000000r 1               TMPFLG          = $87+$40       ;
000000r 1               
000000r 1               ;entry point
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C 1D 22             JMP     MAIN
000803  1               ;copyright notice
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT - RICHARD"
000807  1  52 49 47 48  
00080B  1  54 20 2D 20  
000816  1  20 41 2E 20          .BYTE   " A. LEARY - 2008"
00081A  1  4C 45 41 52  
00081E  1  59 20 2D 20  
000826  1               ;SUBROUTINES
000826  1               ;subroutine to point to source fcb and go to pem
000826  1               RFCBX
000826  1  A9 07                LDA     #<FCB           ;point
000828  1  A0 01                LDY     #>FCB           ;to fcb
00082A  1  4C 03 01             JMP     PEM             ;and go
00082D  1               ;point to int fcb and go to pem
00082D  1               WFCBX
00082D  1  A9 12                LDA     #<WFCB          ;point
00082F  1  A0 34                LDY     #>WFCB          ;to fcb
000831  1  4C 03 01             JMP     PEM             ;and go
000834  1               ;send cr and lf to console/list
000834  1               CRLF
000834  1  A9 0D                LDA     #CR             ;get
000836  1  20 4F 08             JSR     PRNCHR          ;a cr
000839  1  A9 0A                LDA     #LF             ;and
00083B  1  4C 4F 08             JMP     PRNCHR          ;then a lf
00083E  1               ;output char in A to console or list device as a function of LSTFLG
00083E  1               SPCOUT
00083E  1  A9 20                LDA     #SPACE          ;get space
000840  1               CHROUT
000840  1  2C 0C 34             BIT     LSTFLG          ;test flag
000843  1  30 05                BMI     *+7             ;use list if set
000845  1  A2 02                LDX     #2              ;else set
000847  1  4C 03 01             JMP     PEM             ;and do console
00084A  1  A2 05                LDX     #5              ;set list
00084C  1  4C 03 01             JMP     PEM             ;and do
00084F  1               ;print char in A and handle tabs and linefeeds
00084F  1               PRNCHR
00084F  1  C9 09                CMP     #TAB            ;see if tab
000851  1  D0 0C                BNE     NOTTAB          ;branch if not
000853  1               TABOVR
000853  1  20 3E 08             JSR     SPCOUT          ;send a space
000856  1  E6 6F                INC     COLUMN          ;bump column
000858  1  A5 6F                LDA     COLUMN          ;get it
00085A  1  29 07                AND     #7              ;see if mod 8
00085C  1  D0 F5                BNE     TABOVR          ;loop if not
00085E  1  60                   RTS                     ;else done
00085F  1               NOTTAB
00085F  1  48                   PHA                     ;save char
000860  1  20 40 08             JSR     CHROUT          ;send it
000863  1  E6 6F                INC     COLUMN          ;bump column
000865  1  68                   PLA                     ;get char
000866  1  C9 0A                CMP     #LF             ;if a lf
000868  1  F0 01                BEQ     *+3             ;then branch
00086A  1  60                   RTS                     ;else done
00086B  1  A9 00                LDA     #0              ;clear column
00086D  1  85 6F                STA     COLUMN          ;and then
00086F  1  60                   RTS                     ;done
000870  1               ;convert AY to decimal number and print on console
000870  1               PRNDEC
000870  1  85 93                STA     DECOUT          ;save
000872  1  84 94                STY     DECOUT+1        ;value
000874  1  A9 00                LDA     #FALSE          ;set flag
000876  1  85 95                STA     LZFLAG          ;to false
000878  1  A2 2F                LDX     #'0'-1          ;set digit to '0' - 1
00087A  1  38                   SEC                     ;now
00087B  1               P10000
00087B  1  A5 93                LDA     DECOUT          ;subtract
00087D  1  E9 10                SBC     #<10000         ;10000
00087F  1  85 93                STA     DECOUT          ;from
000881  1  A5 94                LDA     DECOUT+1        ;value
000883  1  E9 27                SBC     #>10000         ;and
000885  1  85 94                STA     DECOUT+1        ;save
000887  1  E8                   INX                     ;bump digit
000888  1  B0 F1                BCS     P10000          ;loop if no borrow
00088A  1  A5 93                LDA     DECOUT          ;else
00088C  1  69 10                ADC     #<10000         ;add
00088E  1  85 93                STA     DECOUT          ;10000
000890  1  A5 94                LDA     DECOUT+1        ;back
000892  1  69 27                ADC     #>10000         ;in to
000894  1  85 94                STA     DECOUT+1        ;correct
000896  1  20 E6 08             JSR     DIGOUT          ;send digit
000899  1               P1000
000899  1  A5 93                LDA     DECOUT          ;now
00089B  1  E9 E8                SBC     #<1000          ;drop
00089D  1  85 93                STA     DECOUT          ;by
00089F  1  A5 94                LDA     DECOUT+1        ;1000
0008A1  1  E9 03                SBC     #>1000          ;until
0008A3  1  85 94                STA     DECOUT+1        ;a borrow
0008A5  1  E8                   INX                     ;bump digit
0008A6  1  B0 F1                BCS     P1000           ;loop if more
0008A8  1  A5 93                LDA     DECOUT          ;now
0008AA  1  69 E8                ADC     #<1000          ;add
0008AC  1  85 93                STA     DECOUT          ;1000
0008AE  1  A5 94                LDA     DECOUT+1        ;back
0008B0  1  69 03                ADC     #>1000          ;in to
0008B2  1  85 94                STA     DECOUT+1        ;correct
0008B4  1  20 E6 08             JSR     DIGOUT          ;send 1000s
0008B7  1               P100
0008B7  1  A5 93                LDA     DECOUT          ;now
0008B9  1  E9 64                SBC     #100            ;do
0008BB  1  85 93                STA     DECOUT          ;subtract
0008BD  1  A5 94                LDA     DECOUT+1        ;for
0008BF  1  E9 00                SBC     #0              ;100
0008C1  1  85 94                STA     DECOUT+1        ;with
0008C3  1  E8                   INX                     ;digit bump
0008C4  1  B0 F1                BCS     P100            ;loop if more
0008C6  1  A5 93                LDA     DECOUT          ;else
0008C8  1  69 64                ADC     #100            ;add back
0008CA  1  85 93                STA     DECOUT          ;to correct
0008CC  1  20 E6 08             JSR     DIGOUT          ;send 100s
0008CF  1               P10
0008CF  1  A5 93                LDA     DECOUT          ;now
0008D1  1  E9 0A                SBC     #10             ;drop
0008D3  1  85 93                STA     DECOUT          ;by 10
0008D5  1  E8                   INX                     ;bump digit
0008D6  1  B0 F7                BCS     P10             ;loop if more
0008D8  1  69 0A                ADC     #10             ;correct
0008DA  1  85 93                STA     DECOUT          ;save
0008DC  1  20 E6 08             JSR     DIGOUT          ;and send 10s
0008DF  1  A9 30                LDA     #'0'            ;get zero
0008E1  1  05 93                ORA     DECOUT          ;add number
0008E3  1  4C 4F 08             JMP     PRNCHR          ;and print always
0008E6  1               ;send a single digit in X and handle leading zeros
0008E6  1               DIGOUT
0008E6  1  A9 20                LDA     #SPACE          ;preset for blank
0008E8  1  24 95                BIT     LZFLAG          ;test flag
0008EA  1  30 08                BMI     D2              ;branch if set
0008EC  1  E0 30                CPX     #'0'            ;else test current
0008EE  1  F0 05                BEQ     D3              ;branch if '0'
0008F0  1  A9 FF                LDA     #TRUE           ;else set
0008F2  1  85 95                STA     LZFLAG          ;flag
0008F4  1               D2
0008F4  1  8A                   TXA                     ;get char
0008F5  1               D3
0008F5  1  20 4F 08             JSR     PRNCHR          ;print it
0008F8  1  A2 2F                LDX     #'0'-1          ;now preset
0008FA  1  38                   SEC                     ;for next
0008FB  1  60                   RTS
0008FC  1               ;print message pointed to by AY until a $ is encountered
0008FC  1               PRNMSG
0008FC  1  8D 03 09             STA     PRN0+1          ;save message
0008FF  1  8C 04 09             STY     PRN0+2          ;address
000902  1               PRN0
000902  1  AD FF FF             LDA     $FFFF           ;get byte
000905  1  C9 24                CMP     #'$'            ;see if end
000907  1  D0 01                BNE     *+3             ;branch if not
000909  1  60                   RTS                     ;else done
00090A  1  20 4F 08             JSR     PRNCHR          ;print it
00090D  1  EE 03 09             INC     PRN0+1          ;bump low
000910  1  D0 F0                BNE     PRN0            ;loop if no carry
000912  1  EE 04 09             INC     PRN0+2          ;bump high
000915  1  4C 02 09             JMP     PRN0            ;and loop
000918  1               ;disk error exit
000918  1               DSKERR
000918  1  A9 AB                LDA     #<DEMSG         ;point to
00091A  1  A0 33                LDY     #>DEMSG         ;message
00091C  1               DSKER0
00091C  1  20 FC 08             JSR     PRNMSG          ;print it
00091F  1  4C 00 01             JMP     BOOT            ;and boot
000922  1               ;open source file
000922  1               OPNSRC
000922  1  A2 03                LDX     #3              ;first
000924  1               OPN1
000924  1  BD C1 33             LDA     BASSTR-1,X      ;move
000927  1  9D 0F 01             STA     FCB+8,X         ;BAS to
00092A  1  CA                   DEX                     ;type part
00092B  1  D0 F7                BNE     OPN1            ;of fcb
00092D  1  8E 13 01             STX     FCB+12          ;clear extent
000930  1  8E 14 01             STX     FCB+13
000933  1  8E 27 01             STX     FCB+32          ;and record
000936  1  A9 72                LDA     #<INPBUF        ;point to
000938  1  A0 36                LDY     #>INPBUF        ;buffer
00093A  1  A2 1A                LDX     #26             ;and set
00093C  1  20 03 01             JSR     PEM             ;as buffer location
00093F  1  A2 0F                LDX     #15             ;open code
000941  1  20 26 08             JSR     RFCBX           ;do it
000944  1  30 01                BMI     *+3             ;branch if bad
000946  1  60                   RTS                     ;else done
000947  1  A9 C5                LDA     #<NSMSG         ;point to
000949  1  A0 33                LDY     #>NSMSG         ;no source message
00094B  1  4C 1C 09             JMP     DSKER0          ;send and quit
00094E  1               ;close output (INT) file
00094E  1               CLSINT
00094E  1  A2 10                LDX     #16             ;close code
000950  1  20 2D 08             JSR     WFCBX           ;do it
000953  1  30 01                BMI     *+3             ;branch if bad
000955  1  60                   RTS                     ;else done
000956  1  4C 18 09             JMP     DSKERR          ;error exit
000959  1               ;set-up INT file
000959  1               SUPINT
000959  1  2C 0B 34             BIT     NINTFL          ;test no-int flag
00095C  1  10 01                BPL     *+3             ;branch if false
00095E  1  60                   RTS                     ;else done
00095F  1  A2 08                LDX     #8              ;move 9
000961  1               SUP0
000961  1  BD 07 01             LDA     FCB,X           ;char including drive
000964  1  9D 12 34             STA     WFCB,X          ;to write fcb
000967  1  CA                   DEX                     ;drop count
000968  1  10 F7                BPL     SUP0            ;loop if more
00096A  1  E8                   INX
00096B  1  8E 1E 34             STX     WFCB+12
00096E  1  8E 1F 34             STX     WFCB+13
000971  1  8E 32 34             STX     WFCB+32         ;clear extent and record
000974  1  A2 13                LDX     #19             ;now delete
000976  1  20 2D 08             JSR     WFCBX           ;it if there
000979  1  A2 16                LDX     #22             ;now try
00097B  1  20 2D 08             JSR     WFCBX           ;to create
00097E  1  10 03                BPL     *+5             ;branch if ok
000980  1  4C 18 09             JMP     DSKERR          ;else error
000983  1  60                   RTS                     ;and quit
000984  1               ;reset compiler flags
000984  1               SETFLG
000984  1  A9 00                LDA     #FALSE
000986  1  8D 11 34             STA     RNDFLE          ;random file
000989  1  8D 10 34             STA     FILEIO          ;file io
00098C  1  85 47                STA     INPSTM          ;input statement
00098E  1  8D 0F 34             STA     FORSTM          ;for statement
000991  1  85 48                STA     GSBSTM          ;gosub statement
000993  1  60                   RTS
000994  1               ;write INT record
000994  1               WRTINT
000994  1  2C 0B 34             BIT     NINTFL          ;test flag
000997  1  10 01                BPL     *+3             ;ok if false
000999  1  60                   RTS                     ;else done
00099A  1  A9 F2                LDA     #<OUTBUF        ;point to
00099C  1  A0 36                LDY     #>OUTBUF        ;buffer
00099E  1  A2 1A                LDX     #26             ;and set
0009A0  1  20 03 01             JSR     PEM             ;as dma
0009A3  1  A2 15                LDX     #21             ;now do
0009A5  1  20 2D 08             JSR     WFCBX           ;write op
0009A8  1  F0 03                BEQ     *+5             ;ok if zero
0009AA  1  4C 18 09             JMP     DSKERR          ;else error
0009AD  1  A9 72                LDA     #<INPBUF        ;point back
0009AF  1  A0 36                LDY     #>INPBUF        ;to input
0009B1  1  A2 1A                LDX     #26             ;and set
0009B3  1  4C 03 01             JMP     PEM             ;as default
0009B6  1               ;emit byte in A to INT file
0009B6  1               EMIT
0009B6  1  A6 72                LDX     OUTIND          ;get index
0009B8  1  10 09                BPL     EMIT0           ;ok if < 128
0009BA  1  48                   PHA                     ;else save
0009BB  1  20 94 09             JSR     WRTINT          ;write buffer
0009BE  1  68                   PLA                     ;get byte
0009BF  1  A2 00                LDX     #0              ;now clear
0009C1  1  86 72                STX     OUTIND          ;index
0009C3  1               EMIT0
0009C3  1  E6 72                INC     OUTIND          ;bump for next
0009C5  1  9D F2 36             STA     OUTBUF,X        ;save byte
0009C8  1  60                   RTS                     ;and done
0009C9  1               ;read source file record
0009C9  1               RDESRC
0009C9  1  A2 14                LDX     #20             ;get code
0009CB  1  20 26 08             JSR     RFCBX           ;do it
0009CE  1  C9 02                CMP     #2              ;see if ok
0009D0  1  90 03                BCC     *+5             ;branch if was
0009D2  1  4C 18 09             JMP     DSKERR          ;else error
0009D5  1  60                   RTS
0009D6  1               ;clear output line buffer
0009D6  1               CLLNBF
0009D6  1  A2 51                LDX     #CBUFSZ-1       ;get length - 1
0009D8  1  A9 20                LDA     #SPACE          ;use space
0009DA  1               CLLN0
0009DA  1  9D 72 37             STA     CONBUF,X        ;store
0009DD  1  CA                   DEX                     ;drop index
0009DE  1  E0 FF                CPX     #255            ;see if wrap
0009E0  1  D0 F8                BNE     CLLN0           ;loop if not
0009E2  1  60                   RTS
0009E3  1               ;list line of length LENGTH
0009E3  1               ;note that this routine also sets seprtr to : (just in case!!)
0009E3  1               LSTLNE
0009E3  1  A5 70                LDA     LINENO          ;get line
0009E5  1  A4 71                LDY     LINENO+1        ;number
0009E7  1  20 70 08             JSR     PRNDEC          ;print it
0009EA  1  A5 74                LDA     SEPRTR          ;then print
0009EC  1  20 4F 08             JSR     PRNCHR          ;separator
0009EF  1  A9 20                LDA     #SPACE          ;and a
0009F1  1  20 4F 08             JSR     PRNCHR          ;space
0009F4  1  A9 00                LDA     #0              ;now clear
0009F6  1  85 42                STA     GPIND           ;index
0009F8  1               LSTL0
0009F8  1  A6 42                LDX     GPIND           ;get index
0009FA  1  BD 72 37             LDA     CONBUF,X        ;get char
0009FD  1  20 4F 08             JSR     PRNCHR          ;print it
000A00  1  E6 42                INC     GPIND           ;bump index
000A02  1  A5 42                LDA     GPIND           ;get index
000A04  1  C5 73                CMP     LENGTH          ;compare to length
000A06  1  90 F0                BCC     LSTL0           ;loop if more
000A08  1  F0 EE                BEQ     LSTL0           ;or if same
000A0A  1  20 34 08             JSR     CRLF            ;do cr and lf
000A0D  1  20 D6 09             JSR     CLLNBF          ;clear buffer
000A10  1  A9 3A                LDA     #':'            ;and set
000A12  1  85 74                STA     SEPRTR          ;separator
000A14  1  60                   RTS
000A15  1               ;set global variable NXTCHR to next source file character and return with
000A15  1               ;NXTCHR in A. Replace TAB with SPACE and if LSTSRC is TRUE or an error
000A15  1               ;occurs send the line to the console.
000A15  1               GETCHR
000A15  1  20 70 0A             JSR     CHKFLE          ;go get char
000A18  1  D0 06                BNE     GETEOF          ;branch if eof
000A1A  1  A5 4D                LDA     NXTCHR          ;get nextchar
000A1C  1  C9 1A                CMP     #EOF            ;see if eof char
000A1E  1  D0 13                BNE     NTEOF           ;branch if not
000A20  1               GETEOF
000A20  1  A2 04                LDX     #4              ;move 5
000A22  1               GETE0
000A22  1  BD DB 33             LDA     ADDEND,X        ;from ADDEND
000A25  1  9D 72 36             STA     INPBUF,X        ;to input buffer
000A28  1  CA                   DEX                     ;drop count
000A29  1  10 F7                BPL     GETE0           ;loop if more
000A2B  1  E8                   INX                     ;clear X
000A2C  1  86 75                STX     SRCIND          ;and then index
000A2E  1  20 6A 0A             JSR     NXTSRC          ;get next
000A31  1  85 4D                STA     NXTCHR          ;save it
000A33  1               NTEOF
000A33  1  A6 76                LDX     LNEPTR          ;get pointer
000A35  1  E0 52                CPX     #CBUFSZ         ;compare to max
000A37  1  B0 08                BCS     LTOBIG          ;branch if too big
000A39  1  E8                   INX                     ;else bump
000A3A  1  86 76                STX     LNEPTR          ;and save
000A3C  1  A5 4D                LDA     NXTCHR          ;get char
000A3E  1  9D 72 37             STA     CONBUF,X        ;and save
000A41  1               LTOBIG
000A41  1  A5 4D                LDA     NXTCHR          ;get char
000A43  1  C9 0D                CMP     #CR             ;see if a cr
000A45  1  D0 19                BNE     NTEOL           ;branch if not
000A47  1  E6 70                INC     LINENO          ;else bump
000A49  1  D0 02                BNE     *+4             ;line
000A4B  1  E6 71                INC     LINENO+1        ;number
000A4D  1  A6 76                LDX     LNEPTR          ;get pointer
000A4F  1  CA                   DEX                     ;drop it
000A50  1  86 73                STX     LENGTH          ;put in length
000A52  1  AD 08 34             LDA     LSTSRC          ;get flag
000A55  1  F0 03                BEQ     NOLSLN          ;branch if not true
000A57  1  20 E3 09             JSR     LSTLNE          ;list it
000A5A  1               NOLSLN
000A5A  1  A9 00                LDA     #0              ;then clear
000A5C  1  85 76                STA     LNEPTR          ;pointer
000A5E  1  A5 4D                LDA     NXTCHR          ;get char
000A60  1               NTEOL
000A60  1  C9 09                CMP     #TAB            ;see it tab
000A62  1  F0 01                BEQ     *+3             ;branch if is
000A64  1  60                   RTS
000A65  1  A9 20                LDA     #SPACE          ;else get space
000A67  1  85 4D                STA     NXTCHR          ;set
000A69  1  60                   RTS                     ;and done
000A6A  1               ;get byte from source file
000A6A  1               NXTSRC
000A6A  1  A6 75                LDX     SRCIND          ;get index
000A6C  1  BD 72 36             LDA     INPBUF,X        ;then byte
000A6F  1  60                   RTS
000A70  1               ;maintain source buffer full and check for eof. if eof is detected then
000A70  1               ;A:=TRUE else A:=FALSE
000A70  1               CHKFLE
000A70  1  E6 75                INC     SRCIND          ;bump index
000A72  1  10 0E                BPL     CHKFL0          ;branch if ok
000A74  1  A9 00                LDA     #0              ;else clear
000A76  1  85 75                STA     SRCIND          ;index
000A78  1  20 C9 09             JSR     RDESRC          ;read record
000A7B  1  C9 01                CMP     #1              ;see if eof
000A7D  1  D0 03                BNE     CHKFL0          ;branch if not
000A7F  1  A9 FF                LDA     #TRUE           ;else set
000A81  1  60                   RTS                     ;eof=true
000A82  1               CHKFL0
000A82  1  20 6A 0A             JSR     NXTSRC          ;get next
000A85  1  85 4D                STA     NXTCHR          ;save it
000A87  1  C9 0A                CMP     #LF             ;if a lf
000A89  1  F0 E5                BEQ     CHKFLE          ;loop for more
000A8B  1  A9 00                LDA     #FALSE          ;else say
000A8D  1  60                   RTS                     ;wasn't eof
000A8E  1               ;get non-blank from source. will also skip past eof to reach physical eof.
000A8E  1               GTNBLK
000A8E  1  20 15 0A             JSR     GETCHR          ;get new char
000A91  1  C9 20                CMP     #SPACE          ;if a space
000A93  1  F0 F9                BEQ     GTNBLK          ;try again
000A95  1  C9 1A                CMP     #EOF            ;if an eof
000A97  1  F0 F5                BEQ     GTNBLK          ;try again
000A99  1  60                   RTS
000A9A  1               ;check for continuation character. if it is will get first char from next line.
000A9A  1               CHKCNT
000A9A  1  A5 4D                LDA     NXTCHR          ;get next
000A9C  1  C9 5C                CMP     #backsl         ;see if continue
000A9E  1  F0 01                BEQ     *+3             ;branch if is
000AA0  1  60                   RTS
000AA1  1               CHKCN0
000AA1  1  20 15 0A             JSR     GETCHR          ;get next
000AA4  1  C9 0D                CMP     #CR             ;see if eol
000AA6  1  D0 F9                BNE     CHKCN0          ;loop if isn't
000AA8  1  4C 8E 0A             JMP     GTNBLK          ;now get first non-blank
000AAB  1               ;compiler error handler
000AAB  1               ;at entry a contains error number
000AAB  1               ERROR
000AAB  1  85 78                STA     ERRCDE          ;save
000AAD  1  A5 76                LDA     LNEPTR          ;get index
000AAF  1  85 77                STA     POINTR          ;move to pointer
000AB1  1  E6 77                INC     POINTR          ;and bump
000AB3  1  E6 77                INC     POINTR          ;by two
000AB5  1  A5 49                LDA     TOKEN           ;get token
000AB7  1  C9 17                CMP     #TCR            ;see if for eol
000AB9  1  F0 0F                BEQ     ERROR3          ;branch if is
000ABB  1  A5 4D                LDA     NXTCHR          ;else get next
000ABD  1               ERROR1
000ABD  1  C9 0D                CMP     #CR             ;if a cr
000ABF  1  F0 09                BEQ     ERROR3          ;then done
000AC1  1  20 9A 0A             JSR     CHKCNT          ;else see if continue
000AC4  1  20 15 0A             JSR     GETCHR          ;get another char
000AC7  1  4C BD 0A             JMP     ERROR1          ;and loop
000ACA  1               ERROR3
000ACA  1  2C 06 34             BIT     PASS2           ;test pass 2 flag
000ACD  1  10 43                BPL     ERROR6          ;branch if clear
000ACF  1  2C 08 34             BIT     LSTSRC          ;see if source already listed
000AD2  1  30 03                BMI     *+5             ;skip list if was
000AD4  1  20 E3 09             JSR     LSTLNE          ;else list
000AD7  1  E6 43                INC     ERRCNT          ;bump
000AD9  1  D0 02                BNE     *+4             ;error
000ADB  1  E6 44                INC     ERRCNT+1        ;count
000ADD  1  A9 3F                LDA     #'?'            ;print a ?
000ADF  1  20 4F 08             JSR     PRNCHR
000AE2  1  A9 2D                LDA     #'-'
000AE4  1  20 4F 08             JSR     PRNCHR          ;print two -
000AE7  1  A9 2D                LDA     #'-'
000AE9  1  20 4F 08             JSR     PRNCHR
000AEC  1               ERROR4
000AEC  1  C6 77                DEC     POINTR          ;drop pointer
000AEE  1  F0 0A                BEQ     ERROR5          ;done if zero
000AF0  1  30 08                BMI     ERROR5          ;or <0
000AF2  1  A9 2D                LDA     #'-'            ;else get -
000AF4  1  20 4F 08             JSR     PRNCHR          ;print it
000AF7  1  4C EC 0A             JMP     ERROR4          ;and loop
000AFA  1               ERROR5
000AFA  1  A9 5E                LDA     #'^'            ;get up arrow
000AFC  1  20 4F 08             JSR     PRNCHR          ;print it
000AFF  1  20 34 08             JSR     CRLF            ;then a cr and lf
000B02  1  A5 78                LDA     ERRCDE          ;get error code
000B04  1  0A                   ASL     A               ;mult by two
000B05  1  AA                   TAX
000B06  1  BD 62 33             LDA     ERMTBL,X
000B09  1  BC 63 33             LDY     ERMTBL+1,X      ;get message address
000B0C  1  20 FC 08             JSR     PRNMSG          ;print it
000B0F  1  20 34 08             JSR     CRLF
000B12  1               ERROR6
000B12  1  A9 00                LDA     #FALSE          ;now clear
000B14  1  8D 0E 34             STA     CMPLNG          ;compiling flag
000B17  1  4C 84 09             JMP     SETFLG          ;and then other flags
000B1A  1               ;initialize scanner by setting NXTCHR to the first non-blank character from the
000B1A  1               ;input file and by setting the line number and pointer
000B1A  1               INSCAN
000B1A  1  2C 05 34             BIT     PASS1           ;test for pass 1
000B1D  1  10 0B                BPL     NOGTPR          ;branch if not
000B1F  1  A2 08                LDX     #8              ;move 8 parms
000B21  1               INSCA0
000B21  1  BD 17 01             LDA     FCB+16,X        ;from fcb
000B24  1  9D 32 34             STA     PRMLST-1,X      ;to save area
000B27  1  CA                   DEX                     ;drop count
000B28  1  D0 F7                BNE     INSCA0          ;loop if more
000B2A  1               NOGTPR
000B2A  1  20 22 09             JSR     OPNSRC          ;open file
000B2D  1  A9 00                LDA     #0              ;now
000B2F  1  85 6E                STA     CONT            ;clear
000B31  1  85 6F                STA     COLUMN          ;variables
000B33  1  85 70                STA     LINENO          ;for start
000B35  1  85 71                STA     LINENO+1        ;of a
000B37  1  85 76                STA     LNEPTR          ;pass
000B39  1  20 D6 09             JSR     CLLNBF          ;clear output buffer
000B3C  1  A9 80                LDA     #SRCRSZ         ;now set source
000B3E  1  85 75                STA     SRCIND          ;index to invalid
000B40  1  A9 3A                LDA     #':'            ;set separator
000B42  1  85 74                STA     SEPRTR          ;to a colon
000B44  1  AD 33 34             LDA     PRMLST          ;get first parm
000B47  1  C9 24                CMP     #'$'            ;see if start
000B49  1  D0 44                BNE     INSDNE          ;not so exit
000B4B  1  A2 01                LDX     #1              ;set index to first
000B4D  1               INSCAP
000B4D  1  BD 33 34             LDA     PRMLST,X        ;get parm
000B50  1  E8                   INX                     ;bump index
000B51  1  C9 20                CMP     #SPACE          ;if not a space
000B53  1  F0 3A                BEQ     INSDNE          ;done if space
000B55  1  A0 FF                LDY     #TRUE           ;set true
000B57  1  C9 41                CMP     #'A'            ;if not A
000B59  1  D0 05                BNE     PNOTA           ;try next
000B5B  1  8C 07 34             STY     LSTPRD          ;else set
000B5E  1  F0 ED                BEQ     INSCAP          ;and loop
000B60  1               PNOTA
000B60  1  C9 43                CMP     #'C'            ;if not C
000B62  1  D0 05                BNE     PNOTC           ;try next
000B64  1  8C 0B 34             STY     NINTFL          ;else set
000B67  1  F0 E4                BEQ     INSCAP          ;and loop
000B69  1               PNOTC
000B69  1  C9 45                CMP     #'E'            ;see if E
000B6B  1  D0 05                BNE     PNOTE           ;branch if not
000B6D  1  8C 09 34             STY     DEBUGL          ;else set
000B70  1  F0 DB                BEQ     INSCAP          ;and loop
000B72  1               PNOTE
000B72  1  C9 46                CMP     #'F'            ;see if F
000B74  1  D0 05                BNE     PNOTF           ;branch if not
000B76  1  8C 0C 34             STY     LSTFLG          ;else set
000B79  1  F0 D2                BEQ     INSCAP          ;and loop
000B7B  1               PNOTF
000B7B  1  A0 00                LDY     #FALSE          ;now use false
000B7D  1  C9 42                CMP     #'B'            ;if not B
000B7F  1  D0 05                BNE     PNOTB           ;try next
000B81  1  8C 08 34             STY     LSTSRC          ;else set
000B84  1  F0 C7                BEQ     INSCAP          ;and loop
000B86  1               PNOTB
000B86  1  C9 44                CMP     #'D'            ;if not D
000B88  1  D0 C3                BNE     INSCAP          ;then not valid
000B8A  1  8C 0A 34             STY     LWRUPR          ;else set
000B8D  1  F0 BE                BEQ     INSCAP          ;and loop
000B8F  1               ;done with INSCAN so get first non-blank
000B8F  1               INSDNE
000B8F  1  A9 00                LDA     #0              ;clear eol flag
000B91  1  8D 0D 34             STA     EOLSTS
000B94  1  4C 8E 0A             JMP     GTNBLK
000B97  1               ;put NXTCHR in ACCUM
000B97  1               PUTACC
000B97  1  24 6E                BIT     CONT            ;test for continue
000B99  1  10 01                BPL     *+3             ;do if not
000B9B  1  60                   RTS                     ;else done
000B9C  1  E6 4E                INC     ACCLEN          ;bump length
000B9E  1  A6 4E                LDX     ACCLEN          ;get it as index
000BA0  1  A5 4D                LDA     NXTCHR          ;get next
000BA2  1  95 4E                STA     ACCUM,X         ;store it
000BA4  1  18                   CLC                     ;clear carry
000BA5  1  65 4C                ADC     HSHCDE          ;add hashcde
000BA7  1  29 3F                AND     #HSHMSK         ;mask it
000BA9  1  85 4C                STA     HSHCDE          ;and save
000BAB  1  E0 1F                CPX     #IDNTSZ-1       ;compare to max
000BAD  1  B0 01                BCS     *+3             ;branch if too big
000BAF  1  60                   RTS                     ;else done
000BB0  1  A9 FF                LDA     #TRUE           ;set CONT
000BB2  1  85 6E                STA     CONT            ;flag
000BB4  1  60                   RTS
000BB5  1               ;put NXTCHR in ACCUM and get another non-blank
000BB5  1               PUTGET
000BB5  1  20 97 0B             JSR     PUTACC          ;put
000BB8  1  4C 8E 0A             JMP     GTNBLK          ;and get
000BBB  1               ;put NXTCHR in ACCUM and get another char
000BBB  1               PUTCHR
000BBB  1  20 97 0B             JSR     PUTACC          ;put
000BBE  1  4C 15 0A             JMP     GETCHR          ;and get
000BC1  1               ;test for numeric NXTCHR. return with A:=TRUE iff NXTCHR in '0' to '9'
000BC1  1               NUMRIC
000BC1  1  A5 4D                LDA     NXTCHR          ;get char
000BC3  1  C9 30                CMP     #'0'            ;see if less than 0
000BC5  1  90 07                BCC     NOTNUM          ;branch if is
000BC7  1  C9 3A                CMP     #'9'+1          ;see if over 9
000BC9  1  B0 03                BCS     NOTNUM          ;branch if is
000BCB  1  A9 FF                LDA     #TRUE           ;else set
000BCD  1  60                   RTS                     ;for numeric
000BCE  1               NOTNUM
000BCE  1  A9 00                LDA     #FALSE          ;set false
000BD0  1  60                   RTS
000BD1  1               ;test for lower case NXTCHR. return with A:=TRUE iff NXTCHR in 'a' to 'z'
000BD1  1               LWRCSE
000BD1  1  A5 4D                LDA     NXTCHR          ;get chat
000BD3  1  C9 61                CMP     #'a'            ;see if < a
000BD5  1  90 07                BCC     NOTLWR          ;branch if is
000BD7  1  C9 7B                CMP     #'z'+1          ;see if > z
000BD9  1  B0 03                BCS     NOTLWR          ;branch if is
000BDB  1  A9 FF                LDA     #TRUE           ;else
000BDD  1  60                   RTS                     ;is lower
000BDE  1               NOTLWR
000BDE  1  A9 00                LDA     #FALSE          ;not lower
000BE0  1  60                   RTS
000BE1  1               ;test for NXTCHR a decimal point
000BE1  1               DCMLPT
000BE1  1  A5 4D                LDA     NXTCHR          ;get char
000BE3  1  C9 2E                CMP     #'.'            ;test it
000BE5  1  D0 03                BNE     NTDCML          ;branch if not
000BE7  1  A9 FF                LDA     #TRUE           ;set for true
000BE9  1  60                   RTS
000BEA  1               NTDCML
000BEA  1  A9 00                LDA     #FALSE          ;false
000BEC  1  60                   RTS
000BED  1               ;convert lowercase to uppercase
000BED  1               CNVLWR
000BED  1  20 D1 0B             JSR     LWRCSE          ;see if lower
000BF0  1  2D 0A 34             AND     LWRUPR          ;and with flag
000BF3  1  D0 01                BNE     *+3             ;ok if both true
000BF5  1  60                   RTS                     ;else done
000BF6  1  A5 4D                LDA     NXTCHR          ;get char
000BF8  1  29 5F                AND     #$5F            ;convert
000BFA  1  85 4D                STA     NXTCHR          ;and save
000BFC  1  60                   RTS
000BFD  1               ;test for letter. set A:=TRUE if lowercase or uppercase letter
000BFD  1               LETTER
000BFD  1  20 ED 0B             JSR     CNVLWR          ;covert if all set
000C00  1  20 D1 0B             JSR     LWRCSE          ;see if still lowercase
000C03  1  F0 01                BEQ     *+3             ;branch if not
000C05  1  60                   RTS                     ;else is TRUE
000C06  1  A5 4D                LDA     NXTCHR          ;get char
000C08  1  C9 41                CMP     #'A'            ;if < A
000C0A  1  90 07                BCC     NOTLTR          ;is not letter
000C0C  1  C9 5B                CMP     #'Z'+1          ;if > Z
000C0E  1  B0 03                BCS     NOTLTR          ;is not letter
000C10  1  A9 FF                LDA     #TRUE           ;else is
000C12  1  60                   RTS
000C13  1               NOTLTR
000C13  1  A9 00                LDA     #FALSE          ;not letter
000C15  1  60                   RTS
000C16  1               ;test for letter, number or decimal point. return A:=TRUE if either
000C16  1               ALPNUM
000C16  1  20 FD 0B             JSR     LETTER          ;first try letter
000C19  1  F0 01                BEQ     *+3             ;branch if not
000C1B  1  60                   RTS
000C1C  1  20 C1 0B             JSR     NUMRIC          ;now try number
000C1F  1  F0 01                BEQ     *+3             ;branch if not
000C21  1  60                   RTS
000C22  1  4C E1 0B             JMP     DCMLPT          ;finally try decimal point
000C25  1               ;spool numeric data into ACCUM
000C25  1               SPLNUM
000C25  1  20 C1 0B             JSR     NUMRIC          ;see if number
000C28  1  D0 01                BNE     *+3             ;branch if is
000C2A  1  60                   RTS                     ;else done
000C2B  1  20 BB 0B             JSR     PUTCHR          ;stuff it
000C2E  1  4C 25 0C             JMP     SPLNUM          ;and loop
000C31  1               ;set up next call
000C31  1               SUPNCL
000C31  1  A5 4D                LDA     NXTCHR          ;get next
000C33  1  C9 20                CMP     #SPACE          ;see if blank
000C35  1  D0 03                BNE     *+5             ;branch if not
000C37  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000C3A  1  A9 00                LDA     #FALSE          ;set continue
000C3C  1  85 6E                STA     CONT            ;to false
000C3E  1  60                   RTS
000C3F  1               ;procedure called by SYNTHE to reduce the amount of indexing
000C3F  1               SCOPY
000C3F  1  A6 7B                LDX     SP              ;get stack pointer
000C41  1  BD FF 34             LDA     TYPE,X          ;do
000C44  1  85 80                STA     TYPESP          ;byte
000C46  1  BD 1F 35             LDA     STYPE,X         ;values
000C49  1  85 83                STA     STYPSP          ;first
000C4B  1  BD BF 34             LDA     HASH,X
000C4E  1  85 8C                STA     HASHSP
000C50  1  8A                   TXA                     ;now
000C51  1  0A                   ASL     A               ;make a
000C52  1  AA                   TAX                     ;word index
000C53  1  BD 7F 35             LDA     SYMLOC,X
000C56  1  BC 80 35             LDY     SYMLOC+1,X
000C59  1  85 86                STA     SYMLSP
000C5B  1  84 87                STY     SYMLSP+1
000C5D  1  BD 3F 35             LDA     SRLOC,X
000C60  1  BC 40 35             LDY     SRLOC+1,X
000C63  1  85 8F                STA     SRLOSP
000C65  1  84 90                STY     SRLOSP+1
000C67  1  A6 7C                LDX     MP              ;now get MP
000C69  1  BD FF 34             LDA     TYPE,X
000C6C  1  85 82                STA     TYPEMP
000C6E  1  BD 1F 35             LDA     STYPE,X
000C71  1  85 85                STA     STYPMP
000C73  1  BD BF 34             LDA     HASH,X
000C76  1  85 8E                STA     HASHMP
000C78  1  8A                   TXA                     ;now
000C79  1  0A                   ASL     A               ;make a
000C7A  1  AA                   TAX                     ;word index
000C7B  1  BD 7F 35             LDA     SYMLOC,X
000C7E  1  BC 80 35             LDY     SYMLOC+1,X
000C81  1  85 8A                STA     SYMLMP
000C83  1  84 8B                STY     SYMLMP+1
000C85  1  BD 3F 35             LDA     SRLOC,X
000C88  1  BC 40 35             LDY     SRLOC+1,X
000C8B  1  85 91                STA     SRLOMP
000C8D  1  84 92                STY     SRLOMP+1
000C8F  1  A6 7D                LDX     MPP1            ;now get MP+1
000C91  1  BD FF 34             LDA     TYPE,X
000C94  1  85 81                STA     TYPEM1
000C96  1  BD 1F 35             LDA     STYPE,X
000C99  1  85 84                STA     STYPM1
000C9B  1  BD BF 34             LDA     HASH,X
000C9E  1  85 8D                STA     HASHM1
000CA0  1  8A                   TXA                     ;now
000CA1  1  0A                   ASL     A               ;make a
000CA2  1  AA                   TAX                     ;word index
000CA3  1  BD 7F 35             LDA     SYMLOC,X
000CA6  1  BC 80 35             LDY     SYMLOC+1,X
000CA9  1  85 88                STA     SYMLM1
000CAB  1  84 89                STY     SYMLM1+1
000CAD  1  60                   RTS
000CAE  1               ;called by SYNTHE to set SYMLOC(SP) to AY
000CAE  1               STSLSP
000CAE  1  48                   PHA                     ;save A part
000CAF  1  A5 7B                LDA     SP              ;get SP
000CB1  1               STSL
000CB1  1  0A                   ASL     A               ;mult by two
000CB2  1  AA                   TAX                     ;make index
000CB3  1  68                   PLA                     ;get byte
000CB4  1  9D 7F 35             STA     SYMLOC,X        ;save it
000CB7  1  98                   TYA                     ;get high
000CB8  1  9D 80 35             STA     SYMLOC+1,X      ;save it
000CBB  1  60                   RTS
000CBC  1               ;called by SYNTHE to set SYMLOC(MP) to AY
000CBC  1               STSLMP
000CBC  1  48                   PHA                     ;save low
000CBD  1  A5 7C                LDA     MP              ;get MP
000CBF  1  4C B1 0C             JMP     STSL            ;go do
000CC2  1               ;called by SYNTHE to set TYPE(SP) to A
000CC2  1               STTYSP
000CC2  1  A6 7B                LDX     SP              ;get SP
000CC4  1  9D FF 34             STA     TYPE,X          ;save
000CC7  1  60                   RTS
000CC8  1               ;called by SYNTHE to set STYPE(SP) to A
000CC8  1               STSTSP
000CC8  1  A6 7B                LDX     SP              ;get SP
000CCA  1  9D 1F 35             STA     STYPE,X         ;save
000CCD  1  60                   RTS
000CCE  1               ;set STYPE(MP) to A
000CCE  1               STSTMP
000CCE  1  A6 7C                LDX     MP              ;get MP
000CD0  1  9D 1F 35             STA     STYPE,X         ;save
000CD3  1  60                   RTS
000CD4  1               ;set TYPE(MP) to A
000CD4  1               STTYMP
000CD4  1  A6 7C                LDX     MP              ;get MP
000CD6  1  9D FF 34             STA     TYPE,X          ;save
000CD9  1  60                   RTS
000CDA  1               ;set HASH(MP) to A
000CDA  1               STHAMP
000CDA  1  A6 7C                LDX     MP              ;get MP
000CDC  1  9D BF 34             STA     HASH,X          ;insert
000CDF  1  60                   RTS
000CE0  1               ;set HASH(SP) to A
000CE0  1               STHASP
000CE0  1  A6 7B                LDX     SP              ;get SP
000CE2  1  9D BF 34             STA     HASH,X          ;insert
000CE5  1  60                   RTS
000CE6  1               ;set SRLOC(SP) to AY
000CE6  1               STSRSP
000CE6  1  48                   PHA                     ;save low
000CE7  1  A5 7B                LDA     SP              ;get SP
000CE9  1  0A                   ASL     A               ;mult by two
000CEA  1  AA                   TAX                     ;make index
000CEB  1  68                   PLA                     ;get low
000CEC  1  9D 3F 35             STA     SRLOC,X         ;save ir
000CEF  1  98                   TYA                     ;get high
000CF0  1  9D 40 35             STA     SRLOC+1,X       ;save it
000CF3  1  60                   RTS
000CF4  1               ;write generated code in A and count size of code area
000CF4  1               GENERT
000CF4  1  E6 B2                INC     CODESI          ;bump
000CF6  1  D0 02                BNE     *+4             ;code
000CF8  1  E6 B3                INC     CODESI+1        ;size
000CFA  1  2C 05 34             BIT     PASS1           ;test for pass 1
000CFD  1  30 03                BMI     *+5             ;branch if
000CFF  1  4C B6 09             JMP     EMIT            ;else go emit
000D02  1  60                   RTS
000D03  1               ;write data in A during pass 2 and count size of data area
000D03  1               EMITDT
000D03  1  E6 45                INC     DATACT          ;bump
000D05  1  D0 02                BNE     *+4             ;data
000D07  1  E6 46                INC     DATACT+1        ;size
000D09  1  2C 06 34             BIT     PASS2           ;test for pass 2
000D0C  1  10 03                BPL     *+5             ;branch if not
000D0E  1  4C B6 09             JMP     EMIT            ;else go emit
000D11  1  60                   RTS
000D12  1               ;compare ACCUM to reserved word string
000D12  1               COMPAR
000D12  1  A9 00                LDA     #0
000D14  1  85 A1                STA     IC
000D16  1               COMPA0
000D16  1  A4 A1                LDY     IC
000D18  1  8B DA A2 01          LDAINDIRECTY PTR        ;a=field(i)
000D1C  1  B5 A2 C9 00  
000D20  1  D0 04 A2 00  
000D2E  1  E6 A1                INC     IC
000D30  1  A4 A1                LDY     IC              ;i=i+1
000D32  1                       .IFDEF DUODYNE
000D32  1  DA                   PHX
000D33  1  BB                   TYX
000D34  1  D5 4E                CMP     ACCUM,X         ;compare field(i) to accum(i=i+1)
000D36  1  FA                   PLX
000D37  1                       .ELSE
000D37  1                       CMP     ACCUM,Y         ;compare field(i) to accum(i=i+1)
000D37  1                       .ENDIF
000D37  1  D0 09                BNE     COMPAX          ;exit if different
000D39  1  A5 4E                LDA     ACCLEN
000D3B  1  C5 A1                CMP     IC              ;if i<=acclen
000D3D  1  B0 D7                BCS     COMPA0          ;then loop
000D3F  1               COMPAT
000D3F  1  A9 FF                LDA     #TRUE           ;was a match
000D41  1  60                   RTS
000D42  1               COMPAX
000D42  1  A5 4E                LDA     ACCLEN          ;check termination condition
000D44  1  C5 A1                CMP     IC
000D46  1  90 F7                BCC     COMPAT          ;if i>acclen is true
000D48  1  A9 00                LDA     #FALSE
000D4A  1  60                   RTS
000D4B  1               ;attempt to match reserved word
000D4B  1               LOOKUP
000D4B  1  A9 09                LDA     #MAXRWL         ;compare max word length
000D4D  1  C5 4E                CMP     ACCLEN          ;to length
000D4F  1  90 5A                BCC     LOOKFL          ;exit as false if too big
000D51  1  A6 4E                LDX     ACCLEN          ;get length
000D53  1  BD F6 2F             LDA     OFFSET,X        ;and offset
000D56  1  18                   CLC                     ;in reserved word table
000D57  1  69 B5                ADC     #<LNG1          ;now add to
000D59  1  85 A2                STA     PTR             ;start to
000D5B  1  A9 00                LDA     #0              ;get
000D5D  1  69 2E                ADC     #>LNG1          ;indirect
000D5F  1  85 A3                STA     PTR+1           ;pointer
000D61  1  A9 00                LDA     #0              ;set index
000D63  1  85 A4                STA     IL              ;to zero
000D65  1               LOOKU0
000D65  1  E6 A4                INC     IL              ;bump index
000D67  1  A6 4E                LDX     ACCLEN          ;see if count
000D69  1  BD 00 30             LDA     COUNT,X         ;bigger than
000D6C  1  C5 A4                CMP     IL              ;number words
000D6E  1  90 3B                BCC     LOOKFL          ;no match if is
000D70  1  20 12 0D             JSR     COMPAR          ;try to match
000D73  1  D0 0E                BNE     LOOKMT          ;branch if did
000D75  1  18                   CLC                     ;else
000D76  1  A5 A2                LDA     PTR             ;bump
000D78  1  65 4E                ADC     ACCLEN          ;pointer
000D7A  1  85 A2                STA     PTR             ;by length
000D7C  1  90 E7                BCC     LOOKU0          ;of word
000D7E  1  E6 A3                INC     PTR+1           ;and try
000D80  1  4C 65 0D             JMP     LOOKU0          ;next
000D83  1               LOOKMT
000D83  1  A6 4E                LDX     ACCLEN          ;get length
000D85  1  BD 0A 30             LDA     TKOS,X          ;and token offset
000D88  1  18                   CLC                     ;add to
000D89  1  65 A4                ADC     IL              ;index
000D8B  1  AA                   TAX                     ;make an index
000D8C  1  BD A6 2F             LDA     TK,X            ;get token
000D8F  1  85 49                STA     TOKEN           ;and save
000D91  1  C9 41                CMP     #64+1           ;see if over 64
000D93  1  90 13                BCC     LOOKTR          ;branch if not
000D95  1  C9 63                CMP     #TDATA          ;see if TDATA
000D97  1  F0 0F                BEQ     LOOKTR          ;branch if is
000D99  1  85 4B                STA     FUNCOP          ;else save as FUNCOP
000D9B  1  38                   SEC                     ;now subtract
000D9C  1  E9 41                SBC     #65             ;65 to
000D9E  1  AA                   TAX                     ;make index
000D9F  1  BD 14 30             LDA     ST,X            ;get subtype
000DA2  1  85 4A                STA     SUBTYP          ;and save
000DA4  1  A9 35                LDA     #FUNCT
000DA6  1  85 49                STA     TOKEN           ;token=funct
000DA8  1               LOOKTR
000DA8  1  A9 FF                LDA     #TRUE           ;match
000DAA  1  60                   RTS
000DAB  1               LOOKFL
000DAB  1  A9 00                LDA     #FALSE          ;no match
000DAD  1  60                   RTS
000DAE  1               ;scanner accepts input characters from the source file returning tokens to the
000DAE  1               ;parser.  conversion to uppercase is performed if LWRUPR is set.  each token is
000DAE  1               ;placed in ACCUM and ACCLEN is the length of the token.  the token is hashed by
000DAE  1               ;summing each ASCII character modulo HSHTSZ (hashtablesize) and is stored in
000DAE  1               ;HSHCDE (hashcode).  SUBTYP and FUNCOP are set if the token is a predefined
000DAE  1               ;function.  REM and DATA statements are handled completely by the scanner. REM
000DAE  1               ;and REMARK statements cause the input to be scanned until the end of the
000DAE  1               ;current input line is located.  the cr is then scanned and returned.  DATA
000DAE  1               ;statements are similar except data is output using EMITDT.
000DAE  1               SCANNR
000DAE  1  A9 00                LDA     #0              ;clear
000DB0  1  85 4E                STA     ACCLEN          ;these
000DB2  1  85 4C                STA     HSHCDE          ;variables
000DB4  1  85 49                STA     TOKEN           ;at
000DB6  1  85 4A                STA     SUBTYP          ;start
000DB8  1  24 6E                BIT     CONT            ;test continue flag
000DBA  1  30 13                BMI     SCAN1           ;branch if set
000DBC  1  2C 0D 34             BIT     EOLSTS          ;test eol status
000DBF  1  10 08                BPL     SCAN28          ;skip if char ready
000DC1  1  20 8E 0A             JSR     GTNBLK          ;else go read
000DC4  1  A9 00                LDA     #0              ;then clear flag
000DC6  1  8D 0D 34             STA     EOLSTS
000DC9  1               SCAN28
000DC9  1  A5 4D                LDA     NXTCHR          ;else get next
000DCB  1  C9 22                CMP     #'"'            ;see if "
000DCD  1  D0 2E                BNE     SCAN5           ;branch if not
000DCF  1               ;first case is string or string continuation
000DCF  1               SCAN1
000DCF  1  A9 32                LDA     #STRING         ;get token
000DD1  1  85 49                STA     TOKEN           ;and set
000DD3  1  A9 00                LDA     #FALSE          ;and set
000DD5  1  85 6E                STA     CONT            ;CONT as false
000DD7  1               SCAN2
000DD7  1  20 15 0A             JSR     GETCHR          ;get char
000DDA  1  C9 22                CMP     #'"'            ;see if delimiter
000DDC  1  F0 11                BEQ     SCAN4           ;branch if is
000DDE  1  C9 0D                CMP     #CR             ;see if eol
000DE0  1  D0 05                BNE     SCAN3           ;branch if not
000DE2  1  A9 16                LDA     #22             ;else is unterminated string
000DE4  1  4C AB 0A             JMP     ERROR           ;do error and quit
000DE7  1               SCAN3
000DE7  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000DEA  1  24 6E                BIT     CONT            ;test for continue
000DEC  1  10 E9                BPL     SCAN2           ;loop if not
000DEE  1  60                   RTS                     ;else done
000DEF  1               SCAN4
000DEF  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000DF2  1  C9 22                CMP     #'"'            ;see if another delimiter
000DF4  1  F0 01                BEQ     *+3             ;branch if is
000DF6  1  60                   RTS                     ;else done
000DF7  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000DFA  1  4C D7 0D             JMP     SCAN2           ;and loop
000DFD  1               SCAN5
000DFD  1  20 C1 0B             JSR     NUMRIC          ;see if number
000E00  1  D0 05                BNE     SCAN6           ;branch if is
000E02  1  20 E1 0B             JSR     DCMLPT          ;see if decimal point
000E05  1  F0 51                BEQ     SCAN15          ;branch if not
000E07  1               ;is a numeric of up to IDNTSZ-1 characters
000E07  1               SCAN6
000E07  1  A9 31                LDA     #FLOTPT         ;get token
000E09  1  85 49                STA     TOKEN           ;and set
000E0B  1  A5 4D                LDA     NXTCHR          ;get next char
000E0D  1               SCAN7
000E0D  1  C9 30                CMP     #'0'            ;see if leading zero
000E0F  1  D0 06                BNE     SCAN8           ;branch if not
000E11  1  20 15 0A             JSR     GETCHR          ;else get next
000E14  1  4C 0D 0E             JMP     SCAN7           ;and loop to flush
000E17  1               SCAN8
000E17  1  20 25 0C             JSR     SPLNUM          ;spool numeric
000E1A  1  20 E1 0B             JSR     DCMLPT          ;test for decimal point
000E1D  1  F0 06                BEQ     SCAN9           ;branch if not
000E1F  1  20 BB 0B             JSR     PUTCHR          ;insert it
000E22  1  20 25 0C             JSR     SPLNUM          ;spool rest
000E25  1               SCAN9
000E25  1  20 ED 0B             JSR     CNVLWR          ;convert next to upper
000E28  1  A5 4D                LDA     NXTCHR          ;get it
000E2A  1  C9 45                CMP     #'E'            ;see if e for exponent
000E2C  1  D0 1B                BNE     SCAN13          ;branch if not
000E2E  1  20 B5 0B             JSR     PUTGET          ;else insert and get another
000E31  1  C9 2B                CMP     #'+'            ;if a +
000E33  1  F0 04                BEQ     SCAN10          ;go insert and get another
000E35  1  C9 2D                CMP     #'-'            ;if not a -
000E37  1  D0 03                BNE     SCAN11          ;skip ahead
000E39  1               SCAN10
000E39  1  20 B5 0B             JSR     PUTGET          ;insert and get
000E3C  1               SCAN11
000E3C  1  20 C1 0B             JSR     NUMRIC          ;test for number
000E3F  1  D0 05                BNE     SCAN12          ;branch if is
000E41  1  A9 09                LDA     #9              ;else illegal floating point format
000E43  1  20 AB 0A             JSR     ERROR           ;error
000E46  1               SCAN12
000E46  1  20 25 0C             JSR     SPLNUM          ;spool numbers
000E49  1               SCAN13
000E49  1  A5 4E                LDA     ACCLEN          ;get length
000E4B  1  D0 08                BNE     SCAN14          ;branch if not zero
000E4D  1  E6 4E                INC     ACCLEN          ;else bump
000E4F  1  A9 30                LDA     #'0'            ;and insert a '0'
000E51  1  85 4F                STA     ACCUM+1         ;in ACCUM
000E53  1  85 4C                STA     HSHCDE          ;and hashcode
000E55  1               SCAN14
000E55  1  4C 31 0C             JMP     SUPNCL          ;setupnextcall and return
000E58  1               SCAN15
000E58  1  20 FD 0B             JSR     LETTER          ;see if letter
000E5B  1  D0 03                BNE     *+5             ;continue if is
000E5D  1  4C F4 0E             JMP     SCAN26          ;else go to next section
000E60  1               ;is an identifier or may be REM, REMARK, or DATA statements. these two are
000E60  1               ;handled here
000E60  1               SCAN16
000E60  1  20 16 0C             JSR     ALPNUM          ;test for alphanumeric
000E63  1  F0 06                BEQ     SCAN17          ;branch if not
000E65  1  20 BB 0B             JSR     PUTCHR          ;else insert and get
000E68  1  4C 60 0E             JMP     SCAN16          ;and loop
000E6B  1               SCAN17
000E6B  1  A5 4D                LDA     NXTCHR          ;get next char
000E6D  1  C9 24                CMP     #'$'            ;if not a $
000E6F  1  D0 0A                BNE     SCAN18          ;is floating
000E71  1  A9 32                LDA     #STRING         ;else set string
000E73  1  85 4A                STA     SUBTYP          ;as subtype
000E75  1  20 BB 0B             JSR     PUTCHR          ;put and get
000E78  1  4C 7F 0E             JMP     SCAN19          ;and continue
000E7B  1               SCAN18
000E7B  1  A9 31                LDA     #FLOTPT         ;set floating
000E7D  1  85 4A                STA     SUBTYP          ;as subtype
000E7F  1               SCAN19
000E7F  1  20 4B 0D             JSR     LOOKUP          ;try to match
000E82  1  D0 20                BNE     SCAN21          ;branch if reserved
000E84  1  A5 4F                LDA     ACCUM+1         ;check for user
000E86  1  C9 46                CMP     #'F'            ;defined function
000E88  1  D0 13                BNE     SCAN20          ;branch if not
000E8A  1  A5 50                LDA     ACCUM+2         ;same for next
000E8C  1  C9 4E                CMP     #'N'            ;char in ACCUM
000E8E  1  D0 0D                BNE     SCAN20
000E90  1  A5 4E                LDA     ACCLEN          ;get length
000E92  1  C9 01                CMP     #1              ;must not be 1
000E94  1  F0 07                BEQ     SCAN20          ;branch if is
000E96  1  A9 36                LDA     #UDFUNC         ;ah!ah! is FN--
000E98  1  85 49                STA     TOKEN           ;set token
000E9A  1  4C 31 0C             JMP     SUPNCL          ;exit with setupnextcall
000E9D  1               SCAN20
000E9D  1  A9 34                LDA     #IDENT          ;is identifier
000E9F  1  85 49                STA     TOKEN           ;set token
000EA1  1  4C 31 0C             JMP     SUPNCL          ;exit with setupnextcall
000EA4  1               SCAN21
000EA4  1  A5 49                LDA     TOKEN           ;is a reserved
000EA6  1  C9 00                CMP     #TREM           ;see if REM
000EA8  1  D0 12                BNE     SCAN23          ;branch if not
000EAA  1               SCAN22
000EAA  1  A5 4D                LDA     NXTCHR          ;get next
000EAC  1  C9 0D                CMP     #CR             ;see if eol
000EAE  1  D0 03                BNE     *+5             ;branch if not
000EB0  1  4C AE 0D             JMP     SCANNR          ;else loop to start
000EB3  1  20 15 0A             JSR     GETCHR          ;get char
000EB6  1  20 9A 0A             JSR     CHKCNT          ;check for continue
000EB9  1  4C AA 0E             JMP     SCAN22          ;and loop
000EBC  1               SCAN23
000EBC  1  C9 63                CMP     #TDATA          ;see if DATA
000EBE  1  F0 03                BEQ     *+5             ;branch if is
000EC0  1  4C 31 0C             JMP     SUPNCL          ;else setupnextcall and exit
000EC3  1  A9 33                LDA     #DAT            ;emit DAT opcode
000EC5  1  20 03 0D             JSR     EMITDT          ;to start
000EC8  1  A5 4D                LDA     NXTCHR          ;get next
000ECA  1  20 03 0D             JSR     EMITDT          ;emit it
000ECD  1               SCAN24
000ECD  1  20 15 0A             JSR     GETCHR          ;get another
000ED0  1  C9 0D                CMP     #CR             ;see if eol
000ED2  1  F0 0B                BEQ     SCAN25          ;branch if is
000ED4  1  20 9A 0A             JSR     CHKCNT          ;else check for continue
000ED7  1  A5 4D                LDA     NXTCHR          ;get char
000ED9  1  20 03 0D             JSR     EMITDT          ;emit it
000EDC  1  4C CD 0E             JMP     SCAN24          ;and loop
000EDF  1               SCAN25
000EDF  1  A9 2C                LDA     #','            ;now emit
000EE1  1  20 03 0D             JSR     EMITDT          ;a comma
000EE4  1  A9 00                LDA     #0              ;and a
000EE6  1  20 03 0D             JSR     EMITDT          ;zero
000EE9  1  A5 45                LDA     DATACT          ;now
000EEB  1  D0 02                BNE     *+4             ;drop
000EED  1  C6 46                DEC     DATACT+1        ;data count
000EEF  1  C6 45                DEC     DATACT          ;by one
000EF1  1  4C AE 0D             JMP     SCANNR          ;and loop to start
000EF4  1               ;final case is a special character -- it may be continuation char in which case
000EF4  1               ;just go to next line and scan somemore
000EF4  1               SCAN26
000EF4  1  A5 4D                LDA     NXTCHR          ;get char
000EF6  1  C9 5C                CMP     #backsl         ;see if continue
000EF8  1  D0 06                BNE     SCAN27          ;branch if not
000EFA  1  20 9A 0A             JSR     CHKCNT          ;check it
000EFD  1  4C AE 0D             JMP     SCANNR          ;and loop
000F00  1               SCAN27
000F00  1  20 97 0B             JSR     PUTACC          ;put in accum
000F03  1  A5 4D                LDA     NXTCHR          ;get last char
000F05  1  C9 0D                CMP     #CR             ;see if eol
000F07  1  D0 07                BNE     SCAN29          ;not so skip
000F09  1  A9 FF                LDA     #$FF            ;set flag to read
000F0B  1  8D 0D 34             STA     EOLSTS
000F0E  1  30 03                BMI     SCAN30          ;then jump ahead
000F10  1               SCAN29
000F10  1  20 8E 0A             JSR     GTNBLK          ;get non blank
000F13  1               SCAN30
000F13  1  20 4B 0D             JSR     LOOKUP          ;see if match
000F16  1  F0 01                BEQ     *+3             ;branch if not
000F18  1  60                   RTS                     ;else done
000F19  1  A9 07                LDA     #7              ;illegal character error
000F1B  1  4C AB 0A             JMP     ERROR           ;and quit
000F1E  1               ;adjust base for next entry
000F1E  1               NXTENT
000F1E  1  A0 00                LDY     #0              ;clear index
000F20  1  8B DA A2 01          LDAINDIRECTY BASE       ;get name length
000F24  1  B5 A7 C9 00  
000F28  1  D0 04 A2 00  
000F36  1  18                   CLC                     ;now
000F37  1  65 A7                ADC     BASE            ;add to current
000F39  1  85 A7                STA     BASE            ;and update
000F3B  1  90 02                BCC     *+4             ;don't forget
000F3D  1  E6 A8                INC     BASE+1          ;carry
000F3F  1  18                   CLC                     ;now
000F40  1  A5 A7                LDA     BASE            ;add
000F42  1  69 07                ADC     #7              ;seven for
000F44  1  85 A7                STA     BASE            ;overhead
000F46  1  90 02                BCC     *+4             ;to get
000F48  1  E6 A8                INC     BASE+1          ;new base
000F4A  1  60                   RTS
000F4B  1               ;get length of printname
000F4B  1               GETLEN
000F4B  1  A0 00                LDY     #0              ;clear index
000F4D  1  8B DA A2 01          LDAINDIRECTY BASE       ;get length
000F51  1  B5 A7 C9 00  
000F55  1  D0 04 A2 00  
000F63  1  60                   RTS
000F64  1               ;write numeric constant during pass 1
000F64  1               EMITCN
000F64  1  2C 05 34             BIT     PASS1           ;test for pass 1
000F67  1  30 01                BMI     *+3             ;branch if is
000F69  1  60                   RTS                     ;else done
000F6A  1  4C B6 09             JMP     EMIT            ;write byte
000F6D  1               ;write two bytes of object code on disk for literals
000F6D  1               GENTWO
000F6D  1  48                   PHA                     ;save low
000F6E  1  98                   TYA                     ;get high
000F6F  1  20 F4 0C             JSR     GENERT          ;write it
000F72  1  68                   PLA                     ;get low
000F73  1  4C F4 0C             JMP     GENERT          ;do it
000F76  1               ;
000F76  1               LITERL
000F76  1  48                   PHA                     ;save low
000F77  1  98                   TYA                     ;get high
000F78  1  09 80                ORA     #$80            ;set msb
000F7A  1  A8                   TAY                     ;back to Y
000F7B  1  68                   PLA                     ;get low
000F7C  1  4C 6D 0F             JMP     GENTWO          ;send it
000F7F  1               ;
000F7F  1               LITLOD
000F7F  1  48                   PHA                     ;save low
000F80  1  98                   TYA                     ;get high
000F81  1  09 C0                ORA     #$C0            ;or with mask
000F83  1  A8                   TAY                     ;back to Y
000F84  1  68                   PLA                     ;get low
000F85  1  4C 6D 0F             JMP     GENTWO          ;write it
000F88  1               ;
000F88  1               LINENU
000F88  1  2C 09 34             BIT     DEBUGL          ;test debug flag
000F8B  1  30 01                BMI     *+3             ;branch if set
000F8D  1  60                   RTS                     ;else do nothing
000F8E  1  A5 70                LDA     LINENO          ;get low
000F90  1  A4 71                LDY     LINENO+1        ;and high number
000F92  1  20 76 0F             JSR     LITERL          ;send as literal
000F95  1  A9 5F                LDA     #BOL            ;then send BOL
000F97  1  4C F4 0C             JMP     GENERT          ;opcode
000F9A  1               ;fill hashtable with 0's and initialize pointer to top of symbol table
000F9A  1               INSYMT
000F9A  1  2C 05 34             BIT     PASS1           ;see if pass 1
000F9D  1  10 14                BPL     INSYM1          ;branch if not
000F9F  1  A2 7F                LDX     #HSHTSZ*2-1     ;get number to clear
000FA1  1  A9 00                LDA     #0              ;then value
000FA3  1               INSYM0
000FA3  1  9D 3F 34             STA     HSHTBL,X        ;store it
000FA6  1  CA                   DEX                     ;drop count
000FA7  1  E0 FF                CPX     #255            ;see if wrap
000FA9  1  D0 F8                BNE     INSYM0          ;loop if not
000FAB  1  A9 C6                LDA     #<MEMORY        ;get memory
000FAD  1  A0 37                LDY     #>MEMORY        ;start
000FAF  1  85 AA                STA     SBTBL           ;and set
000FB1  1  84 AB                STY     SBTBL+1         ;table start
000FB3  1               INSYM1
000FB3  1  AD 04 01             LDA     PEM+1           ;get limit
000FB6  1  AC 05 01             LDY     PEM+2           ;of memory
000FB9  1  38                   SEC                     ;drop
000FBA  1  E9 02                SBC     #2              ;two
000FBC  1  85 A5                STA     SBTTOP          ;to get
000FBE  1  85 B9                STA     NXSTPT          ;top starting
000FC0  1  B0 01                BCS     *+3             ;branch if no borrow
000FC2  1  88                   DEY                     ;else drop Y
000FC3  1  84 A6                STY     SBTTOP+1        ;set high
000FC5  1  84 BA                STY     NXSTPT+1        ;and set
000FC7  1  A9 00                LDA     #0              ;clear A
000FC9  1  A0 01                LDY     #1              ;set index to 1
000FCB  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put in memory
000FCF  1  01 B5 B9 C9  
000FD3  1  00 D0 04 A2  
000FE1  1  60                   RTS
000FE2  1               ;
000FE2  1               GETHSH
000FE2  1  A0 00                LDY     #0              ;get
000FE4  1  8B DA A2 01          LDAINDIRECTY BASE       ;PTR
000FE8  1  B5 A7 C9 00  
000FEC  1  D0 04 A2 00  
000FFA  1  85 BC                STA     TMPPTR          ;and save
000FFC  1  84 BB                STY     TMPHSH          ;clear internal hash
000FFE  1  A5 A7                LDA     BASE            ;get
001000  1  A4 A8                LDY     BASE+1          ;base
001002  1  18                   CLC                     ;now
001003  1  69 02                ADC     #2              ;add 2
001005  1  85 AC                STA     APTADD          ;and save
001007  1  90 01                BCC     *+3             ;branch if
001009  1  C8                   INY                     ;no carry
00100A  1  84 AD                STY     APTADD+1        ;save high
00100C  1  A0 01                LDY     #1              ;set starting index
00100E  1               GETHS0
00100E  1  C4 BC                CPY     TMPPTR          ;compare to limit
001010  1  F0 05                BEQ     GETHS1          ;continue if equal
001012  1  90 03                BCC     GETHS1          ;branch if less
001014  1  A5 BB                LDA     TMPHSH          ;else get HASH
001016  1  60                   RTS                     ;and quit
001017  1               GETHS1
001017  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get value
00101B  1  B5 AC C9 00  
00101F  1  D0 04 A2 00  
00102D  1  18                   CLC                     ;now add
00102E  1  65 BB                ADC     TMPHSH          ;in old hash
001030  1  29 3F                AND     #HSHMSK         ;and mask
001032  1  85 BB                STA     TMPHSH          ;and save
001034  1  C8                   INY                     ;bump loop index
001035  1  4C 0E 10             JMP     GETHS0          ;then loop
001038  1               ;
001038  1               HSOSYM
001038  1  A5 B7                LDA     SYMHSH          ;get symhsh
00103A  1  0A                   ASL     A               ;mult by two
00103B  1  AA                   TAX                     ;make index
00103C  1  BD 3F 34             LDA     HSHTBL,X        ;get value
00103F  1  BC 40 34             LDY     HSHTBL+1,X      ;in table
001042  1  60                   RTS
001043  1               ;
001043  1               SETLNK
001043  1  A6 A7                LDX     BASE            ;get
001045  1  A4 A8                LDY     BASE+1          ;base
001047  1  E8                   INX                     ;bump
001048  1  86 AC                STX     APTADD          ;by
00104A  1  D0 01                BNE     *+3             ;one
00104C  1  C8                   INY                     ;and
00104D  1  84 AD                STY     APTADD+1        ;save
00104F  1  60                   RTS
001050  1               ;set pointer for addr reference with offset in A
001050  1               SETADP
001050  1  A0 00                LDY     #0              ;clear index
001052  1  18                   CLC                     ;and carry
001053  1  8B 48 DA A2          ADCINDIRECTY BASE       ;add PTR
001057  1  01 B5 A7 C9  
00105B  1  00 D0 04 A2  
00106C  1  90 01                BCC     *+3             ;branch if no carry
00106E  1  C8                   INY                     ;else set Y to 1
00106F  1  18                   CLC                     ;clear carry
001070  1  65 A7                ADC     BASE            ;add base
001072  1  85 AC                STA     APTADD          ;to low
001074  1  98                   TYA                     ;now add
001075  1  65 A8                ADC     BASE+1          ;with carry to high
001077  1  85 AD                STA     APTADD+1        ;and save
001079  1  60                   RTS
00107A  1               ;check to see if additional SBTBL entry will overflow limits of memory. if
00107A  1               ;so then abort else return. at entry A contains amount to be added (COUNT)
00107A  1               LIMITS
00107A  1  18                   CLC                     ;add count
00107B  1  65 AA                ADC     SBTBL           ;to start
00107D  1  A4 AB                LDY     SBTBL+1         ;with
00107F  1  90 01                BCC     *+3             ;carry to
001081  1  C8                   INY                     ;high
001082  1  C5 A5                CMP     SBTTOP          ;compare to limit
001084  1  98                   TYA                     ;including
001085  1  E5 A6                SBC     SBTTOP+1        ;high
001087  1  B0 01                BCS     *+3             ;whoops! no borrow
001089  1  60                   RTS                     ;else ok
00108A  1  A9 FF                LDA     #TRUE           ;set to
00108C  1  8D 06 34             STA     PASS2           ;pass 2
00108F  1  A9 13                LDA     #19             ;symbol table error
001091  1  20 AB 0A             JSR     ERROR           ;send it
001094  1  4C 00 01             JMP     BOOT            ;and abort
001097  1               ;set the address field at location LOC in AY and resolved bit
001097  1               SETRSV
001097  1  48                   PHA                     ;save
001098  1  98                   TYA                     ;A
001099  1  48                   PHA                     ;and Y
00109A  1  A9 04                LDA     #4              ;set offset
00109C  1  20 50 10             JSR     SETADP          ;of four
00109F  1  A0 01                LDY     #1              ;set index to 1
0010A1  1  68                   PLA                     ;get high
0010A2  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and save
0010A6  1  01 B5 AC C9  
0010AA  1  00 D0 04 A2  
0010B8  1  88                   DEY                     ;drop Y to 0
0010B9  1  68                   PLA                     ;get low
0010BA  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
0010BE  1  01 B5 AC C9  
0010C2  1  00 D0 04 A2  
0010D0  1  A5 AC                LDA     APTADD          ;now
0010D2  1  D0 02                BNE     *+4             ;drop
0010D4  1  C6 AD                DEC     APTADD+1        ;pointer
0010D6  1  C6 AC                DEC     APTADD          ;by one
0010D8  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now set
0010DC  1  B5 AC C9 00  
0010E0  1  D0 04 A2 00  
0010EE  1  09 80                ORA     #$80            ;resolved
0010F0  1  8B DA 48 A2          STAINDIRECTY APTADD     ;bit
0010F4  1  01 B5 AC C9  
0010F8  1  00 D0 04 A2  
001106  1  60                   RTS
001107  1               ;return type of variable
001107  1               GETTYP
001107  1  A9 03                LDA     #3              ;build
001109  1  20 50 10             JSR     SETADP          ;new indirect
00110C  1  A0 00                LDY     #0              ;clear index
00110E  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get
001112  1  B5 AC C9 00  
001116  1  D0 04 A2 00  
001124  1  29 7F                AND     #$7F            ;mask out set bit
001126  1  60                   RTS
001127  1               ;set type of variable to A and preserve resolved bit
001127  1               SETTYP
001127  1  48                   PHA                     ;save type
001128  1  A9 03                LDA     #3              ;calculate
00112A  1  20 50 10             JSR     SETADP          ;new pointer
00112D  1  A0 00                LDY     #0              ;clear index
00112F  1  68                   PLA                     ;get type
001130  1  8B 48 DA A2          ORAINDIRECTY APTADD     ;or with contents
001134  1  01 B5 AC C9  
001138  1  00 D0 04 A2  
001149  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save it
00114D  1  01 B5 AC C9  
001151  1  00 D0 04 A2  
00115F  1  60                   RTS
001160  1               ;get resolved bit A:=TRUE iff bit=1 else A:=FALSE
001160  1               GETRES
001160  1  A9 03                LDA     #3              ;build
001162  1  20 50 10             JSR     SETADP          ;pointer
001165  1  A0 00                LDY     #0              ;clear index
001167  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get byte
00116B  1  B5 AC C9 00  
00116F  1  D0 04 A2 00  
00117D  1  30 03                BMI     *+5             ;branch if set
00117F  1  A9 00                LDA     #FALSE          ;else set
001181  1  60                   RTS                     ;false
001182  1  A9 FF                LDA     #TRUE           ;was set
001184  1  60                   RTS
001185  1               ;get the address of the printname location in AY
001185  1               GETADR
001185  1  A9 04                LDA     #4              ;build
001187  1  20 50 10             JSR     SETADP          ;pointer
00118A  1  A0 00                LDY     #0              ;clear index
00118C  1  8B DA A2 01          LDAINDIRECTY APTADD     ;now get low
001190  1  B5 AC C9 00  
001194  1  D0 04 A2 00  
0011A2  1  48                   PHA                     ;save
0011A3  1  C8                   INY                     ;set Y to 1
0011A4  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
0011A8  1  B5 AC C9 00  
0011AC  1  D0 04 A2 00  
0011BA  1  A8                   TAY                     ;move to Y
0011BB  1  68                   PLA                     ;get low
0011BC  1  60                   RTS
0011BD  1               ;check to see if printname located at address in PRNTNM is in SBTBL. if is
0011BD  1               ;then A:=TRUE and BASE:=address else A:=FALSE
0011BD  1               SLOOKU
0011BD  1  20 38 10             JSR     HSOSYM          ;find base
0011C0  1               SLOOKX
0011C0  1  85 A7                STA     BASE            ;and
0011C2  1  84 A8                STY     BASE+1          ;save
0011C4  1               SLOOK0
0011C4  1  A5 A7                LDA     BASE            ;see if
0011C6  1  05 A8                ORA     BASE+1          ;base = 0
0011C8  1  D0 03 4C 74          LBEQ     SLOOFL         ;false if is
0011CC  1  12           
0011CD  1  A0 00                LDY     #0              ;clear index
0011CF  1  8B DA A2 01          LDAINDIRECTY BASE       ;get PTR
0011D3  1  B5 A7 C9 00  
0011D7  1  D0 04 A2 00  
0011E5  1  85 BD                STA     LEN             ;save as length
0011E7  1  8B 48 DA A2          CMPINDIRECTY PRNTNM     ;compare
0011EB  1  01 B5 B5 C9  
0011EF  1  00 D0 04 A2  
0011FF  1  D0 3B                BNE     SLOOK2          ;branch if different
001201  1               SLOOK1
001201  1  A4 BD                LDY     LEN             ;get length
001203  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
001207  1  B5 B5 C9 00  
00120B  1  D0 04 A2 00  
001219  1  C8                   INY                     ;bump index
00121A  1  C8                   INY                     ;by two
00121B  1  8B 48 DA A2          CMPINDIRECTY BASE       ;compare to entry
00121F  1  01 B5 A7 C9  
001223  1  00 D0 04 A2  
001233  1  D0 07                BNE     SLOOK2          ;branch if different
001235  1  C6 BD                DEC     LEN             ;drop length
001237  1  D0 C8                BNE     SLOOK1          ;loop for more
001239  1  A9 FF                LDA     #TRUE           ;else say true
00123B  1  60                   RTS
00123C  1               SLOOK2
00123C  1  20 43 10             JSR     SETLNK          ;set link
00123F  1  A0 00                LDY     #0              ;clear index
001241  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
001245  1  B5 AC C9 00  
001249  1  D0 04 A2 00  
001257  1  48                   PHA                     ;save it
001258  1  C8                   INY                     ;set y to 1
001259  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get high
00125D  1  B5 AC C9 00  
001261  1  D0 04 A2 00  
00126F  1  A8                   TAY                     ;move to Y
001270  1  68                   PLA                     ;get low
001271  1  4C C0 11             JMP     SLOOKX          ;and loop
001274  1               SLOOFL
001274  1  A9 00                LDA     #FALSE          ;was not
001276  1  60                   RTS                     ;found
001277  1               ;enter token reference by PRNTNM and SYMHSH into next available location in the
001277  1               ;symbol table.  set BASE to beginning of this entry and increment SBTBL. check
001277  1               ;for symbol table full
001277  1               ENTER
001277  1  A0 00                LDY     #0              ;clear index
001279  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get length
00127D  1  B5 B5 C9 00  
001281  1  D0 04 A2 00  
00128F  1  18                   CLC                     ;now
001290  1  69 07                ADC     #7              ;add seven
001292  1  48                   PHA                     ;save on stack
001293  1  20 7A 10             JSR     LIMITS          ;test limits
001296  1  A5 AA                LDA     SBTBL           ;update
001298  1  A4 AB                LDY     SBTBL+1         ;base
00129A  1  85 A7                STA     BASE
00129C  1  84 A8                STY     BASE+1
00129E  1  A0 00                LDY     #0              ;get
0012A0  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;length
0012A4  1  B5 B5 C9 00  
0012A8  1  D0 04 A2 00  
0012B6  1  8B DA 48 A2          STAINDIRECTY BASE       ;move to table
0012BA  1  01 B5 A7 C9  
0012BE  1  00 D0 04 A2  
0012CC  1  AA                   TAX                     ;make a counter
0012CD  1  F0 33                BEQ     ENTER1          ;done if zero
0012CF  1  C8                   INY                     ;start with Y=1
0012D0  1               ENTER0
0012D0  1  8B DA A2 01          LDAINDIRECTY PRNTNM     ;get name
0012D4  1  B5 B5 C9 00  
0012D8  1  D0 04 A2 00  
0012E6  1  C8                   INY                     ;bump index
0012E7  1  C8                   INY                     ;by two
0012E8  1  8B DA 48 A2          STAINDIRECTY SBTBL      ;insert
0012EC  1  01 B5 AA C9  
0012F0  1  00 D0 04 A2  
0012FE  1  88                   DEY                     ;drop y by one
0012FF  1  CA                   DEX                     ;drop count
001300  1  D0 CE                BNE     ENTER0          ;loop if more
001302  1               ENTER1
001302  1  A9 03                LDA     #3              ;clear resolve bit
001304  1  20 50 10             JSR     SETADP          ;by getting pointer
001307  1  A0 00                LDY     #0              ;clear index
001309  1  98                   TYA                     ;and A
00130A  1  8B DA 48 A2          STAINDIRECTY APTADD     ;insert
00130E  1  01 B5 AC C9  
001312  1  00 D0 04 A2  
001320  1  20 43 10             JSR     SETLNK          ;set link
001323  1  20 38 10             JSR     HSOSYM          ;find address
001326  1  48                   PHA                     ;save low on stack
001327  1  98                   TYA                     ;high to A
001328  1  A0 01                LDY     #1              ;do high
00132A  1  8B DA 48 A2          STAINDIRECTY APTADD     ;first
00132E  1  01 B5 AC C9  
001332  1  00 D0 04 A2  
001340  1  88                   DEY                     ;drop Y
001341  1  68                   PLA                     ;get low
001342  1  8B DA 48 A2          STAINDIRECTY APTADD     ;and set
001346  1  01 B5 AC C9  
00134A  1  00 D0 04 A2  
001358  1  A5 B7                LDA     SYMHSH          ;get hash
00135A  1  0A                   ASL     A               ;mult by two
00135B  1  AA                   TAX                     ;make index
00135C  1  A5 A7                LDA     BASE            ;get
00135E  1  9D 3F 34             STA     HSHTBL,X        ;and move
001361  1  A5 A8                LDA     BASE+1          ;to
001363  1  9D 40 34             STA     HSHTBL+1,X      ;table
001366  1  68                   PLA                     ;get new length
001367  1  18                   CLC                     ;now
001368  1  65 AA                ADC     SBTBL           ;to start
00136A  1  85 AA                STA     SBTBL           ;to get
00136C  1  90 02                BCC     *+4             ;new
00136E  1  E6 AB                INC     SBTBL+1         ;table address
001370  1  60                   RTS
001371  1               ;insert subtype in SBTBL
001371  1               SETSUB
001371  1  48                   PHA                     ;save code
001372  1  A9 06                LDA     #6              ;offset pointer
001374  1  20 50 10             JSR     SETADP          ;get pointer
001377  1  A0 00                LDY     #0              ;clear index
001379  1  68                   PLA                     ;get code
00137A  1  8B DA 48 A2          STAINDIRECTY APTADD     ;save
00137E  1  01 B5 AC C9  
001382  1  00 D0 04 A2  
001390  1  60                   RTS
001391  1               ;return the subtype
001391  1               GETSUB
001391  1  A9 06                LDA     #6              ;build
001393  1  20 50 10             JSR     SETADP          ;pointer
001396  1  A0 00                LDY     #0              ;clear pointer
001398  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get subtype
00139C  1  B5 AC C9 00  
0013A0  1  D0 04 A2 00  
0013AE  1  60                   RTS
0013AF  1               ;
0013AF  1               UNLINK
0013AF  1  20 07 11             JSR     GETTYP          ;get type
0013B2  1  85 BE                STA     NUMPRM          ;save it
0013B4  1  A9 01                LDA     #1              ;set index
0013B6  1  85 BF                STA     LINKI           ;to one
0013B8  1               UNLNK0
0013B8  1  A5 BE                LDA     NUMPRM          ;compare limit
0013BA  1  C5 BF                CMP     LINKI           ;to count
0013BC  1  B0 01                BCS     *+3             ;continue if ok
0013BE  1  60                   RTS                     ;else done
0013BF  1  20 1E 0F             JSR     NXTENT          ;get next
0013C2  1  20 E2 0F             JSR     GETHSH          ;and hash
0013C5  1  0A                   ASL     A               ;mult
0013C6  1  18                   CLC                     ;by two
0013C7  1  69 3F                ADC     #<HSHTBL        ;and add
0013C9  1  85 C0                STA     TMPADR          ;hash table start
0013CB  1  A0 34                LDY     #>HSHTBL        ;get high
0013CD  1  90 01                BCC     *+3             ;with carry
0013CF  1  C8                   INY                     ;bump
0013D0  1  84 C1                STY     TMPADR+1        ;and save
0013D2  1               UNLNK1
0013D2  1  A0 00                LDY     #0              ;clear index
0013D4  1  A5 A7                LDA     BASE            ;compare base low
0013D6  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;to byte
0013DA  1  01 B5 C0 C9  
0013DE  1  00 D0 04 A2  
0013EE  1  D0 1D                BNE     UNLNK2          ;branch if different
0013F0  1  C8                   INY                     ;set y to 1
0013F1  1  A5 A8                LDA     BASE+1          ;do same
0013F3  1  8B 48 DA A2          CMPINDIRECTY TMPADR     ;for high
0013F7  1  01 B5 C0 C9  
0013FB  1  00 D0 04 A2  
00140B  1  F0 3E                BEQ     UNLNK3          ;branch if all same
00140D  1               UNLNK2
00140D  1  A0 00                LDY     #0              ;y back to zero
00140F  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get low
001413  1  B5 C0 C9 00  
001417  1  D0 04 A2 00  
001425  1  48                   PHA                     ;save it
001426  1  C8                   INY                     ;bump index
001427  1  8B DA A2 01          LDAINDIRECTY TMPADR     ;get high
00142B  1  B5 C0 C9 00  
00142F  1  D0 04 A2 00  
00143D  1  85 C1                STA     TMPADR+1        ;change address
00143F  1  68                   PLA                     ;get low
001440  1  85 C0                STA     TMPADR          ;save it
001442  1  E6 C0                INC     TMPADR
001444  1  D0 8C                BNE     UNLNK1
001446  1  E6 C1                INC     TMPADR+1
001448  1  4C D2 13             JMP     UNLNK1          ;and loop
00144B  1               UNLNK3
00144B  1  20 43 10             JSR     SETLNK          ;set link
00144E  1  A0 00                LDY     #0              ;clear index
001450  1  8B DA A2 01          LDAINDIRECTY APTADD     ;get low
001454  1  B5 AC C9 00  
001458  1  D0 04 A2 00  
001466  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;and move
00146A  1  01 B5 C0 C9  
00146E  1  00 D0 04 A2  
00147C  1  C8                   INY                     ;now
00147D  1  8B DA A2 01          LDAINDIRECTY APTADD     ;same
001481  1  B5 AC C9 00  
001485  1  D0 04 A2 00  
001493  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;for high
001497  1  01 B5 C0 C9  
00149B  1  00 D0 04 A2  
0014A9  1  E6 BF                INC     LINKI           ;bump loop index
0014AB  1  4C B8 13             JMP     UNLNK0          ;and loop
0014AE  1               ;
0014AE  1               RELINK
0014AE  1  20 07 11             JSR     GETTYP          ;get type
0014B1  1  85 BE                STA     NUMPRM          ;save it
0014B3  1  A9 01                LDA     #1              ;set count
0014B5  1  85 BF                STA     LINKI           ;to one
0014B7  1               RELNK0
0014B7  1  A5 BE                LDA     NUMPRM          ;get limit and
0014B9  1  C5 BF                CMP     LINKI           ;compare to count
0014BB  1  B0 01                BCS     *+3             ;branch if >=
0014BD  1  60                   RTS                     ;else done
0014BE  1  20 1E 0F             JSR     NXTENT          ;do next entry
0014C1  1  A5 A7                LDA     BASE            ;now set
0014C3  1  A4 A8                LDY     BASE+1          ;temp
0014C5  1  85 C0                STA     TMPADR
0014C7  1  E6 C0                INC     TMPADR          ;bump low
0014C9  1  D0 01                BNE     *+3
0014CB  1  C8                   INY
0014CC  1  84 C1                STY     TMPADR+1        ;save high
0014CE  1  20 E2 0F             JSR     GETHSH          ;get hash
0014D1  1  0A                   ASL     A               ;mult by two
0014D2  1  AA                   TAX                     ;make index
0014D3  1  A0 00                LDY     #0              ;clear Y
0014D5  1  BD 3F 34             LDA     HSHTBL,X        ;get low
0014D8  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014DC  1  01 B5 C0 C9  
0014E0  1  00 D0 04 A2  
0014EE  1  C8                   INY                     ;now high
0014EF  1  BD 40 34             LDA     HSHTBL+1,X      ;get it
0014F2  1  8B DA 48 A2          STAINDIRECTY TMPADR     ;save it
0014F6  1  01 B5 C0 C9  
0014FA  1  00 D0 04 A2  
001508  1  20 E2 0F             JSR     GETHSH          ;gethash
00150B  1  0A                   ASL     A
00150C  1  AA                   TAX
00150D  1  A5 A7                LDA     BASE            ;now get
00150F  1  9D 3F 34             STA     HSHTBL,X        ;and put
001512  1  A5 A8                LDA     BASE+1          ;new base
001514  1  9D 40 34             STA     HSHTBL+1,X      ;in table
001517  1  E6 BF                INC     LINKI           ;bump loop index
001519  1  4C B7 14             JMP     RELNK0          ;and loop
00151C  1               ;initialize SYNTHE
00151C  1               ;data definitions for initialization
00151C  1               CONZER
00151C  1  01 30                .BYTE   1,"0"
00151E  1               CONONE
00151E  1  01 31                .BYTE   1,"1"
001520  1               INSYN
001520  1  A9 00                LDA     #0              ;first
001522  1  85 B2                STA     CODESI          ;clear
001524  1  85 B3                STA     CODESI+1        ;variables
001526  1  85 45                STA     DATACT
001528  1  85 46                STA     DATACT+1
00152A  1  8D 63 36             STA     ONSP
00152D  1  8D 3E 34             STA     IFLABL
001530  1  85 B1                STA     FDACT+1         ;set fda
001532  1  A9 01                LDA     #1              ;count to
001534  1  85 B0                STA     FDACT           ;one
001536  1  A9 FF                LDA     #$FF            ;set prt
001538  1  85 AE                STA     PRTCT           ;count
00153A  1  85 AF                STA     PRTCT+1         ;to -1
00153C  1  20 84 09             JSR     SETFLG          ;set flags
00153F  1  2C 05 34             BIT     PASS1           ;see if pass 1
001542  1  30 01                BMI     *+3             ;branch if is
001544  1  60                   RTS                     ;else done
001545  1  20 59 09             JSR     SUPINT          ;setup int file
001548  1  A9 1E                LDA     #<CONONE        ;initialize
00154A  1  A0 15                LDY     #>CONONE        ;printname
00154C  1  85 B5                STA     PRNTNM          ;pointer
00154E  1  84 B6                STY     PRNTNM+1
001550  1  A9 31                LDA     #'1'            ;then
001552  1  85 B7                STA     SYMHSH          ;symbol hash
001554  1  20 77 12             JSR     ENTER           ;put in table
001557  1  A9 31                LDA     #'1'            ;emit
001559  1  20 64 0F             JSR     EMITCN          ;emit
00155C  1  A9 24                LDA     #'$'            ;do a $
00155E  1  20 64 0F             JSR     EMITCN
001561  1  A9 00                LDA     #0              ;constant 1
001563  1  A8                   TAY                     ;is at fda position 0
001564  1  20 97 10             JSR     SETRSV          ;set
001567  1  A9 04                LDA     #CONST          ;set type
001569  1  20 27 11             JSR     SETTYP          ;as constant
00156C  1  A9 1C                LDA     #<CONZER        ;now
00156E  1  A0 15                LDY     #>CONZER        ;point
001570  1  85 B5                STA     PRNTNM          ;to
001572  1  84 B6                STY     PRNTNM+1        ;zero
001574  1  A9 30                LDA     #'0'            ;set hash
001576  1  85 B7                STA     SYMHSH          ;to '0'
001578  1  20 77 12             JSR     ENTER           ;enter it
00157B  1  A9 30                LDA     #'0'            ;now
00157D  1  20 64 0F             JSR     EMITCN          ;output it
001580  1  A9 24                LDA     #'$'            ;do $
001582  1  20 64 0F             JSR     EMITCN
001585  1  A9 01                LDA     #1              ;set address
001587  1  A0 00                LDY     #0
001589  1  20 97 10             JSR     SETRSV
00158C  1  A9 04                LDA     #CONST          ;and type = const
00158E  1  4C 27 11             JMP     SETTYP          ;then exit
001591  1               ;calculate var(a)+.varc
001591  1               CALVRC
001591  1  AA                   TAX                     ;make index
001592  1  BD DF 34             LDA     VAR,X           ;get var contents
001595  1  18                   CLC                     ;now add
001596  1  69 FF                ADC     #<VARC          ;varc start
001598  1  A0 35                LDY     #>VARC          ;with carry
00159A  1  90 01                BCC     *+3
00159C  1  C8                   INY
00159D  1  60                   RTS
00159E  1               ;setlookup
00159E  1               STLKUP
00159E  1  48                   PHA                     ;save param
00159F  1  20 91 15             JSR     CALVRC          ;calculate varc
0015A2  1  85 B5                STA     PRNTNM          ;save as printname
0015A4  1  84 B6                STY     PRNTNM+1        ;position
0015A6  1  68                   PLA                     ;get param
0015A7  1  AA                   TAX                     ;make index
0015A8  1  BD BF 34             LDA     HASH,X          ;get entry
0015AB  1  85 B7                STA     SYMHSH          ;and set symbols
0015AD  1  60                   RTS
0015AE  1               ;lookup$only
0015AE  1               LKONLY
0015AE  1  20 9E 15             JSR     STLKUP          ;set up
0015B1  1  4C BD 11             JMP     SLOOKU          ;try to lookup
0015B4  1               ;normal$lookup
0015B4  1               NRMLKU
0015B4  1  20 AE 15             JSR     LKONLY          ;call lookup$only
0015B7  1  F0 01                BEQ     *+3             ;if false
0015B9  1  60                   RTS                     ;else done
0015BA  1  20 77 12             JSR     ENTER           ;enter in table
0015BD  1  A9 00                LDA     #FALSE          ;then done
0015BF  1  60                   RTS
0015C0  1               ;count size of the prt and return with count in AY
0015C0  1               CNTPRT
0015C0  1  E6 AE                INC     PRTCT           ;bump
0015C2  1  D0 02                BNE     *+4
0015C4  1  E6 AF                INC     PRTCT+1
0015C6  1  A5 AE                LDA     PRTCT           ;and get
0015C8  1  A4 AF                LDY     PRTCT+1
0015CA  1  60                   RTS
0015CB  1               ;setifname
0015CB  1               SETIFN
0015CB  1  A9 3C                LDA     #<IFLBLN        ;point to printname
0015CD  1  A0 34                LDY     #>IFLBLN
0015CF  1  85 B5                STA     PRNTNM
0015D1  1  84 B6                STY     PRNTNM+1
0015D3  1  AD 3E 34             LDA     IFLABL          ;set symhash
0015D6  1  29 3F                AND     #HSHMSK
0015D8  1  85 B7                STA     SYMHSH
0015DA  1  60                   RTS
0015DB  1               ;enter$compiler$label(a)
0015DB  1               ENCMLB
0015DB  1  2C 05 34             BIT     PASS1           ;test for pass 1
0015DE  1  30 01                BMI     *+3             ;branch if is
0015E0  1  60                   RTS
0015E1  1  48                   PHA                     ;save parameter
0015E2  1  20 CB 15             JSR     SETIFN          ;call setifname
0015E5  1  20 77 12             JSR     ENTER           ;call enter
0015E8  1  68                   PLA                     ;get param
0015E9  1  18                   CLC                     ;add to codesize
0015EA  1  65 B2                ADC     CODESI
0015EC  1  A4 B3                LDY     CODESI+1
0015EE  1  90 01                BCC     *+3
0015F0  1  C8                   INY                     ;with carry
0015F1  1  4C 97 10             JMP     SETRSV          ;call setaddr(codesize+a)
0015F4  1               ;set$compiler$label
0015F4  1               STCMLB
0015F4  1  EE 3E 34             INC     IFLABL          ;bump iflable
0015F7  1  20 CB 15             JSR     SETIFN          ;call setifname
0015FA  1  4C BD 11             JMP     SLOOKU          ;call "s"lookup
0015FD  1               ;compiler$label
0015FD  1               COMLBL
0015FD  1  20 F4 15             JSR     STCMLB          ;call set$compiler$label
001600  1  20 85 11             JSR     GETADR
001603  1  4C 6D 0F             JMP     GENTWO          ;call gen$two(getaddr)
001606  1               ;check for mp and sp both floating point
001606  1               CHKTY1
001606  1  A5 85                LDA     STYPMP          ;get stypemp
001608  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
00160A  1  D0 09                BNE     DOC1MF          ;error if not
00160C  1  A5 83                LDA     STYPSP          ;get stypesp
00160E  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
001610  1  D0 03                BNE     DOC1MF          ;error if not
001612  1  A9 FF                LDA     #TRUE
001614  1  60                   RTS
001615  1               DOC1MF
001615  1  20 40 16             JSR     MFERR           ;error
001618  1  A9 00                LDA     #FALSE
00161A  1  60                   RTS
00161B  1               ;check mp and sp both same type
00161B  1               CHKTY2
00161B  1  A5 83                LDA     STYPSP          ;get stypesp
00161D  1  C5 85                CMP     STYPMP          ;see if stypemp same
00161F  1  D0 03                BNE     *+5             ;error if not
001621  1  A9 FF                LDA     #TRUE
001623  1  60                   RTS
001624  1  A9 0D                LDA     #13             ;mixed mode error
001626  1  20 AB 0A             JSR     ERROR
001629  1  A9 00                LDA     #FALSE
00162B  1  60                   RTS
00162C  1               ;chktyp3
00162C  1               CHKTY3
00162C  1  A5 83                LDA     STYPSP          ;get stypesp
00162E  1  20 CE 0C             JSR     STSTMP          ;call setstypemp(stypesp)
001631  1  A5 83                LDA     STYPSP          ;get stypesp
001633  1  C9 31                CMP     #FLOTPT         ;see if floating
001635  1  D0 03                BNE     *+5             ;error if not
001637  1  A9 FF                LDA     #TRUE
001639  1  60                   RTS
00163A  1  20 40 16             JSR     MFERR           ;must be floating error
00163D  1  A9 00                LDA     #FALSE
00163F  1  60                   RTS
001640  1               ;must be floating point error
001640  1               MFERR
001640  1  A9 0C                LDA     #12
001642  1  4C AB 0A             JMP     ERROR
001645  1               ;chktyp4
001645  1               CHKTY4
001645  1  A5 84                LDA     STYPM1          ;get stypemp1
001647  1  C9 32                CMP     #STRING         ;see if string
001649  1  D0 03                BNE     *+5             ;ok if not
00164B  1  20 40 16             JSR     MFERR           ;else must be floating error
00164E  1  A9 5B                LDA     #RON
001650  1  4C F4 0C             JMP     GENERT          ;call generate(ron)
001653  1               ;chktyp5
001653  1               CHKTY5
001653  1  20 45 16             JSR     CHKTY4          ;call chktyp4
001656  1  E6 82                INC     TYPEMP          ;bump typemp
001658  1  A5 82                LDA     TYPEMP
00165A  1  4C D4 0C             JMP     STTYMP          ;call settypemp(typemp:=typemp+1)
00165D  1               ;subcalc
00165D  1               SUBCAL
00165D  1  A5 80                LDA     TYPESP          ;get type
00165F  1  20 71 13             JSR     SETSUB          ;call setsubtype(typesp)
001662  1  A9 20                LDA     #ROW
001664  1  20 F4 0C             JSR     GENERT          ;call generate(row)
001667  1  A5 80                LDA     TYPESP
001669  1  20 F4 0C             JSR     GENERT          ;call generate(typesp)
00166C  1  A9 14                LDA     #STD
00166E  1  4C F4 0C             JMP     GENERT          ;call generate(std)
001671  1               ;gen$store
001671  1               GENSTR
001671  1  A5 84                LDA     STYPM1          ;get stypemp1
001673  1  C9 31                CMP     #FLOTPT         ;see if floating
001675  1  D0 05                BNE     *+7             ;branch if not
001677  1  A9 14                LDA     #STD
001679  1  4C F4 0C             JMP     GENERT          ;call generate(std)
00167C  1  A9 1B                LDA     #STS
00167E  1  4C F4 0C             JMP     GENERT          ;call generate(sts)
001681  1               ;setup$input
001681  1               SEINPU
001681  1  A9 FF                LDA     #TRUE
001683  1  85 47                STA     INPSTM          ;inputstmt=true
001685  1  A9 3B                LDA     #RCN
001687  1  4C F4 0C             JMP     GENERT          ;call generate(rcn)
00168A  1               ;gen$read(a,y)
00168A  1               GENRDE
00168A  1  A6 83                LDX     STYPSP          ;get stypesp
00168C  1  E0 32                CPX     #STRING         ;see if string
00168E  1  D0 08                BNE     *+10            ;branch if not
001690  1  20 F4 0C             JSR     GENERT          ;call generate(i)
001693  1  A9 1B                LDA     #STS
001695  1  4C F4 0C             JMP     GENERT          ;call generate(sts)
001698  1  98                   TYA
001699  1  20 F4 0C             JSR     GENERT          ;call generate(y)
00169C  1  A9 14                LDA     #STD
00169E  1  4C F4 0C             JMP     GENERT          ;call generate(std)
0016A1  1               ;get$field
0016A1  1               GETFLD
0016A1  1  A5 80                LDA     TYPESP          ;get typesp
0016A3  1  C9 00                CMP     #SIMVAR         ;see if simple variable
0016A5  1  D0 07                BNE     *+9             ;skip if not
0016A7  1  A5 86                LDA     SYMLSP
0016A9  1  A4 87                LDY     SYMLSP+1
0016AB  1  20 76 0F             JSR     LITERL          ;call literal(symlocsp)
0016AE  1  24 47                BIT     INPSTM          ;test inputstmt
0016B0  1  10 07                BPL     *+9             ;branch if not
0016B2  1  A9 31                LDA     #RES
0016B4  1  A0 22                LDY     #RDV
0016B6  1  4C 8A 16             JMP     GENRDE          ;call gen$read(res,rdv)
0016B9  1  2C 10 34             BIT     FILEIO          ;see if file io
0016BC  1  10 07                BPL     *+9             ;branch if not
0016BE  1  A9 2A                LDA     #RDS
0016C0  1  A0 29                LDY     #RDN
0016C2  1  4C 8A 16             JMP     GENRDE          ;call gen$read(rds,rdn)
0016C5  1  A9 3C                LDA     #DRS
0016C7  1  A0 3D                LDY     #DRF
0016C9  1  4C 8A 16             JMP     GENRDE          ;call gen$read(drs,drf)
0016CC  1               ;gen$on
0016CC  1               GENON
0016CC  1  A9 5B                LDA     #RON
0016CE  1  20 F4 0C             JSR     GENERT          ;call generate(ron)
0016D1  1  EE 63 36             INC     ONSP
0016D4  1  AE 63 36             LDX     ONSP            ;get as index
0016D7  1  BD 63 36             LDA     ONSTAK,X        ;get entry
0016DA  1  A0 00                LDY     #0              ;high always clear
0016DC  1  20 76 0F             JSR     LITERL          ;call(onstack(onsp:=onsp+1))
0016DF  1  A9 5C                LDA     #CKO
0016E1  1  20 F4 0C             JSR     GENERT          ;call generate(cko)
0016E4  1  A9 39                LDA     #BFN
0016E6  1  4C F4 0C             JMP     GENERT          ;call generate(bfn)
0016E9  1               ;gen$on$2
0016E9  1               GENON2
0016E9  1  A5 80                LDA     TYPESP
0016EB  1  AE 63 36             LDX     ONSP
0016EE  1  9D 63 36             STA     ONSTAK,X
0016F1  1  60                   RTS
0016F2  1               ;gennext
0016F2  1               GENNXT
0016F2  1  C6 A9                DEC     FORCNT          ;drop forcount
0016F4  1  A5 A9                LDA     FORCNT          ;get it
0016F6  1  C9 FF                CMP     #255            ;see if wrap
0016F8  1  D0 07                BNE     *+9             ;branch if ok
0016FA  1  E6 A9                INC     FORCNT          ;set to 0
0016FC  1  A9 10                LDA     #16             ;next w/o for error
0016FE  1  4C AB 0A             JMP     ERROR
001701  1  A9 36                LDA     #BRS
001703  1  20 F4 0C             JSR     GENERT          ;call generate(brs)
001706  1  A0 04                LDY     #2*2            ;word addressing
001708  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
00170C  1  B5 B9 C9 00  
001710  1  D0 04 A2 00  
00171E  1  48                   PHA                     ;save
00171F  1  C8                   INY
001720  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get high
001724  1  B5 B9 C9 00  
001728  1  D0 04 A2 00  
001736  1  A8                   TAY                     ;move to Y
001737  1  68                   PLA                     ;get low
001738  1  20 6D 0F             JSR     GENTWO          ;call gen$two(nextaddress(2))
00173B  1  A0 00                LDY     #0*2            ;still word addressing
00173D  1  A5 B2                LDA     CODESI
00173F  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;put
001743  1  01 B5 B9 C9  
001747  1  00 D0 04 A2  
001755  1  C8                   INY
001756  1  A5 B3                LDA     CODESI+1        ;do high
001758  1  09 80                ORA     #$80            ;set msb
00175A  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;insert
00175E  1  01 B5 B9 C9  
001762  1  00 D0 04 A2  
001770  1               GENNX0
001770  1  A0 01                LDY     #1              ;set index to 1
001772  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get nextbytev(1)
001776  1  B5 B9 C9 00  
00177A  1  D0 04 A2 00  
001788  1  30 01                BMI     *+3             ;continue if > 127
00178A  1  60                   RTS
00178B  1  18                   CLC                     ;now add 8 to nextstmtptr
00178C  1  A5 B9                LDA     NXSTPT
00178E  1  69 08                ADC     #8
001790  1  85 B9                STA     NXSTPT
001792  1  90 DC                BCC     GENNX0
001794  1  E6 BA                INC     NXSTPT+1
001796  1  4C 70 17             JMP     GENNX0
001799  1               ;gen$next$with$ident
001799  1               GENWID
001799  1  A5 7D                LDA     MPP1            ;get mpp1
00179B  1  20 AE 15             JSR     LKONLY
00179E  1  F0 3A                BEQ     GENWIE          ;branch if false
0017A0  1  A0 06                LDY     #3*2            ;word addressing
0017A2  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;get low
0017A6  1  B5 B9 C9 00  
0017AA  1  D0 04 A2 00  
0017B8  1  C5 A7                CMP     BASE            ;compare to low base
0017BA  1  D0 1E                BNE     GENWIE          ;error if different
0017BC  1  C8                   INY
0017BD  1  8B DA A2 01          LDAINDIRECTY NXSTPT     ;same for high
0017C1  1  B5 B9 C9 00  
0017C5  1  D0 04 A2 00  
0017D3  1  C5 A8                CMP     BASE+1
0017D5  1  D0 03                BNE     GENWIE
0017D7  1  4C F2 16             JMP     GENNXT          ;else ok
0017DA  1               GENWIE
0017DA  1  A9 0E                LDA     #14             ;next does not match for
0017DC  1  4C AB 0A             JMP     ERROR
0017DF  1               ;check$ul$error
0017DF  1               CHKULE
0017DF  1  24 B4                BIT     ULERFL          ;test flag
0017E1  1  10 05                BPL     *+7             ;branch if clear
0017E3  1  A9 14                LDA     #20             ;else undefined label
0017E5  1  20 AB 0A             JSR     ERROR
0017E8  1  A9 00                LDA     #FALSE          ;now clear flag
0017EA  1  85 B4                STA     ULERFL
0017EC  1  60                   RTS
0017ED  1               ;findlabel
0017ED  1               FNDLBL
0017ED  1  A5 7B                LDA     SP              ;get sp
0017EF  1  20 B4 15             JSR     NRMLKU          ;normal$lookup(sp)
0017F2  1  D0 01                BNE     *+3             ;if true
0017F4  1  60                   RTS
0017F5  1  2C 06 34             BIT     PASS2           ;if pass2
0017F8  1  30 01                BMI     *+3             ;then
0017FA  1  60                   RTS
0017FB  1  20 60 11             JSR     GETRES          ;if not getres
0017FE  1  F0 01                BEQ     *+3             ;then
001800  1  60                   RTS
001801  1  A9 FF                LDA     #TRUE
001803  1  85 B4                STA     ULERFL          ;ulerrorflag=true
001805  1  60                   RTS
001806  1               ;resolve$label
001806  1               RESLBL
001806  1  20 ED 17             JSR     FNDLBL          ;findlabel
001809  1  A9 1E                LDA     #PRO            ;preset for true
00180B  1  24 48                BIT     GSBSTM          ;test gosubstmt
00180D  1  30 02                BMI     *+4             ;if true
00180F  1  A9 36                LDA     #BRS            ;else
001811  1  20 F4 0C             JSR     GENERT          ;generate( )
001814  1  20 85 11             JSR     GETADR
001817  1  4C 6D 0F             JMP     GENTWO          ;gen$two(getaddr)
00181A  1               ;process$simple$variable
00181A  1               PSIMPV
00181A  1  20 B4 15             JSR     NRMLKU          ;normal$lookup
00181D  1  F0 0F                BEQ     PSIMP0          ;if false then
00181F  1  20 07 11             JSR     GETTYP          ;if getype
001822  1  C9 00                CMP     #SIMVAR         ;= simvar
001824  1  F0 13                BEQ     PSIMP1          ;then
001826  1  A9 0B                LDA     #11             ;array name used as simple variable
001828  1  20 AB 0A             JSR     ERROR
00182B  1  4C 39 18             JMP     PSIMP1          ;continue
00182E  1               PSIMP0
00182E  1  20 C0 15             JSR     CNTPRT
001831  1  20 97 10             JSR     SETRSV          ;setaddr(countprt)
001834  1  A9 00                LDA     #SIMVAR
001836  1  20 27 11             JSR     SETTYP          ;setype(simvar)
001839  1               PSIMP1
001839  1  20 85 11             JSR     GETADR
00183C  1  85 86                STA     SYMLSP
00183E  1  84 87                STY     SYMLSP+1        ;symlocsp=getaddr
001840  1  20 AE 0C             JSR     STSLSP          ;setsymlocsp( )
001843  1  A9 00                LDA     #SIMVAR
001845  1  20 C2 0C             JSR     STTYSP          ;settypesp(simvar)
001848  1  2C 0F 34             BIT     FORSTM          ;if forstmt
00184B  1  30 01                BMI     *+3             ;then
00184D  1  60                   RTS
00184E  1  A9 00                LDA     #FALSE
001850  1  8D 0F 34             STA     FORSTM          ;forstmt=false
001853  1  A0 06                LDY     #3*2            ;word addressing
001855  1  A5 A7                LDA     BASE
001857  1  8B DA 48 A2          STAINDIRECTY SBTTOP
00185B  1  01 B5 A5 C9  
00185F  1  00 D0 04 A2  
00186D  1  C8                   INY
00186E  1  A5 A8                LDA     BASE+1
001870  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(3)=base
001874  1  01 B5 A5 C9  
001878  1  00 D0 04 A2  
001886  1  60                   RTS
001887  1               ;gen$ils
001887  1               GENILS
001887  1  85 C2                STA     WHERE
001889  1  84 C3                STY     WHERE+1         ;save parameter
00188B  1  A9 32                LDA     #STRING
00188D  1  20 C8 0C             JSR     STSTSP          ;setstypesp(string)
001890  1  A9 1C                LDA     #ILS
001892  1  20 F4 0C             JSR     GENERT          ;generate(ils)
001895  1               GENIL0
001895  1  A9 01                LDA     #1
001897  1  85 C4                STA     STRPTR          ;strptr=1
001899  1               GENIL1
001899  1  A0 00                LDY     #0
00189B  1  8B DA A2 01          LDAINDIRECTY WHERE      ;if stringtospool(0)
00189F  1  B5 C2 C9 00  
0018A3  1  D0 04 A2 00  
0018B1  1  C5 C4                CMP     STRPTR          ;< strptr
0018B3  1  90 20                BCC     GENIL2          ;then
0018B5  1  A4 C4                LDY     STRPTR
0018B7  1  8B DA A2 01          LDAINDIRECTY WHERE      ;stringtospool(strptr)
0018BB  1  B5 C2 C9 00  
0018BF  1  D0 04 A2 00  
0018CD  1  20 F4 0C             JSR     GENERT          ;generate
0018D0  1  E6 C4                INC     STRPTR          ;strptr=strptr+1
0018D2  1  4C 99 18             JMP     GENIL1
0018D5  1               GENIL2
0018D5  1  24 6E                BIT     CONT            ;if not cont
0018D7  1  10 06                BPL     *+8             ;then
0018D9  1  20 AE 0D             JSR     SCANNR          ;scanner
0018DC  1  4C 95 18             JMP     GENIL0
0018DF  1  A9 00                LDA     #0
0018E1  1  4C F4 0C             JMP     GENERT          ;generate(0)
0018E4  1               ;gencon
0018E4  1               GENCON
0018E4  1  A9 2E                LDA     #CON
0018E6  1  20 F4 0C             JSR     GENERT          ;generate(con)
0018E9  1  A9 04                LDA     #CONST
0018EB  1  20 C2 0C             JSR     STTYSP          ;settypesp(const)
0018EE  1  A9 31                LDA     #FLOTPT
0018F0  1  20 C8 0C             JSR     STSTSP          ;setstypesp(floatpt)
0018F3  1  A5 7B                LDA     SP
0018F5  1  20 AE 15             JSR     LKONLY          ;lookup$only(sp)
0018F8  1  F0 0D                BEQ     GENCO0          ;if false then
0018FA  1  20 07 11             JSR     GETTYP          ;if getype
0018FD  1  C9 04                CMP     #CONST          ;<> const
0018FF  1  D0 06                BNE     GENCO0          ;then
001901  1  20 85 11             JSR     GETADR
001904  1  4C 6D 0F             JMP     GENTWO          ;gen$two(getaddr)
001907  1               GENCO0
001907  1  A9 01                LDA     #1
001909  1  85 C5                STA     IGEN            ;igen=1
00190B  1               GENCO1
00190B  1  A5 4E                LDA     ACCLEN
00190D  1  C5 C5                CMP     IGEN            ;if igen>acclen
00190F  1  90 0C                BCC     GENCO2          ;then
001911  1  A6 C5                LDX     IGEN
001913  1  B5 4E                LDA     ACCUM,X
001915  1  20 64 0F             JSR     EMITCN          ;emitcon(accum(i))
001918  1  E6 C5                INC     IGEN            ;i=i+1
00191A  1  4C 0B 19             JMP     GENCO1
00191D  1               GENCO2
00191D  1  A9 24                LDA     #'$'
00191F  1  20 64 0F             JSR     EMITCN          ;emitcon('$')
001922  1  E6 B0                INC     FDACT
001924  1  D0 02                BNE     *+4
001926  1  E6 B1                INC     FDACT+1         ;fdact=fdact+1
001928  1  A5 B0                LDA     FDACT
00192A  1  A4 B1                LDY     FDACT+1
00192C  1  4C 6D 0F             JMP     GENTWO          ;gen$two(fdact)
00192F  1               ;put$field
00192F  1               PUTFLD
00192F  1  2C 10 34             BIT     FILEIO          ;if not fileio
001932  1  10 10                BPL     NTFLIO          ;then
001934  1  A5 83                LDA     STYPSP          ;if stypesp
001936  1  C9 31                CMP     #FLOTPT         ;<> floatpt
001938  1  D0 05                BNE     *+7             ;then
00193A  1  A9 2B                LDA     #WRN
00193C  1  4C F4 0C             JMP     GENERT          ;generate(wrn)
00193F  1  A9 2C                LDA     #WRS
001941  1  4C F4 0C             JMP     GENERT          ;generate(wrs)
001944  1               NTFLIO
001944  1  A5 83                LDA     STYPSP          ;if stypesp
001946  1  C9 31                CMP     #FLOTPT         ;= floatpt
001948  1  F0 05                BEQ     *+7             ;then
00194A  1  A9 24                LDA     #WST
00194C  1  4C F4 0C             JMP     GENERT          ;generate(wst)
00194F  1  A5 80                LDA     TYPESP          ;if typesp
001951  1  C9 4A                CMP     #74             ;not a tab
001953  1  D0 01                BNE     *+3             ;then
001955  1  60                   RTS
001956  1  A9 23                LDA     #WRV
001958  1  4C F4 0C             JMP     GENERT          ;generate(wrv)
00195B  1               ;gen$parm
00195B  1               GENPRM
00195B  1  A5 82                LDA     TYPEMP
00195D  1  C9 0A                CMP     #UNFUNC         ;if typemp = unfunc
00195F  1  F0 01                BEQ     *+3             ;then
001961  1  60                   RTS
001962  1  A5 8A                LDA     SYMLMP
001964  1  A4 8B                LDY     SYMLMP+1
001966  1  85 A7                STA     BASE
001968  1  84 A8                STY     BASE+1          ;base=symlocmp
00196A  1  20 1E 0F             JSR     NXTENT          ;nextentry
00196D  1  A5 A7                LDA     BASE
00196F  1  A4 A8                LDY     BASE+1
001971  1  20 BC 0C             JSR     STSLMP          ;setsymlocmp(base)
001974  1  C6 8E                DEC     HASHMP
001976  1  A5 8E                LDA     HASHMP
001978  1  20 DA 0C             JSR     STHAMP          ;sethashmp(hashmp:=hashmp-1)
00197B  1  20 85 11             JSR     GETADR
00197E  1  4C 76 0F             JMP     LITERL          ;literal(getaddr)
001981  1               ;checkparm
001981  1               CHKPRM
001981  1  A5 82                LDA     TYPEMP
001983  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
001985  1  D0 17                BNE     NTUNFN          ;then
001987  1  A5 8A                LDA     SYMLMP
001989  1  A4 8B                LDY     SYMLMP+1
00198B  1  85 A7                STA     BASE
00198D  1  84 A8                STY     BASE+1          ;base=symlocmp
00198F  1  20 91 13             JSR     GETSUB          ;getsubtype
001992  1  C5 84                CMP     STYPM1          ;if = stypemp1
001994  1  F0 05                BEQ     *+7             ;then
001996  1  A9 05                LDA     #5              ;else invalid parameter type in function ref
001998  1  20 AB 0A             JSR     ERROR
00199B  1  4C 71 16             JMP     GENSTR          ;gen$store
00199E  1               NTUNFN
00199E  1  A9 01                LDA     #1
0019A0  1  A4 84                LDY     STYPM1          ;if stypemp1
0019A2  1  C0 31                CPY     #FLOTPT         ;<> floatpt
0019A4  1  D0 02                BNE     *+4             ;then
0019A6  1  A9 00                LDA     #FALSE
0019A8  1  45 8E                EOR     HASHMP          ;xor hashmp
0019AA  1  29 01                AND     #1              ;test lsb only
0019AC  1  F0 05                BEQ     *+7             ;if true
0019AE  1  A9 05                LDA     #5              ;invalid type in function parameter list
0019B0  1  20 AB 0A             JSR     ERROR
0019B3  1  A5 8E                LDA     HASHMP
0019B5  1  4A                   LSR     A               ;shr(hashmp,1)
0019B6  1  20 DA 0C             JSR     STHAMP          ;sethashmp
0019B9  1  C6 85                DEC     STYPMP
0019BB  1  A5 85                LDA     STYPMP
0019BD  1  4C CE 0C             JMP     STSTMP          ;setstypemp(stypemp=stypemp-1)
0019C0  1               ;funcgen
0019C0  1               FNCGEN
0019C0  1  A5 82                LDA     TYPEMP
0019C2  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
0019C4  1  D0 1C                BNE     NOFNGN          ;then
0019C6  1  A5 8E                LDA     HASHMP          ;if hashmp=0
0019C8  1  F0 05                BEQ     *+7             ;then
0019CA  1  A9 04                LDA     #4              ;incorrect number parameters
0019CC  1  20 AB 0A             JSR     ERROR
0019CF  1  A9 1E                LDA     #PRO
0019D1  1  20 F4 0C             JSR     GENERT          ;generate(pro)
0019D4  1  A5 8F                LDA     SRLOSP
0019D6  1  A4 90                LDY     SRLOSP+1
0019D8  1  85 A7                STA     BASE
0019DA  1  84 A8                STY     BASE+1          ;base=srlocsp
0019DC  1  20 85 11             JSR     GETADR
0019DF  1  4C 6D 0F             JMP     GENTWO          ;gen$two(getaddr)
0019E2  1               NOFNGN
0019E2  1  A5 85                LDA     STYPMP
0019E4  1  29 03                AND     #3              ;if stypemp and 3 = 0
0019E6  1  F0 05                BEQ     *+7             ;then
0019E8  1  A9 04                LDA     #4              ;incorrect number parameters
0019EA  1  20 AB 0A             JSR     ERROR
0019ED  1  A5 82                LDA     TYPEMP
0019EF  1  20 F4 0C             JSR     GENERT          ;generate(typemp)
0019F2  1  A5 85                LDA     STYPMP
0019F4  1  29 40                AND     #%01000000      ;if not rol(stypemp,2)
0019F6  1  F0 05                BEQ     *+7             ;then
0019F8  1  A9 32                LDA     #STRING
0019FA  1  4C CE 0C             JMP     STSTMP          ;setstypemp(string)
0019FD  1  A9 31                LDA     #FLOTPT
0019FF  1  4C CE 0C             JMP     STSTMP          ;setstypemp(floatpt)
001A02  1               ;enter$parm
001A02  1               ENTRPR
001A02  1  2C 05 34             BIT     PASS1           ;if pass 1
001A05  1  30 01                BMI     *+3             ;then
001A07  1  60                   RTS
001A08  1  A5 7D                LDA     MPP1
001A0A  1  20 9E 15             JSR     STLKUP          ;setlookup(mpp1)
001A0D  1  20 77 12             JSR     ENTER
001A10  1  20 C0 15             JSR     CNTPRT
001A13  1  20 97 10             JSR     SETRSV          ;setaddr(countprt)
001A16  1  A5 84                LDA     STYPM1
001A18  1  20 71 13             JSR     SETSUB          ;setsubtype(stypemp1)
001A1B  1  A9 00                LDA     #SIMVAR
001A1D  1  20 27 11             JSR     SETTYP          ;setype(simvar)
001A20  1  A6 82                LDX     TYPEMP
001A22  1  E8                   INX
001A23  1  8A                   TXA
001A24  1  4C D4 0C             JMP     STTYMP          ;settypemp(typemp+1)
001A27  1               ;synthesis
001A27  1               ;main code generation routine
001A27  1               SYNTHE
001A27  1  85 B8                STA     PRODCT          ;save production
001A29  1  AD 06 34             LDA     PASS2           ;if not pass 2
001A2C  1  2D 07 34             AND     LSTPRD          ;and listprod
001A2F  1  F0 11                BEQ     NPPROD          ;then
001A31  1  A9 94                LDA     #<PRDMSG
001A33  1  A0 33                LDY     #>PRDMSG
001A35  1  20 FC 08             JSR     PRNMSG          ;print message
001A38  1  A5 B8                LDA     PRODCT
001A3A  1  A0 00                LDY     #0
001A3C  1  20 70 08             JSR     PRNDEC          ;print number
001A3F  1  20 34 08             JSR     CRLF
001A42  1               NPPROD
001A42  1  20 3F 0C             JSR     SCOPY           ;set up simple variables
001A45  1  A5 B8                LDA     PRODCT          ;get number
001A47  1  0A                   ASL     A               ;make word index
001A48  1  AA                   TAX                     ;make index
001A49  1  B0 0F                BCS     GT127           ;branch if > 127
001A4B  1  BD 69 1A             LDA     PRODL,X
001A4E  1  8D 58 1A             STA     JPROD+1
001A51  1  BD 6A 1A             LDA     PRODL+1,X
001A54  1  8D 59 1A             STA     JPROD+2         ;set address
001A57  1               JPROD
001A57  1  4C FF FF             JMP     $FFFF           ;do it
001A5A  1               GT127
001A5A  1  BD 69 1B             LDA     PRODH,X
001A5D  1  8D 58 1A             STA     JPROD+1
001A60  1  BD 6A 1B             LDA     PRODH+1,X
001A63  1  8D 59 1A             STA     JPROD+2
001A66  1  4C 57 1A             JMP     JPROD           ;same for high
001A69  1               ;production jump table for 0 - 127
001A69  1               PRODL
001A69  1  9B 1B 9B 1B          .WORD   PRN,PRN,PR2,PR3,CHKULE,CHKULE,PRN,PRN
001A6D  1  9C 1B D1 1B  
001A71  1  DF 17 DF 17  
001A79  1  9B 1B 9B 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A7D  1  9B 1B 9B 1B  
001A81  1  9B 1B 9B 1B  
001A89  1  9B 1B 9B 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001A8D  1  9B 1B 9B 1B  
001A91  1  9B 1B 9B 1B  
001A99  1  9B 1B 9B 1B          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PR30,PR31
001A9D  1  9B 1B 9B 1B  
001AA1  1  9B 1B 9B 1B  
001AA9  1  9B 1B EF 1B          .WORD   PRN,PR33,PR34,PR35,PRN,PR37,PRN,PR39
001AAD  1  FA 1B FF 1B  
001AB1  1  9B 1B 04 1C  
001AB9  1  9B 1B 1A 1C          .WORD   PRN,PR41,PRN,PR43,PR44,CHKTY3,PR46,PRN
001ABD  1  9B 1B 38 1C  
001AC1  1  4B 1C 2C 16  
001AC9  1  61 1C 6C 1C          .WORD   PR48,PR49,PRN,PR51,PR52,PRN,PRN,PR55
001ACD  1  9B 1B 77 1C  
001AD1  1  82 1C 9B 1B  
001AD9  1  99 1C 9E 1C          .WORD   PR56,PR57,PR58,CHKTY5,PR60,FNCGEN,GENPRM,PR63
001ADD  1  CF 1C 53 16  
001AE1  1  EE 1C C0 19  
001AE9  1  02 1D 27 1D          .WORD   PR64,PR65,GENCON,PR67,PR68,PR69,PR69,PR71
001AED  1  E4 18 35 1D  
001AF1  1  3C 1D 41 1D  
001AF9  1  46 1D 4B 1D          .WORD   PR71,PR73,PR74,PR75,PR75,PR77,PR78,PR79
001AFD  1  50 1D 55 1D  
001B01  1  55 1D 5A 1D  
001B09  1  19 1F 1E 1F          .WORD   PR80,PR81,PR82,PR82,PR84,PRN,RESLBL,PR87
001B0D  1  67 1F 67 1F  
001B11  1  6C 1F 9B 1B  
001B19  1  8C 1F 9F 1F          .WORD   PR88,PR89,PR90,ENTRPR,PR92,PR92,ENTRPR,PRN
001B1D  1  C4 1F 02 1A  
001B21  1  F6 1F F6 1F  
001B29  1  9B 1B 9B 1B          .WORD   PRN,PRN,PR98,CHKTY4,PR100,PRN,SUBCAL,SUBCAL
001B2D  1  FB 1F 45 16  
001B31  1  17 20 9B 1B  
001B39  1  1D 20 29 20          .WORD   PR104,PR105,CHKTY5,PRN,PR108,PR108,PR110,PRN
001B3D  1  53 16 9B 1B  
001B41  1  5C 20 5C 20  
001B49  1  7F 20 89 20          .WORD   PR112,PR113,SEINPU,GETFLD,GETFLD,PR117,PRN,PR119
001B4D  1  81 16 A1 16  
001B51  1  A1 16 79 20  
001B59  1  2F 19 2F 19          .WORD   PUTFLD,PUTFLD,PRN,PUTFLD,PUTFLD,PRN,PR126,PR127
001B5D  1  9B 1B 2F 19  
001B61  1  2F 19 9B 1B  
001B69  1               ;production jump table for 128 - 255
001B69  1               PRODH
001B69  1  AE 20 9B 1B          .WORD   PR128,PRN,PR130,RESLBL,GENON2,PR133,GENON,PR135
001B6D  1  C7 20 06 18  
001B71  1  E9 16 D2 20  
001B79  1  F0 20 F8 20          .WORD   PR136,PR137,PR138,PRN,PRN,PRN,PRN,GENWID
001B7D  1  02 21 9B 1B  
001B81  1  9B 1B 9B 1B  
001B89  1  F2 16 9B 1B          .WORD   GENNXT,PRN,GENWID,PR147,PR148,PR149,PR150,PR151
001B8D  1  99 17 0E 21  
001B91  1  2F 21 34 21  
001B99  1  A6 21                .WORD   PR152
001B9B  1               ;productions not already defined by single no-parameter subroutines
001B9B  1               PRN
001B9B  1  60                   RTS                     ;do nothing - used a lot !!!!
001B9C  1               ;2	<line number>::=<number>
001B9C  1               PR2
001B9C  1  A5 7B                LDA     SP
001B9E  1  20 AE 15             JSR     LKONLY          ;lookup$only(sp)
001BA1  1  F0 27                BEQ     PR2D            ;if false
001BA3  1  20 60 11             JSR     GETRES          ;see if resolved
001BA6  1  F0 13                BEQ     PR2C            ;if not
001BA8  1  20 85 11             JSR     GETADR          ;getaddr
001BAB  1  C5 B2                CMP     CODESI          ;try low
001BAD  1  D0 04                BNE     PR2A            ;error if <>
001BAF  1  C4 B3                CPY     CODESI+1
001BB1  1  F0 05                BEQ     *+7             ;ok if same
001BB3  1               PR2A
001BB3  1  A9 00                LDA     #0              ;duplicate labels
001BB5  1  20 AB 0A             JSR     ERROR
001BB8  1  4C 88 0F             JMP     LINENU
001BBB  1               PR2C
001BBB  1  A5 B2                LDA     CODESI
001BBD  1  A4 B3                LDY     CODESI+1
001BBF  1  20 97 10             JSR     SETRSV          ;setaddr(codesize)
001BC2  1  A9 08                LDA     #LABLE
001BC4  1  20 27 11             JSR     SETTYP          ;setype(lable)
001BC7  1  4C 88 0F             JMP     LINENU
001BCA  1               PR2D
001BCA  1  A9 2A                LDA     #'*'
001BCC  1  85 74                STA     SEPRTR          ;separator=astrik
001BCE  1  4C 88 0F             JMP     LINENU
001BD1  1               ;3	|
001BD1  1               PR3
001BD1  1  A9 3A                LDA     #':'            ;set separator
001BD3  1  85 74                STA     SEPRTR
001BD5  1  4C 88 0F             JMP     LINENU          ;then do line number
001BD8  1               ;30	<assignmemt>::=<assign head><expression>
001BD8  1               PR30
001BD8  1  20 1B 16             JSR     CHKTY2          ;if not chktyp2
001BDB  1  F0 03                BEQ     *+5             ;then
001BDD  1  4C 71 16             JMP     GENSTR          ;else gen$store
001BE0  1  60                   RTS
001BE1  1               ;31	<assign head>::=<variable>=
001BE1  1               PR31
001BE1  1  A5 82                LDA     TYPEMP
001BE3  1  C9 00                CMP     #SIMVAR         ;if typemp=simvar
001BE5  1  F0 01                BEQ     *+3             ;then
001BE7  1  60                   RTS
001BE8  1  A5 8A                LDA     SYMLMP
001BEA  1  A4 8B                LDY     SYMLMP+1
001BEC  1  4C 76 0F             JMP     LITERL          ;literal(symlocmp)
001BEF  1               ;33	|<expression><or><logical factor>
001BEF  1               PR33
001BEF  1  20 06 16             JSR     CHKTY1          ;if chktyp1
001BF2  1  D0 01                BNE     *+3             ;then
001BF4  1  60                   RTS
001BF5  1  A5 81                LDA     TYPEM1
001BF7  1  4C F4 0C             JMP     GENERT          ;generate(typemp1)
001BFA  1               ;34	<or>::=or
001BFA  1               PR34
001BFA  1  A9 0D                LDA     #BOR
001BFC  1  4C C2 0C             JMP     STTYSP          ;settypesp(bor)
001BFF  1               ;35	|xor
001BFF  1               PR35
001BFF  1  A9 5D                LDA     #EXR
001C01  1  4C C2 0C             JMP     STTYSP          ;sttysp
001C04  1               ;37	<logical secondary>
001C04  1               PR37
001C04  1  20 06 16             JSR     CHKTY1          ;if chktyp1
001C07  1  D0 01                BNE     *+3             ;then
001C09  1  60                   RTS
001C0A  1  A9 0C                LDA     #ANDO
001C0C  1  4C F4 0C             JMP     GENERT          ;generate(ando)
001C0F  1               ;39	|not <logical primary>
001C0F  1               PR39
001C0F  1  20 2C 16             JSR     CHKTY3          ;if chktyp3
001C12  1  D0 01                BNE     *+3             ;then
001C14  1  60                   RTS
001C15  1  A9 0B                LDA     #NOT
001C17  1  4C F4 0C             JMP     GENERT          ;generate(not)
001C1A  1               ;41	<arithmetic expression>
001C1A  1               PR41
001C1A  1  20 1B 16             JSR     CHKTY2          ;if chktyp2
001C1D  1  D0 01                BNE     *+3             ;then
001C1F  1  60                   RTS
001C20  1  A5 83                LDA     STYPSP
001C22  1  C9 31                CMP     #FLOTPT         ;if stypesp<>floatpt
001C24  1  D0 05                BNE     PR41A           ;then
001C26  1  A5 81                LDA     TYPEM1
001C28  1  4C F4 0C             JMP     GENERT          ;generate(typemp1)
001C2B  1               PR41A
001C2B  1  18                   CLC
001C2C  1  A5 81                LDA     TYPEM1
001C2E  1  69 10                ADC     #16
001C30  1  20 F4 0C             JSR     GENERT          ;generate(typemp1+16)
001C33  1  A9 31                LDA     #FLOTPT
001C35  1  4C CE 0C             JMP     STSTMP          ;setstypemp(floatpt)
001C38  1               ;43	|<arithmetic expression>+<term>
001C38  1               PR43
001C38  1  20 1B 16             JSR     CHKTY2          ;if chktyp2
001C3B  1  D0 01                BNE     *+3             ;then
001C3D  1  60                   RTS
001C3E  1  A9 00                LDA     #FAD
001C40  1  A4 83                LDY     STYPSP
001C42  1  C0 31                CPY     #FLOTPT         ;if stypesp=floatpt
001C44  1  F0 02                BEQ     *+4             ;then generate(fad)
001C46  1  A9 1D                LDA     #CAT
001C48  1  4C F4 0C             JMP     GENERT          ;else generate(cat)
001C4B  1               ;44	|<arithmetic expression>-<term>
001C4B  1               PR44
001C4B  1  20 06 16             JSR     CHKTY1          ;if chktyp1
001C4E  1  D0 01                BNE     *+3             ;then
001C50  1  60                   RTS
001C51  1  A9 01                LDA     #FMI
001C53  1  4C F4 0C             JMP     GENERT          ;generate(fmi)
001C56  1               ;46	|-<term>
001C56  1               PR46
001C56  1  20 2C 16             JSR     CHKTY3          ;if chktyp3
001C59  1  D0 01                BNE     *+3             ;then
001C5B  1  60                   RTS
001C5C  1  A9 30                LDA     #NEG
001C5E  1  4C F4 0C             JMP     GENERT          ;generate(neg)
001C61  1               ;48	|<term>*<primary>
001C61  1               PR48
001C61  1  20 06 16             JSR     CHKTY1          ;if chktyp1
001C64  1  D0 01                BNE     *+3             ;then
001C66  1  60                   RTS
001C67  1  A9 02                LDA     #FMU
001C69  1  4C F4 0C             JMP     GENERT          ;generate(fmu)
001C6C  1               ;49	|<term>/<primary>
001C6C  1               PR49
001C6C  1  20 06 16             JSR     CHKTY1          ;if chktyp1
001C6F  1  D0 01                BNE     *+3             ;then
001C71  1  60                   RTS
001C72  1  A9 03                LDA     #FDI
001C74  1  4C F4 0C             JMP     GENERT          ;generate(fdi)
001C77  1               ;51	|<primary>**<element>
001C77  1               PR51
001C77  1  20 06 16             JSR     CHKTY1          ;the chktyp1
001C7A  1  D0 01                BNE     *+3             ;then
001C7C  1  60                   RTS
001C7D  1  A9 04                LDA     #EXP
001C7F  1  4C F4 0C             JMP     GENERT          ;generate(exp)
001C82  1               ;52	<element>::=<variable>
001C82  1               PR52
001C82  1  A5 80                LDA     TYPESP          ;if typesp
001C84  1  C9 00                CMP     #SIMVAR         ;= simvar
001C86  1  F0 05                BEQ     *+7             ;then
001C88  1  A9 0E                LDA     #LOD
001C8A  1  4C F4 0C             JMP     GENERT          ;else generate(lod)
001C8D  1  A5 86                LDA     SYMLSP
001C8F  1  A4 87                LDY     SYMLSP+1
001C91  1  4C 7F 0F             JMP     LITLOD          ;litload(symlocsp)
001C94  1               ;55	|(<expression>)
001C94  1               PR55
001C94  1  A5 84                LDA     STYPM1
001C96  1  4C CE 0C             JMP     STSTMP          ;setstypemp(stypemp1)
001C99  1               ;56	<variable>::=<identifier>
001C99  1               PR56
001C99  1  A5 7B                LDA     SP
001C9B  1  4C 1A 18             JMP     PSIMPV          ;process$simple$variable(sp)
001C9E  1               ;57	|<subscript head><expression>
001C9E  1               PR57
001C9E  1  2C 0F 34             BIT     FORSTM          ;if not forstmt
001CA1  1  10 05                BPL     *+7             ;then
001CA3  1  A9 03                LDA     #3              ;for index not simple variable
001CA5  1  20 AB 0A             JSR     ERROR
001CA8  1  20 53 16             JSR     CHKTY5          ;chktyp5
001CAB  1  A5 8A                LDA     SYMLMP
001CAD  1  A4 8B                LDY     SYMLMP+1
001CAF  1  85 A7                STA     BASE
001CB1  1  84 A8                STY     BASE+1          ;base=symlocsp
001CB3  1  20 91 13             JSR     GETSUB          ;if getsubtype
001CB6  1  C5 82                CMP     TYPEMP          ;= typemp
001CB8  1  F0 05                BEQ     *+7             ;then
001CBA  1  A9 11                LDA     #17             ;incorrect number subscripts
001CBC  1  20 AB 0A             JSR     ERROR
001CBF  1  20 85 11             JSR     GETADR
001CC2  1  20 7F 0F             JSR     LITLOD          ;litload(getaddr)
001CC5  1  A9 21                LDA     #SUB
001CC7  1  20 F4 0C             JSR     GENERT          ;generate(subo)
001CCA  1  A9 02                LDA     #SUBVAR
001CCC  1  4C D4 0C             JMP     STTYMP          ;settypemp(subvar)
001CCF  1               ;58	<subscript head>::=<identifier>(
001CCF  1               PR58
001CCF  1  A5 7C                LDA     MP
001CD1  1  20 AE 15             JSR     LKONLY          ;lookup$only(mp)
001CD4  1  F0 07                BEQ     PR58A           ;if not then error
001CD6  1  20 07 11             JSR     GETTYP          ;if getype
001CD9  1  C9 02                CMP     #SUBVAR         ;= subvar
001CDB  1  F0 05                BEQ     *+7             ;then ok
001CDD  1               PR58A
001CDD  1  A9 0A                LDA     #10             ;subscripted variable not dimensioned
001CDF  1  20 AB 0A             JSR     ERROR
001CE2  1  A9 00                LDA     #0
001CE4  1  20 D4 0C             JSR     STTYMP          ;settypemp(0)
001CE7  1  A5 A7                LDA     BASE
001CE9  1  A4 A8                LDY     BASE+1
001CEB  1  4C BC 0C             JMP     STSLMP          ;setsymlocmp(base)
001CEE  1               ;60	<function call>::=<function heading><expression>
001CEE  1               PR60
001CEE  1  20 81 19             JSR     CHKPRM          ;checkparm
001CF1  1  A5 91                LDA     SRLOMP
001CF3  1  A4 92                LDY     SRLOMP+1
001CF5  1  85 8F                STA     SRLOSP
001CF7  1  84 90                STY     SRLOSP+1        ;srlocsp=srlocmp
001CF9  1  4C C0 19             JMP     FNCGEN          ;funcgen
001CFC  1               ;63	|<function heading><expression>
001CFC  1               PR63
001CFC  1  20 81 19             JSR     CHKPRM          ;check$parm
001CFF  1  4C 5B 19             JMP     GENPRM          ;gen$parm
001D02  1               ;64	<function name>::=<user defined name>
001D02  1               PR64
001D02  1  A5 7B                LDA     SP
001D04  1  20 AE 15             JSR     LKONLY          ;if lookup$only(sp)
001D07  1  D0 05                BNE     *+7             ;then
001D09  1  A9 06                LDA     #6              ;function undefined
001D0B  1  4C AB 0A             JMP     ERROR
001D0E  1  A5 A7                LDA     BASE
001D10  1  A4 A8                LDY     BASE+1
001D12  1  20 E6 0C             JSR     STSRSP          ;setsrlocsp(base)
001D15  1  A5 A7                LDA     BASE
001D17  1  A4 A8                LDY     BASE+1
001D19  1  20 AE 0C             JSR     STSLSP          ;setsymlocsp(base)
001D1C  1  A9 0A                LDA     #UNFUNC
001D1E  1  20 C2 0C             JSR     STTYSP          ;settypesp(unfunc)
001D21  1  20 07 11             JSR     GETTYP
001D24  1  4C E0 0C             JMP     STHASP          ;sethashsp(getype)
001D27  1               ;65	|<predefined name>
001D27  1               PR65
001D27  1  A5 4B                LDA     FUNCOP
001D29  1  20 C2 0C             JSR     STTYSP          ;settypesp(funcop)
001D2C  1  A5 83                LDA     STYPSP
001D2E  1  4A                   LSR     A
001D2F  1  4A                   LSR     A               ;shr(stypesp,2)
001D30  1  29 07                AND     #7
001D32  1  4C E0 0C             JMP     STHASP          ;sethashsp( )
001D35  1               ;67	|<string>
001D35  1               PR67
001D35  1  A9 4E                LDA     #<ACCUM
001D37  1  A0 00                LDY     #>ACCUM
001D39  1  4C 87 18             JMP     GENILS          ;gen$ils(.accum)
001D3C  1               ;68	<relation>::= =
001D3C  1               PR68
001D3C  1  A9 07                LDA     #7
001D3E  1  4C C2 0C             JMP     STTYSP          ;settypesp(7)
001D41  1               ;69	| >= | GE
001D41  1               PR69
001D41  1  A9 09                LDA     #9
001D43  1  4C D4 0C             JMP     STTYMP          ;settypemp(9)
001D46  1               ;71	| <= | LE
001D46  1               PR71
001D46  1  A9 0A                LDA     #10
001D48  1  4C D4 0C             JMP     STTYMP          ;settypemp(10)
001D4B  1               ;73	| >
001D4B  1               PR73
001D4B  1  A9 06                LDA     #6
001D4D  1  4C C2 0C             JMP     STTYSP          ;settypesp(6)
001D50  1               ;74	| <
001D50  1               PR74
001D50  1  A9 05                LDA     #5
001D52  1  4C C2 0C             JMP     STTYSP          ;settypesp(5)
001D55  1               ;75	| <> | NE
001D55  1               PR75
001D55  1  A9 08                LDA     #8
001D57  1  4C D4 0C             JMP     STTYMP          ;settypemp(8)
001D5A  1               ;77	<for statement>::=<for head> to <expression> <step clause>
001D5A  1               PR77
001D5A  1  A0 06                LDY     #3*2            ;word addressing
001D5C  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D60  1  B5 A5 C9 00  
001D64  1  D0 04 A2 00  
001D72  1  85 A7                STA     BASE
001D74  1  C8                   INY
001D75  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001D79  1  B5 A5 C9 00  
001D7D  1  D0 04 A2 00  
001D8B  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001D8D  1  A5 80                LDA     TYPESP          ;if not typesp
001D8F  1  4A                   LSR     A
001D90  1  90 05                BCC     *+7             ;then
001D92  1  A9 12                LDA     #DUP
001D94  1  20 F4 0C             JSR     GENERT          ;generate(dup)
001D97  1  20 85 11             JSR     GETADR
001D9A  1  20 7F 0F             JSR     LITLOD          ;litload(getaddr)
001D9D  1  A9 00                LDA     #FAD
001D9F  1  20 F4 0C             JSR     GENERT          ;generate(fad)
001DA2  1  A5 80                LDA     TYPESP          ;if not
001DA4  1  4A                   LSR     A               ;typesp
001DA5  1  90 0B                BCC     PR77A           ;then
001DA7  1  20 85 11             JSR     GETADR
001DAA  1  20 76 0F             JSR     LITERL          ;literal(getaddr)
001DAD  1  A9 13                LDA     #XCH
001DAF  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001DB2  1               PR77A
001DB2  1  A9 0F                LDA     #STO
001DB4  1  20 F4 0C             JSR     GENERT          ;generate(sto)
001DB7  1  A5 80                LDA     TYPESP          ;if not
001DB9  1  4A                   LSR     A               ;typesp
001DBA  1  90 2D                BCC     PR77B           ;then
001DBC  1  A9 13                LDA     #XCH
001DBE  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001DC1  1  A9 00                LDA     #0
001DC3  1  A8                   TAY
001DC4  1  20 76 0F             JSR     LITERL          ;literal(0)
001DC7  1  A9 05                LDA     #LSS
001DC9  1  20 F4 0C             JSR     GENERT          ;generate(lss)
001DCC  1  A9 05                LDA     #5
001DCE  1  A0 00                LDY     #0
001DD0  1  20 76 0F             JSR     LITERL          ;literal(5)
001DD3  1  A9 38                LDA     #BFC
001DD5  1  20 F4 0C             JSR     GENERT          ;generate(bfc)
001DD8  1  A9 0A                LDA     #LEQ
001DDA  1  20 F4 0C             JSR     GENERT          ;generate(leq)
001DDD  1  A9 02                LDA     #2
001DDF  1  A0 00                LDY     #0
001DE1  1  20 76 0F             JSR     LITERL          ;literal(2)
001DE4  1  A9 39                LDA     #BFN
001DE6  1  20 F4 0C             JSR     GENERT          ;generate(bfn)
001DE9  1               PR77B
001DE9  1  A9 09                LDA     #GEQ
001DEB  1  20 F4 0C             JSR     GENERT          ;generate(beq)
001DEE  1  A9 37                LDA     #BRC
001DF0  1  20 F4 0C             JSR     GENERT          ;generate(brc)
001DF3  1  A0 00                LDY     #0*2            ;word address
001DF5  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001DF9  1  B5 A5 C9 00  
001DFD  1  D0 04 A2 00  
001E0B  1  48                   PHA
001E0C  1  C8                   INY
001E0D  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E11  1  B5 A5 C9 00  
001E15  1  D0 04 A2 00  
001E23  1  A8                   TAY
001E24  1  68                   PLA
001E25  1  20 6D 0F             JSR     GENTWO          ;gen$two(foraddress(0))
001E28  1  A0 02                LDY     #1*2            ;word addressing
001E2A  1  A5 B2                LDA     CODESI
001E2C  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001E30  1  01 B5 A5 C9  
001E34  1  00 D0 04 A2  
001E42  1  C8                   INY
001E43  1  A5 B3                LDA     CODESI+1
001E45  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(1)=codesize
001E49  1  01 B5 A5 C9  
001E4D  1  00 D0 04 A2  
001E5B  1  60                   RTS
001E5C  1               ;78	<for head>::=<for><assignment>
001E5C  1               PR78
001E5C  1  A9 36                LDA     #BRS
001E5E  1  20 F4 0C             JSR     GENERT          ;generate(brs)
001E61  1  A0 02                LDY     #1*2            ;word addressing
001E63  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E67  1  B5 A5 C9 00  
001E6B  1  D0 04 A2 00  
001E79  1  48                   PHA
001E7A  1  C8                   INY
001E7B  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001E7F  1  B5 A5 C9 00  
001E83  1  D0 04 A2 00  
001E91  1  A8                   TAY
001E92  1  68                   PLA
001E93  1  20 6D 0F             JSR     GENTWO          ;gen$two(foraddress(1))
001E96  1  A0 04                LDY     #2*2            ;word addressing
001E98  1  A5 B2                LDA     CODESI
001E9A  1  8B DA 48 A2          STAINDIRECTY SBTTOP
001E9E  1  01 B5 A5 C9  
001EA2  1  00 D0 04 A2  
001EB0  1  C8                   INY
001EB1  1  A5 B3                LDA     CODESI+1
001EB3  1  8B DA 48 A2          STAINDIRECTY SBTTOP     ;foraddress(2)=codesize
001EB7  1  01 B5 A5 C9  
001EBB  1  00 D0 04 A2  
001EC9  1  60                   RTS
001ECA  1               ;79	<for>::= for
001ECA  1               PR79
001ECA  1  A9 FF                LDA     #TRUE
001ECC  1  8D 0F 34             STA     FORSTM          ;forstmt=true
001ECF  1  38                   SEC
001ED0  1  A5 A5                LDA     SBTTOP
001ED2  1  E9 08                SBC     #8
001ED4  1  85 A5                STA     SBTTOP
001ED6  1  85 B9                STA     NXSTPT
001ED8  1  A4 A6                LDY     SBTTOP+1
001EDA  1  B0 01                BCS     *+3
001EDC  1  88                   DEY
001EDD  1  84 A6                STY     SBTTOP+1
001EDF  1  84 BA                STY     NXSTPT+1        ;sbtbltop,nextstmtptr=sbtbltop-8
001EE1  1  A0 01                LDY     #1
001EE3  1  8B DA A2 01          LDAINDIRECTY NXSTPT
001EE7  1  B5 B9 C9 00  
001EEB  1  D0 04 A2 00  
001EF9  1  29 7F                AND     #$7F
001EFB  1  8B DA 48 A2          STAINDIRECTY NXSTPT     ;nextbytev(1)=nextbytev(1) and $7f
001EFF  1  01 B5 B9 C9  
001F03  1  00 D0 04 A2  
001F11  1  A9 00                LDA     #0
001F13  1  20 7A 10             JSR     LIMITS          ;limits(0)
001F16  1  E6 A9                INC     FORCNT          ;forcount=forcount+1
001F18  1  60                   RTS
001F19  1               ;80	<step clause>::= step <expression>
001F19  1               PR80
001F19  1  A9 01                LDA     #1
001F1B  1  4C D4 0C             JMP     STTYMP          ;settypemp(true)
001F1E  1               ;81	|
001F1E  1               PR81
001F1E  1  A0 06                LDY     #3*2            ;word addressing
001F20  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F24  1  B5 A5 C9 00  
001F28  1  D0 04 A2 00  
001F36  1  85 A7                STA     BASE
001F38  1  C8                   INY
001F39  1  8B DA A2 01          LDAINDIRECTY SBTTOP
001F3D  1  B5 A5 C9 00  
001F41  1  D0 04 A2 00  
001F4F  1  85 A8                STA     BASE+1          ;base=foraddress(3)
001F51  1  20 85 11             JSR     GETADR
001F54  1  20 76 0F             JSR     LITERL          ;literal(getaddr)
001F57  1  A9 00                LDA     #FALSE
001F59  1  20 C2 0C             JSR     STTYSP          ;settypesp(false)
001F5C  1  A9 2E                LDA     #CON
001F5E  1  20 F4 0C             JSR     GENERT          ;generate(con)
001F61  1  A9 00                LDA     #0
001F63  1  A8                   TAY
001F64  1  4C 6D 0F             JMP     GENTWO          ;gen$two(0)
001F67  1               ;82	<if statement>::=<if group>
001F67  1               PR82
001F67  1  A9 00                LDA     #0
001F69  1  4C DB 15             JMP     ENCMLB          ;enter$compiler$label(0)
001F6C  1               ;84	| if end # <expression> then <number>
001F6C  1               PR84
001F6C  1  A9 5B                LDA     #RON
001F6E  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001F71  1  A9 5E                LDA     #DEF
001F73  1  20 F4 0C             JSR     GENERT          ;generate(def)
001F76  1  20 ED 17             JSR     FNDLBL          ;findlabel
001F79  1  20 85 11             JSR     GETADR
001F7C  1  4C 6D 0F             JMP     GENTWO          ;gen$two(getaddr)
001F7F  1               ;87	<if else group>::=<if head><statement list> else
001F7F  1               PR87
001F7F  1  A9 03                LDA     #3
001F81  1  20 DB 15             JSR     ENCMLB          ;emter$compiler$label(3)
001F84  1  A9 36                LDA     #BRS
001F86  1  20 F4 0C             JSR     GENERT          ;generate(brs)
001F89  1  4C FD 15             JMP     COMLBL          ;compiler$label
001F8C  1               ;88	<if head>::=if <expression> then
001F8C  1               PR88
001F8C  1  A5 84                LDA     STYPM1          ;if stypemp1
001F8E  1  C9 32                CMP     #STRING         ;<> string
001F90  1  D0 05                BNE     *+7             ;then
001F92  1  A9 08                LDA     #8              ;else if expression is not floating point
001F94  1  20 AB 0A             JSR     ERROR
001F97  1  A9 37                LDA     #BRC
001F99  1  20 F4 0C             JSR     GENERT          ;generate(brc)
001F9C  1  4C FD 15             JMP     COMLBL          ;compiler$label
001F9F  1               ;89	<dummy argument list>::=<expresssion>
001F9F  1               PR89
001F9F  1  20 1B 16             JSR     CHKTY2          ;if chkty2
001FA2  1  D0 01                BNE     *+3             ;the
001FA4  1  60                   RTS
001FA5  1  A5 8A                LDA     SYMLMP
001FA7  1  A4 8B                LDY     SYMLMP+1
001FA9  1  85 A7                STA     BASE
001FAB  1  84 A8                STY     BASE+1
001FAD  1  A5 81                LDA     TYPEM1
001FAF  1  20 27 11             JSR     SETTYP          ;setype(typemp1)
001FB2  1  20 AF 13             JSR     UNLINK
001FB5  1  A9 13                LDA     #XCH
001FB7  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001FBA  1  A9 1F                LDA     #RTN
001FBC  1  20 F4 0C             JSR     GENERT          ;generate(rtn)
001FBF  1  A9 00                LDA     #0
001FC1  1  4C DB 15             JMP     ENCMLB          ;enter$compiler$label(0)
001FC4  1               ;90	(ud function name>::= def <user defined name>
001FC4  1               PR90
001FC4  1  A9 36                LDA     #BRS
001FC6  1  20 F4 0C             JSR     GENERT          ;generate(brs)
001FC9  1  20 FD 15             JSR     COMLBL          ;compiler$label
001FCC  1  A5 7B                LDA     SP
001FCE  1  20 B4 15             JSR     NRMLKU          ;normal$lookup(sp)
001FD1  1  48                   PHA                     ;save result
001FD2  1  A5 83                LDA     STYPSP
001FD4  1  20 CE 0C             JSR     STSTMP          ;setstypemp(stypesp)
001FD7  1  A5 A7                LDA     BASE
001FD9  1  A4 A8                LDY     BASE+1
001FDB  1  20 BC 0C             JSR     STSLMP          ;setsymlocmp(base)
001FDE  1  2C 05 34             BIT     PASS1           ;if pass 1
001FE1  1  30 04                BMI     *+6             ;then
001FE3  1  68                   PLA                     ;clear stack
001FE4  1  4C AE 14             JMP     RELINK
001FE7  1  68                   PLA                     ;if not flag
001FE8  1  F0 05                BEQ     *+7             ;then
001FEA  1  A9 02                LDA     #2              ;else function name previously defined
001FEC  1  20 AB 0A             JSR     ERROR
001FEF  1  A5 B2                LDA     CODESI
001FF1  1  A4 B3                LDY     CODESI+1
001FF3  1  4C 97 10             JMP     SETRSV          ;setaddr(codesize)
001FF6  1               ;92	|
001FF6  1               PR92
001FF6  1  A9 00                LDA     #0
001FF8  1  4C D4 0C             JMP     STTYMP          ;settypemp(0)
001FFB  1               ;98	<file decleration>::=<identifier><file rec size>
001FFB  1               PR98
001FFB  1  A5 7C                LDA     MP
001FFD  1  20 1A 18             JSR     PSIMPV          ;process$simple$variable(mp)
002000  1  A5 85                LDA     STYPMP          ;if stypemp
002002  1  C9 31                CMP     #FLOTPT         ;<> floatpt
002004  1  D0 05                BNE     *+7             ;then
002006  1  A9 17                LDA     #23             ;invalid type in file
002008  1  20 AB 0A             JSR     ERROR
00200B  1  A5 86                LDA     SYMLSP
00200D  1  A4 87                LDY     SYMLSP+1
00200F  1  20 7F 0F             JSR     LITLOD          ;litload(symlocsp)
002012  1  A9 2D                LDA     #OPN
002014  1  4C F4 0C             JMP     GENERT          ;generate(opn)
002017  1               ;100	|
002017  1               PR100
002017  1  A9 00                LDA     #0
002019  1  A8                   TAY
00201A  1  4C 76 0F             JMP     LITERL          ;literal(0)
00201D  1               ;104	<dimension variable>::=<dim var head><expression>
00201D  1               PR104
00201D  1  20 53 16             JSR     CHKTY5          ;chktyp5
002020  1  A5 8A                LDA     SYMLMP
002022  1  A4 8B                LDY     SYMLMP+1
002024  1  85 A7                STA     BASE
002026  1  84 A8                STY     BASE+1          ;base=symlocsp
002028  1  60                   RTS
002029  1               ;105	<dim var head>::=<identifier>(
002029  1               PR105
002029  1  A5 7C                LDA     MP
00202B  1  20 B4 15             JSR     NRMLKU          ;if not normal$lookup(mp)
00202E  1  F0 0A                BEQ     PR105A          ;then
002030  1  2C 05 34             BIT     PASS1           ;if not pass 1
002033  1  10 05                BPL     PR105A          ;then
002035  1  A9 01                LDA     #1              ;identifier in dim previously defined
002037  1  20 AB 0A             JSR     ERROR
00203A  1               PR105A
00203A  1  A9 02                LDA     #SUBVAR
00203C  1  20 27 11             JSR     SETTYP          ;setype(subvar)
00203F  1  2C 05 34             BIT     PASS1           ;if not pass 1
002042  1  10 06                BPL     *+8             ;then
002044  1  20 C0 15             JSR     CNTPRT
002047  1  20 97 10             JSR     SETRSV          ;setaddr(countprt)
00204A  1  20 85 11             JSR     GETADR
00204D  1  20 76 0F             JSR     LITERL          ;literal(getaddr)
002050  1  A9 00                LDA     #0
002052  1  20 D4 0C             JSR     STTYMP          ;settypemp(0)
002055  1  A5 A7                LDA     BASE
002057  1  A4 A8                LDY     BASE+1
002059  1  4C BC 0C             JMP     STSLMP          ;setsymlocmp(base)
00205C  1               ;108	<close list>::=<expression>
00205C  1               PR108
00205C  1  A5 83                LDA     STYPSP          ;if stypesp
00205E  1  C9 32                CMP     #STRING         ;<> string
002060  1  D0 03                BNE     *+5             ;then
002062  1  20 40 16             JSR     MFERR           ;must be floating
002065  1  A9 5B                LDA     #RON
002067  1  20 F4 0C             JSR     GENERT          ;generate(ron)
00206A  1  A9 40                LDA     #CLS
00206C  1  4C F4 0C             JMP     GENERT          ;generate(cls)
00206F  1               ;110	<read statement>::= read <file option><read list>
00206F  1               PR110
00206F  1  2C 10 34             BIT     FILEIO          ;if not fileio
002072  1  10 0A                BPL     PR110A          ;then
002074  1  A9 3E                LDA     #EDR
002076  1  20 F4 0C             JSR     GENERT          ;generate(edr)
002079  1               ;117	|
002079  1               PR117
002079  1  A9 00                LDA     #FALSE
00207B  1  8D 10 34             STA     FILEIO          ;fileio=false
00207E  1               PR110A
00207E  1  60                   RTS
00207F  1               ;112	<input statement>::=input <prompt option><read list>
00207F  1               PR112
00207F  1  A9 27                LDA     #ECR
002081  1  20 F4 0C             JSR     GENERT          ;generate(ecr)
002084  1  A9 00                LDA     #FALSE
002086  1  85 47                STA     INPSTM          ;inputstmt=false
002088  1  60                   RTS
002089  1               ;113	<prompt option>::=<constant>
002089  1               PR113
002089  1  20 2F 19             JSR     PUTFLD          ;put$field
00208C  1  4C 81 16             JMP     SEINPU          ;setup$input
00208F  1               ;119	|print <file option><file list>
00208F  1               PR119
00208F  1  A9 3F                LDA     #EDW
002091  1  20 F4 0C             JSR     GENERT          ;generate(edw)
002094  1  A9 00                LDA     #FALSE
002096  1  8D 10 34             STA     FILEIO          ;fileio=false
002099  1  60                   RTS
00209A  1               ;126	|
00209A  1               PR126
00209A  1  A9 34                LDA     #DBF
00209C  1  4C F4 0C             JMP     GENERT          ;generate(dbf)
00209F  1               ;127	<file option>::= # <expression>
00209F  1               PR127
00209F  1  A9 FF                LDA     #TRUE
0020A1  1  8D 10 34             STA     FILEIO          ;fileio=true
0020A4  1  A9 5B                LDA     #RON
0020A6  1  20 F4 0C             JSR     GENERT          ;generate(ron)
0020A9  1  A9 26                LDA     #RDB
0020AB  1  4C F4 0C             JMP     GENERT          ;generate(rdb)
0020AE  1               ;128	| # <expression>,<expression>;
0020AE  1               PR128
0020AE  1  A9 FF                LDA     #TRUE
0020B0  1  8D 10 34             STA     FILEIO          ;fileio=true
0020B3  1  A9 5B                LDA     #RON
0020B5  1  20 F4 0C             JSR     GENERT          ;generate(ron)
0020B8  1  A9 13                LDA     #XCH
0020BA  1  20 F4 0C             JSR     GENERT          ;generate(xch)
0020BD  1  A9 5B                LDA     #RON
0020BF  1  20 F4 0C             JSR     GENERT          ;generate(ron)
0020C2  1  A9 25                LDA     #RDF
0020C4  1  4C F4 0C             JMP     GENERT          ;generate(rdf)
0020C7  1               ;130	| ,
0020C7  1               PR130
0020C7  1  2C 10 34             BIT     FILEIO          ;if not fileio
0020CA  1  10 01                BPL     *+3             ;then
0020CC  1  60                   RTS
0020CD  1  A9 35                LDA     #NSP
0020CF  1  4C F4 0C             JMP     GENERT          ;generate(nsp)
0020D2  1               ;133	|<on gosub> <label list>
0020D2  1               PR133
0020D2  1  20 E9 16             JSR     GENON2          ;gen$on$2
0020D5  1  A9 00                LDA     #0
0020D7  1  4C DB 15             JMP     ENCMLB          ;enter$compiler$label(0)
0020DA  1               ;135	<on gosub>::= on <expression> <gosub>
0020DA  1               PR135
0020DA  1  20 F4 15             JSR     STCMLB          ;set$compiler$label
0020DD  1  20 85 11             JSR     GETADR
0020E0  1  20 76 0F             JSR     LITERL          ;literal(getaddr)
0020E3  1  A9 60                LDA     #ADJ
0020E5  1  20 F4 0C             JSR     GENERT          ;generate(adj)
0020E8  1  A9 13                LDA     #XCH
0020EA  1  20 F4 0C             JSR     GENERT          ;generate(xch)
0020ED  1  4C CC 16             JMP     GENON           ;gen$on
0020F0  1               ;136	<label list>::=<number>
0020F0  1               PR136
0020F0  1  20 06 18             JSR     RESLBL          ;resolve$label
0020F3  1  A9 01                LDA     #1
0020F5  1  4C C2 0C             JMP     STTYSP          ;settypesp(1)
0020F8  1               ;137	|<label list>,<number>
0020F8  1               PR137
0020F8  1  20 06 18             JSR     RESLBL          ;resolve$label
0020FB  1  A6 82                LDX     TYPEMP
0020FD  1  E8                   INX
0020FE  1  8A                   TXA
0020FF  1  4C D4 0C             JMP     STTYMP          ;settypemp(typemp+1)
002102  1               ;138	<gosub statement>::=<gosub><number>
002102  1               PR138
002102  1  A9 FF                LDA     #TRUE
002104  1  85 48                STA     GSBSTM          ;gosubstmt=true
002106  1  20 06 18             JSR     RESLBL          ;resolve$label
002109  1  A9 00                LDA     #FALSE
00210B  1  85 48                STA     GSBSTM          ;gosubstmt=false
00210D  1  60                   RTS
00210E  1               ;147	<out statement>::= out <expression>,<expression>
00210E  1               PR147
00210E  1  A9 31                LDA     #FLOTPT         ;if stypemp1
002110  1  C5 84                CMP     STYPM1          ;<> floatpt
002112  1  D0 04                BNE     *+6             ;then
002114  1  C5 83                CMP     STYPSP          ;if stypesp = floatpt
002116  1  F0 03                BEQ     *+5             ;then ok
002118  1  4C 40 16             JMP     MFERR           ;must be floating error
00211B  1  A9 5B                LDA     #RON
00211D  1  20 F4 0C             JSR     GENERT          ;generate(ron)
002120  1  A9 13                LDA     #XCH
002122  1  20 F4 0C             JSR     GENERT          ;generate(xch)
002125  1  A9 5B                LDA     #RON
002127  1  20 F4 0C             JSR     GENERT          ;generate(ron)
00212A  1  A9 28                LDA     #POT
00212C  1  4C F4 0C             JMP     GENERT          ;generate(pot)
00212F  1               ;148	<return statement>::= return
00212F  1               PR148
00212F  1  A9 1F                LDA     #RTN
002131  1  4C F4 0C             JMP     GENERT          ;generate(rtn)
002134  1               ;149	<stop statement>::= stop
002134  1               PR149
002134  1  A9 10                LDA     #XIT
002136  1  4C F4 0C             JMP     GENERT          ;generate(xit)
002139  1               ;150	<end statement>::= end
002139  1               PR150
002139  1  2C 05 34             BIT     PASS1           ;if not pass 1
00213C  1  10 33                BPL     PR150B          ;then
00213E  1  A9 00                LDA     #FALSE
002140  1  8D 05 34             STA     PASS1           ;pass1=false
002143  1  A5 A9                LDA     FORCNT          ;if forcount
002145  1  F0 09                BEQ     PR150A          ;= zero then ok
002147  1  A9 18                LDA     #24             ;else for without next error
002149  1  20 AB 0A             JSR     ERROR
00214C  1  A9 00                LDA     #0
00214E  1  85 A9                STA     FORCNT          ;forcount=0
002150  1               PR150A
002150  1  A9 2A                LDA     #'*'
002152  1  20 F4 0C             JSR     GENERT          ;generate('*')
002155  1  18                   CLC
002156  1  A5 B2                LDA     CODESI
002158  1  A4 B3                LDY     CODESI+1
00215A  1  69 03                ADC     #3
00215C  1  90 01                BCC     *+3
00215E  1  C8                   INY
00215F  1  29 FC                AND     #$FC
002161  1  20 6D 0F             JSR     GENTWO          ;gen$two((codesize+3) and $fffc)
002164  1  A5 45                LDA     DATACT
002166  1  A4 46                LDY     DATACT+1
002168  1  20 6D 0F             JSR     GENTWO          ;gen$two(datact)
00216B  1  20 C0 15             JSR     CNTPRT
00216E  1  4C 6D 0F             JMP     GENTWO          ;gen$two(countprt)
002171  1               PR150B
002171  1  A5 4D                LDA     NXTCHR
002173  1  C9 0D                CMP     #CR
002175  1  F0 06                BEQ     *+8
002177  1  20 15 0A             JSR     GETCHR
00217A  1  4C 71 21             JMP     PR150B          ;while not eol
00217D  1  A9 10                LDA     #XIT
00217F  1  20 F4 0C             JSR     GENERT          ;generate(xit)
002182  1  A9 7F                LDA     #$7F
002184  1  20 F4 0C             JSR     GENERT          ;generate($7f)
002187  1  20 94 09             JSR     WRTINT          ;write$int$file
00218A  1  20 4E 09             JSR     CLSINT          ;close$int$file
00218D  1  A5 43                LDA     ERRCNT
00218F  1  A4 44                LDY     ERRCNT+1
002191  1  20 70 08             JSR     PRNDEC          ;printdec(errorcount)
002194  1  A9 9A                LDA     #<ERDMSG
002196  1  A0 33                LDY     #>ERDMSG
002198  1  20 FC 08             JSR     PRNMSG          ;print('errors detected')
00219B  1  20 34 08             JSR     CRLF
00219E  1  4C 00 01             JMP     BOOT
0021A1  1               ;151	<restore statement>::= restore
0021A1  1               PR151
0021A1  1  A9 2F                LDA     #RST
0021A3  1  4C F4 0C             JMP     GENERT          ;generate(rst)
0021A6  1               ;152	<randomize statement>::= randomize
0021A6  1               PR152
0021A6  1  A9 4D                LDA     #IRN
0021A8  1  4C F4 0C             JMP     GENERT          ;generate(irn)
0021AB  1               ;getin1  (does ay=index1(state))
0021AB  1               GETIN1
0021AB  1  A5 79                LDA     STATE
0021AD  1  A4 7A                LDY     STATE+1         ;get state
0021AF  1  0A                   ASL     A
0021B0  1  AA                   TAX
0021B1  1  98                   TYA
0021B2  1  2A                   ROL     A
0021B3  1  A8                   TAY
0021B4  1  18                   CLC
0021B5  1  8A                   TXA
0021B6  1  69 B3                ADC     #<INDEX1        ;add state*2 since is word addressing
0021B8  1  8D CF 21             STA     GT+1
0021BB  1  98                   TYA
0021BC  1  69 2A                ADC     #>INDEX1
0021BE  1  8D D0 21             STA     GT+2
0021C1  1  A2 00                LDX     #0
0021C3  1  20 CE 21             JSR     GT              ;get low
0021C6  1  48                   PHA
0021C7  1  E8                   INX
0021C8  1  20 CE 21             JSR     GT              ;get high
0021CB  1  A8                   TAY
0021CC  1  68                   PLA
0021CD  1  60                   RTS
0021CE  1               ;general purpose lda abs,x routine
0021CE  1               GT
0021CE  1  BD FF FF             LDA     $FFFF,X
0021D1  1  60                   RTS
0021D2  1               ;getin2 (does ay=index2(state))
0021D2  1               GETIN2
0021D2  1  A5 79                LDA     STATE
0021D4  1  A4 7A                LDY     STATE+1
0021D6  1  18                   CLC
0021D7  1  69 5F                ADC     #<INDEX2
0021D9  1  8D E3 21             STA     G2+1
0021DC  1  98                   TYA
0021DD  1  69 2D                ADC     #>INDEX2
0021DF  1  8D E4 21             STA     G2+2
0021E2  1               G2
0021E2  1  AD FF FF             LDA     $FFFF
0021E5  1  A0 00                LDY     #0              ;y always zero
0021E7  1  60                   RTS
0021E8  1               ;incsp
0021E8  1               INCSP
0021E8  1  E6 7B                INC     SP
0021EA  1  A5 7B                LDA     SP              ;bump and get
0021EC  1  C9 20                CMP     #PSTKSZ         ;compare to max
0021EE  1  F0 01                BEQ     *+3             ;if = then
0021F0  1  60                   RTS                     ;else ok
0021F1  1  A9 12                LDA     #18             ;stack overflow error
0021F3  1  4C AB 0A             JMP     ERROR
0021F6  1               ;lookahead
0021F6  1               LAHEAD
0021F6  1  24 7E                BIT     NOLOOK          ;if not nolook
0021F8  1  10 07                BPL     LAHEAX          ;then done
0021FA  1  20 AE 0D             JSR     SCANNR          ;scanner
0021FD  1  A9 00                LDA     #FALSE
0021FF  1  85 7E                STA     NOLOOK          ;nolook=false
002201  1               LAHEAX
002201  1  60                   RTS
002202  1               ;set$varc$i ---- set varc and increment varindex
002202  1               STVRCI
002202  1  A6 7F                LDX     VARIND
002204  1  9D FF 35             STA     VARC,X          ;save
002207  1  E8                   INX
002208  1  86 7F                STX     VARIND          ;bump index
00220A  1  E0 65                CPX     #VARCSZ+1       ;if too big
00220C  1  B0 01                BCS     *+3             ;then error
00220E  1  60                   RTS
00220F  1  A9 15                LDA     #21             ;varc overflow
002211  1  4C AB 0A             JMP     ERROR
002214  1               ;initialize all of system
002214  1               INTLZ
002214  1  20 9A 0F             JSR     INSYMT          ;in$symtbl
002217  1  20 20 15             JSR     INSYN           ;in$syn
00221A  1  4C 1A 0B             JMP     INSCAN
00221D  1               ;MAIN PROGRAM
00221D  1               MAIN
00221D  1  A2 02                LDX     #2              ;clear page zero
00221F  1  A9 00                LDA     #0
002221  1               PZC
002221  1  95 00                STA     0,X
002223  1  E8                   INX
002224  1  E0 C6                CPX     #LZ
002226  1  D0 F9                BNE     PZC
002228  1  A9 FF                LDA     #TRUE           ;initialize once
00222A  1  8D 05 34             STA     PASS1
00222D  1  8D 0A 34             STA     LWRUPR
002230  1  A9 3A                LDA     #':'
002232  1  85 74                STA     SEPRTR
002234  1  A9 80                LDA     #SRCRSZ
002236  1  85 75                STA     SRCIND
002238  1  A9 E0                LDA     #<OPNMSG
00223A  1  A0 33                LDY     #>OPNMSG
00223C  1  20 FC 08             JSR     PRNMSG          ;print opening message
00223F  1  20 34 08             JSR     CRLF
002242  1  20 14 22             JSR     INTLZ           ;initialize all
002245  1               ;do forever
002245  1               ;do while (pass1 or pass2)
002245  1               M10
002245  1  2C 05 34             BIT     PASS1           ;if pass 1
002248  1  30 08                BMI     M12             ;then go
00224A  1  2C 06 34             BIT     PASS2           ;or if
00224D  1  30 03                BMI     M12             ;pass2 go
00224F  1  4C F7 24             JMP     EWP1P2          ;else end of do while pass1 or pass2
002252  1               M12
002252  1  A9 FF                LDA     #TRUE
002254  1  85 7E                STA     NOLOOK          ;nolook=true
002256  1  8D 0E 34             STA     CMPLNG          ;compiling=true
002259  1  A9 79                LDA     #<STARTS
00225B  1  A0 00                LDY     #>STARTS
00225D  1  85 79                STA     STATE
00225F  1  84 7A                STY     STATE+1         ;state=startstate
002261  1  A9 FF                LDA     #255
002263  1  85 7B                STA     SP              ;sp=255
002265  1  A9 00                LDA     #0
002267  1  85 7F                STA     VARIND          ;varind=0
002269  1  8D DF 34             STA     VAR
00226C  1               ;do while compiling
00226C  1               M14
00226C  1  2C 0E 34             BIT     CMPLNG          ;test for compiling
00226F  1  10 D4                BPL     M10             ;branch if not
002271  1  A9 78                LDA     #<MAXRNO
002273  1  C5 79                CMP     STATE
002275  1  A9 00                LDA     #>MAXRNO
002277  1  E5 7A                SBC     STATE+1         ;if state>maxrno
002279  1  B0 03                BCS     *+5             ;continue if ok
00227B  1  4C 7A 23             JMP     M30             ;else try next
00227E  1  20 E8 21             JSR     INCSP
002281  1  A5 7B                LDA     SP
002283  1  0A                   ASL     A               ;word addressing
002284  1  AA                   TAX
002285  1  A5 79                LDA     STATE
002287  1  9D BF 35             STA     STSTAK,X
00228A  1  A5 7A                LDA     STATE+1
00228C  1  9D C0 35             STA     STSTAK+1,X      ;statestack(sp)=state
00228F  1  20 AB 21             JSR     GETIN1
002292  1  85 98                STA     I
002294  1  84 99                STY     I+1             ;i=getin1
002296  1  20 F6 21             JSR     LAHEAD          ;lookahead
002299  1  20 D2 21             JSR     GETIN2          ;index2(state)
00229C  1  18                   CLC
00229D  1  65 98                ADC     I
00229F  1  85 9A                STA     J
0022A1  1  98                   TYA
0022A2  1  65 99                ADC     I+1
0022A4  1  85 9B                STA     J+1
0022A6  1  A5 9A                LDA     J
0022A8  1  D0 02                BNE     *+4
0022AA  1  C6 9B                DEC     J+1
0022AC  1  C6 9A                DEC     J               ;j=i-1+getin2
0022AE  1               M20
0022AE  1  A5 9A                LDA     J
0022B0  1  C5 98                CMP     I
0022B2  1  A5 9B                LDA     J+1
0022B4  1  E5 99                SBC     I+1             ;if i>j
0022B6  1  90 B4                BCC     M14             ;go to while compiling
0022B8  1  18                   CLC
0022B9  1  A5 98                LDA     I
0022BB  1  69 07                ADC     #<READ1
0022BD  1  85 9F                STA     I2
0022BF  1  A5 99                LDA     I+1
0022C1  1  69 25                ADC     #>READ1
0022C3  1  85 A0                STA     I2+1
0022C5  1  A0 00                LDY     #0
0022C7  1  8B DA A2 01          LDAINDIRECTY I2         ;a=read(i)
0022CB  1  B5 9F C9 00  
0022CF  1  D0 04 A2 00  
0022DD  1  C5 49                CMP     TOKEN           ;if not token
0022DF  1  D0 7F                BNE     M23             ;then
0022E1  1  A5 7F                LDA     VARIND          ;get varindex
0022E3  1  A6 7B                LDX     SP
0022E5  1  9D DF 34             STA     VAR,X           ;set var(sp)
0022E8  1  A2 00                LDX     #0
0022EA  1  86 9E                STX     INDEX           ;index=0
0022EC  1               M22
0022EC  1  B5 4E                LDA     ACCUM,X         ;accum(index)
0022EE  1  20 02 22             JSR     STVRCI
0022F1  1  E6 9E                INC     INDEX           ;index=index+1
0022F3  1  A6 9E                LDX     INDEX
0022F5  1  E4 4E                CPX     ACCLEN          ;if < length
0022F7  1  90 F3                BCC     M22             ;then loop
0022F9  1  F0 F1                BEQ     M22             ;loop also if equal
0022FB  1  A6 7B                LDX     SP
0022FD  1  A5 4C                LDA     HSHCDE
0022FF  1  9D BF 34             STA     HASH,X          ;hash(sp)=hashcode
002302  1  A5 4A                LDA     SUBTYP
002304  1  9D 1F 35             STA     STYPE,X         ;stype(sp)=subtype
002307  1  A5 98                LDA     I
002309  1  0A                   ASL     A
00230A  1  85 9F                STA     I2
00230C  1  A5 99                LDA     I+1
00230E  1  2A                   ROL     A
00230F  1  85 A0                STA     I2+1            ;i2=i*2
002311  1  18                   CLC
002312  1  A5 9F                LDA     I2
002314  1  69 EB                ADC     #<READ2
002316  1  85 9F                STA     I2
002318  1  A5 A0                LDA     I2+1
00231A  1  69 26                ADC     #>READ2
00231C  1  85 A0                STA     I2+1            ;read2(i)
00231E  1  A0 00                LDY     #0
002320  1  8B DA A2 01          LDAINDIRECTY I2         ;low
002324  1  B5 9F C9 00  
002328  1  D0 04 A2 00  
002336  1  85 79                STA     STATE
002338  1  C8                   INY
002339  1  8B DA A2 01          LDAINDIRECTY I2
00233D  1  B5 9F C9 00  
002341  1  D0 04 A2 00  
00234F  1  85 7A                STA     STATE+1         ;state=read2(i)
002351  1  A9 FF                LDA     #TRUE
002353  1  85 7E                STA     NOLOOK          ;nolook=true
002355  1  A5 9A                LDA     J
002357  1  A4 9B                LDY     J+1
002359  1  85 98                STA     I
00235B  1  84 99                STY     I+1
00235D  1  4C 71 23             JMP     M24
002360  1               M23
002360  1  A5 98                LDA     I
002362  1  C5 9A                CMP     J               ;ok if different
002364  1  D0 0B                BNE     M24
002366  1  A5 99                LDA     I+1
002368  1  C5 9B                CMP     J+1
00236A  1  D0 05                BNE     M24             ;ok if different
00236C  1  A9 0F                LDA     #15             ;no legal production
00236E  1  20 AB 0A             JSR     ERROR
002371  1               M24
002371  1  E6 98                INC     I               ;bump i and loop
002373  1  D0 02                BNE     *+4
002375  1  E6 99                INC     I+1
002377  1  4C AE 22             JMP     M20
00237A  1               M30
00237A  1  A9 BD                LDA     #<MAXPNO        ;if state <= maxpno
00237C  1  C5 79                CMP     STATE
00237E  1  A9 00                LDA     #>MAXPNO
002380  1  E5 7A                SBC     STATE+1
002382  1  90 03                BCC     *+5
002384  1  4C 3A 24             JMP     M40
002387  1  20 D2 21             JSR     GETIN2          ;index2(state)
00238A  1  85 98                STA     I               ;ignore high
00238C  1  38                   SEC
00238D  1  A5 7B                LDA     SP
00238F  1  E5 98                SBC     I
002391  1  85 7C                STA     MP              ;mp=sp-getin2
002393  1  A8                   TAY
002394  1  C8                   INY
002395  1  84 7D                STY     MPP1            ;mpp1=mp+1
002397  1  38                   SEC
002398  1  A5 79                LDA     STATE
00239A  1  E9 BD                SBC     #<MAXPNO        ;parameter=state-maxpno
00239C  1  20 27 1A             JSR     SYNTHE          ;synthesize(state-maxpno)
00239F  1  2C 0E 34             BIT     CMPLNG          ;if compiling
0023A2  1  30 03                BMI     *+5             ;then go
0023A4  1  4C 45 22             JMP     M10             ;else go to do while pass 1 or pass 2
0023A7  1  A5 7C                LDA     MP
0023A9  1  85 7B                STA     SP              ;sp=mp
0023AB  1  20 AB 21             JSR     GETIN1
0023AE  1  85 98                STA     I
0023B0  1  84 99                STY     I+1             ;i=getin1
0023B2  1  A6 7B                LDX     SP
0023B4  1  BD DF 34             LDA     VAR,X
0023B7  1  85 7F                STA     VARIND          ;varindex=var(sp)
0023B9  1  8A                   TXA
0023BA  1  0A                   ASL     A
0023BB  1  AA                   TAX                     ;word addressing
0023BC  1  BD BF 35             LDA     STSTAK,X
0023BF  1  85 9A                STA     J
0023C1  1  BD C0 35             LDA     STSTAK+1,X
0023C4  1  85 9B                STA     J+1             ;j=statestack(sp)
0023C6  1               M31
0023C6  1  A2 00                LDX     #0
0023C8  1  86 9D                STX     K+1             ;high must be zero
0023CA  1  A6 98                LDX     I
0023CC  1  BD 6B 26             LDA     APPLY1,X
0023CF  1  85 9C                STA     K
0023D1  1  F0 11                BEQ     M33             ;exit if k=0
0023D3  1  C5 9A                CMP     J
0023D5  1  D0 04                BNE     M32             ;ok if low k <> low j
0023D7  1  A5 9B                LDA     J+1
0023D9  1  F0 09                BEQ     M33             ;if =0 then j=k
0023DB  1               M32
0023DB  1  E6 98                INC     I
0023DD  1  D0 E7                BNE     M31             ;loop
0023DF  1  E6 99                INC     I+1
0023E1  1  4C C6 23             JMP     M31
0023E4  1               M33
0023E4  1  A5 98                LDA     I               ;ignore high i
0023E6  1  0A                   ASL     A
0023E7  1  85 9F                STA     I2
0023E9  1  A5 99                LDA     I+1
0023EB  1  2A                   ROL     A
0023EC  1  85 A0                STA     I2+1
0023EE  1  18                   CLC
0023EF  1  A5 9F                LDA     I2
0023F1  1  69 B3                ADC     #<APPLY2
0023F3  1  85 9F                STA     I2
0023F5  1  A5 A0                LDA     I2+1
0023F7  1  69 29                ADC     #>APPLY2
0023F9  1  85 A0                STA     I2+1
0023FB  1  A0 00                LDY     #0
0023FD  1  8B DA A2 01          LDAINDIRECTY I2
002401  1  B5 9F C9 00  
002405  1  D0 04 A2 00  
002413  1  85 79                STA     STATE
002415  1  C8                   INY
002416  1  8B DA A2 01          LDAINDIRECTY I2
00241A  1  B5 9F C9 00  
00241E  1  D0 04 A2 00  
00242C  1  85 7A                STA     STATE+1         ;state=apply2(i)
00242E  1  05 79                ORA     STATE
002430  1  D0 05                BNE     *+7             ;if not zero then
002432  1  A9 00                LDA     #FALSE
002434  1  8D 0E 34             STA     CMPLNG          ;compiling=false
002437  1  4C 6C 22             JMP     M14
00243A  1               M40
00243A  1  A9 AF                LDA     #<MAXLNO        ;if state
00243C  1  C5 79                CMP     STATE
00243E  1  A9 00                LDA     #>MAXLNO
002440  1  E5 7A                SBC     STATE+1         ;> maxlno
002442  1  90 02 80 03          LBCC     M50            ;then go to next
002446  1  4C DA 24     
002449  1  20 AB 21             JSR     GETIN1
00244C  1  85 98                STA     I
00244E  1  84 99                STY     I+1             ;i=getin1
002450  1  20 F6 21             JSR     LAHEAD          ;lookahead
002453  1               M41
002453  1  A2 00                LDX     #0
002455  1  86 9D                STX     K+1
002457  1  18                   CLC
002458  1  A5 98                LDA     I
00245A  1  69 D4                ADC     #<LOOK1
00245C  1  85 9F                STA     I2
00245E  1  A5 99                LDA     I+1
002460  1  69 25                ADC     #>LOOK1
002462  1  85 A0                STA     I2+1
002464  1  A0 00                LDY     #0
002466  1  8B DA A2 01          LDAINDIRECTY I2         ;a=look1(i)
00246A  1  B5 9F C9 00  
00246E  1  D0 04 A2 00  
00247C  1  85 9C                STA     K
00247E  1  F0 0D                BEQ     M42             ;exit if k=0
002480  1  C5 49                CMP     TOKEN
002482  1  F0 09                BEQ     M42             ;or if =token
002484  1  E6 98                INC     I               ;bump and loop
002486  1  D0 CB                BNE     M41
002488  1  E6 99                INC     I+1
00248A  1  4C 53 24             JMP     M41
00248D  1               M42
00248D  1  A5 98                LDA     I               ;word addressing
00248F  1  0A                   ASL     A
002490  1  85 9F                STA     I2
002492  1  A5 99                LDA     I+1
002494  1  2A                   ROL     A
002495  1  85 A0                STA     I2+1
002497  1  18                   CLC
002498  1  A5 9F                LDA     I2              ;add start
00249A  1  69 85                ADC     #<LOOK2
00249C  1  85 9F                STA     I2
00249E  1  A5 A0                LDA     I2+1
0024A0  1  69 28                ADC     #>LOOK2
0024A2  1  85 A0                STA     I2+1
0024A4  1  A0 00                LDY     #0
0024A6  1  8B DA A2 01          LDAINDIRECTY I2         ;low
0024AA  1  B5 9F C9 00  
0024AE  1  D0 04 A2 00  
0024BC  1  85 79                STA     STATE
0024BE  1  C8                   INY
0024BF  1  8B DA A2 01          LDAINDIRECTY I2
0024C3  1  B5 9F C9 00  
0024C7  1  D0 04 A2 00  
0024D5  1  85 7A                STA     STATE+1
0024D7  1  4C 6C 22             JMP     M14
0024DA  1               M50
0024DA  1  20 E8 21             JSR     INCSP
0024DD  1  20 D2 21             JSR     GETIN2
0024E0  1  48                   PHA                     ;save low
0024E1  1  A5 7B                LDA     SP
0024E3  1  0A                   ASL     A               ;word addressing
0024E4  1  AA                   TAX
0024E5  1  68                   PLA
0024E6  1  9D BF 35             STA     STSTAK,X        ;statestack(sp)=getin2
0024E9  1  98                   TYA
0024EA  1  9D C0 35             STA     STSTAK+1,X
0024ED  1  20 AB 21             JSR     GETIN1
0024F0  1  85 79                STA     STATE
0024F2  1  84 7A                STY     STATE+1         ;state=getin1
0024F4  1  4C 6C 22             JMP     M14
0024F7  1               ;end of do while pass 1 or pass 2
0024F7  1               EWP1P2
0024F7  1  A9 FF                LDA     #TRUE
0024F9  1  8D 08 34             STA     LSTSRC          ;listsource=true
0024FC  1  20 14 22             JSR     INTLZ           ;initialize
0024FF  1  A9 FF                LDA     #TRUE
002501  1  8D 06 34             STA     PASS2           ;pass2=true
002504  1  4C 45 22             JMP     M10             ;do forever
002507  1               ;parser state tables
002507  1               READ1
002507  1  00 31 0A 0D          .BYTE   0,49,10,13,2,49,50,52,53,54,49,13,22,32,2,3,7,27,30,49,50,52,53
00250B  1  02 31 32 34  
00250F  1  35 36 31 0D  
00251E  1  36 02 03 07          .BYTE   54,2,3,7,30,49,50,52,53,54,54,52,12,52,2,3,7,49,50,52,53,54,12
002522  1  1E 31 32 34  
002526  1  35 36 36 34  
002535  1  34 31 31 32          .BYTE   52,49,49,50,2,3,7,12,30,49,50,52,53,54,2,2,2,9,5,9,49,4,8,49,16
002539  1  02 03 07 0C  
00253D  1  1E 31 32 34  
00254E  1  14 1C 1D 1F          .BYTE   20,28,29,31,35,36,37,38,40,42,43,44,45,46,48,49,51,52,49,14,6
002552  1  23 24 25 26  
002556  1  28 2A 2B 2C  
002563  1  16 0D 34 09          .BYTE   22,13,52,9,52,9,23,9,21,33,41,16,21,33,36,43,9,21,33,5,9,21,33
002567  1  34 09 17 09  
00256B  1  15 21 29 10  
00257A  1  05 15 21 05          .BYTE   5,21,33,5,9,21,33,5,9,21,33,6,9,21,33,21,33,39,21,33,41,5,21,33
00257E  1  09 15 21 05  
002582  1  09 15 21 06  
002592  1  06 15 21 09          .BYTE   6,21,33,9,6,9,16,17,20,25,26,27,28,29,31,35,36,37,38,40,42,43
002596  1  06 09 10 11  
00259A  1  14 19 1A 1B  
0025A8  1  2C 2D 2E 30          .BYTE   44,45,46,48,51,52,2,16,20,28,29,31,35,36,37,38,40,42,43,44,45
0025AC  1  33 34 02 10  
0025B0  1  14 1C 1D 1F  
0025BD  1  2E 30 33 34          .BYTE   46,48,51,52,52,13,24,11,34,9,2,1,3,7,10,13,15,18,19,3,7,9,0
0025C1  1  34 0D 18 0B  
0025C5  1  22 09 02 01  
0025D4  1               LOOK1
0025D4  1  00 31 00 0A          .BYTE   0,49,0,10,13,0,13,0,11,23,34,0,52,0,12,52,0,49,50,0,6,9,11,23
0025D8  1  0D 00 0D 00  
0025DC  1  0B 17 22 00  
0025EC  1  22 00 02 00          .BYTE   34,0,2,0,2,0,9,0,4,8,0,4,8,0,4,8,0,4,8,0,4,8,0,11,23,34,0,14,0
0025F0  1  02 00 09 00  
0025F4  1  04 08 00 04  
002609  1  0E 00 0E 00          .BYTE   14,0,14,0,9,0,9,0,9,0,9,0,9,0,21,33,0,21,33,0,21,33,0,21,33,0
00260D  1  09 00 09 00  
002611  1  09 00 09 00  
002623  1  15 21 27 00          .BYTE   21,33,39,0,21,33,0,21,33,0,21,33,0,23,0,21,33,0,21,33,0,9,0,9
002627  1  15 21 00 15  
00262B  1  21 00 15 21  
00263B  1  00 06 09 00          .BYTE   0,6,9,0,52,0,11,23,0,11,23,34,0,2,0,11,23,0,52,0,24,0,24,0,11
00263F  1  34 00 0B 17  
002643  1  00 0B 17 22  
002654  1  00 17 00 0B          .BYTE   0,23,0,11,0,9,0,2,0,1,3,7,10,13,15,18,19,0,3,7,0,9,0
002658  1  00 09 00 02  
00265C  1  00 01 03 07  
00266B  1               APPLY1
00266B  1  00 00 00 00          .BYTE   0,0,0,0,55,105,0,19,0,0,32,47,0,0,3,4,12,14,16,17,20,21,22,26
00266F  1  37 69 00 13  
002673  1  00 00 20 2F  
002683  1  1B 22 24 26          .BYTE   27,34,36,38,40,98,100,102,103,114,116,0,0,46,0,28,0,33,0,63,0,5
002687  1  28 62 64 66  
00268B  1  67 72 74 00  
002699  1  06 08 09 00          .BYTE   6,8,9,0,7,10,0,23,0,13,19,32,35,47,55,99,101,105,106,0,0,0,0,0
00269D  1  07 0A 00 17  
0026A1  1  00 0D 13 20  
0026B1  1  27 00 00 00          .BYTE   39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,99
0026B5  1  00 00 00 00  
0026B9  1  00 00 00 00  
0026CF  1  6A 00 00 00          .BYTE   106,0,0,0,0,0,40,0,0,0,0,0,0,62,0,0,74,0,74,0,0,0,0,0,0,0,0,0
0026D3  1  00 00 28 00  
0026D7  1  00 00 00 00  
0026EB  1               READ2
0026EB  1  00 00 BF 00          .WORD   0,191,264,260,3,255,256,129,254,253,326,258,329,331,3,5,8,31
0026EF  1  08 01 04 01  
0026F3  1  03 00 FF 00  
00270F  1  21 00 FF 00          .WORD   33,255,256,129,254,253,3,5,8,33,255,256,129,254,253,279,42,21
002713  1  00 01 81 00  
002717  1  FE 00 FD 00  
002733  1  81 00 03 00          .WORD   129,3,5,8,255,256,129,254,253,20,129,273,255,256,3,5,8,20,33
002737  1  05 00 08 00  
00273B  1  FF 00 00 01  
002759  1  FF 00 00 01          .WORD   255,256,129,254,253,247,294,4,335,280,283,320,7,10,327,24,26
00275D  1  81 00 FE 00  
002761  1  FD 00 F7 00  
00277B  1  0C 01 20 00          .WORD   268,32,34,285,328,125,126,338,38,330,127,128,337,340,275,341
00277F  1  22 00 1D 01  
002783  1  48 01 7D 00  
00279B  1  81 00 45 01          .WORD   129,325,23,302,27,220,130,17,131,13,190,14,223,224,277,24,223
00279F  1  17 00 2E 01  
0027A3  1  1B 00 DC 00  
0027BD  1  E0 00 48 01          .WORD   224,328,330,12,223,224,246,248,223,224,244,223,224,249,252,223
0027C1  1  4A 01 0C 00  
0027C5  1  DF 00 E0 00  
0027DD  1  E0 00 25 01          .WORD   224,293,295,223,224,316,16,223,224,223,224,36,223,224,37,288
0027E1  1  27 01 DF 00  
0027E5  1  E0 00 3C 01  
0027FD  1  DF 00 E0 00          .WORD   223,224,317,223,224,15,318,319,24,25,26,29,30,339,268,32,34,285
002801  1  3D 01 DF 00  
002805  1  E0 00 0F 00  
002821  1  48 01 7D 00          .WORD   328,125,126,338,38,330,127,128,337,340,341,129,251,24,26,268,32
002825  1  7E 00 52 01  
002829  1  26 00 4A 01  
002843  1  22 00 1D 01          .WORD   34,285,328,125,126,338,38,330,127,128,337,340,341,129,45,22,28
002847  1  48 01 7D 00  
00284B  1  7E 00 52 01  
002865  1  7C 00 14 01          .WORD   124,276,286,282,122,6,9,123,257,259,261,265,6,9,11,0
002869  1  1E 01 1A 01  
00286D  1  7A 00 06 00  
002885  1               LOOK2
002885  1  00 00 01 00          .WORD   0,1,176,2,2,263,18,262,177,177,177,19,334,333,35,35,178,39,39
002889  1  B0 00 02 00  
00288D  1  02 00 07 01  
0028AB  1  B3 00 B4 00          .WORD   179,180,180,180,180,180,40,41,245,43,181,44,332,49,49,231,50,50
0028AF  1  B4 00 B4 00  
0028B3  1  B4 00 B4 00  
0028CF  1  EA 00 33 00          .WORD   234,51,51,235,52,52,232,53,53,233,182,182,182,55,57,236,58,237
0028D3  1  33 00 EB 00  
0028D7  1  34 00 34 00  
0028F3  1  3B 00 EE 00          .WORD   59,238,66,308,68,300,69,299,70,301,72,296,76,76,297,77,77,309
0028F7  1  42 00 34 01  
0028FB  1  44 00 2C 01  
002917  1  4E 00 4E 00          .WORD   78,78,219,84,84,312,85,85,85,183,87,87,336,88,88,298,89,89,310
00291B  1  DB 00 54 00  
00291F  1  54 00 38 01  
00293D  1  16 01 5B 00          .WORD   278,91,93,93,313,94,94,269,95,321,96,322,97,97,184,99,185,186
002941  1  5D 00 5D 00  
002945  1  39 01 5E 00  
002961  1  BA 00 65 00          .WORD   186,101,314,314,314,102,104,250,187,187,105,106,188,109,221,110
002965  1  3A 01 3A 01  
002969  1  3A 01 66 00  
002981  1  DE 00 6F 00          .WORD   222,111,193,274,112,113,272,115,284,117,189,118,118,118,118,118
002985  1  C1 00 12 01  
002989  1  70 00 71 00  
0029A1  1  76 00 76 00          .WORD   118,118,118,229,119,119,230,120,290
0029A5  1  76 00 E5 00  
0029A9  1  77 00 77 00  
0029B3  1               APPLY2
0029B3  1  00 00 00 00          .WORD   0,0,161,71,169,170,168,199,198,200,218,267,201,98,80,90,151,152
0029B7  1  A1 00 47 00  
0029BB  1  A9 00 AA 00  
0029D7  1  5C 00 9B 00          .WORD   92,155,83,86,154,74,150,75,156,146,147,148,149,153,82,79,81,73
0029DB  1  53 00 56 00  
0029DF  1  9A 00 4A 00  
0029FB  1  2E 00 A7 00          .WORD   46,167,166,226,225,228,227,174,173,133,135,134,136,132,139,140
0029FF  1  A6 00 E2 00  
002A03  1  E1 00 E4 00  
002A1B  1  8A 00 F0 00          .WORD   138,240,239,305,64,64,304,64,64,304,64,64,304,241,114,243,116
002A1F  1  EF 00 31 01  
002A23  1  40 00 40 00  
002A3D  1  A3 00 3C 00          .WORD   163,60,242,63,202,61,47,266,194,271,164,137,197,172,108,107,204
002A41  1  F2 00 3F 00  
002A45  1  CA 00 3D 00  
002A5F  1  41 00 AB 00          .WORD   65,171,287,196,175,292,291,103,205,145,206,210,165,143,144,142
002A63  1  1F 01 C4 00  
002A67  1  AF 00 24 01  
002A7F  1  CF 00 9F 00          .WORD   207,159,141,307,100,160,162,208,213,56,62,158,157,209,323,48
002A83  1  8D 00 33 01  
002A87  1  64 00 A0 00  
002A9F  1  44 01 36 00          .WORD   324,54,203,67,216,212,211,195,214,215
002AA3  1  CB 00 43 00  
002AA7  1  D8 00 D4 00  
002AB3  1               INDEX1
002AB3  1  00 00 01 00          .WORD   0,1,2,24,24,4,4,4,4,4,4,34,24,36,24,10,24,24,11,168,24,24,24,4
002AB7  1  02 00 18 00  
002ABB  1  18 00 04 00  
002AE3  1  0C 00 0E 00          .WORD   12,14,24,24,24,33,34,35,36,37,24,45,24,47,24,48,50,60,61,62,63
002AE7  1  18 00 18 00  
002AEB  1  18 00 21 00  
002B0D  1  40 00 18 00          .WORD   64,24,36,66,67,67,67,67,67,69,70,89,90,90,90,91,92,89,37,93,94
002B11  1  24 00 42 00  
002B15  1  43 00 43 00  
002B37  1  5F 00 60 00          .WORD   95,96,97,97,97,98,99,100,103,108,100,100,100,111,115,118,122
002B3B  1  61 00 61 00  
002B3F  1  61 00 62 00  
002B59  1  7E 00 64 00          .WORD   126,100,130,133,100,100,100,136,100,139,100,100,142,142,143,24
002B5D  1  82 00 85 00  
002B61  1  64 00 64 00  
002B79  1  24 00 18 00          .WORD   36,24,145,24,24,167,168,36,186,187,188,188,189,189,189,24,191
002B7D  1  91 00 18 00  
002B81  1  18 00 A7 00  
002B9B  1  18 00 C0 00          .WORD   24,192,193,201,203,1,3,6,8,12,14,17,20,26,28,30,32,35,38,41,44
002B9F  1  C1 00 C9 00  
002BA3  1  CB 00 01 00  
002BC5  1  2F 00 33 00          .WORD   47,51,53,55,57,59,61,63,65,67,70,73,76,79,83,86,89,92,94,97,100
002BC9  1  35 00 37 00  
002BCD  1  39 00 3B 00  
002BEF  1  66 00 68 00          .WORD   102,104,107,109,112,116,118,121,123,125,127,129,131,133,135,137
002BF3  1  6B 00 6D 00  
002BF7  1  70 00 74 00  
002C0F  1  92 00 95 00          .WORD   146,149,192,217,306,303,311,289,217,270,315,306,217,217,306,281
002C13  1  C0 00 D9 00  
002C17  1  32 01 2F 01  
002C2F  1  01 00 02 00          .WORD   1,2,2,3,3,3,3,3,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,13
002C33  1  02 00 03 00  
002C37  1  03 00 03 00  
002C6D  1  0E 00 0E 00          .WORD   14,14,36,36,37,37,39,39,41,41,43,43,43,43,43,45,45,45,50,50,53
002C71  1  24 00 24 00  
002C75  1  25 00 25 00  
002C97  1  35 00 35 00          .WORD   53,53,53,55,55,66,66,67,67,68,68,69,69,70,70,72,72,72,72,72,72
002C9B  1  35 00 37 00  
002C9F  1  37 00 42 00  
002CC1  1  48 00 48 00          .WORD   72,72,72,73,74,75,76,76,77,77,77,78,78,79,80,81,82,83,83,84,84
002CC5  1  48 00 49 00  
002CC9  1  4A 00 4B 00  
002CEB  1  55 00 56 00          .WORD   85,86,86,87,88,88,89,90,90,91,93,93,94,95,95,96,96,97,98,98,99
002CEF  1  56 00 57 00  
002CF3  1  58 00 58 00  
002D15  1  63 00 63 00          .WORD   99,99,102,102,103,103,103,104,104,105,105,106,106,108,108,109
002D19  1  66 00 66 00  
002D1D  1  67 00 67 00  
002D35  1  6E 00 6E 00          .WORD   110,110,111,112,113,113,115,116,116,118,118,120,120,121,121,122
002D39  1  6F 00 70 00  
002D3D  1  71 00 71 00  
002D55  1  7B 00 7C 00          .WORD   123,124,125,126,127
002D59  1  7D 00 7E 00  
002D5D  1  7F 00        
002D5F  1               INDEX2
002D5F  1  00 01 02 09          .BYTE   0,1,2,9,9,6,6,6,6,6,6,1,9,1,9,1
002D63  1  09 06 06 06  
002D67  1  06 06 06 01  
002D6F  1  09 09 01 12          .BYTE   9,9,1,18,9,9,9,6,2,10,9,9,9,1,1
002D73  1  09 09 09 06  
002D77  1  02 0A 09 09  
002D7E  1  01 01 08 09          .BYTE   1,1,8,9,2,9,1,9,2,10,1,1,1,1,2
002D82  1  02 09 01 09  
002D86  1  02 0A 01 01  
002D8D  1  09 01 01 02          .BYTE   9,1,1,2,2,2,2,2,1,19,1,1,1,1,1,1
002D91  1  02 02 02 02  
002D95  1  01 13 01 01  
002D9D  1  01 08 01 01          .BYTE   1,8,1,1,1,1,1,1,1,1,1,3,5,3,2,2
002DA1  1  01 01 01 01  
002DA5  1  01 01 01 03  
002DAD  1  02 04 03 04          .BYTE   2,4,3,4,4,4,2,3,3,2,2,2,3,2,3,2
002DB1  1  04 04 02 03  
002DB5  1  03 02 02 02  
002DBD  1  02 01 01 02          .BYTE   2,1,1,2,9,1,9,22,9,9,1,18,1,1,1
002DC1  1  09 01 09 16  
002DC5  1  09 09 01 12  
002DCC  1  01 01 01 02          .BYTE   1,1,1,2,1,9,1,9,1,8,2,1,2,3,2,4
002DD0  1  01 09 01 09  
002DD4  1  01 08 02 01  
002DDC  1  02 03 03 06          .BYTE   2,3,3,6,2,2,2,3,3,3,3,3,4,2,2,2
002DE0  1  02 02 02 03  
002DE4  1  03 03 03 03  
002DEC  1  02 02 02 02          .BYTE   2,2,2,2,2,3,3,3,3,4,3,3,3,2,3,3
002DF0  1  02 03 03 03  
002DF4  1  03 04 03 03  
002DFC  1  02 02 03 02          .BYTE   2,2,3,2,3,4,2,3,2,2,2,2,2,2,2,2
002E00  1  03 04 02 03  
002E04  1  02 02 02 02  
002E0C  1  09 03 02 01          .BYTE   9,3,2,1,19,35,39,40,43,55,85,97
002E10  1  13 23 27 28  
002E14  1  2B 37 55 61  
002E18  1  63 65 69 6A          .BYTE   99,101,105,106,117,2,0,0,0,0,0,0
002E1C  1  75 02 00 00  
002E20  1  00 00 00 00  
002E24  1  00 00 02 00          .BYTE   0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
002E28  1  00 00 00 00  
002E2C  1  00 00 00 00  
002E33  1  00 00 00 00          .BYTE   0,0,0,0,0,0,1,1,1,0,2,0,0,0,2,0
002E37  1  00 00 01 01  
002E3B  1  01 00 02 00  
002E43  1  01 00 02 00          .BYTE   1,0,2,0,2,2,1,1,0,2,2,0,2,0,0,0
002E47  1  02 02 01 01  
002E4B  1  00 02 02 00  
002E53  1  02 00 02 01          .BYTE   2,0,2,1,2,2,0,1,2,0,0,0,0,0,1,0
002E57  1  02 02 00 01  
002E5B  1  02 00 00 00  
002E63  1  01 00 00 00          .BYTE   1,0,0,0,1,0,3,1,0,1,0,0,1,5,1,1
002E67  1  01 00 03 01  
002E6B  1  00 01 00 00  
002E73  1  02 02 03 01          .BYTE   2,2,3,1,2,0,0,2,1,0,2,1,2,0,1,0
002E77  1  02 00 00 02  
002E7B  1  01 00 02 01  
002E83  1  02 02 01 02          .BYTE   2,2,1,2,1,0,2,2,1,2,1,0,0,2,0,2
002E87  1  01 00 02 02  
002E8B  1  01 02 01 00  
002E93  1  02 00 02 00          .BYTE   2,0,2,0,0,2,0,0,2,4,0,0,1,1,1,2
002E97  1  00 02 00 00  
002E9B  1  02 04 00 00  
002EA3  1  02 00 02 01          .BYTE   2,0,2,1,0,1,0,1,1,0,0,2,3,0,0,0
002EA7  1  00 01 00 01  
002EAB  1  01 00 00 02  
002EB3  1  00 00                .BYTE   0,0
002EB5  1               ;reserved word tables
002EB5  1               ;length=1
002EB5  1               LNG1
002EB5  1  0D 3C 28 2B          .BYTE   CR,"<(+*)-,=/",semico,">:#^"
002EB9  1  2A 29 2D 2C  
002EBD  1  3D 2F 3B 3E  
002EC4  1               ;length=2
002EC4  1               LNG2
002EC4  1  49 46 54 4F          .BYTE   "IFTOGOONOREQLTGTLEGENE"
002EC8  1  47 4F 4F 4E  
002ECC  1  4F 52 45 51  
002EDA  1               ;length=3
002EDA  1               LNG3
002EDA  1  46 4F 52 4C          .BYTE   "FORLETREMDIMDEFNOTAND"
002EDE  1  45 54 52 45  
002EE2  1  4D 44 49 4D  
002EEF  1  54 41 4E 53          .BYTE   "TANSINCOSSQRTABLOGLEN"
002EF3  1  49 4E 43 4F  
002EF7  1  53 53 51 52  
002F04  1  46 52 45 41          .BYTE   "FREATNABSEXPINTEND"
002F08  1  54 4E 41 42  
002F0C  1  53 45 58 50  
002F16  1  50 4F 53 52          .BYTE   "POSRNDSGNASCVALXORSUB"
002F1A  1  4E 44 53 47  
002F1E  1  4E 41 53 43  
002F2B  1               ;length=4
002F2B  1               LNG4
002F2B  1  50 45 45 4B          .BYTE   "PEEKPOKE"
002F2F  1  50 4F 4B 45  
002F33  1  54 48 45 4E          .BYTE   "THENREADGOTOELSENEXTSTOPDATA"
002F37  1  52 45 41 44  
002F3B  1  47 4F 54 4F  
002F4F  1  46 49 4C 45          .BYTE   "FILECHR$MID$STEPSTR$CALLSINH"
002F53  1  43 48 52 24  
002F57  1  4D 49 44 24  
002F6B  1               ;length=5
002F6B  1               LNG5
002F6B  1  50 52 49 4E          .BYTE   "PRINTINPUTGOSUBCLOSELEFT$"
002F6F  1  54 49 4E 50  
002F73  1  55 54 47 4F  
002F84  1               ;length=6
002F84  1               LNG6
002F84  1  52 45 54 55          .BYTE   "RETURNRIGHT$REMARK"
002F88  1  52 4E 52 49  
002F8C  1  47 48 54 24  
002F96  1               ;length=7
002F96  1               LNG7
002F96  1  52 45 53 54          .BYTE   "RESTORE"
002F9A  1  4F 52 45     
002F9D  1               ;length=9
002F9D  1               LNG9
002F9D  1  52 41 4E 44          .BYTE   "RANDOMIZE"
002FA1  1  4F 4D 49 5A  
002FA5  1  45           
002FA6  1               ;token table
002FA6  1               ;this table must be ordered in the same order as the reserved word table.  the
002FA6  1               ;first entry does not correspond to any valid token.
002FA6  1               TK
002FA6  1  00                   .BYTE   0
002FA7  1               ;length=1
002FA7  1  17 01 02 03          .BYTE   TCR,LESST,LPARN,TPLUS,ASTRK,RPARN,TMINUS,COMMA,EQUAL,SLASH
002FAB  1  04 05 07 09  
002FAF  1  0D 08        
002FB1  1  06 0A 0B 0C          .BYTE   SCOLN,GTRT,TCOLIN,POUND,EXPON
002FB5  1  0E           
002FB6  1               ;length=2
002FB6  1  11 16 10 14          .BYTE   TIF,TTO,TGO,TON,TOR,EQUAL,LESST,GTRT,TLEQ,TGEQ,TNE
002FBA  1  15 0D 01 0A  
002FBE  1  12 0F 13     
002FC1  1               ;length=3
002FC1  1  1C 1D 00 1A          .BYTE   TFOR,TLET,TREM,TDIM,TDEF,TNOT,TAND,72,69,70,73,74,78,84,76,71
002FC5  1  19 1E 18 48  
002FC9  1  45 46 49 4A  
002FD1  1  41 4B 42 1B          .BYTE   65,75,66,TEND,79,67,68,81,88,TXOR,TSUB
002FD5  1  4F 43 44 51  
002FD9  1  58 21 20     
002FDC  1               ;length=4
002FDC  1  50 1F                .BYTE   80,TOUT
002FDE  1  29 26 24 22          .BYTE   TTHEN,TREAD,TGOTO,TELSE,TNEXT,TSTOP,TDATA,TFILE,82,85,TSTEP
002FE2  1  25 28 63 23  
002FE6  1  52 55 27     
002FE9  1  57 59 5A             .BYTE   87,89,90
002FEC  1               ;length=5
002FEC  1  2D 2C 2B 2A          .BYTE   TPRNT,TINPT,TGOSB,TCLOS,83
002FF0  1  53           
002FF1  1               ;length=6
002FF1  1  2E 56 00             .BYTE   TRETN,86,TREM
002FF4  1               ;length=7
002FF4  1  30                   .BYTE   TREST
002FF5  1               ;length=9
002FF5  1  33                   .BYTE   TIRN
002FF6  1               ;token offset table
002FF6  1               OFFSET
002FF6  1  00 00 0F 25          .BYTE   0,0,15,37,118,182,207,225,232,232
002FFA  1  76 B6 CF E1  
002FFE  1  E8 E8        
003000  1               ;reserved word count table
003000  1               ;each entry is the number of reserved words of the associated length (0 and up)
003000  1               COUNT
003000  1  00 0F 0B 1B          .BYTE   0,15,11,27,16,5,3,1,0,1
003004  1  10 05 03 01  
003008  1  00 01        
00300A  1               ;each entry is the index into the token table for the first token of the
00300A  1               ;associated length (0 and up)
00300A  1               TKOS
00300A  1  00 00 0F 1A          .BYTE   0,0,15,26,53,69,74,77,78,78
00300E  1  35 45 4A 4D  
003012  1  4E 4E        
003014  1               ;
003014  1               ST
003014  1  01 01 00 01          .BYTE   1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,5,65,70,5,71,70,65,5,1,1
003018  1  01 01 01 01  
00301C  1  01 01 01 00  
00302E  1               ;error messages
00302E  1               ERM0
00302E  1  44 55 50 4C          .BYTE   "DUPLICATE LABELS OR "
003032  1  49 43 41 54  
003036  1  45 20 4C 41  
003042  1  53 59 4E 43          .BYTE   "SYNCHRONIZATION ERROR$"
003046  1  48 52 4F 4E  
00304A  1  49 5A 41 54  
003058  1               ERM1
003058  1  49 44 45 4E          .BYTE   "IDENTIFIER IN DIM "
00305C  1  54 49 46 49  
003060  1  45 52 20 49  
00306A  1  50 52 45 56          .BYTE   "PREVIOUSLY DEFINED$"
00306E  1  49 4F 55 53  
003072  1  4C 59 20 44  
00307D  1               ERM2
00307D  1  50 52 45 44          .BYTE   "PREDEFINED FUNCTION "
003081  1  45 46 49 4E  
003085  1  45 44 20 46  
003091  1  4E 41 4D 45          .BYTE   "NAME PREVIOUSLY DEFINED$"
003095  1  20 50 52 45  
003099  1  56 49 4F 55  
0030A9  1               ERM3
0030A9  1  46 4F 52 20          .BYTE   "FOR LOOP INDEX NOT SIMPLE"
0030AD  1  4C 4F 4F 50  
0030B1  1  20 49 4E 44  
0030C2  1  20 46 4C 4F          .BYTE   " FLOATING POINT VARIABLE$"
0030C6  1  41 54 49 4E  
0030CA  1  47 20 50 4F  
0030DB  1               ERM4
0030DB  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF PARAMETERS"
0030DF  1  52 52 45 43  
0030E3  1  54 20 4E 55  
0030F9  1  20 49 4E 20          .BYTE   " IN FUNCTION REFERENCE$"
0030FD  1  46 55 4E 43  
003101  1  54 49 4F 4E  
003110  1               ERM5
003110  1  49 4E 56 41          .BYTE   "INVALID PARAMETER TYPE IN "
003114  1  4C 49 44 20  
003118  1  50 41 52 41  
00312A  1  46 55 4E 43          .BYTE   "FUNCTION REFERENCE$"
00312E  1  54 49 4F 4E  
003132  1  20 52 45 46  
00313D  1               ERM6
00313D  1  55 4E 44 45          .BYTE   "UNDEFINED FUNCTION$"
003141  1  46 49 4E 45  
003145  1  44 20 46 55  
003150  1               ERM7
003150  1  49 4E 56 41          .BYTE   "INVALID CHARACTER$"
003154  1  4C 49 44 20  
003158  1  43 48 41 52  
003162  1               ERM8
003162  1  45 58 50 52          .BYTE   "EXPRESSION IN IF STATEMENT"
003166  1  45 53 53 49  
00316A  1  4F 4E 20 49  
00317C  1  20 4E 4F 54          .BYTE   " NOT FLOATING POINT$"
003180  1  20 46 4C 4F  
003184  1  41 54 49 4E  
003190  1               ERM9
003190  1  49 4C 4C 45          .BYTE   "ILLEGAL FLOATING POINT FORMAT$"
003194  1  47 41 4C 20  
003198  1  46 4C 4F 41  
0031AE  1               ERM10
0031AE  1  53 55 42 53          .BYTE   "SUBSCRIPTED VARIABLE NOT "
0031B2  1  43 52 49 50  
0031B6  1  54 45 44 20  
0031C7  1  50 52 45 56          .BYTE   "PREVIOUSLY DIMENSIONED$"
0031CB  1  49 4F 55 53  
0031CF  1  4C 59 20 44  
0031DE  1               ERM11
0031DE  1  41 52 52 41          .BYTE   "ARRAY NAME USED AS SIMPLE"
0031E2  1  59 20 4E 41  
0031E6  1  4D 45 20 55  
0031F7  1  20 56 41 52          .BYTE   " VARAIBLE$"
0031FB  1  41 49 42 4C  
0031FF  1  45 24        
003201  1               ERM12
003201  1  53 54 52 49          .BYTE   "STRING EXPRESSION NOT ALLOWED$"
003205  1  4E 47 20 45  
003209  1  58 50 52 45  
00321F  1               ERM13
00321F  1  4D 49 58 45          .BYTE   "MIXED MODE (STRING - FLOATING)"
003223  1  44 20 4D 4F  
003227  1  44 45 20 28  
00323D  1  20 45 58 50          .BYTE   " EXPRESSION$"
003241  1  52 45 53 53  
003245  1  49 4F 4E 24  
003249  1               ERM14
003249  1  4E 45 58 54          .BYTE   "NEXT VARIABLE DOES NOT "
00324D  1  20 56 41 52  
003251  1  49 41 42 4C  
003260  1  4D 41 54 43          .BYTE   "MATCH FOR$"
003264  1  48 20 46 4F  
003268  1  52 24        
00326A  1               ERM15
00326A  1  4E 4F 20 50          .BYTE   "NO PRODUCTION EXISTS$"
00326E  1  52 4F 44 55  
003272  1  43 54 49 4F  
00327F  1               ERM16
00327F  1  4E 45 58 54          .BYTE   "NEXT STATEMENT WITHOUT "
003283  1  20 53 54 41  
003287  1  54 45 4D 45  
003296  1  4D 41 54 43          .BYTE   "MATCHING FOR$"
00329A  1  48 49 4E 47  
00329E  1  20 46 4F 52  
0032A3  1               ERM17
0032A3  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF "
0032A7  1  52 52 45 43  
0032AB  1  54 20 4E 55  
0032B7  1  53 55 42 53          .BYTE   "SUBSCRIPTS$"
0032BB  1  43 52 49 50  
0032BF  1  54 53 24     
0032C2  1               ERM18
0032C2  1  43 4F 4D 50          .BYTE   "COMPILER STACK OVERFLOW$"
0032C6  1  49 4C 45 52  
0032CA  1  20 53 54 41  
0032DA  1               ERM19
0032DA  1  53 59 4D 42          .BYTE   "SYMBOL TABLE OVERFLOW$"
0032DE  1  4F 4C 20 54  
0032E2  1  41 42 4C 45  
0032F0  1               ERM20
0032F0  1  55 4E 44 45          .BYTE   "UNDEFINED LABEL$"
0032F4  1  46 49 4E 45  
0032F8  1  44 20 4C 41  
003300  1               ERM21
003300  1  56 41 52 43          .BYTE   "VARC TABLE OVERFLOW$"
003304  1  20 54 41 42  
003308  1  4C 45 20 4F  
003314  1               ERM22
003314  1  55 4E 54 45          .BYTE   "UNTERMINATED STRING$"
003318  1  52 4D 49 4E  
00331C  1  41 54 45 44  
003328  1               ERM23
003328  1  49 4E 56 41          .BYTE   "INVALID TYPE IN FILE"
00332C  1  4C 49 44 20  
003330  1  54 59 50 45  
00333C  1  20 49 44 45          .BYTE   " IDENTIFIER$"
003340  1  4E 54 49 46  
003344  1  49 45 52 24  
003348  1               ERM24
003348  1  46 4F 52 20          .BYTE   "FOR WITHOUT MATCHING NEXT$"
00334C  1  57 49 54 48  
003350  1  4F 55 54 20  
003362  1               ;error message table
003362  1               ERMTBL
003362  1  2E 30 58 30          .WORD   ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
003366  1  7D 30 A9 30  
00336A  1  DB 30 10 31  
003372  1  62 31 90 31          .WORD   ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
003376  1  AE 31 DE 31  
00337A  1  01 32 1F 32  
003382  1  7F 32 A3 32          .WORD   ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
003386  1  C2 32 DA 32  
00338A  1  F0 32 00 33  
003392  1  48 33                .WORD   ERM24
003394  1               ;messages and strings
003394  1               PRDMSG
003394  1  50 52 4F 44          .BYTE   "PROD $"
003398  1  20 24        
00339A  1               ERDMSG
00339A  1  20 45 52 52          .BYTE   " ERRORS DETECTED$"
00339E  1  4F 52 53 20  
0033A2  1  44 45 54 45  
0033AB  1               DEMSG
0033AB  1  44 49 53 4B          .BYTE   "DISK ERROR - ABORTING $"
0033AF  1  20 45 52 52  
0033B3  1  4F 52 20 2D  
0033C2  1               BASSTR
0033C2  1  42 41 53             .BYTE   "BAS"
0033C5  1               NSMSG
0033C5  1  4E 4F 20 53          .BYTE   "NO SOURCE - ABORTING $"
0033C9  1  4F 55 52 43  
0033CD  1  45 20 2D 20  
0033DB  1               ADDEND
0033DB  1  45 4E 44 0D          .BYTE   "END",CR,LF
0033DF  1  0A           
0033E0  1               OPNMSG
0033E0  1  42 41 53 49          .BYTE   "BASIC-E/65 COMPILER - "
0033E4  1  43 2D 45 2F  
0033E8  1  36 35 20 43  
0033F6  1  56 45 52 53          .BYTE   "VERSION 2.03-A$"
0033FA  1  49 4F 4E 20  
0033FE  1  32 2E 30 33  
003405  1               ;variables - this area holds data moved from page zero to save page zero space
003405  1               PASS1
003405  1  00                   .BYTE   0               ;pass 1 if true i=TRUE
003406  1               PASS2
003406  1  00                   .BYTE   0               ;pass 2 if true
003407  1               LSTPRD
003407  1  00                   .BYTE   0               ;list production if true (listprod)
003408  1               LSTSRC
003408  1  00                   .BYTE   0               ;list source if true (listsource)
003409  1               DEBUGL
003409  1  00                   .BYTE   0               ;debug line numbers if true (debugln)
00340A  1               LWRUPR
00340A  1  00                   .BYTE   0               ;convert if true i=TRUE (lowertoupper)
00340B  1               NINTFL
00340B  1  00                   .BYTE   0               ;no .INT file if true (nointfile)
00340C  1               LSTFLG
00340C  1  00                   .BYTE   0               ;list device if false (lstflag)
00340D  1               EOLSTS
00340D  1  00                   .BYTE   0               ;flag that eol (cr) read by scan
00340E  1               CMPLNG
00340E  1  00                   .BYTE   0               ;compiling if true (compiling)
00340F  1               FORSTM
00340F  1  00                   .BYTE   0               ;for statement flag (forstmt)
003410  1               FILEIO
003410  1  00                   .BYTE   0               ;file i/o flag
003411  1               ;next variable is never read or tested - need to check need
003411  1               RNDFLE
003411  1  00                   .BYTE   0               ;random file flag (randomfile)
003412  1               ;fcbs and similar
003412  1               WFCB
003412  1  xx xx xx xx          .RES    9
003416  1  xx xx xx xx  
00341A  1  xx           
00341B  1  49 4E 54             .BYTE   "INT"
00341E  1  xx xx xx xx          .RES    21
003422  1  xx xx xx xx  
003426  1  xx xx xx xx  
003433  1               PRMLST
003433  1  20 20 20 20          .BYTE   "         "
003437  1  20 20 20 20  
00343B  1  20           
00343C  1               ;parser data tables
00343C  1               IFLBLN
00343C  1  02                   .BYTE   2
00343D  1               IFLAB2
00343D  1  17                   .BYTE   23
00343E  1               IFLABL
00343E  1  00                   .BYTE   0
00343F  1               HSHTBL
00343F  1  xx xx xx xx          .RES    HSHTSZ*2
003443  1  xx xx xx xx  
003447  1  xx xx xx xx  
0034BF  1               HASH
0034BF  1  xx xx xx xx          .RES    PSTKSZ
0034C3  1  xx xx xx xx  
0034C7  1  xx xx xx xx  
0034DF  1               VAR
0034DF  1  xx xx xx xx          .RES    PSTKSZ
0034E3  1  xx xx xx xx  
0034E7  1  xx xx xx xx  
0034FF  1               TYPE
0034FF  1  xx xx xx xx          .RES    PSTKSZ
003503  1  xx xx xx xx  
003507  1  xx xx xx xx  
00351F  1               STYPE
00351F  1  xx xx xx xx          .RES    PSTKSZ
003523  1  xx xx xx xx  
003527  1  xx xx xx xx  
00353F  1               SRLOC
00353F  1  xx xx xx xx          .RES    PSTKSZ*2
003543  1  xx xx xx xx  
003547  1  xx xx xx xx  
00357F  1               SYMLOC
00357F  1  xx xx xx xx          .RES    PSTKSZ*2
003583  1  xx xx xx xx  
003587  1  xx xx xx xx  
0035BF  1               STSTAK
0035BF  1  xx xx xx xx          .RES    PSTKSZ*2
0035C3  1  xx xx xx xx  
0035C7  1  xx xx xx xx  
0035FF  1               VARC
0035FF  1  xx xx xx xx          .RES    VARCSZ
003603  1  xx xx xx xx  
003607  1  xx xx xx xx  
003663  1               ONSTAK
003663  1  xx xx xx xx          .RES    MAXOCT
003667  1  xx xx xx xx  
00366B  1  xx xx xx xx  
003672  1               ONSP            = ONSTAK
003672  1               ;buffers
003672  1               INPBUF
003672  1  xx xx xx xx          .RES    SRCRSZ
003676  1  xx xx xx xx  
00367A  1  xx xx xx xx  
0036F2  1               OUTBUF
0036F2  1  xx xx xx xx          .RES    INTRSZ
0036F6  1  xx xx xx xx  
0036FA  1  xx xx xx xx  
003772  1               CONBUF
003772  1  xx xx xx xx          .RES    CBUFSZ+2
003776  1  xx xx xx xx  
00377A  1  xx xx xx xx  
0037C6  1               ;start of free memory
0037C6  1               MEMORY
0037C6  1                       .END
