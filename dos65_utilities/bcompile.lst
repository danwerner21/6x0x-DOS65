ca65 V2.18 - Ubuntu 2.19-1
Main file   : compl203.asm
Current file: compl203.asm

000000r 1                       .INCLUDE "macro816.asm"
000000r 2                .IFDEF  DUODYNE
000000r 2               .P816
000000r 2               
000000r 2                       .MACRO  INDEX16         ; Set 16bit Index Registers
000000r 2                       REP     #$10            ; 16 bit Index registers
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2                       .MACRO  INDEX8          ; Set 8bit Index Registers
000000r 2                       SEP     #$10            ; 8 bit Index registers
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR16   ; Set 16bit Index Registers
000000r 2                       REP     #$20            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATOR8    ; Set 8bit Index Registers
000000r 2                       SEP     #$20            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX16; Set 16bit Index Registers
000000r 2                       REP     #$30            ; 16 bit Index registers
000000r 2                       .A16
000000r 2                       .I16
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ACCUMULATORINDEX8; Set 8bit Index Registers
000000r 2                       SEP     #$30            ; 8 bit Index registers
000000r 2                       .A8
000000r 2                       .I8
000000r 2                       .ENDMACRO
000000r 2               
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLB
000000r 2                       LDA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHX
000000r 2                       PHA
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLA
000000r 2                       PLX
000000r 2                       STA     (<PARM1),Y      ;
000000r 2                       PLB
000000r 2                       STA     <TMPFLG
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CMP     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ADC     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       PHB
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       LDX     #$01
000000r 2                       LDA     <PARM1,X
000000r 2                       CMP     #$00
000000r 2                       BNE     *+6
000000r 2                       LDX     #00
000000r 2                       PHX
000000r 2                       PLB
000000r 2                       PLX
000000r 2                       LDA     (<PARM1),Y      ;
000000r 2                       STA     <TMPFLG
000000r 2                       PLA
000000r 2                       PLB
000000r 2                       CLC
000000r 2                       ORA     <TMPFLG         ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BNE     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE PARM1
000000r 2                       BEQ     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     *+4
000000r 2                       BRA     *+5
000000r 2                       JMP     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ELSE
000000r 2               
000000r 2                       .MACRO  LDAINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  STAINDIRECTY PARM1
000000r 2                       STA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  FETCHINDIRECTY PARM1
000000r 2                       LDA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  CMPINDIRECTY  PARM1
000000r 2                       CMP     (<PARM1),Y      ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ADCINDIRECTY  PARM1
000000r 2                       ADC     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  ORAINDIRECTY  PARM1
000000r 2                       ORA     (PARM1),Y       ;
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBEQ  PARM1
000000r 2                       BEQ     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBNE  PARM1
000000r 2                       BNE     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCC  PARM1
000000r 2                       BCC     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .MACRO  LBCS PARM1
000000r 2                       BCS     PARM1
000000r 2                       .ENDMACRO
000000r 2               
000000r 2                       .ENDIF
000000r 2               
000000r 1               ;COMPILE
000000r 1               ;BASIC-E/65 Compiler
000000r 1               ;Version 2.03-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;released:	18 october 1982
000000r 1               ;last revision:
000000r 1               ;	24 december 1983
000000r 1               ;		added chkule for prod 5
000000r 1               ;		modified error to print line
000000r 1               ;		added code to set seprtr
000000r 1               ;	12 january 1984
000000r 1               ;		deleted error0 bit and branch
000000r 1               ;		fixed first blank line list for $b option
000000r 1               ;		fixed buffer overwrite on error
000000r 1               ;	4 april 2008
000000r 1               ;		reformatted for ASM211 & TASM
000000r 1               ;		eliminated page zero 0 & 1
000000r 1               ;		moved some variables from page zero
000000r 1               ;A translation of Gordon Eubanks BASIC-E to operate under DOS/65.  This is a
000000r 1               ;compile-interpret systems invoked against a source file of type .BAS.  The
000000r 1               ;compiler produces an intermediate code file of type .INT which is executed
000000r 1               ;by the program RUN.
000000r 1               ;external references
000000r 1               BOOT            = $100          ;boot entry
000000r 1               PEM             = $103          ;pem entry
000000r 1               FCB             = $107          ;default fcb
000000r 1               TEA             = $800          ;load address
000000r 1               ;fixed parameters and constants
000000r 1               ;CAUTION: When a register is set to TRUE, Z is set to 0 (i.e. NE).  If a
000000r 1               ;register is set to FALSE then Z is set to 1 (i.e. EQ).
000000r 1               TRUE            = $FF
000000r 1               FALSE           = 0
000000r 1               ;ascii characters
000000r 1               TAB             = 9             ;tab
000000r 1               LF              = 10            ;linefeed
000000r 1               CR              = 13            ;return and eol
000000r 1               EOF             = 26            ;eof char
000000r 1               SPACE           = 32            ;ascii blank
000000r 1               semico          = 59            ;semicolon
000000r 1               backsl          = 92            ;backslash
000000r 1               ;other
000000r 1               IDNTSZ          = 32            ;max identifier size + 1
000000r 1               VARCSZ          = 100           ;varc stack size
000000r 1               PSTKSZ          = 32            ;parse stack size
000000r 1               SRCRSZ          = 128           ;source file record size
000000r 1               INTRSZ          = 128           ;int file record size
000000r 1               CBUFSZ          = 82            ;console buffer size
000000r 1               HSHTSZ          = 64            ;hash table size
000000r 1               HSHMSK          = HSHTSZ-1      ;hashing mask
000000r 1               MAXOCT          = 15            ;max number on statements
000000r 1               MAXRWL          = 9             ;max reserved word length
000000r 1               MAXRNO          = 120           ;max read count
000000r 1               MAXLNO          = 175           ;max look count
000000r 1               MAXPNO          = 189           ;max push count
000000r 1               MAXSNO          = 341           ;max state count
000000r 1               STARTS          = 121           ;start state
000000r 1               PRODNO          = 152           ;number productions
000000r 1               SIMVAR          = 0
000000r 1               SUBVAR          = 2
000000r 1               CONST           = 4
000000r 1               LABLE           = 8
000000r 1               UNFUNC          = $A
000000r 1               ;mnemonics for basic-e machine
000000r 1               FAD             = 0
000000r 1               FMI             = 1
000000r 1               FMU             = 2
000000r 1               FDI             = 3
000000r 1               EXP             = 4
000000r 1               LSS             = 5
000000r 1               GTR             = 6
000000r 1               EQU             = 7
000000r 1               NEQ             = 8
000000r 1               GEQ             = 9
000000r 1               LEQ             = 10
000000r 1               NOT             = 11
000000r 1               ANDO            = 12
000000r 1               BOR             = 13
000000r 1               LOD             = 14
000000r 1               STO             = 15
000000r 1               XIT             = 16
000000r 1               DEL             = 17
000000r 1               DUP             = 18
000000r 1               XCH             = 19
000000r 1               STD             = 20
000000r 1               SLT             = 21
000000r 1               SGT             = 22
000000r 1               SEQ             = 23
000000r 1               SNE             = 24
000000r 1               SGE             = 25
000000r 1               SLE             = 26
000000r 1               STS             = 27
000000r 1               ILS             = 28
000000r 1               CAT             = 29
000000r 1               PRO             = 30
000000r 1               RTN             = 31
000000r 1               ROW             = 32
000000r 1               SUB             = 33
000000r 1               RDV             = 34
000000r 1               WRV             = 35
000000r 1               WST             = 36
000000r 1               RDF             = 37
000000r 1               RDB             = 38
000000r 1               ECR             = 39
000000r 1               POT             = 40
000000r 1               WRB             = 40
000000r 1               RDN             = 41
000000r 1               RDS             = 42
000000r 1               WRN             = 43
000000r 1               WRS             = 44
000000r 1               OPN             = 45
000000r 1               CON             = 46
000000r 1               RST             = 47
000000r 1               NEG             = 48
000000r 1               RES             = 49
000000r 1               NOPO            = 50
000000r 1               DAT             = 51
000000r 1               DBF             = 52
000000r 1               NSP             = 53
000000r 1               BRS             = 54
000000r 1               BRC             = 55
000000r 1               BFC             = 56
000000r 1               BFN             = 57
000000r 1               CVB             = 58
000000r 1               RCN             = 59
000000r 1               DRS             = 60
000000r 1               DRF             = 61
000000r 1               EDR             = 62
000000r 1               EDW             = 63
000000r 1               CLS             = 64
000000r 1               IRN             = 77
000000r 1               RON             = 91
000000r 1               CKO             = 92
000000r 1               EXR             = 93
000000r 1               DEF             = 94
000000r 1               BOL             = 95
000000r 1               ADJ             = 96
000000r 1               ;token definitions
000000r 1               POUND           = 12
000000r 1               ASTRK           = 4
000000r 1               LESST           = 1
000000r 1               EXPON           = 14
000000r 1               TDATA           = 99
000000r 1               TELSE           = 34
000000r 1               TFOR            = 28
000000r 1               TIF             = 17
000000r 1               TNEXT           = 37
000000r 1               SLASH           = 8
000000r 1               TOR             = 21
000000r 1               TREST           = 48
000000r 1               TSTOP           = 40
000000r 1               FUNCT           = 53
000000r 1               TLEQ            = 18
000000r 1               TNE             = 19
000000r 1               TOUT            = 31
000000r 1               IDENT           = 52
000000r 1               UDFUNC          = 54
000000r 1               LPARN           = 2
000000r 1               TPLUS           = 3
000000r 1               TCOLIN          = 11
000000r 1               EQUAL           = 13
000000r 1               TAND            = 24
000000r 1               TDEF            = 25
000000r 1               TEND            = 27
000000r 1               TGOSB           = 43
000000r 1               TINPT           = 44
000000r 1               TNOT            = 30
000000r 1               TPRNT           = 45
000000r 1               TRETN           = 46
000000r 1               TTHEN           = 41
000000r 1               TGEQ            = 15
000000r 1               COMMA           = 9
000000r 1               TCLOS           = 42
000000r 1               TIRN            = 51
000000r 1               RPARN           = 5
000000r 1               TMINUS          = 7
000000r 1               SCOLN           = 6
000000r 1               GTRT            = 10
000000r 1               TCR             = 23
000000r 1               TDIM            = 26
000000r 1               TFILE           = 35
000000r 1               TGOTO           = 36
000000r 1               TLET            = 29
000000r 1               TON             = 20
000000r 1               TREAD           = 38
000000r 1               TSTEP           = 39
000000r 1               TTO             = 22
000000r 1               TSUB            = 32
000000r 1               TGO             = 16
000000r 1               TXOR            = 33
000000r 1               STRING          = 50
000000r 1               FLOTPT          = 49
000000r 1               TREM            = 0
000000r 1               ;page zero variables
000000r 1               ;all non-zero initial values are shown as i=xxxx where xxxx is the initial
000000r 1               ;value. PL/M name is shown if significantly different.
000000r 1               GPIND           = $02+$40       ;INDEX IN GETCHR
000000r 1               ERRCNT          = $03+$40       ;ERROR COUNT (ERRORCOUNT)
000000r 1               DATACT          = $05+$40       ;COUNT DATA AREA SIZE
000000r 1               INPSTM          = $07+$40       ;(INPUTSTMT)
000000r 1               GSBSTM          = $08+$40       ;(GOSUBSTMT)
000000r 1               TOKEN           = $09+$40       ;TYPE OF TOKEN
000000r 1               SUBTYP          = $0A+$40       ;SUBTYPE OF TOKEN (SUBTYPE)
000000r 1               FUNCOP          = $0B+$40       ;FUNCTION NUMBER IF FUNCTION
000000r 1               HSHCDE          = $0C+$40       ;HASH OF CURRENT TOKEN (HASHCODE)
000000r 1               NXTCHR          = $0D+$40       ;CURRENT CHAR FROM GETCHR (NEXTCHAR)
000000r 1               ACCUM           = $0E+$40       ;CURRENT TOKEN
000000r 1               ACCLEN          = ACCUM         ;LENGTH IS FIRST BYTE
000000r 1               CONT            = $2E+$40       ;ACCUM FULL FLAG
000000r 1               COLUMN          = $2F+$40       ;CURRENT COLUMN
000000r 1               LINENO          = $30+$40       ;CURRENT LINE NUMBER
000000r 1               OUTIND          = $32+$40       ;INT BUFFER INDEX (BUFFPTR)
000000r 1               LENGTH          = $33+$40       ;OUTPUT LINE LENGTH
000000r 1               SEPRTR          = $34+$40       ;SEPARATOR I=':'
000000r 1               SRCIND          = $35+$40       ;SOURCE INDEX I=SRCRSZ (SOURCEPTR)
000000r 1               LNEPTR          = $36+$40       ;LINE POINTER
000000r 1               POINTR          = $37+$40       ;POINTER IN ERROR
000000r 1               ERRCDE          = $38+$40       ;COMPILER ERROR CODE
000000r 1               STATE           = $39+$40       ;STATE
000000r 1               SP              = $3B+$40       ;STACK POINTER
000000r 1               MP              = $3C+$40       ;
000000r 1               MPP1            = $3D+$40       ;MP + 1
000000r 1               NOLOOK          = $3E+$40       ;
000000r 1               VARIND          = $3F+$40       ;INDEX INTO VAR
000000r 1               TYPESP          = $40+$40       ;GROUP OF
000000r 1               TYPEM1          = $41+$40       ;VARIABLES
000000r 1               TYPEMP          = $42+$40       ;TO HOLD
000000r 1               STYPSP          = $43+$40       ;PARSER STACK
000000r 1               STYPM1          = $44+$40       ;CONTENTS
000000r 1               STYPMP          = $45+$40       ;DURING
000000r 1               SYMLSP          = $46+$40       ;ACTION
000000r 1               SYMLM1          = $48+$40       ;OF SYNTHESIZE
000000r 1               SYMLMP          = $4A+$40       ;IN
000000r 1               HASHSP          = $4C+$40       ;ORDER TO
000000r 1               HASHM1          = $4D+$40       ;REDUCE
000000r 1               HASHMP          = $4E+$40       ;THE AMOUNT
000000r 1               SRLOSP          = $4F+$40       ;OF INDEXING
000000r 1               SRLOMP          = $51+$40       ;IN SYNTHE
000000r 1               DECOUT          = $53+$40       ;DECIMAL WORD
000000r 1               LZFLAG          = $55+$40       ;LEADING ZERO FLAG IN PRNDEC
000000r 1               FIELD           = $56+$40       ;POINTER IN COMPARE
000000r 1               I               = $58+$40       ;PARSER VAR
000000r 1               J               = $5A+$40       ;SAME
000000r 1               K               = $5C+$40       ;EVEN MORE
000000r 1               INDEX           = $5E+$40       ;
000000r 1               I2              = $5F+$40       ;I*2 AND WORD POINTER
000000r 1               IC              = $61+$40       ;INDEX IN COMPAR
000000r 1               PTR             = $62+$40       ;POINTER IN LOOKUP AND COMPAR
000000r 1               IL              = $64+$40       ;INDEX IN LOOKUP
000000r 1               SBTTOP          = $65+$40       ;TOP OF FOR/NEXT STACK
000000r 1               BASE            = $67+$40       ;BASE OF CURRENT ENTRY
000000r 1               FORCNT          = $69+$40       ;FOR COUNT
000000r 1               SBTBL           = $6A+$40       ;TOP OF SYMBOL TABLE
000000r 1               APTADD          = $6C+$40       ;UTILITY VAR TO ACCESS TABLE
000000r 1               PRTCT           = $6E+$40       ;COUNT PRT ENTRIES
000000r 1               FDACT           = $70+$40       ;COUNT FDA ENTRIES
000000r 1               CODESI          = $72+$40       ;COUNT SIZE OF CODE AREA
000000r 1               ULERFL          = $74+$40       ;
000000r 1               PRNTNM          = $75+$40       ;POINTER SET BEFORE SLOOKU OR ENTER
000000r 1               SYMHSH          = $77+$40       ;HASH OF TOKEN REFERENCE
000000r 1               PRODCT          = $78+$40       ;PRODUCTION NUMBER (0 TO PRODNO)
000000r 1               NXSTPT          = $79+$40       ;NEXT STATEMENT POINTER
000000r 1               TMPHSH          = $7B+$40       ;LOCAL HASH IN GETHSH
000000r 1               TMPPTR          = $7C+$40       ;LOCAL PTR IN GETHSH
000000r 1               LEN             = $7D+$40       ;TEMP IN SLOOKU
000000r 1               NUMPRM          = $7E+$40       ;TEMP IN UNLINK/RELINK
000000r 1               LINKI           = $7F+$40       ;TEMP IN UNLINK/RELINK
000000r 1               TMPADR          = $80+$40       ;TEMP IN UNLINK/RELINK
000000r 1               WHERE           = $82+$40       ;TEMP IN GENILS
000000r 1               STRPTR          = $84+$40       ;TEMP IN GINILS
000000r 1               IGEN            = $85+$40       ;TEMP IN GENCON
000000r 1               LZ              = $86+$40       ;
000000r 1               TMPFLG          = $87+$40       ;
000000r 1               
000000r 1               ;entry point
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C BD 1C             JMP     MAIN
000803  1               ;copyright notice
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT - RICHARD"
000807  1  52 49 47 48  
00080B  1  54 20 2D 20  
000816  1  20 41 2E 20          .BYTE   " A. LEARY - 2008"
00081A  1  4C 45 41 52  
00081E  1  59 20 2D 20  
000826  1               ;SUBROUTINES
000826  1               ;subroutine to point to source fcb and go to pem
000826  1               RFCBX
000826  1  A9 07                LDA     #<FCB           ;point
000828  1  A0 01                LDY     #>FCB           ;to fcb
00082A  1  4C 03 01             JMP     PEM             ;and go
00082D  1               ;point to int fcb and go to pem
00082D  1               WFCBX
00082D  1  A9 0D                LDA     #<WFCB          ;point
00082F  1  A0 2E                LDY     #>WFCB          ;to fcb
000831  1  4C 03 01             JMP     PEM             ;and go
000834  1               ;send cr and lf to console/list
000834  1               CRLF
000834  1  A9 0D                LDA     #CR             ;get
000836  1  20 4F 08             JSR     PRNCHR          ;a cr
000839  1  A9 0A                LDA     #LF             ;and
00083B  1  4C 4F 08             JMP     PRNCHR          ;then a lf
00083E  1               ;output char in A to console or list device as a function of LSTFLG
00083E  1               SPCOUT
00083E  1  A9 20                LDA     #SPACE          ;get space
000840  1               CHROUT
000840  1  2C 07 2E             BIT     LSTFLG          ;test flag
000843  1  30 05                BMI     *+7             ;use list if set
000845  1  A2 02                LDX     #2              ;else set
000847  1  4C 03 01             JMP     PEM             ;and do console
00084A  1  A2 05                LDX     #5              ;set list
00084C  1  4C 03 01             JMP     PEM             ;and do
00084F  1               ;print char in A and handle tabs and linefeeds
00084F  1               PRNCHR
00084F  1  C9 09                CMP     #TAB            ;see if tab
000851  1  D0 0C                BNE     NOTTAB          ;branch if not
000853  1               TABOVR
000853  1  20 3E 08             JSR     SPCOUT          ;send a space
000856  1  E6 6F                INC     COLUMN          ;bump column
000858  1  A5 6F                LDA     COLUMN          ;get it
00085A  1  29 07                AND     #7              ;see if mod 8
00085C  1  D0 F5                BNE     TABOVR          ;loop if not
00085E  1  60                   RTS                     ;else done
00085F  1               NOTTAB
00085F  1  48                   PHA                     ;save char
000860  1  20 40 08             JSR     CHROUT          ;send it
000863  1  E6 6F                INC     COLUMN          ;bump column
000865  1  68                   PLA                     ;get char
000866  1  C9 0A                CMP     #LF             ;if a lf
000868  1  F0 01                BEQ     *+3             ;then branch
00086A  1  60                   RTS                     ;else done
00086B  1  A9 00                LDA     #0              ;clear column
00086D  1  85 6F                STA     COLUMN          ;and then
00086F  1  60                   RTS                     ;done
000870  1               ;convert AY to decimal number and print on console
000870  1               PRNDEC
000870  1  85 93                STA     DECOUT          ;save
000872  1  84 94                STY     DECOUT+1        ;value
000874  1  A9 00                LDA     #FALSE          ;set flag
000876  1  85 95                STA     LZFLAG          ;to false
000878  1  A2 2F                LDX     #'0'-1          ;set digit to '0' - 1
00087A  1  38                   SEC                     ;now
00087B  1               P10000
00087B  1  A5 93                LDA     DECOUT          ;subtract
00087D  1  E9 10                SBC     #<10000         ;10000
00087F  1  85 93                STA     DECOUT          ;from
000881  1  A5 94                LDA     DECOUT+1        ;value
000883  1  E9 27                SBC     #>10000         ;and
000885  1  85 94                STA     DECOUT+1        ;save
000887  1  E8                   INX                     ;bump digit
000888  1  B0 F1                BCS     P10000          ;loop if no borrow
00088A  1  A5 93                LDA     DECOUT          ;else
00088C  1  69 10                ADC     #<10000         ;add
00088E  1  85 93                STA     DECOUT          ;10000
000890  1  A5 94                LDA     DECOUT+1        ;back
000892  1  69 27                ADC     #>10000         ;in to
000894  1  85 94                STA     DECOUT+1        ;correct
000896  1  20 E6 08             JSR     DIGOUT          ;send digit
000899  1               P1000
000899  1  A5 93                LDA     DECOUT          ;now
00089B  1  E9 E8                SBC     #<1000          ;drop
00089D  1  85 93                STA     DECOUT          ;by
00089F  1  A5 94                LDA     DECOUT+1        ;1000
0008A1  1  E9 03                SBC     #>1000          ;until
0008A3  1  85 94                STA     DECOUT+1        ;a borrow
0008A5  1  E8                   INX                     ;bump digit
0008A6  1  B0 F1                BCS     P1000           ;loop if more
0008A8  1  A5 93                LDA     DECOUT          ;now
0008AA  1  69 E8                ADC     #<1000          ;add
0008AC  1  85 93                STA     DECOUT          ;1000
0008AE  1  A5 94                LDA     DECOUT+1        ;back
0008B0  1  69 03                ADC     #>1000          ;in to
0008B2  1  85 94                STA     DECOUT+1        ;correct
0008B4  1  20 E6 08             JSR     DIGOUT          ;send 1000s
0008B7  1               P100
0008B7  1  A5 93                LDA     DECOUT          ;now
0008B9  1  E9 64                SBC     #100            ;do
0008BB  1  85 93                STA     DECOUT          ;subtract
0008BD  1  A5 94                LDA     DECOUT+1        ;for
0008BF  1  E9 00                SBC     #0              ;100
0008C1  1  85 94                STA     DECOUT+1        ;with
0008C3  1  E8                   INX                     ;digit bump
0008C4  1  B0 F1                BCS     P100            ;loop if more
0008C6  1  A5 93                LDA     DECOUT          ;else
0008C8  1  69 64                ADC     #100            ;add back
0008CA  1  85 93                STA     DECOUT          ;to correct
0008CC  1  20 E6 08             JSR     DIGOUT          ;send 100s
0008CF  1               P10
0008CF  1  A5 93                LDA     DECOUT          ;now
0008D1  1  E9 0A                SBC     #10             ;drop
0008D3  1  85 93                STA     DECOUT          ;by 10
0008D5  1  E8                   INX                     ;bump digit
0008D6  1  B0 F7                BCS     P10             ;loop if more
0008D8  1  69 0A                ADC     #10             ;correct
0008DA  1  85 93                STA     DECOUT          ;save
0008DC  1  20 E6 08             JSR     DIGOUT          ;and send 10s
0008DF  1  A9 30                LDA     #'0'            ;get zero
0008E1  1  05 93                ORA     DECOUT          ;add number
0008E3  1  4C 4F 08             JMP     PRNCHR          ;and print always
0008E6  1               ;send a single digit in X and handle leading zeros
0008E6  1               DIGOUT
0008E6  1  A9 20                LDA     #SPACE          ;preset for blank
0008E8  1  24 95                BIT     LZFLAG          ;test flag
0008EA  1  30 08                BMI     D2              ;branch if set
0008EC  1  E0 30                CPX     #'0'            ;else test current
0008EE  1  F0 05                BEQ     D3              ;branch if '0'
0008F0  1  A9 FF                LDA     #TRUE           ;else set
0008F2  1  85 95                STA     LZFLAG          ;flag
0008F4  1               D2
0008F4  1  8A                   TXA                     ;get char
0008F5  1               D3
0008F5  1  20 4F 08             JSR     PRNCHR          ;print it
0008F8  1  A2 2F                LDX     #'0'-1          ;now preset
0008FA  1  38                   SEC                     ;for next
0008FB  1  60                   RTS
0008FC  1               ;print message pointed to by AY until a $ is encountered
0008FC  1               PRNMSG
0008FC  1  8D 03 09             STA     PRN0+1          ;save message
0008FF  1  8C 04 09             STY     PRN0+2          ;address
000902  1               PRN0
000902  1  AD FF FF             LDA     $FFFF           ;get byte
000905  1  C9 24                CMP     #'$'            ;see if end
000907  1  D0 01                BNE     *+3             ;branch if not
000909  1  60                   RTS                     ;else done
00090A  1  20 4F 08             JSR     PRNCHR          ;print it
00090D  1  EE 03 09             INC     PRN0+1          ;bump low
000910  1  D0 F0                BNE     PRN0            ;loop if no carry
000912  1  EE 04 09             INC     PRN0+2          ;bump high
000915  1  4C 02 09             JMP     PRN0            ;and loop
000918  1               ;disk error exit
000918  1               DSKERR
000918  1  A9 A6                LDA     #<DEMSG         ;point to
00091A  1  A0 2D                LDY     #>DEMSG         ;message
00091C  1               DSKER0
00091C  1  20 FC 08             JSR     PRNMSG          ;print it
00091F  1  4C 00 01             JMP     BOOT            ;and boot
000922  1               ;open source file
000922  1               OPNSRC
000922  1  A2 03                LDX     #3              ;first
000924  1               OPN1
000924  1  BD BC 2D             LDA     BASSTR-1,X      ;move
000927  1  9D 0F 01             STA     FCB+8,X         ;BAS to
00092A  1  CA                   DEX                     ;type part
00092B  1  D0 F7                BNE     OPN1            ;of fcb
00092D  1  8E 13 01             STX     FCB+12          ;clear extent
000930  1  8E 14 01             STX     FCB+13
000933  1  8E 27 01             STX     FCB+32          ;and record
000936  1  A9 6D                LDA     #<INPBUF        ;point to
000938  1  A0 30                LDY     #>INPBUF        ;buffer
00093A  1  A2 1A                LDX     #26             ;and set
00093C  1  20 03 01             JSR     PEM             ;as buffer location
00093F  1  A2 0F                LDX     #15             ;open code
000941  1  20 26 08             JSR     RFCBX           ;do it
000944  1  30 01                BMI     *+3             ;branch if bad
000946  1  60                   RTS                     ;else done
000947  1  A9 C0                LDA     #<NSMSG         ;point to
000949  1  A0 2D                LDY     #>NSMSG         ;no source message
00094B  1  4C 1C 09             JMP     DSKER0          ;send and quit
00094E  1               ;close output (INT) file
00094E  1               CLSINT
00094E  1  A2 10                LDX     #16             ;close code
000950  1  20 2D 08             JSR     WFCBX           ;do it
000953  1  30 01                BMI     *+3             ;branch if bad
000955  1  60                   RTS                     ;else done
000956  1  4C 18 09             JMP     DSKERR          ;error exit
000959  1               ;set-up INT file
000959  1               SUPINT
000959  1  2C 06 2E             BIT     NINTFL          ;test no-int flag
00095C  1  10 01                BPL     *+3             ;branch if false
00095E  1  60                   RTS                     ;else done
00095F  1  A2 08                LDX     #8              ;move 9
000961  1               SUP0
000961  1  BD 07 01             LDA     FCB,X           ;char including drive
000964  1  9D 0D 2E             STA     WFCB,X          ;to write fcb
000967  1  CA                   DEX                     ;drop count
000968  1  10 F7                BPL     SUP0            ;loop if more
00096A  1  E8                   INX
00096B  1  8E 19 2E             STX     WFCB+12
00096E  1  8E 1A 2E             STX     WFCB+13
000971  1  8E 2D 2E             STX     WFCB+32         ;clear extent and record
000974  1  A2 13                LDX     #19             ;now delete
000976  1  20 2D 08             JSR     WFCBX           ;it if there
000979  1  A2 16                LDX     #22             ;now try
00097B  1  20 2D 08             JSR     WFCBX           ;to create
00097E  1  10 03                BPL     *+5             ;branch if ok
000980  1  4C 18 09             JMP     DSKERR          ;else error
000983  1  60                   RTS                     ;and quit
000984  1               ;reset compiler flags
000984  1               SETFLG
000984  1  A9 00                LDA     #FALSE
000986  1  8D 0C 2E             STA     RNDFLE          ;random file
000989  1  8D 0B 2E             STA     FILEIO          ;file io
00098C  1  85 47                STA     INPSTM          ;input statement
00098E  1  8D 0A 2E             STA     FORSTM          ;for statement
000991  1  85 48                STA     GSBSTM          ;gosub statement
000993  1  60                   RTS
000994  1               ;write INT record
000994  1               WRTINT
000994  1  2C 06 2E             BIT     NINTFL          ;test flag
000997  1  10 01                BPL     *+3             ;ok if false
000999  1  60                   RTS                     ;else done
00099A  1  A9 ED                LDA     #<OUTBUF        ;point to
00099C  1  A0 30                LDY     #>OUTBUF        ;buffer
00099E  1  A2 1A                LDX     #26             ;and set
0009A0  1  20 03 01             JSR     PEM             ;as dma
0009A3  1  A2 15                LDX     #21             ;now do
0009A5  1  20 2D 08             JSR     WFCBX           ;write op
0009A8  1  F0 03                BEQ     *+5             ;ok if zero
0009AA  1  4C 18 09             JMP     DSKERR          ;else error
0009AD  1  A9 6D                LDA     #<INPBUF        ;point back
0009AF  1  A0 30                LDY     #>INPBUF        ;to input
0009B1  1  A2 1A                LDX     #26             ;and set
0009B3  1  4C 03 01             JMP     PEM             ;as default
0009B6  1               ;emit byte in A to INT file
0009B6  1               EMIT
0009B6  1  A6 72                LDX     OUTIND          ;get index
0009B8  1  10 09                BPL     EMIT0           ;ok if < 128
0009BA  1  48                   PHA                     ;else save
0009BB  1  20 94 09             JSR     WRTINT          ;write buffer
0009BE  1  68                   PLA                     ;get byte
0009BF  1  A2 00                LDX     #0              ;now clear
0009C1  1  86 72                STX     OUTIND          ;index
0009C3  1               EMIT0
0009C3  1  E6 72                INC     OUTIND          ;bump for next
0009C5  1  9D ED 30             STA     OUTBUF,X        ;save byte
0009C8  1  60                   RTS                     ;and done
0009C9  1               ;read source file record
0009C9  1               RDESRC
0009C9  1  A2 14                LDX     #20             ;get code
0009CB  1  20 26 08             JSR     RFCBX           ;do it
0009CE  1  C9 02                CMP     #2              ;see if ok
0009D0  1  90 03                BCC     *+5             ;branch if was
0009D2  1  4C 18 09             JMP     DSKERR          ;else error
0009D5  1  60                   RTS
0009D6  1               ;clear output line buffer
0009D6  1               CLLNBF
0009D6  1  A2 51                LDX     #CBUFSZ-1       ;get length - 1
0009D8  1  A9 20                LDA     #SPACE          ;use space
0009DA  1               CLLN0
0009DA  1  9D 6D 31             STA     CONBUF,X        ;store
0009DD  1  CA                   DEX                     ;drop index
0009DE  1  E0 FF                CPX     #255            ;see if wrap
0009E0  1  D0 F8                BNE     CLLN0           ;loop if not
0009E2  1  60                   RTS
0009E3  1               ;list line of length LENGTH
0009E3  1               ;note that this routine also sets seprtr to : (just in case!!)
0009E3  1               LSTLNE
0009E3  1  A5 70                LDA     LINENO          ;get line
0009E5  1  A4 71                LDY     LINENO+1        ;number
0009E7  1  20 70 08             JSR     PRNDEC          ;print it
0009EA  1  A5 74                LDA     SEPRTR          ;then print
0009EC  1  20 4F 08             JSR     PRNCHR          ;separator
0009EF  1  A9 20                LDA     #SPACE          ;and a
0009F1  1  20 4F 08             JSR     PRNCHR          ;space
0009F4  1  A9 00                LDA     #0              ;now clear
0009F6  1  85 42                STA     GPIND           ;index
0009F8  1               LSTL0
0009F8  1  A6 42                LDX     GPIND           ;get index
0009FA  1  BD 6D 31             LDA     CONBUF,X        ;get char
0009FD  1  20 4F 08             JSR     PRNCHR          ;print it
000A00  1  E6 42                INC     GPIND           ;bump index
000A02  1  A5 42                LDA     GPIND           ;get index
000A04  1  C5 73                CMP     LENGTH          ;compare to length
000A06  1  90 F0                BCC     LSTL0           ;loop if more
000A08  1  F0 EE                BEQ     LSTL0           ;or if same
000A0A  1  20 34 08             JSR     CRLF            ;do cr and lf
000A0D  1  20 D6 09             JSR     CLLNBF          ;clear buffer
000A10  1  A9 3A                LDA     #':'            ;and set
000A12  1  85 74                STA     SEPRTR          ;separator
000A14  1  60                   RTS
000A15  1               ;set global variable NXTCHR to next source file character and return with
000A15  1               ;NXTCHR in A. Replace TAB with SPACE and if LSTSRC is TRUE or an error
000A15  1               ;occurs send the line to the console.
000A15  1               GETCHR
000A15  1  20 73 0A             JSR     CHKFLE          ;go get char
000A18  1  D0 06                BNE     GETEOF          ;branch if eof
000A1A  1  A5 4D                LDA     NXTCHR          ;get nextchar
000A1C  1  C9 1A                CMP     #EOF            ;see if eof char
000A1E  1  D0 14                BNE     NTEOF           ;branch if not
000A20  1               GETEOF
000A20  1  A2 04                LDX     #4              ;move 5
000A22  1               GETE0
000A22  1  BD D6 2D             LDA     ADDEND,X        ;from ADDEND
000A25  1  9D 6D 30             STA     INPBUF,X        ;to input buffer
000A28  1  CA                   DEX                     ;drop count
000A29  1  10 F7                BPL     GETE0           ;loop if more
000A2B  1  00                   BRK
000A2C  1  E8                   INX                     ;clear X
000A2D  1  86 75                STX     SRCIND          ;and then index
000A2F  1  20 6D 0A             JSR     NXTSRC          ;get next
000A32  1  85 4D                STA     NXTCHR          ;save it
000A34  1               NTEOF
000A34  1  A6 76                LDX     LNEPTR          ;get pointer
000A36  1  E0 52                CPX     #CBUFSZ         ;compare to max
000A38  1  B0 08                BCS     LTOBIG          ;branch if too big
000A3A  1  E8                   INX                     ;else bump
000A3B  1  86 76                STX     LNEPTR          ;and save
000A3D  1  A5 4D                LDA     NXTCHR          ;get char
000A3F  1  9D 6D 31             STA     CONBUF,X        ;and save
000A42  1               LTOBIG
000A42  1  00                   BRK
000A43  1  A5 4D                LDA     NXTCHR          ;get char
000A45  1  C9 0D                CMP     #CR             ;see if a cr
000A47  1  D0 1A                BNE     NTEOL           ;branch if not
000A49  1  E6 70                INC     LINENO          ;else bump
000A4B  1  D0 02                BNE     *+4             ;line
000A4D  1  E6 71                INC     LINENO+1        ;number
000A4F  1  A6 76                LDX     LNEPTR          ;get pointer
000A51  1  CA                   DEX                     ;drop it
000A52  1  86 73                STX     LENGTH          ;put in length
000A54  1  AD 03 2E             LDA     LSTSRC          ;get flag
000A57  1  F0 04                BEQ     NOLSLN          ;branch if not true
000A59  1  00                   BRK
000A5A  1  20 E3 09             JSR     LSTLNE          ;list it
000A5D  1               NOLSLN
000A5D  1  A9 00                LDA     #0              ;then clear
000A5F  1  85 76                STA     LNEPTR          ;pointer
000A61  1  A5 4D                LDA     NXTCHR          ;get char
000A63  1               NTEOL
000A63  1  C9 09                CMP     #TAB            ;see it tab
000A65  1  F0 01                BEQ     *+3             ;branch if is
000A67  1  60                   RTS
000A68  1  A9 20                LDA     #SPACE          ;else get space
000A6A  1  85 4D                STA     NXTCHR          ;set
000A6C  1  60                   RTS                     ;and done
000A6D  1               ;get byte from source file
000A6D  1               NXTSRC
000A6D  1  A6 75                LDX     SRCIND          ;get index
000A6F  1  BD 6D 30             LDA     INPBUF,X        ;then byte
000A72  1  60                   RTS
000A73  1               ;maintain source buffer full and check for eof. if eof is detected then
000A73  1               ;A:=TRUE else A:=FALSE
000A73  1               CHKFLE
000A73  1  E6 75                INC     SRCIND          ;bump index
000A75  1  10 0E                BPL     CHKFL0          ;branch if ok
000A77  1  A9 00                LDA     #0              ;else clear
000A79  1  85 75                STA     SRCIND          ;index
000A7B  1  20 C9 09             JSR     RDESRC          ;read record
000A7E  1  C9 01                CMP     #1              ;see if eof
000A80  1  D0 03                BNE     CHKFL0          ;branch if not
000A82  1  A9 FF                LDA     #TRUE           ;else set
000A84  1  60                   RTS                     ;eof=true
000A85  1               CHKFL0
000A85  1  20 6D 0A             JSR     NXTSRC          ;get next
000A88  1  85 4D                STA     NXTCHR          ;save it
000A8A  1  C9 0A                CMP     #LF             ;if a lf
000A8C  1  F0 E5                BEQ     CHKFLE          ;loop for more
000A8E  1  A9 00                LDA     #FALSE          ;else say
000A90  1  60                   RTS                     ;wasn't eof
000A91  1               ;get non-blank from source. will also skip past eof to reach physical eof.
000A91  1               GTNBLK
000A91  1  20 15 0A             JSR     GETCHR          ;get new char
000A94  1  C9 20                CMP     #SPACE          ;if a space
000A96  1  F0 F9                BEQ     GTNBLK          ;try again
000A98  1  C9 1A                CMP     #EOF            ;if an eof
000A9A  1  F0 F5                BEQ     GTNBLK          ;try again
000A9C  1  60                   RTS
000A9D  1               ;check for continuation character. if it is will get first char from next line.
000A9D  1               CHKCNT
000A9D  1  A5 4D                LDA     NXTCHR          ;get next
000A9F  1  C9 5C                CMP     #backsl         ;see if continue
000AA1  1  F0 01                BEQ     *+3             ;branch if is
000AA3  1  60                   RTS
000AA4  1               CHKCN0
000AA4  1  20 15 0A             JSR     GETCHR          ;get next
000AA7  1  C9 0D                CMP     #CR             ;see if eol
000AA9  1  D0 F9                BNE     CHKCN0          ;loop if isn't
000AAB  1  4C 91 0A             JMP     GTNBLK          ;now get first non-blank
000AAE  1               ;compiler error handler
000AAE  1               ;at entry a contains error number
000AAE  1               ERROR
000AAE  1  85 78                STA     ERRCDE          ;save
000AB0  1  A5 76                LDA     LNEPTR          ;get index
000AB2  1  85 77                STA     POINTR          ;move to pointer
000AB4  1  E6 77                INC     POINTR          ;and bump
000AB6  1  E6 77                INC     POINTR          ;by two
000AB8  1  A5 49                LDA     TOKEN           ;get token
000ABA  1  C9 17                CMP     #TCR            ;see if for eol
000ABC  1  F0 0F                BEQ     ERROR3          ;branch if is
000ABE  1  A5 4D                LDA     NXTCHR          ;else get next
000AC0  1               ERROR1
000AC0  1  C9 0D                CMP     #CR             ;if a cr
000AC2  1  F0 09                BEQ     ERROR3          ;then done
000AC4  1  20 9D 0A             JSR     CHKCNT          ;else see if continue
000AC7  1  20 15 0A             JSR     GETCHR          ;get another char
000ACA  1  4C C0 0A             JMP     ERROR1          ;and loop
000ACD  1               ERROR3
000ACD  1  2C 01 2E             BIT     PASS2           ;test pass 2 flag
000AD0  1  10 43                BPL     ERROR6          ;branch if clear
000AD2  1  2C 03 2E             BIT     LSTSRC          ;see if source already listed
000AD5  1  30 03                BMI     *+5             ;skip list if was
000AD7  1  20 E3 09             JSR     LSTLNE          ;else list
000ADA  1  E6 43                INC     ERRCNT          ;bump
000ADC  1  D0 02                BNE     *+4             ;error
000ADE  1  E6 44                INC     ERRCNT+1        ;count
000AE0  1  A9 3F                LDA     #'?'            ;print a ?
000AE2  1  20 4F 08             JSR     PRNCHR
000AE5  1  A9 2D                LDA     #'-'
000AE7  1  20 4F 08             JSR     PRNCHR          ;print two -
000AEA  1  A9 2D                LDA     #'-'
000AEC  1  20 4F 08             JSR     PRNCHR
000AEF  1               ERROR4
000AEF  1  C6 77                DEC     POINTR          ;drop pointer
000AF1  1  F0 0A                BEQ     ERROR5          ;done if zero
000AF3  1  30 08                BMI     ERROR5          ;or <0
000AF5  1  A9 2D                LDA     #'-'            ;else get -
000AF7  1  20 4F 08             JSR     PRNCHR          ;print it
000AFA  1  4C EF 0A             JMP     ERROR4          ;and loop
000AFD  1               ERROR5
000AFD  1  A9 5E                LDA     #'^'            ;get up arrow
000AFF  1  20 4F 08             JSR     PRNCHR          ;print it
000B02  1  20 34 08             JSR     CRLF            ;then a cr and lf
000B05  1  A5 78                LDA     ERRCDE          ;get error code
000B07  1  0A                   ASL     A               ;mult by two
000B08  1  AA                   TAX
000B09  1  BD 5D 2D             LDA     ERMTBL,X
000B0C  1  BC 5E 2D             LDY     ERMTBL+1,X      ;get message address
000B0F  1  20 FC 08             JSR     PRNMSG          ;print it
000B12  1  20 34 08             JSR     CRLF
000B15  1               ERROR6
000B15  1  A9 00                LDA     #FALSE          ;now clear
000B17  1  8D 09 2E             STA     CMPLNG          ;compiling flag
000B1A  1  4C 84 09             JMP     SETFLG          ;and then other flags
000B1D  1               ;initialize scanner by setting NXTCHR to the first non-blank character from the
000B1D  1               ;input file and by setting the line number and pointer
000B1D  1               INSCAN
000B1D  1  2C 00 2E             BIT     PASS1           ;test for pass 1
000B20  1  10 0B                BPL     NOGTPR          ;branch if not
000B22  1  A2 08                LDX     #8              ;move 8 parms
000B24  1               INSCA0
000B24  1  BD 17 01             LDA     FCB+16,X        ;from fcb
000B27  1  9D 2D 2E             STA     PRMLST-1,X      ;to save area
000B2A  1  CA                   DEX                     ;drop count
000B2B  1  D0 F7                BNE     INSCA0          ;loop if more
000B2D  1               NOGTPR
000B2D  1  20 22 09             JSR     OPNSRC          ;open file
000B30  1  A9 00                LDA     #0              ;now
000B32  1  85 6E                STA     CONT            ;clear
000B34  1  85 6F                STA     COLUMN          ;variables
000B36  1  85 70                STA     LINENO          ;for start
000B38  1  85 71                STA     LINENO+1        ;of a
000B3A  1  85 76                STA     LNEPTR          ;pass
000B3C  1  20 D6 09             JSR     CLLNBF          ;clear output buffer
000B3F  1  A9 80                LDA     #SRCRSZ         ;now set source
000B41  1  85 75                STA     SRCIND          ;index to invalid
000B43  1  A9 3A                LDA     #':'            ;set separator
000B45  1  85 74                STA     SEPRTR          ;to a colon
000B47  1  AD 2E 2E             LDA     PRMLST          ;get first parm
000B4A  1  C9 24                CMP     #'$'            ;see if start
000B4C  1  D0 44                BNE     INSDNE          ;not so exit
000B4E  1  A2 01                LDX     #1              ;set index to first
000B50  1               INSCAP
000B50  1  BD 2E 2E             LDA     PRMLST,X        ;get parm
000B53  1  E8                   INX                     ;bump index
000B54  1  C9 20                CMP     #SPACE          ;if not a space
000B56  1  F0 3A                BEQ     INSDNE          ;done if space
000B58  1  A0 FF                LDY     #TRUE           ;set true
000B5A  1  C9 41                CMP     #'A'            ;if not A
000B5C  1  D0 05                BNE     PNOTA           ;try next
000B5E  1  8C 02 2E             STY     LSTPRD          ;else set
000B61  1  F0 ED                BEQ     INSCAP          ;and loop
000B63  1               PNOTA
000B63  1  C9 43                CMP     #'C'            ;if not C
000B65  1  D0 05                BNE     PNOTC           ;try next
000B67  1  8C 06 2E             STY     NINTFL          ;else set
000B6A  1  F0 E4                BEQ     INSCAP          ;and loop
000B6C  1               PNOTC
000B6C  1  C9 45                CMP     #'E'            ;see if E
000B6E  1  D0 05                BNE     PNOTE           ;branch if not
000B70  1  8C 04 2E             STY     DEBUGL          ;else set
000B73  1  F0 DB                BEQ     INSCAP          ;and loop
000B75  1               PNOTE
000B75  1  C9 46                CMP     #'F'            ;see if F
000B77  1  D0 05                BNE     PNOTF           ;branch if not
000B79  1  8C 07 2E             STY     LSTFLG          ;else set
000B7C  1  F0 D2                BEQ     INSCAP          ;and loop
000B7E  1               PNOTF
000B7E  1  A0 00                LDY     #FALSE          ;now use false
000B80  1  C9 42                CMP     #'B'            ;if not B
000B82  1  D0 05                BNE     PNOTB           ;try next
000B84  1  8C 03 2E             STY     LSTSRC          ;else set
000B87  1  F0 C7                BEQ     INSCAP          ;and loop
000B89  1               PNOTB
000B89  1  C9 44                CMP     #'D'            ;if not D
000B8B  1  D0 C3                BNE     INSCAP          ;then not valid
000B8D  1  8C 05 2E             STY     LWRUPR          ;else set
000B90  1  F0 BE                BEQ     INSCAP          ;and loop
000B92  1               ;done with INSCAN so get first non-blank
000B92  1               INSDNE
000B92  1  A9 00                LDA     #0              ;clear eol flag
000B94  1  8D 08 2E             STA     EOLSTS
000B97  1  4C 91 0A             JMP     GTNBLK
000B9A  1               ;put NXTCHR in ACCUM
000B9A  1               PUTACC
000B9A  1  24 6E                BIT     CONT            ;test for continue
000B9C  1  10 01                BPL     *+3             ;do if not
000B9E  1  60                   RTS                     ;else done
000B9F  1  E6 4E                INC     ACCLEN          ;bump length
000BA1  1  A6 4E                LDX     ACCLEN          ;get it as index
000BA3  1  A5 4D                LDA     NXTCHR          ;get next
000BA5  1  95 4E                STA     ACCUM,X         ;store it
000BA7  1  18                   CLC                     ;clear carry
000BA8  1  65 4C                ADC     HSHCDE          ;add hashcde
000BAA  1  29 3F                AND     #HSHMSK         ;mask it
000BAC  1  85 4C                STA     HSHCDE          ;and save
000BAE  1  E0 1F                CPX     #IDNTSZ-1       ;compare to max
000BB0  1  B0 01                BCS     *+3             ;branch if too big
000BB2  1  60                   RTS                     ;else done
000BB3  1  A9 FF                LDA     #TRUE           ;set CONT
000BB5  1  85 6E                STA     CONT            ;flag
000BB7  1  60                   RTS
000BB8  1               ;put NXTCHR in ACCUM and get another non-blank
000BB8  1               PUTGET
000BB8  1  20 9A 0B             JSR     PUTACC          ;put
000BBB  1  4C 91 0A             JMP     GTNBLK          ;and get
000BBE  1               ;put NXTCHR in ACCUM and get another char
000BBE  1               PUTCHR
000BBE  1  20 9A 0B             JSR     PUTACC          ;put
000BC1  1  4C 15 0A             JMP     GETCHR          ;and get
000BC4  1               ;test for numeric NXTCHR. return with A:=TRUE iff NXTCHR in '0' to '9'
000BC4  1               NUMRIC
000BC4  1  A5 4D                LDA     NXTCHR          ;get char
000BC6  1  C9 30                CMP     #'0'            ;see if less than 0
000BC8  1  90 07                BCC     NOTNUM          ;branch if is
000BCA  1  C9 3A                CMP     #'9'+1          ;see if over 9
000BCC  1  B0 03                BCS     NOTNUM          ;branch if is
000BCE  1  A9 FF                LDA     #TRUE           ;else set
000BD0  1  60                   RTS                     ;for numeric
000BD1  1               NOTNUM
000BD1  1  A9 00                LDA     #FALSE          ;set false
000BD3  1  60                   RTS
000BD4  1               ;test for lower case NXTCHR. return with A:=TRUE iff NXTCHR in 'a' to 'z'
000BD4  1               LWRCSE
000BD4  1  A5 4D                LDA     NXTCHR          ;get chat
000BD6  1  C9 61                CMP     #'a'            ;see if < a
000BD8  1  90 07                BCC     NOTLWR          ;branch if is
000BDA  1  C9 7B                CMP     #'z'+1          ;see if > z
000BDC  1  B0 03                BCS     NOTLWR          ;branch if is
000BDE  1  A9 FF                LDA     #TRUE           ;else
000BE0  1  60                   RTS                     ;is lower
000BE1  1               NOTLWR
000BE1  1  A9 00                LDA     #FALSE          ;not lower
000BE3  1  60                   RTS
000BE4  1               ;test for NXTCHR a decimal point
000BE4  1               DCMLPT
000BE4  1  A5 4D                LDA     NXTCHR          ;get char
000BE6  1  C9 2E                CMP     #'.'            ;test it
000BE8  1  D0 03                BNE     NTDCML          ;branch if not
000BEA  1  A9 FF                LDA     #TRUE           ;set for true
000BEC  1  60                   RTS
000BED  1               NTDCML
000BED  1  A9 00                LDA     #FALSE          ;false
000BEF  1  60                   RTS
000BF0  1               ;convert lowercase to uppercase
000BF0  1               CNVLWR
000BF0  1  20 D4 0B             JSR     LWRCSE          ;see if lower
000BF3  1  2D 05 2E             AND     LWRUPR          ;and with flag
000BF6  1  D0 01                BNE     *+3             ;ok if both true
000BF8  1  60                   RTS                     ;else done
000BF9  1  A5 4D                LDA     NXTCHR          ;get char
000BFB  1  29 5F                AND     #$5F            ;convert
000BFD  1  85 4D                STA     NXTCHR          ;and save
000BFF  1  60                   RTS
000C00  1               ;test for letter. set A:=TRUE if lowercase or uppercase letter
000C00  1               LETTER
000C00  1  20 F0 0B             JSR     CNVLWR          ;covert if all set
000C03  1  20 D4 0B             JSR     LWRCSE          ;see if still lowercase
000C06  1  F0 01                BEQ     *+3             ;branch if not
000C08  1  60                   RTS                     ;else is TRUE
000C09  1  A5 4D                LDA     NXTCHR          ;get char
000C0B  1  C9 41                CMP     #'A'            ;if < A
000C0D  1  90 07                BCC     NOTLTR          ;is not letter
000C0F  1  C9 5B                CMP     #'Z'+1          ;if > Z
000C11  1  B0 03                BCS     NOTLTR          ;is not letter
000C13  1  A9 FF                LDA     #TRUE           ;else is
000C15  1  60                   RTS
000C16  1               NOTLTR
000C16  1  A9 00                LDA     #FALSE          ;not letter
000C18  1  60                   RTS
000C19  1               ;test for letter, number or decimal point. return A:=TRUE if either
000C19  1               ALPNUM
000C19  1  20 00 0C             JSR     LETTER          ;first try letter
000C1C  1  F0 01                BEQ     *+3             ;branch if not
000C1E  1  60                   RTS
000C1F  1  20 C4 0B             JSR     NUMRIC          ;now try number
000C22  1  F0 01                BEQ     *+3             ;branch if not
000C24  1  60                   RTS
000C25  1  4C E4 0B             JMP     DCMLPT          ;finally try decimal point
000C28  1               ;spool numeric data into ACCUM
000C28  1               SPLNUM
000C28  1  20 C4 0B             JSR     NUMRIC          ;see if number
000C2B  1  D0 01                BNE     *+3             ;branch if is
000C2D  1  60                   RTS                     ;else done
000C2E  1  20 BE 0B             JSR     PUTCHR          ;stuff it
000C31  1  4C 28 0C             JMP     SPLNUM          ;and loop
000C34  1               ;set up next call
000C34  1               SUPNCL
000C34  1  A5 4D                LDA     NXTCHR          ;get next
000C36  1  C9 20                CMP     #SPACE          ;see if blank
000C38  1  D0 03                BNE     *+5             ;branch if not
000C3A  1  20 91 0A             JSR     GTNBLK          ;get non-blank
000C3D  1  A9 00                LDA     #FALSE          ;set continue
000C3F  1  85 6E                STA     CONT            ;to false
000C41  1  60                   RTS
000C42  1               ;procedure called by SYNTHE to reduce the amount of indexing
000C42  1               SCOPY
000C42  1  A6 7B                LDX     SP              ;get stack pointer
000C44  1  BD FA 2E             LDA     TYPE,X          ;do
000C47  1  85 80                STA     TYPESP          ;byte
000C49  1  BD 1A 2F             LDA     STYPE,X         ;values
000C4C  1  85 83                STA     STYPSP          ;first
000C4E  1  BD BA 2E             LDA     HASH,X
000C51  1  85 8C                STA     HASHSP
000C53  1  8A                   TXA                     ;now
000C54  1  0A                   ASL     A               ;make a
000C55  1  AA                   TAX                     ;word index
000C56  1  BD 7A 2F             LDA     SYMLOC,X
000C59  1  BC 7B 2F             LDY     SYMLOC+1,X
000C5C  1  85 86                STA     SYMLSP
000C5E  1  84 87                STY     SYMLSP+1
000C60  1  BD 3A 2F             LDA     SRLOC,X
000C63  1  BC 3B 2F             LDY     SRLOC+1,X
000C66  1  85 8F                STA     SRLOSP
000C68  1  84 90                STY     SRLOSP+1
000C6A  1  A6 7C                LDX     MP              ;now get MP
000C6C  1  BD FA 2E             LDA     TYPE,X
000C6F  1  85 82                STA     TYPEMP
000C71  1  BD 1A 2F             LDA     STYPE,X
000C74  1  85 85                STA     STYPMP
000C76  1  BD BA 2E             LDA     HASH,X
000C79  1  85 8E                STA     HASHMP
000C7B  1  8A                   TXA                     ;now
000C7C  1  0A                   ASL     A               ;make a
000C7D  1  AA                   TAX                     ;word index
000C7E  1  BD 7A 2F             LDA     SYMLOC,X
000C81  1  BC 7B 2F             LDY     SYMLOC+1,X
000C84  1  85 8A                STA     SYMLMP
000C86  1  84 8B                STY     SYMLMP+1
000C88  1  BD 3A 2F             LDA     SRLOC,X
000C8B  1  BC 3B 2F             LDY     SRLOC+1,X
000C8E  1  85 91                STA     SRLOMP
000C90  1  84 92                STY     SRLOMP+1
000C92  1  A6 7D                LDX     MPP1            ;now get MP+1
000C94  1  BD FA 2E             LDA     TYPE,X
000C97  1  85 81                STA     TYPEM1
000C99  1  BD 1A 2F             LDA     STYPE,X
000C9C  1  85 84                STA     STYPM1
000C9E  1  BD BA 2E             LDA     HASH,X
000CA1  1  85 8D                STA     HASHM1
000CA3  1  8A                   TXA                     ;now
000CA4  1  0A                   ASL     A               ;make a
000CA5  1  AA                   TAX                     ;word index
000CA6  1  BD 7A 2F             LDA     SYMLOC,X
000CA9  1  BC 7B 2F             LDY     SYMLOC+1,X
000CAC  1  85 88                STA     SYMLM1
000CAE  1  84 89                STY     SYMLM1+1
000CB0  1  60                   RTS
000CB1  1               ;called by SYNTHE to set SYMLOC(SP) to AY
000CB1  1               STSLSP
000CB1  1  48                   PHA                     ;save A part
000CB2  1  A5 7B                LDA     SP              ;get SP
000CB4  1               STSL
000CB4  1  0A                   ASL     A               ;mult by two
000CB5  1  AA                   TAX                     ;make index
000CB6  1  68                   PLA                     ;get byte
000CB7  1  9D 7A 2F             STA     SYMLOC,X        ;save it
000CBA  1  98                   TYA                     ;get high
000CBB  1  9D 7B 2F             STA     SYMLOC+1,X      ;save it
000CBE  1  60                   RTS
000CBF  1               ;called by SYNTHE to set SYMLOC(MP) to AY
000CBF  1               STSLMP
000CBF  1  48                   PHA                     ;save low
000CC0  1  A5 7C                LDA     MP              ;get MP
000CC2  1  4C B4 0C             JMP     STSL            ;go do
000CC5  1               ;called by SYNTHE to set TYPE(SP) to A
000CC5  1               STTYSP
000CC5  1  A6 7B                LDX     SP              ;get SP
000CC7  1  9D FA 2E             STA     TYPE,X          ;save
000CCA  1  60                   RTS
000CCB  1               ;called by SYNTHE to set STYPE(SP) to A
000CCB  1               STSTSP
000CCB  1  A6 7B                LDX     SP              ;get SP
000CCD  1  9D 1A 2F             STA     STYPE,X         ;save
000CD0  1  60                   RTS
000CD1  1               ;set STYPE(MP) to A
000CD1  1               STSTMP
000CD1  1  A6 7C                LDX     MP              ;get MP
000CD3  1  9D 1A 2F             STA     STYPE,X         ;save
000CD6  1  60                   RTS
000CD7  1               ;set TYPE(MP) to A
000CD7  1               STTYMP
000CD7  1  A6 7C                LDX     MP              ;get MP
000CD9  1  9D FA 2E             STA     TYPE,X          ;save
000CDC  1  60                   RTS
000CDD  1               ;set HASH(MP) to A
000CDD  1               STHAMP
000CDD  1  A6 7C                LDX     MP              ;get MP
000CDF  1  9D BA 2E             STA     HASH,X          ;insert
000CE2  1  60                   RTS
000CE3  1               ;set HASH(SP) to A
000CE3  1               STHASP
000CE3  1  A6 7B                LDX     SP              ;get SP
000CE5  1  9D BA 2E             STA     HASH,X          ;insert
000CE8  1  60                   RTS
000CE9  1               ;set SRLOC(SP) to AY
000CE9  1               STSRSP
000CE9  1  48                   PHA                     ;save low
000CEA  1  A5 7B                LDA     SP              ;get SP
000CEC  1  0A                   ASL     A               ;mult by two
000CED  1  AA                   TAX                     ;make index
000CEE  1  68                   PLA                     ;get low
000CEF  1  9D 3A 2F             STA     SRLOC,X         ;save ir
000CF2  1  98                   TYA                     ;get high
000CF3  1  9D 3B 2F             STA     SRLOC+1,X       ;save it
000CF6  1  60                   RTS
000CF7  1               ;write generated code in A and count size of code area
000CF7  1               GENERT
000CF7  1  E6 B2                INC     CODESI          ;bump
000CF9  1  D0 02                BNE     *+4             ;code
000CFB  1  E6 B3                INC     CODESI+1        ;size
000CFD  1  2C 00 2E             BIT     PASS1           ;test for pass 1
000D00  1  30 03                BMI     *+5             ;branch if
000D02  1  4C B6 09             JMP     EMIT            ;else go emit
000D05  1  60                   RTS
000D06  1               ;write data in A during pass 2 and count size of data area
000D06  1               EMITDT
000D06  1  E6 45                INC     DATACT          ;bump
000D08  1  D0 02                BNE     *+4             ;data
000D0A  1  E6 46                INC     DATACT+1        ;size
000D0C  1  2C 01 2E             BIT     PASS2           ;test for pass 2
000D0F  1  10 03                BPL     *+5             ;branch if not
000D11  1  4C B6 09             JMP     EMIT            ;else go emit
000D14  1  60                   RTS
000D15  1               ;compare ACCUM to reserved word string
000D15  1               COMPAR
000D15  1  A9 00                LDA     #0
000D17  1  85 A1                STA     IC
000D19  1               COMPA0
000D19  1  A4 A1                LDY     IC
000D1B  1  B1 A2                LDAINDIRECTY PTR        ;a=field(i)
000D1D  1  E6 A1                INC     IC
000D1F  1  A4 A1                LDY     IC              ;i=i+1
000D21  1                       .IFDEF DUODYNE
000D21  1                       PHX
000D21  1                       TYX
000D21  1                       CMP     ACCUM,X         ;compare field(i) to accum(i=i+1)
000D21  1                       PLX
000D21  1                       .ELSE
000D21  1  D9 4E 00             CMP     ACCUM,Y         ;compare field(i) to accum(i=i+1)
000D24  1                       .ENDIF
000D24  1  D0 09                BNE     COMPAX          ;exit if different
000D26  1  A5 4E                LDA     ACCLEN
000D28  1  C5 A1                CMP     IC              ;if i<=acclen
000D2A  1  B0 ED                BCS     COMPA0          ;then loop
000D2C  1               COMPAT
000D2C  1  A9 FF                LDA     #TRUE           ;was a match
000D2E  1  60                   RTS
000D2F  1               COMPAX
000D2F  1  A5 4E                LDA     ACCLEN          ;check termination condition
000D31  1  C5 A1                CMP     IC
000D33  1  90 F7                BCC     COMPAT          ;if i>acclen is true
000D35  1  A9 00                LDA     #FALSE
000D37  1  60                   RTS
000D38  1               ;attempt to match reserved word
000D38  1               LOOKUP
000D38  1  A9 09                LDA     #MAXRWL         ;compare max word length
000D3A  1  C5 4E                CMP     ACCLEN          ;to length
000D3C  1  90 5A                BCC     LOOKFL          ;exit as false if too big
000D3E  1  A6 4E                LDX     ACCLEN          ;get length
000D40  1  BD F1 29             LDA     OFFSET,X        ;and offset
000D43  1  18                   CLC                     ;in reserved word table
000D44  1  69 B0                ADC     #<LNG1          ;now add to
000D46  1  85 A2                STA     PTR             ;start to
000D48  1  A9 00                LDA     #0              ;get
000D4A  1  69 28                ADC     #>LNG1          ;indirect
000D4C  1  85 A3                STA     PTR+1           ;pointer
000D4E  1  A9 00                LDA     #0              ;set index
000D50  1  85 A4                STA     IL              ;to zero
000D52  1               LOOKU0
000D52  1  E6 A4                INC     IL              ;bump index
000D54  1  A6 4E                LDX     ACCLEN          ;see if count
000D56  1  BD FB 29             LDA     COUNT,X         ;bigger than
000D59  1  C5 A4                CMP     IL              ;number words
000D5B  1  90 3B                BCC     LOOKFL          ;no match if is
000D5D  1  20 15 0D             JSR     COMPAR          ;try to match
000D60  1  D0 0E                BNE     LOOKMT          ;branch if did
000D62  1  18                   CLC                     ;else
000D63  1  A5 A2                LDA     PTR             ;bump
000D65  1  65 4E                ADC     ACCLEN          ;pointer
000D67  1  85 A2                STA     PTR             ;by length
000D69  1  90 E7                BCC     LOOKU0          ;of word
000D6B  1  E6 A3                INC     PTR+1           ;and try
000D6D  1  4C 52 0D             JMP     LOOKU0          ;next
000D70  1               LOOKMT
000D70  1  A6 4E                LDX     ACCLEN          ;get length
000D72  1  BD 05 2A             LDA     TKOS,X          ;and token offset
000D75  1  18                   CLC                     ;add to
000D76  1  65 A4                ADC     IL              ;index
000D78  1  AA                   TAX                     ;make an index
000D79  1  BD A1 29             LDA     TK,X            ;get token
000D7C  1  85 49                STA     TOKEN           ;and save
000D7E  1  C9 41                CMP     #64+1           ;see if over 64
000D80  1  90 13                BCC     LOOKTR          ;branch if not
000D82  1  C9 63                CMP     #TDATA          ;see if TDATA
000D84  1  F0 0F                BEQ     LOOKTR          ;branch if is
000D86  1  85 4B                STA     FUNCOP          ;else save as FUNCOP
000D88  1  38                   SEC                     ;now subtract
000D89  1  E9 41                SBC     #65             ;65 to
000D8B  1  AA                   TAX                     ;make index
000D8C  1  BD 0F 2A             LDA     ST,X            ;get subtype
000D8F  1  85 4A                STA     SUBTYP          ;and save
000D91  1  A9 35                LDA     #FUNCT
000D93  1  85 49                STA     TOKEN           ;token=funct
000D95  1               LOOKTR
000D95  1  A9 FF                LDA     #TRUE           ;match
000D97  1  60                   RTS
000D98  1               LOOKFL
000D98  1  A9 00                LDA     #FALSE          ;no match
000D9A  1  60                   RTS
000D9B  1               ;scanner accepts input characters from the source file returning tokens to the
000D9B  1               ;parser.  conversion to uppercase is performed if LWRUPR is set.  each token is
000D9B  1               ;placed in ACCUM and ACCLEN is the length of the token.  the token is hashed by
000D9B  1               ;summing each ASCII character modulo HSHTSZ (hashtablesize) and is stored in
000D9B  1               ;HSHCDE (hashcode).  SUBTYP and FUNCOP are set if the token is a predefined
000D9B  1               ;function.  REM and DATA statements are handled completely by the scanner. REM
000D9B  1               ;and REMARK statements cause the input to be scanned until the end of the
000D9B  1               ;current input line is located.  the cr is then scanned and returned.  DATA
000D9B  1               ;statements are similar except data is output using EMITDT.
000D9B  1               SCANNR
000D9B  1  A9 00                LDA     #0              ;clear
000D9D  1  85 4E                STA     ACCLEN          ;these
000D9F  1  85 4C                STA     HSHCDE          ;variables
000DA1  1  85 49                STA     TOKEN           ;at
000DA3  1  85 4A                STA     SUBTYP          ;start
000DA5  1  24 6E                BIT     CONT            ;test continue flag
000DA7  1  30 13                BMI     SCAN1           ;branch if set
000DA9  1  2C 08 2E             BIT     EOLSTS          ;test eol status
000DAC  1  10 08                BPL     SCAN28          ;skip if char ready
000DAE  1  20 91 0A             JSR     GTNBLK          ;else go read
000DB1  1  A9 00                LDA     #0              ;then clear flag
000DB3  1  8D 08 2E             STA     EOLSTS
000DB6  1               SCAN28
000DB6  1  A5 4D                LDA     NXTCHR          ;else get next
000DB8  1  C9 22                CMP     #'"'            ;see if "
000DBA  1  D0 2E                BNE     SCAN5           ;branch if not
000DBC  1               ;first case is string or string continuation
000DBC  1               SCAN1
000DBC  1  A9 32                LDA     #STRING         ;get token
000DBE  1  85 49                STA     TOKEN           ;and set
000DC0  1  A9 00                LDA     #FALSE          ;and set
000DC2  1  85 6E                STA     CONT            ;CONT as false
000DC4  1               SCAN2
000DC4  1  20 15 0A             JSR     GETCHR          ;get char
000DC7  1  C9 22                CMP     #'"'            ;see if delimiter
000DC9  1  F0 11                BEQ     SCAN4           ;branch if is
000DCB  1  C9 0D                CMP     #CR             ;see if eol
000DCD  1  D0 05                BNE     SCAN3           ;branch if not
000DCF  1  A9 16                LDA     #22             ;else is unterminated string
000DD1  1  4C AE 0A             JMP     ERROR           ;do error and quit
000DD4  1               SCAN3
000DD4  1  20 9A 0B             JSR     PUTACC          ;put in ACCUM
000DD7  1  24 6E                BIT     CONT            ;test for continue
000DD9  1  10 E9                BPL     SCAN2           ;loop if not
000DDB  1  60                   RTS                     ;else done
000DDC  1               SCAN4
000DDC  1  20 91 0A             JSR     GTNBLK          ;get non-blank
000DDF  1  C9 22                CMP     #'"'            ;see if another delimiter
000DE1  1  F0 01                BEQ     *+3             ;branch if is
000DE3  1  60                   RTS                     ;else done
000DE4  1  20 9A 0B             JSR     PUTACC          ;put in ACCUM
000DE7  1  4C C4 0D             JMP     SCAN2           ;and loop
000DEA  1               SCAN5
000DEA  1  20 C4 0B             JSR     NUMRIC          ;see if number
000DED  1  D0 05                BNE     SCAN6           ;branch if is
000DEF  1  20 E4 0B             JSR     DCMLPT          ;see if decimal point
000DF2  1  F0 51                BEQ     SCAN15          ;branch if not
000DF4  1               ;is a numeric of up to IDNTSZ-1 characters
000DF4  1               SCAN6
000DF4  1  A9 31                LDA     #FLOTPT         ;get token
000DF6  1  85 49                STA     TOKEN           ;and set
000DF8  1  A5 4D                LDA     NXTCHR          ;get next char
000DFA  1               SCAN7
000DFA  1  C9 30                CMP     #'0'            ;see if leading zero
000DFC  1  D0 06                BNE     SCAN8           ;branch if not
000DFE  1  20 15 0A             JSR     GETCHR          ;else get next
000E01  1  4C FA 0D             JMP     SCAN7           ;and loop to flush
000E04  1               SCAN8
000E04  1  20 28 0C             JSR     SPLNUM          ;spool numeric
000E07  1  20 E4 0B             JSR     DCMLPT          ;test for decimal point
000E0A  1  F0 06                BEQ     SCAN9           ;branch if not
000E0C  1  20 BE 0B             JSR     PUTCHR          ;insert it
000E0F  1  20 28 0C             JSR     SPLNUM          ;spool rest
000E12  1               SCAN9
000E12  1  20 F0 0B             JSR     CNVLWR          ;convert next to upper
000E15  1  A5 4D                LDA     NXTCHR          ;get it
000E17  1  C9 45                CMP     #'E'            ;see if e for exponent
000E19  1  D0 1B                BNE     SCAN13          ;branch if not
000E1B  1  20 B8 0B             JSR     PUTGET          ;else insert and get another
000E1E  1  C9 2B                CMP     #'+'            ;if a +
000E20  1  F0 04                BEQ     SCAN10          ;go insert and get another
000E22  1  C9 2D                CMP     #'-'            ;if not a -
000E24  1  D0 03                BNE     SCAN11          ;skip ahead
000E26  1               SCAN10
000E26  1  20 B8 0B             JSR     PUTGET          ;insert and get
000E29  1               SCAN11
000E29  1  20 C4 0B             JSR     NUMRIC          ;test for number
000E2C  1  D0 05                BNE     SCAN12          ;branch if is
000E2E  1  A9 09                LDA     #9              ;else illegal floating point format
000E30  1  20 AE 0A             JSR     ERROR           ;error
000E33  1               SCAN12
000E33  1  20 28 0C             JSR     SPLNUM          ;spool numbers
000E36  1               SCAN13
000E36  1  A5 4E                LDA     ACCLEN          ;get length
000E38  1  D0 08                BNE     SCAN14          ;branch if not zero
000E3A  1  E6 4E                INC     ACCLEN          ;else bump
000E3C  1  A9 30                LDA     #'0'            ;and insert a '0'
000E3E  1  85 4F                STA     ACCUM+1         ;in ACCUM
000E40  1  85 4C                STA     HSHCDE          ;and hashcode
000E42  1               SCAN14
000E42  1  4C 34 0C             JMP     SUPNCL          ;setupnextcall and return
000E45  1               SCAN15
000E45  1  20 00 0C             JSR     LETTER          ;see if letter
000E48  1  D0 03                BNE     *+5             ;continue if is
000E4A  1  4C E1 0E             JMP     SCAN26          ;else go to next section
000E4D  1               ;is an identifier or may be REM, REMARK, or DATA statements. these two are
000E4D  1               ;handled here
000E4D  1               SCAN16
000E4D  1  20 19 0C             JSR     ALPNUM          ;test for alphanumeric
000E50  1  F0 06                BEQ     SCAN17          ;branch if not
000E52  1  20 BE 0B             JSR     PUTCHR          ;else insert and get
000E55  1  4C 4D 0E             JMP     SCAN16          ;and loop
000E58  1               SCAN17
000E58  1  A5 4D                LDA     NXTCHR          ;get next char
000E5A  1  C9 24                CMP     #'$'            ;if not a $
000E5C  1  D0 0A                BNE     SCAN18          ;is floating
000E5E  1  A9 32                LDA     #STRING         ;else set string
000E60  1  85 4A                STA     SUBTYP          ;as subtype
000E62  1  20 BE 0B             JSR     PUTCHR          ;put and get
000E65  1  4C 6C 0E             JMP     SCAN19          ;and continue
000E68  1               SCAN18
000E68  1  A9 31                LDA     #FLOTPT         ;set floating
000E6A  1  85 4A                STA     SUBTYP          ;as subtype
000E6C  1               SCAN19
000E6C  1  20 38 0D             JSR     LOOKUP          ;try to match
000E6F  1  D0 20                BNE     SCAN21          ;branch if reserved
000E71  1  A5 4F                LDA     ACCUM+1         ;check for user
000E73  1  C9 46                CMP     #'F'            ;defined function
000E75  1  D0 13                BNE     SCAN20          ;branch if not
000E77  1  A5 50                LDA     ACCUM+2         ;same for next
000E79  1  C9 4E                CMP     #'N'            ;char in ACCUM
000E7B  1  D0 0D                BNE     SCAN20
000E7D  1  A5 4E                LDA     ACCLEN          ;get length
000E7F  1  C9 01                CMP     #1              ;must not be 1
000E81  1  F0 07                BEQ     SCAN20          ;branch if is
000E83  1  A9 36                LDA     #UDFUNC         ;ah!ah! is FN--
000E85  1  85 49                STA     TOKEN           ;set token
000E87  1  4C 34 0C             JMP     SUPNCL          ;exit with setupnextcall
000E8A  1               SCAN20
000E8A  1  A9 34                LDA     #IDENT          ;is identifier
000E8C  1  85 49                STA     TOKEN           ;set token
000E8E  1  4C 34 0C             JMP     SUPNCL          ;exit with setupnextcall
000E91  1               SCAN21
000E91  1  A5 49                LDA     TOKEN           ;is a reserved
000E93  1  C9 00                CMP     #TREM           ;see if REM
000E95  1  D0 12                BNE     SCAN23          ;branch if not
000E97  1               SCAN22
000E97  1  A5 4D                LDA     NXTCHR          ;get next
000E99  1  C9 0D                CMP     #CR             ;see if eol
000E9B  1  D0 03                BNE     *+5             ;branch if not
000E9D  1  4C 9B 0D             JMP     SCANNR          ;else loop to start
000EA0  1  20 15 0A             JSR     GETCHR          ;get char
000EA3  1  20 9D 0A             JSR     CHKCNT          ;check for continue
000EA6  1  4C 97 0E             JMP     SCAN22          ;and loop
000EA9  1               SCAN23
000EA9  1  C9 63                CMP     #TDATA          ;see if DATA
000EAB  1  F0 03                BEQ     *+5             ;branch if is
000EAD  1  4C 34 0C             JMP     SUPNCL          ;else setupnextcall and exit
000EB0  1  A9 33                LDA     #DAT            ;emit DAT opcode
000EB2  1  20 06 0D             JSR     EMITDT          ;to start
000EB5  1  A5 4D                LDA     NXTCHR          ;get next
000EB7  1  20 06 0D             JSR     EMITDT          ;emit it
000EBA  1               SCAN24
000EBA  1  20 15 0A             JSR     GETCHR          ;get another
000EBD  1  C9 0D                CMP     #CR             ;see if eol
000EBF  1  F0 0B                BEQ     SCAN25          ;branch if is
000EC1  1  20 9D 0A             JSR     CHKCNT          ;else check for continue
000EC4  1  A5 4D                LDA     NXTCHR          ;get char
000EC6  1  20 06 0D             JSR     EMITDT          ;emit it
000EC9  1  4C BA 0E             JMP     SCAN24          ;and loop
000ECC  1               SCAN25
000ECC  1  A9 2C                LDA     #','            ;now emit
000ECE  1  20 06 0D             JSR     EMITDT          ;a comma
000ED1  1  A9 00                LDA     #0              ;and a
000ED3  1  20 06 0D             JSR     EMITDT          ;zero
000ED6  1  A5 45                LDA     DATACT          ;now
000ED8  1  D0 02                BNE     *+4             ;drop
000EDA  1  C6 46                DEC     DATACT+1        ;data count
000EDC  1  C6 45                DEC     DATACT          ;by one
000EDE  1  4C 9B 0D             JMP     SCANNR          ;and loop to start
000EE1  1               ;final case is a special character -- it may be continuation char in which case
000EE1  1               ;just go to next line and scan somemore
000EE1  1               SCAN26
000EE1  1  A5 4D                LDA     NXTCHR          ;get char
000EE3  1  C9 5C                CMP     #backsl         ;see if continue
000EE5  1  D0 06                BNE     SCAN27          ;branch if not
000EE7  1  20 9D 0A             JSR     CHKCNT          ;check it
000EEA  1  4C 9B 0D             JMP     SCANNR          ;and loop
000EED  1               SCAN27
000EED  1  20 9A 0B             JSR     PUTACC          ;put in accum
000EF0  1  A5 4D                LDA     NXTCHR          ;get last char
000EF2  1  C9 0D                CMP     #CR             ;see if eol
000EF4  1  D0 07                BNE     SCAN29          ;not so skip
000EF6  1  A9 FF                LDA     #$FF            ;set flag to read
000EF8  1  8D 08 2E             STA     EOLSTS
000EFB  1  30 03                BMI     SCAN30          ;then jump ahead
000EFD  1               SCAN29
000EFD  1  20 91 0A             JSR     GTNBLK          ;get non blank
000F00  1               SCAN30
000F00  1  20 38 0D             JSR     LOOKUP          ;see if match
000F03  1  F0 01                BEQ     *+3             ;branch if not
000F05  1  60                   RTS                     ;else done
000F06  1  A9 07                LDA     #7              ;illegal character error
000F08  1  4C AE 0A             JMP     ERROR           ;and quit
000F0B  1               ;adjust base for next entry
000F0B  1               NXTENT
000F0B  1  A0 00                LDY     #0              ;clear index
000F0D  1  B1 A7                LDAINDIRECTY BASE       ;get name length
000F0F  1  18                   CLC                     ;now
000F10  1  65 A7                ADC     BASE            ;add to current
000F12  1  85 A7                STA     BASE            ;and update
000F14  1  90 02                BCC     *+4             ;don't forget
000F16  1  E6 A8                INC     BASE+1          ;carry
000F18  1  18                   CLC                     ;now
000F19  1  A5 A7                LDA     BASE            ;add
000F1B  1  69 07                ADC     #7              ;seven for
000F1D  1  85 A7                STA     BASE            ;overhead
000F1F  1  90 02                BCC     *+4             ;to get
000F21  1  E6 A8                INC     BASE+1          ;new base
000F23  1  60                   RTS
000F24  1               ;get length of printname
000F24  1               GETLEN
000F24  1  A0 00                LDY     #0              ;clear index
000F26  1  B1 A7                LDAINDIRECTY BASE       ;get length
000F28  1  60                   RTS
000F29  1               ;write numeric constant during pass 1
000F29  1               EMITCN
000F29  1  2C 00 2E             BIT     PASS1           ;test for pass 1
000F2C  1  30 01                BMI     *+3             ;branch if is
000F2E  1  60                   RTS                     ;else done
000F2F  1  4C B6 09             JMP     EMIT            ;write byte
000F32  1               ;write two bytes of object code on disk for literals
000F32  1               GENTWO
000F32  1  48                   PHA                     ;save low
000F33  1  98                   TYA                     ;get high
000F34  1  20 F7 0C             JSR     GENERT          ;write it
000F37  1  68                   PLA                     ;get low
000F38  1  4C F7 0C             JMP     GENERT          ;do it
000F3B  1               ;
000F3B  1               LITERL
000F3B  1  48                   PHA                     ;save low
000F3C  1  98                   TYA                     ;get high
000F3D  1  09 80                ORA     #$80            ;set msb
000F3F  1  A8                   TAY                     ;back to Y
000F40  1  68                   PLA                     ;get low
000F41  1  4C 32 0F             JMP     GENTWO          ;send it
000F44  1               ;
000F44  1               LITLOD
000F44  1  48                   PHA                     ;save low
000F45  1  98                   TYA                     ;get high
000F46  1  09 C0                ORA     #$C0            ;or with mask
000F48  1  A8                   TAY                     ;back to Y
000F49  1  68                   PLA                     ;get low
000F4A  1  4C 32 0F             JMP     GENTWO          ;write it
000F4D  1               ;
000F4D  1               LINENU
000F4D  1  2C 04 2E             BIT     DEBUGL          ;test debug flag
000F50  1  30 01                BMI     *+3             ;branch if set
000F52  1  60                   RTS                     ;else do nothing
000F53  1  A5 70                LDA     LINENO          ;get low
000F55  1  A4 71                LDY     LINENO+1        ;and high number
000F57  1  20 3B 0F             JSR     LITERL          ;send as literal
000F5A  1  A9 5F                LDA     #BOL            ;then send BOL
000F5C  1  4C F7 0C             JMP     GENERT          ;opcode
000F5F  1               ;fill hashtable with 0's and initialize pointer to top of symbol table
000F5F  1               INSYMT
000F5F  1  2C 00 2E             BIT     PASS1           ;see if pass 1
000F62  1  10 14                BPL     INSYM1          ;branch if not
000F64  1  A2 7F                LDX     #HSHTSZ*2-1     ;get number to clear
000F66  1  A9 00                LDA     #0              ;then value
000F68  1               INSYM0
000F68  1  9D 3A 2E             STA     HSHTBL,X        ;store it
000F6B  1  CA                   DEX                     ;drop count
000F6C  1  E0 FF                CPX     #255            ;see if wrap
000F6E  1  D0 F8                BNE     INSYM0          ;loop if not
000F70  1  A9 C1                LDA     #<MEMORY        ;get memory
000F72  1  A0 31                LDY     #>MEMORY        ;start
000F74  1  85 AA                STA     SBTBL           ;and set
000F76  1  84 AB                STY     SBTBL+1         ;table start
000F78  1               INSYM1
000F78  1  AD 04 01             LDA     PEM+1           ;get limit
000F7B  1  AC 05 01             LDY     PEM+2           ;of memory
000F7E  1  38                   SEC                     ;drop
000F7F  1  E9 02                SBC     #2              ;two
000F81  1  85 A5                STA     SBTTOP          ;to get
000F83  1  85 B9                STA     NXSTPT          ;top starting
000F85  1  B0 01                BCS     *+3             ;branch if no borrow
000F87  1  88                   DEY                     ;else drop Y
000F88  1  84 A6                STY     SBTTOP+1        ;set high
000F8A  1  84 BA                STY     NXSTPT+1        ;and set
000F8C  1  A9 00                LDA     #0              ;clear A
000F8E  1  A0 01                LDY     #1              ;set index to 1
000F90  1  91 B9                STAINDIRECTY NXSTPT     ;put in memory
000F92  1  60                   RTS
000F93  1               ;
000F93  1               GETHSH
000F93  1  A0 00                LDY     #0              ;get
000F95  1  B1 A7                LDAINDIRECTY BASE       ;PTR
000F97  1  85 BC                STA     TMPPTR          ;and save
000F99  1  84 BB                STY     TMPHSH          ;clear internal hash
000F9B  1  A5 A7                LDA     BASE            ;get
000F9D  1  A4 A8                LDY     BASE+1          ;base
000F9F  1  18                   CLC                     ;now
000FA0  1  69 02                ADC     #2              ;add 2
000FA2  1  85 AC                STA     APTADD          ;and save
000FA4  1  90 01                BCC     *+3             ;branch if
000FA6  1  C8                   INY                     ;no carry
000FA7  1  84 AD                STY     APTADD+1        ;save high
000FA9  1  A0 01                LDY     #1              ;set starting index
000FAB  1               GETHS0
000FAB  1  C4 BC                CPY     TMPPTR          ;compare to limit
000FAD  1  F0 05                BEQ     GETHS1          ;continue if equal
000FAF  1  90 03                BCC     GETHS1          ;branch if less
000FB1  1  A5 BB                LDA     TMPHSH          ;else get HASH
000FB3  1  60                   RTS                     ;and quit
000FB4  1               GETHS1
000FB4  1  B1 AC                LDAINDIRECTY APTADD     ;get value
000FB6  1  18                   CLC                     ;now add
000FB7  1  65 BB                ADC     TMPHSH          ;in old hash
000FB9  1  29 3F                AND     #HSHMSK         ;and mask
000FBB  1  85 BB                STA     TMPHSH          ;and save
000FBD  1  C8                   INY                     ;bump loop index
000FBE  1  4C AB 0F             JMP     GETHS0          ;then loop
000FC1  1               ;
000FC1  1               HSOSYM
000FC1  1  A5 B7                LDA     SYMHSH          ;get symhsh
000FC3  1  0A                   ASL     A               ;mult by two
000FC4  1  AA                   TAX                     ;make index
000FC5  1  BD 3A 2E             LDA     HSHTBL,X        ;get value
000FC8  1  BC 3B 2E             LDY     HSHTBL+1,X      ;in table
000FCB  1  60                   RTS
000FCC  1               ;
000FCC  1               SETLNK
000FCC  1  A6 A7                LDX     BASE            ;get
000FCE  1  A4 A8                LDY     BASE+1          ;base
000FD0  1  E8                   INX                     ;bump
000FD1  1  86 AC                STX     APTADD          ;by
000FD3  1  D0 01                BNE     *+3             ;one
000FD5  1  C8                   INY                     ;and
000FD6  1  84 AD                STY     APTADD+1        ;save
000FD8  1  60                   RTS
000FD9  1               ;set pointer for addr reference with offset in A
000FD9  1               SETADP
000FD9  1  A0 00                LDY     #0              ;clear index
000FDB  1  18                   CLC                     ;and carry
000FDC  1  71 A7                ADCINDIRECTY BASE       ;add PTR
000FDE  1  90 01                BCC     *+3             ;branch if no carry
000FE0  1  C8                   INY                     ;else set Y to 1
000FE1  1  18                   CLC                     ;clear carry
000FE2  1  65 A7                ADC     BASE            ;add base
000FE4  1  85 AC                STA     APTADD          ;to low
000FE6  1  98                   TYA                     ;now add
000FE7  1  65 A8                ADC     BASE+1          ;with carry to high
000FE9  1  85 AD                STA     APTADD+1        ;and save
000FEB  1  60                   RTS
000FEC  1               ;check to see if additional SBTBL entry will overflow limits of memory. if
000FEC  1               ;so then abort else return. at entry A contains amount to be added (COUNT)
000FEC  1               LIMITS
000FEC  1  18                   CLC                     ;add count
000FED  1  65 AA                ADC     SBTBL           ;to start
000FEF  1  A4 AB                LDY     SBTBL+1         ;with
000FF1  1  90 01                BCC     *+3             ;carry to
000FF3  1  C8                   INY                     ;high
000FF4  1  C5 A5                CMP     SBTTOP          ;compare to limit
000FF6  1  98                   TYA                     ;including
000FF7  1  E5 A6                SBC     SBTTOP+1        ;high
000FF9  1  B0 01                BCS     *+3             ;whoops! no borrow
000FFB  1  60                   RTS                     ;else ok
000FFC  1  A9 FF                LDA     #TRUE           ;set to
000FFE  1  8D 01 2E             STA     PASS2           ;pass 2
001001  1  A9 13                LDA     #19             ;symbol table error
001003  1  20 AE 0A             JSR     ERROR           ;send it
001006  1  4C 00 01             JMP     BOOT            ;and abort
001009  1               ;set the address field at location LOC in AY and resolved bit
001009  1               SETRSV
001009  1  48                   PHA                     ;save
00100A  1  98                   TYA                     ;A
00100B  1  48                   PHA                     ;and Y
00100C  1  A9 04                LDA     #4              ;set offset
00100E  1  20 D9 0F             JSR     SETADP          ;of four
001011  1  A0 01                LDY     #1              ;set index to 1
001013  1  68                   PLA                     ;get high
001014  1  91 AC                STAINDIRECTY APTADD     ;and save
001016  1  88                   DEY                     ;drop Y to 0
001017  1  68                   PLA                     ;get low
001018  1  91 AC                STAINDIRECTY APTADD     ;save it
00101A  1  A5 AC                LDA     APTADD          ;now
00101C  1  D0 02                BNE     *+4             ;drop
00101E  1  C6 AD                DEC     APTADD+1        ;pointer
001020  1  C6 AC                DEC     APTADD          ;by one
001022  1  B1 AC                LDAINDIRECTY APTADD     ;now set
001024  1  09 80                ORA     #$80            ;resolved
001026  1  91 AC                STAINDIRECTY APTADD     ;bit
001028  1  60                   RTS
001029  1               ;return type of variable
001029  1               GETTYP
001029  1  A9 03                LDA     #3              ;build
00102B  1  20 D9 0F             JSR     SETADP          ;new indirect
00102E  1  A0 00                LDY     #0              ;clear index
001030  1  B1 AC                LDAINDIRECTY APTADD     ;get
001032  1  29 7F                AND     #$7F            ;mask out set bit
001034  1  60                   RTS
001035  1               ;set type of variable to A and preserve resolved bit
001035  1               SETTYP
001035  1  48                   PHA                     ;save type
001036  1  A9 03                LDA     #3              ;calculate
001038  1  20 D9 0F             JSR     SETADP          ;new pointer
00103B  1  A0 00                LDY     #0              ;clear index
00103D  1  68                   PLA                     ;get type
00103E  1  11 AC                ORAINDIRECTY APTADD     ;or with contents
001040  1  91 AC                STAINDIRECTY APTADD     ;save it
001042  1  60                   RTS
001043  1               ;get resolved bit A:=TRUE iff bit=1 else A:=FALSE
001043  1               GETRES
001043  1  A9 03                LDA     #3              ;build
001045  1  20 D9 0F             JSR     SETADP          ;pointer
001048  1  A0 00                LDY     #0              ;clear index
00104A  1  B1 AC                LDAINDIRECTY APTADD     ;get byte
00104C  1  30 03                BMI     *+5             ;branch if set
00104E  1  A9 00                LDA     #FALSE          ;else set
001050  1  60                   RTS                     ;false
001051  1  A9 FF                LDA     #TRUE           ;was set
001053  1  60                   RTS
001054  1               ;get the address of the printname location in AY
001054  1               GETADR
001054  1  A9 04                LDA     #4              ;build
001056  1  20 D9 0F             JSR     SETADP          ;pointer
001059  1  A0 00                LDY     #0              ;clear index
00105B  1  B1 AC                LDAINDIRECTY APTADD     ;now get low
00105D  1  48                   PHA                     ;save
00105E  1  C8                   INY                     ;set Y to 1
00105F  1  B1 AC                LDAINDIRECTY APTADD     ;get high
001061  1  A8                   TAY                     ;move to Y
001062  1  68                   PLA                     ;get low
001063  1  60                   RTS
001064  1               ;check to see if printname located at address in PRNTNM is in SBTBL. if is
001064  1               ;then A:=TRUE and BASE:=address else A:=FALSE
001064  1               SLOOKU
001064  1  20 C1 0F             JSR     HSOSYM          ;find base
001067  1               SLOOKX
001067  1  85 A7                STA     BASE            ;and
001069  1  84 A8                STY     BASE+1          ;save
00106B  1               SLOOK0
00106B  1  A5 A7                LDA     BASE            ;see if
00106D  1  05 A8                ORA     BASE+1          ;base = 0
00106F  1  F0 2B                LBEQ     SLOOFL         ;false if is
001071  1  A0 00                LDY     #0              ;clear index
001073  1  B1 A7                LDAINDIRECTY BASE       ;get PTR
001075  1  85 BD                STA     LEN             ;save as length
001077  1  D1 B5                CMPINDIRECTY PRNTNM     ;compare
001079  1  D0 11                BNE     SLOOK2          ;branch if different
00107B  1               SLOOK1
00107B  1  A4 BD                LDY     LEN             ;get length
00107D  1  B1 B5                LDAINDIRECTY PRNTNM     ;get name
00107F  1  C8                   INY                     ;bump index
001080  1  C8                   INY                     ;by two
001081  1  D1 A7                CMPINDIRECTY BASE       ;compare to entry
001083  1  D0 07                BNE     SLOOK2          ;branch if different
001085  1  C6 BD                DEC     LEN             ;drop length
001087  1  D0 F2                BNE     SLOOK1          ;loop for more
001089  1  A9 FF                LDA     #TRUE           ;else say true
00108B  1  60                   RTS
00108C  1               SLOOK2
00108C  1  20 CC 0F             JSR     SETLNK          ;set link
00108F  1  A0 00                LDY     #0              ;clear index
001091  1  B1 AC                LDAINDIRECTY APTADD     ;get low
001093  1  48                   PHA                     ;save it
001094  1  C8                   INY                     ;set y to 1
001095  1  B1 AC                LDAINDIRECTY APTADD     ;get high
001097  1  A8                   TAY                     ;move to Y
001098  1  68                   PLA                     ;get low
001099  1  4C 67 10             JMP     SLOOKX          ;and loop
00109C  1               SLOOFL
00109C  1  A9 00                LDA     #FALSE          ;was not
00109E  1  60                   RTS                     ;found
00109F  1               ;enter token reference by PRNTNM and SYMHSH into next available location in the
00109F  1               ;symbol table.  set BASE to beginning of this entry and increment SBTBL. check
00109F  1               ;for symbol table full
00109F  1               ENTER
00109F  1  A0 00                LDY     #0              ;clear index
0010A1  1  B1 B5                LDAINDIRECTY PRNTNM     ;get length
0010A3  1  18                   CLC                     ;now
0010A4  1  69 07                ADC     #7              ;add seven
0010A6  1  48                   PHA                     ;save on stack
0010A7  1  20 EC 0F             JSR     LIMITS          ;test limits
0010AA  1  A5 AA                LDA     SBTBL           ;update
0010AC  1  A4 AB                LDY     SBTBL+1         ;base
0010AE  1  85 A7                STA     BASE
0010B0  1  84 A8                STY     BASE+1
0010B2  1  A0 00                LDY     #0              ;get
0010B4  1  B1 B5                LDAINDIRECTY PRNTNM     ;length
0010B6  1  91 A7                STAINDIRECTY BASE       ;move to table
0010B8  1  AA                   TAX                     ;make a counter
0010B9  1  F0 0B                BEQ     ENTER1          ;done if zero
0010BB  1  C8                   INY                     ;start with Y=1
0010BC  1               ENTER0
0010BC  1  B1 B5                LDAINDIRECTY PRNTNM     ;get name
0010BE  1  C8                   INY                     ;bump index
0010BF  1  C8                   INY                     ;by two
0010C0  1  91 AA                STAINDIRECTY SBTBL      ;insert
0010C2  1  88                   DEY                     ;drop y by one
0010C3  1  CA                   DEX                     ;drop count
0010C4  1  D0 F6                BNE     ENTER0          ;loop if more
0010C6  1               ENTER1
0010C6  1  A9 03                LDA     #3              ;clear resolve bit
0010C8  1  20 D9 0F             JSR     SETADP          ;by getting pointer
0010CB  1  A0 00                LDY     #0              ;clear index
0010CD  1  98                   TYA                     ;and A
0010CE  1  91 AC                STAINDIRECTY APTADD     ;insert
0010D0  1  20 CC 0F             JSR     SETLNK          ;set link
0010D3  1  20 C1 0F             JSR     HSOSYM          ;find address
0010D6  1  48                   PHA                     ;save low on stack
0010D7  1  98                   TYA                     ;high to A
0010D8  1  A0 01                LDY     #1              ;do high
0010DA  1  91 AC                STAINDIRECTY APTADD     ;first
0010DC  1  88                   DEY                     ;drop Y
0010DD  1  68                   PLA                     ;get low
0010DE  1  91 AC                STAINDIRECTY APTADD     ;and set
0010E0  1  A5 B7                LDA     SYMHSH          ;get hash
0010E2  1  0A                   ASL     A               ;mult by two
0010E3  1  AA                   TAX                     ;make index
0010E4  1  A5 A7                LDA     BASE            ;get
0010E6  1  9D 3A 2E             STA     HSHTBL,X        ;and move
0010E9  1  A5 A8                LDA     BASE+1          ;to
0010EB  1  9D 3B 2E             STA     HSHTBL+1,X      ;table
0010EE  1  68                   PLA                     ;get new length
0010EF  1  18                   CLC                     ;now
0010F0  1  65 AA                ADC     SBTBL           ;to start
0010F2  1  85 AA                STA     SBTBL           ;to get
0010F4  1  90 02                BCC     *+4             ;new
0010F6  1  E6 AB                INC     SBTBL+1         ;table address
0010F8  1  60                   RTS
0010F9  1               ;insert subtype in SBTBL
0010F9  1               SETSUB
0010F9  1  48                   PHA                     ;save code
0010FA  1  A9 06                LDA     #6              ;offset pointer
0010FC  1  20 D9 0F             JSR     SETADP          ;get pointer
0010FF  1  A0 00                LDY     #0              ;clear index
001101  1  68                   PLA                     ;get code
001102  1  91 AC                STAINDIRECTY APTADD     ;save
001104  1  60                   RTS
001105  1               ;return the subtype
001105  1               GETSUB
001105  1  A9 06                LDA     #6              ;build
001107  1  20 D9 0F             JSR     SETADP          ;pointer
00110A  1  A0 00                LDY     #0              ;clear pointer
00110C  1  B1 AC                LDAINDIRECTY APTADD     ;get subtype
00110E  1  60                   RTS
00110F  1               ;
00110F  1               UNLINK
00110F  1  20 29 10             JSR     GETTYP          ;get type
001112  1  85 BE                STA     NUMPRM          ;save it
001114  1  A9 01                LDA     #1              ;set index
001116  1  85 BF                STA     LINKI           ;to one
001118  1               UNLNK0
001118  1  A5 BE                LDA     NUMPRM          ;compare limit
00111A  1  C5 BF                CMP     LINKI           ;to count
00111C  1  B0 01                BCS     *+3             ;continue if ok
00111E  1  60                   RTS                     ;else done
00111F  1  20 0B 0F             JSR     NXTENT          ;get next
001122  1  20 93 0F             JSR     GETHSH          ;and hash
001125  1  0A                   ASL     A               ;mult
001126  1  18                   CLC                     ;by two
001127  1  69 3A                ADC     #<HSHTBL        ;and add
001129  1  85 C0                STA     TMPADR          ;hash table start
00112B  1  A0 2E                LDY     #>HSHTBL        ;get high
00112D  1  90 01                BCC     *+3             ;with carry
00112F  1  C8                   INY                     ;bump
001130  1  84 C1                STY     TMPADR+1        ;and save
001132  1               UNLNK1
001132  1  A0 00                LDY     #0              ;clear index
001134  1  A5 A7                LDA     BASE            ;compare base low
001136  1  D1 C0                CMPINDIRECTY TMPADR     ;to byte
001138  1  D0 07                BNE     UNLNK2          ;branch if different
00113A  1  C8                   INY                     ;set y to 1
00113B  1  A5 A8                LDA     BASE+1          ;do same
00113D  1  D1 C0                CMPINDIRECTY TMPADR     ;for high
00113F  1  F0 16                BEQ     UNLNK3          ;branch if all same
001141  1               UNLNK2
001141  1  A0 00                LDY     #0              ;y back to zero
001143  1  B1 C0                LDAINDIRECTY TMPADR     ;get low
001145  1  48                   PHA                     ;save it
001146  1  C8                   INY                     ;bump index
001147  1  B1 C0                LDAINDIRECTY TMPADR     ;get high
001149  1  85 C1                STA     TMPADR+1        ;change address
00114B  1  68                   PLA                     ;get low
00114C  1  85 C0                STA     TMPADR          ;save it
00114E  1  E6 C0                INC     TMPADR
001150  1  D0 E0                BNE     UNLNK1
001152  1  E6 C1                INC     TMPADR+1
001154  1  4C 32 11             JMP     UNLNK1          ;and loop
001157  1               UNLNK3
001157  1  20 CC 0F             JSR     SETLNK          ;set link
00115A  1  A0 00                LDY     #0              ;clear index
00115C  1  B1 AC                LDAINDIRECTY APTADD     ;get low
00115E  1  91 C0                STAINDIRECTY TMPADR     ;and move
001160  1  C8                   INY                     ;now
001161  1  B1 AC                LDAINDIRECTY APTADD     ;same
001163  1  91 C0                STAINDIRECTY TMPADR     ;for high
001165  1  E6 BF                INC     LINKI           ;bump loop index
001167  1  4C 18 11             JMP     UNLNK0          ;and loop
00116A  1               ;
00116A  1               RELINK
00116A  1  20 29 10             JSR     GETTYP          ;get type
00116D  1  85 BE                STA     NUMPRM          ;save it
00116F  1  A9 01                LDA     #1              ;set count
001171  1  85 BF                STA     LINKI           ;to one
001173  1               RELNK0
001173  1  A5 BE                LDA     NUMPRM          ;get limit and
001175  1  C5 BF                CMP     LINKI           ;compare to count
001177  1  B0 01                BCS     *+3             ;branch if >=
001179  1  60                   RTS                     ;else done
00117A  1  20 0B 0F             JSR     NXTENT          ;do next entry
00117D  1  A5 A7                LDA     BASE            ;now set
00117F  1  A4 A8                LDY     BASE+1          ;temp
001181  1  85 C0                STA     TMPADR
001183  1  E6 C0                INC     TMPADR          ;bump low
001185  1  D0 01                BNE     *+3
001187  1  C8                   INY
001188  1  84 C1                STY     TMPADR+1        ;save high
00118A  1  20 93 0F             JSR     GETHSH          ;get hash
00118D  1  0A                   ASL     A               ;mult by two
00118E  1  AA                   TAX                     ;make index
00118F  1  A0 00                LDY     #0              ;clear Y
001191  1  BD 3A 2E             LDA     HSHTBL,X        ;get low
001194  1  91 C0                STAINDIRECTY TMPADR     ;save it
001196  1  C8                   INY                     ;now high
001197  1  BD 3B 2E             LDA     HSHTBL+1,X      ;get it
00119A  1  91 C0                STAINDIRECTY TMPADR     ;save it
00119C  1  20 93 0F             JSR     GETHSH          ;gethash
00119F  1  0A                   ASL     A
0011A0  1  AA                   TAX
0011A1  1  A5 A7                LDA     BASE            ;now get
0011A3  1  9D 3A 2E             STA     HSHTBL,X        ;and put
0011A6  1  A5 A8                LDA     BASE+1          ;new base
0011A8  1  9D 3B 2E             STA     HSHTBL+1,X      ;in table
0011AB  1  E6 BF                INC     LINKI           ;bump loop index
0011AD  1  4C 73 11             JMP     RELNK0          ;and loop
0011B0  1               ;initialize SYNTHE
0011B0  1               ;data definitions for initialization
0011B0  1               CONZER
0011B0  1  01 30                .BYTE   1,"0"
0011B2  1               CONONE
0011B2  1  01 31                .BYTE   1,"1"
0011B4  1               INSYN
0011B4  1  A9 00                LDA     #0              ;first
0011B6  1  85 B2                STA     CODESI          ;clear
0011B8  1  85 B3                STA     CODESI+1        ;variables
0011BA  1  85 45                STA     DATACT
0011BC  1  85 46                STA     DATACT+1
0011BE  1  8D 5E 30             STA     ONSP
0011C1  1  8D 39 2E             STA     IFLABL
0011C4  1  85 B1                STA     FDACT+1         ;set fda
0011C6  1  A9 01                LDA     #1              ;count to
0011C8  1  85 B0                STA     FDACT           ;one
0011CA  1  A9 FF                LDA     #$FF            ;set prt
0011CC  1  85 AE                STA     PRTCT           ;count
0011CE  1  85 AF                STA     PRTCT+1         ;to -1
0011D0  1  20 84 09             JSR     SETFLG          ;set flags
0011D3  1  2C 00 2E             BIT     PASS1           ;see if pass 1
0011D6  1  30 01                BMI     *+3             ;branch if is
0011D8  1  60                   RTS                     ;else done
0011D9  1  20 59 09             JSR     SUPINT          ;setup int file
0011DC  1  A9 B2                LDA     #<CONONE        ;initialize
0011DE  1  A0 11                LDY     #>CONONE        ;printname
0011E0  1  85 B5                STA     PRNTNM          ;pointer
0011E2  1  84 B6                STY     PRNTNM+1
0011E4  1  A9 31                LDA     #'1'            ;then
0011E6  1  85 B7                STA     SYMHSH          ;symbol hash
0011E8  1  20 9F 10             JSR     ENTER           ;put in table
0011EB  1  A9 31                LDA     #'1'            ;emit
0011ED  1  20 29 0F             JSR     EMITCN          ;emit
0011F0  1  A9 24                LDA     #'$'            ;do a $
0011F2  1  20 29 0F             JSR     EMITCN
0011F5  1  A9 00                LDA     #0              ;constant 1
0011F7  1  A8                   TAY                     ;is at fda position 0
0011F8  1  20 09 10             JSR     SETRSV          ;set
0011FB  1  A9 04                LDA     #CONST          ;set type
0011FD  1  20 35 10             JSR     SETTYP          ;as constant
001200  1  A9 B0                LDA     #<CONZER        ;now
001202  1  A0 11                LDY     #>CONZER        ;point
001204  1  85 B5                STA     PRNTNM          ;to
001206  1  84 B6                STY     PRNTNM+1        ;zero
001208  1  A9 30                LDA     #'0'            ;set hash
00120A  1  85 B7                STA     SYMHSH          ;to '0'
00120C  1  20 9F 10             JSR     ENTER           ;enter it
00120F  1  A9 30                LDA     #'0'            ;now
001211  1  20 29 0F             JSR     EMITCN          ;output it
001214  1  A9 24                LDA     #'$'            ;do $
001216  1  20 29 0F             JSR     EMITCN
001219  1  A9 01                LDA     #1              ;set address
00121B  1  A0 00                LDY     #0
00121D  1  20 09 10             JSR     SETRSV
001220  1  A9 04                LDA     #CONST          ;and type = const
001222  1  4C 35 10             JMP     SETTYP          ;then exit
001225  1               ;calculate var(a)+.varc
001225  1               CALVRC
001225  1  AA                   TAX                     ;make index
001226  1  BD DA 2E             LDA     VAR,X           ;get var contents
001229  1  18                   CLC                     ;now add
00122A  1  69 FA                ADC     #<VARC          ;varc start
00122C  1  A0 2F                LDY     #>VARC          ;with carry
00122E  1  90 01                BCC     *+3
001230  1  C8                   INY
001231  1  60                   RTS
001232  1               ;setlookup
001232  1               STLKUP
001232  1  48                   PHA                     ;save param
001233  1  20 25 12             JSR     CALVRC          ;calculate varc
001236  1  85 B5                STA     PRNTNM          ;save as printname
001238  1  84 B6                STY     PRNTNM+1        ;position
00123A  1  68                   PLA                     ;get param
00123B  1  AA                   TAX                     ;make index
00123C  1  BD BA 2E             LDA     HASH,X          ;get entry
00123F  1  85 B7                STA     SYMHSH          ;and set symbols
001241  1  60                   RTS
001242  1               ;lookup$only
001242  1               LKONLY
001242  1  20 32 12             JSR     STLKUP          ;set up
001245  1  4C 64 10             JMP     SLOOKU          ;try to lookup
001248  1               ;normal$lookup
001248  1               NRMLKU
001248  1  20 42 12             JSR     LKONLY          ;call lookup$only
00124B  1  F0 01                BEQ     *+3             ;if false
00124D  1  60                   RTS                     ;else done
00124E  1  20 9F 10             JSR     ENTER           ;enter in table
001251  1  A9 00                LDA     #FALSE          ;then done
001253  1  60                   RTS
001254  1               ;count size of the prt and return with count in AY
001254  1               CNTPRT
001254  1  E6 AE                INC     PRTCT           ;bump
001256  1  D0 02                BNE     *+4
001258  1  E6 AF                INC     PRTCT+1
00125A  1  A5 AE                LDA     PRTCT           ;and get
00125C  1  A4 AF                LDY     PRTCT+1
00125E  1  60                   RTS
00125F  1               ;setifname
00125F  1               SETIFN
00125F  1  A9 37                LDA     #<IFLBLN        ;point to printname
001261  1  A0 2E                LDY     #>IFLBLN
001263  1  85 B5                STA     PRNTNM
001265  1  84 B6                STY     PRNTNM+1
001267  1  AD 39 2E             LDA     IFLABL          ;set symhash
00126A  1  29 3F                AND     #HSHMSK
00126C  1  85 B7                STA     SYMHSH
00126E  1  60                   RTS
00126F  1               ;enter$compiler$label(a)
00126F  1               ENCMLB
00126F  1  2C 00 2E             BIT     PASS1           ;test for pass 1
001272  1  30 01                BMI     *+3             ;branch if is
001274  1  60                   RTS
001275  1  48                   PHA                     ;save parameter
001276  1  20 5F 12             JSR     SETIFN          ;call setifname
001279  1  20 9F 10             JSR     ENTER           ;call enter
00127C  1  68                   PLA                     ;get param
00127D  1  18                   CLC                     ;add to codesize
00127E  1  65 B2                ADC     CODESI
001280  1  A4 B3                LDY     CODESI+1
001282  1  90 01                BCC     *+3
001284  1  C8                   INY                     ;with carry
001285  1  4C 09 10             JMP     SETRSV          ;call setaddr(codesize+a)
001288  1               ;set$compiler$label
001288  1               STCMLB
001288  1  EE 39 2E             INC     IFLABL          ;bump iflable
00128B  1  20 5F 12             JSR     SETIFN          ;call setifname
00128E  1  4C 64 10             JMP     SLOOKU          ;call "s"lookup
001291  1               ;compiler$label
001291  1               COMLBL
001291  1  20 88 12             JSR     STCMLB          ;call set$compiler$label
001294  1  20 54 10             JSR     GETADR
001297  1  4C 32 0F             JMP     GENTWO          ;call gen$two(getaddr)
00129A  1               ;check for mp and sp both floating point
00129A  1               CHKTY1
00129A  1  A5 85                LDA     STYPMP          ;get stypemp
00129C  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
00129E  1  D0 09                BNE     DOC1MF          ;error if not
0012A0  1  A5 83                LDA     STYPSP          ;get stypesp
0012A2  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
0012A4  1  D0 03                BNE     DOC1MF          ;error if not
0012A6  1  A9 FF                LDA     #TRUE
0012A8  1  60                   RTS
0012A9  1               DOC1MF
0012A9  1  20 D4 12             JSR     MFERR           ;error
0012AC  1  A9 00                LDA     #FALSE
0012AE  1  60                   RTS
0012AF  1               ;check mp and sp both same type
0012AF  1               CHKTY2
0012AF  1  A5 83                LDA     STYPSP          ;get stypesp
0012B1  1  C5 85                CMP     STYPMP          ;see if stypemp same
0012B3  1  D0 03                BNE     *+5             ;error if not
0012B5  1  A9 FF                LDA     #TRUE
0012B7  1  60                   RTS
0012B8  1  A9 0D                LDA     #13             ;mixed mode error
0012BA  1  20 AE 0A             JSR     ERROR
0012BD  1  A9 00                LDA     #FALSE
0012BF  1  60                   RTS
0012C0  1               ;chktyp3
0012C0  1               CHKTY3
0012C0  1  A5 83                LDA     STYPSP          ;get stypesp
0012C2  1  20 D1 0C             JSR     STSTMP          ;call setstypemp(stypesp)
0012C5  1  A5 83                LDA     STYPSP          ;get stypesp
0012C7  1  C9 31                CMP     #FLOTPT         ;see if floating
0012C9  1  D0 03                BNE     *+5             ;error if not
0012CB  1  A9 FF                LDA     #TRUE
0012CD  1  60                   RTS
0012CE  1  20 D4 12             JSR     MFERR           ;must be floating error
0012D1  1  A9 00                LDA     #FALSE
0012D3  1  60                   RTS
0012D4  1               ;must be floating point error
0012D4  1               MFERR
0012D4  1  A9 0C                LDA     #12
0012D6  1  4C AE 0A             JMP     ERROR
0012D9  1               ;chktyp4
0012D9  1               CHKTY4
0012D9  1  A5 84                LDA     STYPM1          ;get stypemp1
0012DB  1  C9 32                CMP     #STRING         ;see if string
0012DD  1  D0 03                BNE     *+5             ;ok if not
0012DF  1  20 D4 12             JSR     MFERR           ;else must be floating error
0012E2  1  A9 5B                LDA     #RON
0012E4  1  4C F7 0C             JMP     GENERT          ;call generate(ron)
0012E7  1               ;chktyp5
0012E7  1               CHKTY5
0012E7  1  20 D9 12             JSR     CHKTY4          ;call chktyp4
0012EA  1  E6 82                INC     TYPEMP          ;bump typemp
0012EC  1  A5 82                LDA     TYPEMP
0012EE  1  4C D7 0C             JMP     STTYMP          ;call settypemp(typemp:=typemp+1)
0012F1  1               ;subcalc
0012F1  1               SUBCAL
0012F1  1  A5 80                LDA     TYPESP          ;get type
0012F3  1  20 F9 10             JSR     SETSUB          ;call setsubtype(typesp)
0012F6  1  A9 20                LDA     #ROW
0012F8  1  20 F7 0C             JSR     GENERT          ;call generate(row)
0012FB  1  A5 80                LDA     TYPESP
0012FD  1  20 F7 0C             JSR     GENERT          ;call generate(typesp)
001300  1  A9 14                LDA     #STD
001302  1  4C F7 0C             JMP     GENERT          ;call generate(std)
001305  1               ;gen$store
001305  1               GENSTR
001305  1  A5 84                LDA     STYPM1          ;get stypemp1
001307  1  C9 31                CMP     #FLOTPT         ;see if floating
001309  1  D0 05                BNE     *+7             ;branch if not
00130B  1  A9 14                LDA     #STD
00130D  1  4C F7 0C             JMP     GENERT          ;call generate(std)
001310  1  A9 1B                LDA     #STS
001312  1  4C F7 0C             JMP     GENERT          ;call generate(sts)
001315  1               ;setup$input
001315  1               SEINPU
001315  1  A9 FF                LDA     #TRUE
001317  1  85 47                STA     INPSTM          ;inputstmt=true
001319  1  A9 3B                LDA     #RCN
00131B  1  4C F7 0C             JMP     GENERT          ;call generate(rcn)
00131E  1               ;gen$read(a,y)
00131E  1               GENRDE
00131E  1  A6 83                LDX     STYPSP          ;get stypesp
001320  1  E0 32                CPX     #STRING         ;see if string
001322  1  D0 08                BNE     *+10            ;branch if not
001324  1  20 F7 0C             JSR     GENERT          ;call generate(i)
001327  1  A9 1B                LDA     #STS
001329  1  4C F7 0C             JMP     GENERT          ;call generate(sts)
00132C  1  98                   TYA
00132D  1  20 F7 0C             JSR     GENERT          ;call generate(y)
001330  1  A9 14                LDA     #STD
001332  1  4C F7 0C             JMP     GENERT          ;call generate(std)
001335  1               ;get$field
001335  1               GETFLD
001335  1  A5 80                LDA     TYPESP          ;get typesp
001337  1  C9 00                CMP     #SIMVAR         ;see if simple variable
001339  1  D0 07                BNE     *+9             ;skip if not
00133B  1  A5 86                LDA     SYMLSP
00133D  1  A4 87                LDY     SYMLSP+1
00133F  1  20 3B 0F             JSR     LITERL          ;call literal(symlocsp)
001342  1  24 47                BIT     INPSTM          ;test inputstmt
001344  1  10 07                BPL     *+9             ;branch if not
001346  1  A9 31                LDA     #RES
001348  1  A0 22                LDY     #RDV
00134A  1  4C 1E 13             JMP     GENRDE          ;call gen$read(res,rdv)
00134D  1  2C 0B 2E             BIT     FILEIO          ;see if file io
001350  1  10 07                BPL     *+9             ;branch if not
001352  1  A9 2A                LDA     #RDS
001354  1  A0 29                LDY     #RDN
001356  1  4C 1E 13             JMP     GENRDE          ;call gen$read(rds,rdn)
001359  1  A9 3C                LDA     #DRS
00135B  1  A0 3D                LDY     #DRF
00135D  1  4C 1E 13             JMP     GENRDE          ;call gen$read(drs,drf)
001360  1               ;gen$on
001360  1               GENON
001360  1  A9 5B                LDA     #RON
001362  1  20 F7 0C             JSR     GENERT          ;call generate(ron)
001365  1  EE 5E 30             INC     ONSP
001368  1  AE 5E 30             LDX     ONSP            ;get as index
00136B  1  BD 5E 30             LDA     ONSTAK,X        ;get entry
00136E  1  A0 00                LDY     #0              ;high always clear
001370  1  20 3B 0F             JSR     LITERL          ;call(onstack(onsp:=onsp+1))
001373  1  A9 5C                LDA     #CKO
001375  1  20 F7 0C             JSR     GENERT          ;call generate(cko)
001378  1  A9 39                LDA     #BFN
00137A  1  4C F7 0C             JMP     GENERT          ;call generate(bfn)
00137D  1               ;gen$on$2
00137D  1               GENON2
00137D  1  A5 80                LDA     TYPESP
00137F  1  AE 5E 30             LDX     ONSP
001382  1  9D 5E 30             STA     ONSTAK,X
001385  1  60                   RTS
001386  1               ;gennext
001386  1               GENNXT
001386  1  C6 A9                DEC     FORCNT          ;drop forcount
001388  1  A5 A9                LDA     FORCNT          ;get it
00138A  1  C9 FF                CMP     #255            ;see if wrap
00138C  1  D0 07                BNE     *+9             ;branch if ok
00138E  1  E6 A9                INC     FORCNT          ;set to 0
001390  1  A9 10                LDA     #16             ;next w/o for error
001392  1  4C AE 0A             JMP     ERROR
001395  1  A9 36                LDA     #BRS
001397  1  20 F7 0C             JSR     GENERT          ;call generate(brs)
00139A  1  A0 04                LDY     #2*2            ;word addressing
00139C  1  B1 B9                LDAINDIRECTY NXSTPT     ;get low
00139E  1  48                   PHA                     ;save
00139F  1  C8                   INY
0013A0  1  B1 B9                LDAINDIRECTY NXSTPT     ;get high
0013A2  1  A8                   TAY                     ;move to Y
0013A3  1  68                   PLA                     ;get low
0013A4  1  20 32 0F             JSR     GENTWO          ;call gen$two(nextaddress(2))
0013A7  1  A0 00                LDY     #0*2            ;still word addressing
0013A9  1  A5 B2                LDA     CODESI
0013AB  1  91 B9                STAINDIRECTY NXSTPT     ;put
0013AD  1  C8                   INY
0013AE  1  A5 B3                LDA     CODESI+1        ;do high
0013B0  1  09 80                ORA     #$80            ;set msb
0013B2  1  91 B9                STAINDIRECTY NXSTPT     ;insert
0013B4  1               GENNX0
0013B4  1  A0 01                LDY     #1              ;set index to 1
0013B6  1  B1 B9                LDAINDIRECTY NXSTPT     ;get nextbytev(1)
0013B8  1  30 01                BMI     *+3             ;continue if > 127
0013BA  1  60                   RTS
0013BB  1  18                   CLC                     ;now add 8 to nextstmtptr
0013BC  1  A5 B9                LDA     NXSTPT
0013BE  1  69 08                ADC     #8
0013C0  1  85 B9                STA     NXSTPT
0013C2  1  90 F0                BCC     GENNX0
0013C4  1  E6 BA                INC     NXSTPT+1
0013C6  1  4C B4 13             JMP     GENNX0
0013C9  1               ;gen$next$with$ident
0013C9  1               GENWID
0013C9  1  A5 7D                LDA     MPP1            ;get mpp1
0013CB  1  20 42 12             JSR     LKONLY
0013CE  1  F0 12                BEQ     GENWIE          ;branch if false
0013D0  1  A0 06                LDY     #3*2            ;word addressing
0013D2  1  B1 B9                LDAINDIRECTY NXSTPT     ;get low
0013D4  1  C5 A7                CMP     BASE            ;compare to low base
0013D6  1  D0 0A                BNE     GENWIE          ;error if different
0013D8  1  C8                   INY
0013D9  1  B1 B9                LDAINDIRECTY NXSTPT     ;same for high
0013DB  1  C5 A8                CMP     BASE+1
0013DD  1  D0 03                BNE     GENWIE
0013DF  1  4C 86 13             JMP     GENNXT          ;else ok
0013E2  1               GENWIE
0013E2  1  A9 0E                LDA     #14             ;next does not match for
0013E4  1  4C AE 0A             JMP     ERROR
0013E7  1               ;check$ul$error
0013E7  1               CHKULE
0013E7  1  24 B4                BIT     ULERFL          ;test flag
0013E9  1  10 05                BPL     *+7             ;branch if clear
0013EB  1  A9 14                LDA     #20             ;else undefined label
0013ED  1  20 AE 0A             JSR     ERROR
0013F0  1  A9 00                LDA     #FALSE          ;now clear flag
0013F2  1  85 B4                STA     ULERFL
0013F4  1  60                   RTS
0013F5  1               ;findlabel
0013F5  1               FNDLBL
0013F5  1  A5 7B                LDA     SP              ;get sp
0013F7  1  20 48 12             JSR     NRMLKU          ;normal$lookup(sp)
0013FA  1  D0 01                BNE     *+3             ;if true
0013FC  1  60                   RTS
0013FD  1  2C 01 2E             BIT     PASS2           ;if pass2
001400  1  30 01                BMI     *+3             ;then
001402  1  60                   RTS
001403  1  20 43 10             JSR     GETRES          ;if not getres
001406  1  F0 01                BEQ     *+3             ;then
001408  1  60                   RTS
001409  1  A9 FF                LDA     #TRUE
00140B  1  85 B4                STA     ULERFL          ;ulerrorflag=true
00140D  1  60                   RTS
00140E  1               ;resolve$label
00140E  1               RESLBL
00140E  1  20 F5 13             JSR     FNDLBL          ;findlabel
001411  1  A9 1E                LDA     #PRO            ;preset for true
001413  1  24 48                BIT     GSBSTM          ;test gosubstmt
001415  1  30 02                BMI     *+4             ;if true
001417  1  A9 36                LDA     #BRS            ;else
001419  1  20 F7 0C             JSR     GENERT          ;generate( )
00141C  1  20 54 10             JSR     GETADR
00141F  1  4C 32 0F             JMP     GENTWO          ;gen$two(getaddr)
001422  1               ;process$simple$variable
001422  1               PSIMPV
001422  1  20 48 12             JSR     NRMLKU          ;normal$lookup
001425  1  F0 0F                BEQ     PSIMP0          ;if false then
001427  1  20 29 10             JSR     GETTYP          ;if getype
00142A  1  C9 00                CMP     #SIMVAR         ;= simvar
00142C  1  F0 13                BEQ     PSIMP1          ;then
00142E  1  A9 0B                LDA     #11             ;array name used as simple variable
001430  1  20 AE 0A             JSR     ERROR
001433  1  4C 41 14             JMP     PSIMP1          ;continue
001436  1               PSIMP0
001436  1  20 54 12             JSR     CNTPRT
001439  1  20 09 10             JSR     SETRSV          ;setaddr(countprt)
00143C  1  A9 00                LDA     #SIMVAR
00143E  1  20 35 10             JSR     SETTYP          ;setype(simvar)
001441  1               PSIMP1
001441  1  20 54 10             JSR     GETADR
001444  1  85 86                STA     SYMLSP
001446  1  84 87                STY     SYMLSP+1        ;symlocsp=getaddr
001448  1  20 B1 0C             JSR     STSLSP          ;setsymlocsp( )
00144B  1  A9 00                LDA     #SIMVAR
00144D  1  20 C5 0C             JSR     STTYSP          ;settypesp(simvar)
001450  1  2C 0A 2E             BIT     FORSTM          ;if forstmt
001453  1  30 01                BMI     *+3             ;then
001455  1  60                   RTS
001456  1  A9 00                LDA     #FALSE
001458  1  8D 0A 2E             STA     FORSTM          ;forstmt=false
00145B  1  A0 06                LDY     #3*2            ;word addressing
00145D  1  A5 A7                LDA     BASE
00145F  1  91 A5                STAINDIRECTY SBTTOP
001461  1  C8                   INY
001462  1  A5 A8                LDA     BASE+1
001464  1  91 A5                STAINDIRECTY SBTTOP     ;foraddress(3)=base
001466  1  60                   RTS
001467  1               ;gen$ils
001467  1               GENILS
001467  1  85 C2                STA     WHERE
001469  1  84 C3                STY     WHERE+1         ;save parameter
00146B  1  A9 32                LDA     #STRING
00146D  1  20 CB 0C             JSR     STSTSP          ;setstypesp(string)
001470  1  A9 1C                LDA     #ILS
001472  1  20 F7 0C             JSR     GENERT          ;generate(ils)
001475  1               GENIL0
001475  1  A9 01                LDA     #1
001477  1  85 C4                STA     STRPTR          ;strptr=1
001479  1               GENIL1
001479  1  A0 00                LDY     #0
00147B  1  B1 C2                LDAINDIRECTY WHERE      ;if stringtospool(0)
00147D  1  C5 C4                CMP     STRPTR          ;< strptr
00147F  1  90 0C                BCC     GENIL2          ;then
001481  1  A4 C4                LDY     STRPTR
001483  1  B1 C2                LDAINDIRECTY WHERE      ;stringtospool(strptr)
001485  1  20 F7 0C             JSR     GENERT          ;generate
001488  1  E6 C4                INC     STRPTR          ;strptr=strptr+1
00148A  1  4C 79 14             JMP     GENIL1
00148D  1               GENIL2
00148D  1  24 6E                BIT     CONT            ;if not cont
00148F  1  10 06                BPL     *+8             ;then
001491  1  20 9B 0D             JSR     SCANNR          ;scanner
001494  1  4C 75 14             JMP     GENIL0
001497  1  A9 00                LDA     #0
001499  1  4C F7 0C             JMP     GENERT          ;generate(0)
00149C  1               ;gencon
00149C  1               GENCON
00149C  1  A9 2E                LDA     #CON
00149E  1  20 F7 0C             JSR     GENERT          ;generate(con)
0014A1  1  A9 04                LDA     #CONST
0014A3  1  20 C5 0C             JSR     STTYSP          ;settypesp(const)
0014A6  1  A9 31                LDA     #FLOTPT
0014A8  1  20 CB 0C             JSR     STSTSP          ;setstypesp(floatpt)
0014AB  1  A5 7B                LDA     SP
0014AD  1  20 42 12             JSR     LKONLY          ;lookup$only(sp)
0014B0  1  F0 0D                BEQ     GENCO0          ;if false then
0014B2  1  20 29 10             JSR     GETTYP          ;if getype
0014B5  1  C9 04                CMP     #CONST          ;<> const
0014B7  1  D0 06                BNE     GENCO0          ;then
0014B9  1  20 54 10             JSR     GETADR
0014BC  1  4C 32 0F             JMP     GENTWO          ;gen$two(getaddr)
0014BF  1               GENCO0
0014BF  1  A9 01                LDA     #1
0014C1  1  85 C5                STA     IGEN            ;igen=1
0014C3  1               GENCO1
0014C3  1  A5 4E                LDA     ACCLEN
0014C5  1  C5 C5                CMP     IGEN            ;if igen>acclen
0014C7  1  90 0C                BCC     GENCO2          ;then
0014C9  1  A6 C5                LDX     IGEN
0014CB  1  B5 4E                LDA     ACCUM,X
0014CD  1  20 29 0F             JSR     EMITCN          ;emitcon(accum(i))
0014D0  1  E6 C5                INC     IGEN            ;i=i+1
0014D2  1  4C C3 14             JMP     GENCO1
0014D5  1               GENCO2
0014D5  1  A9 24                LDA     #'$'
0014D7  1  20 29 0F             JSR     EMITCN          ;emitcon('$')
0014DA  1  E6 B0                INC     FDACT
0014DC  1  D0 02                BNE     *+4
0014DE  1  E6 B1                INC     FDACT+1         ;fdact=fdact+1
0014E0  1  A5 B0                LDA     FDACT
0014E2  1  A4 B1                LDY     FDACT+1
0014E4  1  4C 32 0F             JMP     GENTWO          ;gen$two(fdact)
0014E7  1               ;put$field
0014E7  1               PUTFLD
0014E7  1  2C 0B 2E             BIT     FILEIO          ;if not fileio
0014EA  1  10 10                BPL     NTFLIO          ;then
0014EC  1  A5 83                LDA     STYPSP          ;if stypesp
0014EE  1  C9 31                CMP     #FLOTPT         ;<> floatpt
0014F0  1  D0 05                BNE     *+7             ;then
0014F2  1  A9 2B                LDA     #WRN
0014F4  1  4C F7 0C             JMP     GENERT          ;generate(wrn)
0014F7  1  A9 2C                LDA     #WRS
0014F9  1  4C F7 0C             JMP     GENERT          ;generate(wrs)
0014FC  1               NTFLIO
0014FC  1  A5 83                LDA     STYPSP          ;if stypesp
0014FE  1  C9 31                CMP     #FLOTPT         ;= floatpt
001500  1  F0 05                BEQ     *+7             ;then
001502  1  A9 24                LDA     #WST
001504  1  4C F7 0C             JMP     GENERT          ;generate(wst)
001507  1  A5 80                LDA     TYPESP          ;if typesp
001509  1  C9 4A                CMP     #74             ;not a tab
00150B  1  D0 01                BNE     *+3             ;then
00150D  1  60                   RTS
00150E  1  A9 23                LDA     #WRV
001510  1  4C F7 0C             JMP     GENERT          ;generate(wrv)
001513  1               ;gen$parm
001513  1               GENPRM
001513  1  A5 82                LDA     TYPEMP
001515  1  C9 0A                CMP     #UNFUNC         ;if typemp = unfunc
001517  1  F0 01                BEQ     *+3             ;then
001519  1  60                   RTS
00151A  1  A5 8A                LDA     SYMLMP
00151C  1  A4 8B                LDY     SYMLMP+1
00151E  1  85 A7                STA     BASE
001520  1  84 A8                STY     BASE+1          ;base=symlocmp
001522  1  20 0B 0F             JSR     NXTENT          ;nextentry
001525  1  A5 A7                LDA     BASE
001527  1  A4 A8                LDY     BASE+1
001529  1  20 BF 0C             JSR     STSLMP          ;setsymlocmp(base)
00152C  1  C6 8E                DEC     HASHMP
00152E  1  A5 8E                LDA     HASHMP
001530  1  20 DD 0C             JSR     STHAMP          ;sethashmp(hashmp:=hashmp-1)
001533  1  20 54 10             JSR     GETADR
001536  1  4C 3B 0F             JMP     LITERL          ;literal(getaddr)
001539  1               ;checkparm
001539  1               CHKPRM
001539  1  A5 82                LDA     TYPEMP
00153B  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
00153D  1  D0 17                BNE     NTUNFN          ;then
00153F  1  A5 8A                LDA     SYMLMP
001541  1  A4 8B                LDY     SYMLMP+1
001543  1  85 A7                STA     BASE
001545  1  84 A8                STY     BASE+1          ;base=symlocmp
001547  1  20 05 11             JSR     GETSUB          ;getsubtype
00154A  1  C5 84                CMP     STYPM1          ;if = stypemp1
00154C  1  F0 05                BEQ     *+7             ;then
00154E  1  A9 05                LDA     #5              ;else invalid parameter type in function ref
001550  1  20 AE 0A             JSR     ERROR
001553  1  4C 05 13             JMP     GENSTR          ;gen$store
001556  1               NTUNFN
001556  1  A9 01                LDA     #1
001558  1  A4 84                LDY     STYPM1          ;if stypemp1
00155A  1  C0 31                CPY     #FLOTPT         ;<> floatpt
00155C  1  D0 02                BNE     *+4             ;then
00155E  1  A9 00                LDA     #FALSE
001560  1  45 8E                EOR     HASHMP          ;xor hashmp
001562  1  29 01                AND     #1              ;test lsb only
001564  1  F0 05                BEQ     *+7             ;if true
001566  1  A9 05                LDA     #5              ;invalid type in function parameter list
001568  1  20 AE 0A             JSR     ERROR
00156B  1  A5 8E                LDA     HASHMP
00156D  1  4A                   LSR     A               ;shr(hashmp,1)
00156E  1  20 DD 0C             JSR     STHAMP          ;sethashmp
001571  1  C6 85                DEC     STYPMP
001573  1  A5 85                LDA     STYPMP
001575  1  4C D1 0C             JMP     STSTMP          ;setstypemp(stypemp=stypemp-1)
001578  1               ;funcgen
001578  1               FNCGEN
001578  1  A5 82                LDA     TYPEMP
00157A  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
00157C  1  D0 1C                BNE     NOFNGN          ;then
00157E  1  A5 8E                LDA     HASHMP          ;if hashmp=0
001580  1  F0 05                BEQ     *+7             ;then
001582  1  A9 04                LDA     #4              ;incorrect number parameters
001584  1  20 AE 0A             JSR     ERROR
001587  1  A9 1E                LDA     #PRO
001589  1  20 F7 0C             JSR     GENERT          ;generate(pro)
00158C  1  A5 8F                LDA     SRLOSP
00158E  1  A4 90                LDY     SRLOSP+1
001590  1  85 A7                STA     BASE
001592  1  84 A8                STY     BASE+1          ;base=srlocsp
001594  1  20 54 10             JSR     GETADR
001597  1  4C 32 0F             JMP     GENTWO          ;gen$two(getaddr)
00159A  1               NOFNGN
00159A  1  A5 85                LDA     STYPMP
00159C  1  29 03                AND     #3              ;if stypemp and 3 = 0
00159E  1  F0 05                BEQ     *+7             ;then
0015A0  1  A9 04                LDA     #4              ;incorrect number parameters
0015A2  1  20 AE 0A             JSR     ERROR
0015A5  1  A5 82                LDA     TYPEMP
0015A7  1  20 F7 0C             JSR     GENERT          ;generate(typemp)
0015AA  1  A5 85                LDA     STYPMP
0015AC  1  29 40                AND     #%01000000      ;if not rol(stypemp,2)
0015AE  1  F0 05                BEQ     *+7             ;then
0015B0  1  A9 32                LDA     #STRING
0015B2  1  4C D1 0C             JMP     STSTMP          ;setstypemp(string)
0015B5  1  A9 31                LDA     #FLOTPT
0015B7  1  4C D1 0C             JMP     STSTMP          ;setstypemp(floatpt)
0015BA  1               ;enter$parm
0015BA  1               ENTRPR
0015BA  1  2C 00 2E             BIT     PASS1           ;if pass 1
0015BD  1  30 01                BMI     *+3             ;then
0015BF  1  60                   RTS
0015C0  1  A5 7D                LDA     MPP1
0015C2  1  20 32 12             JSR     STLKUP          ;setlookup(mpp1)
0015C5  1  20 9F 10             JSR     ENTER
0015C8  1  20 54 12             JSR     CNTPRT
0015CB  1  20 09 10             JSR     SETRSV          ;setaddr(countprt)
0015CE  1  A5 84                LDA     STYPM1
0015D0  1  20 F9 10             JSR     SETSUB          ;setsubtype(stypemp1)
0015D3  1  A9 00                LDA     #SIMVAR
0015D5  1  20 35 10             JSR     SETTYP          ;setype(simvar)
0015D8  1  A6 82                LDX     TYPEMP
0015DA  1  E8                   INX
0015DB  1  8A                   TXA
0015DC  1  4C D7 0C             JMP     STTYMP          ;settypemp(typemp+1)
0015DF  1               ;synthesis
0015DF  1               ;main code generation routine
0015DF  1               SYNTHE
0015DF  1  85 B8                STA     PRODCT          ;save production
0015E1  1  AD 01 2E             LDA     PASS2           ;if not pass 2
0015E4  1  2D 02 2E             AND     LSTPRD          ;and listprod
0015E7  1  F0 11                BEQ     NPPROD          ;then
0015E9  1  A9 8F                LDA     #<PRDMSG
0015EB  1  A0 2D                LDY     #>PRDMSG
0015ED  1  20 FC 08             JSR     PRNMSG          ;print message
0015F0  1  A5 B8                LDA     PRODCT
0015F2  1  A0 00                LDY     #0
0015F4  1  20 70 08             JSR     PRNDEC          ;print number
0015F7  1  20 34 08             JSR     CRLF
0015FA  1               NPPROD
0015FA  1  20 42 0C             JSR     SCOPY           ;set up simple variables
0015FD  1  A5 B8                LDA     PRODCT          ;get number
0015FF  1  0A                   ASL     A               ;make word index
001600  1  AA                   TAX                     ;make index
001601  1  B0 0F                BCS     GT127           ;branch if > 127
001603  1  BD 21 16             LDA     PRODL,X
001606  1  8D 10 16             STA     JPROD+1
001609  1  BD 22 16             LDA     PRODL+1,X
00160C  1  8D 11 16             STA     JPROD+2         ;set address
00160F  1               JPROD
00160F  1  4C FF FF             JMP     $FFFF           ;do it
001612  1               GT127
001612  1  BD 21 17             LDA     PRODH,X
001615  1  8D 10 16             STA     JPROD+1
001618  1  BD 22 17             LDA     PRODH+1,X
00161B  1  8D 11 16             STA     JPROD+2
00161E  1  4C 0F 16             JMP     JPROD           ;same for high
001621  1               ;production jump table for 0 - 127
001621  1               PRODL
001621  1  53 17 53 17          .WORD   PRN,PRN,PR2,PR3,CHKULE,CHKULE,PRN,PRN
001625  1  54 17 89 17  
001629  1  E7 13 E7 13  
001631  1  53 17 53 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001635  1  53 17 53 17  
001639  1  53 17 53 17  
001641  1  53 17 53 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001645  1  53 17 53 17  
001649  1  53 17 53 17  
001651  1  53 17 53 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PR30,PR31
001655  1  53 17 53 17  
001659  1  53 17 53 17  
001661  1  53 17 A7 17          .WORD   PRN,PR33,PR34,PR35,PRN,PR37,PRN,PR39
001665  1  B2 17 B7 17  
001669  1  53 17 BC 17  
001671  1  53 17 D2 17          .WORD   PRN,PR41,PRN,PR43,PR44,CHKTY3,PR46,PRN
001675  1  53 17 F0 17  
001679  1  03 18 C0 12  
001681  1  19 18 24 18          .WORD   PR48,PR49,PRN,PR51,PR52,PRN,PRN,PR55
001685  1  53 17 2F 18  
001689  1  3A 18 53 17  
001691  1  51 18 56 18          .WORD   PR56,PR57,PR58,CHKTY5,PR60,FNCGEN,GENPRM,PR63
001695  1  87 18 E7 12  
001699  1  A6 18 78 15  
0016A1  1  BA 18 DF 18          .WORD   PR64,PR65,GENCON,PR67,PR68,PR69,PR69,PR71
0016A5  1  9C 14 ED 18  
0016A9  1  F4 18 F9 18  
0016B1  1  FE 18 03 19          .WORD   PR71,PR73,PR74,PR75,PR75,PR77,PR78,PR79
0016B5  1  08 19 0D 19  
0016B9  1  0D 19 12 19  
0016C1  1  E1 19 E6 19          .WORD   PR80,PR81,PR82,PR82,PR84,PRN,RESLBL,PR87
0016C5  1  07 1A 07 1A  
0016C9  1  0C 1A 53 17  
0016D1  1  2C 1A 3F 1A          .WORD   PR88,PR89,PR90,ENTRPR,PR92,PR92,ENTRPR,PRN
0016D5  1  64 1A BA 15  
0016D9  1  96 1A 96 1A  
0016E1  1  53 17 53 17          .WORD   PRN,PRN,PR98,CHKTY4,PR100,PRN,SUBCAL,SUBCAL
0016E5  1  9B 1A D9 12  
0016E9  1  B7 1A 53 17  
0016F1  1  BD 1A C9 1A          .WORD   PR104,PR105,CHKTY5,PRN,PR108,PR108,PR110,PRN
0016F5  1  E7 12 53 17  
0016F9  1  FC 1A FC 1A  
001701  1  1F 1B 29 1B          .WORD   PR112,PR113,SEINPU,GETFLD,GETFLD,PR117,PRN,PR119
001705  1  15 13 35 13  
001709  1  35 13 19 1B  
001711  1  E7 14 E7 14          .WORD   PUTFLD,PUTFLD,PRN,PUTFLD,PUTFLD,PRN,PR126,PR127
001715  1  53 17 E7 14  
001719  1  E7 14 53 17  
001721  1               ;production jump table for 128 - 255
001721  1               PRODH
001721  1  4E 1B 53 17          .WORD   PR128,PRN,PR130,RESLBL,GENON2,PR133,GENON,PR135
001725  1  67 1B 0E 14  
001729  1  7D 13 72 1B  
001731  1  90 1B 98 1B          .WORD   PR136,PR137,PR138,PRN,PRN,PRN,PRN,GENWID
001735  1  A2 1B 53 17  
001739  1  53 17 53 17  
001741  1  86 13 53 17          .WORD   GENNXT,PRN,GENWID,PR147,PR148,PR149,PR150,PR151
001745  1  C9 13 AE 1B  
001749  1  CF 1B D4 1B  
001751  1  46 1C                .WORD   PR152
001753  1               ;productions not already defined by single no-parameter subroutines
001753  1               PRN
001753  1  60                   RTS                     ;do nothing - used a lot !!!!
001754  1               ;2	<line number>::=<number>
001754  1               PR2
001754  1  A5 7B                LDA     SP
001756  1  20 42 12             JSR     LKONLY          ;lookup$only(sp)
001759  1  F0 27                BEQ     PR2D            ;if false
00175B  1  20 43 10             JSR     GETRES          ;see if resolved
00175E  1  F0 13                BEQ     PR2C            ;if not
001760  1  20 54 10             JSR     GETADR          ;getaddr
001763  1  C5 B2                CMP     CODESI          ;try low
001765  1  D0 04                BNE     PR2A            ;error if <>
001767  1  C4 B3                CPY     CODESI+1
001769  1  F0 05                BEQ     *+7             ;ok if same
00176B  1               PR2A
00176B  1  A9 00                LDA     #0              ;duplicate labels
00176D  1  20 AE 0A             JSR     ERROR
001770  1  4C 4D 0F             JMP     LINENU
001773  1               PR2C
001773  1  A5 B2                LDA     CODESI
001775  1  A4 B3                LDY     CODESI+1
001777  1  20 09 10             JSR     SETRSV          ;setaddr(codesize)
00177A  1  A9 08                LDA     #LABLE
00177C  1  20 35 10             JSR     SETTYP          ;setype(lable)
00177F  1  4C 4D 0F             JMP     LINENU
001782  1               PR2D
001782  1  A9 2A                LDA     #'*'
001784  1  85 74                STA     SEPRTR          ;separator=astrik
001786  1  4C 4D 0F             JMP     LINENU
001789  1               ;3	|
001789  1               PR3
001789  1  A9 3A                LDA     #':'            ;set separator
00178B  1  85 74                STA     SEPRTR
00178D  1  4C 4D 0F             JMP     LINENU          ;then do line number
001790  1               ;30	<assignmemt>::=<assign head><expression>
001790  1               PR30
001790  1  20 AF 12             JSR     CHKTY2          ;if not chktyp2
001793  1  F0 03                BEQ     *+5             ;then
001795  1  4C 05 13             JMP     GENSTR          ;else gen$store
001798  1  60                   RTS
001799  1               ;31	<assign head>::=<variable>=
001799  1               PR31
001799  1  A5 82                LDA     TYPEMP
00179B  1  C9 00                CMP     #SIMVAR         ;if typemp=simvar
00179D  1  F0 01                BEQ     *+3             ;then
00179F  1  60                   RTS
0017A0  1  A5 8A                LDA     SYMLMP
0017A2  1  A4 8B                LDY     SYMLMP+1
0017A4  1  4C 3B 0F             JMP     LITERL          ;literal(symlocmp)
0017A7  1               ;33	|<expression><or><logical factor>
0017A7  1               PR33
0017A7  1  20 9A 12             JSR     CHKTY1          ;if chktyp1
0017AA  1  D0 01                BNE     *+3             ;then
0017AC  1  60                   RTS
0017AD  1  A5 81                LDA     TYPEM1
0017AF  1  4C F7 0C             JMP     GENERT          ;generate(typemp1)
0017B2  1               ;34	<or>::=or
0017B2  1               PR34
0017B2  1  A9 0D                LDA     #BOR
0017B4  1  4C C5 0C             JMP     STTYSP          ;settypesp(bor)
0017B7  1               ;35	|xor
0017B7  1               PR35
0017B7  1  A9 5D                LDA     #EXR
0017B9  1  4C C5 0C             JMP     STTYSP          ;sttysp
0017BC  1               ;37	<logical secondary>
0017BC  1               PR37
0017BC  1  20 9A 12             JSR     CHKTY1          ;if chktyp1
0017BF  1  D0 01                BNE     *+3             ;then
0017C1  1  60                   RTS
0017C2  1  A9 0C                LDA     #ANDO
0017C4  1  4C F7 0C             JMP     GENERT          ;generate(ando)
0017C7  1               ;39	|not <logical primary>
0017C7  1               PR39
0017C7  1  20 C0 12             JSR     CHKTY3          ;if chktyp3
0017CA  1  D0 01                BNE     *+3             ;then
0017CC  1  60                   RTS
0017CD  1  A9 0B                LDA     #NOT
0017CF  1  4C F7 0C             JMP     GENERT          ;generate(not)
0017D2  1               ;41	<arithmetic expression>
0017D2  1               PR41
0017D2  1  20 AF 12             JSR     CHKTY2          ;if chktyp2
0017D5  1  D0 01                BNE     *+3             ;then
0017D7  1  60                   RTS
0017D8  1  A5 83                LDA     STYPSP
0017DA  1  C9 31                CMP     #FLOTPT         ;if stypesp<>floatpt
0017DC  1  D0 05                BNE     PR41A           ;then
0017DE  1  A5 81                LDA     TYPEM1
0017E0  1  4C F7 0C             JMP     GENERT          ;generate(typemp1)
0017E3  1               PR41A
0017E3  1  18                   CLC
0017E4  1  A5 81                LDA     TYPEM1
0017E6  1  69 10                ADC     #16
0017E8  1  20 F7 0C             JSR     GENERT          ;generate(typemp1+16)
0017EB  1  A9 31                LDA     #FLOTPT
0017ED  1  4C D1 0C             JMP     STSTMP          ;setstypemp(floatpt)
0017F0  1               ;43	|<arithmetic expression>+<term>
0017F0  1               PR43
0017F0  1  20 AF 12             JSR     CHKTY2          ;if chktyp2
0017F3  1  D0 01                BNE     *+3             ;then
0017F5  1  60                   RTS
0017F6  1  A9 00                LDA     #FAD
0017F8  1  A4 83                LDY     STYPSP
0017FA  1  C0 31                CPY     #FLOTPT         ;if stypesp=floatpt
0017FC  1  F0 02                BEQ     *+4             ;then generate(fad)
0017FE  1  A9 1D                LDA     #CAT
001800  1  4C F7 0C             JMP     GENERT          ;else generate(cat)
001803  1               ;44	|<arithmetic expression>-<term>
001803  1               PR44
001803  1  20 9A 12             JSR     CHKTY1          ;if chktyp1
001806  1  D0 01                BNE     *+3             ;then
001808  1  60                   RTS
001809  1  A9 01                LDA     #FMI
00180B  1  4C F7 0C             JMP     GENERT          ;generate(fmi)
00180E  1               ;46	|-<term>
00180E  1               PR46
00180E  1  20 C0 12             JSR     CHKTY3          ;if chktyp3
001811  1  D0 01                BNE     *+3             ;then
001813  1  60                   RTS
001814  1  A9 30                LDA     #NEG
001816  1  4C F7 0C             JMP     GENERT          ;generate(neg)
001819  1               ;48	|<term>*<primary>
001819  1               PR48
001819  1  20 9A 12             JSR     CHKTY1          ;if chktyp1
00181C  1  D0 01                BNE     *+3             ;then
00181E  1  60                   RTS
00181F  1  A9 02                LDA     #FMU
001821  1  4C F7 0C             JMP     GENERT          ;generate(fmu)
001824  1               ;49	|<term>/<primary>
001824  1               PR49
001824  1  20 9A 12             JSR     CHKTY1          ;if chktyp1
001827  1  D0 01                BNE     *+3             ;then
001829  1  60                   RTS
00182A  1  A9 03                LDA     #FDI
00182C  1  4C F7 0C             JMP     GENERT          ;generate(fdi)
00182F  1               ;51	|<primary>**<element>
00182F  1               PR51
00182F  1  20 9A 12             JSR     CHKTY1          ;the chktyp1
001832  1  D0 01                BNE     *+3             ;then
001834  1  60                   RTS
001835  1  A9 04                LDA     #EXP
001837  1  4C F7 0C             JMP     GENERT          ;generate(exp)
00183A  1               ;52	<element>::=<variable>
00183A  1               PR52
00183A  1  A5 80                LDA     TYPESP          ;if typesp
00183C  1  C9 00                CMP     #SIMVAR         ;= simvar
00183E  1  F0 05                BEQ     *+7             ;then
001840  1  A9 0E                LDA     #LOD
001842  1  4C F7 0C             JMP     GENERT          ;else generate(lod)
001845  1  A5 86                LDA     SYMLSP
001847  1  A4 87                LDY     SYMLSP+1
001849  1  4C 44 0F             JMP     LITLOD          ;litload(symlocsp)
00184C  1               ;55	|(<expression>)
00184C  1               PR55
00184C  1  A5 84                LDA     STYPM1
00184E  1  4C D1 0C             JMP     STSTMP          ;setstypemp(stypemp1)
001851  1               ;56	<variable>::=<identifier>
001851  1               PR56
001851  1  A5 7B                LDA     SP
001853  1  4C 22 14             JMP     PSIMPV          ;process$simple$variable(sp)
001856  1               ;57	|<subscript head><expression>
001856  1               PR57
001856  1  2C 0A 2E             BIT     FORSTM          ;if not forstmt
001859  1  10 05                BPL     *+7             ;then
00185B  1  A9 03                LDA     #3              ;for index not simple variable
00185D  1  20 AE 0A             JSR     ERROR
001860  1  20 E7 12             JSR     CHKTY5          ;chktyp5
001863  1  A5 8A                LDA     SYMLMP
001865  1  A4 8B                LDY     SYMLMP+1
001867  1  85 A7                STA     BASE
001869  1  84 A8                STY     BASE+1          ;base=symlocsp
00186B  1  20 05 11             JSR     GETSUB          ;if getsubtype
00186E  1  C5 82                CMP     TYPEMP          ;= typemp
001870  1  F0 05                BEQ     *+7             ;then
001872  1  A9 11                LDA     #17             ;incorrect number subscripts
001874  1  20 AE 0A             JSR     ERROR
001877  1  20 54 10             JSR     GETADR
00187A  1  20 44 0F             JSR     LITLOD          ;litload(getaddr)
00187D  1  A9 21                LDA     #SUB
00187F  1  20 F7 0C             JSR     GENERT          ;generate(subo)
001882  1  A9 02                LDA     #SUBVAR
001884  1  4C D7 0C             JMP     STTYMP          ;settypemp(subvar)
001887  1               ;58	<subscript head>::=<identifier>(
001887  1               PR58
001887  1  A5 7C                LDA     MP
001889  1  20 42 12             JSR     LKONLY          ;lookup$only(mp)
00188C  1  F0 07                BEQ     PR58A           ;if not then error
00188E  1  20 29 10             JSR     GETTYP          ;if getype
001891  1  C9 02                CMP     #SUBVAR         ;= subvar
001893  1  F0 05                BEQ     *+7             ;then ok
001895  1               PR58A
001895  1  A9 0A                LDA     #10             ;subscripted variable not dimensioned
001897  1  20 AE 0A             JSR     ERROR
00189A  1  A9 00                LDA     #0
00189C  1  20 D7 0C             JSR     STTYMP          ;settypemp(0)
00189F  1  A5 A7                LDA     BASE
0018A1  1  A4 A8                LDY     BASE+1
0018A3  1  4C BF 0C             JMP     STSLMP          ;setsymlocmp(base)
0018A6  1               ;60	<function call>::=<function heading><expression>
0018A6  1               PR60
0018A6  1  20 39 15             JSR     CHKPRM          ;checkparm
0018A9  1  A5 91                LDA     SRLOMP
0018AB  1  A4 92                LDY     SRLOMP+1
0018AD  1  85 8F                STA     SRLOSP
0018AF  1  84 90                STY     SRLOSP+1        ;srlocsp=srlocmp
0018B1  1  4C 78 15             JMP     FNCGEN          ;funcgen
0018B4  1               ;63	|<function heading><expression>
0018B4  1               PR63
0018B4  1  20 39 15             JSR     CHKPRM          ;check$parm
0018B7  1  4C 13 15             JMP     GENPRM          ;gen$parm
0018BA  1               ;64	<function name>::=<user defined name>
0018BA  1               PR64
0018BA  1  A5 7B                LDA     SP
0018BC  1  20 42 12             JSR     LKONLY          ;if lookup$only(sp)
0018BF  1  D0 05                BNE     *+7             ;then
0018C1  1  A9 06                LDA     #6              ;function undefined
0018C3  1  4C AE 0A             JMP     ERROR
0018C6  1  A5 A7                LDA     BASE
0018C8  1  A4 A8                LDY     BASE+1
0018CA  1  20 E9 0C             JSR     STSRSP          ;setsrlocsp(base)
0018CD  1  A5 A7                LDA     BASE
0018CF  1  A4 A8                LDY     BASE+1
0018D1  1  20 B1 0C             JSR     STSLSP          ;setsymlocsp(base)
0018D4  1  A9 0A                LDA     #UNFUNC
0018D6  1  20 C5 0C             JSR     STTYSP          ;settypesp(unfunc)
0018D9  1  20 29 10             JSR     GETTYP
0018DC  1  4C E3 0C             JMP     STHASP          ;sethashsp(getype)
0018DF  1               ;65	|<predefined name>
0018DF  1               PR65
0018DF  1  A5 4B                LDA     FUNCOP
0018E1  1  20 C5 0C             JSR     STTYSP          ;settypesp(funcop)
0018E4  1  A5 83                LDA     STYPSP
0018E6  1  4A                   LSR     A
0018E7  1  4A                   LSR     A               ;shr(stypesp,2)
0018E8  1  29 07                AND     #7
0018EA  1  4C E3 0C             JMP     STHASP          ;sethashsp( )
0018ED  1               ;67	|<string>
0018ED  1               PR67
0018ED  1  A9 4E                LDA     #<ACCUM
0018EF  1  A0 00                LDY     #>ACCUM
0018F1  1  4C 67 14             JMP     GENILS          ;gen$ils(.accum)
0018F4  1               ;68	<relation>::= =
0018F4  1               PR68
0018F4  1  A9 07                LDA     #7
0018F6  1  4C C5 0C             JMP     STTYSP          ;settypesp(7)
0018F9  1               ;69	| >= | GE
0018F9  1               PR69
0018F9  1  A9 09                LDA     #9
0018FB  1  4C D7 0C             JMP     STTYMP          ;settypemp(9)
0018FE  1               ;71	| <= | LE
0018FE  1               PR71
0018FE  1  A9 0A                LDA     #10
001900  1  4C D7 0C             JMP     STTYMP          ;settypemp(10)
001903  1               ;73	| >
001903  1               PR73
001903  1  A9 06                LDA     #6
001905  1  4C C5 0C             JMP     STTYSP          ;settypesp(6)
001908  1               ;74	| <
001908  1               PR74
001908  1  A9 05                LDA     #5
00190A  1  4C C5 0C             JMP     STTYSP          ;settypesp(5)
00190D  1               ;75	| <> | NE
00190D  1               PR75
00190D  1  A9 08                LDA     #8
00190F  1  4C D7 0C             JMP     STTYMP          ;settypemp(8)
001912  1               ;77	<for statement>::=<for head> to <expression> <step clause>
001912  1               PR77
001912  1  A0 06                LDY     #3*2            ;word addressing
001914  1  B1 A5                LDAINDIRECTY SBTTOP
001916  1  85 A7                STA     BASE
001918  1  C8                   INY
001919  1  B1 A5                LDAINDIRECTY SBTTOP
00191B  1  85 A8                STA     BASE+1          ;base=foraddress(3)
00191D  1  A5 80                LDA     TYPESP          ;if not typesp
00191F  1  4A                   LSR     A
001920  1  90 05                BCC     *+7             ;then
001922  1  A9 12                LDA     #DUP
001924  1  20 F7 0C             JSR     GENERT          ;generate(dup)
001927  1  20 54 10             JSR     GETADR
00192A  1  20 44 0F             JSR     LITLOD          ;litload(getaddr)
00192D  1  A9 00                LDA     #FAD
00192F  1  20 F7 0C             JSR     GENERT          ;generate(fad)
001932  1  A5 80                LDA     TYPESP          ;if not
001934  1  4A                   LSR     A               ;typesp
001935  1  90 0B                BCC     PR77A           ;then
001937  1  20 54 10             JSR     GETADR
00193A  1  20 3B 0F             JSR     LITERL          ;literal(getaddr)
00193D  1  A9 13                LDA     #XCH
00193F  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001942  1               PR77A
001942  1  A9 0F                LDA     #STO
001944  1  20 F7 0C             JSR     GENERT          ;generate(sto)
001947  1  A5 80                LDA     TYPESP          ;if not
001949  1  4A                   LSR     A               ;typesp
00194A  1  90 2D                BCC     PR77B           ;then
00194C  1  A9 13                LDA     #XCH
00194E  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001951  1  A9 00                LDA     #0
001953  1  A8                   TAY
001954  1  20 3B 0F             JSR     LITERL          ;literal(0)
001957  1  A9 05                LDA     #LSS
001959  1  20 F7 0C             JSR     GENERT          ;generate(lss)
00195C  1  A9 05                LDA     #5
00195E  1  A0 00                LDY     #0
001960  1  20 3B 0F             JSR     LITERL          ;literal(5)
001963  1  A9 38                LDA     #BFC
001965  1  20 F7 0C             JSR     GENERT          ;generate(bfc)
001968  1  A9 0A                LDA     #LEQ
00196A  1  20 F7 0C             JSR     GENERT          ;generate(leq)
00196D  1  A9 02                LDA     #2
00196F  1  A0 00                LDY     #0
001971  1  20 3B 0F             JSR     LITERL          ;literal(2)
001974  1  A9 39                LDA     #BFN
001976  1  20 F7 0C             JSR     GENERT          ;generate(bfn)
001979  1               PR77B
001979  1  A9 09                LDA     #GEQ
00197B  1  20 F7 0C             JSR     GENERT          ;generate(beq)
00197E  1  A9 37                LDA     #BRC
001980  1  20 F7 0C             JSR     GENERT          ;generate(brc)
001983  1  A0 00                LDY     #0*2            ;word address
001985  1  B1 A5                LDAINDIRECTY SBTTOP
001987  1  48                   PHA
001988  1  C8                   INY
001989  1  B1 A5                LDAINDIRECTY SBTTOP
00198B  1  A8                   TAY
00198C  1  68                   PLA
00198D  1  20 32 0F             JSR     GENTWO          ;gen$two(foraddress(0))
001990  1  A0 02                LDY     #1*2            ;word addressing
001992  1  A5 B2                LDA     CODESI
001994  1  91 A5                STAINDIRECTY SBTTOP
001996  1  C8                   INY
001997  1  A5 B3                LDA     CODESI+1
001999  1  91 A5                STAINDIRECTY SBTTOP     ;foraddress(1)=codesize
00199B  1  60                   RTS
00199C  1               ;78	<for head>::=<for><assignment>
00199C  1               PR78
00199C  1  A9 36                LDA     #BRS
00199E  1  20 F7 0C             JSR     GENERT          ;generate(brs)
0019A1  1  A0 02                LDY     #1*2            ;word addressing
0019A3  1  B1 A5                LDAINDIRECTY SBTTOP
0019A5  1  48                   PHA
0019A6  1  C8                   INY
0019A7  1  B1 A5                LDAINDIRECTY SBTTOP
0019A9  1  A8                   TAY
0019AA  1  68                   PLA
0019AB  1  20 32 0F             JSR     GENTWO          ;gen$two(foraddress(1))
0019AE  1  A0 04                LDY     #2*2            ;word addressing
0019B0  1  A5 B2                LDA     CODESI
0019B2  1  91 A5                STAINDIRECTY SBTTOP
0019B4  1  C8                   INY
0019B5  1  A5 B3                LDA     CODESI+1
0019B7  1  91 A5                STAINDIRECTY SBTTOP     ;foraddress(2)=codesize
0019B9  1  60                   RTS
0019BA  1               ;79	<for>::= for
0019BA  1               PR79
0019BA  1  A9 FF                LDA     #TRUE
0019BC  1  8D 0A 2E             STA     FORSTM          ;forstmt=true
0019BF  1  38                   SEC
0019C0  1  A5 A5                LDA     SBTTOP
0019C2  1  E9 08                SBC     #8
0019C4  1  85 A5                STA     SBTTOP
0019C6  1  85 B9                STA     NXSTPT
0019C8  1  A4 A6                LDY     SBTTOP+1
0019CA  1  B0 01                BCS     *+3
0019CC  1  88                   DEY
0019CD  1  84 A6                STY     SBTTOP+1
0019CF  1  84 BA                STY     NXSTPT+1        ;sbtbltop,nextstmtptr=sbtbltop-8
0019D1  1  A0 01                LDY     #1
0019D3  1  B1 B9                LDAINDIRECTY NXSTPT
0019D5  1  29 7F                AND     #$7F
0019D7  1  91 B9                STAINDIRECTY NXSTPT     ;nextbytev(1)=nextbytev(1) and $7f
0019D9  1  A9 00                LDA     #0
0019DB  1  20 EC 0F             JSR     LIMITS          ;limits(0)
0019DE  1  E6 A9                INC     FORCNT          ;forcount=forcount+1
0019E0  1  60                   RTS
0019E1  1               ;80	<step clause>::= step <expression>
0019E1  1               PR80
0019E1  1  A9 01                LDA     #1
0019E3  1  4C D7 0C             JMP     STTYMP          ;settypemp(true)
0019E6  1               ;81	|
0019E6  1               PR81
0019E6  1  A0 06                LDY     #3*2            ;word addressing
0019E8  1  B1 A5                LDAINDIRECTY SBTTOP
0019EA  1  85 A7                STA     BASE
0019EC  1  C8                   INY
0019ED  1  B1 A5                LDAINDIRECTY SBTTOP
0019EF  1  85 A8                STA     BASE+1          ;base=foraddress(3)
0019F1  1  20 54 10             JSR     GETADR
0019F4  1  20 3B 0F             JSR     LITERL          ;literal(getaddr)
0019F7  1  A9 00                LDA     #FALSE
0019F9  1  20 C5 0C             JSR     STTYSP          ;settypesp(false)
0019FC  1  A9 2E                LDA     #CON
0019FE  1  20 F7 0C             JSR     GENERT          ;generate(con)
001A01  1  A9 00                LDA     #0
001A03  1  A8                   TAY
001A04  1  4C 32 0F             JMP     GENTWO          ;gen$two(0)
001A07  1               ;82	<if statement>::=<if group>
001A07  1               PR82
001A07  1  A9 00                LDA     #0
001A09  1  4C 6F 12             JMP     ENCMLB          ;enter$compiler$label(0)
001A0C  1               ;84	| if end # <expression> then <number>
001A0C  1               PR84
001A0C  1  A9 5B                LDA     #RON
001A0E  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001A11  1  A9 5E                LDA     #DEF
001A13  1  20 F7 0C             JSR     GENERT          ;generate(def)
001A16  1  20 F5 13             JSR     FNDLBL          ;findlabel
001A19  1  20 54 10             JSR     GETADR
001A1C  1  4C 32 0F             JMP     GENTWO          ;gen$two(getaddr)
001A1F  1               ;87	<if else group>::=<if head><statement list> else
001A1F  1               PR87
001A1F  1  A9 03                LDA     #3
001A21  1  20 6F 12             JSR     ENCMLB          ;emter$compiler$label(3)
001A24  1  A9 36                LDA     #BRS
001A26  1  20 F7 0C             JSR     GENERT          ;generate(brs)
001A29  1  4C 91 12             JMP     COMLBL          ;compiler$label
001A2C  1               ;88	<if head>::=if <expression> then
001A2C  1               PR88
001A2C  1  A5 84                LDA     STYPM1          ;if stypemp1
001A2E  1  C9 32                CMP     #STRING         ;<> string
001A30  1  D0 05                BNE     *+7             ;then
001A32  1  A9 08                LDA     #8              ;else if expression is not floating point
001A34  1  20 AE 0A             JSR     ERROR
001A37  1  A9 37                LDA     #BRC
001A39  1  20 F7 0C             JSR     GENERT          ;generate(brc)
001A3C  1  4C 91 12             JMP     COMLBL          ;compiler$label
001A3F  1               ;89	<dummy argument list>::=<expresssion>
001A3F  1               PR89
001A3F  1  20 AF 12             JSR     CHKTY2          ;if chkty2
001A42  1  D0 01                BNE     *+3             ;the
001A44  1  60                   RTS
001A45  1  A5 8A                LDA     SYMLMP
001A47  1  A4 8B                LDY     SYMLMP+1
001A49  1  85 A7                STA     BASE
001A4B  1  84 A8                STY     BASE+1
001A4D  1  A5 81                LDA     TYPEM1
001A4F  1  20 35 10             JSR     SETTYP          ;setype(typemp1)
001A52  1  20 0F 11             JSR     UNLINK
001A55  1  A9 13                LDA     #XCH
001A57  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001A5A  1  A9 1F                LDA     #RTN
001A5C  1  20 F7 0C             JSR     GENERT          ;generate(rtn)
001A5F  1  A9 00                LDA     #0
001A61  1  4C 6F 12             JMP     ENCMLB          ;enter$compiler$label(0)
001A64  1               ;90	(ud function name>::= def <user defined name>
001A64  1               PR90
001A64  1  A9 36                LDA     #BRS
001A66  1  20 F7 0C             JSR     GENERT          ;generate(brs)
001A69  1  20 91 12             JSR     COMLBL          ;compiler$label
001A6C  1  A5 7B                LDA     SP
001A6E  1  20 48 12             JSR     NRMLKU          ;normal$lookup(sp)
001A71  1  48                   PHA                     ;save result
001A72  1  A5 83                LDA     STYPSP
001A74  1  20 D1 0C             JSR     STSTMP          ;setstypemp(stypesp)
001A77  1  A5 A7                LDA     BASE
001A79  1  A4 A8                LDY     BASE+1
001A7B  1  20 BF 0C             JSR     STSLMP          ;setsymlocmp(base)
001A7E  1  2C 00 2E             BIT     PASS1           ;if pass 1
001A81  1  30 04                BMI     *+6             ;then
001A83  1  68                   PLA                     ;clear stack
001A84  1  4C 6A 11             JMP     RELINK
001A87  1  68                   PLA                     ;if not flag
001A88  1  F0 05                BEQ     *+7             ;then
001A8A  1  A9 02                LDA     #2              ;else function name previously defined
001A8C  1  20 AE 0A             JSR     ERROR
001A8F  1  A5 B2                LDA     CODESI
001A91  1  A4 B3                LDY     CODESI+1
001A93  1  4C 09 10             JMP     SETRSV          ;setaddr(codesize)
001A96  1               ;92	|
001A96  1               PR92
001A96  1  A9 00                LDA     #0
001A98  1  4C D7 0C             JMP     STTYMP          ;settypemp(0)
001A9B  1               ;98	<file decleration>::=<identifier><file rec size>
001A9B  1               PR98
001A9B  1  A5 7C                LDA     MP
001A9D  1  20 22 14             JSR     PSIMPV          ;process$simple$variable(mp)
001AA0  1  A5 85                LDA     STYPMP          ;if stypemp
001AA2  1  C9 31                CMP     #FLOTPT         ;<> floatpt
001AA4  1  D0 05                BNE     *+7             ;then
001AA6  1  A9 17                LDA     #23             ;invalid type in file
001AA8  1  20 AE 0A             JSR     ERROR
001AAB  1  A5 86                LDA     SYMLSP
001AAD  1  A4 87                LDY     SYMLSP+1
001AAF  1  20 44 0F             JSR     LITLOD          ;litload(symlocsp)
001AB2  1  A9 2D                LDA     #OPN
001AB4  1  4C F7 0C             JMP     GENERT          ;generate(opn)
001AB7  1               ;100	|
001AB7  1               PR100
001AB7  1  A9 00                LDA     #0
001AB9  1  A8                   TAY
001ABA  1  4C 3B 0F             JMP     LITERL          ;literal(0)
001ABD  1               ;104	<dimension variable>::=<dim var head><expression>
001ABD  1               PR104
001ABD  1  20 E7 12             JSR     CHKTY5          ;chktyp5
001AC0  1  A5 8A                LDA     SYMLMP
001AC2  1  A4 8B                LDY     SYMLMP+1
001AC4  1  85 A7                STA     BASE
001AC6  1  84 A8                STY     BASE+1          ;base=symlocsp
001AC8  1  60                   RTS
001AC9  1               ;105	<dim var head>::=<identifier>(
001AC9  1               PR105
001AC9  1  A5 7C                LDA     MP
001ACB  1  20 48 12             JSR     NRMLKU          ;if not normal$lookup(mp)
001ACE  1  F0 0A                BEQ     PR105A          ;then
001AD0  1  2C 00 2E             BIT     PASS1           ;if not pass 1
001AD3  1  10 05                BPL     PR105A          ;then
001AD5  1  A9 01                LDA     #1              ;identifier in dim previously defined
001AD7  1  20 AE 0A             JSR     ERROR
001ADA  1               PR105A
001ADA  1  A9 02                LDA     #SUBVAR
001ADC  1  20 35 10             JSR     SETTYP          ;setype(subvar)
001ADF  1  2C 00 2E             BIT     PASS1           ;if not pass 1
001AE2  1  10 06                BPL     *+8             ;then
001AE4  1  20 54 12             JSR     CNTPRT
001AE7  1  20 09 10             JSR     SETRSV          ;setaddr(countprt)
001AEA  1  20 54 10             JSR     GETADR
001AED  1  20 3B 0F             JSR     LITERL          ;literal(getaddr)
001AF0  1  A9 00                LDA     #0
001AF2  1  20 D7 0C             JSR     STTYMP          ;settypemp(0)
001AF5  1  A5 A7                LDA     BASE
001AF7  1  A4 A8                LDY     BASE+1
001AF9  1  4C BF 0C             JMP     STSLMP          ;setsymlocmp(base)
001AFC  1               ;108	<close list>::=<expression>
001AFC  1               PR108
001AFC  1  A5 83                LDA     STYPSP          ;if stypesp
001AFE  1  C9 32                CMP     #STRING         ;<> string
001B00  1  D0 03                BNE     *+5             ;then
001B02  1  20 D4 12             JSR     MFERR           ;must be floating
001B05  1  A9 5B                LDA     #RON
001B07  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001B0A  1  A9 40                LDA     #CLS
001B0C  1  4C F7 0C             JMP     GENERT          ;generate(cls)
001B0F  1               ;110	<read statement>::= read <file option><read list>
001B0F  1               PR110
001B0F  1  2C 0B 2E             BIT     FILEIO          ;if not fileio
001B12  1  10 0A                BPL     PR110A          ;then
001B14  1  A9 3E                LDA     #EDR
001B16  1  20 F7 0C             JSR     GENERT          ;generate(edr)
001B19  1               ;117	|
001B19  1               PR117
001B19  1  A9 00                LDA     #FALSE
001B1B  1  8D 0B 2E             STA     FILEIO          ;fileio=false
001B1E  1               PR110A
001B1E  1  60                   RTS
001B1F  1               ;112	<input statement>::=input <prompt option><read list>
001B1F  1               PR112
001B1F  1  A9 27                LDA     #ECR
001B21  1  20 F7 0C             JSR     GENERT          ;generate(ecr)
001B24  1  A9 00                LDA     #FALSE
001B26  1  85 47                STA     INPSTM          ;inputstmt=false
001B28  1  60                   RTS
001B29  1               ;113	<prompt option>::=<constant>
001B29  1               PR113
001B29  1  20 E7 14             JSR     PUTFLD          ;put$field
001B2C  1  4C 15 13             JMP     SEINPU          ;setup$input
001B2F  1               ;119	|print <file option><file list>
001B2F  1               PR119
001B2F  1  A9 3F                LDA     #EDW
001B31  1  20 F7 0C             JSR     GENERT          ;generate(edw)
001B34  1  A9 00                LDA     #FALSE
001B36  1  8D 0B 2E             STA     FILEIO          ;fileio=false
001B39  1  60                   RTS
001B3A  1               ;126	|
001B3A  1               PR126
001B3A  1  A9 34                LDA     #DBF
001B3C  1  4C F7 0C             JMP     GENERT          ;generate(dbf)
001B3F  1               ;127	<file option>::= # <expression>
001B3F  1               PR127
001B3F  1  A9 FF                LDA     #TRUE
001B41  1  8D 0B 2E             STA     FILEIO          ;fileio=true
001B44  1  A9 5B                LDA     #RON
001B46  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001B49  1  A9 26                LDA     #RDB
001B4B  1  4C F7 0C             JMP     GENERT          ;generate(rdb)
001B4E  1               ;128	| # <expression>,<expression>;
001B4E  1               PR128
001B4E  1  A9 FF                LDA     #TRUE
001B50  1  8D 0B 2E             STA     FILEIO          ;fileio=true
001B53  1  A9 5B                LDA     #RON
001B55  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001B58  1  A9 13                LDA     #XCH
001B5A  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001B5D  1  A9 5B                LDA     #RON
001B5F  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001B62  1  A9 25                LDA     #RDF
001B64  1  4C F7 0C             JMP     GENERT          ;generate(rdf)
001B67  1               ;130	| ,
001B67  1               PR130
001B67  1  2C 0B 2E             BIT     FILEIO          ;if not fileio
001B6A  1  10 01                BPL     *+3             ;then
001B6C  1  60                   RTS
001B6D  1  A9 35                LDA     #NSP
001B6F  1  4C F7 0C             JMP     GENERT          ;generate(nsp)
001B72  1               ;133	|<on gosub> <label list>
001B72  1               PR133
001B72  1  20 7D 13             JSR     GENON2          ;gen$on$2
001B75  1  A9 00                LDA     #0
001B77  1  4C 6F 12             JMP     ENCMLB          ;enter$compiler$label(0)
001B7A  1               ;135	<on gosub>::= on <expression> <gosub>
001B7A  1               PR135
001B7A  1  20 88 12             JSR     STCMLB          ;set$compiler$label
001B7D  1  20 54 10             JSR     GETADR
001B80  1  20 3B 0F             JSR     LITERL          ;literal(getaddr)
001B83  1  A9 60                LDA     #ADJ
001B85  1  20 F7 0C             JSR     GENERT          ;generate(adj)
001B88  1  A9 13                LDA     #XCH
001B8A  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001B8D  1  4C 60 13             JMP     GENON           ;gen$on
001B90  1               ;136	<label list>::=<number>
001B90  1               PR136
001B90  1  20 0E 14             JSR     RESLBL          ;resolve$label
001B93  1  A9 01                LDA     #1
001B95  1  4C C5 0C             JMP     STTYSP          ;settypesp(1)
001B98  1               ;137	|<label list>,<number>
001B98  1               PR137
001B98  1  20 0E 14             JSR     RESLBL          ;resolve$label
001B9B  1  A6 82                LDX     TYPEMP
001B9D  1  E8                   INX
001B9E  1  8A                   TXA
001B9F  1  4C D7 0C             JMP     STTYMP          ;settypemp(typemp+1)
001BA2  1               ;138	<gosub statement>::=<gosub><number>
001BA2  1               PR138
001BA2  1  A9 FF                LDA     #TRUE
001BA4  1  85 48                STA     GSBSTM          ;gosubstmt=true
001BA6  1  20 0E 14             JSR     RESLBL          ;resolve$label
001BA9  1  A9 00                LDA     #FALSE
001BAB  1  85 48                STA     GSBSTM          ;gosubstmt=false
001BAD  1  60                   RTS
001BAE  1               ;147	<out statement>::= out <expression>,<expression>
001BAE  1               PR147
001BAE  1  A9 31                LDA     #FLOTPT         ;if stypemp1
001BB0  1  C5 84                CMP     STYPM1          ;<> floatpt
001BB2  1  D0 04                BNE     *+6             ;then
001BB4  1  C5 83                CMP     STYPSP          ;if stypesp = floatpt
001BB6  1  F0 03                BEQ     *+5             ;then ok
001BB8  1  4C D4 12             JMP     MFERR           ;must be floating error
001BBB  1  A9 5B                LDA     #RON
001BBD  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001BC0  1  A9 13                LDA     #XCH
001BC2  1  20 F7 0C             JSR     GENERT          ;generate(xch)
001BC5  1  A9 5B                LDA     #RON
001BC7  1  20 F7 0C             JSR     GENERT          ;generate(ron)
001BCA  1  A9 28                LDA     #POT
001BCC  1  4C F7 0C             JMP     GENERT          ;generate(pot)
001BCF  1               ;148	<return statement>::= return
001BCF  1               PR148
001BCF  1  A9 1F                LDA     #RTN
001BD1  1  4C F7 0C             JMP     GENERT          ;generate(rtn)
001BD4  1               ;149	<stop statement>::= stop
001BD4  1               PR149
001BD4  1  A9 10                LDA     #XIT
001BD6  1  4C F7 0C             JMP     GENERT          ;generate(xit)
001BD9  1               ;150	<end statement>::= end
001BD9  1               PR150
001BD9  1  2C 00 2E             BIT     PASS1           ;if not pass 1
001BDC  1  10 33                BPL     PR150B          ;then
001BDE  1  A9 00                LDA     #FALSE
001BE0  1  8D 00 2E             STA     PASS1           ;pass1=false
001BE3  1  A5 A9                LDA     FORCNT          ;if forcount
001BE5  1  F0 09                BEQ     PR150A          ;= zero then ok
001BE7  1  A9 18                LDA     #24             ;else for without next error
001BE9  1  20 AE 0A             JSR     ERROR
001BEC  1  A9 00                LDA     #0
001BEE  1  85 A9                STA     FORCNT          ;forcount=0
001BF0  1               PR150A
001BF0  1  A9 2A                LDA     #'*'
001BF2  1  20 F7 0C             JSR     GENERT          ;generate('*')
001BF5  1  18                   CLC
001BF6  1  A5 B2                LDA     CODESI
001BF8  1  A4 B3                LDY     CODESI+1
001BFA  1  69 03                ADC     #3
001BFC  1  90 01                BCC     *+3
001BFE  1  C8                   INY
001BFF  1  29 FC                AND     #$FC
001C01  1  20 32 0F             JSR     GENTWO          ;gen$two((codesize+3) and $fffc)
001C04  1  A5 45                LDA     DATACT
001C06  1  A4 46                LDY     DATACT+1
001C08  1  20 32 0F             JSR     GENTWO          ;gen$two(datact)
001C0B  1  20 54 12             JSR     CNTPRT
001C0E  1  4C 32 0F             JMP     GENTWO          ;gen$two(countprt)
001C11  1               PR150B
001C11  1  A5 4D                LDA     NXTCHR
001C13  1  C9 0D                CMP     #CR
001C15  1  F0 06                BEQ     *+8
001C17  1  20 15 0A             JSR     GETCHR
001C1A  1  4C 11 1C             JMP     PR150B          ;while not eol
001C1D  1  A9 10                LDA     #XIT
001C1F  1  20 F7 0C             JSR     GENERT          ;generate(xit)
001C22  1  A9 7F                LDA     #$7F
001C24  1  20 F7 0C             JSR     GENERT          ;generate($7f)
001C27  1  20 94 09             JSR     WRTINT          ;write$int$file
001C2A  1  20 4E 09             JSR     CLSINT          ;close$int$file
001C2D  1  A5 43                LDA     ERRCNT
001C2F  1  A4 44                LDY     ERRCNT+1
001C31  1  20 70 08             JSR     PRNDEC          ;printdec(errorcount)
001C34  1  A9 95                LDA     #<ERDMSG
001C36  1  A0 2D                LDY     #>ERDMSG
001C38  1  20 FC 08             JSR     PRNMSG          ;print('errors detected')
001C3B  1  20 34 08             JSR     CRLF
001C3E  1  4C 00 01             JMP     BOOT
001C41  1               ;151	<restore statement>::= restore
001C41  1               PR151
001C41  1  A9 2F                LDA     #RST
001C43  1  4C F7 0C             JMP     GENERT          ;generate(rst)
001C46  1               ;152	<randomize statement>::= randomize
001C46  1               PR152
001C46  1  A9 4D                LDA     #IRN
001C48  1  4C F7 0C             JMP     GENERT          ;generate(irn)
001C4B  1               ;getin1  (does ay=index1(state))
001C4B  1               GETIN1
001C4B  1  A5 79                LDA     STATE
001C4D  1  A4 7A                LDY     STATE+1         ;get state
001C4F  1  0A                   ASL     A
001C50  1  AA                   TAX
001C51  1  98                   TYA
001C52  1  2A                   ROL     A
001C53  1  A8                   TAY
001C54  1  18                   CLC
001C55  1  8A                   TXA
001C56  1  69 AE                ADC     #<INDEX1        ;add state*2 since is word addressing
001C58  1  8D 6F 1C             STA     GT+1
001C5B  1  98                   TYA
001C5C  1  69 24                ADC     #>INDEX1
001C5E  1  8D 70 1C             STA     GT+2
001C61  1  A2 00                LDX     #0
001C63  1  20 6E 1C             JSR     GT              ;get low
001C66  1  48                   PHA
001C67  1  E8                   INX
001C68  1  20 6E 1C             JSR     GT              ;get high
001C6B  1  A8                   TAY
001C6C  1  68                   PLA
001C6D  1  60                   RTS
001C6E  1               ;general purpose lda abs,x routine
001C6E  1               GT
001C6E  1  BD FF FF             LDA     $FFFF,X
001C71  1  60                   RTS
001C72  1               ;getin2 (does ay=index2(state))
001C72  1               GETIN2
001C72  1  A5 79                LDA     STATE
001C74  1  A4 7A                LDY     STATE+1
001C76  1  18                   CLC
001C77  1  69 5A                ADC     #<INDEX2
001C79  1  8D 83 1C             STA     G2+1
001C7C  1  98                   TYA
001C7D  1  69 27                ADC     #>INDEX2
001C7F  1  8D 84 1C             STA     G2+2
001C82  1               G2
001C82  1  AD FF FF             LDA     $FFFF
001C85  1  A0 00                LDY     #0              ;y always zero
001C87  1  60                   RTS
001C88  1               ;incsp
001C88  1               INCSP
001C88  1  E6 7B                INC     SP
001C8A  1  A5 7B                LDA     SP              ;bump and get
001C8C  1  C9 20                CMP     #PSTKSZ         ;compare to max
001C8E  1  F0 01                BEQ     *+3             ;if = then
001C90  1  60                   RTS                     ;else ok
001C91  1  A9 12                LDA     #18             ;stack overflow error
001C93  1  4C AE 0A             JMP     ERROR
001C96  1               ;lookahead
001C96  1               LAHEAD
001C96  1  24 7E                BIT     NOLOOK          ;if not nolook
001C98  1  10 07                BPL     LAHEAX          ;then done
001C9A  1  20 9B 0D             JSR     SCANNR          ;scanner
001C9D  1  A9 00                LDA     #FALSE
001C9F  1  85 7E                STA     NOLOOK          ;nolook=false
001CA1  1               LAHEAX
001CA1  1  60                   RTS
001CA2  1               ;set$varc$i ---- set varc and increment varindex
001CA2  1               STVRCI
001CA2  1  A6 7F                LDX     VARIND
001CA4  1  9D FA 2F             STA     VARC,X          ;save
001CA7  1  E8                   INX
001CA8  1  86 7F                STX     VARIND          ;bump index
001CAA  1  E0 65                CPX     #VARCSZ+1       ;if too big
001CAC  1  B0 01                BCS     *+3             ;then error
001CAE  1  60                   RTS
001CAF  1  A9 15                LDA     #21             ;varc overflow
001CB1  1  4C AE 0A             JMP     ERROR
001CB4  1               ;initialize all of system
001CB4  1               INTLZ
001CB4  1  20 5F 0F             JSR     INSYMT          ;in$symtbl
001CB7  1  20 B4 11             JSR     INSYN           ;in$syn
001CBA  1  4C 1D 0B             JMP     INSCAN
001CBD  1               ;MAIN PROGRAM
001CBD  1               MAIN
001CBD  1  A2 02                LDX     #2              ;clear page zero
001CBF  1  A9 00                LDA     #0
001CC1  1               PZC
001CC1  1  95 00                STA     0,X
001CC3  1  E8                   INX
001CC4  1  E0 C6                CPX     #LZ
001CC6  1  D0 F9                BNE     PZC
001CC8  1  A9 FF                LDA     #TRUE           ;initialize once
001CCA  1  8D 00 2E             STA     PASS1
001CCD  1  8D 05 2E             STA     LWRUPR
001CD0  1  A9 3A                LDA     #':'
001CD2  1  85 74                STA     SEPRTR
001CD4  1  A9 80                LDA     #SRCRSZ
001CD6  1  85 75                STA     SRCIND
001CD8  1  A9 DB                LDA     #<OPNMSG
001CDA  1  A0 2D                LDY     #>OPNMSG
001CDC  1  20 FC 08             JSR     PRNMSG          ;print opening message
001CDF  1  20 34 08             JSR     CRLF
001CE2  1  20 B4 1C             JSR     INTLZ           ;initialize all
001CE5  1               ;do forever
001CE5  1               ;do while (pass1 or pass2)
001CE5  1               M10
001CE5  1  2C 00 2E             BIT     PASS1           ;if pass 1
001CE8  1  30 08                BMI     M12             ;then go
001CEA  1  2C 01 2E             BIT     PASS2           ;or if
001CED  1  30 03                BMI     M12             ;pass2 go
001CEF  1  4C F2 1E             JMP     EWP1P2          ;else end of do while pass1 or pass2
001CF2  1               M12
001CF2  1  A9 FF                LDA     #TRUE
001CF4  1  85 7E                STA     NOLOOK          ;nolook=true
001CF6  1  8D 09 2E             STA     CMPLNG          ;compiling=true
001CF9  1  A9 79                LDA     #<STARTS
001CFB  1  A0 00                LDY     #>STARTS
001CFD  1  85 79                STA     STATE
001CFF  1  84 7A                STY     STATE+1         ;state=startstate
001D01  1  A9 FF                LDA     #255
001D03  1  85 7B                STA     SP              ;sp=255
001D05  1  A9 00                LDA     #0
001D07  1  85 7F                STA     VARIND          ;varind=0
001D09  1  8D DA 2E             STA     VAR
001D0C  1               ;do while compiling
001D0C  1               M14
001D0C  1  2C 09 2E             BIT     CMPLNG          ;test for compiling
001D0F  1  10 D4                BPL     M10             ;branch if not
001D11  1  A9 78                LDA     #<MAXRNO
001D13  1  C5 79                CMP     STATE
001D15  1  A9 00                LDA     #>MAXRNO
001D17  1  E5 7A                SBC     STATE+1         ;if state>maxrno
001D19  1  B0 03                BCS     *+5             ;continue if ok
001D1B  1  4C DE 1D             JMP     M30             ;else try next
001D1E  1  20 88 1C             JSR     INCSP
001D21  1  A5 7B                LDA     SP
001D23  1  0A                   ASL     A               ;word addressing
001D24  1  AA                   TAX
001D25  1  A5 79                LDA     STATE
001D27  1  9D BA 2F             STA     STSTAK,X
001D2A  1  A5 7A                LDA     STATE+1
001D2C  1  9D BB 2F             STA     STSTAK+1,X      ;statestack(sp)=state
001D2F  1  20 4B 1C             JSR     GETIN1
001D32  1  85 98                STA     I
001D34  1  84 99                STY     I+1             ;i=getin1
001D36  1  20 96 1C             JSR     LAHEAD          ;lookahead
001D39  1  20 72 1C             JSR     GETIN2          ;index2(state)
001D3C  1  18                   CLC
001D3D  1  65 98                ADC     I
001D3F  1  85 9A                STA     J
001D41  1  98                   TYA
001D42  1  65 99                ADC     I+1
001D44  1  85 9B                STA     J+1
001D46  1  A5 9A                LDA     J
001D48  1  D0 02                BNE     *+4
001D4A  1  C6 9B                DEC     J+1
001D4C  1  C6 9A                DEC     J               ;j=i-1+getin2
001D4E  1               M20
001D4E  1  A5 9A                LDA     J
001D50  1  C5 98                CMP     I
001D52  1  A5 9B                LDA     J+1
001D54  1  E5 99                SBC     I+1             ;if i>j
001D56  1  90 B4                BCC     M14             ;go to while compiling
001D58  1  18                   CLC
001D59  1  A5 98                LDA     I
001D5B  1  69 02                ADC     #<READ1
001D5D  1  85 9F                STA     I2
001D5F  1  A5 99                LDA     I+1
001D61  1  69 1F                ADC     #>READ1
001D63  1  85 A0                STA     I2+1
001D65  1  A0 00                LDY     #0
001D67  1  B1 9F                LDAINDIRECTY I2         ;a=read(i)
001D69  1  C5 49                CMP     TOKEN           ;if not token
001D6B  1  D0 57                BNE     M23             ;then
001D6D  1  A5 7F                LDA     VARIND          ;get varindex
001D6F  1  A6 7B                LDX     SP
001D71  1  9D DA 2E             STA     VAR,X           ;set var(sp)
001D74  1  A2 00                LDX     #0
001D76  1  86 9E                STX     INDEX           ;index=0
001D78  1               M22
001D78  1  B5 4E                LDA     ACCUM,X         ;accum(index)
001D7A  1  20 A2 1C             JSR     STVRCI
001D7D  1  E6 9E                INC     INDEX           ;index=index+1
001D7F  1  A6 9E                LDX     INDEX
001D81  1  E4 4E                CPX     ACCLEN          ;if < length
001D83  1  90 F3                BCC     M22             ;then loop
001D85  1  F0 F1                BEQ     M22             ;loop also if equal
001D87  1  A6 7B                LDX     SP
001D89  1  A5 4C                LDA     HSHCDE
001D8B  1  9D BA 2E             STA     HASH,X          ;hash(sp)=hashcode
001D8E  1  A5 4A                LDA     SUBTYP
001D90  1  9D 1A 2F             STA     STYPE,X         ;stype(sp)=subtype
001D93  1  A5 98                LDA     I
001D95  1  0A                   ASL     A
001D96  1  85 9F                STA     I2
001D98  1  A5 99                LDA     I+1
001D9A  1  2A                   ROL     A
001D9B  1  85 A0                STA     I2+1            ;i2=i*2
001D9D  1  18                   CLC
001D9E  1  A5 9F                LDA     I2
001DA0  1  69 E6                ADC     #<READ2
001DA2  1  85 9F                STA     I2
001DA4  1  A5 A0                LDA     I2+1
001DA6  1  69 20                ADC     #>READ2
001DA8  1  85 A0                STA     I2+1            ;read2(i)
001DAA  1  A0 00                LDY     #0
001DAC  1  B1 9F                LDAINDIRECTY I2         ;low
001DAE  1  85 79                STA     STATE
001DB0  1  C8                   INY
001DB1  1  B1 9F                LDAINDIRECTY I2
001DB3  1  85 7A                STA     STATE+1         ;state=read2(i)
001DB5  1  A9 FF                LDA     #TRUE
001DB7  1  85 7E                STA     NOLOOK          ;nolook=true
001DB9  1  A5 9A                LDA     J
001DBB  1  A4 9B                LDY     J+1
001DBD  1  85 98                STA     I
001DBF  1  84 99                STY     I+1
001DC1  1  4C D5 1D             JMP     M24
001DC4  1               M23
001DC4  1  A5 98                LDA     I
001DC6  1  C5 9A                CMP     J               ;ok if different
001DC8  1  D0 0B                BNE     M24
001DCA  1  A5 99                LDA     I+1
001DCC  1  C5 9B                CMP     J+1
001DCE  1  D0 05                BNE     M24             ;ok if different
001DD0  1  A9 0F                LDA     #15             ;no legal production
001DD2  1  20 AE 0A             JSR     ERROR
001DD5  1               M24
001DD5  1  E6 98                INC     I               ;bump i and loop
001DD7  1  D0 02                BNE     *+4
001DD9  1  E6 99                INC     I+1
001DDB  1  4C 4E 1D             JMP     M20
001DDE  1               M30
001DDE  1  A9 BD                LDA     #<MAXPNO        ;if state <= maxpno
001DE0  1  C5 79                CMP     STATE
001DE2  1  A9 00                LDA     #>MAXPNO
001DE4  1  E5 7A                SBC     STATE+1
001DE6  1  90 03                BCC     *+5
001DE8  1  4C 76 1E             JMP     M40
001DEB  1  20 72 1C             JSR     GETIN2          ;index2(state)
001DEE  1  85 98                STA     I               ;ignore high
001DF0  1  38                   SEC
001DF1  1  A5 7B                LDA     SP
001DF3  1  E5 98                SBC     I
001DF5  1  85 7C                STA     MP              ;mp=sp-getin2
001DF7  1  A8                   TAY
001DF8  1  C8                   INY
001DF9  1  84 7D                STY     MPP1            ;mpp1=mp+1
001DFB  1  38                   SEC
001DFC  1  A5 79                LDA     STATE
001DFE  1  E9 BD                SBC     #<MAXPNO        ;parameter=state-maxpno
001E00  1  20 DF 15             JSR     SYNTHE          ;synthesize(state-maxpno)
001E03  1  2C 09 2E             BIT     CMPLNG          ;if compiling
001E06  1  30 03                BMI     *+5             ;then go
001E08  1  4C E5 1C             JMP     M10             ;else go to do while pass 1 or pass 2
001E0B  1  A5 7C                LDA     MP
001E0D  1  85 7B                STA     SP              ;sp=mp
001E0F  1  20 4B 1C             JSR     GETIN1
001E12  1  85 98                STA     I
001E14  1  84 99                STY     I+1             ;i=getin1
001E16  1  A6 7B                LDX     SP
001E18  1  BD DA 2E             LDA     VAR,X
001E1B  1  85 7F                STA     VARIND          ;varindex=var(sp)
001E1D  1  8A                   TXA
001E1E  1  0A                   ASL     A
001E1F  1  AA                   TAX                     ;word addressing
001E20  1  BD BA 2F             LDA     STSTAK,X
001E23  1  85 9A                STA     J
001E25  1  BD BB 2F             LDA     STSTAK+1,X
001E28  1  85 9B                STA     J+1             ;j=statestack(sp)
001E2A  1               M31
001E2A  1  A2 00                LDX     #0
001E2C  1  86 9D                STX     K+1             ;high must be zero
001E2E  1  A6 98                LDX     I
001E30  1  BD 66 20             LDA     APPLY1,X
001E33  1  85 9C                STA     K
001E35  1  F0 11                BEQ     M33             ;exit if k=0
001E37  1  C5 9A                CMP     J
001E39  1  D0 04                BNE     M32             ;ok if low k <> low j
001E3B  1  A5 9B                LDA     J+1
001E3D  1  F0 09                BEQ     M33             ;if =0 then j=k
001E3F  1               M32
001E3F  1  E6 98                INC     I
001E41  1  D0 E7                BNE     M31             ;loop
001E43  1  E6 99                INC     I+1
001E45  1  4C 2A 1E             JMP     M31
001E48  1               M33
001E48  1  A5 98                LDA     I               ;ignore high i
001E4A  1  0A                   ASL     A
001E4B  1  85 9F                STA     I2
001E4D  1  A5 99                LDA     I+1
001E4F  1  2A                   ROL     A
001E50  1  85 A0                STA     I2+1
001E52  1  18                   CLC
001E53  1  A5 9F                LDA     I2
001E55  1  69 AE                ADC     #<APPLY2
001E57  1  85 9F                STA     I2
001E59  1  A5 A0                LDA     I2+1
001E5B  1  69 23                ADC     #>APPLY2
001E5D  1  85 A0                STA     I2+1
001E5F  1  A0 00                LDY     #0
001E61  1  B1 9F                LDAINDIRECTY I2
001E63  1  85 79                STA     STATE
001E65  1  C8                   INY
001E66  1  B1 9F                LDAINDIRECTY I2
001E68  1  85 7A                STA     STATE+1         ;state=apply2(i)
001E6A  1  05 79                ORA     STATE
001E6C  1  D0 05                BNE     *+7             ;if not zero then
001E6E  1  A9 00                LDA     #FALSE
001E70  1  8D 09 2E             STA     CMPLNG          ;compiling=false
001E73  1  4C 0C 1D             JMP     M14
001E76  1               M40
001E76  1  A9 AF                LDA     #<MAXLNO        ;if state
001E78  1  C5 79                CMP     STATE
001E7A  1  A9 00                LDA     #>MAXLNO
001E7C  1  E5 7A                SBC     STATE+1         ;> maxlno
001E7E  1  90 55                LBCC     M50            ;then go to next
001E80  1  20 4B 1C             JSR     GETIN1
001E83  1  85 98                STA     I
001E85  1  84 99                STY     I+1             ;i=getin1
001E87  1  20 96 1C             JSR     LAHEAD          ;lookahead
001E8A  1               M41
001E8A  1  A2 00                LDX     #0
001E8C  1  86 9D                STX     K+1
001E8E  1  18                   CLC
001E8F  1  A5 98                LDA     I
001E91  1  69 CF                ADC     #<LOOK1
001E93  1  85 9F                STA     I2
001E95  1  A5 99                LDA     I+1
001E97  1  69 1F                ADC     #>LOOK1
001E99  1  85 A0                STA     I2+1
001E9B  1  A0 00                LDY     #0
001E9D  1  B1 9F                LDAINDIRECTY I2         ;a=look1(i)
001E9F  1  85 9C                STA     K
001EA1  1  F0 0D                BEQ     M42             ;exit if k=0
001EA3  1  C5 49                CMP     TOKEN
001EA5  1  F0 09                BEQ     M42             ;or if =token
001EA7  1  E6 98                INC     I               ;bump and loop
001EA9  1  D0 DF                BNE     M41
001EAB  1  E6 99                INC     I+1
001EAD  1  4C 8A 1E             JMP     M41
001EB0  1               M42
001EB0  1  A5 98                LDA     I               ;word addressing
001EB2  1  0A                   ASL     A
001EB3  1  85 9F                STA     I2
001EB5  1  A5 99                LDA     I+1
001EB7  1  2A                   ROL     A
001EB8  1  85 A0                STA     I2+1
001EBA  1  18                   CLC
001EBB  1  A5 9F                LDA     I2              ;add start
001EBD  1  69 80                ADC     #<LOOK2
001EBF  1  85 9F                STA     I2
001EC1  1  A5 A0                LDA     I2+1
001EC3  1  69 22                ADC     #>LOOK2
001EC5  1  85 A0                STA     I2+1
001EC7  1  A0 00                LDY     #0
001EC9  1  B1 9F                LDAINDIRECTY I2         ;low
001ECB  1  85 79                STA     STATE
001ECD  1  C8                   INY
001ECE  1  B1 9F                LDAINDIRECTY I2
001ED0  1  85 7A                STA     STATE+1
001ED2  1  4C 0C 1D             JMP     M14
001ED5  1               M50
001ED5  1  20 88 1C             JSR     INCSP
001ED8  1  20 72 1C             JSR     GETIN2
001EDB  1  48                   PHA                     ;save low
001EDC  1  A5 7B                LDA     SP
001EDE  1  0A                   ASL     A               ;word addressing
001EDF  1  AA                   TAX
001EE0  1  68                   PLA
001EE1  1  9D BA 2F             STA     STSTAK,X        ;statestack(sp)=getin2
001EE4  1  98                   TYA
001EE5  1  9D BB 2F             STA     STSTAK+1,X
001EE8  1  20 4B 1C             JSR     GETIN1
001EEB  1  85 79                STA     STATE
001EED  1  84 7A                STY     STATE+1         ;state=getin1
001EEF  1  4C 0C 1D             JMP     M14
001EF2  1               ;end of do while pass 1 or pass 2
001EF2  1               EWP1P2
001EF2  1  A9 FF                LDA     #TRUE
001EF4  1  8D 03 2E             STA     LSTSRC          ;listsource=true
001EF7  1  20 B4 1C             JSR     INTLZ           ;initialize
001EFA  1  A9 FF                LDA     #TRUE
001EFC  1  8D 01 2E             STA     PASS2           ;pass2=true
001EFF  1  4C E5 1C             JMP     M10             ;do forever
001F02  1               ;parser state tables
001F02  1               READ1
001F02  1  00 31 0A 0D          .BYTE   0,49,10,13,2,49,50,52,53,54,49,13,22,32,2,3,7,27,30,49,50,52,53
001F06  1  02 31 32 34  
001F0A  1  35 36 31 0D  
001F19  1  36 02 03 07          .BYTE   54,2,3,7,30,49,50,52,53,54,54,52,12,52,2,3,7,49,50,52,53,54,12
001F1D  1  1E 31 32 34  
001F21  1  35 36 36 34  
001F30  1  34 31 31 32          .BYTE   52,49,49,50,2,3,7,12,30,49,50,52,53,54,2,2,2,9,5,9,49,4,8,49,16
001F34  1  02 03 07 0C  
001F38  1  1E 31 32 34  
001F49  1  14 1C 1D 1F          .BYTE   20,28,29,31,35,36,37,38,40,42,43,44,45,46,48,49,51,52,49,14,6
001F4D  1  23 24 25 26  
001F51  1  28 2A 2B 2C  
001F5E  1  16 0D 34 09          .BYTE   22,13,52,9,52,9,23,9,21,33,41,16,21,33,36,43,9,21,33,5,9,21,33
001F62  1  34 09 17 09  
001F66  1  15 21 29 10  
001F75  1  05 15 21 05          .BYTE   5,21,33,5,9,21,33,5,9,21,33,6,9,21,33,21,33,39,21,33,41,5,21,33
001F79  1  09 15 21 05  
001F7D  1  09 15 21 06  
001F8D  1  06 15 21 09          .BYTE   6,21,33,9,6,9,16,17,20,25,26,27,28,29,31,35,36,37,38,40,42,43
001F91  1  06 09 10 11  
001F95  1  14 19 1A 1B  
001FA3  1  2C 2D 2E 30          .BYTE   44,45,46,48,51,52,2,16,20,28,29,31,35,36,37,38,40,42,43,44,45
001FA7  1  33 34 02 10  
001FAB  1  14 1C 1D 1F  
001FB8  1  2E 30 33 34          .BYTE   46,48,51,52,52,13,24,11,34,9,2,1,3,7,10,13,15,18,19,3,7,9,0
001FBC  1  34 0D 18 0B  
001FC0  1  22 09 02 01  
001FCF  1               LOOK1
001FCF  1  00 31 00 0A          .BYTE   0,49,0,10,13,0,13,0,11,23,34,0,52,0,12,52,0,49,50,0,6,9,11,23
001FD3  1  0D 00 0D 00  
001FD7  1  0B 17 22 00  
001FE7  1  22 00 02 00          .BYTE   34,0,2,0,2,0,9,0,4,8,0,4,8,0,4,8,0,4,8,0,4,8,0,11,23,34,0,14,0
001FEB  1  02 00 09 00  
001FEF  1  04 08 00 04  
002004  1  0E 00 0E 00          .BYTE   14,0,14,0,9,0,9,0,9,0,9,0,9,0,21,33,0,21,33,0,21,33,0,21,33,0
002008  1  09 00 09 00  
00200C  1  09 00 09 00  
00201E  1  15 21 27 00          .BYTE   21,33,39,0,21,33,0,21,33,0,21,33,0,23,0,21,33,0,21,33,0,9,0,9
002022  1  15 21 00 15  
002026  1  21 00 15 21  
002036  1  00 06 09 00          .BYTE   0,6,9,0,52,0,11,23,0,11,23,34,0,2,0,11,23,0,52,0,24,0,24,0,11
00203A  1  34 00 0B 17  
00203E  1  00 0B 17 22  
00204F  1  00 17 00 0B          .BYTE   0,23,0,11,0,9,0,2,0,1,3,7,10,13,15,18,19,0,3,7,0,9,0
002053  1  00 09 00 02  
002057  1  00 01 03 07  
002066  1               APPLY1
002066  1  00 00 00 00          .BYTE   0,0,0,0,55,105,0,19,0,0,32,47,0,0,3,4,12,14,16,17,20,21,22,26
00206A  1  37 69 00 13  
00206E  1  00 00 20 2F  
00207E  1  1B 22 24 26          .BYTE   27,34,36,38,40,98,100,102,103,114,116,0,0,46,0,28,0,33,0,63,0,5
002082  1  28 62 64 66  
002086  1  67 72 74 00  
002094  1  06 08 09 00          .BYTE   6,8,9,0,7,10,0,23,0,13,19,32,35,47,55,99,101,105,106,0,0,0,0,0
002098  1  07 0A 00 17  
00209C  1  00 0D 13 20  
0020AC  1  27 00 00 00          .BYTE   39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,99
0020B0  1  00 00 00 00  
0020B4  1  00 00 00 00  
0020CA  1  6A 00 00 00          .BYTE   106,0,0,0,0,0,40,0,0,0,0,0,0,62,0,0,74,0,74,0,0,0,0,0,0,0,0,0
0020CE  1  00 00 28 00  
0020D2  1  00 00 00 00  
0020E6  1               READ2
0020E6  1  00 00 BF 00          .WORD   0,191,264,260,3,255,256,129,254,253,326,258,329,331,3,5,8,31
0020EA  1  08 01 04 01  
0020EE  1  03 00 FF 00  
00210A  1  21 00 FF 00          .WORD   33,255,256,129,254,253,3,5,8,33,255,256,129,254,253,279,42,21
00210E  1  00 01 81 00  
002112  1  FE 00 FD 00  
00212E  1  81 00 03 00          .WORD   129,3,5,8,255,256,129,254,253,20,129,273,255,256,3,5,8,20,33
002132  1  05 00 08 00  
002136  1  FF 00 00 01  
002154  1  FF 00 00 01          .WORD   255,256,129,254,253,247,294,4,335,280,283,320,7,10,327,24,26
002158  1  81 00 FE 00  
00215C  1  FD 00 F7 00  
002176  1  0C 01 20 00          .WORD   268,32,34,285,328,125,126,338,38,330,127,128,337,340,275,341
00217A  1  22 00 1D 01  
00217E  1  48 01 7D 00  
002196  1  81 00 45 01          .WORD   129,325,23,302,27,220,130,17,131,13,190,14,223,224,277,24,223
00219A  1  17 00 2E 01  
00219E  1  1B 00 DC 00  
0021B8  1  E0 00 48 01          .WORD   224,328,330,12,223,224,246,248,223,224,244,223,224,249,252,223
0021BC  1  4A 01 0C 00  
0021C0  1  DF 00 E0 00  
0021D8  1  E0 00 25 01          .WORD   224,293,295,223,224,316,16,223,224,223,224,36,223,224,37,288
0021DC  1  27 01 DF 00  
0021E0  1  E0 00 3C 01  
0021F8  1  DF 00 E0 00          .WORD   223,224,317,223,224,15,318,319,24,25,26,29,30,339,268,32,34,285
0021FC  1  3D 01 DF 00  
002200  1  E0 00 0F 00  
00221C  1  48 01 7D 00          .WORD   328,125,126,338,38,330,127,128,337,340,341,129,251,24,26,268,32
002220  1  7E 00 52 01  
002224  1  26 00 4A 01  
00223E  1  22 00 1D 01          .WORD   34,285,328,125,126,338,38,330,127,128,337,340,341,129,45,22,28
002242  1  48 01 7D 00  
002246  1  7E 00 52 01  
002260  1  7C 00 14 01          .WORD   124,276,286,282,122,6,9,123,257,259,261,265,6,9,11,0
002264  1  1E 01 1A 01  
002268  1  7A 00 06 00  
002280  1               LOOK2
002280  1  00 00 01 00          .WORD   0,1,176,2,2,263,18,262,177,177,177,19,334,333,35,35,178,39,39
002284  1  B0 00 02 00  
002288  1  02 00 07 01  
0022A6  1  B3 00 B4 00          .WORD   179,180,180,180,180,180,40,41,245,43,181,44,332,49,49,231,50,50
0022AA  1  B4 00 B4 00  
0022AE  1  B4 00 B4 00  
0022CA  1  EA 00 33 00          .WORD   234,51,51,235,52,52,232,53,53,233,182,182,182,55,57,236,58,237
0022CE  1  33 00 EB 00  
0022D2  1  34 00 34 00  
0022EE  1  3B 00 EE 00          .WORD   59,238,66,308,68,300,69,299,70,301,72,296,76,76,297,77,77,309
0022F2  1  42 00 34 01  
0022F6  1  44 00 2C 01  
002312  1  4E 00 4E 00          .WORD   78,78,219,84,84,312,85,85,85,183,87,87,336,88,88,298,89,89,310
002316  1  DB 00 54 00  
00231A  1  54 00 38 01  
002338  1  16 01 5B 00          .WORD   278,91,93,93,313,94,94,269,95,321,96,322,97,97,184,99,185,186
00233C  1  5D 00 5D 00  
002340  1  39 01 5E 00  
00235C  1  BA 00 65 00          .WORD   186,101,314,314,314,102,104,250,187,187,105,106,188,109,221,110
002360  1  3A 01 3A 01  
002364  1  3A 01 66 00  
00237C  1  DE 00 6F 00          .WORD   222,111,193,274,112,113,272,115,284,117,189,118,118,118,118,118
002380  1  C1 00 12 01  
002384  1  70 00 71 00  
00239C  1  76 00 76 00          .WORD   118,118,118,229,119,119,230,120,290
0023A0  1  76 00 E5 00  
0023A4  1  77 00 77 00  
0023AE  1               APPLY2
0023AE  1  00 00 00 00          .WORD   0,0,161,71,169,170,168,199,198,200,218,267,201,98,80,90,151,152
0023B2  1  A1 00 47 00  
0023B6  1  A9 00 AA 00  
0023D2  1  5C 00 9B 00          .WORD   92,155,83,86,154,74,150,75,156,146,147,148,149,153,82,79,81,73
0023D6  1  53 00 56 00  
0023DA  1  9A 00 4A 00  
0023F6  1  2E 00 A7 00          .WORD   46,167,166,226,225,228,227,174,173,133,135,134,136,132,139,140
0023FA  1  A6 00 E2 00  
0023FE  1  E1 00 E4 00  
002416  1  8A 00 F0 00          .WORD   138,240,239,305,64,64,304,64,64,304,64,64,304,241,114,243,116
00241A  1  EF 00 31 01  
00241E  1  40 00 40 00  
002438  1  A3 00 3C 00          .WORD   163,60,242,63,202,61,47,266,194,271,164,137,197,172,108,107,204
00243C  1  F2 00 3F 00  
002440  1  CA 00 3D 00  
00245A  1  41 00 AB 00          .WORD   65,171,287,196,175,292,291,103,205,145,206,210,165,143,144,142
00245E  1  1F 01 C4 00  
002462  1  AF 00 24 01  
00247A  1  CF 00 9F 00          .WORD   207,159,141,307,100,160,162,208,213,56,62,158,157,209,323,48
00247E  1  8D 00 33 01  
002482  1  64 00 A0 00  
00249A  1  44 01 36 00          .WORD   324,54,203,67,216,212,211,195,214,215
00249E  1  CB 00 43 00  
0024A2  1  D8 00 D4 00  
0024AE  1               INDEX1
0024AE  1  00 00 01 00          .WORD   0,1,2,24,24,4,4,4,4,4,4,34,24,36,24,10,24,24,11,168,24,24,24,4
0024B2  1  02 00 18 00  
0024B6  1  18 00 04 00  
0024DE  1  0C 00 0E 00          .WORD   12,14,24,24,24,33,34,35,36,37,24,45,24,47,24,48,50,60,61,62,63
0024E2  1  18 00 18 00  
0024E6  1  18 00 21 00  
002508  1  40 00 18 00          .WORD   64,24,36,66,67,67,67,67,67,69,70,89,90,90,90,91,92,89,37,93,94
00250C  1  24 00 42 00  
002510  1  43 00 43 00  
002532  1  5F 00 60 00          .WORD   95,96,97,97,97,98,99,100,103,108,100,100,100,111,115,118,122
002536  1  61 00 61 00  
00253A  1  61 00 62 00  
002554  1  7E 00 64 00          .WORD   126,100,130,133,100,100,100,136,100,139,100,100,142,142,143,24
002558  1  82 00 85 00  
00255C  1  64 00 64 00  
002574  1  24 00 18 00          .WORD   36,24,145,24,24,167,168,36,186,187,188,188,189,189,189,24,191
002578  1  91 00 18 00  
00257C  1  18 00 A7 00  
002596  1  18 00 C0 00          .WORD   24,192,193,201,203,1,3,6,8,12,14,17,20,26,28,30,32,35,38,41,44
00259A  1  C1 00 C9 00  
00259E  1  CB 00 01 00  
0025C0  1  2F 00 33 00          .WORD   47,51,53,55,57,59,61,63,65,67,70,73,76,79,83,86,89,92,94,97,100
0025C4  1  35 00 37 00  
0025C8  1  39 00 3B 00  
0025EA  1  66 00 68 00          .WORD   102,104,107,109,112,116,118,121,123,125,127,129,131,133,135,137
0025EE  1  6B 00 6D 00  
0025F2  1  70 00 74 00  
00260A  1  92 00 95 00          .WORD   146,149,192,217,306,303,311,289,217,270,315,306,217,217,306,281
00260E  1  C0 00 D9 00  
002612  1  32 01 2F 01  
00262A  1  01 00 02 00          .WORD   1,2,2,3,3,3,3,3,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,13
00262E  1  02 00 03 00  
002632  1  03 00 03 00  
002668  1  0E 00 0E 00          .WORD   14,14,36,36,37,37,39,39,41,41,43,43,43,43,43,45,45,45,50,50,53
00266C  1  24 00 24 00  
002670  1  25 00 25 00  
002692  1  35 00 35 00          .WORD   53,53,53,55,55,66,66,67,67,68,68,69,69,70,70,72,72,72,72,72,72
002696  1  35 00 37 00  
00269A  1  37 00 42 00  
0026BC  1  48 00 48 00          .WORD   72,72,72,73,74,75,76,76,77,77,77,78,78,79,80,81,82,83,83,84,84
0026C0  1  48 00 49 00  
0026C4  1  4A 00 4B 00  
0026E6  1  55 00 56 00          .WORD   85,86,86,87,88,88,89,90,90,91,93,93,94,95,95,96,96,97,98,98,99
0026EA  1  56 00 57 00  
0026EE  1  58 00 58 00  
002710  1  63 00 63 00          .WORD   99,99,102,102,103,103,103,104,104,105,105,106,106,108,108,109
002714  1  66 00 66 00  
002718  1  67 00 67 00  
002730  1  6E 00 6E 00          .WORD   110,110,111,112,113,113,115,116,116,118,118,120,120,121,121,122
002734  1  6F 00 70 00  
002738  1  71 00 71 00  
002750  1  7B 00 7C 00          .WORD   123,124,125,126,127
002754  1  7D 00 7E 00  
002758  1  7F 00        
00275A  1               INDEX2
00275A  1  00 01 02 09          .BYTE   0,1,2,9,9,6,6,6,6,6,6,1,9,1,9,1
00275E  1  09 06 06 06  
002762  1  06 06 06 01  
00276A  1  09 09 01 12          .BYTE   9,9,1,18,9,9,9,6,2,10,9,9,9,1,1
00276E  1  09 09 09 06  
002772  1  02 0A 09 09  
002779  1  01 01 08 09          .BYTE   1,1,8,9,2,9,1,9,2,10,1,1,1,1,2
00277D  1  02 09 01 09  
002781  1  02 0A 01 01  
002788  1  09 01 01 02          .BYTE   9,1,1,2,2,2,2,2,1,19,1,1,1,1,1,1
00278C  1  02 02 02 02  
002790  1  01 13 01 01  
002798  1  01 08 01 01          .BYTE   1,8,1,1,1,1,1,1,1,1,1,3,5,3,2,2
00279C  1  01 01 01 01  
0027A0  1  01 01 01 03  
0027A8  1  02 04 03 04          .BYTE   2,4,3,4,4,4,2,3,3,2,2,2,3,2,3,2
0027AC  1  04 04 02 03  
0027B0  1  03 02 02 02  
0027B8  1  02 01 01 02          .BYTE   2,1,1,2,9,1,9,22,9,9,1,18,1,1,1
0027BC  1  09 01 09 16  
0027C0  1  09 09 01 12  
0027C7  1  01 01 01 02          .BYTE   1,1,1,2,1,9,1,9,1,8,2,1,2,3,2,4
0027CB  1  01 09 01 09  
0027CF  1  01 08 02 01  
0027D7  1  02 03 03 06          .BYTE   2,3,3,6,2,2,2,3,3,3,3,3,4,2,2,2
0027DB  1  02 02 02 03  
0027DF  1  03 03 03 03  
0027E7  1  02 02 02 02          .BYTE   2,2,2,2,2,3,3,3,3,4,3,3,3,2,3,3
0027EB  1  02 03 03 03  
0027EF  1  03 04 03 03  
0027F7  1  02 02 03 02          .BYTE   2,2,3,2,3,4,2,3,2,2,2,2,2,2,2,2
0027FB  1  03 04 02 03  
0027FF  1  02 02 02 02  
002807  1  09 03 02 01          .BYTE   9,3,2,1,19,35,39,40,43,55,85,97
00280B  1  13 23 27 28  
00280F  1  2B 37 55 61  
002813  1  63 65 69 6A          .BYTE   99,101,105,106,117,2,0,0,0,0,0,0
002817  1  75 02 00 00  
00281B  1  00 00 00 00  
00281F  1  00 00 02 00          .BYTE   0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
002823  1  00 00 00 00  
002827  1  00 00 00 00  
00282E  1  00 00 00 00          .BYTE   0,0,0,0,0,0,1,1,1,0,2,0,0,0,2,0
002832  1  00 00 01 01  
002836  1  01 00 02 00  
00283E  1  01 00 02 00          .BYTE   1,0,2,0,2,2,1,1,0,2,2,0,2,0,0,0
002842  1  02 02 01 01  
002846  1  00 02 02 00  
00284E  1  02 00 02 01          .BYTE   2,0,2,1,2,2,0,1,2,0,0,0,0,0,1,0
002852  1  02 02 00 01  
002856  1  02 00 00 00  
00285E  1  01 00 00 00          .BYTE   1,0,0,0,1,0,3,1,0,1,0,0,1,5,1,1
002862  1  01 00 03 01  
002866  1  00 01 00 00  
00286E  1  02 02 03 01          .BYTE   2,2,3,1,2,0,0,2,1,0,2,1,2,0,1,0
002872  1  02 00 00 02  
002876  1  01 00 02 01  
00287E  1  02 02 01 02          .BYTE   2,2,1,2,1,0,2,2,1,2,1,0,0,2,0,2
002882  1  01 00 02 02  
002886  1  01 02 01 00  
00288E  1  02 00 02 00          .BYTE   2,0,2,0,0,2,0,0,2,4,0,0,1,1,1,2
002892  1  00 02 00 00  
002896  1  02 04 00 00  
00289E  1  02 00 02 01          .BYTE   2,0,2,1,0,1,0,1,1,0,0,2,3,0,0,0
0028A2  1  00 01 00 01  
0028A6  1  01 00 00 02  
0028AE  1  00 00                .BYTE   0,0
0028B0  1               ;reserved word tables
0028B0  1               ;length=1
0028B0  1               LNG1
0028B0  1  0D 3C 28 2B          .BYTE   CR,"<(+*)-,=/",semico,">:#^"
0028B4  1  2A 29 2D 2C  
0028B8  1  3D 2F 3B 3E  
0028BF  1               ;length=2
0028BF  1               LNG2
0028BF  1  49 46 54 4F          .BYTE   "IFTOGOONOREQLTGTLEGENE"
0028C3  1  47 4F 4F 4E  
0028C7  1  4F 52 45 51  
0028D5  1               ;length=3
0028D5  1               LNG3
0028D5  1  46 4F 52 4C          .BYTE   "FORLETREMDIMDEFNOTAND"
0028D9  1  45 54 52 45  
0028DD  1  4D 44 49 4D  
0028EA  1  54 41 4E 53          .BYTE   "TANSINCOSSQRTABLOGLEN"
0028EE  1  49 4E 43 4F  
0028F2  1  53 53 51 52  
0028FF  1  46 52 45 41          .BYTE   "FREATNABSEXPINTEND"
002903  1  54 4E 41 42  
002907  1  53 45 58 50  
002911  1  50 4F 53 52          .BYTE   "POSRNDSGNASCVALXORSUB"
002915  1  4E 44 53 47  
002919  1  4E 41 53 43  
002926  1               ;length=4
002926  1               LNG4
002926  1  50 45 45 4B          .BYTE   "PEEKPOKE"
00292A  1  50 4F 4B 45  
00292E  1  54 48 45 4E          .BYTE   "THENREADGOTOELSENEXTSTOPDATA"
002932  1  52 45 41 44  
002936  1  47 4F 54 4F  
00294A  1  46 49 4C 45          .BYTE   "FILECHR$MID$STEPSTR$CALLSINH"
00294E  1  43 48 52 24  
002952  1  4D 49 44 24  
002966  1               ;length=5
002966  1               LNG5
002966  1  50 52 49 4E          .BYTE   "PRINTINPUTGOSUBCLOSELEFT$"
00296A  1  54 49 4E 50  
00296E  1  55 54 47 4F  
00297F  1               ;length=6
00297F  1               LNG6
00297F  1  52 45 54 55          .BYTE   "RETURNRIGHT$REMARK"
002983  1  52 4E 52 49  
002987  1  47 48 54 24  
002991  1               ;length=7
002991  1               LNG7
002991  1  52 45 53 54          .BYTE   "RESTORE"
002995  1  4F 52 45     
002998  1               ;length=9
002998  1               LNG9
002998  1  52 41 4E 44          .BYTE   "RANDOMIZE"
00299C  1  4F 4D 49 5A  
0029A0  1  45           
0029A1  1               ;token table
0029A1  1               ;this table must be ordered in the same order as the reserved word table.  the
0029A1  1               ;first entry does not correspond to any valid token.
0029A1  1               TK
0029A1  1  00                   .BYTE   0
0029A2  1               ;length=1
0029A2  1  17 01 02 03          .BYTE   TCR,LESST,LPARN,TPLUS,ASTRK,RPARN,TMINUS,COMMA,EQUAL,SLASH
0029A6  1  04 05 07 09  
0029AA  1  0D 08        
0029AC  1  06 0A 0B 0C          .BYTE   SCOLN,GTRT,TCOLIN,POUND,EXPON
0029B0  1  0E           
0029B1  1               ;length=2
0029B1  1  11 16 10 14          .BYTE   TIF,TTO,TGO,TON,TOR,EQUAL,LESST,GTRT,TLEQ,TGEQ,TNE
0029B5  1  15 0D 01 0A  
0029B9  1  12 0F 13     
0029BC  1               ;length=3
0029BC  1  1C 1D 00 1A          .BYTE   TFOR,TLET,TREM,TDIM,TDEF,TNOT,TAND,72,69,70,73,74,78,84,76,71
0029C0  1  19 1E 18 48  
0029C4  1  45 46 49 4A  
0029CC  1  41 4B 42 1B          .BYTE   65,75,66,TEND,79,67,68,81,88,TXOR,TSUB
0029D0  1  4F 43 44 51  
0029D4  1  58 21 20     
0029D7  1               ;length=4
0029D7  1  50 1F                .BYTE   80,TOUT
0029D9  1  29 26 24 22          .BYTE   TTHEN,TREAD,TGOTO,TELSE,TNEXT,TSTOP,TDATA,TFILE,82,85,TSTEP
0029DD  1  25 28 63 23  
0029E1  1  52 55 27     
0029E4  1  57 59 5A             .BYTE   87,89,90
0029E7  1               ;length=5
0029E7  1  2D 2C 2B 2A          .BYTE   TPRNT,TINPT,TGOSB,TCLOS,83
0029EB  1  53           
0029EC  1               ;length=6
0029EC  1  2E 56 00             .BYTE   TRETN,86,TREM
0029EF  1               ;length=7
0029EF  1  30                   .BYTE   TREST
0029F0  1               ;length=9
0029F0  1  33                   .BYTE   TIRN
0029F1  1               ;token offset table
0029F1  1               OFFSET
0029F1  1  00 00 0F 25          .BYTE   0,0,15,37,118,182,207,225,232,232
0029F5  1  76 B6 CF E1  
0029F9  1  E8 E8        
0029FB  1               ;reserved word count table
0029FB  1               ;each entry is the number of reserved words of the associated length (0 and up)
0029FB  1               COUNT
0029FB  1  00 0F 0B 1B          .BYTE   0,15,11,27,16,5,3,1,0,1
0029FF  1  10 05 03 01  
002A03  1  00 01        
002A05  1               ;each entry is the index into the token table for the first token of the
002A05  1               ;associated length (0 and up)
002A05  1               TKOS
002A05  1  00 00 0F 1A          .BYTE   0,0,15,26,53,69,74,77,78,78
002A09  1  35 45 4A 4D  
002A0D  1  4E 4E        
002A0F  1               ;
002A0F  1               ST
002A0F  1  01 01 00 01          .BYTE   1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,5,65,70,5,71,70,65,5,1,1
002A13  1  01 01 01 01  
002A17  1  01 01 01 00  
002A29  1               ;error messages
002A29  1               ERM0
002A29  1  44 55 50 4C          .BYTE   "DUPLICATE LABELS OR "
002A2D  1  49 43 41 54  
002A31  1  45 20 4C 41  
002A3D  1  53 59 4E 43          .BYTE   "SYNCHRONIZATION ERROR$"
002A41  1  48 52 4F 4E  
002A45  1  49 5A 41 54  
002A53  1               ERM1
002A53  1  49 44 45 4E          .BYTE   "IDENTIFIER IN DIM "
002A57  1  54 49 46 49  
002A5B  1  45 52 20 49  
002A65  1  50 52 45 56          .BYTE   "PREVIOUSLY DEFINED$"
002A69  1  49 4F 55 53  
002A6D  1  4C 59 20 44  
002A78  1               ERM2
002A78  1  50 52 45 44          .BYTE   "PREDEFINED FUNCTION "
002A7C  1  45 46 49 4E  
002A80  1  45 44 20 46  
002A8C  1  4E 41 4D 45          .BYTE   "NAME PREVIOUSLY DEFINED$"
002A90  1  20 50 52 45  
002A94  1  56 49 4F 55  
002AA4  1               ERM3
002AA4  1  46 4F 52 20          .BYTE   "FOR LOOP INDEX NOT SIMPLE"
002AA8  1  4C 4F 4F 50  
002AAC  1  20 49 4E 44  
002ABD  1  20 46 4C 4F          .BYTE   " FLOATING POINT VARIABLE$"
002AC1  1  41 54 49 4E  
002AC5  1  47 20 50 4F  
002AD6  1               ERM4
002AD6  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF PARAMETERS"
002ADA  1  52 52 45 43  
002ADE  1  54 20 4E 55  
002AF4  1  20 49 4E 20          .BYTE   " IN FUNCTION REFERENCE$"
002AF8  1  46 55 4E 43  
002AFC  1  54 49 4F 4E  
002B0B  1               ERM5
002B0B  1  49 4E 56 41          .BYTE   "INVALID PARAMETER TYPE IN "
002B0F  1  4C 49 44 20  
002B13  1  50 41 52 41  
002B25  1  46 55 4E 43          .BYTE   "FUNCTION REFERENCE$"
002B29  1  54 49 4F 4E  
002B2D  1  20 52 45 46  
002B38  1               ERM6
002B38  1  55 4E 44 45          .BYTE   "UNDEFINED FUNCTION$"
002B3C  1  46 49 4E 45  
002B40  1  44 20 46 55  
002B4B  1               ERM7
002B4B  1  49 4E 56 41          .BYTE   "INVALID CHARACTER$"
002B4F  1  4C 49 44 20  
002B53  1  43 48 41 52  
002B5D  1               ERM8
002B5D  1  45 58 50 52          .BYTE   "EXPRESSION IN IF STATEMENT"
002B61  1  45 53 53 49  
002B65  1  4F 4E 20 49  
002B77  1  20 4E 4F 54          .BYTE   " NOT FLOATING POINT$"
002B7B  1  20 46 4C 4F  
002B7F  1  41 54 49 4E  
002B8B  1               ERM9
002B8B  1  49 4C 4C 45          .BYTE   "ILLEGAL FLOATING POINT FORMAT$"
002B8F  1  47 41 4C 20  
002B93  1  46 4C 4F 41  
002BA9  1               ERM10
002BA9  1  53 55 42 53          .BYTE   "SUBSCRIPTED VARIABLE NOT "
002BAD  1  43 52 49 50  
002BB1  1  54 45 44 20  
002BC2  1  50 52 45 56          .BYTE   "PREVIOUSLY DIMENSIONED$"
002BC6  1  49 4F 55 53  
002BCA  1  4C 59 20 44  
002BD9  1               ERM11
002BD9  1  41 52 52 41          .BYTE   "ARRAY NAME USED AS SIMPLE"
002BDD  1  59 20 4E 41  
002BE1  1  4D 45 20 55  
002BF2  1  20 56 41 52          .BYTE   " VARAIBLE$"
002BF6  1  41 49 42 4C  
002BFA  1  45 24        
002BFC  1               ERM12
002BFC  1  53 54 52 49          .BYTE   "STRING EXPRESSION NOT ALLOWED$"
002C00  1  4E 47 20 45  
002C04  1  58 50 52 45  
002C1A  1               ERM13
002C1A  1  4D 49 58 45          .BYTE   "MIXED MODE (STRING - FLOATING)"
002C1E  1  44 20 4D 4F  
002C22  1  44 45 20 28  
002C38  1  20 45 58 50          .BYTE   " EXPRESSION$"
002C3C  1  52 45 53 53  
002C40  1  49 4F 4E 24  
002C44  1               ERM14
002C44  1  4E 45 58 54          .BYTE   "NEXT VARIABLE DOES NOT "
002C48  1  20 56 41 52  
002C4C  1  49 41 42 4C  
002C5B  1  4D 41 54 43          .BYTE   "MATCH FOR$"
002C5F  1  48 20 46 4F  
002C63  1  52 24        
002C65  1               ERM15
002C65  1  4E 4F 20 50          .BYTE   "NO PRODUCTION EXISTS$"
002C69  1  52 4F 44 55  
002C6D  1  43 54 49 4F  
002C7A  1               ERM16
002C7A  1  4E 45 58 54          .BYTE   "NEXT STATEMENT WITHOUT "
002C7E  1  20 53 54 41  
002C82  1  54 45 4D 45  
002C91  1  4D 41 54 43          .BYTE   "MATCHING FOR$"
002C95  1  48 49 4E 47  
002C99  1  20 46 4F 52  
002C9E  1               ERM17
002C9E  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF "
002CA2  1  52 52 45 43  
002CA6  1  54 20 4E 55  
002CB2  1  53 55 42 53          .BYTE   "SUBSCRIPTS$"
002CB6  1  43 52 49 50  
002CBA  1  54 53 24     
002CBD  1               ERM18
002CBD  1  43 4F 4D 50          .BYTE   "COMPILER STACK OVERFLOW$"
002CC1  1  49 4C 45 52  
002CC5  1  20 53 54 41  
002CD5  1               ERM19
002CD5  1  53 59 4D 42          .BYTE   "SYMBOL TABLE OVERFLOW$"
002CD9  1  4F 4C 20 54  
002CDD  1  41 42 4C 45  
002CEB  1               ERM20
002CEB  1  55 4E 44 45          .BYTE   "UNDEFINED LABEL$"
002CEF  1  46 49 4E 45  
002CF3  1  44 20 4C 41  
002CFB  1               ERM21
002CFB  1  56 41 52 43          .BYTE   "VARC TABLE OVERFLOW$"
002CFF  1  20 54 41 42  
002D03  1  4C 45 20 4F  
002D0F  1               ERM22
002D0F  1  55 4E 54 45          .BYTE   "UNTERMINATED STRING$"
002D13  1  52 4D 49 4E  
002D17  1  41 54 45 44  
002D23  1               ERM23
002D23  1  49 4E 56 41          .BYTE   "INVALID TYPE IN FILE"
002D27  1  4C 49 44 20  
002D2B  1  54 59 50 45  
002D37  1  20 49 44 45          .BYTE   " IDENTIFIER$"
002D3B  1  4E 54 49 46  
002D3F  1  49 45 52 24  
002D43  1               ERM24
002D43  1  46 4F 52 20          .BYTE   "FOR WITHOUT MATCHING NEXT$"
002D47  1  57 49 54 48  
002D4B  1  4F 55 54 20  
002D5D  1               ;error message table
002D5D  1               ERMTBL
002D5D  1  29 2A 53 2A          .WORD   ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
002D61  1  78 2A A4 2A  
002D65  1  D6 2A 0B 2B  
002D6D  1  5D 2B 8B 2B          .WORD   ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
002D71  1  A9 2B D9 2B  
002D75  1  FC 2B 1A 2C  
002D7D  1  7A 2C 9E 2C          .WORD   ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
002D81  1  BD 2C D5 2C  
002D85  1  EB 2C FB 2C  
002D8D  1  43 2D                .WORD   ERM24
002D8F  1               ;messages and strings
002D8F  1               PRDMSG
002D8F  1  50 52 4F 44          .BYTE   "PROD $"
002D93  1  20 24        
002D95  1               ERDMSG
002D95  1  20 45 52 52          .BYTE   " ERRORS DETECTED$"
002D99  1  4F 52 53 20  
002D9D  1  44 45 54 45  
002DA6  1               DEMSG
002DA6  1  44 49 53 4B          .BYTE   "DISK ERROR - ABORTING $"
002DAA  1  20 45 52 52  
002DAE  1  4F 52 20 2D  
002DBD  1               BASSTR
002DBD  1  42 41 53             .BYTE   "BAS"
002DC0  1               NSMSG
002DC0  1  4E 4F 20 53          .BYTE   "NO SOURCE - ABORTING $"
002DC4  1  4F 55 52 43  
002DC8  1  45 20 2D 20  
002DD6  1               ADDEND
002DD6  1  45 4E 44 0D          .BYTE   "END",CR,LF
002DDA  1  0A           
002DDB  1               OPNMSG
002DDB  1  42 41 53 49          .BYTE   "BASIC-E/65 COMPILER - "
002DDF  1  43 2D 45 2F  
002DE3  1  36 35 20 43  
002DF1  1  56 45 52 53          .BYTE   "VERSION 2.03-A$"
002DF5  1  49 4F 4E 20  
002DF9  1  32 2E 30 33  
002E00  1               ;variables - this area holds data moved from page zero to save page zero space
002E00  1               PASS1
002E00  1  00                   .BYTE   0               ;pass 1 if true i=TRUE
002E01  1               PASS2
002E01  1  00                   .BYTE   0               ;pass 2 if true
002E02  1               LSTPRD
002E02  1  00                   .BYTE   0               ;list production if true (listprod)
002E03  1               LSTSRC
002E03  1  00                   .BYTE   0               ;list source if true (listsource)
002E04  1               DEBUGL
002E04  1  00                   .BYTE   0               ;debug line numbers if true (debugln)
002E05  1               LWRUPR
002E05  1  00                   .BYTE   0               ;convert if true i=TRUE (lowertoupper)
002E06  1               NINTFL
002E06  1  00                   .BYTE   0               ;no .INT file if true (nointfile)
002E07  1               LSTFLG
002E07  1  00                   .BYTE   0               ;list device if false (lstflag)
002E08  1               EOLSTS
002E08  1  00                   .BYTE   0               ;flag that eol (cr) read by scan
002E09  1               CMPLNG
002E09  1  00                   .BYTE   0               ;compiling if true (compiling)
002E0A  1               FORSTM
002E0A  1  00                   .BYTE   0               ;for statement flag (forstmt)
002E0B  1               FILEIO
002E0B  1  00                   .BYTE   0               ;file i/o flag
002E0C  1               ;next variable is never read or tested - need to check need
002E0C  1               RNDFLE
002E0C  1  00                   .BYTE   0               ;random file flag (randomfile)
002E0D  1               ;fcbs and similar
002E0D  1               WFCB
002E0D  1  xx xx xx xx          .RES    9
002E11  1  xx xx xx xx  
002E15  1  xx           
002E16  1  49 4E 54             .BYTE   "INT"
002E19  1  xx xx xx xx          .RES    21
002E1D  1  xx xx xx xx  
002E21  1  xx xx xx xx  
002E2E  1               PRMLST
002E2E  1  20 20 20 20          .BYTE   "         "
002E32  1  20 20 20 20  
002E36  1  20           
002E37  1               ;parser data tables
002E37  1               IFLBLN
002E37  1  02                   .BYTE   2
002E38  1               IFLAB2
002E38  1  17                   .BYTE   23
002E39  1               IFLABL
002E39  1  00                   .BYTE   0
002E3A  1               HSHTBL
002E3A  1  xx xx xx xx          .RES    HSHTSZ*2
002E3E  1  xx xx xx xx  
002E42  1  xx xx xx xx  
002EBA  1               HASH
002EBA  1  xx xx xx xx          .RES    PSTKSZ
002EBE  1  xx xx xx xx  
002EC2  1  xx xx xx xx  
002EDA  1               VAR
002EDA  1  xx xx xx xx          .RES    PSTKSZ
002EDE  1  xx xx xx xx  
002EE2  1  xx xx xx xx  
002EFA  1               TYPE
002EFA  1  xx xx xx xx          .RES    PSTKSZ
002EFE  1  xx xx xx xx  
002F02  1  xx xx xx xx  
002F1A  1               STYPE
002F1A  1  xx xx xx xx          .RES    PSTKSZ
002F1E  1  xx xx xx xx  
002F22  1  xx xx xx xx  
002F3A  1               SRLOC
002F3A  1  xx xx xx xx          .RES    PSTKSZ*2
002F3E  1  xx xx xx xx  
002F42  1  xx xx xx xx  
002F7A  1               SYMLOC
002F7A  1  xx xx xx xx          .RES    PSTKSZ*2
002F7E  1  xx xx xx xx  
002F82  1  xx xx xx xx  
002FBA  1               STSTAK
002FBA  1  xx xx xx xx          .RES    PSTKSZ*2
002FBE  1  xx xx xx xx  
002FC2  1  xx xx xx xx  
002FFA  1               VARC
002FFA  1  xx xx xx xx          .RES    VARCSZ
002FFE  1  xx xx xx xx  
003002  1  xx xx xx xx  
00305E  1               ONSTAK
00305E  1  xx xx xx xx          .RES    MAXOCT
003062  1  xx xx xx xx  
003066  1  xx xx xx xx  
00306D  1               ONSP            = ONSTAK
00306D  1               ;buffers
00306D  1               INPBUF
00306D  1  xx xx xx xx          .RES    SRCRSZ
003071  1  xx xx xx xx  
003075  1  xx xx xx xx  
0030ED  1               OUTBUF
0030ED  1  xx xx xx xx          .RES    INTRSZ
0030F1  1  xx xx xx xx  
0030F5  1  xx xx xx xx  
00316D  1               CONBUF
00316D  1  xx xx xx xx          .RES    CBUFSZ+2
003171  1  xx xx xx xx  
003175  1  xx xx xx xx  
0031C1  1               ;start of free memory
0031C1  1               MEMORY
0031C1  1                       .END
