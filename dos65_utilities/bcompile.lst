ca65 V2.18 - Ubuntu 2.19-1
Main file   : compl203.asm
Current file: compl203.asm

000000r 1               ;COMPILE
000000r 1               ;BASIC-E/65 Compiler
000000r 1               ;Version 2.03-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;released:	18 october 1982
000000r 1               ;last revision:
000000r 1               ;	24 december 1983
000000r 1               ;		added chkule for prod 5
000000r 1               ;		modified error to print line
000000r 1               ;		added code to set seprtr
000000r 1               ;	12 january 1984
000000r 1               ;		deleted error0 bit and branch
000000r 1               ;		fixed first blank line list for $b option
000000r 1               ;		fixed buffer overwrite on error
000000r 1               ;	4 april 2008
000000r 1               ;		reformatted for ASM211 & TASM
000000r 1               ;		eliminated page zero 0 & 1
000000r 1               ;		moved some variables from page zero
000000r 1               ;A translation of Gordon Eubanks BASIC-E to operate under DOS/65.  This is a
000000r 1               ;compile-interpret systems invoked against a source file of type .BAS.  The
000000r 1               ;compiler produces an intermediate code file of type .INT which is executed
000000r 1               ;by the program RUN.
000000r 1               ;external references
000000r 1               BOOT            = $100          ;boot entry
000000r 1               PEM             = $103          ;pem entry
000000r 1               FCB             = $107          ;default fcb
000000r 1               TEA             = $800          ;load address
000000r 1               ;fixed parameters and constants
000000r 1               ;CAUTION: When a register is set to TRUE, Z is set to 0 (i.e. NE).  If a
000000r 1               ;register is set to FALSE then Z is set to 1 (i.e. EQ).
000000r 1               TRUE            = $FF
000000r 1               FALSE           = 0
000000r 1               ;ascii characters
000000r 1               TAB             = 9             ;tab
000000r 1               LF              = 10            ;linefeed
000000r 1               CR              = 13            ;return and eol
000000r 1               EOF             = 26            ;eof char
000000r 1               SPACE           = 32            ;ascii blank
000000r 1               semico          = 59            ;semicolon
000000r 1               backsl          = 92            ;backslash
000000r 1               ;other
000000r 1               IDNTSZ          = 32            ;max identifier size + 1
000000r 1               VARCSZ          = 100           ;varc stack size
000000r 1               PSTKSZ          = 32            ;parse stack size
000000r 1               SRCRSZ          = 128           ;source file record size
000000r 1               INTRSZ          = 128           ;int file record size
000000r 1               CBUFSZ          = 82            ;console buffer size
000000r 1               HSHTSZ          = 64            ;hash table size
000000r 1               HSHMSK          = HSHTSZ-1      ;hashing mask
000000r 1               MAXOCT          = 15            ;max number on statements
000000r 1               MAXRWL          = 9             ;max reserved word length
000000r 1               MAXRNO          = 120           ;max read count
000000r 1               MAXLNO          = 175           ;max look count
000000r 1               MAXPNO          = 189           ;max push count
000000r 1               MAXSNO          = 341           ;max state count
000000r 1               STARTS          = 121           ;start state
000000r 1               PRODNO          = 152           ;number productions
000000r 1               SIMVAR          = 0
000000r 1               SUBVAR          = 2
000000r 1               CONST           = 4
000000r 1               LABLE           = 8
000000r 1               UNFUNC          = $A
000000r 1               ;mnemonics for basic-e machine
000000r 1               FAD             = 0
000000r 1               FMI             = 1
000000r 1               FMU             = 2
000000r 1               FDI             = 3
000000r 1               EXP             = 4
000000r 1               LSS             = 5
000000r 1               GTR             = 6
000000r 1               EQU             = 7
000000r 1               NEQ             = 8
000000r 1               GEQ             = 9
000000r 1               LEQ             = 10
000000r 1               NOT             = 11
000000r 1               ANDO            = 12
000000r 1               BOR             = 13
000000r 1               LOD             = 14
000000r 1               STO             = 15
000000r 1               XIT             = 16
000000r 1               DEL             = 17
000000r 1               DUP             = 18
000000r 1               XCH             = 19
000000r 1               STD             = 20
000000r 1               SLT             = 21
000000r 1               SGT             = 22
000000r 1               SEQ             = 23
000000r 1               SNE             = 24
000000r 1               SGE             = 25
000000r 1               SLE             = 26
000000r 1               STS             = 27
000000r 1               ILS             = 28
000000r 1               CAT             = 29
000000r 1               PRO             = 30
000000r 1               RTN             = 31
000000r 1               ROW             = 32
000000r 1               SUB             = 33
000000r 1               RDV             = 34
000000r 1               WRV             = 35
000000r 1               WST             = 36
000000r 1               RDF             = 37
000000r 1               RDB             = 38
000000r 1               ECR             = 39
000000r 1               POT             = 40
000000r 1               WRB             = 40
000000r 1               RDN             = 41
000000r 1               RDS             = 42
000000r 1               WRN             = 43
000000r 1               WRS             = 44
000000r 1               OPN             = 45
000000r 1               CON             = 46
000000r 1               RST             = 47
000000r 1               NEG             = 48
000000r 1               RES             = 49
000000r 1               NOPO            = 50
000000r 1               DAT             = 51
000000r 1               DBF             = 52
000000r 1               NSP             = 53
000000r 1               BRS             = 54
000000r 1               BRC             = 55
000000r 1               BFC             = 56
000000r 1               BFN             = 57
000000r 1               CVB             = 58
000000r 1               RCN             = 59
000000r 1               DRS             = 60
000000r 1               DRF             = 61
000000r 1               EDR             = 62
000000r 1               EDW             = 63
000000r 1               CLS             = 64
000000r 1               IRN             = 77
000000r 1               RON             = 91
000000r 1               CKO             = 92
000000r 1               EXR             = 93
000000r 1               DEF             = 94
000000r 1               BOL             = 95
000000r 1               ADJ             = 96
000000r 1               ;token definitions
000000r 1               POUND           = 12
000000r 1               ASTRK           = 4
000000r 1               LESST           = 1
000000r 1               EXPON           = 14
000000r 1               TDATA           = 99
000000r 1               TELSE           = 34
000000r 1               TFOR            = 28
000000r 1               TIF             = 17
000000r 1               TNEXT           = 37
000000r 1               SLASH           = 8
000000r 1               TOR             = 21
000000r 1               TREST           = 48
000000r 1               TSTOP           = 40
000000r 1               FUNCT           = 53
000000r 1               TLEQ            = 18
000000r 1               TNE             = 19
000000r 1               TOUT            = 31
000000r 1               IDENT           = 52
000000r 1               UDFUNC          = 54
000000r 1               LPARN           = 2
000000r 1               TPLUS           = 3
000000r 1               TCOLIN          = 11
000000r 1               EQUAL           = 13
000000r 1               TAND            = 24
000000r 1               TDEF            = 25
000000r 1               TEND            = 27
000000r 1               TGOSB           = 43
000000r 1               TINPT           = 44
000000r 1               TNOT            = 30
000000r 1               TPRNT           = 45
000000r 1               TRETN           = 46
000000r 1               TTHEN           = 41
000000r 1               TGEQ            = 15
000000r 1               COMMA           = 9
000000r 1               TCLOS           = 42
000000r 1               TIRN            = 51
000000r 1               RPARN           = 5
000000r 1               TMINUS          = 7
000000r 1               SCOLN           = 6
000000r 1               GTRT            = 10
000000r 1               TCR             = 23
000000r 1               TDIM            = 26
000000r 1               TFILE           = 35
000000r 1               TGOTO           = 36
000000r 1               TLET            = 29
000000r 1               TON             = 20
000000r 1               TREAD           = 38
000000r 1               TSTEP           = 39
000000r 1               TTO             = 22
000000r 1               TSUB            = 32
000000r 1               TGO             = 16
000000r 1               TXOR            = 33
000000r 1               STRING          = 50
000000r 1               FLOTPT          = 49
000000r 1               TREM            = 0
000000r 1               ;page zero variables
000000r 1               ;all non-zero initial values are shown as i=xxxx where xxxx is the initial
000000r 1               ;value. PL/M name is shown if significantly different.
000000r 1               GPIND           = $02+$40       ;INDEX IN GETCHR
000000r 1               ERRCNT          = $03+$40       ;ERROR COUNT (ERRORCOUNT)
000000r 1               DATACT          = $05+$40       ;COUNT DATA AREA SIZE
000000r 1               INPSTM          = $07+$40       ;(INPUTSTMT)
000000r 1               GSBSTM          = $08+$40       ;(GOSUBSTMT)
000000r 1               TOKEN           = $09+$40       ;TYPE OF TOKEN
000000r 1               SUBTYP          = $0A+$40       ;SUBTYPE OF TOKEN (SUBTYPE)
000000r 1               FUNCOP          = $0B+$40       ;FUNCTION NUMBER IF FUNCTION
000000r 1               HSHCDE          = $0C+$40       ;HASH OF CURRENT TOKEN (HASHCODE)
000000r 1               NXTCHR          = $0D+$40       ;CURRENT CHAR FROM GETCHR (NEXTCHAR)
000000r 1               ACCUM           = $0E+$40       ;CURRENT TOKEN
000000r 1               ACCLEN          = ACCUM         ;LENGTH IS FIRST BYTE
000000r 1               CONT            = $2E+$40       ;ACCUM FULL FLAG
000000r 1               COLUMN          = $2F+$40       ;CURRENT COLUMN
000000r 1               LINENO          = $30+$40       ;CURRENT LINE NUMBER
000000r 1               OUTIND          = $32+$40       ;INT BUFFER INDEX (BUFFPTR)
000000r 1               LENGTH          = $33+$40       ;OUTPUT LINE LENGTH
000000r 1               SEPRTR          = $34+$40       ;SEPARATOR I=':'
000000r 1               SRCIND          = $35+$40       ;SOURCE INDEX I=SRCRSZ (SOURCEPTR)
000000r 1               LNEPTR          = $36+$40       ;LINE POINTER
000000r 1               POINTR          = $37+$40       ;POINTER IN ERROR
000000r 1               ERRCDE          = $38+$40       ;COMPILER ERROR CODE
000000r 1               STATE           = $39+$40       ;STATE
000000r 1               SP              = $3B+$40       ;STACK POINTER
000000r 1               MP              = $3C+$40       ;
000000r 1               MPP1            = $3D+$40       ;MP + 1
000000r 1               NOLOOK          = $3E+$40       ;
000000r 1               VARIND          = $3F+$40       ;INDEX INTO VAR
000000r 1               TYPESP          = $40+$40       ;GROUP OF
000000r 1               TYPEM1          = $41+$40       ;VARIABLES
000000r 1               TYPEMP          = $42+$40       ;TO HOLD
000000r 1               STYPSP          = $43+$40       ;PARSER STACK
000000r 1               STYPM1          = $44+$40       ;CONTENTS
000000r 1               STYPMP          = $45+$40       ;DURING
000000r 1               SYMLSP          = $46+$40       ;ACTION
000000r 1               SYMLM1          = $48+$40       ;OF SYNTHESIZE
000000r 1               SYMLMP          = $4A+$40       ;IN
000000r 1               HASHSP          = $4C+$40       ;ORDER TO
000000r 1               HASHM1          = $4D+$40       ;REDUCE
000000r 1               HASHMP          = $4E+$40       ;THE AMOUNT
000000r 1               SRLOSP          = $4F+$40       ;OF INDEXING
000000r 1               SRLOMP          = $51+$40       ;IN SYNTHE
000000r 1               DECOUT          = $53+$40       ;DECIMAL WORD
000000r 1               LZFLAG          = $55+$40       ;LEADING ZERO FLAG IN PRNDEC
000000r 1               FIELD           = $56+$40       ;POINTER IN COMPARE
000000r 1               I               = $58+$40       ;PARSER VAR
000000r 1               J               = $5A+$40       ;SAME
000000r 1               K               = $5C+$40       ;EVEN MORE
000000r 1               INDEX           = $5E+$40       ;
000000r 1               I2              = $5F+$40       ;I*2 AND WORD POINTER
000000r 1               IC              = $61+$40       ;INDEX IN COMPAR
000000r 1               PTR             = $62+$40       ;POINTER IN LOOKUP AND COMPAR
000000r 1               IL              = $64+$40       ;INDEX IN LOOKUP
000000r 1               SBTTOP          = $65+$40       ;TOP OF FOR/NEXT STACK
000000r 1               BASE            = $67+$40       ;BASE OF CURRENT ENTRY
000000r 1               FORCNT          = $69+$40       ;FOR COUNT
000000r 1               SBTBL           = $6A+$40       ;TOP OF SYMBOL TABLE
000000r 1               APTADD          = $6C+$40       ;UTILITY VAR TO ACCESS TABLE
000000r 1               PRTCT           = $6E+$40       ;COUNT PRT ENTRIES
000000r 1               FDACT           = $70+$40       ;COUNT FDA ENTRIES
000000r 1               CODESI          = $72+$40       ;COUNT SIZE OF CODE AREA
000000r 1               ULERFL          = $74+$40       ;
000000r 1               PRNTNM          = $75+$40       ;POINTER SET BEFORE SLOOKU OR ENTER
000000r 1               SYMHSH          = $77+$40       ;HASH OF TOKEN REFERENCE
000000r 1               PRODCT          = $78+$40       ;PRODUCTION NUMBER (0 TO PRODNO)
000000r 1               NXSTPT          = $79+$40       ;NEXT STATEMENT POINTER
000000r 1               TMPHSH          = $7B+$40       ;LOCAL HASH IN GETHSH
000000r 1               TMPPTR          = $7C+$40       ;LOCAL PTR IN GETHSH
000000r 1               LEN             = $7D+$40       ;TEMP IN SLOOKU
000000r 1               NUMPRM          = $7E+$40       ;TEMP IN UNLINK/RELINK
000000r 1               LINKI           = $7F+$40       ;TEMP IN UNLINK/RELINK
000000r 1               TMPADR          = $80+$40       ;TEMP IN UNLINK/RELINK
000000r 1               WHERE           = $82+$40       ;TEMP IN GENILS
000000r 1               STRPTR          = $84+$40       ;TEMP IN GINILS
000000r 1               IGEN            = $85+$40       ;TEMP IN GENCON
000000r 1               LZ              = $86+$40       ;
000000r 1               
000000r 1               ;entry point
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1  4C BA 1C             JMP     MAIN
000803  1               ;copyright notice
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT - RICHARD"
000807  1  52 49 47 48  
00080B  1  54 20 2D 20  
000816  1  20 41 2E 20          .BYTE   " A. LEARY - 2008"
00081A  1  4C 45 41 52  
00081E  1  59 20 2D 20  
000826  1               ;SUBROUTINES
000826  1               ;subroutine to point to source fcb and go to pem
000826  1               RFCBX
000826  1  A9 07                LDA     #<FCB           ;point
000828  1  A0 01                LDY     #>FCB           ;to fcb
00082A  1  4C 03 01             JMP     PEM             ;and go
00082D  1               ;point to int fcb and go to pem
00082D  1               WFCBX
00082D  1  A9 0A                LDA     #<WFCB          ;point
00082F  1  A0 2E                LDY     #>WFCB          ;to fcb
000831  1  4C 03 01             JMP     PEM             ;and go
000834  1               ;send cr and lf to console/list
000834  1               CRLF
000834  1  A9 0D                LDA     #CR             ;get
000836  1  20 4F 08             JSR     PRNCHR          ;a cr
000839  1  A9 0A                LDA     #LF             ;and
00083B  1  4C 4F 08             JMP     PRNCHR          ;then a lf
00083E  1               ;output char in A to console or list device as a function of LSTFLG
00083E  1               SPCOUT
00083E  1  A9 20                LDA     #SPACE          ;get space
000840  1               CHROUT
000840  1  2C 04 2E             BIT     LSTFLG          ;test flag
000843  1  30 05                BMI     *+7             ;use list if set
000845  1  A2 02                LDX     #2              ;else set
000847  1  4C 03 01             JMP     PEM             ;and do console
00084A  1  A2 05                LDX     #5              ;set list
00084C  1  4C 03 01             JMP     PEM             ;and do
00084F  1               ;print char in A and handle tabs and linefeeds
00084F  1               PRNCHR
00084F  1  C9 09                CMP     #TAB            ;see if tab
000851  1  D0 0C                BNE     NOTTAB          ;branch if not
000853  1               TABOVR
000853  1  20 3E 08             JSR     SPCOUT          ;send a space
000856  1  E6 6F                INC     COLUMN          ;bump column
000858  1  A5 6F                LDA     COLUMN          ;get it
00085A  1  29 07                AND     #7              ;see if mod 8
00085C  1  D0 F5                BNE     TABOVR          ;loop if not
00085E  1  60                   RTS                     ;else done
00085F  1               NOTTAB
00085F  1  48                   PHA                     ;save char
000860  1  20 40 08             JSR     CHROUT          ;send it
000863  1  E6 6F                INC     COLUMN          ;bump column
000865  1  68                   PLA                     ;get char
000866  1  C9 0A                CMP     #LF             ;if a lf
000868  1  F0 01                BEQ     *+3             ;then branch
00086A  1  60                   RTS                     ;else done
00086B  1  A9 00                LDA     #0              ;clear column
00086D  1  85 6F                STA     COLUMN          ;and then
00086F  1  60                   RTS                     ;done
000870  1               ;convert AY to decimal number and print on console
000870  1               PRNDEC
000870  1  85 93                STA     DECOUT          ;save
000872  1  84 94                STY     DECOUT+1        ;value
000874  1  A9 00                LDA     #FALSE          ;set flag
000876  1  85 95                STA     LZFLAG          ;to false
000878  1  A2 2F                LDX     #'0'-1          ;set digit to '0' - 1
00087A  1  38                   SEC                     ;now
00087B  1               P10000
00087B  1  A5 93                LDA     DECOUT          ;subtract
00087D  1  E9 10                SBC     #<10000         ;10000
00087F  1  85 93                STA     DECOUT          ;from
000881  1  A5 94                LDA     DECOUT+1        ;value
000883  1  E9 27                SBC     #>10000         ;and
000885  1  85 94                STA     DECOUT+1        ;save
000887  1  E8                   INX                     ;bump digit
000888  1  B0 F1                BCS     P10000          ;loop if no borrow
00088A  1  A5 93                LDA     DECOUT          ;else
00088C  1  69 10                ADC     #<10000         ;add
00088E  1  85 93                STA     DECOUT          ;10000
000890  1  A5 94                LDA     DECOUT+1        ;back
000892  1  69 27                ADC     #>10000         ;in to
000894  1  85 94                STA     DECOUT+1        ;correct
000896  1  20 E6 08             JSR     DIGOUT          ;send digit
000899  1               P1000
000899  1  A5 93                LDA     DECOUT          ;now
00089B  1  E9 E8                SBC     #<1000          ;drop
00089D  1  85 93                STA     DECOUT          ;by
00089F  1  A5 94                LDA     DECOUT+1        ;1000
0008A1  1  E9 03                SBC     #>1000          ;until
0008A3  1  85 94                STA     DECOUT+1        ;a borrow
0008A5  1  E8                   INX                     ;bump digit
0008A6  1  B0 F1                BCS     P1000           ;loop if more
0008A8  1  A5 93                LDA     DECOUT          ;now
0008AA  1  69 E8                ADC     #<1000          ;add
0008AC  1  85 93                STA     DECOUT          ;1000
0008AE  1  A5 94                LDA     DECOUT+1        ;back
0008B0  1  69 03                ADC     #>1000          ;in to
0008B2  1  85 94                STA     DECOUT+1        ;correct
0008B4  1  20 E6 08             JSR     DIGOUT          ;send 1000s
0008B7  1               P100
0008B7  1  A5 93                LDA     DECOUT          ;now
0008B9  1  E9 64                SBC     #100            ;do
0008BB  1  85 93                STA     DECOUT          ;subtract
0008BD  1  A5 94                LDA     DECOUT+1        ;for
0008BF  1  E9 00                SBC     #0              ;100
0008C1  1  85 94                STA     DECOUT+1        ;with
0008C3  1  E8                   INX                     ;digit bump
0008C4  1  B0 F1                BCS     P100            ;loop if more
0008C6  1  A5 93                LDA     DECOUT          ;else
0008C8  1  69 64                ADC     #100            ;add back
0008CA  1  85 93                STA     DECOUT          ;to correct
0008CC  1  20 E6 08             JSR     DIGOUT          ;send 100s
0008CF  1               P10
0008CF  1  A5 93                LDA     DECOUT          ;now
0008D1  1  E9 0A                SBC     #10             ;drop
0008D3  1  85 93                STA     DECOUT          ;by 10
0008D5  1  E8                   INX                     ;bump digit
0008D6  1  B0 F7                BCS     P10             ;loop if more
0008D8  1  69 0A                ADC     #10             ;correct
0008DA  1  85 93                STA     DECOUT          ;save
0008DC  1  20 E6 08             JSR     DIGOUT          ;and send 10s
0008DF  1  A9 30                LDA     #'0'            ;get zero
0008E1  1  05 93                ORA     DECOUT          ;add number
0008E3  1  4C 4F 08             JMP     PRNCHR          ;and print always
0008E6  1               ;send a single digit in X and handle leading zeros
0008E6  1               DIGOUT
0008E6  1  A9 20                LDA     #SPACE          ;preset for blank
0008E8  1  24 95                BIT     LZFLAG          ;test flag
0008EA  1  30 08                BMI     D2              ;branch if set
0008EC  1  E0 30                CPX     #'0'            ;else test current
0008EE  1  F0 05                BEQ     D3              ;branch if '0'
0008F0  1  A9 FF                LDA     #TRUE           ;else set
0008F2  1  85 95                STA     LZFLAG          ;flag
0008F4  1               D2
0008F4  1  8A                   TXA                     ;get char
0008F5  1               D3
0008F5  1  20 4F 08             JSR     PRNCHR          ;print it
0008F8  1  A2 2F                LDX     #'0'-1          ;now preset
0008FA  1  38                   SEC                     ;for next
0008FB  1  60                   RTS
0008FC  1               ;print message pointed to by AY until a $ is encountered
0008FC  1               PRNMSG
0008FC  1  8D 03 09             STA     PRN0+1          ;save message
0008FF  1  8C 04 09             STY     PRN0+2          ;address
000902  1               PRN0
000902  1  AD FF FF             LDA     $FFFF           ;get byte
000905  1  C9 24                CMP     #'$'            ;see if end
000907  1  D0 01                BNE     *+3             ;branch if not
000909  1  60                   RTS                     ;else done
00090A  1  20 4F 08             JSR     PRNCHR          ;print it
00090D  1  EE 03 09             INC     PRN0+1          ;bump low
000910  1  D0 F0                BNE     PRN0            ;loop if no carry
000912  1  EE 04 09             INC     PRN0+2          ;bump high
000915  1  4C 02 09             JMP     PRN0            ;and loop
000918  1               ;disk error exit
000918  1               DSKERR
000918  1  A9 A3                LDA     #<DEMSG         ;point to
00091A  1  A0 2D                LDY     #>DEMSG         ;message
00091C  1               DSKER0
00091C  1  20 FC 08             JSR     PRNMSG          ;print it
00091F  1  4C 00 01             JMP     BOOT            ;and boot
000922  1               ;open source file
000922  1               OPNSRC
000922  1  A2 03                LDX     #3              ;first
000924  1               OPN1
000924  1  BD B9 2D             LDA     BASSTR-1,X      ;move
000927  1  9D 0F 01             STA     FCB+8,X         ;BAS to
00092A  1  CA                   DEX                     ;type part
00092B  1  D0 F7                BNE     OPN1            ;of fcb
00092D  1  8E 13 01             STX     FCB+12          ;clear extent
000930  1  8E 14 01             STX     FCB+13
000933  1  8E 27 01             STX     FCB+32          ;and record
000936  1  A9 6A                LDA     #<INPBUF        ;point to
000938  1  A0 30                LDY     #>INPBUF        ;buffer
00093A  1  A2 1A                LDX     #26             ;and set
00093C  1  20 03 01             JSR     PEM             ;as buffer location
00093F  1  A2 0F                LDX     #15             ;open code
000941  1  20 26 08             JSR     RFCBX           ;do it
000944  1  30 01                BMI     *+3             ;branch if bad
000946  1  60                   RTS                     ;else done
000947  1  A9 BD                LDA     #<NSMSG         ;point to
000949  1  A0 2D                LDY     #>NSMSG         ;no source message
00094B  1  4C 1C 09             JMP     DSKER0          ;send and quit
00094E  1               ;close output (INT) file
00094E  1               CLSINT
00094E  1  A2 10                LDX     #16             ;close code
000950  1  20 2D 08             JSR     WFCBX           ;do it
000953  1  30 01                BMI     *+3             ;branch if bad
000955  1  60                   RTS                     ;else done
000956  1  4C 18 09             JMP     DSKERR          ;error exit
000959  1               ;set-up INT file
000959  1               SUPINT
000959  1  2C 03 2E             BIT     NINTFL          ;test no-int flag
00095C  1  10 01                BPL     *+3             ;branch if false
00095E  1  60                   RTS                     ;else done
00095F  1  A2 08                LDX     #8              ;move 9
000961  1               SUP0
000961  1  BD 07 01             LDA     FCB,X           ;char including drive
000964  1  9D 0A 2E             STA     WFCB,X          ;to write fcb
000967  1  CA                   DEX                     ;drop count
000968  1  10 F7                BPL     SUP0            ;loop if more
00096A  1  E8                   INX
00096B  1  8E 16 2E             STX     WFCB+12
00096E  1  8E 17 2E             STX     WFCB+13
000971  1  8E 2A 2E             STX     WFCB+32         ;clear extent and record
000974  1  A2 13                LDX     #19             ;now delete
000976  1  20 2D 08             JSR     WFCBX           ;it if there
000979  1  A2 16                LDX     #22             ;now try
00097B  1  20 2D 08             JSR     WFCBX           ;to create
00097E  1  10 03                BPL     *+5             ;branch if ok
000980  1  4C 18 09             JMP     DSKERR          ;else error
000983  1  60                   RTS                     ;and quit
000984  1               ;reset compiler flags
000984  1               SETFLG
000984  1  A9 00                LDA     #FALSE
000986  1  8D 09 2E             STA     RNDFLE          ;random file
000989  1  8D 08 2E             STA     FILEIO          ;file io
00098C  1  85 47                STA     INPSTM          ;input statement
00098E  1  8D 07 2E             STA     FORSTM          ;for statement
000991  1  85 48                STA     GSBSTM          ;gosub statement
000993  1  60                   RTS
000994  1               ;write INT record
000994  1               WRTINT
000994  1  2C 03 2E             BIT     NINTFL          ;test flag
000997  1  10 01                BPL     *+3             ;ok if false
000999  1  60                   RTS                     ;else done
00099A  1  A9 EA                LDA     #<OUTBUF        ;point to
00099C  1  A0 30                LDY     #>OUTBUF        ;buffer
00099E  1  A2 1A                LDX     #26             ;and set
0009A0  1  20 03 01             JSR     PEM             ;as dma
0009A3  1  A2 15                LDX     #21             ;now do
0009A5  1  20 2D 08             JSR     WFCBX           ;write op
0009A8  1  F0 03                BEQ     *+5             ;ok if zero
0009AA  1  4C 18 09             JMP     DSKERR          ;else error
0009AD  1  A9 6A                LDA     #<INPBUF        ;point back
0009AF  1  A0 30                LDY     #>INPBUF        ;to input
0009B1  1  A2 1A                LDX     #26             ;and set
0009B3  1  4C 03 01             JMP     PEM             ;as default
0009B6  1               ;emit byte in A to INT file
0009B6  1               EMIT
0009B6  1  A6 72                LDX     OUTIND          ;get index
0009B8  1  10 09                BPL     EMIT0           ;ok if < 128
0009BA  1  48                   PHA                     ;else save
0009BB  1  20 94 09             JSR     WRTINT          ;write buffer
0009BE  1  68                   PLA                     ;get byte
0009BF  1  A2 00                LDX     #0              ;now clear
0009C1  1  86 72                STX     OUTIND          ;index
0009C3  1               EMIT0
0009C3  1  E6 72                INC     OUTIND          ;bump for next
0009C5  1  9D EA 30             STA     OUTBUF,X        ;save byte
0009C8  1  60                   RTS                     ;and done
0009C9  1               ;read source file record
0009C9  1               RDESRC
0009C9  1  A2 14                LDX     #20             ;get code
0009CB  1  20 26 08             JSR     RFCBX           ;do it
0009CE  1  C9 02                CMP     #2              ;see if ok
0009D0  1  90 03                BCC     *+5             ;branch if was
0009D2  1  4C 18 09             JMP     DSKERR          ;else error
0009D5  1  60                   RTS
0009D6  1               ;clear output line buffer
0009D6  1               CLLNBF
0009D6  1  A2 51                LDX     #CBUFSZ-1       ;get length - 1
0009D8  1  A9 20                LDA     #SPACE          ;use space
0009DA  1               CLLN0
0009DA  1  9D 6A 31             STA     CONBUF,X        ;store
0009DD  1  CA                   DEX                     ;drop index
0009DE  1  E0 FF                CPX     #255            ;see if wrap
0009E0  1  D0 F8                BNE     CLLN0           ;loop if not
0009E2  1  60                   RTS
0009E3  1               ;list line of length LENGTH
0009E3  1               ;note that this routine also sets seprtr to : (just in case!!)
0009E3  1               LSTLNE
0009E3  1  A5 70                LDA     LINENO          ;get line
0009E5  1  A4 71                LDY     LINENO+1        ;number
0009E7  1  20 70 08             JSR     PRNDEC          ;print it
0009EA  1  A5 74                LDA     SEPRTR          ;then print
0009EC  1  20 4F 08             JSR     PRNCHR          ;separator
0009EF  1  A9 20                LDA     #SPACE          ;and a
0009F1  1  20 4F 08             JSR     PRNCHR          ;space
0009F4  1  A9 00                LDA     #0              ;now clear
0009F6  1  85 42                STA     GPIND           ;index
0009F8  1               LSTL0
0009F8  1  A6 42                LDX     GPIND           ;get index
0009FA  1  BD 6A 31             LDA     CONBUF,X        ;get char
0009FD  1  20 4F 08             JSR     PRNCHR          ;print it
000A00  1  E6 42                INC     GPIND           ;bump index
000A02  1  A5 42                LDA     GPIND           ;get index
000A04  1  C5 73                CMP     LENGTH          ;compare to length
000A06  1  90 F0                BCC     LSTL0           ;loop if more
000A08  1  F0 EE                BEQ     LSTL0           ;or if same
000A0A  1  20 34 08             JSR     CRLF            ;do cr and lf
000A0D  1  20 D6 09             JSR     CLLNBF          ;clear buffer
000A10  1  A9 3A                LDA     #':'            ;and set
000A12  1  85 74                STA     SEPRTR          ;separator
000A14  1  60                   RTS
000A15  1               ;set global variable NXTCHR to next source file character and return with
000A15  1               ;NXTCHR in A. Replace TAB with SPACE and if LSTSRC is TRUE or an error
000A15  1               ;occurs send the line to the console.
000A15  1               GETCHR
000A15  1  20 70 0A             JSR     CHKFLE          ;go get char
000A18  1  D0 06                BNE     GETEOF          ;branch if eof
000A1A  1  A5 4D                LDA     NXTCHR          ;get nextchar
000A1C  1  C9 1A                CMP     #EOF            ;see if eof char
000A1E  1  D0 13                BNE     NTEOF           ;branch if not
000A20  1               GETEOF
000A20  1  A2 04                LDX     #4              ;move 5
000A22  1               GETE0
000A22  1  BD D3 2D             LDA     ADDEND,X        ;from ADDEND
000A25  1  9D 6A 30             STA     INPBUF,X        ;to input buffer
000A28  1  CA                   DEX                     ;drop count
000A29  1  10 F7                BPL     GETE0           ;loop if more
000A2B  1  E8                   INX                     ;clear X
000A2C  1  86 75                STX     SRCIND          ;and then index
000A2E  1  20 6A 0A             JSR     NXTSRC          ;get next
000A31  1  85 4D                STA     NXTCHR          ;save it
000A33  1               NTEOF
000A33  1  A6 76                LDX     LNEPTR          ;get pointer
000A35  1  E0 52                CPX     #CBUFSZ         ;compare to max
000A37  1  B0 08                BCS     LTOBIG          ;branch if too big
000A39  1  E8                   INX                     ;else bump
000A3A  1  86 76                STX     LNEPTR          ;and save
000A3C  1  A5 4D                LDA     NXTCHR          ;get char
000A3E  1  9D 6A 31             STA     CONBUF,X        ;and save
000A41  1               LTOBIG
000A41  1  A5 4D                LDA     NXTCHR          ;get char
000A43  1  C9 0D                CMP     #CR             ;see if a cr
000A45  1  D0 19                BNE     NTEOL           ;branch if not
000A47  1  E6 70                INC     LINENO          ;else bump
000A49  1  D0 02                BNE     *+4             ;line
000A4B  1  E6 71                INC     LINENO+1        ;number
000A4D  1  A6 76                LDX     LNEPTR          ;get pointer
000A4F  1  CA                   DEX                     ;drop it
000A50  1  86 73                STX     LENGTH          ;put in length
000A52  1  AD 00 2E             LDA     LSTSRC          ;get flag
000A55  1  F0 03                BEQ     NOLSLN          ;branch if not true
000A57  1  20 E3 09             JSR     LSTLNE          ;list it
000A5A  1               NOLSLN
000A5A  1  A9 00                LDA     #0              ;then clear
000A5C  1  85 76                STA     LNEPTR          ;pointer
000A5E  1  A5 4D                LDA     NXTCHR          ;get char
000A60  1               NTEOL
000A60  1  C9 09                CMP     #TAB            ;see it tab
000A62  1  F0 01                BEQ     *+3             ;branch if is
000A64  1  60                   RTS
000A65  1  A9 20                LDA     #SPACE          ;else get space
000A67  1  85 4D                STA     NXTCHR          ;set
000A69  1  60                   RTS                     ;and done
000A6A  1               ;get byte from source file
000A6A  1               NXTSRC
000A6A  1  A6 75                LDX     SRCIND          ;get index
000A6C  1  BD 6A 30             LDA     INPBUF,X        ;then byte
000A6F  1  60                   RTS
000A70  1               ;maintain source buffer full and check for eof. if eof is detected then
000A70  1               ;A:=TRUE else A:=FALSE
000A70  1               CHKFLE
000A70  1  E6 75                INC     SRCIND          ;bump index
000A72  1  10 0E                BPL     CHKFL0          ;branch if ok
000A74  1  A9 00                LDA     #0              ;else clear
000A76  1  85 75                STA     SRCIND          ;index
000A78  1  20 C9 09             JSR     RDESRC          ;read record
000A7B  1  C9 01                CMP     #1              ;see if eof
000A7D  1  D0 03                BNE     CHKFL0          ;branch if not
000A7F  1  A9 FF                LDA     #TRUE           ;else set
000A81  1  60                   RTS                     ;eof=true
000A82  1               CHKFL0
000A82  1  20 6A 0A             JSR     NXTSRC          ;get next
000A85  1  85 4D                STA     NXTCHR          ;save it
000A87  1  C9 0A                CMP     #LF             ;if a lf
000A89  1  F0 E5                BEQ     CHKFLE          ;loop for more
000A8B  1  A9 00                LDA     #FALSE          ;else say
000A8D  1  60                   RTS                     ;wasn't eof
000A8E  1               ;get non-blank from source. will also skip past eof to reach physical eof.
000A8E  1               GTNBLK
000A8E  1  20 15 0A             JSR     GETCHR          ;get new char
000A91  1  C9 20                CMP     #SPACE          ;if a space
000A93  1  F0 F9                BEQ     GTNBLK          ;try again
000A95  1  C9 1A                CMP     #EOF            ;if an eof
000A97  1  F0 F5                BEQ     GTNBLK          ;try again
000A99  1  60                   RTS
000A9A  1               ;check for continuation character. if it is will get first char from next line.
000A9A  1               CHKCNT
000A9A  1  A5 4D                LDA     NXTCHR          ;get next
000A9C  1  C9 5C                CMP     #backsl         ;see if continue
000A9E  1  F0 01                BEQ     *+3             ;branch if is
000AA0  1  60                   RTS
000AA1  1               CHKCN0
000AA1  1  20 15 0A             JSR     GETCHR          ;get next
000AA4  1  C9 0D                CMP     #CR             ;see if eol
000AA6  1  D0 F9                BNE     CHKCN0          ;loop if isn't
000AA8  1  4C 8E 0A             JMP     GTNBLK          ;now get first non-blank
000AAB  1               ;compiler error handler
000AAB  1               ;at entry a contains error number
000AAB  1               ERROR
000AAB  1  85 78                STA     ERRCDE          ;save
000AAD  1  A5 76                LDA     LNEPTR          ;get index
000AAF  1  85 77                STA     POINTR          ;move to pointer
000AB1  1  E6 77                INC     POINTR          ;and bump
000AB3  1  E6 77                INC     POINTR          ;by two
000AB5  1  A5 49                LDA     TOKEN           ;get token
000AB7  1  C9 17                CMP     #TCR            ;see if for eol
000AB9  1  F0 0F                BEQ     ERROR3          ;branch if is
000ABB  1  A5 4D                LDA     NXTCHR          ;else get next
000ABD  1               ERROR1
000ABD  1  C9 0D                CMP     #CR             ;if a cr
000ABF  1  F0 09                BEQ     ERROR3          ;then done
000AC1  1  20 9A 0A             JSR     CHKCNT          ;else see if continue
000AC4  1  20 15 0A             JSR     GETCHR          ;get another char
000AC7  1  4C BD 0A             JMP     ERROR1          ;and loop
000ACA  1               ERROR3
000ACA  1  2C FE 2D             BIT     PASS2           ;test pass 2 flag
000ACD  1  10 43                BPL     ERROR6          ;branch if clear
000ACF  1  2C 00 2E             BIT     LSTSRC          ;see if source already listed
000AD2  1  30 03                BMI     *+5             ;skip list if was
000AD4  1  20 E3 09             JSR     LSTLNE          ;else list
000AD7  1  E6 43                INC     ERRCNT          ;bump
000AD9  1  D0 02                BNE     *+4             ;error
000ADB  1  E6 44                INC     ERRCNT+1        ;count
000ADD  1  A9 3F                LDA     #'?'            ;print a ?
000ADF  1  20 4F 08             JSR     PRNCHR
000AE2  1  A9 2D                LDA     #'-'
000AE4  1  20 4F 08             JSR     PRNCHR          ;print two -
000AE7  1  A9 2D                LDA     #'-'
000AE9  1  20 4F 08             JSR     PRNCHR
000AEC  1               ERROR4
000AEC  1  C6 77                DEC     POINTR          ;drop pointer
000AEE  1  F0 0A                BEQ     ERROR5          ;done if zero
000AF0  1  30 08                BMI     ERROR5          ;or <0
000AF2  1  A9 2D                LDA     #'-'            ;else get -
000AF4  1  20 4F 08             JSR     PRNCHR          ;print it
000AF7  1  4C EC 0A             JMP     ERROR4          ;and loop
000AFA  1               ERROR5
000AFA  1  A9 5E                LDA     #'^'            ;get up arrow
000AFC  1  20 4F 08             JSR     PRNCHR          ;print it
000AFF  1  20 34 08             JSR     CRLF            ;then a cr and lf
000B02  1  A5 78                LDA     ERRCDE          ;get error code
000B04  1  0A                   ASL     A               ;mult by two
000B05  1  AA                   TAX
000B06  1  BD 5A 2D             LDA     ERMTBL,X
000B09  1  BC 5B 2D             LDY     ERMTBL+1,X      ;get message address
000B0C  1  20 FC 08             JSR     PRNMSG          ;print it
000B0F  1  20 34 08             JSR     CRLF
000B12  1               ERROR6
000B12  1  A9 00                LDA     #FALSE          ;now clear
000B14  1  8D 06 2E             STA     CMPLNG          ;compiling flag
000B17  1  4C 84 09             JMP     SETFLG          ;and then other flags
000B1A  1               ;initialize scanner by setting NXTCHR to the first non-blank character from the
000B1A  1               ;input file and by setting the line number and pointer
000B1A  1               INSCAN
000B1A  1  2C FD 2D             BIT     PASS1           ;test for pass 1
000B1D  1  10 0B                BPL     NOGTPR          ;branch if not
000B1F  1  A2 08                LDX     #8              ;move 8 parms
000B21  1               INSCA0
000B21  1  BD 17 01             LDA     FCB+16,X        ;from fcb
000B24  1  9D 2A 2E             STA     PRMLST-1,X      ;to save area
000B27  1  CA                   DEX                     ;drop count
000B28  1  D0 F7                BNE     INSCA0          ;loop if more
000B2A  1               NOGTPR
000B2A  1  20 22 09             JSR     OPNSRC          ;open file
000B2D  1  A9 00                LDA     #0              ;now
000B2F  1  85 6E                STA     CONT            ;clear
000B31  1  85 6F                STA     COLUMN          ;variables
000B33  1  85 70                STA     LINENO          ;for start
000B35  1  85 71                STA     LINENO+1        ;of a
000B37  1  85 76                STA     LNEPTR          ;pass
000B39  1  20 D6 09             JSR     CLLNBF          ;clear output buffer
000B3C  1  A9 80                LDA     #SRCRSZ         ;now set source
000B3E  1  85 75                STA     SRCIND          ;index to invalid
000B40  1  A9 3A                LDA     #':'            ;set separator
000B42  1  85 74                STA     SEPRTR          ;to a colon
000B44  1  AD 2B 2E             LDA     PRMLST          ;get first parm
000B47  1  C9 24                CMP     #'$'            ;see if start
000B49  1  D0 44                BNE     INSDNE          ;not so exit
000B4B  1  A2 01                LDX     #1              ;set index to first
000B4D  1               INSCAP
000B4D  1  BD 2B 2E             LDA     PRMLST,X        ;get parm
000B50  1  E8                   INX                     ;bump index
000B51  1  C9 20                CMP     #SPACE          ;if not a space
000B53  1  F0 3A                BEQ     INSDNE          ;done if space
000B55  1  A0 FF                LDY     #TRUE           ;set true
000B57  1  C9 41                CMP     #'A'            ;if not A
000B59  1  D0 05                BNE     PNOTA           ;try next
000B5B  1  8C FF 2D             STY     LSTPRD          ;else set
000B5E  1  F0 ED                BEQ     INSCAP          ;and loop
000B60  1               PNOTA
000B60  1  C9 43                CMP     #'C'            ;if not C
000B62  1  D0 05                BNE     PNOTC           ;try next
000B64  1  8C 03 2E             STY     NINTFL          ;else set
000B67  1  F0 E4                BEQ     INSCAP          ;and loop
000B69  1               PNOTC
000B69  1  C9 45                CMP     #'E'            ;see if E
000B6B  1  D0 05                BNE     PNOTE           ;branch if not
000B6D  1  8C 01 2E             STY     DEBUGL          ;else set
000B70  1  F0 DB                BEQ     INSCAP          ;and loop
000B72  1               PNOTE
000B72  1  C9 46                CMP     #'F'            ;see if F
000B74  1  D0 05                BNE     PNOTF           ;branch if not
000B76  1  8C 04 2E             STY     LSTFLG          ;else set
000B79  1  F0 D2                BEQ     INSCAP          ;and loop
000B7B  1               PNOTF
000B7B  1  A0 00                LDY     #FALSE          ;now use false
000B7D  1  C9 42                CMP     #'B'            ;if not B
000B7F  1  D0 05                BNE     PNOTB           ;try next
000B81  1  8C 00 2E             STY     LSTSRC          ;else set
000B84  1  F0 C7                BEQ     INSCAP          ;and loop
000B86  1               PNOTB
000B86  1  C9 44                CMP     #'D'            ;if not D
000B88  1  D0 C3                BNE     INSCAP          ;then not valid
000B8A  1  8C 02 2E             STY     LWRUPR          ;else set
000B8D  1  F0 BE                BEQ     INSCAP          ;and loop
000B8F  1               ;done with INSCAN so get first non-blank
000B8F  1               INSDNE
000B8F  1  A9 00                LDA     #0              ;clear eol flag
000B91  1  8D 05 2E             STA     EOLSTS
000B94  1  4C 8E 0A             JMP     GTNBLK
000B97  1               ;put NXTCHR in ACCUM
000B97  1               PUTACC
000B97  1  24 6E                BIT     CONT            ;test for continue
000B99  1  10 01                BPL     *+3             ;do if not
000B9B  1  60                   RTS                     ;else done
000B9C  1  E6 4E                INC     ACCLEN          ;bump length
000B9E  1  A6 4E                LDX     ACCLEN          ;get it as index
000BA0  1  A5 4D                LDA     NXTCHR          ;get next
000BA2  1  95 4E                STA     ACCUM,X         ;store it
000BA4  1  18                   CLC                     ;clear carry
000BA5  1  65 4C                ADC     HSHCDE          ;add hashcde
000BA7  1  29 3F                AND     #HSHMSK         ;mask it
000BA9  1  85 4C                STA     HSHCDE          ;and save
000BAB  1  E0 1F                CPX     #IDNTSZ-1       ;compare to max
000BAD  1  B0 01                BCS     *+3             ;branch if too big
000BAF  1  60                   RTS                     ;else done
000BB0  1  A9 FF                LDA     #TRUE           ;set CONT
000BB2  1  85 6E                STA     CONT            ;flag
000BB4  1  60                   RTS
000BB5  1               ;put NXTCHR in ACCUM and get another non-blank
000BB5  1               PUTGET
000BB5  1  20 97 0B             JSR     PUTACC          ;put
000BB8  1  4C 8E 0A             JMP     GTNBLK          ;and get
000BBB  1               ;put NXTCHR in ACCUM and get another char
000BBB  1               PUTCHR
000BBB  1  20 97 0B             JSR     PUTACC          ;put
000BBE  1  4C 15 0A             JMP     GETCHR          ;and get
000BC1  1               ;test for numeric NXTCHR. return with A:=TRUE iff NXTCHR in '0' to '9'
000BC1  1               NUMRIC
000BC1  1  A5 4D                LDA     NXTCHR          ;get char
000BC3  1  C9 30                CMP     #'0'            ;see if less than 0
000BC5  1  90 07                BCC     NOTNUM          ;branch if is
000BC7  1  C9 3A                CMP     #'9'+1          ;see if over 9
000BC9  1  B0 03                BCS     NOTNUM          ;branch if is
000BCB  1  A9 FF                LDA     #TRUE           ;else set
000BCD  1  60                   RTS                     ;for numeric
000BCE  1               NOTNUM
000BCE  1  A9 00                LDA     #FALSE          ;set false
000BD0  1  60                   RTS
000BD1  1               ;test for lower case NXTCHR. return with A:=TRUE iff NXTCHR in 'a' to 'z'
000BD1  1               LWRCSE
000BD1  1  A5 4D                LDA     NXTCHR          ;get chat
000BD3  1  C9 61                CMP     #'a'            ;see if < a
000BD5  1  90 07                BCC     NOTLWR          ;branch if is
000BD7  1  C9 7B                CMP     #'z'+1          ;see if > z
000BD9  1  B0 03                BCS     NOTLWR          ;branch if is
000BDB  1  A9 FF                LDA     #TRUE           ;else
000BDD  1  60                   RTS                     ;is lower
000BDE  1               NOTLWR
000BDE  1  A9 00                LDA     #FALSE          ;not lower
000BE0  1  60                   RTS
000BE1  1               ;test for NXTCHR a decimal point
000BE1  1               DCMLPT
000BE1  1  A5 4D                LDA     NXTCHR          ;get char
000BE3  1  C9 2E                CMP     #'.'            ;test it
000BE5  1  D0 03                BNE     NTDCML          ;branch if not
000BE7  1  A9 FF                LDA     #TRUE           ;set for true
000BE9  1  60                   RTS
000BEA  1               NTDCML
000BEA  1  A9 00                LDA     #FALSE          ;false
000BEC  1  60                   RTS
000BED  1               ;convert lowercase to uppercase
000BED  1               CNVLWR
000BED  1  20 D1 0B             JSR     LWRCSE          ;see if lower
000BF0  1  2D 02 2E             AND     LWRUPR          ;and with flag
000BF3  1  D0 01                BNE     *+3             ;ok if both true
000BF5  1  60                   RTS                     ;else done
000BF6  1  A5 4D                LDA     NXTCHR          ;get char
000BF8  1  29 5F                AND     #$5F            ;convert
000BFA  1  85 4D                STA     NXTCHR          ;and save
000BFC  1  60                   RTS
000BFD  1               ;test for letter. set A:=TRUE if lowercase or uppercase letter
000BFD  1               LETTER
000BFD  1  20 ED 0B             JSR     CNVLWR          ;covert if all set
000C00  1  20 D1 0B             JSR     LWRCSE          ;see if still lowercase
000C03  1  F0 01                BEQ     *+3             ;branch if not
000C05  1  60                   RTS                     ;else is TRUE
000C06  1  A5 4D                LDA     NXTCHR          ;get char
000C08  1  C9 41                CMP     #'A'            ;if < A
000C0A  1  90 07                BCC     NOTLTR          ;is not letter
000C0C  1  C9 5B                CMP     #'Z'+1          ;if > Z
000C0E  1  B0 03                BCS     NOTLTR          ;is not letter
000C10  1  A9 FF                LDA     #TRUE           ;else is
000C12  1  60                   RTS
000C13  1               NOTLTR
000C13  1  A9 00                LDA     #FALSE          ;not letter
000C15  1  60                   RTS
000C16  1               ;test for letter, number or decimal point. return A:=TRUE if either
000C16  1               ALPNUM
000C16  1  20 FD 0B             JSR     LETTER          ;first try letter
000C19  1  F0 01                BEQ     *+3             ;branch if not
000C1B  1  60                   RTS
000C1C  1  20 C1 0B             JSR     NUMRIC          ;now try number
000C1F  1  F0 01                BEQ     *+3             ;branch if not
000C21  1  60                   RTS
000C22  1  4C E1 0B             JMP     DCMLPT          ;finally try decimal point
000C25  1               ;spool numeric data into ACCUM
000C25  1               SPLNUM
000C25  1  20 C1 0B             JSR     NUMRIC          ;see if number
000C28  1  D0 01                BNE     *+3             ;branch if is
000C2A  1  60                   RTS                     ;else done
000C2B  1  20 BB 0B             JSR     PUTCHR          ;stuff it
000C2E  1  4C 25 0C             JMP     SPLNUM          ;and loop
000C31  1               ;set up next call
000C31  1               SUPNCL
000C31  1  A5 4D                LDA     NXTCHR          ;get next
000C33  1  C9 20                CMP     #SPACE          ;see if blank
000C35  1  D0 03                BNE     *+5             ;branch if not
000C37  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000C3A  1  A9 00                LDA     #FALSE          ;set continue
000C3C  1  85 6E                STA     CONT            ;to false
000C3E  1  60                   RTS
000C3F  1               ;procedure called by SYNTHE to reduce the amount of indexing
000C3F  1               SCOPY
000C3F  1  A6 7B                LDX     SP              ;get stack pointer
000C41  1  BD F7 2E             LDA     TYPE,X          ;do
000C44  1  85 80                STA     TYPESP          ;byte
000C46  1  BD 17 2F             LDA     STYPE,X         ;values
000C49  1  85 83                STA     STYPSP          ;first
000C4B  1  BD B7 2E             LDA     HASH,X
000C4E  1  85 8C                STA     HASHSP
000C50  1  8A                   TXA                     ;now
000C51  1  0A                   ASL     A               ;make a
000C52  1  AA                   TAX                     ;word index
000C53  1  BD 77 2F             LDA     SYMLOC,X
000C56  1  BC 78 2F             LDY     SYMLOC+1,X
000C59  1  85 86                STA     SYMLSP
000C5B  1  84 87                STY     SYMLSP+1
000C5D  1  BD 37 2F             LDA     SRLOC,X
000C60  1  BC 38 2F             LDY     SRLOC+1,X
000C63  1  85 8F                STA     SRLOSP
000C65  1  84 90                STY     SRLOSP+1
000C67  1  A6 7C                LDX     MP              ;now get MP
000C69  1  BD F7 2E             LDA     TYPE,X
000C6C  1  85 82                STA     TYPEMP
000C6E  1  BD 17 2F             LDA     STYPE,X
000C71  1  85 85                STA     STYPMP
000C73  1  BD B7 2E             LDA     HASH,X
000C76  1  85 8E                STA     HASHMP
000C78  1  8A                   TXA                     ;now
000C79  1  0A                   ASL     A               ;make a
000C7A  1  AA                   TAX                     ;word index
000C7B  1  BD 77 2F             LDA     SYMLOC,X
000C7E  1  BC 78 2F             LDY     SYMLOC+1,X
000C81  1  85 8A                STA     SYMLMP
000C83  1  84 8B                STY     SYMLMP+1
000C85  1  BD 37 2F             LDA     SRLOC,X
000C88  1  BC 38 2F             LDY     SRLOC+1,X
000C8B  1  85 91                STA     SRLOMP
000C8D  1  84 92                STY     SRLOMP+1
000C8F  1  A6 7D                LDX     MPP1            ;now get MP+1
000C91  1  BD F7 2E             LDA     TYPE,X
000C94  1  85 81                STA     TYPEM1
000C96  1  BD 17 2F             LDA     STYPE,X
000C99  1  85 84                STA     STYPM1
000C9B  1  BD B7 2E             LDA     HASH,X
000C9E  1  85 8D                STA     HASHM1
000CA0  1  8A                   TXA                     ;now
000CA1  1  0A                   ASL     A               ;make a
000CA2  1  AA                   TAX                     ;word index
000CA3  1  BD 77 2F             LDA     SYMLOC,X
000CA6  1  BC 78 2F             LDY     SYMLOC+1,X
000CA9  1  85 88                STA     SYMLM1
000CAB  1  84 89                STY     SYMLM1+1
000CAD  1  60                   RTS
000CAE  1               ;called by SYNTHE to set SYMLOC(SP) to AY
000CAE  1               STSLSP
000CAE  1  48                   PHA                     ;save A part
000CAF  1  A5 7B                LDA     SP              ;get SP
000CB1  1               STSL
000CB1  1  0A                   ASL     A               ;mult by two
000CB2  1  AA                   TAX                     ;make index
000CB3  1  68                   PLA                     ;get byte
000CB4  1  9D 77 2F             STA     SYMLOC,X        ;save it
000CB7  1  98                   TYA                     ;get high
000CB8  1  9D 78 2F             STA     SYMLOC+1,X      ;save it
000CBB  1  60                   RTS
000CBC  1               ;called by SYNTHE to set SYMLOC(MP) to AY
000CBC  1               STSLMP
000CBC  1  48                   PHA                     ;save low
000CBD  1  A5 7C                LDA     MP              ;get MP
000CBF  1  4C B1 0C             JMP     STSL            ;go do
000CC2  1               ;called by SYNTHE to set TYPE(SP) to A
000CC2  1               STTYSP
000CC2  1  A6 7B                LDX     SP              ;get SP
000CC4  1  9D F7 2E             STA     TYPE,X          ;save
000CC7  1  60                   RTS
000CC8  1               ;called by SYNTHE to set STYPE(SP) to A
000CC8  1               STSTSP
000CC8  1  A6 7B                LDX     SP              ;get SP
000CCA  1  9D 17 2F             STA     STYPE,X         ;save
000CCD  1  60                   RTS
000CCE  1               ;set STYPE(MP) to A
000CCE  1               STSTMP
000CCE  1  A6 7C                LDX     MP              ;get MP
000CD0  1  9D 17 2F             STA     STYPE,X         ;save
000CD3  1  60                   RTS
000CD4  1               ;set TYPE(MP) to A
000CD4  1               STTYMP
000CD4  1  A6 7C                LDX     MP              ;get MP
000CD6  1  9D F7 2E             STA     TYPE,X          ;save
000CD9  1  60                   RTS
000CDA  1               ;set HASH(MP) to A
000CDA  1               STHAMP
000CDA  1  A6 7C                LDX     MP              ;get MP
000CDC  1  9D B7 2E             STA     HASH,X          ;insert
000CDF  1  60                   RTS
000CE0  1               ;set HASH(SP) to A
000CE0  1               STHASP
000CE0  1  A6 7B                LDX     SP              ;get SP
000CE2  1  9D B7 2E             STA     HASH,X          ;insert
000CE5  1  60                   RTS
000CE6  1               ;set SRLOC(SP) to AY
000CE6  1               STSRSP
000CE6  1  48                   PHA                     ;save low
000CE7  1  A5 7B                LDA     SP              ;get SP
000CE9  1  0A                   ASL     A               ;mult by two
000CEA  1  AA                   TAX                     ;make index
000CEB  1  68                   PLA                     ;get low
000CEC  1  9D 37 2F             STA     SRLOC,X         ;save ir
000CEF  1  98                   TYA                     ;get high
000CF0  1  9D 38 2F             STA     SRLOC+1,X       ;save it
000CF3  1  60                   RTS
000CF4  1               ;write generated code in A and count size of code area
000CF4  1               GENERT
000CF4  1  E6 B2                INC     CODESI          ;bump
000CF6  1  D0 02                BNE     *+4             ;code
000CF8  1  E6 B3                INC     CODESI+1        ;size
000CFA  1  2C FD 2D             BIT     PASS1           ;test for pass 1
000CFD  1  30 03                BMI     *+5             ;branch if
000CFF  1  4C B6 09             JMP     EMIT            ;else go emit
000D02  1  60                   RTS
000D03  1               ;write data in A during pass 2 and count size of data area
000D03  1               EMITDT
000D03  1  E6 45                INC     DATACT          ;bump
000D05  1  D0 02                BNE     *+4             ;data
000D07  1  E6 46                INC     DATACT+1        ;size
000D09  1  2C FE 2D             BIT     PASS2           ;test for pass 2
000D0C  1  10 03                BPL     *+5             ;branch if not
000D0E  1  4C B6 09             JMP     EMIT            ;else go emit
000D11  1  60                   RTS
000D12  1               ;compare ACCUM to reserved word string
000D12  1               COMPAR
000D12  1  A9 00                LDA     #0
000D14  1  85 A1                STA     IC
000D16  1               COMPA0
000D16  1  A4 A1                LDY     IC
000D18  1  B1 A2                LDA     (PTR),Y         ;a=field(i)
000D1A  1  E6 A1                INC     IC
000D1C  1  A4 A1                LDY     IC              ;i=i+1
000D1E  1  D9 4E 00             CMP     ACCUM,Y         ;compare field(i) to accum(i=i+1)
000D21  1  D0 09                BNE     COMPAX          ;exit if different
000D23  1  A5 4E                LDA     ACCLEN
000D25  1  C5 A1                CMP     IC              ;if i<=acclen
000D27  1  B0 ED                BCS     COMPA0          ;then loop
000D29  1               COMPAT
000D29  1  A9 FF                LDA     #TRUE           ;was a match
000D2B  1  60                   RTS
000D2C  1               COMPAX
000D2C  1  A5 4E                LDA     ACCLEN          ;check termination condition
000D2E  1  C5 A1                CMP     IC
000D30  1  90 F7                BCC     COMPAT          ;if i>acclen is true
000D32  1  A9 00                LDA     #FALSE
000D34  1  60                   RTS
000D35  1               ;attempt to match reserved word
000D35  1               LOOKUP
000D35  1  A9 09                LDA     #MAXRWL         ;compare max word length
000D37  1  C5 4E                CMP     ACCLEN          ;to length
000D39  1  90 5A                BCC     LOOKFL          ;exit as false if too big
000D3B  1  A6 4E                LDX     ACCLEN          ;get length
000D3D  1  BD EE 29             LDA     OFFSET,X        ;and offset
000D40  1  18                   CLC                     ;in reserved word table
000D41  1  69 AD                ADC     #<LNG1          ;now add to
000D43  1  85 A2                STA     PTR             ;start to
000D45  1  A9 00                LDA     #0              ;get
000D47  1  69 28                ADC     #>LNG1          ;indirect
000D49  1  85 A3                STA     PTR+1           ;pointer
000D4B  1  A9 00                LDA     #0              ;set index
000D4D  1  85 A4                STA     IL              ;to zero
000D4F  1               LOOKU0
000D4F  1  E6 A4                INC     IL              ;bump index
000D51  1  A6 4E                LDX     ACCLEN          ;see if count
000D53  1  BD F8 29             LDA     COUNT,X         ;bigger than
000D56  1  C5 A4                CMP     IL              ;number words
000D58  1  90 3B                BCC     LOOKFL          ;no match if is
000D5A  1  20 12 0D             JSR     COMPAR          ;try to match
000D5D  1  D0 0E                BNE     LOOKMT          ;branch if did
000D5F  1  18                   CLC                     ;else
000D60  1  A5 A2                LDA     PTR             ;bump
000D62  1  65 4E                ADC     ACCLEN          ;pointer
000D64  1  85 A2                STA     PTR             ;by length
000D66  1  90 E7                BCC     LOOKU0          ;of word
000D68  1  E6 A3                INC     PTR+1           ;and try
000D6A  1  4C 4F 0D             JMP     LOOKU0          ;next
000D6D  1               LOOKMT
000D6D  1  A6 4E                LDX     ACCLEN          ;get length
000D6F  1  BD 02 2A             LDA     TKOS,X          ;and token offset
000D72  1  18                   CLC                     ;add to
000D73  1  65 A4                ADC     IL              ;index
000D75  1  AA                   TAX                     ;make an index
000D76  1  BD 9E 29             LDA     TK,X            ;get token
000D79  1  85 49                STA     TOKEN           ;and save
000D7B  1  C9 41                CMP     #64+1           ;see if over 64
000D7D  1  90 13                BCC     LOOKTR          ;branch if not
000D7F  1  C9 63                CMP     #TDATA          ;see if TDATA
000D81  1  F0 0F                BEQ     LOOKTR          ;branch if is
000D83  1  85 4B                STA     FUNCOP          ;else save as FUNCOP
000D85  1  38                   SEC                     ;now subtract
000D86  1  E9 41                SBC     #65             ;65 to
000D88  1  AA                   TAX                     ;make index
000D89  1  BD 0C 2A             LDA     ST,X            ;get subtype
000D8C  1  85 4A                STA     SUBTYP          ;and save
000D8E  1  A9 35                LDA     #FUNCT
000D90  1  85 49                STA     TOKEN           ;token=funct
000D92  1               LOOKTR
000D92  1  A9 FF                LDA     #TRUE           ;match
000D94  1  60                   RTS
000D95  1               LOOKFL
000D95  1  A9 00                LDA     #FALSE          ;no match
000D97  1  60                   RTS
000D98  1               ;scanner accepts input characters from the source file returning tokens to the
000D98  1               ;parser.  conversion to uppercase is performed if LWRUPR is set.  each token is
000D98  1               ;placed in ACCUM and ACCLEN is the length of the token.  the token is hashed by
000D98  1               ;summing each ASCII character modulo HSHTSZ (hashtablesize) and is stored in
000D98  1               ;HSHCDE (hashcode).  SUBTYP and FUNCOP are set if the token is a predefined
000D98  1               ;function.  REM and DATA statements are handled completely by the scanner. REM
000D98  1               ;and REMARK statements cause the input to be scanned until the end of the
000D98  1               ;current input line is located.  the cr is then scanned and returned.  DATA
000D98  1               ;statements are similar except data is output using EMITDT.
000D98  1               SCANNR
000D98  1  A9 00                LDA     #0              ;clear
000D9A  1  85 4E                STA     ACCLEN          ;these
000D9C  1  85 4C                STA     HSHCDE          ;variables
000D9E  1  85 49                STA     TOKEN           ;at
000DA0  1  85 4A                STA     SUBTYP          ;start
000DA2  1  24 6E                BIT     CONT            ;test continue flag
000DA4  1  30 13                BMI     SCAN1           ;branch if set
000DA6  1  2C 05 2E             BIT     EOLSTS          ;test eol status
000DA9  1  10 08                BPL     SCAN28          ;skip if char ready
000DAB  1  20 8E 0A             JSR     GTNBLK          ;else go read
000DAE  1  A9 00                LDA     #0              ;then clear flag
000DB0  1  8D 05 2E             STA     EOLSTS
000DB3  1               SCAN28
000DB3  1  A5 4D                LDA     NXTCHR          ;else get next
000DB5  1  C9 22                CMP     #'"'            ;see if "
000DB7  1  D0 2E                BNE     SCAN5           ;branch if not
000DB9  1               ;first case is string or string continuation
000DB9  1               SCAN1
000DB9  1  A9 32                LDA     #STRING         ;get token
000DBB  1  85 49                STA     TOKEN           ;and set
000DBD  1  A9 00                LDA     #FALSE          ;and set
000DBF  1  85 6E                STA     CONT            ;CONT as false
000DC1  1               SCAN2
000DC1  1  20 15 0A             JSR     GETCHR          ;get char
000DC4  1  C9 22                CMP     #'"'            ;see if delimiter
000DC6  1  F0 11                BEQ     SCAN4           ;branch if is
000DC8  1  C9 0D                CMP     #CR             ;see if eol
000DCA  1  D0 05                BNE     SCAN3           ;branch if not
000DCC  1  A9 16                LDA     #22             ;else is unterminated string
000DCE  1  4C AB 0A             JMP     ERROR           ;do error and quit
000DD1  1               SCAN3
000DD1  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000DD4  1  24 6E                BIT     CONT            ;test for continue
000DD6  1  10 E9                BPL     SCAN2           ;loop if not
000DD8  1  60                   RTS                     ;else done
000DD9  1               SCAN4
000DD9  1  20 8E 0A             JSR     GTNBLK          ;get non-blank
000DDC  1  C9 22                CMP     #'"'            ;see if another delimiter
000DDE  1  F0 01                BEQ     *+3             ;branch if is
000DE0  1  60                   RTS                     ;else done
000DE1  1  20 97 0B             JSR     PUTACC          ;put in ACCUM
000DE4  1  4C C1 0D             JMP     SCAN2           ;and loop
000DE7  1               SCAN5
000DE7  1  20 C1 0B             JSR     NUMRIC          ;see if number
000DEA  1  D0 05                BNE     SCAN6           ;branch if is
000DEC  1  20 E1 0B             JSR     DCMLPT          ;see if decimal point
000DEF  1  F0 51                BEQ     SCAN15          ;branch if not
000DF1  1               ;is a numeric of up to IDNTSZ-1 characters
000DF1  1               SCAN6
000DF1  1  A9 31                LDA     #FLOTPT         ;get token
000DF3  1  85 49                STA     TOKEN           ;and set
000DF5  1  A5 4D                LDA     NXTCHR          ;get next char
000DF7  1               SCAN7
000DF7  1  C9 30                CMP     #'0'            ;see if leading zero
000DF9  1  D0 06                BNE     SCAN8           ;branch if not
000DFB  1  20 15 0A             JSR     GETCHR          ;else get next
000DFE  1  4C F7 0D             JMP     SCAN7           ;and loop to flush
000E01  1               SCAN8
000E01  1  20 25 0C             JSR     SPLNUM          ;spool numeric
000E04  1  20 E1 0B             JSR     DCMLPT          ;test for decimal point
000E07  1  F0 06                BEQ     SCAN9           ;branch if not
000E09  1  20 BB 0B             JSR     PUTCHR          ;insert it
000E0C  1  20 25 0C             JSR     SPLNUM          ;spool rest
000E0F  1               SCAN9
000E0F  1  20 ED 0B             JSR     CNVLWR          ;convert next to upper
000E12  1  A5 4D                LDA     NXTCHR          ;get it
000E14  1  C9 45                CMP     #'E'            ;see if e for exponent
000E16  1  D0 1B                BNE     SCAN13          ;branch if not
000E18  1  20 B5 0B             JSR     PUTGET          ;else insert and get another
000E1B  1  C9 2B                CMP     #'+'            ;if a +
000E1D  1  F0 04                BEQ     SCAN10          ;go insert and get another
000E1F  1  C9 2D                CMP     #'-'            ;if not a -
000E21  1  D0 03                BNE     SCAN11          ;skip ahead
000E23  1               SCAN10
000E23  1  20 B5 0B             JSR     PUTGET          ;insert and get
000E26  1               SCAN11
000E26  1  20 C1 0B             JSR     NUMRIC          ;test for number
000E29  1  D0 05                BNE     SCAN12          ;branch if is
000E2B  1  A9 09                LDA     #9              ;else illegal floating point format
000E2D  1  20 AB 0A             JSR     ERROR           ;error
000E30  1               SCAN12
000E30  1  20 25 0C             JSR     SPLNUM          ;spool numbers
000E33  1               SCAN13
000E33  1  A5 4E                LDA     ACCLEN          ;get length
000E35  1  D0 08                BNE     SCAN14          ;branch if not zero
000E37  1  E6 4E                INC     ACCLEN          ;else bump
000E39  1  A9 30                LDA     #'0'            ;and insert a '0'
000E3B  1  85 4F                STA     ACCUM+1         ;in ACCUM
000E3D  1  85 4C                STA     HSHCDE          ;and hashcode
000E3F  1               SCAN14
000E3F  1  4C 31 0C             JMP     SUPNCL          ;setupnextcall and return
000E42  1               SCAN15
000E42  1  20 FD 0B             JSR     LETTER          ;see if letter
000E45  1  D0 03                BNE     *+5             ;continue if is
000E47  1  4C DE 0E             JMP     SCAN26          ;else go to next section
000E4A  1               ;is an identifier or may be REM, REMARK, or DATA statements. these two are
000E4A  1               ;handled here
000E4A  1               SCAN16
000E4A  1  20 16 0C             JSR     ALPNUM          ;test for alphanumeric
000E4D  1  F0 06                BEQ     SCAN17          ;branch if not
000E4F  1  20 BB 0B             JSR     PUTCHR          ;else insert and get
000E52  1  4C 4A 0E             JMP     SCAN16          ;and loop
000E55  1               SCAN17
000E55  1  A5 4D                LDA     NXTCHR          ;get next char
000E57  1  C9 24                CMP     #'$'            ;if not a $
000E59  1  D0 0A                BNE     SCAN18          ;is floating
000E5B  1  A9 32                LDA     #STRING         ;else set string
000E5D  1  85 4A                STA     SUBTYP          ;as subtype
000E5F  1  20 BB 0B             JSR     PUTCHR          ;put and get
000E62  1  4C 69 0E             JMP     SCAN19          ;and continue
000E65  1               SCAN18
000E65  1  A9 31                LDA     #FLOTPT         ;set floating
000E67  1  85 4A                STA     SUBTYP          ;as subtype
000E69  1               SCAN19
000E69  1  20 35 0D             JSR     LOOKUP          ;try to match
000E6C  1  D0 20                BNE     SCAN21          ;branch if reserved
000E6E  1  A5 4F                LDA     ACCUM+1         ;check for user
000E70  1  C9 46                CMP     #'F'            ;defined function
000E72  1  D0 13                BNE     SCAN20          ;branch if not
000E74  1  A5 50                LDA     ACCUM+2         ;same for next
000E76  1  C9 4E                CMP     #'N'            ;char in ACCUM
000E78  1  D0 0D                BNE     SCAN20
000E7A  1  A5 4E                LDA     ACCLEN          ;get length
000E7C  1  C9 01                CMP     #1              ;must not be 1
000E7E  1  F0 07                BEQ     SCAN20          ;branch if is
000E80  1  A9 36                LDA     #UDFUNC         ;ah!ah! is FN--
000E82  1  85 49                STA     TOKEN           ;set token
000E84  1  4C 31 0C             JMP     SUPNCL          ;exit with setupnextcall
000E87  1               SCAN20
000E87  1  A9 34                LDA     #IDENT          ;is identifier
000E89  1  85 49                STA     TOKEN           ;set token
000E8B  1  4C 31 0C             JMP     SUPNCL          ;exit with setupnextcall
000E8E  1               SCAN21
000E8E  1  A5 49                LDA     TOKEN           ;is a reserved
000E90  1  C9 00                CMP     #TREM           ;see if REM
000E92  1  D0 12                BNE     SCAN23          ;branch if not
000E94  1               SCAN22
000E94  1  A5 4D                LDA     NXTCHR          ;get next
000E96  1  C9 0D                CMP     #CR             ;see if eol
000E98  1  D0 03                BNE     *+5             ;branch if not
000E9A  1  4C 98 0D             JMP     SCANNR          ;else loop to start
000E9D  1  20 15 0A             JSR     GETCHR          ;get char
000EA0  1  20 9A 0A             JSR     CHKCNT          ;check for continue
000EA3  1  4C 94 0E             JMP     SCAN22          ;and loop
000EA6  1               SCAN23
000EA6  1  C9 63                CMP     #TDATA          ;see if DATA
000EA8  1  F0 03                BEQ     *+5             ;branch if is
000EAA  1  4C 31 0C             JMP     SUPNCL          ;else setupnextcall and exit
000EAD  1  A9 33                LDA     #DAT            ;emit DAT opcode
000EAF  1  20 03 0D             JSR     EMITDT          ;to start
000EB2  1  A5 4D                LDA     NXTCHR          ;get next
000EB4  1  20 03 0D             JSR     EMITDT          ;emit it
000EB7  1               SCAN24
000EB7  1  20 15 0A             JSR     GETCHR          ;get another
000EBA  1  C9 0D                CMP     #CR             ;see if eol
000EBC  1  F0 0B                BEQ     SCAN25          ;branch if is
000EBE  1  20 9A 0A             JSR     CHKCNT          ;else check for continue
000EC1  1  A5 4D                LDA     NXTCHR          ;get char
000EC3  1  20 03 0D             JSR     EMITDT          ;emit it
000EC6  1  4C B7 0E             JMP     SCAN24          ;and loop
000EC9  1               SCAN25
000EC9  1  A9 2C                LDA     #','            ;now emit
000ECB  1  20 03 0D             JSR     EMITDT          ;a comma
000ECE  1  A9 00                LDA     #0              ;and a
000ED0  1  20 03 0D             JSR     EMITDT          ;zero
000ED3  1  A5 45                LDA     DATACT          ;now
000ED5  1  D0 02                BNE     *+4             ;drop
000ED7  1  C6 46                DEC     DATACT+1        ;data count
000ED9  1  C6 45                DEC     DATACT          ;by one
000EDB  1  4C 98 0D             JMP     SCANNR          ;and loop to start
000EDE  1               ;final case is a special character -- it may be continuation char in which case
000EDE  1               ;just go to next line and scan somemore
000EDE  1               SCAN26
000EDE  1  A5 4D                LDA     NXTCHR          ;get char
000EE0  1  C9 5C                CMP     #backsl         ;see if continue
000EE2  1  D0 06                BNE     SCAN27          ;branch if not
000EE4  1  20 9A 0A             JSR     CHKCNT          ;check it
000EE7  1  4C 98 0D             JMP     SCANNR          ;and loop
000EEA  1               SCAN27
000EEA  1  20 97 0B             JSR     PUTACC          ;put in accum
000EED  1  A5 4D                LDA     NXTCHR          ;get last char
000EEF  1  C9 0D                CMP     #CR             ;see if eol
000EF1  1  D0 07                BNE     SCAN29          ;not so skip
000EF3  1  A9 FF                LDA     #$FF            ;set flag to read
000EF5  1  8D 05 2E             STA     EOLSTS
000EF8  1  30 03                BMI     SCAN30          ;then jump ahead
000EFA  1               SCAN29
000EFA  1  20 8E 0A             JSR     GTNBLK          ;get non blank
000EFD  1               SCAN30
000EFD  1  20 35 0D             JSR     LOOKUP          ;see if match
000F00  1  F0 01                BEQ     *+3             ;branch if not
000F02  1  60                   RTS                     ;else done
000F03  1  A9 07                LDA     #7              ;illegal character error
000F05  1  4C AB 0A             JMP     ERROR           ;and quit
000F08  1               ;adjust base for next entry
000F08  1               NXTENT
000F08  1  A0 00                LDY     #0              ;clear index
000F0A  1  B1 A7                LDA     (BASE),Y        ;get name length
000F0C  1  18                   CLC                     ;now
000F0D  1  65 A7                ADC     BASE            ;add to current
000F0F  1  85 A7                STA     BASE            ;and update
000F11  1  90 02                BCC     *+4             ;don't forget
000F13  1  E6 A8                INC     BASE+1          ;carry
000F15  1  18                   CLC                     ;now
000F16  1  A5 A7                LDA     BASE            ;add
000F18  1  69 07                ADC     #7              ;seven for
000F1A  1  85 A7                STA     BASE            ;overhead
000F1C  1  90 02                BCC     *+4             ;to get
000F1E  1  E6 A8                INC     BASE+1          ;new base
000F20  1  60                   RTS
000F21  1               ;get length of printname
000F21  1               GETLEN
000F21  1  A0 00                LDY     #0              ;clear index
000F23  1  B1 A7                LDA     (BASE),Y        ;get length
000F25  1  60                   RTS
000F26  1               ;write numeric constant during pass 1
000F26  1               EMITCN
000F26  1  2C FD 2D             BIT     PASS1           ;test for pass 1
000F29  1  30 01                BMI     *+3             ;branch if is
000F2B  1  60                   RTS                     ;else done
000F2C  1  4C B6 09             JMP     EMIT            ;write byte
000F2F  1               ;write two bytes of object code on disk for literals
000F2F  1               GENTWO
000F2F  1  48                   PHA                     ;save low
000F30  1  98                   TYA                     ;get high
000F31  1  20 F4 0C             JSR     GENERT          ;write it
000F34  1  68                   PLA                     ;get low
000F35  1  4C F4 0C             JMP     GENERT          ;do it
000F38  1               ;
000F38  1               LITERL
000F38  1  48                   PHA                     ;save low
000F39  1  98                   TYA                     ;get high
000F3A  1  09 80                ORA     #$80            ;set msb
000F3C  1  A8                   TAY                     ;back to Y
000F3D  1  68                   PLA                     ;get low
000F3E  1  4C 2F 0F             JMP     GENTWO          ;send it
000F41  1               ;
000F41  1               LITLOD
000F41  1  48                   PHA                     ;save low
000F42  1  98                   TYA                     ;get high
000F43  1  09 C0                ORA     #$C0            ;or with mask
000F45  1  A8                   TAY                     ;back to Y
000F46  1  68                   PLA                     ;get low
000F47  1  4C 2F 0F             JMP     GENTWO          ;write it
000F4A  1               ;
000F4A  1               LINENU
000F4A  1  2C 01 2E             BIT     DEBUGL          ;test debug flag
000F4D  1  30 01                BMI     *+3             ;branch if set
000F4F  1  60                   RTS                     ;else do nothing
000F50  1  A5 70                LDA     LINENO          ;get low
000F52  1  A4 71                LDY     LINENO+1        ;and high number
000F54  1  20 38 0F             JSR     LITERL          ;send as literal
000F57  1  A9 5F                LDA     #BOL            ;then send BOL
000F59  1  4C F4 0C             JMP     GENERT          ;opcode
000F5C  1               ;fill hashtable with 0's and initialize pointer to top of symbol table
000F5C  1               INSYMT
000F5C  1  2C FD 2D             BIT     PASS1           ;see if pass 1
000F5F  1  10 14                BPL     INSYM1          ;branch if not
000F61  1  A2 7F                LDX     #HSHTSZ*2-1     ;get number to clear
000F63  1  A9 00                LDA     #0              ;then value
000F65  1               INSYM0
000F65  1  9D 37 2E             STA     HSHTBL,X        ;store it
000F68  1  CA                   DEX                     ;drop count
000F69  1  E0 FF                CPX     #255            ;see if wrap
000F6B  1  D0 F8                BNE     INSYM0          ;loop if not
000F6D  1  A9 BE                LDA     #<MEMORY        ;get memory
000F6F  1  A0 31                LDY     #>MEMORY        ;start
000F71  1  85 AA                STA     SBTBL           ;and set
000F73  1  84 AB                STY     SBTBL+1         ;table start
000F75  1               INSYM1
000F75  1  AD 04 01             LDA     PEM+1           ;get limit
000F78  1  AC 05 01             LDY     PEM+2           ;of memory
000F7B  1  38                   SEC                     ;drop
000F7C  1  E9 02                SBC     #2              ;two
000F7E  1  85 A5                STA     SBTTOP          ;to get
000F80  1  85 B9                STA     NXSTPT          ;top starting
000F82  1  B0 01                BCS     *+3             ;branch if no borrow
000F84  1  88                   DEY                     ;else drop Y
000F85  1  84 A6                STY     SBTTOP+1        ;set high
000F87  1  84 BA                STY     NXSTPT+1        ;and set
000F89  1  A9 00                LDA     #0              ;clear A
000F8B  1  A0 01                LDY     #1              ;set index to 1
000F8D  1  91 B9                STA     (NXSTPT),Y      ;put in memory
000F8F  1  60                   RTS
000F90  1               ;
000F90  1               GETHSH
000F90  1  A0 00                LDY     #0              ;get
000F92  1  B1 A7                LDA     (BASE),Y        ;PTR
000F94  1  85 BC                STA     TMPPTR          ;and save
000F96  1  84 BB                STY     TMPHSH          ;clear internal hash
000F98  1  A5 A7                LDA     BASE            ;get
000F9A  1  A4 A8                LDY     BASE+1          ;base
000F9C  1  18                   CLC                     ;now
000F9D  1  69 02                ADC     #2              ;add 2
000F9F  1  85 AC                STA     APTADD          ;and save
000FA1  1  90 01                BCC     *+3             ;branch if
000FA3  1  C8                   INY                     ;no carry
000FA4  1  84 AD                STY     APTADD+1        ;save high
000FA6  1  A0 01                LDY     #1              ;set starting index
000FA8  1               GETHS0
000FA8  1  C4 BC                CPY     TMPPTR          ;compare to limit
000FAA  1  F0 05                BEQ     GETHS1          ;continue if equal
000FAC  1  90 03                BCC     GETHS1          ;branch if less
000FAE  1  A5 BB                LDA     TMPHSH          ;else get HASH
000FB0  1  60                   RTS                     ;and quit
000FB1  1               GETHS1
000FB1  1  B1 AC                LDA     (APTADD),Y      ;get value
000FB3  1  18                   CLC                     ;now add
000FB4  1  65 BB                ADC     TMPHSH          ;in old hash
000FB6  1  29 3F                AND     #HSHMSK         ;and mask
000FB8  1  85 BB                STA     TMPHSH          ;and save
000FBA  1  C8                   INY                     ;bump loop index
000FBB  1  4C A8 0F             JMP     GETHS0          ;then loop
000FBE  1               ;
000FBE  1               HSOSYM
000FBE  1  A5 B7                LDA     SYMHSH          ;get symhsh
000FC0  1  0A                   ASL     A               ;mult by two
000FC1  1  AA                   TAX                     ;make index
000FC2  1  BD 37 2E             LDA     HSHTBL,X        ;get value
000FC5  1  BC 38 2E             LDY     HSHTBL+1,X      ;in table
000FC8  1  60                   RTS
000FC9  1               ;
000FC9  1               SETLNK
000FC9  1  A6 A7                LDX     BASE            ;get
000FCB  1  A4 A8                LDY     BASE+1          ;base
000FCD  1  E8                   INX                     ;bump
000FCE  1  86 AC                STX     APTADD          ;by
000FD0  1  D0 01                BNE     *+3             ;one
000FD2  1  C8                   INY                     ;and
000FD3  1  84 AD                STY     APTADD+1        ;save
000FD5  1  60                   RTS
000FD6  1               ;set pointer for addr reference with offset in A
000FD6  1               SETADP
000FD6  1  A0 00                LDY     #0              ;clear index
000FD8  1  18                   CLC                     ;and carry
000FD9  1  71 A7                ADC     (BASE),Y        ;add PTR
000FDB  1  90 01                BCC     *+3             ;branch if no carry
000FDD  1  C8                   INY                     ;else set Y to 1
000FDE  1  18                   CLC                     ;clear carry
000FDF  1  65 A7                ADC     BASE            ;add base
000FE1  1  85 AC                STA     APTADD          ;to low
000FE3  1  98                   TYA                     ;now add
000FE4  1  65 A8                ADC     BASE+1          ;with carry to high
000FE6  1  85 AD                STA     APTADD+1        ;and save
000FE8  1  60                   RTS
000FE9  1               ;check to see if additional SBTBL entry will overflow limits of memory. if
000FE9  1               ;so then abort else return. at entry A contains amount to be added (COUNT)
000FE9  1               LIMITS
000FE9  1  18                   CLC                     ;add count
000FEA  1  65 AA                ADC     SBTBL           ;to start
000FEC  1  A4 AB                LDY     SBTBL+1         ;with
000FEE  1  90 01                BCC     *+3             ;carry to
000FF0  1  C8                   INY                     ;high
000FF1  1  C5 A5                CMP     SBTTOP          ;compare to limit
000FF3  1  98                   TYA                     ;including
000FF4  1  E5 A6                SBC     SBTTOP+1        ;high
000FF6  1  B0 01                BCS     *+3             ;whoops! no borrow
000FF8  1  60                   RTS                     ;else ok
000FF9  1  A9 FF                LDA     #TRUE           ;set to
000FFB  1  8D FE 2D             STA     PASS2           ;pass 2
000FFE  1  A9 13                LDA     #19             ;symbol table error
001000  1  20 AB 0A             JSR     ERROR           ;send it
001003  1  4C 00 01             JMP     BOOT            ;and abort
001006  1               ;set the address field at location LOC in AY and resolved bit
001006  1               SETRSV
001006  1  48                   PHA                     ;save
001007  1  98                   TYA                     ;A
001008  1  48                   PHA                     ;and Y
001009  1  A9 04                LDA     #4              ;set offset
00100B  1  20 D6 0F             JSR     SETADP          ;of four
00100E  1  A0 01                LDY     #1              ;set index to 1
001010  1  68                   PLA                     ;get high
001011  1  91 AC                STA     (APTADD),Y      ;and save
001013  1  88                   DEY                     ;drop Y to 0
001014  1  68                   PLA                     ;get low
001015  1  91 AC                STA     (APTADD),Y      ;save it
001017  1  A5 AC                LDA     APTADD          ;now
001019  1  D0 02                BNE     *+4             ;drop
00101B  1  C6 AD                DEC     APTADD+1        ;pointer
00101D  1  C6 AC                DEC     APTADD          ;by one
00101F  1  B1 AC                LDA     (APTADD),Y      ;now set
001021  1  09 80                ORA     #$80            ;resolved
001023  1  91 AC                STA     (APTADD),Y      ;bit
001025  1  60                   RTS
001026  1               ;return type of variable
001026  1               GETTYP
001026  1  A9 03                LDA     #3              ;build
001028  1  20 D6 0F             JSR     SETADP          ;new indirect
00102B  1  A0 00                LDY     #0              ;clear index
00102D  1  B1 AC                LDA     (APTADD),Y      ;get
00102F  1  29 7F                AND     #$7F            ;mask out set bit
001031  1  60                   RTS
001032  1               ;set type of variable to A and preserve resolved bit
001032  1               SETTYP
001032  1  48                   PHA                     ;save type
001033  1  A9 03                LDA     #3              ;calculate
001035  1  20 D6 0F             JSR     SETADP          ;new pointer
001038  1  A0 00                LDY     #0              ;clear index
00103A  1  68                   PLA                     ;get type
00103B  1  11 AC                ORA     (APTADD),Y      ;or with contents
00103D  1  91 AC                STA     (APTADD),Y      ;save it
00103F  1  60                   RTS
001040  1               ;get resolved bit A:=TRUE iff bit=1 else A:=FALSE
001040  1               GETRES
001040  1  A9 03                LDA     #3              ;build
001042  1  20 D6 0F             JSR     SETADP          ;pointer
001045  1  A0 00                LDY     #0              ;clear index
001047  1  B1 AC                LDA     (APTADD),Y      ;get byte
001049  1  30 03                BMI     *+5             ;branch if set
00104B  1  A9 00                LDA     #FALSE          ;else set
00104D  1  60                   RTS                     ;false
00104E  1  A9 FF                LDA     #TRUE           ;was set
001050  1  60                   RTS
001051  1               ;get the address of the printname location in AY
001051  1               GETADR
001051  1  A9 04                LDA     #4              ;build
001053  1  20 D6 0F             JSR     SETADP          ;pointer
001056  1  A0 00                LDY     #0              ;clear index
001058  1  B1 AC                LDA     (APTADD),Y      ;now get low
00105A  1  48                   PHA                     ;save
00105B  1  C8                   INY                     ;set Y to 1
00105C  1  B1 AC                LDA     (APTADD),Y      ;get high
00105E  1  A8                   TAY                     ;move to Y
00105F  1  68                   PLA                     ;get low
001060  1  60                   RTS
001061  1               ;check to see if printname located at address in PRNTNM is in SBTBL. if is
001061  1               ;then A:=TRUE and BASE:=address else A:=FALSE
001061  1               SLOOKU
001061  1  20 BE 0F             JSR     HSOSYM          ;find base
001064  1               SLOOKX
001064  1  85 A7                STA     BASE            ;and
001066  1  84 A8                STY     BASE+1          ;save
001068  1               SLOOK0
001068  1  A5 A7                LDA     BASE            ;see if
00106A  1  05 A8                ORA     BASE+1          ;base = 0
00106C  1  F0 2B                BEQ     SLOOFL          ;false if is
00106E  1  A0 00                LDY     #0              ;clear index
001070  1  B1 A7                LDA     (BASE),Y        ;get PTR
001072  1  85 BD                STA     LEN             ;save as length
001074  1  D1 B5                CMP     (PRNTNM),Y      ;compare
001076  1  D0 11                BNE     SLOOK2          ;branch if different
001078  1               SLOOK1
001078  1  A4 BD                LDY     LEN             ;get length
00107A  1  B1 B5                LDA     (PRNTNM),Y      ;get name
00107C  1  C8                   INY                     ;bump index
00107D  1  C8                   INY                     ;by two
00107E  1  D1 A7                CMP     (BASE),Y        ;compare to entry
001080  1  D0 07                BNE     SLOOK2          ;branch if different
001082  1  C6 BD                DEC     LEN             ;drop length
001084  1  D0 F2                BNE     SLOOK1          ;loop for more
001086  1  A9 FF                LDA     #TRUE           ;else say true
001088  1  60                   RTS
001089  1               SLOOK2
001089  1  20 C9 0F             JSR     SETLNK          ;set link
00108C  1  A0 00                LDY     #0              ;clear index
00108E  1  B1 AC                LDA     (APTADD),Y      ;get low
001090  1  48                   PHA                     ;save it
001091  1  C8                   INY                     ;set y to 1
001092  1  B1 AC                LDA     (APTADD),Y      ;get high
001094  1  A8                   TAY                     ;move to Y
001095  1  68                   PLA                     ;get low
001096  1  4C 64 10             JMP     SLOOKX          ;and loop
001099  1               SLOOFL
001099  1  A9 00                LDA     #FALSE          ;was not
00109B  1  60                   RTS                     ;found
00109C  1               ;enter token reference by PRNTNM and SYMHSH into next available location in the
00109C  1               ;symbol table.  set BASE to beginning of this entry and increment SBTBL. check
00109C  1               ;for symbol table full
00109C  1               ENTER
00109C  1  A0 00                LDY     #0              ;clear index
00109E  1  B1 B5                LDA     (PRNTNM),Y      ;get length
0010A0  1  18                   CLC                     ;now
0010A1  1  69 07                ADC     #7              ;add seven
0010A3  1  48                   PHA                     ;save on stack
0010A4  1  20 E9 0F             JSR     LIMITS          ;test limits
0010A7  1  A5 AA                LDA     SBTBL           ;update
0010A9  1  A4 AB                LDY     SBTBL+1         ;base
0010AB  1  85 A7                STA     BASE
0010AD  1  84 A8                STY     BASE+1
0010AF  1  A0 00                LDY     #0              ;get
0010B1  1  B1 B5                LDA     (PRNTNM),Y      ;length
0010B3  1  91 A7                STA     (BASE),Y        ;move to table
0010B5  1  AA                   TAX                     ;make a counter
0010B6  1  F0 0B                BEQ     ENTER1          ;done if zero
0010B8  1  C8                   INY                     ;start with Y=1
0010B9  1               ENTER0
0010B9  1  B1 B5                LDA     (PRNTNM),Y      ;get name
0010BB  1  C8                   INY                     ;bump index
0010BC  1  C8                   INY                     ;by two
0010BD  1  91 AA                STA     (SBTBL),Y       ;insert
0010BF  1  88                   DEY                     ;drop y by one
0010C0  1  CA                   DEX                     ;drop count
0010C1  1  D0 F6                BNE     ENTER0          ;loop if more
0010C3  1               ENTER1
0010C3  1  A9 03                LDA     #3              ;clear resolve bit
0010C5  1  20 D6 0F             JSR     SETADP          ;by getting pointer
0010C8  1  A0 00                LDY     #0              ;clear index
0010CA  1  98                   TYA                     ;and A
0010CB  1  91 AC                STA     (APTADD),Y      ;insert
0010CD  1  20 C9 0F             JSR     SETLNK          ;set link
0010D0  1  20 BE 0F             JSR     HSOSYM          ;find address
0010D3  1  48                   PHA                     ;save low on stack
0010D4  1  98                   TYA                     ;high to A
0010D5  1  A0 01                LDY     #1              ;do high
0010D7  1  91 AC                STA     (APTADD),Y      ;first
0010D9  1  88                   DEY                     ;drop Y
0010DA  1  68                   PLA                     ;get low
0010DB  1  91 AC                STA     (APTADD),Y      ;and set
0010DD  1  A5 B7                LDA     SYMHSH          ;get hash
0010DF  1  0A                   ASL     A               ;mult by two
0010E0  1  AA                   TAX                     ;make index
0010E1  1  A5 A7                LDA     BASE            ;get
0010E3  1  9D 37 2E             STA     HSHTBL,X        ;and move
0010E6  1  A5 A8                LDA     BASE+1          ;to
0010E8  1  9D 38 2E             STA     HSHTBL+1,X      ;table
0010EB  1  68                   PLA                     ;get new length
0010EC  1  18                   CLC                     ;now
0010ED  1  65 AA                ADC     SBTBL           ;to start
0010EF  1  85 AA                STA     SBTBL           ;to get
0010F1  1  90 02                BCC     *+4             ;new
0010F3  1  E6 AB                INC     SBTBL+1         ;table address
0010F5  1  60                   RTS
0010F6  1               ;insert subtype in SBTBL
0010F6  1               SETSUB
0010F6  1  48                   PHA                     ;save code
0010F7  1  A9 06                LDA     #6              ;offset pointer
0010F9  1  20 D6 0F             JSR     SETADP          ;get pointer
0010FC  1  A0 00                LDY     #0              ;clear index
0010FE  1  68                   PLA                     ;get code
0010FF  1  91 AC                STA     (APTADD),Y      ;save
001101  1  60                   RTS
001102  1               ;return the subtype
001102  1               GETSUB
001102  1  A9 06                LDA     #6              ;build
001104  1  20 D6 0F             JSR     SETADP          ;pointer
001107  1  A0 00                LDY     #0              ;clear pointer
001109  1  B1 AC                LDA     (APTADD),Y      ;get subtype
00110B  1  60                   RTS
00110C  1               ;
00110C  1               UNLINK
00110C  1  20 26 10             JSR     GETTYP          ;get type
00110F  1  85 BE                STA     NUMPRM          ;save it
001111  1  A9 01                LDA     #1              ;set index
001113  1  85 BF                STA     LINKI           ;to one
001115  1               UNLNK0
001115  1  A5 BE                LDA     NUMPRM          ;compare limit
001117  1  C5 BF                CMP     LINKI           ;to count
001119  1  B0 01                BCS     *+3             ;continue if ok
00111B  1  60                   RTS                     ;else done
00111C  1  20 08 0F             JSR     NXTENT          ;get next
00111F  1  20 90 0F             JSR     GETHSH          ;and hash
001122  1  0A                   ASL     A               ;mult
001123  1  18                   CLC                     ;by two
001124  1  69 37                ADC     #<HSHTBL        ;and add
001126  1  85 C0                STA     TMPADR          ;hash table start
001128  1  A0 2E                LDY     #>HSHTBL        ;get high
00112A  1  90 01                BCC     *+3             ;with carry
00112C  1  C8                   INY                     ;bump
00112D  1  84 C1                STY     TMPADR+1        ;and save
00112F  1               UNLNK1
00112F  1  A0 00                LDY     #0              ;clear index
001131  1  A5 A7                LDA     BASE            ;compare base low
001133  1  D1 C0                CMP     (TMPADR),Y      ;to byte
001135  1  D0 07                BNE     UNLNK2          ;branch if different
001137  1  C8                   INY                     ;set y to 1
001138  1  A5 A8                LDA     BASE+1          ;do same
00113A  1  D1 C0                CMP     (TMPADR),Y      ;for high
00113C  1  F0 16                BEQ     UNLNK3          ;branch if all same
00113E  1               UNLNK2
00113E  1  A0 00                LDY     #0              ;y back to zero
001140  1  B1 C0                LDA     (TMPADR),Y      ;get low
001142  1  48                   PHA                     ;save it
001143  1  C8                   INY                     ;bump index
001144  1  B1 C0                LDA     (TMPADR),Y      ;get high
001146  1  85 C1                STA     TMPADR+1        ;change address
001148  1  68                   PLA                     ;get low
001149  1  85 C0                STA     TMPADR          ;save it
00114B  1  E6 C0                INC     TMPADR
00114D  1  D0 E0                BNE     UNLNK1
00114F  1  E6 C1                INC     TMPADR+1
001151  1  4C 2F 11             JMP     UNLNK1          ;and loop
001154  1               UNLNK3
001154  1  20 C9 0F             JSR     SETLNK          ;set link
001157  1  A0 00                LDY     #0              ;clear index
001159  1  B1 AC                LDA     (APTADD),Y      ;get low
00115B  1  91 C0                STA     (TMPADR),Y      ;and move
00115D  1  C8                   INY                     ;now
00115E  1  B1 AC                LDA     (APTADD),Y      ;same
001160  1  91 C0                STA     (TMPADR),Y      ;for high
001162  1  E6 BF                INC     LINKI           ;bump loop index
001164  1  4C 15 11             JMP     UNLNK0          ;and loop
001167  1               ;
001167  1               RELINK
001167  1  20 26 10             JSR     GETTYP          ;get type
00116A  1  85 BE                STA     NUMPRM          ;save it
00116C  1  A9 01                LDA     #1              ;set count
00116E  1  85 BF                STA     LINKI           ;to one
001170  1               RELNK0
001170  1  A5 BE                LDA     NUMPRM          ;get limit and
001172  1  C5 BF                CMP     LINKI           ;compare to count
001174  1  B0 01                BCS     *+3             ;branch if >=
001176  1  60                   RTS                     ;else done
001177  1  20 08 0F             JSR     NXTENT          ;do next entry
00117A  1  A5 A7                LDA     BASE            ;now set
00117C  1  A4 A8                LDY     BASE+1          ;temp
00117E  1  85 C0                STA     TMPADR
001180  1  E6 C0                INC     TMPADR          ;bump low
001182  1  D0 01                BNE     *+3
001184  1  C8                   INY
001185  1  84 C1                STY     TMPADR+1        ;save high
001187  1  20 90 0F             JSR     GETHSH          ;get hash
00118A  1  0A                   ASL     A               ;mult by two
00118B  1  AA                   TAX                     ;make index
00118C  1  A0 00                LDY     #0              ;clear Y
00118E  1  BD 37 2E             LDA     HSHTBL,X        ;get low
001191  1  91 C0                STA     (TMPADR),Y      ;save it
001193  1  C8                   INY                     ;now high
001194  1  BD 38 2E             LDA     HSHTBL+1,X      ;get it
001197  1  91 C0                STA     (TMPADR),Y      ;save it
001199  1  20 90 0F             JSR     GETHSH          ;gethash
00119C  1  0A                   ASL     A
00119D  1  AA                   TAX
00119E  1  A5 A7                LDA     BASE            ;now get
0011A0  1  9D 37 2E             STA     HSHTBL,X        ;and put
0011A3  1  A5 A8                LDA     BASE+1          ;new base
0011A5  1  9D 38 2E             STA     HSHTBL+1,X      ;in table
0011A8  1  E6 BF                INC     LINKI           ;bump loop index
0011AA  1  4C 70 11             JMP     RELNK0          ;and loop
0011AD  1               ;initialize SYNTHE
0011AD  1               ;data definitions for initialization
0011AD  1               CONZER
0011AD  1  01 30                .BYTE   1,"0"
0011AF  1               CONONE
0011AF  1  01 31                .BYTE   1,"1"
0011B1  1               INSYN
0011B1  1  A9 00                LDA     #0              ;first
0011B3  1  85 B2                STA     CODESI          ;clear
0011B5  1  85 B3                STA     CODESI+1        ;variables
0011B7  1  85 45                STA     DATACT
0011B9  1  85 46                STA     DATACT+1
0011BB  1  8D 5B 30             STA     ONSP
0011BE  1  8D 36 2E             STA     IFLABL
0011C1  1  85 B1                STA     FDACT+1         ;set fda
0011C3  1  A9 01                LDA     #1              ;count to
0011C5  1  85 B0                STA     FDACT           ;one
0011C7  1  A9 FF                LDA     #$FF            ;set prt
0011C9  1  85 AE                STA     PRTCT           ;count
0011CB  1  85 AF                STA     PRTCT+1         ;to -1
0011CD  1  20 84 09             JSR     SETFLG          ;set flags
0011D0  1  2C FD 2D             BIT     PASS1           ;see if pass 1
0011D3  1  30 01                BMI     *+3             ;branch if is
0011D5  1  60                   RTS                     ;else done
0011D6  1  20 59 09             JSR     SUPINT          ;setup int file
0011D9  1  A9 AF                LDA     #<CONONE        ;initialize
0011DB  1  A0 11                LDY     #>CONONE        ;printname
0011DD  1  85 B5                STA     PRNTNM          ;pointer
0011DF  1  84 B6                STY     PRNTNM+1
0011E1  1  A9 31                LDA     #'1'            ;then
0011E3  1  85 B7                STA     SYMHSH          ;symbol hash
0011E5  1  20 9C 10             JSR     ENTER           ;put in table
0011E8  1  A9 31                LDA     #'1'            ;emit
0011EA  1  20 26 0F             JSR     EMITCN          ;emit
0011ED  1  A9 24                LDA     #'$'            ;do a $
0011EF  1  20 26 0F             JSR     EMITCN
0011F2  1  A9 00                LDA     #0              ;constant 1
0011F4  1  A8                   TAY                     ;is at fda position 0
0011F5  1  20 06 10             JSR     SETRSV          ;set
0011F8  1  A9 04                LDA     #CONST          ;set type
0011FA  1  20 32 10             JSR     SETTYP          ;as constant
0011FD  1  A9 AD                LDA     #<CONZER        ;now
0011FF  1  A0 11                LDY     #>CONZER        ;point
001201  1  85 B5                STA     PRNTNM          ;to
001203  1  84 B6                STY     PRNTNM+1        ;zero
001205  1  A9 30                LDA     #'0'            ;set hash
001207  1  85 B7                STA     SYMHSH          ;to '0'
001209  1  20 9C 10             JSR     ENTER           ;enter it
00120C  1  A9 30                LDA     #'0'            ;now
00120E  1  20 26 0F             JSR     EMITCN          ;output it
001211  1  A9 24                LDA     #'$'            ;do $
001213  1  20 26 0F             JSR     EMITCN
001216  1  A9 01                LDA     #1              ;set address
001218  1  A0 00                LDY     #0
00121A  1  20 06 10             JSR     SETRSV
00121D  1  A9 04                LDA     #CONST          ;and type = const
00121F  1  4C 32 10             JMP     SETTYP          ;then exit
001222  1               ;calculate var(a)+.varc
001222  1               CALVRC
001222  1  AA                   TAX                     ;make index
001223  1  BD D7 2E             LDA     VAR,X           ;get var contents
001226  1  18                   CLC                     ;now add
001227  1  69 F7                ADC     #<VARC          ;varc start
001229  1  A0 2F                LDY     #>VARC          ;with carry
00122B  1  90 01                BCC     *+3
00122D  1  C8                   INY
00122E  1  60                   RTS
00122F  1               ;setlookup
00122F  1               STLKUP
00122F  1  48                   PHA                     ;save param
001230  1  20 22 12             JSR     CALVRC          ;calculate varc
001233  1  85 B5                STA     PRNTNM          ;save as printname
001235  1  84 B6                STY     PRNTNM+1        ;position
001237  1  68                   PLA                     ;get param
001238  1  AA                   TAX                     ;make index
001239  1  BD B7 2E             LDA     HASH,X          ;get entry
00123C  1  85 B7                STA     SYMHSH          ;and set symbols
00123E  1  60                   RTS
00123F  1               ;lookup$only
00123F  1               LKONLY
00123F  1  20 2F 12             JSR     STLKUP          ;set up
001242  1  4C 61 10             JMP     SLOOKU          ;try to lookup
001245  1               ;normal$lookup
001245  1               NRMLKU
001245  1  20 3F 12             JSR     LKONLY          ;call lookup$only
001248  1  F0 01                BEQ     *+3             ;if false
00124A  1  60                   RTS                     ;else done
00124B  1  20 9C 10             JSR     ENTER           ;enter in table
00124E  1  A9 00                LDA     #FALSE          ;then done
001250  1  60                   RTS
001251  1               ;count size of the prt and return with count in AY
001251  1               CNTPRT
001251  1  E6 AE                INC     PRTCT           ;bump
001253  1  D0 02                BNE     *+4
001255  1  E6 AF                INC     PRTCT+1
001257  1  A5 AE                LDA     PRTCT           ;and get
001259  1  A4 AF                LDY     PRTCT+1
00125B  1  60                   RTS
00125C  1               ;setifname
00125C  1               SETIFN
00125C  1  A9 34                LDA     #<IFLBLN        ;point to printname
00125E  1  A0 2E                LDY     #>IFLBLN
001260  1  85 B5                STA     PRNTNM
001262  1  84 B6                STY     PRNTNM+1
001264  1  AD 36 2E             LDA     IFLABL          ;set symhash
001267  1  29 3F                AND     #HSHMSK
001269  1  85 B7                STA     SYMHSH
00126B  1  60                   RTS
00126C  1               ;enter$compiler$label(a)
00126C  1               ENCMLB
00126C  1  2C FD 2D             BIT     PASS1           ;test for pass 1
00126F  1  30 01                BMI     *+3             ;branch if is
001271  1  60                   RTS
001272  1  48                   PHA                     ;save parameter
001273  1  20 5C 12             JSR     SETIFN          ;call setifname
001276  1  20 9C 10             JSR     ENTER           ;call enter
001279  1  68                   PLA                     ;get param
00127A  1  18                   CLC                     ;add to codesize
00127B  1  65 B2                ADC     CODESI
00127D  1  A4 B3                LDY     CODESI+1
00127F  1  90 01                BCC     *+3
001281  1  C8                   INY                     ;with carry
001282  1  4C 06 10             JMP     SETRSV          ;call setaddr(codesize+a)
001285  1               ;set$compiler$label
001285  1               STCMLB
001285  1  EE 36 2E             INC     IFLABL          ;bump iflable
001288  1  20 5C 12             JSR     SETIFN          ;call setifname
00128B  1  4C 61 10             JMP     SLOOKU          ;call "s"lookup
00128E  1               ;compiler$label
00128E  1               COMLBL
00128E  1  20 85 12             JSR     STCMLB          ;call set$compiler$label
001291  1  20 51 10             JSR     GETADR
001294  1  4C 2F 0F             JMP     GENTWO          ;call gen$two(getaddr)
001297  1               ;check for mp and sp both floating point
001297  1               CHKTY1
001297  1  A5 85                LDA     STYPMP          ;get stypemp
001299  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
00129B  1  D0 09                BNE     DOC1MF          ;error if not
00129D  1  A5 83                LDA     STYPSP          ;get stypesp
00129F  1  C9 31                CMP     #FLOTPT         ;see if = floatpt
0012A1  1  D0 03                BNE     DOC1MF          ;error if not
0012A3  1  A9 FF                LDA     #TRUE
0012A5  1  60                   RTS
0012A6  1               DOC1MF
0012A6  1  20 D1 12             JSR     MFERR           ;error
0012A9  1  A9 00                LDA     #FALSE
0012AB  1  60                   RTS
0012AC  1               ;check mp and sp both same type
0012AC  1               CHKTY2
0012AC  1  A5 83                LDA     STYPSP          ;get stypesp
0012AE  1  C5 85                CMP     STYPMP          ;see if stypemp same
0012B0  1  D0 03                BNE     *+5             ;error if not
0012B2  1  A9 FF                LDA     #TRUE
0012B4  1  60                   RTS
0012B5  1  A9 0D                LDA     #13             ;mixed mode error
0012B7  1  20 AB 0A             JSR     ERROR
0012BA  1  A9 00                LDA     #FALSE
0012BC  1  60                   RTS
0012BD  1               ;chktyp3
0012BD  1               CHKTY3
0012BD  1  A5 83                LDA     STYPSP          ;get stypesp
0012BF  1  20 CE 0C             JSR     STSTMP          ;call setstypemp(stypesp)
0012C2  1  A5 83                LDA     STYPSP          ;get stypesp
0012C4  1  C9 31                CMP     #FLOTPT         ;see if floating
0012C6  1  D0 03                BNE     *+5             ;error if not
0012C8  1  A9 FF                LDA     #TRUE
0012CA  1  60                   RTS
0012CB  1  20 D1 12             JSR     MFERR           ;must be floating error
0012CE  1  A9 00                LDA     #FALSE
0012D0  1  60                   RTS
0012D1  1               ;must be floating point error
0012D1  1               MFERR
0012D1  1  A9 0C                LDA     #12
0012D3  1  4C AB 0A             JMP     ERROR
0012D6  1               ;chktyp4
0012D6  1               CHKTY4
0012D6  1  A5 84                LDA     STYPM1          ;get stypemp1
0012D8  1  C9 32                CMP     #STRING         ;see if string
0012DA  1  D0 03                BNE     *+5             ;ok if not
0012DC  1  20 D1 12             JSR     MFERR           ;else must be floating error
0012DF  1  A9 5B                LDA     #RON
0012E1  1  4C F4 0C             JMP     GENERT          ;call generate(ron)
0012E4  1               ;chktyp5
0012E4  1               CHKTY5
0012E4  1  20 D6 12             JSR     CHKTY4          ;call chktyp4
0012E7  1  E6 82                INC     TYPEMP          ;bump typemp
0012E9  1  A5 82                LDA     TYPEMP
0012EB  1  4C D4 0C             JMP     STTYMP          ;call settypemp(typemp:=typemp+1)
0012EE  1               ;subcalc
0012EE  1               SUBCAL
0012EE  1  A5 80                LDA     TYPESP          ;get type
0012F0  1  20 F6 10             JSR     SETSUB          ;call setsubtype(typesp)
0012F3  1  A9 20                LDA     #ROW
0012F5  1  20 F4 0C             JSR     GENERT          ;call generate(row)
0012F8  1  A5 80                LDA     TYPESP
0012FA  1  20 F4 0C             JSR     GENERT          ;call generate(typesp)
0012FD  1  A9 14                LDA     #STD
0012FF  1  4C F4 0C             JMP     GENERT          ;call generate(std)
001302  1               ;gen$store
001302  1               GENSTR
001302  1  A5 84                LDA     STYPM1          ;get stypemp1
001304  1  C9 31                CMP     #FLOTPT         ;see if floating
001306  1  D0 05                BNE     *+7             ;branch if not
001308  1  A9 14                LDA     #STD
00130A  1  4C F4 0C             JMP     GENERT          ;call generate(std)
00130D  1  A9 1B                LDA     #STS
00130F  1  4C F4 0C             JMP     GENERT          ;call generate(sts)
001312  1               ;setup$input
001312  1               SEINPU
001312  1  A9 FF                LDA     #TRUE
001314  1  85 47                STA     INPSTM          ;inputstmt=true
001316  1  A9 3B                LDA     #RCN
001318  1  4C F4 0C             JMP     GENERT          ;call generate(rcn)
00131B  1               ;gen$read(a,y)
00131B  1               GENRDE
00131B  1  A6 83                LDX     STYPSP          ;get stypesp
00131D  1  E0 32                CPX     #STRING         ;see if string
00131F  1  D0 08                BNE     *+10            ;branch if not
001321  1  20 F4 0C             JSR     GENERT          ;call generate(i)
001324  1  A9 1B                LDA     #STS
001326  1  4C F4 0C             JMP     GENERT          ;call generate(sts)
001329  1  98                   TYA
00132A  1  20 F4 0C             JSR     GENERT          ;call generate(y)
00132D  1  A9 14                LDA     #STD
00132F  1  4C F4 0C             JMP     GENERT          ;call generate(std)
001332  1               ;get$field
001332  1               GETFLD
001332  1  A5 80                LDA     TYPESP          ;get typesp
001334  1  C9 00                CMP     #SIMVAR         ;see if simple variable
001336  1  D0 07                BNE     *+9             ;skip if not
001338  1  A5 86                LDA     SYMLSP
00133A  1  A4 87                LDY     SYMLSP+1
00133C  1  20 38 0F             JSR     LITERL          ;call literal(symlocsp)
00133F  1  24 47                BIT     INPSTM          ;test inputstmt
001341  1  10 07                BPL     *+9             ;branch if not
001343  1  A9 31                LDA     #RES
001345  1  A0 22                LDY     #RDV
001347  1  4C 1B 13             JMP     GENRDE          ;call gen$read(res,rdv)
00134A  1  2C 08 2E             BIT     FILEIO          ;see if file io
00134D  1  10 07                BPL     *+9             ;branch if not
00134F  1  A9 2A                LDA     #RDS
001351  1  A0 29                LDY     #RDN
001353  1  4C 1B 13             JMP     GENRDE          ;call gen$read(rds,rdn)
001356  1  A9 3C                LDA     #DRS
001358  1  A0 3D                LDY     #DRF
00135A  1  4C 1B 13             JMP     GENRDE          ;call gen$read(drs,drf)
00135D  1               ;gen$on
00135D  1               GENON
00135D  1  A9 5B                LDA     #RON
00135F  1  20 F4 0C             JSR     GENERT          ;call generate(ron)
001362  1  EE 5B 30             INC     ONSP
001365  1  AE 5B 30             LDX     ONSP            ;get as index
001368  1  BD 5B 30             LDA     ONSTAK,X        ;get entry
00136B  1  A0 00                LDY     #0              ;high always clear
00136D  1  20 38 0F             JSR     LITERL          ;call(onstack(onsp:=onsp+1))
001370  1  A9 5C                LDA     #CKO
001372  1  20 F4 0C             JSR     GENERT          ;call generate(cko)
001375  1  A9 39                LDA     #BFN
001377  1  4C F4 0C             JMP     GENERT          ;call generate(bfn)
00137A  1               ;gen$on$2
00137A  1               GENON2
00137A  1  A5 80                LDA     TYPESP
00137C  1  AE 5B 30             LDX     ONSP
00137F  1  9D 5B 30             STA     ONSTAK,X
001382  1  60                   RTS
001383  1               ;gennext
001383  1               GENNXT
001383  1  C6 A9                DEC     FORCNT          ;drop forcount
001385  1  A5 A9                LDA     FORCNT          ;get it
001387  1  C9 FF                CMP     #255            ;see if wrap
001389  1  D0 07                BNE     *+9             ;branch if ok
00138B  1  E6 A9                INC     FORCNT          ;set to 0
00138D  1  A9 10                LDA     #16             ;next w/o for error
00138F  1  4C AB 0A             JMP     ERROR
001392  1  A9 36                LDA     #BRS
001394  1  20 F4 0C             JSR     GENERT          ;call generate(brs)
001397  1  A0 04                LDY     #2*2            ;word addressing
001399  1  B1 B9                LDA     (NXSTPT),Y      ;get low
00139B  1  48                   PHA                     ;save
00139C  1  C8                   INY
00139D  1  B1 B9                LDA     (NXSTPT),Y      ;get high
00139F  1  A8                   TAY                     ;move to Y
0013A0  1  68                   PLA                     ;get low
0013A1  1  20 2F 0F             JSR     GENTWO          ;call gen$two(nextaddress(2))
0013A4  1  A0 00                LDY     #0*2            ;still word addressing
0013A6  1  A5 B2                LDA     CODESI
0013A8  1  91 B9                STA     (NXSTPT),Y      ;put
0013AA  1  C8                   INY
0013AB  1  A5 B3                LDA     CODESI+1        ;do high
0013AD  1  09 80                ORA     #$80            ;set msb
0013AF  1  91 B9                STA     (NXSTPT),Y      ;insert
0013B1  1               GENNX0
0013B1  1  A0 01                LDY     #1              ;set index to 1
0013B3  1  B1 B9                LDA     (NXSTPT),Y      ;get nextbytev(1)
0013B5  1  30 01                BMI     *+3             ;continue if > 127
0013B7  1  60                   RTS
0013B8  1  18                   CLC                     ;now add 8 to nextstmtptr
0013B9  1  A5 B9                LDA     NXSTPT
0013BB  1  69 08                ADC     #8
0013BD  1  85 B9                STA     NXSTPT
0013BF  1  90 F0                BCC     GENNX0
0013C1  1  E6 BA                INC     NXSTPT+1
0013C3  1  4C B1 13             JMP     GENNX0
0013C6  1               ;gen$next$with$ident
0013C6  1               GENWID
0013C6  1  A5 7D                LDA     MPP1            ;get mpp1
0013C8  1  20 3F 12             JSR     LKONLY
0013CB  1  F0 12                BEQ     GENWIE          ;branch if false
0013CD  1  A0 06                LDY     #3*2            ;word addressing
0013CF  1  B1 B9                LDA     (NXSTPT),Y      ;get low
0013D1  1  C5 A7                CMP     BASE            ;compare to low base
0013D3  1  D0 0A                BNE     GENWIE          ;error if different
0013D5  1  C8                   INY
0013D6  1  B1 B9                LDA     (NXSTPT),Y      ;same for high
0013D8  1  C5 A8                CMP     BASE+1
0013DA  1  D0 03                BNE     GENWIE
0013DC  1  4C 83 13             JMP     GENNXT          ;else ok
0013DF  1               GENWIE
0013DF  1  A9 0E                LDA     #14             ;next does not match for
0013E1  1  4C AB 0A             JMP     ERROR
0013E4  1               ;check$ul$error
0013E4  1               CHKULE
0013E4  1  24 B4                BIT     ULERFL          ;test flag
0013E6  1  10 05                BPL     *+7             ;branch if clear
0013E8  1  A9 14                LDA     #20             ;else undefined label
0013EA  1  20 AB 0A             JSR     ERROR
0013ED  1  A9 00                LDA     #FALSE          ;now clear flag
0013EF  1  85 B4                STA     ULERFL
0013F1  1  60                   RTS
0013F2  1               ;findlabel
0013F2  1               FNDLBL
0013F2  1  A5 7B                LDA     SP              ;get sp
0013F4  1  20 45 12             JSR     NRMLKU          ;normal$lookup(sp)
0013F7  1  D0 01                BNE     *+3             ;if true
0013F9  1  60                   RTS
0013FA  1  2C FE 2D             BIT     PASS2           ;if pass2
0013FD  1  30 01                BMI     *+3             ;then
0013FF  1  60                   RTS
001400  1  20 40 10             JSR     GETRES          ;if not getres
001403  1  F0 01                BEQ     *+3             ;then
001405  1  60                   RTS
001406  1  A9 FF                LDA     #TRUE
001408  1  85 B4                STA     ULERFL          ;ulerrorflag=true
00140A  1  60                   RTS
00140B  1               ;resolve$label
00140B  1               RESLBL
00140B  1  20 F2 13             JSR     FNDLBL          ;findlabel
00140E  1  A9 1E                LDA     #PRO            ;preset for true
001410  1  24 48                BIT     GSBSTM          ;test gosubstmt
001412  1  30 02                BMI     *+4             ;if true
001414  1  A9 36                LDA     #BRS            ;else
001416  1  20 F4 0C             JSR     GENERT          ;generate( )
001419  1  20 51 10             JSR     GETADR
00141C  1  4C 2F 0F             JMP     GENTWO          ;gen$two(getaddr)
00141F  1               ;process$simple$variable
00141F  1               PSIMPV
00141F  1  20 45 12             JSR     NRMLKU          ;normal$lookup
001422  1  F0 0F                BEQ     PSIMP0          ;if false then
001424  1  20 26 10             JSR     GETTYP          ;if getype
001427  1  C9 00                CMP     #SIMVAR         ;= simvar
001429  1  F0 13                BEQ     PSIMP1          ;then
00142B  1  A9 0B                LDA     #11             ;array name used as simple variable
00142D  1  20 AB 0A             JSR     ERROR
001430  1  4C 3E 14             JMP     PSIMP1          ;continue
001433  1               PSIMP0
001433  1  20 51 12             JSR     CNTPRT
001436  1  20 06 10             JSR     SETRSV          ;setaddr(countprt)
001439  1  A9 00                LDA     #SIMVAR
00143B  1  20 32 10             JSR     SETTYP          ;setype(simvar)
00143E  1               PSIMP1
00143E  1  20 51 10             JSR     GETADR
001441  1  85 86                STA     SYMLSP
001443  1  84 87                STY     SYMLSP+1        ;symlocsp=getaddr
001445  1  20 AE 0C             JSR     STSLSP          ;setsymlocsp( )
001448  1  A9 00                LDA     #SIMVAR
00144A  1  20 C2 0C             JSR     STTYSP          ;settypesp(simvar)
00144D  1  2C 07 2E             BIT     FORSTM          ;if forstmt
001450  1  30 01                BMI     *+3             ;then
001452  1  60                   RTS
001453  1  A9 00                LDA     #FALSE
001455  1  8D 07 2E             STA     FORSTM          ;forstmt=false
001458  1  A0 06                LDY     #3*2            ;word addressing
00145A  1  A5 A7                LDA     BASE
00145C  1  91 A5                STA     (SBTTOP),Y
00145E  1  C8                   INY
00145F  1  A5 A8                LDA     BASE+1
001461  1  91 A5                STA     (SBTTOP),Y      ;foraddress(3)=base
001463  1  60                   RTS
001464  1               ;gen$ils
001464  1               GENILS
001464  1  85 C2                STA     WHERE
001466  1  84 C3                STY     WHERE+1         ;save parameter
001468  1  A9 32                LDA     #STRING
00146A  1  20 C8 0C             JSR     STSTSP          ;setstypesp(string)
00146D  1  A9 1C                LDA     #ILS
00146F  1  20 F4 0C             JSR     GENERT          ;generate(ils)
001472  1               GENIL0
001472  1  A9 01                LDA     #1
001474  1  85 C4                STA     STRPTR          ;strptr=1
001476  1               GENIL1
001476  1  A0 00                LDY     #0
001478  1  B1 C2                LDA     (WHERE),Y       ;if stringtospool(0)
00147A  1  C5 C4                CMP     STRPTR          ;< strptr
00147C  1  90 0C                BCC     GENIL2          ;then
00147E  1  A4 C4                LDY     STRPTR
001480  1  B1 C2                LDA     (WHERE),Y       ;stringtospool(strptr)
001482  1  20 F4 0C             JSR     GENERT          ;generate
001485  1  E6 C4                INC     STRPTR          ;strptr=strptr+1
001487  1  4C 76 14             JMP     GENIL1
00148A  1               GENIL2
00148A  1  24 6E                BIT     CONT            ;if not cont
00148C  1  10 06                BPL     *+8             ;then
00148E  1  20 98 0D             JSR     SCANNR          ;scanner
001491  1  4C 72 14             JMP     GENIL0
001494  1  A9 00                LDA     #0
001496  1  4C F4 0C             JMP     GENERT          ;generate(0)
001499  1               ;gencon
001499  1               GENCON
001499  1  A9 2E                LDA     #CON
00149B  1  20 F4 0C             JSR     GENERT          ;generate(con)
00149E  1  A9 04                LDA     #CONST
0014A0  1  20 C2 0C             JSR     STTYSP          ;settypesp(const)
0014A3  1  A9 31                LDA     #FLOTPT
0014A5  1  20 C8 0C             JSR     STSTSP          ;setstypesp(floatpt)
0014A8  1  A5 7B                LDA     SP
0014AA  1  20 3F 12             JSR     LKONLY          ;lookup$only(sp)
0014AD  1  F0 0D                BEQ     GENCO0          ;if false then
0014AF  1  20 26 10             JSR     GETTYP          ;if getype
0014B2  1  C9 04                CMP     #CONST          ;<> const
0014B4  1  D0 06                BNE     GENCO0          ;then
0014B6  1  20 51 10             JSR     GETADR
0014B9  1  4C 2F 0F             JMP     GENTWO          ;gen$two(getaddr)
0014BC  1               GENCO0
0014BC  1  A9 01                LDA     #1
0014BE  1  85 C5                STA     IGEN            ;igen=1
0014C0  1               GENCO1
0014C0  1  A5 4E                LDA     ACCLEN
0014C2  1  C5 C5                CMP     IGEN            ;if igen>acclen
0014C4  1  90 0C                BCC     GENCO2          ;then
0014C6  1  A6 C5                LDX     IGEN
0014C8  1  B5 4E                LDA     ACCUM,X
0014CA  1  20 26 0F             JSR     EMITCN          ;emitcon(accum(i))
0014CD  1  E6 C5                INC     IGEN            ;i=i+1
0014CF  1  4C C0 14             JMP     GENCO1
0014D2  1               GENCO2
0014D2  1  A9 24                LDA     #'$'
0014D4  1  20 26 0F             JSR     EMITCN          ;emitcon('$')
0014D7  1  E6 B0                INC     FDACT
0014D9  1  D0 02                BNE     *+4
0014DB  1  E6 B1                INC     FDACT+1         ;fdact=fdact+1
0014DD  1  A5 B0                LDA     FDACT
0014DF  1  A4 B1                LDY     FDACT+1
0014E1  1  4C 2F 0F             JMP     GENTWO          ;gen$two(fdact)
0014E4  1               ;put$field
0014E4  1               PUTFLD
0014E4  1  2C 08 2E             BIT     FILEIO          ;if not fileio
0014E7  1  10 10                BPL     NTFLIO          ;then
0014E9  1  A5 83                LDA     STYPSP          ;if stypesp
0014EB  1  C9 31                CMP     #FLOTPT         ;<> floatpt
0014ED  1  D0 05                BNE     *+7             ;then
0014EF  1  A9 2B                LDA     #WRN
0014F1  1  4C F4 0C             JMP     GENERT          ;generate(wrn)
0014F4  1  A9 2C                LDA     #WRS
0014F6  1  4C F4 0C             JMP     GENERT          ;generate(wrs)
0014F9  1               NTFLIO
0014F9  1  A5 83                LDA     STYPSP          ;if stypesp
0014FB  1  C9 31                CMP     #FLOTPT         ;= floatpt
0014FD  1  F0 05                BEQ     *+7             ;then
0014FF  1  A9 24                LDA     #WST
001501  1  4C F4 0C             JMP     GENERT          ;generate(wst)
001504  1  A5 80                LDA     TYPESP          ;if typesp
001506  1  C9 4A                CMP     #74             ;not a tab
001508  1  D0 01                BNE     *+3             ;then
00150A  1  60                   RTS
00150B  1  A9 23                LDA     #WRV
00150D  1  4C F4 0C             JMP     GENERT          ;generate(wrv)
001510  1               ;gen$parm
001510  1               GENPRM
001510  1  A5 82                LDA     TYPEMP
001512  1  C9 0A                CMP     #UNFUNC         ;if typemp = unfunc
001514  1  F0 01                BEQ     *+3             ;then
001516  1  60                   RTS
001517  1  A5 8A                LDA     SYMLMP
001519  1  A4 8B                LDY     SYMLMP+1
00151B  1  85 A7                STA     BASE
00151D  1  84 A8                STY     BASE+1          ;base=symlocmp
00151F  1  20 08 0F             JSR     NXTENT          ;nextentry
001522  1  A5 A7                LDA     BASE
001524  1  A4 A8                LDY     BASE+1
001526  1  20 BC 0C             JSR     STSLMP          ;setsymlocmp(base)
001529  1  C6 8E                DEC     HASHMP
00152B  1  A5 8E                LDA     HASHMP
00152D  1  20 DA 0C             JSR     STHAMP          ;sethashmp(hashmp:=hashmp-1)
001530  1  20 51 10             JSR     GETADR
001533  1  4C 38 0F             JMP     LITERL          ;literal(getaddr)
001536  1               ;checkparm
001536  1               CHKPRM
001536  1  A5 82                LDA     TYPEMP
001538  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
00153A  1  D0 17                BNE     NTUNFN          ;then
00153C  1  A5 8A                LDA     SYMLMP
00153E  1  A4 8B                LDY     SYMLMP+1
001540  1  85 A7                STA     BASE
001542  1  84 A8                STY     BASE+1          ;base=symlocmp
001544  1  20 02 11             JSR     GETSUB          ;getsubtype
001547  1  C5 84                CMP     STYPM1          ;if = stypemp1
001549  1  F0 05                BEQ     *+7             ;then
00154B  1  A9 05                LDA     #5              ;else invalid parameter type in function ref
00154D  1  20 AB 0A             JSR     ERROR
001550  1  4C 02 13             JMP     GENSTR          ;gen$store
001553  1               NTUNFN
001553  1  A9 01                LDA     #1
001555  1  A4 84                LDY     STYPM1          ;if stypemp1
001557  1  C0 31                CPY     #FLOTPT         ;<> floatpt
001559  1  D0 02                BNE     *+4             ;then
00155B  1  A9 00                LDA     #FALSE
00155D  1  45 8E                EOR     HASHMP          ;xor hashmp
00155F  1  29 01                AND     #1              ;test lsb only
001561  1  F0 05                BEQ     *+7             ;if true
001563  1  A9 05                LDA     #5              ;invalid type in function parameter list
001565  1  20 AB 0A             JSR     ERROR
001568  1  A5 8E                LDA     HASHMP
00156A  1  4A                   LSR     A               ;shr(hashmp,1)
00156B  1  20 DA 0C             JSR     STHAMP          ;sethashmp
00156E  1  C6 85                DEC     STYPMP
001570  1  A5 85                LDA     STYPMP
001572  1  4C CE 0C             JMP     STSTMP          ;setstypemp(stypemp=stypemp-1)
001575  1               ;funcgen
001575  1               FNCGEN
001575  1  A5 82                LDA     TYPEMP
001577  1  C9 0A                CMP     #UNFUNC         ;if typemp <> unfunc
001579  1  D0 1C                BNE     NOFNGN          ;then
00157B  1  A5 8E                LDA     HASHMP          ;if hashmp=0
00157D  1  F0 05                BEQ     *+7             ;then
00157F  1  A9 04                LDA     #4              ;incorrect number parameters
001581  1  20 AB 0A             JSR     ERROR
001584  1  A9 1E                LDA     #PRO
001586  1  20 F4 0C             JSR     GENERT          ;generate(pro)
001589  1  A5 8F                LDA     SRLOSP
00158B  1  A4 90                LDY     SRLOSP+1
00158D  1  85 A7                STA     BASE
00158F  1  84 A8                STY     BASE+1          ;base=srlocsp
001591  1  20 51 10             JSR     GETADR
001594  1  4C 2F 0F             JMP     GENTWO          ;gen$two(getaddr)
001597  1               NOFNGN
001597  1  A5 85                LDA     STYPMP
001599  1  29 03                AND     #3              ;if stypemp and 3 = 0
00159B  1  F0 05                BEQ     *+7             ;then
00159D  1  A9 04                LDA     #4              ;incorrect number parameters
00159F  1  20 AB 0A             JSR     ERROR
0015A2  1  A5 82                LDA     TYPEMP
0015A4  1  20 F4 0C             JSR     GENERT          ;generate(typemp)
0015A7  1  A5 85                LDA     STYPMP
0015A9  1  29 40                AND     #%01000000      ;if not rol(stypemp,2)
0015AB  1  F0 05                BEQ     *+7             ;then
0015AD  1  A9 32                LDA     #STRING
0015AF  1  4C CE 0C             JMP     STSTMP          ;setstypemp(string)
0015B2  1  A9 31                LDA     #FLOTPT
0015B4  1  4C CE 0C             JMP     STSTMP          ;setstypemp(floatpt)
0015B7  1               ;enter$parm
0015B7  1               ENTRPR
0015B7  1  2C FD 2D             BIT     PASS1           ;if pass 1
0015BA  1  30 01                BMI     *+3             ;then
0015BC  1  60                   RTS
0015BD  1  A5 7D                LDA     MPP1
0015BF  1  20 2F 12             JSR     STLKUP          ;setlookup(mpp1)
0015C2  1  20 9C 10             JSR     ENTER
0015C5  1  20 51 12             JSR     CNTPRT
0015C8  1  20 06 10             JSR     SETRSV          ;setaddr(countprt)
0015CB  1  A5 84                LDA     STYPM1
0015CD  1  20 F6 10             JSR     SETSUB          ;setsubtype(stypemp1)
0015D0  1  A9 00                LDA     #SIMVAR
0015D2  1  20 32 10             JSR     SETTYP          ;setype(simvar)
0015D5  1  A6 82                LDX     TYPEMP
0015D7  1  E8                   INX
0015D8  1  8A                   TXA
0015D9  1  4C D4 0C             JMP     STTYMP          ;settypemp(typemp+1)
0015DC  1               ;synthesis
0015DC  1               ;main code generation routine
0015DC  1               SYNTHE
0015DC  1  85 B8                STA     PRODCT          ;save production
0015DE  1  AD FE 2D             LDA     PASS2           ;if not pass 2
0015E1  1  2D FF 2D             AND     LSTPRD          ;and listprod
0015E4  1  F0 11                BEQ     NPPROD          ;then
0015E6  1  A9 8C                LDA     #<PRDMSG
0015E8  1  A0 2D                LDY     #>PRDMSG
0015EA  1  20 FC 08             JSR     PRNMSG          ;print message
0015ED  1  A5 B8                LDA     PRODCT
0015EF  1  A0 00                LDY     #0
0015F1  1  20 70 08             JSR     PRNDEC          ;print number
0015F4  1  20 34 08             JSR     CRLF
0015F7  1               NPPROD
0015F7  1  20 3F 0C             JSR     SCOPY           ;set up simple variables
0015FA  1  A5 B8                LDA     PRODCT          ;get number
0015FC  1  0A                   ASL     A               ;make word index
0015FD  1  AA                   TAX                     ;make index
0015FE  1  B0 0F                BCS     GT127           ;branch if > 127
001600  1  BD 1E 16             LDA     PRODL,X
001603  1  8D 0D 16             STA     JPROD+1
001606  1  BD 1F 16             LDA     PRODL+1,X
001609  1  8D 0E 16             STA     JPROD+2         ;set address
00160C  1               JPROD
00160C  1  4C FF FF             JMP     $FFFF           ;do it
00160F  1               GT127
00160F  1  BD 1E 17             LDA     PRODH,X
001612  1  8D 0D 16             STA     JPROD+1
001615  1  BD 1F 17             LDA     PRODH+1,X
001618  1  8D 0E 16             STA     JPROD+2
00161B  1  4C 0C 16             JMP     JPROD           ;same for high
00161E  1               ;production jump table for 0 - 127
00161E  1               PRODL
00161E  1  50 17 50 17          .WORD   PRN,PRN,PR2,PR3,CHKULE,CHKULE,PRN,PRN
001622  1  51 17 86 17  
001626  1  E4 13 E4 13  
00162E  1  50 17 50 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001632  1  50 17 50 17  
001636  1  50 17 50 17  
00163E  1  50 17 50 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PRN,PRN
001642  1  50 17 50 17  
001646  1  50 17 50 17  
00164E  1  50 17 50 17          .WORD   PRN,PRN,PRN,PRN,PRN,PRN,PR30,PR31
001652  1  50 17 50 17  
001656  1  50 17 50 17  
00165E  1  50 17 A4 17          .WORD   PRN,PR33,PR34,PR35,PRN,PR37,PRN,PR39
001662  1  AF 17 B4 17  
001666  1  50 17 B9 17  
00166E  1  50 17 CF 17          .WORD   PRN,PR41,PRN,PR43,PR44,CHKTY3,PR46,PRN
001672  1  50 17 ED 17  
001676  1  00 18 BD 12  
00167E  1  16 18 21 18          .WORD   PR48,PR49,PRN,PR51,PR52,PRN,PRN,PR55
001682  1  50 17 2C 18  
001686  1  37 18 50 17  
00168E  1  4E 18 53 18          .WORD   PR56,PR57,PR58,CHKTY5,PR60,FNCGEN,GENPRM,PR63
001692  1  84 18 E4 12  
001696  1  A3 18 75 15  
00169E  1  B7 18 DC 18          .WORD   PR64,PR65,GENCON,PR67,PR68,PR69,PR69,PR71
0016A2  1  99 14 EA 18  
0016A6  1  F1 18 F6 18  
0016AE  1  FB 18 00 19          .WORD   PR71,PR73,PR74,PR75,PR75,PR77,PR78,PR79
0016B2  1  05 19 0A 19  
0016B6  1  0A 19 0F 19  
0016BE  1  DE 19 E3 19          .WORD   PR80,PR81,PR82,PR82,PR84,PRN,RESLBL,PR87
0016C2  1  04 1A 04 1A  
0016C6  1  09 1A 50 17  
0016CE  1  29 1A 3C 1A          .WORD   PR88,PR89,PR90,ENTRPR,PR92,PR92,ENTRPR,PRN
0016D2  1  61 1A B7 15  
0016D6  1  93 1A 93 1A  
0016DE  1  50 17 50 17          .WORD   PRN,PRN,PR98,CHKTY4,PR100,PRN,SUBCAL,SUBCAL
0016E2  1  98 1A D6 12  
0016E6  1  B4 1A 50 17  
0016EE  1  BA 1A C6 1A          .WORD   PR104,PR105,CHKTY5,PRN,PR108,PR108,PR110,PRN
0016F2  1  E4 12 50 17  
0016F6  1  F9 1A F9 1A  
0016FE  1  1C 1B 26 1B          .WORD   PR112,PR113,SEINPU,GETFLD,GETFLD,PR117,PRN,PR119
001702  1  12 13 32 13  
001706  1  32 13 16 1B  
00170E  1  E4 14 E4 14          .WORD   PUTFLD,PUTFLD,PRN,PUTFLD,PUTFLD,PRN,PR126,PR127
001712  1  50 17 E4 14  
001716  1  E4 14 50 17  
00171E  1               ;production jump table for 128 - 255
00171E  1               PRODH
00171E  1  4B 1B 50 17          .WORD   PR128,PRN,PR130,RESLBL,GENON2,PR133,GENON,PR135
001722  1  64 1B 0B 14  
001726  1  7A 13 6F 1B  
00172E  1  8D 1B 95 1B          .WORD   PR136,PR137,PR138,PRN,PRN,PRN,PRN,GENWID
001732  1  9F 1B 50 17  
001736  1  50 17 50 17  
00173E  1  83 13 50 17          .WORD   GENNXT,PRN,GENWID,PR147,PR148,PR149,PR150,PR151
001742  1  C6 13 AB 1B  
001746  1  CC 1B D1 1B  
00174E  1  43 1C                .WORD   PR152
001750  1               ;productions not already defined by single no-parameter subroutines
001750  1               PRN
001750  1  60                   RTS                     ;do nothing - used a lot !!!!
001751  1               ;2	<line number>::=<number>
001751  1               PR2
001751  1  A5 7B                LDA     SP
001753  1  20 3F 12             JSR     LKONLY          ;lookup$only(sp)
001756  1  F0 27                BEQ     PR2D            ;if false
001758  1  20 40 10             JSR     GETRES          ;see if resolved
00175B  1  F0 13                BEQ     PR2C            ;if not
00175D  1  20 51 10             JSR     GETADR          ;getaddr
001760  1  C5 B2                CMP     CODESI          ;try low
001762  1  D0 04                BNE     PR2A            ;error if <>
001764  1  C4 B3                CPY     CODESI+1
001766  1  F0 05                BEQ     *+7             ;ok if same
001768  1               PR2A
001768  1  A9 00                LDA     #0              ;duplicate labels
00176A  1  20 AB 0A             JSR     ERROR
00176D  1  4C 4A 0F             JMP     LINENU
001770  1               PR2C
001770  1  A5 B2                LDA     CODESI
001772  1  A4 B3                LDY     CODESI+1
001774  1  20 06 10             JSR     SETRSV          ;setaddr(codesize)
001777  1  A9 08                LDA     #LABLE
001779  1  20 32 10             JSR     SETTYP          ;setype(lable)
00177C  1  4C 4A 0F             JMP     LINENU
00177F  1               PR2D
00177F  1  A9 2A                LDA     #'*'
001781  1  85 74                STA     SEPRTR          ;separator=astrik
001783  1  4C 4A 0F             JMP     LINENU
001786  1               ;3	|
001786  1               PR3
001786  1  A9 3A                LDA     #':'            ;set separator
001788  1  85 74                STA     SEPRTR
00178A  1  4C 4A 0F             JMP     LINENU          ;then do line number
00178D  1               ;30	<assignmemt>::=<assign head><expression>
00178D  1               PR30
00178D  1  20 AC 12             JSR     CHKTY2          ;if not chktyp2
001790  1  F0 03                BEQ     *+5             ;then
001792  1  4C 02 13             JMP     GENSTR          ;else gen$store
001795  1  60                   RTS
001796  1               ;31	<assign head>::=<variable>=
001796  1               PR31
001796  1  A5 82                LDA     TYPEMP
001798  1  C9 00                CMP     #SIMVAR         ;if typemp=simvar
00179A  1  F0 01                BEQ     *+3             ;then
00179C  1  60                   RTS
00179D  1  A5 8A                LDA     SYMLMP
00179F  1  A4 8B                LDY     SYMLMP+1
0017A1  1  4C 38 0F             JMP     LITERL          ;literal(symlocmp)
0017A4  1               ;33	|<expression><or><logical factor>
0017A4  1               PR33
0017A4  1  20 97 12             JSR     CHKTY1          ;if chktyp1
0017A7  1  D0 01                BNE     *+3             ;then
0017A9  1  60                   RTS
0017AA  1  A5 81                LDA     TYPEM1
0017AC  1  4C F4 0C             JMP     GENERT          ;generate(typemp1)
0017AF  1               ;34	<or>::=or
0017AF  1               PR34
0017AF  1  A9 0D                LDA     #BOR
0017B1  1  4C C2 0C             JMP     STTYSP          ;settypesp(bor)
0017B4  1               ;35	|xor
0017B4  1               PR35
0017B4  1  A9 5D                LDA     #EXR
0017B6  1  4C C2 0C             JMP     STTYSP          ;sttysp
0017B9  1               ;37	<logical secondary>
0017B9  1               PR37
0017B9  1  20 97 12             JSR     CHKTY1          ;if chktyp1
0017BC  1  D0 01                BNE     *+3             ;then
0017BE  1  60                   RTS
0017BF  1  A9 0C                LDA     #ANDO
0017C1  1  4C F4 0C             JMP     GENERT          ;generate(ando)
0017C4  1               ;39	|not <logical primary>
0017C4  1               PR39
0017C4  1  20 BD 12             JSR     CHKTY3          ;if chktyp3
0017C7  1  D0 01                BNE     *+3             ;then
0017C9  1  60                   RTS
0017CA  1  A9 0B                LDA     #NOT
0017CC  1  4C F4 0C             JMP     GENERT          ;generate(not)
0017CF  1               ;41	<arithmetic expression>
0017CF  1               PR41
0017CF  1  20 AC 12             JSR     CHKTY2          ;if chktyp2
0017D2  1  D0 01                BNE     *+3             ;then
0017D4  1  60                   RTS
0017D5  1  A5 83                LDA     STYPSP
0017D7  1  C9 31                CMP     #FLOTPT         ;if stypesp<>floatpt
0017D9  1  D0 05                BNE     PR41A           ;then
0017DB  1  A5 81                LDA     TYPEM1
0017DD  1  4C F4 0C             JMP     GENERT          ;generate(typemp1)
0017E0  1               PR41A
0017E0  1  18                   CLC
0017E1  1  A5 81                LDA     TYPEM1
0017E3  1  69 10                ADC     #16
0017E5  1  20 F4 0C             JSR     GENERT          ;generate(typemp1+16)
0017E8  1  A9 31                LDA     #FLOTPT
0017EA  1  4C CE 0C             JMP     STSTMP          ;setstypemp(floatpt)
0017ED  1               ;43	|<arithmetic expression>+<term>
0017ED  1               PR43
0017ED  1  20 AC 12             JSR     CHKTY2          ;if chktyp2
0017F0  1  D0 01                BNE     *+3             ;then
0017F2  1  60                   RTS
0017F3  1  A9 00                LDA     #FAD
0017F5  1  A4 83                LDY     STYPSP
0017F7  1  C0 31                CPY     #FLOTPT         ;if stypesp=floatpt
0017F9  1  F0 02                BEQ     *+4             ;then generate(fad)
0017FB  1  A9 1D                LDA     #CAT
0017FD  1  4C F4 0C             JMP     GENERT          ;else generate(cat)
001800  1               ;44	|<arithmetic expression>-<term>
001800  1               PR44
001800  1  20 97 12             JSR     CHKTY1          ;if chktyp1
001803  1  D0 01                BNE     *+3             ;then
001805  1  60                   RTS
001806  1  A9 01                LDA     #FMI
001808  1  4C F4 0C             JMP     GENERT          ;generate(fmi)
00180B  1               ;46	|-<term>
00180B  1               PR46
00180B  1  20 BD 12             JSR     CHKTY3          ;if chktyp3
00180E  1  D0 01                BNE     *+3             ;then
001810  1  60                   RTS
001811  1  A9 30                LDA     #NEG
001813  1  4C F4 0C             JMP     GENERT          ;generate(neg)
001816  1               ;48	|<term>*<primary>
001816  1               PR48
001816  1  20 97 12             JSR     CHKTY1          ;if chktyp1
001819  1  D0 01                BNE     *+3             ;then
00181B  1  60                   RTS
00181C  1  A9 02                LDA     #FMU
00181E  1  4C F4 0C             JMP     GENERT          ;generate(fmu)
001821  1               ;49	|<term>/<primary>
001821  1               PR49
001821  1  20 97 12             JSR     CHKTY1          ;if chktyp1
001824  1  D0 01                BNE     *+3             ;then
001826  1  60                   RTS
001827  1  A9 03                LDA     #FDI
001829  1  4C F4 0C             JMP     GENERT          ;generate(fdi)
00182C  1               ;51	|<primary>**<element>
00182C  1               PR51
00182C  1  20 97 12             JSR     CHKTY1          ;the chktyp1
00182F  1  D0 01                BNE     *+3             ;then
001831  1  60                   RTS
001832  1  A9 04                LDA     #EXP
001834  1  4C F4 0C             JMP     GENERT          ;generate(exp)
001837  1               ;52	<element>::=<variable>
001837  1               PR52
001837  1  A5 80                LDA     TYPESP          ;if typesp
001839  1  C9 00                CMP     #SIMVAR         ;= simvar
00183B  1  F0 05                BEQ     *+7             ;then
00183D  1  A9 0E                LDA     #LOD
00183F  1  4C F4 0C             JMP     GENERT          ;else generate(lod)
001842  1  A5 86                LDA     SYMLSP
001844  1  A4 87                LDY     SYMLSP+1
001846  1  4C 41 0F             JMP     LITLOD          ;litload(symlocsp)
001849  1               ;55	|(<expression>)
001849  1               PR55
001849  1  A5 84                LDA     STYPM1
00184B  1  4C CE 0C             JMP     STSTMP          ;setstypemp(stypemp1)
00184E  1               ;56	<variable>::=<identifier>
00184E  1               PR56
00184E  1  A5 7B                LDA     SP
001850  1  4C 1F 14             JMP     PSIMPV          ;process$simple$variable(sp)
001853  1               ;57	|<subscript head><expression>
001853  1               PR57
001853  1  2C 07 2E             BIT     FORSTM          ;if not forstmt
001856  1  10 05                BPL     *+7             ;then
001858  1  A9 03                LDA     #3              ;for index not simple variable
00185A  1  20 AB 0A             JSR     ERROR
00185D  1  20 E4 12             JSR     CHKTY5          ;chktyp5
001860  1  A5 8A                LDA     SYMLMP
001862  1  A4 8B                LDY     SYMLMP+1
001864  1  85 A7                STA     BASE
001866  1  84 A8                STY     BASE+1          ;base=symlocsp
001868  1  20 02 11             JSR     GETSUB          ;if getsubtype
00186B  1  C5 82                CMP     TYPEMP          ;= typemp
00186D  1  F0 05                BEQ     *+7             ;then
00186F  1  A9 11                LDA     #17             ;incorrect number subscripts
001871  1  20 AB 0A             JSR     ERROR
001874  1  20 51 10             JSR     GETADR
001877  1  20 41 0F             JSR     LITLOD          ;litload(getaddr)
00187A  1  A9 21                LDA     #SUB
00187C  1  20 F4 0C             JSR     GENERT          ;generate(subo)
00187F  1  A9 02                LDA     #SUBVAR
001881  1  4C D4 0C             JMP     STTYMP          ;settypemp(subvar)
001884  1               ;58	<subscript head>::=<identifier>(
001884  1               PR58
001884  1  A5 7C                LDA     MP
001886  1  20 3F 12             JSR     LKONLY          ;lookup$only(mp)
001889  1  F0 07                BEQ     PR58A           ;if not then error
00188B  1  20 26 10             JSR     GETTYP          ;if getype
00188E  1  C9 02                CMP     #SUBVAR         ;= subvar
001890  1  F0 05                BEQ     *+7             ;then ok
001892  1               PR58A
001892  1  A9 0A                LDA     #10             ;subscripted variable not dimensioned
001894  1  20 AB 0A             JSR     ERROR
001897  1  A9 00                LDA     #0
001899  1  20 D4 0C             JSR     STTYMP          ;settypemp(0)
00189C  1  A5 A7                LDA     BASE
00189E  1  A4 A8                LDY     BASE+1
0018A0  1  4C BC 0C             JMP     STSLMP          ;setsymlocmp(base)
0018A3  1               ;60	<function call>::=<function heading><expression>
0018A3  1               PR60
0018A3  1  20 36 15             JSR     CHKPRM          ;checkparm
0018A6  1  A5 91                LDA     SRLOMP
0018A8  1  A4 92                LDY     SRLOMP+1
0018AA  1  85 8F                STA     SRLOSP
0018AC  1  84 90                STY     SRLOSP+1        ;srlocsp=srlocmp
0018AE  1  4C 75 15             JMP     FNCGEN          ;funcgen
0018B1  1               ;63	|<function heading><expression>
0018B1  1               PR63
0018B1  1  20 36 15             JSR     CHKPRM          ;check$parm
0018B4  1  4C 10 15             JMP     GENPRM          ;gen$parm
0018B7  1               ;64	<function name>::=<user defined name>
0018B7  1               PR64
0018B7  1  A5 7B                LDA     SP
0018B9  1  20 3F 12             JSR     LKONLY          ;if lookup$only(sp)
0018BC  1  D0 05                BNE     *+7             ;then
0018BE  1  A9 06                LDA     #6              ;function undefined
0018C0  1  4C AB 0A             JMP     ERROR
0018C3  1  A5 A7                LDA     BASE
0018C5  1  A4 A8                LDY     BASE+1
0018C7  1  20 E6 0C             JSR     STSRSP          ;setsrlocsp(base)
0018CA  1  A5 A7                LDA     BASE
0018CC  1  A4 A8                LDY     BASE+1
0018CE  1  20 AE 0C             JSR     STSLSP          ;setsymlocsp(base)
0018D1  1  A9 0A                LDA     #UNFUNC
0018D3  1  20 C2 0C             JSR     STTYSP          ;settypesp(unfunc)
0018D6  1  20 26 10             JSR     GETTYP
0018D9  1  4C E0 0C             JMP     STHASP          ;sethashsp(getype)
0018DC  1               ;65	|<predefined name>
0018DC  1               PR65
0018DC  1  A5 4B                LDA     FUNCOP
0018DE  1  20 C2 0C             JSR     STTYSP          ;settypesp(funcop)
0018E1  1  A5 83                LDA     STYPSP
0018E3  1  4A                   LSR     A
0018E4  1  4A                   LSR     A               ;shr(stypesp,2)
0018E5  1  29 07                AND     #7
0018E7  1  4C E0 0C             JMP     STHASP          ;sethashsp( )
0018EA  1               ;67	|<string>
0018EA  1               PR67
0018EA  1  A9 4E                LDA     #<ACCUM
0018EC  1  A0 00                LDY     #>ACCUM
0018EE  1  4C 64 14             JMP     GENILS          ;gen$ils(.accum)
0018F1  1               ;68	<relation>::= =
0018F1  1               PR68
0018F1  1  A9 07                LDA     #7
0018F3  1  4C C2 0C             JMP     STTYSP          ;settypesp(7)
0018F6  1               ;69	| >= | GE
0018F6  1               PR69
0018F6  1  A9 09                LDA     #9
0018F8  1  4C D4 0C             JMP     STTYMP          ;settypemp(9)
0018FB  1               ;71	| <= | LE
0018FB  1               PR71
0018FB  1  A9 0A                LDA     #10
0018FD  1  4C D4 0C             JMP     STTYMP          ;settypemp(10)
001900  1               ;73	| >
001900  1               PR73
001900  1  A9 06                LDA     #6
001902  1  4C C2 0C             JMP     STTYSP          ;settypesp(6)
001905  1               ;74	| <
001905  1               PR74
001905  1  A9 05                LDA     #5
001907  1  4C C2 0C             JMP     STTYSP          ;settypesp(5)
00190A  1               ;75	| <> | NE
00190A  1               PR75
00190A  1  A9 08                LDA     #8
00190C  1  4C D4 0C             JMP     STTYMP          ;settypemp(8)
00190F  1               ;77	<for statement>::=<for head> to <expression> <step clause>
00190F  1               PR77
00190F  1  A0 06                LDY     #3*2            ;word addressing
001911  1  B1 A5                LDA     (SBTTOP),Y
001913  1  85 A7                STA     BASE
001915  1  C8                   INY
001916  1  B1 A5                LDA     (SBTTOP),Y
001918  1  85 A8                STA     BASE+1          ;base=foraddress(3)
00191A  1  A5 80                LDA     TYPESP          ;if not typesp
00191C  1  4A                   LSR     A
00191D  1  90 05                BCC     *+7             ;then
00191F  1  A9 12                LDA     #DUP
001921  1  20 F4 0C             JSR     GENERT          ;generate(dup)
001924  1  20 51 10             JSR     GETADR
001927  1  20 41 0F             JSR     LITLOD          ;litload(getaddr)
00192A  1  A9 00                LDA     #FAD
00192C  1  20 F4 0C             JSR     GENERT          ;generate(fad)
00192F  1  A5 80                LDA     TYPESP          ;if not
001931  1  4A                   LSR     A               ;typesp
001932  1  90 0B                BCC     PR77A           ;then
001934  1  20 51 10             JSR     GETADR
001937  1  20 38 0F             JSR     LITERL          ;literal(getaddr)
00193A  1  A9 13                LDA     #XCH
00193C  1  20 F4 0C             JSR     GENERT          ;generate(xch)
00193F  1               PR77A
00193F  1  A9 0F                LDA     #STO
001941  1  20 F4 0C             JSR     GENERT          ;generate(sto)
001944  1  A5 80                LDA     TYPESP          ;if not
001946  1  4A                   LSR     A               ;typesp
001947  1  90 2D                BCC     PR77B           ;then
001949  1  A9 13                LDA     #XCH
00194B  1  20 F4 0C             JSR     GENERT          ;generate(xch)
00194E  1  A9 00                LDA     #0
001950  1  A8                   TAY
001951  1  20 38 0F             JSR     LITERL          ;literal(0)
001954  1  A9 05                LDA     #LSS
001956  1  20 F4 0C             JSR     GENERT          ;generate(lss)
001959  1  A9 05                LDA     #5
00195B  1  A0 00                LDY     #0
00195D  1  20 38 0F             JSR     LITERL          ;literal(5)
001960  1  A9 38                LDA     #BFC
001962  1  20 F4 0C             JSR     GENERT          ;generate(bfc)
001965  1  A9 0A                LDA     #LEQ
001967  1  20 F4 0C             JSR     GENERT          ;generate(leq)
00196A  1  A9 02                LDA     #2
00196C  1  A0 00                LDY     #0
00196E  1  20 38 0F             JSR     LITERL          ;literal(2)
001971  1  A9 39                LDA     #BFN
001973  1  20 F4 0C             JSR     GENERT          ;generate(bfn)
001976  1               PR77B
001976  1  A9 09                LDA     #GEQ
001978  1  20 F4 0C             JSR     GENERT          ;generate(beq)
00197B  1  A9 37                LDA     #BRC
00197D  1  20 F4 0C             JSR     GENERT          ;generate(brc)
001980  1  A0 00                LDY     #0*2            ;word address
001982  1  B1 A5                LDA     (SBTTOP),Y
001984  1  48                   PHA
001985  1  C8                   INY
001986  1  B1 A5                LDA     (SBTTOP),Y
001988  1  A8                   TAY
001989  1  68                   PLA
00198A  1  20 2F 0F             JSR     GENTWO          ;gen$two(foraddress(0))
00198D  1  A0 02                LDY     #1*2            ;word addressing
00198F  1  A5 B2                LDA     CODESI
001991  1  91 A5                STA     (SBTTOP),Y
001993  1  C8                   INY
001994  1  A5 B3                LDA     CODESI+1
001996  1  91 A5                STA     (SBTTOP),Y      ;foraddress(1)=codesize
001998  1  60                   RTS
001999  1               ;78	<for head>::=<for><assignment>
001999  1               PR78
001999  1  A9 36                LDA     #BRS
00199B  1  20 F4 0C             JSR     GENERT          ;generate(brs)
00199E  1  A0 02                LDY     #1*2            ;word addressing
0019A0  1  B1 A5                LDA     (SBTTOP),Y
0019A2  1  48                   PHA
0019A3  1  C8                   INY
0019A4  1  B1 A5                LDA     (SBTTOP),Y
0019A6  1  A8                   TAY
0019A7  1  68                   PLA
0019A8  1  20 2F 0F             JSR     GENTWO          ;gen$two(foraddress(1))
0019AB  1  A0 04                LDY     #2*2            ;word addressing
0019AD  1  A5 B2                LDA     CODESI
0019AF  1  91 A5                STA     (SBTTOP),Y
0019B1  1  C8                   INY
0019B2  1  A5 B3                LDA     CODESI+1
0019B4  1  91 A5                STA     (SBTTOP),Y      ;foraddress(2)=codesize
0019B6  1  60                   RTS
0019B7  1               ;79	<for>::= for
0019B7  1               PR79
0019B7  1  A9 FF                LDA     #TRUE
0019B9  1  8D 07 2E             STA     FORSTM          ;forstmt=true
0019BC  1  38                   SEC
0019BD  1  A5 A5                LDA     SBTTOP
0019BF  1  E9 08                SBC     #8
0019C1  1  85 A5                STA     SBTTOP
0019C3  1  85 B9                STA     NXSTPT
0019C5  1  A4 A6                LDY     SBTTOP+1
0019C7  1  B0 01                BCS     *+3
0019C9  1  88                   DEY
0019CA  1  84 A6                STY     SBTTOP+1
0019CC  1  84 BA                STY     NXSTPT+1        ;sbtbltop,nextstmtptr=sbtbltop-8
0019CE  1  A0 01                LDY     #1
0019D0  1  B1 B9                LDA     (NXSTPT),Y
0019D2  1  29 7F                AND     #$7F
0019D4  1  91 B9                STA     (NXSTPT),Y      ;nextbytev(1)=nextbytev(1) and $7f
0019D6  1  A9 00                LDA     #0
0019D8  1  20 E9 0F             JSR     LIMITS          ;limits(0)
0019DB  1  E6 A9                INC     FORCNT          ;forcount=forcount+1
0019DD  1  60                   RTS
0019DE  1               ;80	<step clause>::= step <expression>
0019DE  1               PR80
0019DE  1  A9 01                LDA     #1
0019E0  1  4C D4 0C             JMP     STTYMP          ;settypemp(true)
0019E3  1               ;81	|
0019E3  1               PR81
0019E3  1  A0 06                LDY     #3*2            ;word addressing
0019E5  1  B1 A5                LDA     (SBTTOP),Y
0019E7  1  85 A7                STA     BASE
0019E9  1  C8                   INY
0019EA  1  B1 A5                LDA     (SBTTOP),Y
0019EC  1  85 A8                STA     BASE+1          ;base=foraddress(3)
0019EE  1  20 51 10             JSR     GETADR
0019F1  1  20 38 0F             JSR     LITERL          ;literal(getaddr)
0019F4  1  A9 00                LDA     #FALSE
0019F6  1  20 C2 0C             JSR     STTYSP          ;settypesp(false)
0019F9  1  A9 2E                LDA     #CON
0019FB  1  20 F4 0C             JSR     GENERT          ;generate(con)
0019FE  1  A9 00                LDA     #0
001A00  1  A8                   TAY
001A01  1  4C 2F 0F             JMP     GENTWO          ;gen$two(0)
001A04  1               ;82	<if statement>::=<if group>
001A04  1               PR82
001A04  1  A9 00                LDA     #0
001A06  1  4C 6C 12             JMP     ENCMLB          ;enter$compiler$label(0)
001A09  1               ;84	| if end # <expression> then <number>
001A09  1               PR84
001A09  1  A9 5B                LDA     #RON
001A0B  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001A0E  1  A9 5E                LDA     #DEF
001A10  1  20 F4 0C             JSR     GENERT          ;generate(def)
001A13  1  20 F2 13             JSR     FNDLBL          ;findlabel
001A16  1  20 51 10             JSR     GETADR
001A19  1  4C 2F 0F             JMP     GENTWO          ;gen$two(getaddr)
001A1C  1               ;87	<if else group>::=<if head><statement list> else
001A1C  1               PR87
001A1C  1  A9 03                LDA     #3
001A1E  1  20 6C 12             JSR     ENCMLB          ;emter$compiler$label(3)
001A21  1  A9 36                LDA     #BRS
001A23  1  20 F4 0C             JSR     GENERT          ;generate(brs)
001A26  1  4C 8E 12             JMP     COMLBL          ;compiler$label
001A29  1               ;88	<if head>::=if <expression> then
001A29  1               PR88
001A29  1  A5 84                LDA     STYPM1          ;if stypemp1
001A2B  1  C9 32                CMP     #STRING         ;<> string
001A2D  1  D0 05                BNE     *+7             ;then
001A2F  1  A9 08                LDA     #8              ;else if expression is not floating point
001A31  1  20 AB 0A             JSR     ERROR
001A34  1  A9 37                LDA     #BRC
001A36  1  20 F4 0C             JSR     GENERT          ;generate(brc)
001A39  1  4C 8E 12             JMP     COMLBL          ;compiler$label
001A3C  1               ;89	<dummy argument list>::=<expresssion>
001A3C  1               PR89
001A3C  1  20 AC 12             JSR     CHKTY2          ;if chkty2
001A3F  1  D0 01                BNE     *+3             ;the
001A41  1  60                   RTS
001A42  1  A5 8A                LDA     SYMLMP
001A44  1  A4 8B                LDY     SYMLMP+1
001A46  1  85 A7                STA     BASE
001A48  1  84 A8                STY     BASE+1
001A4A  1  A5 81                LDA     TYPEM1
001A4C  1  20 32 10             JSR     SETTYP          ;setype(typemp1)
001A4F  1  20 0C 11             JSR     UNLINK
001A52  1  A9 13                LDA     #XCH
001A54  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001A57  1  A9 1F                LDA     #RTN
001A59  1  20 F4 0C             JSR     GENERT          ;generate(rtn)
001A5C  1  A9 00                LDA     #0
001A5E  1  4C 6C 12             JMP     ENCMLB          ;enter$compiler$label(0)
001A61  1               ;90	(ud function name>::= def <user defined name>
001A61  1               PR90
001A61  1  A9 36                LDA     #BRS
001A63  1  20 F4 0C             JSR     GENERT          ;generate(brs)
001A66  1  20 8E 12             JSR     COMLBL          ;compiler$label
001A69  1  A5 7B                LDA     SP
001A6B  1  20 45 12             JSR     NRMLKU          ;normal$lookup(sp)
001A6E  1  48                   PHA                     ;save result
001A6F  1  A5 83                LDA     STYPSP
001A71  1  20 CE 0C             JSR     STSTMP          ;setstypemp(stypesp)
001A74  1  A5 A7                LDA     BASE
001A76  1  A4 A8                LDY     BASE+1
001A78  1  20 BC 0C             JSR     STSLMP          ;setsymlocmp(base)
001A7B  1  2C FD 2D             BIT     PASS1           ;if pass 1
001A7E  1  30 04                BMI     *+6             ;then
001A80  1  68                   PLA                     ;clear stack
001A81  1  4C 67 11             JMP     RELINK
001A84  1  68                   PLA                     ;if not flag
001A85  1  F0 05                BEQ     *+7             ;then
001A87  1  A9 02                LDA     #2              ;else function name previously defined
001A89  1  20 AB 0A             JSR     ERROR
001A8C  1  A5 B2                LDA     CODESI
001A8E  1  A4 B3                LDY     CODESI+1
001A90  1  4C 06 10             JMP     SETRSV          ;setaddr(codesize)
001A93  1               ;92	|
001A93  1               PR92
001A93  1  A9 00                LDA     #0
001A95  1  4C D4 0C             JMP     STTYMP          ;settypemp(0)
001A98  1               ;98	<file decleration>::=<identifier><file rec size>
001A98  1               PR98
001A98  1  A5 7C                LDA     MP
001A9A  1  20 1F 14             JSR     PSIMPV          ;process$simple$variable(mp)
001A9D  1  A5 85                LDA     STYPMP          ;if stypemp
001A9F  1  C9 31                CMP     #FLOTPT         ;<> floatpt
001AA1  1  D0 05                BNE     *+7             ;then
001AA3  1  A9 17                LDA     #23             ;invalid type in file
001AA5  1  20 AB 0A             JSR     ERROR
001AA8  1  A5 86                LDA     SYMLSP
001AAA  1  A4 87                LDY     SYMLSP+1
001AAC  1  20 41 0F             JSR     LITLOD          ;litload(symlocsp)
001AAF  1  A9 2D                LDA     #OPN
001AB1  1  4C F4 0C             JMP     GENERT          ;generate(opn)
001AB4  1               ;100	|
001AB4  1               PR100
001AB4  1  A9 00                LDA     #0
001AB6  1  A8                   TAY
001AB7  1  4C 38 0F             JMP     LITERL          ;literal(0)
001ABA  1               ;104	<dimension variable>::=<dim var head><expression>
001ABA  1               PR104
001ABA  1  20 E4 12             JSR     CHKTY5          ;chktyp5
001ABD  1  A5 8A                LDA     SYMLMP
001ABF  1  A4 8B                LDY     SYMLMP+1
001AC1  1  85 A7                STA     BASE
001AC3  1  84 A8                STY     BASE+1          ;base=symlocsp
001AC5  1  60                   RTS
001AC6  1               ;105	<dim var head>::=<identifier>(
001AC6  1               PR105
001AC6  1  A5 7C                LDA     MP
001AC8  1  20 45 12             JSR     NRMLKU          ;if not normal$lookup(mp)
001ACB  1  F0 0A                BEQ     PR105A          ;then
001ACD  1  2C FD 2D             BIT     PASS1           ;if not pass 1
001AD0  1  10 05                BPL     PR105A          ;then
001AD2  1  A9 01                LDA     #1              ;identifier in dim previously defined
001AD4  1  20 AB 0A             JSR     ERROR
001AD7  1               PR105A
001AD7  1  A9 02                LDA     #SUBVAR
001AD9  1  20 32 10             JSR     SETTYP          ;setype(subvar)
001ADC  1  2C FD 2D             BIT     PASS1           ;if not pass 1
001ADF  1  10 06                BPL     *+8             ;then
001AE1  1  20 51 12             JSR     CNTPRT
001AE4  1  20 06 10             JSR     SETRSV          ;setaddr(countprt)
001AE7  1  20 51 10             JSR     GETADR
001AEA  1  20 38 0F             JSR     LITERL          ;literal(getaddr)
001AED  1  A9 00                LDA     #0
001AEF  1  20 D4 0C             JSR     STTYMP          ;settypemp(0)
001AF2  1  A5 A7                LDA     BASE
001AF4  1  A4 A8                LDY     BASE+1
001AF6  1  4C BC 0C             JMP     STSLMP          ;setsymlocmp(base)
001AF9  1               ;108	<close list>::=<expression>
001AF9  1               PR108
001AF9  1  A5 83                LDA     STYPSP          ;if stypesp
001AFB  1  C9 32                CMP     #STRING         ;<> string
001AFD  1  D0 03                BNE     *+5             ;then
001AFF  1  20 D1 12             JSR     MFERR           ;must be floating
001B02  1  A9 5B                LDA     #RON
001B04  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001B07  1  A9 40                LDA     #CLS
001B09  1  4C F4 0C             JMP     GENERT          ;generate(cls)
001B0C  1               ;110	<read statement>::= read <file option><read list>
001B0C  1               PR110
001B0C  1  2C 08 2E             BIT     FILEIO          ;if not fileio
001B0F  1  10 0A                BPL     PR110A          ;then
001B11  1  A9 3E                LDA     #EDR
001B13  1  20 F4 0C             JSR     GENERT          ;generate(edr)
001B16  1               ;117	|
001B16  1               PR117
001B16  1  A9 00                LDA     #FALSE
001B18  1  8D 08 2E             STA     FILEIO          ;fileio=false
001B1B  1               PR110A
001B1B  1  60                   RTS
001B1C  1               ;112	<input statement>::=input <prompt option><read list>
001B1C  1               PR112
001B1C  1  A9 27                LDA     #ECR
001B1E  1  20 F4 0C             JSR     GENERT          ;generate(ecr)
001B21  1  A9 00                LDA     #FALSE
001B23  1  85 47                STA     INPSTM          ;inputstmt=false
001B25  1  60                   RTS
001B26  1               ;113	<prompt option>::=<constant>
001B26  1               PR113
001B26  1  20 E4 14             JSR     PUTFLD          ;put$field
001B29  1  4C 12 13             JMP     SEINPU          ;setup$input
001B2C  1               ;119	|print <file option><file list>
001B2C  1               PR119
001B2C  1  A9 3F                LDA     #EDW
001B2E  1  20 F4 0C             JSR     GENERT          ;generate(edw)
001B31  1  A9 00                LDA     #FALSE
001B33  1  8D 08 2E             STA     FILEIO          ;fileio=false
001B36  1  60                   RTS
001B37  1               ;126	|
001B37  1               PR126
001B37  1  A9 34                LDA     #DBF
001B39  1  4C F4 0C             JMP     GENERT          ;generate(dbf)
001B3C  1               ;127	<file option>::= # <expression>
001B3C  1               PR127
001B3C  1  A9 FF                LDA     #TRUE
001B3E  1  8D 08 2E             STA     FILEIO          ;fileio=true
001B41  1  A9 5B                LDA     #RON
001B43  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001B46  1  A9 26                LDA     #RDB
001B48  1  4C F4 0C             JMP     GENERT          ;generate(rdb)
001B4B  1               ;128	| # <expression>,<expression>;
001B4B  1               PR128
001B4B  1  A9 FF                LDA     #TRUE
001B4D  1  8D 08 2E             STA     FILEIO          ;fileio=true
001B50  1  A9 5B                LDA     #RON
001B52  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001B55  1  A9 13                LDA     #XCH
001B57  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001B5A  1  A9 5B                LDA     #RON
001B5C  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001B5F  1  A9 25                LDA     #RDF
001B61  1  4C F4 0C             JMP     GENERT          ;generate(rdf)
001B64  1               ;130	| ,
001B64  1               PR130
001B64  1  2C 08 2E             BIT     FILEIO          ;if not fileio
001B67  1  10 01                BPL     *+3             ;then
001B69  1  60                   RTS
001B6A  1  A9 35                LDA     #NSP
001B6C  1  4C F4 0C             JMP     GENERT          ;generate(nsp)
001B6F  1               ;133	|<on gosub> <label list>
001B6F  1               PR133
001B6F  1  20 7A 13             JSR     GENON2          ;gen$on$2
001B72  1  A9 00                LDA     #0
001B74  1  4C 6C 12             JMP     ENCMLB          ;enter$compiler$label(0)
001B77  1               ;135	<on gosub>::= on <expression> <gosub>
001B77  1               PR135
001B77  1  20 85 12             JSR     STCMLB          ;set$compiler$label
001B7A  1  20 51 10             JSR     GETADR
001B7D  1  20 38 0F             JSR     LITERL          ;literal(getaddr)
001B80  1  A9 60                LDA     #ADJ
001B82  1  20 F4 0C             JSR     GENERT          ;generate(adj)
001B85  1  A9 13                LDA     #XCH
001B87  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001B8A  1  4C 5D 13             JMP     GENON           ;gen$on
001B8D  1               ;136	<label list>::=<number>
001B8D  1               PR136
001B8D  1  20 0B 14             JSR     RESLBL          ;resolve$label
001B90  1  A9 01                LDA     #1
001B92  1  4C C2 0C             JMP     STTYSP          ;settypesp(1)
001B95  1               ;137	|<label list>,<number>
001B95  1               PR137
001B95  1  20 0B 14             JSR     RESLBL          ;resolve$label
001B98  1  A6 82                LDX     TYPEMP
001B9A  1  E8                   INX
001B9B  1  8A                   TXA
001B9C  1  4C D4 0C             JMP     STTYMP          ;settypemp(typemp+1)
001B9F  1               ;138	<gosub statement>::=<gosub><number>
001B9F  1               PR138
001B9F  1  A9 FF                LDA     #TRUE
001BA1  1  85 48                STA     GSBSTM          ;gosubstmt=true
001BA3  1  20 0B 14             JSR     RESLBL          ;resolve$label
001BA6  1  A9 00                LDA     #FALSE
001BA8  1  85 48                STA     GSBSTM          ;gosubstmt=false
001BAA  1  60                   RTS
001BAB  1               ;147	<out statement>::= out <expression>,<expression>
001BAB  1               PR147
001BAB  1  A9 31                LDA     #FLOTPT         ;if stypemp1
001BAD  1  C5 84                CMP     STYPM1          ;<> floatpt
001BAF  1  D0 04                BNE     *+6             ;then
001BB1  1  C5 83                CMP     STYPSP          ;if stypesp = floatpt
001BB3  1  F0 03                BEQ     *+5             ;then ok
001BB5  1  4C D1 12             JMP     MFERR           ;must be floating error
001BB8  1  A9 5B                LDA     #RON
001BBA  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001BBD  1  A9 13                LDA     #XCH
001BBF  1  20 F4 0C             JSR     GENERT          ;generate(xch)
001BC2  1  A9 5B                LDA     #RON
001BC4  1  20 F4 0C             JSR     GENERT          ;generate(ron)
001BC7  1  A9 28                LDA     #POT
001BC9  1  4C F4 0C             JMP     GENERT          ;generate(pot)
001BCC  1               ;148	<return statement>::= return
001BCC  1               PR148
001BCC  1  A9 1F                LDA     #RTN
001BCE  1  4C F4 0C             JMP     GENERT          ;generate(rtn)
001BD1  1               ;149	<stop statement>::= stop
001BD1  1               PR149
001BD1  1  A9 10                LDA     #XIT
001BD3  1  4C F4 0C             JMP     GENERT          ;generate(xit)
001BD6  1               ;150	<end statement>::= end
001BD6  1               PR150
001BD6  1  2C FD 2D             BIT     PASS1           ;if not pass 1
001BD9  1  10 33                BPL     PR150B          ;then
001BDB  1  A9 00                LDA     #FALSE
001BDD  1  8D FD 2D             STA     PASS1           ;pass1=false
001BE0  1  A5 A9                LDA     FORCNT          ;if forcount
001BE2  1  F0 09                BEQ     PR150A          ;= zero then ok
001BE4  1  A9 18                LDA     #24             ;else for without next error
001BE6  1  20 AB 0A             JSR     ERROR
001BE9  1  A9 00                LDA     #0
001BEB  1  85 A9                STA     FORCNT          ;forcount=0
001BED  1               PR150A
001BED  1  A9 2A                LDA     #'*'
001BEF  1  20 F4 0C             JSR     GENERT          ;generate('*')
001BF2  1  18                   CLC
001BF3  1  A5 B2                LDA     CODESI
001BF5  1  A4 B3                LDY     CODESI+1
001BF7  1  69 03                ADC     #3
001BF9  1  90 01                BCC     *+3
001BFB  1  C8                   INY
001BFC  1  29 FC                AND     #$FC
001BFE  1  20 2F 0F             JSR     GENTWO          ;gen$two((codesize+3) and $fffc)
001C01  1  A5 45                LDA     DATACT
001C03  1  A4 46                LDY     DATACT+1
001C05  1  20 2F 0F             JSR     GENTWO          ;gen$two(datact)
001C08  1  20 51 12             JSR     CNTPRT
001C0B  1  4C 2F 0F             JMP     GENTWO          ;gen$two(countprt)
001C0E  1               PR150B
001C0E  1  A5 4D                LDA     NXTCHR
001C10  1  C9 0D                CMP     #CR
001C12  1  F0 06                BEQ     *+8
001C14  1  20 15 0A             JSR     GETCHR
001C17  1  4C 0E 1C             JMP     PR150B          ;while not eol
001C1A  1  A9 10                LDA     #XIT
001C1C  1  20 F4 0C             JSR     GENERT          ;generate(xit)
001C1F  1  A9 7F                LDA     #$7F
001C21  1  20 F4 0C             JSR     GENERT          ;generate($7f)
001C24  1  20 94 09             JSR     WRTINT          ;write$int$file
001C27  1  20 4E 09             JSR     CLSINT          ;close$int$file
001C2A  1  A5 43                LDA     ERRCNT
001C2C  1  A4 44                LDY     ERRCNT+1
001C2E  1  20 70 08             JSR     PRNDEC          ;printdec(errorcount)
001C31  1  A9 92                LDA     #<ERDMSG
001C33  1  A0 2D                LDY     #>ERDMSG
001C35  1  20 FC 08             JSR     PRNMSG          ;print('errors detected')
001C38  1  20 34 08             JSR     CRLF
001C3B  1  4C 00 01             JMP     BOOT
001C3E  1               ;151	<restore statement>::= restore
001C3E  1               PR151
001C3E  1  A9 2F                LDA     #RST
001C40  1  4C F4 0C             JMP     GENERT          ;generate(rst)
001C43  1               ;152	<randomize statement>::= randomize
001C43  1               PR152
001C43  1  A9 4D                LDA     #IRN
001C45  1  4C F4 0C             JMP     GENERT          ;generate(irn)
001C48  1               ;getin1  (does ay=index1(state))
001C48  1               GETIN1
001C48  1  A5 79                LDA     STATE
001C4A  1  A4 7A                LDY     STATE+1         ;get state
001C4C  1  0A                   ASL     A
001C4D  1  AA                   TAX
001C4E  1  98                   TYA
001C4F  1  2A                   ROL     A
001C50  1  A8                   TAY
001C51  1  18                   CLC
001C52  1  8A                   TXA
001C53  1  69 AB                ADC     #<INDEX1        ;add state*2 since is word addressing
001C55  1  8D 6C 1C             STA     GT+1
001C58  1  98                   TYA
001C59  1  69 24                ADC     #>INDEX1
001C5B  1  8D 6D 1C             STA     GT+2
001C5E  1  A2 00                LDX     #0
001C60  1  20 6B 1C             JSR     GT              ;get low
001C63  1  48                   PHA
001C64  1  E8                   INX
001C65  1  20 6B 1C             JSR     GT              ;get high
001C68  1  A8                   TAY
001C69  1  68                   PLA
001C6A  1  60                   RTS
001C6B  1               ;general purpose lda abs,x routine
001C6B  1               GT
001C6B  1  BD FF FF             LDA     $FFFF,X
001C6E  1  60                   RTS
001C6F  1               ;getin2 (does ay=index2(state))
001C6F  1               GETIN2
001C6F  1  A5 79                LDA     STATE
001C71  1  A4 7A                LDY     STATE+1
001C73  1  18                   CLC
001C74  1  69 57                ADC     #<INDEX2
001C76  1  8D 80 1C             STA     G2+1
001C79  1  98                   TYA
001C7A  1  69 27                ADC     #>INDEX2
001C7C  1  8D 81 1C             STA     G2+2
001C7F  1               G2
001C7F  1  AD FF FF             LDA     $FFFF
001C82  1  A0 00                LDY     #0              ;y always zero
001C84  1  60                   RTS
001C85  1               ;incsp
001C85  1               INCSP
001C85  1  E6 7B                INC     SP
001C87  1  A5 7B                LDA     SP              ;bump and get
001C89  1  C9 20                CMP     #PSTKSZ         ;compare to max
001C8B  1  F0 01                BEQ     *+3             ;if = then
001C8D  1  60                   RTS                     ;else ok
001C8E  1  A9 12                LDA     #18             ;stack overflow error
001C90  1  4C AB 0A             JMP     ERROR
001C93  1               ;lookahead
001C93  1               LAHEAD
001C93  1  24 7E                BIT     NOLOOK          ;if not nolook
001C95  1  10 07                BPL     LAHEAX          ;then done
001C97  1  20 98 0D             JSR     SCANNR          ;scanner
001C9A  1  A9 00                LDA     #FALSE
001C9C  1  85 7E                STA     NOLOOK          ;nolook=false
001C9E  1               LAHEAX
001C9E  1  60                   RTS
001C9F  1               ;set$varc$i ---- set varc and increment varindex
001C9F  1               STVRCI
001C9F  1  A6 7F                LDX     VARIND
001CA1  1  9D F7 2F             STA     VARC,X          ;save
001CA4  1  E8                   INX
001CA5  1  86 7F                STX     VARIND          ;bump index
001CA7  1  E0 65                CPX     #VARCSZ+1       ;if too big
001CA9  1  B0 01                BCS     *+3             ;then error
001CAB  1  60                   RTS
001CAC  1  A9 15                LDA     #21             ;varc overflow
001CAE  1  4C AB 0A             JMP     ERROR
001CB1  1               ;initialize all of system
001CB1  1               INTLZ
001CB1  1  20 5C 0F             JSR     INSYMT          ;in$symtbl
001CB4  1  20 B1 11             JSR     INSYN           ;in$syn
001CB7  1  4C 1A 0B             JMP     INSCAN
001CBA  1               ;MAIN PROGRAM
001CBA  1               MAIN
001CBA  1  A2 02                LDX     #2              ;clear page zero
001CBC  1  A9 00                LDA     #0
001CBE  1               PZC
001CBE  1  95 00                STA     0,X
001CC0  1  E8                   INX
001CC1  1  E0 C6                CPX     #LZ
001CC3  1  D0 F9                BNE     PZC
001CC5  1  A9 FF                LDA     #TRUE           ;initialize once
001CC7  1  8D FD 2D             STA     PASS1
001CCA  1  8D 02 2E             STA     LWRUPR
001CCD  1  A9 3A                LDA     #':'
001CCF  1  85 74                STA     SEPRTR
001CD1  1  A9 80                LDA     #SRCRSZ
001CD3  1  85 75                STA     SRCIND
001CD5  1  A9 D8                LDA     #<OPNMSG
001CD7  1  A0 2D                LDY     #>OPNMSG
001CD9  1  20 FC 08             JSR     PRNMSG          ;print opening message
001CDC  1  20 34 08             JSR     CRLF
001CDF  1  20 B1 1C             JSR     INTLZ           ;initialize all
001CE2  1               ;do forever
001CE2  1               ;do while (pass1 or pass2)
001CE2  1               M10
001CE2  1  2C FD 2D             BIT     PASS1           ;if pass 1
001CE5  1  30 08                BMI     M12             ;then go
001CE7  1  2C FE 2D             BIT     PASS2           ;or if
001CEA  1  30 03                BMI     M12             ;pass2 go
001CEC  1  4C EF 1E             JMP     EWP1P2          ;else end of do while pass1 or pass2
001CEF  1               M12
001CEF  1  A9 FF                LDA     #TRUE
001CF1  1  85 7E                STA     NOLOOK          ;nolook=true
001CF3  1  8D 06 2E             STA     CMPLNG          ;compiling=true
001CF6  1  A9 79                LDA     #<STARTS
001CF8  1  A0 00                LDY     #>STARTS
001CFA  1  85 79                STA     STATE
001CFC  1  84 7A                STY     STATE+1         ;state=startstate
001CFE  1  A9 FF                LDA     #255
001D00  1  85 7B                STA     SP              ;sp=255
001D02  1  A9 00                LDA     #0
001D04  1  85 7F                STA     VARIND          ;varind=0
001D06  1  8D D7 2E             STA     VAR
001D09  1               ;do while compiling
001D09  1               M14
001D09  1  2C 06 2E             BIT     CMPLNG          ;test for compiling
001D0C  1  10 D4                BPL     M10             ;branch if not
001D0E  1  A9 78                LDA     #<MAXRNO
001D10  1  C5 79                CMP     STATE
001D12  1  A9 00                LDA     #>MAXRNO
001D14  1  E5 7A                SBC     STATE+1         ;if state>maxrno
001D16  1  B0 03                BCS     *+5             ;continue if ok
001D18  1  4C DB 1D             JMP     M30             ;else try next
001D1B  1  20 85 1C             JSR     INCSP
001D1E  1  A5 7B                LDA     SP
001D20  1  0A                   ASL     A               ;word addressing
001D21  1  AA                   TAX
001D22  1  A5 79                LDA     STATE
001D24  1  9D B7 2F             STA     STSTAK,X
001D27  1  A5 7A                LDA     STATE+1
001D29  1  9D B8 2F             STA     STSTAK+1,X      ;statestack(sp)=state
001D2C  1  20 48 1C             JSR     GETIN1
001D2F  1  85 98                STA     I
001D31  1  84 99                STY     I+1             ;i=getin1
001D33  1  20 93 1C             JSR     LAHEAD          ;lookahead
001D36  1  20 6F 1C             JSR     GETIN2          ;index2(state)
001D39  1  18                   CLC
001D3A  1  65 98                ADC     I
001D3C  1  85 9A                STA     J
001D3E  1  98                   TYA
001D3F  1  65 99                ADC     I+1
001D41  1  85 9B                STA     J+1
001D43  1  A5 9A                LDA     J
001D45  1  D0 02                BNE     *+4
001D47  1  C6 9B                DEC     J+1
001D49  1  C6 9A                DEC     J               ;j=i-1+getin2
001D4B  1               M20
001D4B  1  A5 9A                LDA     J
001D4D  1  C5 98                CMP     I
001D4F  1  A5 9B                LDA     J+1
001D51  1  E5 99                SBC     I+1             ;if i>j
001D53  1  90 B4                BCC     M14             ;go to while compiling
001D55  1  18                   CLC
001D56  1  A5 98                LDA     I
001D58  1  69 FF                ADC     #<READ1
001D5A  1  85 9F                STA     I2
001D5C  1  A5 99                LDA     I+1
001D5E  1  69 1E                ADC     #>READ1
001D60  1  85 A0                STA     I2+1
001D62  1  A0 00                LDY     #0
001D64  1  B1 9F                LDA     (I2),Y          ;a=read(i)
001D66  1  C5 49                CMP     TOKEN           ;if not token
001D68  1  D0 57                BNE     M23             ;then
001D6A  1  A5 7F                LDA     VARIND          ;get varindex
001D6C  1  A6 7B                LDX     SP
001D6E  1  9D D7 2E             STA     VAR,X           ;set var(sp)
001D71  1  A2 00                LDX     #0
001D73  1  86 9E                STX     INDEX           ;index=0
001D75  1               M22
001D75  1  B5 4E                LDA     ACCUM,X         ;accum(index)
001D77  1  20 9F 1C             JSR     STVRCI
001D7A  1  E6 9E                INC     INDEX           ;index=index+1
001D7C  1  A6 9E                LDX     INDEX
001D7E  1  E4 4E                CPX     ACCLEN          ;if < length
001D80  1  90 F3                BCC     M22             ;then loop
001D82  1  F0 F1                BEQ     M22             ;loop also if equal
001D84  1  A6 7B                LDX     SP
001D86  1  A5 4C                LDA     HSHCDE
001D88  1  9D B7 2E             STA     HASH,X          ;hash(sp)=hashcode
001D8B  1  A5 4A                LDA     SUBTYP
001D8D  1  9D 17 2F             STA     STYPE,X         ;stype(sp)=subtype
001D90  1  A5 98                LDA     I
001D92  1  0A                   ASL     A
001D93  1  85 9F                STA     I2
001D95  1  A5 99                LDA     I+1
001D97  1  2A                   ROL     A
001D98  1  85 A0                STA     I2+1            ;i2=i*2
001D9A  1  18                   CLC
001D9B  1  A5 9F                LDA     I2
001D9D  1  69 E3                ADC     #<READ2
001D9F  1  85 9F                STA     I2
001DA1  1  A5 A0                LDA     I2+1
001DA3  1  69 20                ADC     #>READ2
001DA5  1  85 A0                STA     I2+1            ;read2(i)
001DA7  1  A0 00                LDY     #0
001DA9  1  B1 9F                LDA     (I2),Y          ;low
001DAB  1  85 79                STA     STATE
001DAD  1  C8                   INY
001DAE  1  B1 9F                LDA     (I2),Y
001DB0  1  85 7A                STA     STATE+1         ;state=read2(i)
001DB2  1  A9 FF                LDA     #TRUE
001DB4  1  85 7E                STA     NOLOOK          ;nolook=true
001DB6  1  A5 9A                LDA     J
001DB8  1  A4 9B                LDY     J+1
001DBA  1  85 98                STA     I
001DBC  1  84 99                STY     I+1
001DBE  1  4C D2 1D             JMP     M24
001DC1  1               M23
001DC1  1  A5 98                LDA     I
001DC3  1  C5 9A                CMP     J               ;ok if different
001DC5  1  D0 0B                BNE     M24
001DC7  1  A5 99                LDA     I+1
001DC9  1  C5 9B                CMP     J+1
001DCB  1  D0 05                BNE     M24             ;ok if different
001DCD  1  A9 0F                LDA     #15             ;no legal production
001DCF  1  20 AB 0A             JSR     ERROR
001DD2  1               M24
001DD2  1  E6 98                INC     I               ;bump i and loop
001DD4  1  D0 02                BNE     *+4
001DD6  1  E6 99                INC     I+1
001DD8  1  4C 4B 1D             JMP     M20
001DDB  1               M30
001DDB  1  A9 BD                LDA     #<MAXPNO        ;if state <= maxpno
001DDD  1  C5 79                CMP     STATE
001DDF  1  A9 00                LDA     #>MAXPNO
001DE1  1  E5 7A                SBC     STATE+1
001DE3  1  90 03                BCC     *+5
001DE5  1  4C 73 1E             JMP     M40
001DE8  1  20 6F 1C             JSR     GETIN2          ;index2(state)
001DEB  1  85 98                STA     I               ;ignore high
001DED  1  38                   SEC
001DEE  1  A5 7B                LDA     SP
001DF0  1  E5 98                SBC     I
001DF2  1  85 7C                STA     MP              ;mp=sp-getin2
001DF4  1  A8                   TAY
001DF5  1  C8                   INY
001DF6  1  84 7D                STY     MPP1            ;mpp1=mp+1
001DF8  1  38                   SEC
001DF9  1  A5 79                LDA     STATE
001DFB  1  E9 BD                SBC     #<MAXPNO        ;parameter=state-maxpno
001DFD  1  20 DC 15             JSR     SYNTHE          ;synthesize(state-maxpno)
001E00  1  2C 06 2E             BIT     CMPLNG          ;if compiling
001E03  1  30 03                BMI     *+5             ;then go
001E05  1  4C E2 1C             JMP     M10             ;else go to do while pass 1 or pass 2
001E08  1  A5 7C                LDA     MP
001E0A  1  85 7B                STA     SP              ;sp=mp
001E0C  1  20 48 1C             JSR     GETIN1
001E0F  1  85 98                STA     I
001E11  1  84 99                STY     I+1             ;i=getin1
001E13  1  A6 7B                LDX     SP
001E15  1  BD D7 2E             LDA     VAR,X
001E18  1  85 7F                STA     VARIND          ;varindex=var(sp)
001E1A  1  8A                   TXA
001E1B  1  0A                   ASL     A
001E1C  1  AA                   TAX                     ;word addressing
001E1D  1  BD B7 2F             LDA     STSTAK,X
001E20  1  85 9A                STA     J
001E22  1  BD B8 2F             LDA     STSTAK+1,X
001E25  1  85 9B                STA     J+1             ;j=statestack(sp)
001E27  1               M31
001E27  1  A2 00                LDX     #0
001E29  1  86 9D                STX     K+1             ;high must be zero
001E2B  1  A6 98                LDX     I
001E2D  1  BD 63 20             LDA     APPLY1,X
001E30  1  85 9C                STA     K
001E32  1  F0 11                BEQ     M33             ;exit if k=0
001E34  1  C5 9A                CMP     J
001E36  1  D0 04                BNE     M32             ;ok if low k <> low j
001E38  1  A5 9B                LDA     J+1
001E3A  1  F0 09                BEQ     M33             ;if =0 then j=k
001E3C  1               M32
001E3C  1  E6 98                INC     I
001E3E  1  D0 E7                BNE     M31             ;loop
001E40  1  E6 99                INC     I+1
001E42  1  4C 27 1E             JMP     M31
001E45  1               M33
001E45  1  A5 98                LDA     I               ;ignore high i
001E47  1  0A                   ASL     A
001E48  1  85 9F                STA     I2
001E4A  1  A5 99                LDA     I+1
001E4C  1  2A                   ROL     A
001E4D  1  85 A0                STA     I2+1
001E4F  1  18                   CLC
001E50  1  A5 9F                LDA     I2
001E52  1  69 AB                ADC     #<APPLY2
001E54  1  85 9F                STA     I2
001E56  1  A5 A0                LDA     I2+1
001E58  1  69 23                ADC     #>APPLY2
001E5A  1  85 A0                STA     I2+1
001E5C  1  A0 00                LDY     #0
001E5E  1  B1 9F                LDA     (I2),Y
001E60  1  85 79                STA     STATE
001E62  1  C8                   INY
001E63  1  B1 9F                LDA     (I2),Y
001E65  1  85 7A                STA     STATE+1         ;state=apply2(i)
001E67  1  05 79                ORA     STATE
001E69  1  D0 05                BNE     *+7             ;if not zero then
001E6B  1  A9 00                LDA     #FALSE
001E6D  1  8D 06 2E             STA     CMPLNG          ;compiling=false
001E70  1  4C 09 1D             JMP     M14
001E73  1               M40
001E73  1  A9 AF                LDA     #<MAXLNO        ;if state
001E75  1  C5 79                CMP     STATE
001E77  1  A9 00                LDA     #>MAXLNO
001E79  1  E5 7A                SBC     STATE+1         ;> maxlno
001E7B  1  90 55                BCC     M50             ;then go to next
001E7D  1  20 48 1C             JSR     GETIN1
001E80  1  85 98                STA     I
001E82  1  84 99                STY     I+1             ;i=getin1
001E84  1  20 93 1C             JSR     LAHEAD          ;lookahead
001E87  1               M41
001E87  1  A2 00                LDX     #0
001E89  1  86 9D                STX     K+1
001E8B  1  18                   CLC
001E8C  1  A5 98                LDA     I
001E8E  1  69 CC                ADC     #<LOOK1
001E90  1  85 9F                STA     I2
001E92  1  A5 99                LDA     I+1
001E94  1  69 1F                ADC     #>LOOK1
001E96  1  85 A0                STA     I2+1
001E98  1  A0 00                LDY     #0
001E9A  1  B1 9F                LDA     (I2),Y          ;a=look1(i)
001E9C  1  85 9C                STA     K
001E9E  1  F0 0D                BEQ     M42             ;exit if k=0
001EA0  1  C5 49                CMP     TOKEN
001EA2  1  F0 09                BEQ     M42             ;or if =token
001EA4  1  E6 98                INC     I               ;bump and loop
001EA6  1  D0 DF                BNE     M41
001EA8  1  E6 99                INC     I+1
001EAA  1  4C 87 1E             JMP     M41
001EAD  1               M42
001EAD  1  A5 98                LDA     I               ;word addressing
001EAF  1  0A                   ASL     A
001EB0  1  85 9F                STA     I2
001EB2  1  A5 99                LDA     I+1
001EB4  1  2A                   ROL     A
001EB5  1  85 A0                STA     I2+1
001EB7  1  18                   CLC
001EB8  1  A5 9F                LDA     I2              ;add start
001EBA  1  69 7D                ADC     #<LOOK2
001EBC  1  85 9F                STA     I2
001EBE  1  A5 A0                LDA     I2+1
001EC0  1  69 22                ADC     #>LOOK2
001EC2  1  85 A0                STA     I2+1
001EC4  1  A0 00                LDY     #0
001EC6  1  B1 9F                LDA     (I2),Y          ;low
001EC8  1  85 79                STA     STATE
001ECA  1  C8                   INY
001ECB  1  B1 9F                LDA     (I2),Y
001ECD  1  85 7A                STA     STATE+1
001ECF  1  4C 09 1D             JMP     M14
001ED2  1               M50
001ED2  1  20 85 1C             JSR     INCSP
001ED5  1  20 6F 1C             JSR     GETIN2
001ED8  1  48                   PHA                     ;save low
001ED9  1  A5 7B                LDA     SP
001EDB  1  0A                   ASL     A               ;word addressing
001EDC  1  AA                   TAX
001EDD  1  68                   PLA
001EDE  1  9D B7 2F             STA     STSTAK,X        ;statestack(sp)=getin2
001EE1  1  98                   TYA
001EE2  1  9D B8 2F             STA     STSTAK+1,X
001EE5  1  20 48 1C             JSR     GETIN1
001EE8  1  85 79                STA     STATE
001EEA  1  84 7A                STY     STATE+1         ;state=getin1
001EEC  1  4C 09 1D             JMP     M14
001EEF  1               ;end of do while pass 1 or pass 2
001EEF  1               EWP1P2
001EEF  1  A9 FF                LDA     #TRUE
001EF1  1  8D 00 2E             STA     LSTSRC          ;listsource=true
001EF4  1  20 B1 1C             JSR     INTLZ           ;initialize
001EF7  1  A9 FF                LDA     #TRUE
001EF9  1  8D FE 2D             STA     PASS2           ;pass2=true
001EFC  1  4C E2 1C             JMP     M10             ;do forever
001EFF  1               ;parser state tables
001EFF  1               READ1
001EFF  1  00 31 0A 0D          .BYTE   0,49,10,13,2,49,50,52,53,54,49,13,22,32,2,3,7,27,30,49,50,52,53
001F03  1  02 31 32 34  
001F07  1  35 36 31 0D  
001F16  1  36 02 03 07          .BYTE   54,2,3,7,30,49,50,52,53,54,54,52,12,52,2,3,7,49,50,52,53,54,12
001F1A  1  1E 31 32 34  
001F1E  1  35 36 36 34  
001F2D  1  34 31 31 32          .BYTE   52,49,49,50,2,3,7,12,30,49,50,52,53,54,2,2,2,9,5,9,49,4,8,49,16
001F31  1  02 03 07 0C  
001F35  1  1E 31 32 34  
001F46  1  14 1C 1D 1F          .BYTE   20,28,29,31,35,36,37,38,40,42,43,44,45,46,48,49,51,52,49,14,6
001F4A  1  23 24 25 26  
001F4E  1  28 2A 2B 2C  
001F5B  1  16 0D 34 09          .BYTE   22,13,52,9,52,9,23,9,21,33,41,16,21,33,36,43,9,21,33,5,9,21,33
001F5F  1  34 09 17 09  
001F63  1  15 21 29 10  
001F72  1  05 15 21 05          .BYTE   5,21,33,5,9,21,33,5,9,21,33,6,9,21,33,21,33,39,21,33,41,5,21,33
001F76  1  09 15 21 05  
001F7A  1  09 15 21 06  
001F8A  1  06 15 21 09          .BYTE   6,21,33,9,6,9,16,17,20,25,26,27,28,29,31,35,36,37,38,40,42,43
001F8E  1  06 09 10 11  
001F92  1  14 19 1A 1B  
001FA0  1  2C 2D 2E 30          .BYTE   44,45,46,48,51,52,2,16,20,28,29,31,35,36,37,38,40,42,43,44,45
001FA4  1  33 34 02 10  
001FA8  1  14 1C 1D 1F  
001FB5  1  2E 30 33 34          .BYTE   46,48,51,52,52,13,24,11,34,9,2,1,3,7,10,13,15,18,19,3,7,9,0
001FB9  1  34 0D 18 0B  
001FBD  1  22 09 02 01  
001FCC  1               LOOK1
001FCC  1  00 31 00 0A          .BYTE   0,49,0,10,13,0,13,0,11,23,34,0,52,0,12,52,0,49,50,0,6,9,11,23
001FD0  1  0D 00 0D 00  
001FD4  1  0B 17 22 00  
001FE4  1  22 00 02 00          .BYTE   34,0,2,0,2,0,9,0,4,8,0,4,8,0,4,8,0,4,8,0,4,8,0,11,23,34,0,14,0
001FE8  1  02 00 09 00  
001FEC  1  04 08 00 04  
002001  1  0E 00 0E 00          .BYTE   14,0,14,0,9,0,9,0,9,0,9,0,9,0,21,33,0,21,33,0,21,33,0,21,33,0
002005  1  09 00 09 00  
002009  1  09 00 09 00  
00201B  1  15 21 27 00          .BYTE   21,33,39,0,21,33,0,21,33,0,21,33,0,23,0,21,33,0,21,33,0,9,0,9
00201F  1  15 21 00 15  
002023  1  21 00 15 21  
002033  1  00 06 09 00          .BYTE   0,6,9,0,52,0,11,23,0,11,23,34,0,2,0,11,23,0,52,0,24,0,24,0,11
002037  1  34 00 0B 17  
00203B  1  00 0B 17 22  
00204C  1  00 17 00 0B          .BYTE   0,23,0,11,0,9,0,2,0,1,3,7,10,13,15,18,19,0,3,7,0,9,0
002050  1  00 09 00 02  
002054  1  00 01 03 07  
002063  1               APPLY1
002063  1  00 00 00 00          .BYTE   0,0,0,0,55,105,0,19,0,0,32,47,0,0,3,4,12,14,16,17,20,21,22,26
002067  1  37 69 00 13  
00206B  1  00 00 20 2F  
00207B  1  1B 22 24 26          .BYTE   27,34,36,38,40,98,100,102,103,114,116,0,0,46,0,28,0,33,0,63,0,5
00207F  1  28 62 64 66  
002083  1  67 72 74 00  
002091  1  06 08 09 00          .BYTE   6,8,9,0,7,10,0,23,0,13,19,32,35,47,55,99,101,105,106,0,0,0,0,0
002095  1  07 0A 00 17  
002099  1  00 0D 13 20  
0020A9  1  27 00 00 00          .BYTE   39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,99
0020AD  1  00 00 00 00  
0020B1  1  00 00 00 00  
0020C7  1  6A 00 00 00          .BYTE   106,0,0,0,0,0,40,0,0,0,0,0,0,62,0,0,74,0,74,0,0,0,0,0,0,0,0,0
0020CB  1  00 00 28 00  
0020CF  1  00 00 00 00  
0020E3  1               READ2
0020E3  1  00 00 BF 00          .WORD   0,191,264,260,3,255,256,129,254,253,326,258,329,331,3,5,8,31
0020E7  1  08 01 04 01  
0020EB  1  03 00 FF 00  
002107  1  21 00 FF 00          .WORD   33,255,256,129,254,253,3,5,8,33,255,256,129,254,253,279,42,21
00210B  1  00 01 81 00  
00210F  1  FE 00 FD 00  
00212B  1  81 00 03 00          .WORD   129,3,5,8,255,256,129,254,253,20,129,273,255,256,3,5,8,20,33
00212F  1  05 00 08 00  
002133  1  FF 00 00 01  
002151  1  FF 00 00 01          .WORD   255,256,129,254,253,247,294,4,335,280,283,320,7,10,327,24,26
002155  1  81 00 FE 00  
002159  1  FD 00 F7 00  
002173  1  0C 01 20 00          .WORD   268,32,34,285,328,125,126,338,38,330,127,128,337,340,275,341
002177  1  22 00 1D 01  
00217B  1  48 01 7D 00  
002193  1  81 00 45 01          .WORD   129,325,23,302,27,220,130,17,131,13,190,14,223,224,277,24,223
002197  1  17 00 2E 01  
00219B  1  1B 00 DC 00  
0021B5  1  E0 00 48 01          .WORD   224,328,330,12,223,224,246,248,223,224,244,223,224,249,252,223
0021B9  1  4A 01 0C 00  
0021BD  1  DF 00 E0 00  
0021D5  1  E0 00 25 01          .WORD   224,293,295,223,224,316,16,223,224,223,224,36,223,224,37,288
0021D9  1  27 01 DF 00  
0021DD  1  E0 00 3C 01  
0021F5  1  DF 00 E0 00          .WORD   223,224,317,223,224,15,318,319,24,25,26,29,30,339,268,32,34,285
0021F9  1  3D 01 DF 00  
0021FD  1  E0 00 0F 00  
002219  1  48 01 7D 00          .WORD   328,125,126,338,38,330,127,128,337,340,341,129,251,24,26,268,32
00221D  1  7E 00 52 01  
002221  1  26 00 4A 01  
00223B  1  22 00 1D 01          .WORD   34,285,328,125,126,338,38,330,127,128,337,340,341,129,45,22,28
00223F  1  48 01 7D 00  
002243  1  7E 00 52 01  
00225D  1  7C 00 14 01          .WORD   124,276,286,282,122,6,9,123,257,259,261,265,6,9,11,0
002261  1  1E 01 1A 01  
002265  1  7A 00 06 00  
00227D  1               LOOK2
00227D  1  00 00 01 00          .WORD   0,1,176,2,2,263,18,262,177,177,177,19,334,333,35,35,178,39,39
002281  1  B0 00 02 00  
002285  1  02 00 07 01  
0022A3  1  B3 00 B4 00          .WORD   179,180,180,180,180,180,40,41,245,43,181,44,332,49,49,231,50,50
0022A7  1  B4 00 B4 00  
0022AB  1  B4 00 B4 00  
0022C7  1  EA 00 33 00          .WORD   234,51,51,235,52,52,232,53,53,233,182,182,182,55,57,236,58,237
0022CB  1  33 00 EB 00  
0022CF  1  34 00 34 00  
0022EB  1  3B 00 EE 00          .WORD   59,238,66,308,68,300,69,299,70,301,72,296,76,76,297,77,77,309
0022EF  1  42 00 34 01  
0022F3  1  44 00 2C 01  
00230F  1  4E 00 4E 00          .WORD   78,78,219,84,84,312,85,85,85,183,87,87,336,88,88,298,89,89,310
002313  1  DB 00 54 00  
002317  1  54 00 38 01  
002335  1  16 01 5B 00          .WORD   278,91,93,93,313,94,94,269,95,321,96,322,97,97,184,99,185,186
002339  1  5D 00 5D 00  
00233D  1  39 01 5E 00  
002359  1  BA 00 65 00          .WORD   186,101,314,314,314,102,104,250,187,187,105,106,188,109,221,110
00235D  1  3A 01 3A 01  
002361  1  3A 01 66 00  
002379  1  DE 00 6F 00          .WORD   222,111,193,274,112,113,272,115,284,117,189,118,118,118,118,118
00237D  1  C1 00 12 01  
002381  1  70 00 71 00  
002399  1  76 00 76 00          .WORD   118,118,118,229,119,119,230,120,290
00239D  1  76 00 E5 00  
0023A1  1  77 00 77 00  
0023AB  1               APPLY2
0023AB  1  00 00 00 00          .WORD   0,0,161,71,169,170,168,199,198,200,218,267,201,98,80,90,151,152
0023AF  1  A1 00 47 00  
0023B3  1  A9 00 AA 00  
0023CF  1  5C 00 9B 00          .WORD   92,155,83,86,154,74,150,75,156,146,147,148,149,153,82,79,81,73
0023D3  1  53 00 56 00  
0023D7  1  9A 00 4A 00  
0023F3  1  2E 00 A7 00          .WORD   46,167,166,226,225,228,227,174,173,133,135,134,136,132,139,140
0023F7  1  A6 00 E2 00  
0023FB  1  E1 00 E4 00  
002413  1  8A 00 F0 00          .WORD   138,240,239,305,64,64,304,64,64,304,64,64,304,241,114,243,116
002417  1  EF 00 31 01  
00241B  1  40 00 40 00  
002435  1  A3 00 3C 00          .WORD   163,60,242,63,202,61,47,266,194,271,164,137,197,172,108,107,204
002439  1  F2 00 3F 00  
00243D  1  CA 00 3D 00  
002457  1  41 00 AB 00          .WORD   65,171,287,196,175,292,291,103,205,145,206,210,165,143,144,142
00245B  1  1F 01 C4 00  
00245F  1  AF 00 24 01  
002477  1  CF 00 9F 00          .WORD   207,159,141,307,100,160,162,208,213,56,62,158,157,209,323,48
00247B  1  8D 00 33 01  
00247F  1  64 00 A0 00  
002497  1  44 01 36 00          .WORD   324,54,203,67,216,212,211,195,214,215
00249B  1  CB 00 43 00  
00249F  1  D8 00 D4 00  
0024AB  1               INDEX1
0024AB  1  00 00 01 00          .WORD   0,1,2,24,24,4,4,4,4,4,4,34,24,36,24,10,24,24,11,168,24,24,24,4
0024AF  1  02 00 18 00  
0024B3  1  18 00 04 00  
0024DB  1  0C 00 0E 00          .WORD   12,14,24,24,24,33,34,35,36,37,24,45,24,47,24,48,50,60,61,62,63
0024DF  1  18 00 18 00  
0024E3  1  18 00 21 00  
002505  1  40 00 18 00          .WORD   64,24,36,66,67,67,67,67,67,69,70,89,90,90,90,91,92,89,37,93,94
002509  1  24 00 42 00  
00250D  1  43 00 43 00  
00252F  1  5F 00 60 00          .WORD   95,96,97,97,97,98,99,100,103,108,100,100,100,111,115,118,122
002533  1  61 00 61 00  
002537  1  61 00 62 00  
002551  1  7E 00 64 00          .WORD   126,100,130,133,100,100,100,136,100,139,100,100,142,142,143,24
002555  1  82 00 85 00  
002559  1  64 00 64 00  
002571  1  24 00 18 00          .WORD   36,24,145,24,24,167,168,36,186,187,188,188,189,189,189,24,191
002575  1  91 00 18 00  
002579  1  18 00 A7 00  
002593  1  18 00 C0 00          .WORD   24,192,193,201,203,1,3,6,8,12,14,17,20,26,28,30,32,35,38,41,44
002597  1  C1 00 C9 00  
00259B  1  CB 00 01 00  
0025BD  1  2F 00 33 00          .WORD   47,51,53,55,57,59,61,63,65,67,70,73,76,79,83,86,89,92,94,97,100
0025C1  1  35 00 37 00  
0025C5  1  39 00 3B 00  
0025E7  1  66 00 68 00          .WORD   102,104,107,109,112,116,118,121,123,125,127,129,131,133,135,137
0025EB  1  6B 00 6D 00  
0025EF  1  70 00 74 00  
002607  1  92 00 95 00          .WORD   146,149,192,217,306,303,311,289,217,270,315,306,217,217,306,281
00260B  1  C0 00 D9 00  
00260F  1  32 01 2F 01  
002627  1  01 00 02 00          .WORD   1,2,2,3,3,3,3,3,4,4,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,13
00262B  1  02 00 03 00  
00262F  1  03 00 03 00  
002665  1  0E 00 0E 00          .WORD   14,14,36,36,37,37,39,39,41,41,43,43,43,43,43,45,45,45,50,50,53
002669  1  24 00 24 00  
00266D  1  25 00 25 00  
00268F  1  35 00 35 00          .WORD   53,53,53,55,55,66,66,67,67,68,68,69,69,70,70,72,72,72,72,72,72
002693  1  35 00 37 00  
002697  1  37 00 42 00  
0026B9  1  48 00 48 00          .WORD   72,72,72,73,74,75,76,76,77,77,77,78,78,79,80,81,82,83,83,84,84
0026BD  1  48 00 49 00  
0026C1  1  4A 00 4B 00  
0026E3  1  55 00 56 00          .WORD   85,86,86,87,88,88,89,90,90,91,93,93,94,95,95,96,96,97,98,98,99
0026E7  1  56 00 57 00  
0026EB  1  58 00 58 00  
00270D  1  63 00 63 00          .WORD   99,99,102,102,103,103,103,104,104,105,105,106,106,108,108,109
002711  1  66 00 66 00  
002715  1  67 00 67 00  
00272D  1  6E 00 6E 00          .WORD   110,110,111,112,113,113,115,116,116,118,118,120,120,121,121,122
002731  1  6F 00 70 00  
002735  1  71 00 71 00  
00274D  1  7B 00 7C 00          .WORD   123,124,125,126,127
002751  1  7D 00 7E 00  
002755  1  7F 00        
002757  1               INDEX2
002757  1  00 01 02 09          .BYTE   0,1,2,9,9,6,6,6,6,6,6,1,9,1,9,1
00275B  1  09 06 06 06  
00275F  1  06 06 06 01  
002767  1  09 09 01 12          .BYTE   9,9,1,18,9,9,9,6,2,10,9,9,9,1,1
00276B  1  09 09 09 06  
00276F  1  02 0A 09 09  
002776  1  01 01 08 09          .BYTE   1,1,8,9,2,9,1,9,2,10,1,1,1,1,2
00277A  1  02 09 01 09  
00277E  1  02 0A 01 01  
002785  1  09 01 01 02          .BYTE   9,1,1,2,2,2,2,2,1,19,1,1,1,1,1,1
002789  1  02 02 02 02  
00278D  1  01 13 01 01  
002795  1  01 08 01 01          .BYTE   1,8,1,1,1,1,1,1,1,1,1,3,5,3,2,2
002799  1  01 01 01 01  
00279D  1  01 01 01 03  
0027A5  1  02 04 03 04          .BYTE   2,4,3,4,4,4,2,3,3,2,2,2,3,2,3,2
0027A9  1  04 04 02 03  
0027AD  1  03 02 02 02  
0027B5  1  02 01 01 02          .BYTE   2,1,1,2,9,1,9,22,9,9,1,18,1,1,1
0027B9  1  09 01 09 16  
0027BD  1  09 09 01 12  
0027C4  1  01 01 01 02          .BYTE   1,1,1,2,1,9,1,9,1,8,2,1,2,3,2,4
0027C8  1  01 09 01 09  
0027CC  1  01 08 02 01  
0027D4  1  02 03 03 06          .BYTE   2,3,3,6,2,2,2,3,3,3,3,3,4,2,2,2
0027D8  1  02 02 02 03  
0027DC  1  03 03 03 03  
0027E4  1  02 02 02 02          .BYTE   2,2,2,2,2,3,3,3,3,4,3,3,3,2,3,3
0027E8  1  02 03 03 03  
0027EC  1  03 04 03 03  
0027F4  1  02 02 03 02          .BYTE   2,2,3,2,3,4,2,3,2,2,2,2,2,2,2,2
0027F8  1  03 04 02 03  
0027FC  1  02 02 02 02  
002804  1  09 03 02 01          .BYTE   9,3,2,1,19,35,39,40,43,55,85,97
002808  1  13 23 27 28  
00280C  1  2B 37 55 61  
002810  1  63 65 69 6A          .BYTE   99,101,105,106,117,2,0,0,0,0,0,0
002814  1  75 02 00 00  
002818  1  00 00 00 00  
00281C  1  00 00 02 00          .BYTE   0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
002820  1  00 00 00 00  
002824  1  00 00 00 00  
00282B  1  00 00 00 00          .BYTE   0,0,0,0,0,0,1,1,1,0,2,0,0,0,2,0
00282F  1  00 00 01 01  
002833  1  01 00 02 00  
00283B  1  01 00 02 00          .BYTE   1,0,2,0,2,2,1,1,0,2,2,0,2,0,0,0
00283F  1  02 02 01 01  
002843  1  00 02 02 00  
00284B  1  02 00 02 01          .BYTE   2,0,2,1,2,2,0,1,2,0,0,0,0,0,1,0
00284F  1  02 02 00 01  
002853  1  02 00 00 00  
00285B  1  01 00 00 00          .BYTE   1,0,0,0,1,0,3,1,0,1,0,0,1,5,1,1
00285F  1  01 00 03 01  
002863  1  00 01 00 00  
00286B  1  02 02 03 01          .BYTE   2,2,3,1,2,0,0,2,1,0,2,1,2,0,1,0
00286F  1  02 00 00 02  
002873  1  01 00 02 01  
00287B  1  02 02 01 02          .BYTE   2,2,1,2,1,0,2,2,1,2,1,0,0,2,0,2
00287F  1  01 00 02 02  
002883  1  01 02 01 00  
00288B  1  02 00 02 00          .BYTE   2,0,2,0,0,2,0,0,2,4,0,0,1,1,1,2
00288F  1  00 02 00 00  
002893  1  02 04 00 00  
00289B  1  02 00 02 01          .BYTE   2,0,2,1,0,1,0,1,1,0,0,2,3,0,0,0
00289F  1  00 01 00 01  
0028A3  1  01 00 00 02  
0028AB  1  00 00                .BYTE   0,0
0028AD  1               ;reserved word tables
0028AD  1               ;length=1
0028AD  1               LNG1
0028AD  1  0D 3C 28 2B          .BYTE   CR,"<(+*)-,=/",semico,">:#^"
0028B1  1  2A 29 2D 2C  
0028B5  1  3D 2F 3B 3E  
0028BC  1               ;length=2
0028BC  1               LNG2
0028BC  1  49 46 54 4F          .BYTE   "IFTOGOONOREQLTGTLEGENE"
0028C0  1  47 4F 4F 4E  
0028C4  1  4F 52 45 51  
0028D2  1               ;length=3
0028D2  1               LNG3
0028D2  1  46 4F 52 4C          .BYTE   "FORLETREMDIMDEFNOTAND"
0028D6  1  45 54 52 45  
0028DA  1  4D 44 49 4D  
0028E7  1  54 41 4E 53          .BYTE   "TANSINCOSSQRTABLOGLEN"
0028EB  1  49 4E 43 4F  
0028EF  1  53 53 51 52  
0028FC  1  46 52 45 41          .BYTE   "FREATNABSEXPINTEND"
002900  1  54 4E 41 42  
002904  1  53 45 58 50  
00290E  1  50 4F 53 52          .BYTE   "POSRNDSGNASCVALXORSUB"
002912  1  4E 44 53 47  
002916  1  4E 41 53 43  
002923  1               ;length=4
002923  1               LNG4
002923  1  50 45 45 4B          .BYTE   "PEEKPOKE"
002927  1  50 4F 4B 45  
00292B  1  54 48 45 4E          .BYTE   "THENREADGOTOELSENEXTSTOPDATA"
00292F  1  52 45 41 44  
002933  1  47 4F 54 4F  
002947  1  46 49 4C 45          .BYTE   "FILECHR$MID$STEPSTR$CALLSINH"
00294B  1  43 48 52 24  
00294F  1  4D 49 44 24  
002963  1               ;length=5
002963  1               LNG5
002963  1  50 52 49 4E          .BYTE   "PRINTINPUTGOSUBCLOSELEFT$"
002967  1  54 49 4E 50  
00296B  1  55 54 47 4F  
00297C  1               ;length=6
00297C  1               LNG6
00297C  1  52 45 54 55          .BYTE   "RETURNRIGHT$REMARK"
002980  1  52 4E 52 49  
002984  1  47 48 54 24  
00298E  1               ;length=7
00298E  1               LNG7
00298E  1  52 45 53 54          .BYTE   "RESTORE"
002992  1  4F 52 45     
002995  1               ;length=9
002995  1               LNG9
002995  1  52 41 4E 44          .BYTE   "RANDOMIZE"
002999  1  4F 4D 49 5A  
00299D  1  45           
00299E  1               ;token table
00299E  1               ;this table must be ordered in the same order as the reserved word table.  the
00299E  1               ;first entry does not correspond to any valid token.
00299E  1               TK
00299E  1  00                   .BYTE   0
00299F  1               ;length=1
00299F  1  17 01 02 03          .BYTE   TCR,LESST,LPARN,TPLUS,ASTRK,RPARN,TMINUS,COMMA,EQUAL,SLASH
0029A3  1  04 05 07 09  
0029A7  1  0D 08        
0029A9  1  06 0A 0B 0C          .BYTE   SCOLN,GTRT,TCOLIN,POUND,EXPON
0029AD  1  0E           
0029AE  1               ;length=2
0029AE  1  11 16 10 14          .BYTE   TIF,TTO,TGO,TON,TOR,EQUAL,LESST,GTRT,TLEQ,TGEQ,TNE
0029B2  1  15 0D 01 0A  
0029B6  1  12 0F 13     
0029B9  1               ;length=3
0029B9  1  1C 1D 00 1A          .BYTE   TFOR,TLET,TREM,TDIM,TDEF,TNOT,TAND,72,69,70,73,74,78,84,76,71
0029BD  1  19 1E 18 48  
0029C1  1  45 46 49 4A  
0029C9  1  41 4B 42 1B          .BYTE   65,75,66,TEND,79,67,68,81,88,TXOR,TSUB
0029CD  1  4F 43 44 51  
0029D1  1  58 21 20     
0029D4  1               ;length=4
0029D4  1  50 1F                .BYTE   80,TOUT
0029D6  1  29 26 24 22          .BYTE   TTHEN,TREAD,TGOTO,TELSE,TNEXT,TSTOP,TDATA,TFILE,82,85,TSTEP
0029DA  1  25 28 63 23  
0029DE  1  52 55 27     
0029E1  1  57 59 5A             .BYTE   87,89,90
0029E4  1               ;length=5
0029E4  1  2D 2C 2B 2A          .BYTE   TPRNT,TINPT,TGOSB,TCLOS,83
0029E8  1  53           
0029E9  1               ;length=6
0029E9  1  2E 56 00             .BYTE   TRETN,86,TREM
0029EC  1               ;length=7
0029EC  1  30                   .BYTE   TREST
0029ED  1               ;length=9
0029ED  1  33                   .BYTE   TIRN
0029EE  1               ;token offset table
0029EE  1               OFFSET
0029EE  1  00 00 0F 25          .BYTE   0,0,15,37,118,182,207,225,232,232
0029F2  1  76 B6 CF E1  
0029F6  1  E8 E8        
0029F8  1               ;reserved word count table
0029F8  1               ;each entry is the number of reserved words of the associated length (0 and up)
0029F8  1               COUNT
0029F8  1  00 0F 0B 1B          .BYTE   0,15,11,27,16,5,3,1,0,1
0029FC  1  10 05 03 01  
002A00  1  00 01        
002A02  1               ;each entry is the index into the token table for the first token of the
002A02  1               ;associated length (0 and up)
002A02  1               TKOS
002A02  1  00 00 0F 1A          .BYTE   0,0,15,26,53,69,74,77,78,78
002A06  1  35 45 4A 4D  
002A0A  1  4E 4E        
002A0C  1               ;
002A0C  1               ST
002A0C  1  01 01 00 01          .BYTE   1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,5,65,70,5,71,70,65,5,1,1
002A10  1  01 01 01 01  
002A14  1  01 01 01 00  
002A26  1               ;error messages
002A26  1               ERM0
002A26  1  44 55 50 4C          .BYTE   "DUPLICATE LABELS OR "
002A2A  1  49 43 41 54  
002A2E  1  45 20 4C 41  
002A3A  1  53 59 4E 43          .BYTE   "SYNCHRONIZATION ERROR$"
002A3E  1  48 52 4F 4E  
002A42  1  49 5A 41 54  
002A50  1               ERM1
002A50  1  49 44 45 4E          .BYTE   "IDENTIFIER IN DIM "
002A54  1  54 49 46 49  
002A58  1  45 52 20 49  
002A62  1  50 52 45 56          .BYTE   "PREVIOUSLY DEFINED$"
002A66  1  49 4F 55 53  
002A6A  1  4C 59 20 44  
002A75  1               ERM2
002A75  1  50 52 45 44          .BYTE   "PREDEFINED FUNCTION "
002A79  1  45 46 49 4E  
002A7D  1  45 44 20 46  
002A89  1  4E 41 4D 45          .BYTE   "NAME PREVIOUSLY DEFINED$"
002A8D  1  20 50 52 45  
002A91  1  56 49 4F 55  
002AA1  1               ERM3
002AA1  1  46 4F 52 20          .BYTE   "FOR LOOP INDEX NOT SIMPLE"
002AA5  1  4C 4F 4F 50  
002AA9  1  20 49 4E 44  
002ABA  1  20 46 4C 4F          .BYTE   " FLOATING POINT VARIABLE$"
002ABE  1  41 54 49 4E  
002AC2  1  47 20 50 4F  
002AD3  1               ERM4
002AD3  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF PARAMETERS"
002AD7  1  52 52 45 43  
002ADB  1  54 20 4E 55  
002AF1  1  20 49 4E 20          .BYTE   " IN FUNCTION REFERENCE$"
002AF5  1  46 55 4E 43  
002AF9  1  54 49 4F 4E  
002B08  1               ERM5
002B08  1  49 4E 56 41          .BYTE   "INVALID PARAMETER TYPE IN "
002B0C  1  4C 49 44 20  
002B10  1  50 41 52 41  
002B22  1  46 55 4E 43          .BYTE   "FUNCTION REFERENCE$"
002B26  1  54 49 4F 4E  
002B2A  1  20 52 45 46  
002B35  1               ERM6
002B35  1  55 4E 44 45          .BYTE   "UNDEFINED FUNCTION$"
002B39  1  46 49 4E 45  
002B3D  1  44 20 46 55  
002B48  1               ERM7
002B48  1  49 4E 56 41          .BYTE   "INVALID CHARACTER$"
002B4C  1  4C 49 44 20  
002B50  1  43 48 41 52  
002B5A  1               ERM8
002B5A  1  45 58 50 52          .BYTE   "EXPRESSION IN IF STATEMENT"
002B5E  1  45 53 53 49  
002B62  1  4F 4E 20 49  
002B74  1  20 4E 4F 54          .BYTE   " NOT FLOATING POINT$"
002B78  1  20 46 4C 4F  
002B7C  1  41 54 49 4E  
002B88  1               ERM9
002B88  1  49 4C 4C 45          .BYTE   "ILLEGAL FLOATING POINT FORMAT$"
002B8C  1  47 41 4C 20  
002B90  1  46 4C 4F 41  
002BA6  1               ERM10
002BA6  1  53 55 42 53          .BYTE   "SUBSCRIPTED VARIABLE NOT "
002BAA  1  43 52 49 50  
002BAE  1  54 45 44 20  
002BBF  1  50 52 45 56          .BYTE   "PREVIOUSLY DIMENSIONED$"
002BC3  1  49 4F 55 53  
002BC7  1  4C 59 20 44  
002BD6  1               ERM11
002BD6  1  41 52 52 41          .BYTE   "ARRAY NAME USED AS SIMPLE"
002BDA  1  59 20 4E 41  
002BDE  1  4D 45 20 55  
002BEF  1  20 56 41 52          .BYTE   " VARAIBLE$"
002BF3  1  41 49 42 4C  
002BF7  1  45 24        
002BF9  1               ERM12
002BF9  1  53 54 52 49          .BYTE   "STRING EXPRESSION NOT ALLOWED$"
002BFD  1  4E 47 20 45  
002C01  1  58 50 52 45  
002C17  1               ERM13
002C17  1  4D 49 58 45          .BYTE   "MIXED MODE (STRING - FLOATING)"
002C1B  1  44 20 4D 4F  
002C1F  1  44 45 20 28  
002C35  1  20 45 58 50          .BYTE   " EXPRESSION$"
002C39  1  52 45 53 53  
002C3D  1  49 4F 4E 24  
002C41  1               ERM14
002C41  1  4E 45 58 54          .BYTE   "NEXT VARIABLE DOES NOT "
002C45  1  20 56 41 52  
002C49  1  49 41 42 4C  
002C58  1  4D 41 54 43          .BYTE   "MATCH FOR$"
002C5C  1  48 20 46 4F  
002C60  1  52 24        
002C62  1               ERM15
002C62  1  4E 4F 20 50          .BYTE   "NO PRODUCTION EXISTS$"
002C66  1  52 4F 44 55  
002C6A  1  43 54 49 4F  
002C77  1               ERM16
002C77  1  4E 45 58 54          .BYTE   "NEXT STATEMENT WITHOUT "
002C7B  1  20 53 54 41  
002C7F  1  54 45 4D 45  
002C8E  1  4D 41 54 43          .BYTE   "MATCHING FOR$"
002C92  1  48 49 4E 47  
002C96  1  20 46 4F 52  
002C9B  1               ERM17
002C9B  1  49 4E 43 4F          .BYTE   "INCORRECT NUMBER OF "
002C9F  1  52 52 45 43  
002CA3  1  54 20 4E 55  
002CAF  1  53 55 42 53          .BYTE   "SUBSCRIPTS$"
002CB3  1  43 52 49 50  
002CB7  1  54 53 24     
002CBA  1               ERM18
002CBA  1  43 4F 4D 50          .BYTE   "COMPILER STACK OVERFLOW$"
002CBE  1  49 4C 45 52  
002CC2  1  20 53 54 41  
002CD2  1               ERM19
002CD2  1  53 59 4D 42          .BYTE   "SYMBOL TABLE OVERFLOW$"
002CD6  1  4F 4C 20 54  
002CDA  1  41 42 4C 45  
002CE8  1               ERM20
002CE8  1  55 4E 44 45          .BYTE   "UNDEFINED LABEL$"
002CEC  1  46 49 4E 45  
002CF0  1  44 20 4C 41  
002CF8  1               ERM21
002CF8  1  56 41 52 43          .BYTE   "VARC TABLE OVERFLOW$"
002CFC  1  20 54 41 42  
002D00  1  4C 45 20 4F  
002D0C  1               ERM22
002D0C  1  55 4E 54 45          .BYTE   "UNTERMINATED STRING$"
002D10  1  52 4D 49 4E  
002D14  1  41 54 45 44  
002D20  1               ERM23
002D20  1  49 4E 56 41          .BYTE   "INVALID TYPE IN FILE"
002D24  1  4C 49 44 20  
002D28  1  54 59 50 45  
002D34  1  20 49 44 45          .BYTE   " IDENTIFIER$"
002D38  1  4E 54 49 46  
002D3C  1  49 45 52 24  
002D40  1               ERM24
002D40  1  46 4F 52 20          .BYTE   "FOR WITHOUT MATCHING NEXT$"
002D44  1  57 49 54 48  
002D48  1  4F 55 54 20  
002D5A  1               ;error message table
002D5A  1               ERMTBL
002D5A  1  26 2A 50 2A          .WORD   ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
002D5E  1  75 2A A1 2A  
002D62  1  D3 2A 08 2B  
002D6A  1  5A 2B 88 2B          .WORD   ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
002D6E  1  A6 2B D6 2B  
002D72  1  F9 2B 17 2C  
002D7A  1  77 2C 9B 2C          .WORD   ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
002D7E  1  BA 2C D2 2C  
002D82  1  E8 2C F8 2C  
002D8A  1  40 2D                .WORD   ERM24
002D8C  1               ;messages and strings
002D8C  1               PRDMSG
002D8C  1  50 52 4F 44          .BYTE   "PROD $"
002D90  1  20 24        
002D92  1               ERDMSG
002D92  1  20 45 52 52          .BYTE   " ERRORS DETECTED$"
002D96  1  4F 52 53 20  
002D9A  1  44 45 54 45  
002DA3  1               DEMSG
002DA3  1  44 49 53 4B          .BYTE   "DISK ERROR - ABORTING $"
002DA7  1  20 45 52 52  
002DAB  1  4F 52 20 2D  
002DBA  1               BASSTR
002DBA  1  42 41 53             .BYTE   "BAS"
002DBD  1               NSMSG
002DBD  1  4E 4F 20 53          .BYTE   "NO SOURCE - ABORTING $"
002DC1  1  4F 55 52 43  
002DC5  1  45 20 2D 20  
002DD3  1               ADDEND
002DD3  1  45 4E 44 0D          .BYTE   "END",CR,LF
002DD7  1  0A           
002DD8  1               OPNMSG
002DD8  1  42 41 53 49          .BYTE   "BASIC-E/65 COMPILER - "
002DDC  1  43 2D 45 2F  
002DE0  1  36 35 20 43  
002DEE  1  56 45 52 53          .BYTE   "VERSION 2.03-A$"
002DF2  1  49 4F 4E 20  
002DF6  1  32 2E 30 33  
002DFD  1               ;variables - this area holds data moved from page zero to save page zero space
002DFD  1               PASS1
002DFD  1  00                   .BYTE   0               ;pass 1 if true i=TRUE
002DFE  1               PASS2
002DFE  1  00                   .BYTE   0               ;pass 2 if true
002DFF  1               LSTPRD
002DFF  1  00                   .BYTE   0               ;list production if true (listprod)
002E00  1               LSTSRC
002E00  1  00                   .BYTE   0               ;list source if true (listsource)
002E01  1               DEBUGL
002E01  1  00                   .BYTE   0               ;debug line numbers if true (debugln)
002E02  1               LWRUPR
002E02  1  00                   .BYTE   0               ;convert if true i=TRUE (lowertoupper)
002E03  1               NINTFL
002E03  1  00                   .BYTE   0               ;no .INT file if true (nointfile)
002E04  1               LSTFLG
002E04  1  00                   .BYTE   0               ;list device if false (lstflag)
002E05  1               EOLSTS
002E05  1  00                   .BYTE   0               ;flag that eol (cr) read by scan
002E06  1               CMPLNG
002E06  1  00                   .BYTE   0               ;compiling if true (compiling)
002E07  1               FORSTM
002E07  1  00                   .BYTE   0               ;for statement flag (forstmt)
002E08  1               FILEIO
002E08  1  00                   .BYTE   0               ;file i/o flag
002E09  1               ;next variable is never read or tested - need to check need
002E09  1               RNDFLE
002E09  1  00                   .BYTE   0               ;random file flag (randomfile)
002E0A  1               ;fcbs and similar
002E0A  1               WFCB
002E0A  1  xx xx xx xx          .RES    9
002E0E  1  xx xx xx xx  
002E12  1  xx           
002E13  1  49 4E 54             .BYTE   "INT"
002E16  1  xx xx xx xx          .RES    21
002E1A  1  xx xx xx xx  
002E1E  1  xx xx xx xx  
002E2B  1               PRMLST
002E2B  1  20 20 20 20          .BYTE   "         "
002E2F  1  20 20 20 20  
002E33  1  20           
002E34  1               ;parser data tables
002E34  1               IFLBLN
002E34  1  02                   .BYTE   2
002E35  1               IFLAB2
002E35  1  17                   .BYTE   23
002E36  1               IFLABL
002E36  1  00                   .BYTE   0
002E37  1               HSHTBL
002E37  1  xx xx xx xx          .RES    HSHTSZ*2
002E3B  1  xx xx xx xx  
002E3F  1  xx xx xx xx  
002EB7  1               HASH
002EB7  1  xx xx xx xx          .RES    PSTKSZ
002EBB  1  xx xx xx xx  
002EBF  1  xx xx xx xx  
002ED7  1               VAR
002ED7  1  xx xx xx xx          .RES    PSTKSZ
002EDB  1  xx xx xx xx  
002EDF  1  xx xx xx xx  
002EF7  1               TYPE
002EF7  1  xx xx xx xx          .RES    PSTKSZ
002EFB  1  xx xx xx xx  
002EFF  1  xx xx xx xx  
002F17  1               STYPE
002F17  1  xx xx xx xx          .RES    PSTKSZ
002F1B  1  xx xx xx xx  
002F1F  1  xx xx xx xx  
002F37  1               SRLOC
002F37  1  xx xx xx xx          .RES    PSTKSZ*2
002F3B  1  xx xx xx xx  
002F3F  1  xx xx xx xx  
002F77  1               SYMLOC
002F77  1  xx xx xx xx          .RES    PSTKSZ*2
002F7B  1  xx xx xx xx  
002F7F  1  xx xx xx xx  
002FB7  1               STSTAK
002FB7  1  xx xx xx xx          .RES    PSTKSZ*2
002FBB  1  xx xx xx xx  
002FBF  1  xx xx xx xx  
002FF7  1               VARC
002FF7  1  xx xx xx xx          .RES    VARCSZ
002FFB  1  xx xx xx xx  
002FFF  1  xx xx xx xx  
00305B  1               ONSTAK
00305B  1  xx xx xx xx          .RES    MAXOCT
00305F  1  xx xx xx xx  
003063  1  xx xx xx xx  
00306A  1               ONSP            = ONSTAK
00306A  1               ;buffers
00306A  1               INPBUF
00306A  1  xx xx xx xx          .RES    SRCRSZ
00306E  1  xx xx xx xx  
003072  1  xx xx xx xx  
0030EA  1               OUTBUF
0030EA  1  xx xx xx xx          .RES    INTRSZ
0030EE  1  xx xx xx xx  
0030F2  1  xx xx xx xx  
00316A  1               CONBUF
00316A  1  xx xx xx xx          .RES    CBUFSZ+2
00316E  1  xx xx xx xx  
003172  1  xx xx xx xx  
0031BE  1               ;start of free memory
0031BE  1               MEMORY
0031BE  1                       .END
