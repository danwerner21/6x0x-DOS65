ca65 V2.18 - Ubuntu 2.19-1
Main file   : debug202.asm
Current file: debug202.asm

000000r 1               ;DEBUG - DOS/65 DEBUGGER
000000r 1               ;VERSION 2.02-A
000000r 1               ;RELEASED:	30 SEPTEMBER 1982
000000r 1               ;LAST REVISION:
000000r 1               ;	29 MARCH 2008
000000r 1               ;		REFORMATTED FOR ASM210 & TASM
000000r 1               ;		DELETED REDUNDANT COPYRIGHT NOTICE
000000r 1               ;		ELIMINATED PAGE ZERO 0 & 1
000000r 1               ;	30 MARCH 2008
000000r 1               ;		SET MINIMUM LOAD ADDRESS TO TEA
000000r 1               ;		ALIGNED START OF RUN TIME ON PAGE BOUNDARY
000000r 1               ;		CORRECTED ERROR NEAR JMP (EXECUT)
000000r 1               ;BASE ADDRESSES
000000r 1               BTEJMP          = $100          ;SIM+3 ENTRY
000000r 1               PEMJMP          = $103          ;PEM ENTRY
000000r 1               DFLFCB          = $107          ;DEFAULT FCB
000000r 1               DFLBUF          = $128          ;DEFAULT BUFFER
000000r 1               MINMEM          = $800          ;MINIMUM LOAD ADDRESS
000000r 1               TEA             = $800          ;TEA START
000000r 1               
000000r 1               ;ZERO PAGE FOR SETUP
000000r 1               POINT           = $02           ;RELOCATE POINTER
000000r 1               ADJUST          = $04           ;RELOCATE DISTANCE
000000r 1               LOWER           = $06           ;LOWER LIMIT
000000r 1               PAGLIM          = $08           ;UPPER PAGE LIMIT
000000r 1               LENGTH          = $09           ;PROGRAM LENGTH
000000r 1               NEWSTR          = $0B           ;START AFTER MOVE
000000r 1               EXECUT          = $0D           ;EXECUTE VECTOR
000000r 1               FROM            = $0F           ;START FOR MOVE
000000r 1               MOVCNT          = $11           ;COUNTER FOR MOVE
000000r 1               ;FIXED PARAMETERS
000000r 1               LF              = $A            ;LINEFEEED
000000r 1               CR              = $D            ;RETURN
000000r 1               EOF             = $1A           ;END OF FILE
000000r 1               SEMICO          = 59            ;SEMICOLON
000000r 1               ;SET-UP POINTERS
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1               
000800  1  4C 28 08             JMP     START           ;GO START
000803  1  43 4F 50 59          .BYTE   "COPYRIGHT (C) 2008 -"
000807  1  52 49 47 48  
00080B  1  54 20 28 43  
000817  1  20 52 49 43          .BYTE   " RICHARD A. LEARY"
00081B  1  48 41 52 44  
00081F  1  20 41 2E 20  
000828  1               ;FIRST USE PEM JMP IN PAGE 1 TO GET VECTOR TO PEM SO PEM
000828  1               ;LINK CAN BE MAINTAINED.
000828  1               START
000828  1  AD 04 01             LDA     PEMJMP+1        ;SET VECTOR
00082B  1  AC 05 01             LDY     PEMJMP+2        ;TO PEM
00082E  1  8D B0 14             STA     VECTOR          ;FROM PAGE
000831  1  8C B1 14             STY     VECTOR+1        ;ONE JUMP
000834  1  8D E9 08             STA     GOTOPM+1        ;SET MESSAGE PEM CALL ADDRESS
000837  1  8C EA 08             STY     GOTOPM+2
00083A  1  A2 10                LDX     #17-1           ;INITIALIZE 17 BYTES
00083C  1               SETZPG
00083C  1  BD 5F 09             LDA     INITTB,X        ;PAGE
00083F  1  95 02                STA     2,X             ;ZERO
000841  1  CA                   DEX                     ;VARIABLES
000842  1  10 F8                BPL     SETZPG          ;AND POINTERS
000844  1               ;ZERO PAGE HAS BEEN INITIALIZED
000844  1               ;NOW CALCULATE DESTINATION START ADDRESS FOR RELOCATION AND MOVE
000844  1  38                   SEC                     ;SUBTRACT LOW OF LENGTH
000845  1  AD B0 14             LDA     VECTOR          ;FROM LOW
000848  1  E5 09                SBC     LENGTH          ;PEM LOCATION
00084A  1  85 0B                STA     NEWSTR          ;AND SAVE
00084C  1  8D 04 01             STA     PEMJMP+1        ;ALSO IN VECTOR AROUND DEBUG
00084F  1  85 0D                STA     EXECUT          ;ALSO IN FINAL LINK
000851  1  AD B1 14             LDA     VECTOR+1        ;GET HIGH
000854  1  E5 0A                SBC     LENGTH+1        ;AND SUBTRACT HIGH
000856  1  85 0C                STA     NEWSTR+1        ;AND SAVE
000858  1  8D 05 01             STA     PEMJMP+2
00085B  1  85 0E                STA     EXECUT+1
00085D  1               ;NOW CALCULATE DISTANCE TO MOVE SINCE POINT STARTS OUT SET TO
00085D  1               ;PEMVEC LOCATION
00085D  1  38                   SEC                     ;CALCULATE
00085E  1  A5 0B                LDA     NEWSTR          ;DISTANCE
000860  1  E5 02                SBC     POINT           ;TO
000862  1  85 04                STA     ADJUST          ;RELOCATE
000864  1  A5 0C                LDA     NEWSTR+1        ;FROM NEW
000866  1  E5 03                SBC     POINT+1         ;AND OLD
000868  1  85 05                STA     ADJUST+1        ;START
00086A  1               ;BEGIN RELOCATION
00086A  1               STRTRL
00086A  1  A0 00                LDY     #0              ;GET OPCODE
00086C  1  B1 02                LDA     (POINT),Y       ;FROM MEMORY
00086E  1  A8                   TAY                     ;SAVE IN Y
00086F  1  A2 07                LDX     #7              ;SEARCH SEVEN
000871  1               RLLOOP
000871  1  98                   TYA                     ;GET OPCODE
000872  1  3D 48 09             AND     TABLE1-1,X      ;REMOVE BITS
000875  1  5D 4F 09             EOR     TABLE2-1,X      ;TEST REST
000878  1  F0 03                BEQ     GOTOPC          ;IF ZERO A MATCH
00087A  1  CA                   DEX                     ;ELSE TRY
00087B  1  D0 F4                BNE     RLLOOP          ;NEXT
00087D  1               GOTOPC
00087D  1  BC 57 09             LDY     TABLE3,X        ;GET LENGTH/FLAG
000880  1  10 27                BPL     SKIPBY          ;NO CHANGE IF POSITIVE
000882  1  C8                   INY                     ;ADD ONE
000883  1  30 2F                BMI     STSMPG          ;EXIT IF TERMINATOR
000885  1  C8                   INY                     ;ELSE ADD ONE MORE
000886  1  B1 02                LDA     (POINT),Y       ;GET LOW
000888  1  AA                   TAX                     ;SAVE IN X
000889  1  C8                   INY                     ;THEN GET
00088A  1  B1 02                LDA     (POINT),Y       ;HIGH
00088C  1  C5 08                CMP     PAGLIM          ;IF AT HIGH LIMIT
00088E  1  B0 11                BCS     NORELC          ;DO NOTHING
000890  1  C5 07                CMP     LOWER+1         ;IF ABOVE
000892  1  D0 02                BNE     TRYLOW          ;LOWER LIMIT
000894  1  E4 06                CPX     LOWER           ;THEN
000896  1               TRYLOW
000896  1  90 09                BCC     NORELC          ;DO NOTHING
000898  1  48                   PHA                     ;ELSE SAVE HIGH
000899  1  8A                   TXA                     ;ADD OFFSET
00089A  1  18                   CLC                     ;TO LOW
00089B  1  65 04                ADC     ADJUST          ;AND THEN
00089D  1  AA                   TAX                     ;SAVE
00089E  1  68                   PLA                     ;GET HIGH
00089F  1  65 05                ADC     ADJUST+1        ;ADD AGAIN
0008A1  1               NORELC
0008A1  1  91 02                STA     (POINT),Y       ;PUT BACK
0008A3  1  88                   DEY                     ;BACKUP
0008A4  1  8A                   TXA                     ;GET LOW
0008A5  1  91 02                STA     (POINT),Y       ;SAVE
0008A7  1  A0 03                LDY     #3              ;GO UP THREE
0008A9  1               SKIPBY
0008A9  1  E6 02                INC     POINT           ;ADD ONE
0008AB  1  D0 02                BNE     NOINCY          ;WITH
0008AD  1  E6 03                INC     POINT+1         ;CARRY
0008AF  1               NOINCY
0008AF  1  88                   DEY                     ;LOOP IF
0008B0  1  D0 F7                BNE     SKIPBY          ;MORE
0008B2  1  F0 B6                BEQ     STRTRL          ;THEN START OVER
0008B4  1               ;SET SIM PAGE ADDRESS
0008B4  1               STSMPG
0008B4  1  AD 02 01             LDA     BTEJMP+2        ;GET SIM PAGE
0008B7  1  8D 3D 13             STA     GTCHLN+2        ;SET SIZE PARAM ADDRESSES
0008BA  1  8D 41 13             STA     GTLNSC+2
0008BD  1               ;DISABLE INTERRUPTS BEFORE TESTING
0008BD  1  08                   PHP                     ;SAVE CURRENT STATUS
0008BE  1  78                   SEI                     ;THEN DISABLE
0008BF  1               ;SEE IF INTERRUPTS ALLOWED AND SET POINTERS
0008BF  1  A9 FE                LDA     #$FE            ;SET POINTER TO VECTOR
0008C1  1  A0 FF                LDY     #$FF
0008C3  1  85 02                STA     POINT
0008C5  1  84 03                STY     POINT+1
0008C7  1               ;LOOP BACK POINT FOR ROM TEST
0008C7  1               TSPTRM
0008C7  1  20 AC 09             JSR     TSTROM          ;SEE IF ROM
0008CA  1  F0 22                BEQ     WASROM          ;JUMP IF WAS
0008CC  1               GOTRAM
0008CC  1  B1 02                LDA     (POINT),Y       ;ELSE GET LOW
0008CE  1  8D AE 14             STA     IRQVEC          ;AND SAVE
0008D1  1  C8                   INY                     ;NOW GO FOR HIGH
0008D2  1  B1 02                LDA     (POINT),Y
0008D4  1  8D AF 14             STA     IRQVEC+1        ;AND SAVE
0008D7  1  AD 86 13             LDA     IBKVEC+1        ;GET HIGH OF VECTOR
0008DA  1  91 02                STA     (POINT),Y       ;AND PUT AT POINT
0008DC  1  88                   DEY                     ;DO LOW
0008DD  1  AD 85 13             LDA     IBKVEC
0008E0  1  91 02                STA     (POINT),Y       ;IN SAME WAY
0008E2  1               ;SEND MESSAGE SAYING IRQ/BRK VECTOR HAS BEEN SET
0008E2  1  A9 70                LDA     #<SETMSG        ;POINT TO MESSAGE
0008E4  1  A0 09                LDY     #>SETMSG
0008E6  1               SETEXT
0008E6  1  A2 09                LDX     #9              ;SEND MESSAGE
0008E8  1               GOTOPM
0008E8  1  20 FF FF             JSR     $FFFF           ;TO CONSOLE
0008EB  1  4C 1A 09             JMP     EXRELC          ;AND CONTINUE
0008EE  1               ;AT THIS POINT IT HAS BEEN DETERMINED THAT IRQ/BRK VECTOR IS IN ROM
0008EE  1               ;BUT NOW TEST TO SEE IF IT POINTS TO A JMP, EITHER ABSOLUTE OR INDIRECT.
0008EE  1               ;IF THAT IS THE CASE SEE IF THE JMP OPERAND CAN BE MODIFIED.
0008EE  1               WASROM
0008EE  1  20 9E 09             JSR     LDEPNT          ;DO POINT LOAD
0008F1  1  B1 02                LDA     (POINT),Y       ;GET BYTE
0008F3  1  C9 4C                CMP     #$4C            ;SEE IF JMP OPCODE
0008F5  1  F0 19                BEQ     ISJMAB          ;JUMP IF IS
0008F7  1  C9 6C                CMP     #$6C            ;SEE IF JMP INDIRECT
0008F9  1  D0 09                BNE     CNNTST          ;IF NOT CAN NOT SET
0008FB  1  20 CC 09             JSR     BMPPNT          ;BUMP POINTER
0008FE  1  20 9E 09             JSR     LDEPNT          ;THEN (POINT) --> POINT
000901  1  4C C7 08             JMP     TSPTRM          ;AND LOOP BACK TO START
000904  1               ;THIS IS TARGET WHEN IT HAS BEEN DETERMINED THAT IRQ/BRK CA NOT BE SET
000904  1               CNNTST
000904  1  A0 FF                LDY     #255            ;SET Y TO $FF
000906  1  8C F9 14             STY     BRKOK           ;TO DISABLE BRK
000909  1               ;SEND MESSAGE SAYING IRQ/BRK CAN NOT BE SET
000909  1  A9 83                LDA     #<NTSMSG        ;POINT TO MESSAGE
00090B  1  A0 09                LDY     #>NTSMSG
00090D  1  4C E6 08             JMP     SETEXT          ;THEN CONTINUE
000910  1               ;IT HAS BEEN DETERMINED THAT IRQ/BRK POINTS TO A JMP - SEE IF IT
000910  1               ;CAN BE CHANGED
000910  1               ISJMAB
000910  1  20 CC 09             JSR     BMPPNT          ;BUMP POINTER PAST JMP
000913  1  20 AC 09             JSR     TSTROM          ;SEE IF ROM
000916  1  F0 D6                BEQ     WASROM          ;JUMP IF WAS
000918  1  D0 B2                BNE     GOTRAM          ;ELSE GO RAM
00091A  1               ;DO ACTUAL MOVE OF DEBUG EXECUTE MODULE TO CORRECT LOCATION
00091A  1               EXRELC
00091A  1  A0 00                LDY     #0              ;CLEAR INDEX
00091C  1  B1 0F                LDA     (FROM),Y        ;GET BYTE
00091E  1  91 0B                STA     (NEWSTR),Y      ;MOVE
000920  1  E6 0F                INC     FROM            ;THEN
000922  1  D0 02                BNE     FROMOK          ;BUMP
000924  1  E6 10                INC     FROM+1          ;POINTERS
000926  1               FROMOK
000926  1  E6 0B                INC     NEWSTR          ;BOTH
000928  1  D0 02                BNE     NEWOK           ;FROM AND
00092A  1  E6 0C                INC     NEWSTR+1        ;TO
00092C  1               NEWOK
00092C  1  38                   SEC                     ;NOW
00092D  1  A5 11                LDA     MOVCNT          ;DECREMENT
00092F  1  E9 01                SBC     #1              ;COUNT
000931  1  85 11                STA     MOVCNT          ;BY ONE
000933  1  B0 02                BCS     SKPDEC          ;JUMP IF NO BORROW
000935  1  C6 12                DEC     MOVCNT+1        ;DECREMENT HIGH
000937  1               SKPDEC
000937  1  05 12                ORA     MOVCNT+1        ;IF NOT ZERO
000939  1  D0 DF                BNE     EXRELC          ;MOVE MORE
00093B  1               ;PREPARE TO JUMP TO NEW START + 3 TO BYPASS JMP TO TRUE PEM
00093B  1  18                   CLC                     ;ELSE
00093C  1  A5 0D                LDA     EXECUT          ;GET START
00093E  1  69 03                ADC     #3              ;ADD THREE
000940  1  85 0D                STA     EXECUT          ;SAVE
000942  1  90 02                BCC     NOXQCY          ;JUMP IF NO CARRY
000944  1  E6 0E                INC     EXECUT+1        ;ELSE BUMP HIGH
000946  1               NOXQCY
000946  1  6C 0D 00             JMP     (EXECUT)        ;THEN EXECUTE
000949  1               ;RELOCATION TABLES
000949  1               TABLE1
000949  1  0C 1F 0D 87          .BYTE   $C,$1F,$D,$87,$1F,$FF,$3
00094D  1  1F FF 03     
000950  1               TABLE2
000950  1  0C 19 08 00          .BYTE   $C,$19,$8,$0,$10,$20,$3
000954  1  10 20 03     
000957  1               TABLE3
000957  1  02 FF FF 01          .BYTE   2,$FF,$FF,1,1,2,$FF,$FE
00095B  1  01 02 FF FE  
00095F  1               ;INITIALIZATION TABLES
00095F  1               INITTB
00095F  1  00 0A                .WORD   PEMVEC          ;POINT
000961  1  00 00                .WORD   0               ;ADJUST
000963  1  FF 07                .WORD   TEA-1           ;LOWER
000965  1  FF                   .BYTE   $FF             ;PAGLIM
000966  1  00 0C                .WORD   LAST-PEMVEC+1   ;LENGTH
000968  1  00 00                .WORD   0               ;NEWSTR
00096A  1  00 00                .WORD   0               ;EXECUT
00096C  1  00 0A                .WORD   PEMVEC          ;FROM
00096E  1  00 0C                .WORD   LAST-PEMVEC+1   ;MOVCNT
000970  1               ;MESSAGES
000970  1               SETMSG
000970  1  49 52 51 2F          .BYTE   "IRQ/BRK VECTOR SET$"
000974  1  42 52 4B 20  
000978  1  56 45 43 54  
000983  1               NTSMSG
000983  1  43 41 4E 20          .BYTE   "CAN NOT SET IRQ/BRK VECTOR$"
000987  1  4E 4F 54 20  
00098B  1  53 45 54 20  
00099E  1               ;LOAD POINT FROM (POINT)
00099E  1               ;EXITS WITH Y=0
00099E  1               LDEPNT
00099E  1  A0 00                LDY     #0              ;CLEAR INDEX
0009A0  1  B1 02                LDA     (POINT),Y       ;GET LOW
0009A2  1  AA                   TAX                     ;SAVE IN X
0009A3  1  C8                   INY                     ;Y TO ONE
0009A4  1  B1 02                LDA     (POINT),Y       ;GET HIGH
0009A6  1  85 03                STA     POINT+1
0009A8  1  86 02                STX     POINT
0009AA  1  88                   DEY                     ;SET Y TO ZERO
0009AB  1  60                   RTS
0009AC  1               ;SUBROUTINE TO CHECK (POINT) FOR ROM
0009AC  1               ;RETURNS Z=1 IF ROM OR Z=0 IF RAM
0009AC  1               ;RETURNS WITH Y=0
0009AC  1               TSTROM
0009AC  1  A0 00                LDY     #0              ;CLEAR INDEX
0009AE  1  B1 02                LDA     (POINT),Y       ;GET VALUE
0009B0  1  48                   PHA                     ;SAVE ON STACK
0009B1  1  98                   TYA                     ;CLEAR A
0009B2  1  91 02                STA     (POINT),Y       ;STORE A ZERO
0009B4  1  B1 02                LDA     (POINT),Y       ;GET IT BACK
0009B6  1  D0 0E                BNE     PTISRM          ;IS ROM IF NOT ZERO
0009B8  1  A9 FF                LDA     #$FF            ;SET A TO FF
0009BA  1  91 02                STA     (POINT),Y       ;AND SET
0009BC  1  D1 02                CMP     (POINT),Y       ;THEN COMPARE
0009BE  1  D0 06                BNE     PTISRM          ;ROM IF DIFFERENT
0009C0  1  68                   PLA                     ;IS RAM SO RESTORE
0009C1  1  91 02                STA     (POINT),Y
0009C3  1  A9 FF                LDA     #$FF            ;SET Z=0 FOR RAM
0009C5  1  60                   RTS
0009C6  1               PTISRM
0009C6  1  68                   PLA                     ;CLEAR STACK
0009C7  1  91 02                STA     (POINT),Y       ;DO A RESTORE TO BE SAFE
0009C9  1  A9 00                LDA     #0              ;SET Z=1 FOR ROM
0009CB  1  60                   RTS
0009CC  1               ;BUMP PAGE ZERO POINT
0009CC  1               BMPPNT
0009CC  1  E6 02                INC     POINT           ;DO LOW
0009CE  1  D0 02                BNE     *+4
0009D0  1  E6 03                INC     POINT+1
0009D2  1  60                   RTS
0009D3  1               ;----------------------------------------
0009D3  1               ;DEBUG
0009D3  1               ;FROM HERE ON IS THE CODE AND DATA THAT GETS MOVED BELOW PEM AND ACTS
0009D3  1               ;AS THE COMMAND SHELL TO LOAD FILES, MANIPULATE MEMORY, ETC
0009D3  1               ;----------------------------------------
0009D3  1               ;FIRST ALIGN START ON A PAGE BOUNDARY
0009D3  1  xx xx xx xx          .ALIGN  256
0009D7  1  xx xx xx xx  
0009DB  1  xx xx xx xx  
000A00  1               ;VECTOR TO PEM
000A00  1               PEMVEC
000A00  1  6C B0 14             JMP     (VECTOR)        ;VECTOR FROM PAGE ONE
000A03  1               ;MAIN PROGRAM
000A03  1               DEBUG
000A03  1  28                   PLP                     ;RESTORE INTERRUPT STATUS
000A04  1  20 13 12             JSR     SETBUF          ;POINT TO DEFAULT BUFFER
000A07  1  A9 20                LDA     #' '            ;IF NAME
000A09  1  CD 08 01             CMP     DFLFCB+1        ;NOT BLANK
000A0C  1  D0 05                BNE     TRYAFN          ;CHECK FOR AFN
000A0E  1  CD 10 01             CMP     DFLFCB+9        ;IF TYPE BLANK
000A11  1  F0 14                BEQ     GETCOM          ;DO NOTHING
000A13  1               TRYAFN
000A13  1  A2 0B                LDX     #11             ;CHECK
000A15  1  A9 3F                LDA     #'?'            ;ALL OF NAME
000A17  1               TSTAFN
000A17  1  DD 07 01             CMP     DFLFCB,X        ;FOR AMBIGUOUS
000A1A  1  F0 05                BEQ     BDFILE          ;FILE NAME
000A1C  1  CA                   DEX                     ;COUNT DOWN
000A1D  1  D0 F8                BNE     TSTAFN          ;AND LOOP UNTIL DONE
000A1F  1  F0 03                BEQ     RDEINP          ;THEN EXECUTE
000A21  1               BDFILE
000A21  1  4C D7 11             JMP     ERROR           ;ERROR IN FILE
000A24  1               RDEINP
000A24  1  20 46 0D             JSR     XQREAD          ;READ FILE
000A27  1               GETCOM
000A27  1  AE EB 14             LDX     USRS            ;RESET
000A2A  1  9A                   TXS                     ;STACK
000A2B  1  20 F6 11             JSR     CRLF            ;DO A CR AND LF
000A2E  1  A9 2D                LDA     #'-'            ;PROMPT WITH
000A30  1  20 01 12             JSR     CHROUT          ;A DASH
000A33  1  20 32 12             JSR     RDEBUF          ;GET COMMAND LINE
000A36  1  A0 00                LDY     #0              ;SET INDEX TO ZERO
000A38  1  AE B3 14             LDX     CNSLNG          ;GET LENGTH
000A3B  1  F0 EA                BEQ     GETCOM          ;IF ZERO TRY AGAIN
000A3D  1               LWRUPR
000A3D  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHARACTER
000A40  1  C9 41                CMP     #'A'            ;IF LESS THAN
000A42  1  90 09                BCC     NXTCHG          ;A OK
000A44  1  C9 7B                CMP     #'{'            ;OR IF OVER
000A46  1  B0 05                BCS     NXTCHG          ;A { OK
000A48  1  29 5F                AND     #%01011111      ;ELSE CONVERT
000A4A  1  99 B4 14             STA     CNSTXT,Y        ;AND PUT BACK
000A4D  1               NXTCHG
000A4D  1  C8                   INY                     ;BUMP INDEX
000A4E  1  CA                   DEX                     ;DECREMENT COUNT
000A4F  1  D0 EC                BNE     LWRUPR          ;LOOP IF MORE
000A51  1  8A                   TXA                     ;SET A TO ZERO
000A52  1  99 B4 14             STA     CNSTXT,Y        ;INSERT STOPPER
000A55  1  A8                   TAY                     ;SET INDEX TO ZERO
000A56  1  20 83 10             JSR     SKPSPC          ;GET FIRST NON-BLANK
000A59  1  8D DA 14             STA     COMMND          ;SAVE COMMAND
000A5C  1  F0 C9                BEQ     GETCOM          ;TRY AGAIN IF NONE
000A5E  1  C9 49                CMP     #'I'            ;IF NOT I
000A60  1  D0 06                BNE     NOTINP          ;THEN CONTINUE
000A62  1  20 D9 0C             JSR     XQINPT          ;ELSE INPUT FILE NAME
000A65  1  4C 27 0A             JMP     GETCOM          ;AND LOOP
000A68  1               NOTINP
000A68  1  C9 58                CMP     #'X'
000A6A  1  F0 03                BEQ     *+5             ;CONTINUE IF X
000A6C  1  4C 3A 0B             JMP     NOTSTE
000A6F  1               ;X=MACHINE STATE
000A6F  1  C8                   INY                     ;GET COMMAND
000A70  1  20 83 10             JSR     SKPSPC          ;OBJECT REGISTER
000A73  1  F0 7D                BEQ     NOSTCH          ;OK IF NONE
000A75  1  8D FA 14             STA     XRGCMD          ;ELSE SAVE
000A78  1  C8                   INY                     ;THEN GET
000A79  1  20 83 10             JSR     SKPSPC          ;EQUALS SIGN
000A7C  1  D0 03                BNE     *+5             ;OK IF NOT NULL
000A7E  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000A81  1  C9 3D                CMP     #'='            ;IF EQUALS
000A83  1  F0 03                BEQ     *+5             ;THEN OK
000A85  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000A88  1  20 39 10             JSR     GETPRM          ;GET PARAMETER
000A8B  1  AD F5 14             LDA     NUMPRM          ;GET NUMBER PARMS
000A8E  1  C9 01                CMP     #1              ;IF ONE
000A90  1  F0 03                BEQ     *+5             ;IS OK
000A92  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000A95  1  AD FA 14             LDA     XRGCMD          ;GET COMMAND
000A98  1  C9 2A                CMP     #'*'            ;IF NOT PC
000A9A  1  D0 06                BNE     *+8             ;TRY BYTE/BIT
000A9C  1  20 E2 11             JSR     PRMUPC          ;ELSE SET PC
000A9F  1  4C F2 0A             JMP     NOSTCH          ;AND DISPLAY
000AA2  1               ;BYTE CHANGES
000AA2  1  AD D9 14             LDA     PARM3+1         ;IF HIGH ZERO
000AA5  1  F0 03                BEQ     *+5             ;IS OK
000AA7  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000AAA  1  A2 00                LDX     #0              ;CLEAR INDEX
000AAC  1  A0 00                LDY     #0              ;FOR SEARCH
000AAE  1  AD FA 14             LDA     XRGCMD          ;GET COMMAND
000AB1  1               TSTREG
000AB1  1  D9 88 13             CMP     REGTBL,Y        ;IF SAME AS TABLE
000AB4  1  F0 0E                BEQ     GOTREG          ;IS OK
000AB6  1  C0 08                CPY     #8              ;IF PAST S
000AB8  1  B0 01                BCS     *+3             ;DO NOT BUMP
000ABA  1  E8                   INX                     ;BYTE INDEX
000ABB  1  C8                   INY                     ;ELSE BUMP
000ABC  1  C8                   INY                     ;INDEX BY TWO
000ABD  1  C0 16                CPY     #22             ;IF NOT TOO BIG
000ABF  1  D0 F0                BNE     TSTREG          ;TRY AGAIN
000AC1  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000AC4  1               ;FOUND REGISTER OR BIT
000AC4  1               GOTREG
000AC4  1  E0 04                CPX     #4              ;IF A BIT CHANGE
000AC6  1  F0 09                BEQ     ISABIT          ;GO DO IT
000AC8  1  AD D8 14             LDA     PARM3           ;ELSE GET BYTE
000ACB  1  9D E8 14             STA     USRA,X          ;SET REGISTER
000ACE  1  4C F2 0A             JMP     NOSTCH          ;AND DISPLAY
000AD1  1               ;IS A FLAG BIT
000AD1  1               ISABIT
000AD1  1  C8                   INY                     ;POINT TO MASK
000AD2  1  AD D8 14             LDA     PARM3           ;IF PARM ZERO
000AD5  1  F0 0D                BEQ     ZROBIT          ;THEN CLEAR
000AD7  1  C9 01                CMP     #1              ;IF ONE OK
000AD9  1  F0 03                BEQ     *+5             ;TO USE
000ADB  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000ADE  1  B9 88 13             LDA     REGTBL,Y        ;GET MASK
000AE1  1  8D D8 14             STA     PARM3           ;SET
000AE4  1               ZROBIT
000AE4  1  B9 88 13             LDA     REGTBL,Y        ;GET MASK
000AE7  1  49 FF                EOR     #$FF            ;COMPLEMENT
000AE9  1  2D EC 14             AND     USRP            ;GET FLAGS
000AEC  1  0D D8 14             ORA     PARM3           ;OR WITH NEW
000AEF  1  8D EC 14             STA     USRP            ;AND SAVE
000AF2  1               NOSTCH
000AF2  1  A2 00                LDX     #0              ;CLEAR INDEX
000AF4  1               STMSLP
000AF4  1  BD 8F 14             LDA     STEMSG,X        ;GET MESSAGE
000AF7  1  F0 06                BEQ     EXTSMS          ;DONE IF NULL
000AF9  1  20 01 12             JSR     CHROUT          ;ELSE SEND
000AFC  1  E8                   INX                     ;NEXT CHAR
000AFD  1  D0 F5                BNE     STMSLP          ;LOOP
000AFF  1               EXTSMS
000AFF  1  AD E7 14             LDA     USRPC+1         ;GET HIGH PC
000B02  1  20 60 11             JSR     OUTBYT          ;SEND BYTE
000B05  1  AD E6 14             LDA     USRPC           ;GET LOW PC
000B08  1  20 5B 12             JSR     BYTSPC          ;SEND BYTE AND SPACE
000B0B  1  AD E8 14             LDA     USRA            ;GET A
000B0E  1  20 5B 12             JSR     BYTSPC          ;SEND IT
000B11  1  AD E9 14             LDA     USRX            ;GET X
000B14  1  20 5B 12             JSR     BYTSPC          ;SEND IT
000B17  1  AD EA 14             LDA     USRY            ;GET Y
000B1A  1  20 5B 12             JSR     BYTSPC          ;SEND IT
000B1D  1  AD EB 14             LDA     USRS            ;GET S
000B20  1  20 5B 12             JSR     BYTSPC          ;SEND IT
000B23  1  A2 08                LDX     #8              ;EIGHT BITS
000B25  1  AD EC 14             LDA     USRP            ;GET FLAGS
000B28  1               STSLPE
000B28  1  0A                   ASL     A               ;SHIFT LEFT
000B29  1  48                   PHA                     ;SAVE WHAT IS LEFT
000B2A  1  A9 00                LDA     #0              ;GET A ZERO
000B2C  1  90 02                BCC     *+4             ;SKIP IF MSB IS ZERO
000B2E  1  A9 01                LDA     #1              ;GET A ONE
000B30  1  20 52 11             JSR     OUTNIB          ;TO CONSOLE
000B33  1  68                   PLA                     ;GET FLAGS BACK
000B34  1  CA                   DEX                     ;COUNT DOWN
000B35  1  D0 F1                BNE     STSLPE          ;LOOP IF MORE
000B37  1  4C 27 0A             JMP     GETCOM          ;GET NEW COMMAND
000B3A  1               ;DISPATCH COMMAND
000B3A  1               NOTSTE
000B3A  1  20 39 10             JSR     GETPRM          ;GET PARMS
000B3D  1  AE F5 14             LDX     NUMPRM          ;GET NUMBER PARMS
000B40  1  AD DA 14             LDA     COMMND          ;AND COMMAND
000B43  1  C9 52                CMP     #'R'            ;IF NOT READ
000B45  1  D0 0D                BNE     NTREAD          ;TRY NEXT
000B47  1               ;R=READ FILE
000B47  1  E0 02                CPX     #2              ;IF ZERO OR ONE
000B49  1  90 03                BCC     DOREAD          ;DO READ
000B4B  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000B4E  1               DOREAD
000B4E  1  20 46 0D             JSR     XQREAD          ;READ FILE
000B51  1  4C 27 0A             JMP     GETCOM          ;AND LOOP
000B54  1               NTREAD
000B54  1  C9 44                CMP     #'D'            ;IF NOT DISPLAY
000B56  1  D0 35                BNE     NTDISP          ;TRY NEXT
000B58  1               ;D=DISPLAY MEMORY
000B58  1  8A                   TXA                     ;GET NUMBER PARMS
000B59  1  D0 15                BNE     TDOPRM          ;IF NOT ZERO TRY ONE
000B5B  1               CLDEND
000B5B  1  20 68 13             JSR     CLTLBY          ;ADD NUMBER BYTES MINUS ONE
000B5E  1  18                   CLC
000B5F  1  6D DC 14             ADC     POINTR          ;TO POINTER
000B62  1  8D D6 14             STA     PARM2           ;AND SAVE
000B65  1  AD DD 14             LDA     POINTR+1        ;IN PARM
000B68  1  69 00                ADC     #0              ;NUMBER
000B6A  1  8D D7 14             STA     PARM2+1         ;TWO AS END
000B6D  1  4C 87 0B             JMP     DODISP          ;THEN EXECUTE
000B70  1               TDOPRM
000B70  1  C9 01                CMP     #1              ;IF NOT ONE
000B72  1  D0 06                BNE     TDTPRM          ;TRY TWO
000B74  1  20 92 11             JSR     PR3PTR          ;ELSE MOVE PARM3 TO POINTER
000B77  1  4C 5B 0B             JMP     CLDEND          ;AND SET END
000B7A  1               TDTPRM
000B7A  1  C9 02                CMP     #2              ;IF NOT TWO PARMS
000B7C  1  D0 27                BNE     SUBERR          ;THEN ERROR
000B7E  1  20 46 13             JSR     CLBYLN          ;ELSE FIND BYTES PER LINE
000B81  1  20 85 11             JSR     PR2PTR          ;MOVE PARM2 TO POINTER
000B84  1  20 9F 11             JSR     PR3PR2          ;MOVE PARM3 TO PARM2
000B87  1               DODISP
000B87  1  20 69 0E             JSR     XQDISP          ;DO DISPLAY
000B8A  1  4C 27 0A             JMP     GETCOM          ;THEN LOOP
000B8D  1               NTDISP
000B8D  1  C9 53                CMP     #'S'            ;IF NOT SUBSTITUTE
000B8F  1  D0 2F                BNE     NTSUBS          ;TRY NEXT
000B91  1               ;S=SUBSTITUTE MEMORY
000B91  1  8A                   TXA                     ;GET NUMBER PARMS
000B92  1  F0 07                BEQ     DOSUBS          ;IF ZERO DO IT
000B94  1  C9 01                CMP     #1              ;IF NOT ONE
000B96  1  D0 09                BNE     TRTWSU          ;TRY TWO
000B98  1  20 92 11             JSR     PR3PTR          ;ELSE SET POINTER
000B9B  1               DOSUBS
000B9B  1  20 CA 0E             JSR     XQSUBS          ;EXECUTE
000B9E  1  4C 27 0A             JMP     GETCOM          ;AND LOOP
000BA1  1               TRTWSU
000BA1  1  C9 02                CMP     #2              ;IF TWO PARMS
000BA3  1  F0 03                BEQ     DOUBLE          ;DO DOUBLE STORE
000BA5  1               SUBERR
000BA5  1  4C D7 11             JMP     ERROR           ;ELSE IS ERROR
000BA8  1               DOUBLE
000BA8  1  20 85 11             JSR     PR2PTR          ;SET POINTER
000BAB  1  20 67 12             JSR     STRABS          ;STORE ABSOLUTE
000BAE  1  AD D8 14             LDA     PARM3           ;GET LOW
000BB1  1  20 DB 14             JSR     MOVPNT          ;SET
000BB4  1  20 B9 11             JSR     INCPNT          ;GO TO NEXT
000BB7  1  AD D9 14             LDA     PARM3+1         ;GET HIGH
000BBA  1  20 DB 14             JSR     MOVPNT          ;SET
000BBD  1  4C 27 0A             JMP     GETCOM          ;THEN LOOP
000BC0  1               NTSUBS
000BC0  1  C9 46                CMP     #'F'            ;IF NOT FILL
000BC2  1  D0 28                BNE     NTFILL          ;TRY NEXT
000BC4  1               ;F=FILL MEMORY
000BC4  1  E0 03                CPX     #3              ;IF THREE PARMS
000BC6  1  F0 03                BEQ     DOFILL          ;DO IT
000BC8  1               FILLER
000BC8  1  4C D7 11             JMP     ERROR           ;ELSE IS ERROR
000BCB  1               DOFILL
000BCB  1  AD D9 14             LDA     PARM3+1         ;IF HIGH NOT
000BCE  1  D0 F8                BNE     FILLER          ;ZERO THEN ERROR
000BD0  1  20 78 11             JSR     PR1PTR          ;SET POINTER
000BD3  1  20 67 12             JSR     STRABS          ;STORE ABSOLUTE
000BD6  1               FILMRE
000BD6  1  AD D8 14             LDA     PARM3           ;GET BYTE
000BD9  1  20 DB 14             JSR     MOVPNT          ;STORE
000BDC  1  20 B9 11             JSR     INCPNT          ;POINT TO NEXT
000BDF  1  20 EF 11             JSR     TSTPR0          ;TEST FOR ZERO POINTER
000BE2  1  F0 05                BEQ     EXFILL          ;DONE IF IT IS
000BE4  1  20 AC 11             JSR     LSTCHK          ;IF NOT LAST
000BE7  1  B0 ED                BCS     FILMRE          ;DO MORE
000BE9  1               EXFILL
000BE9  1  4C 27 0A             JMP     GETCOM          ;ELSE LOOP
000BEC  1               NTFILL
000BEC  1  C9 4C                CMP     #'L'            ;IF NOT LIST
000BEE  1  D0 33                BNE     NTLIST          ;TRY NEXT
000BF0  1               ;L=LIST (DISASSEMBLE)
000BF0  1  8A                   TXA                     ;GET NUMBER PARMS
000BF1  1  F0 07                BEQ     DOONLS          ;DO ONE IF ZERO
000BF3  1  C9 01                CMP     #1              ;IF NOT ONE
000BF5  1  D0 14                BNE     TRTWLS          ;TRY TWO
000BF7  1  20 92 11             JSR     PR3PTR          ;SET POINTER
000BFA  1               DOONLS
000BFA  1  20 3F 13             JSR     GTLNSC          ;DO NUM LINES MINUS ONE
000BFD  1  8D E3 14             STA     COUNT           ;INSTRUCTIONS
000C00  1               DSONMR
000C00  1  20 2B 0F             JSR     DSMBL           ;DO DISASSEMBLY
000C03  1  CE E3 14             DEC     COUNT           ;COUNT DOWN
000C06  1  D0 F8                BNE     DSONMR          ;LOOP IF MORE
000C08  1  4C 27 0A             JMP     GETCOM          ;ELSE GET NEXT
000C0B  1               TRTWLS
000C0B  1  C9 02                CMP     #2              ;IF TWO THEN
000C0D  1  F0 03                BEQ     DOTWDS          ;DO IT
000C0F  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000C12  1               DOTWDS
000C12  1  20 85 11             JSR     PR2PTR          ;SET POINTER
000C15  1  20 9F 11             JSR     PR3PR2          ;MOVE PARM3 TO PARM2
000C18  1               DSMORE
000C18  1  20 2B 0F             JSR     DSMBL           ;DO ONE INTRUCTION
000C1B  1  20 AC 11             JSR     LSTCHK          ;TEST FOR END
000C1E  1  B0 F8                BCS     DSMORE          ;LOOP IF MORE
000C20  1  4C 27 0A             JMP     GETCOM          ;ELSE GET NEXT COM
000C23  1               NTLIST
000C23  1  C9 47                CMP     #'G'            ;IF G
000C25  1  F0 03                BEQ     *+5             ;DO
000C27  1  4C D6 0C             JMP     NTGO            ;ELSE TRY NEXT
000C2A  1               ;G=GO (EXECUTE)
000C2A  1  8A                   TXA                     ;GET NUMBER PARMS
000C2B  1  D0 03                BNE     *+5             ;IF NOT ZERO TRY MORE
000C2D  1  4C BC 0C             JMP     DOGO            ;ELSE GO
000C30  1  C9 01                CMP     #1              ;IF NOT ONE
000C32  1  D0 06                BNE     TGTPRM          ;SEE IF TWO
000C34  1  20 E2 11             JSR     PRMUPC          ;SET USER PC
000C37  1  4C BC 0C             JMP     DOGO            ;AND GO
000C3A  1               TGTPRM
000C3A  1  C9 02                CMP     #2              ;IF NOT TWO
000C3C  1  D0 32                BNE     TG3PRM          ;SEE IF THREE
000C3E  1  AD D6 14             LDA     PARM2           ;IF PC
000C41  1  0D D7 14             ORA     PARM2+1         ;IS ZERO
000C44  1  F0 0C                BEQ     NOPC2           ;USE OLD
000C46  1  AD D6 14             LDA     PARM2           ;ELSE GET
000C49  1  AC D7 14             LDY     PARM2+1         ;NEW
000C4C  1  8D E6 14             STA     USRPC           ;AND
000C4F  1  8C E7 14             STY     USRPC+1         ;SET
000C52  1               NOPC2
000C52  1  2C F9 14             BIT     BRKOK           ;IF BRK NOT
000C55  1  30 16                BMI     DOGO2           ;ALLOWED GO DO
000C57  1  20 92 11             JSR     PR3PTR          ;ELSE MOVE
000C5A  1  20 61 12             JSR     LDEABS          ;SET LOAD MODE
000C5D  1  20 DB 14             JSR     MOVPNT          ;GET OPCODE
000C60  1  F0 0B                BEQ     DOGO2           ;IF BRK EXECUTE
000C62  1  8D F1 14             STA     OPCDE1          ;ELSE SAVE
000C65  1  20 3D 12             JSR     SETBPT          ;GET BREAK
000C68  1  A2 00                LDX     #0              ;SET
000C6A  1  20 45 12             JSR     PNTBPT          ;POINTER
000C6D  1               DOGO2
000C6D  1  4C BC 0C             JMP     DOGO            ;AND GO
000C70  1               TG3PRM
000C70  1  C9 03                CMP     #3              ;IF THREE
000C72  1  F0 03                BEQ     *+5             ;THE OK
000C74  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000C77  1  AD D4 14             LDA     PARM1           ;IF PC 0
000C7A  1  0D D5 14             ORA     PARM1+1         ;THEN USE
000C7D  1  F0 0C                BEQ     NOPC3           ;OLD
000C7F  1  AD D4 14             LDA     PARM1           ;ELSE GET
000C82  1  AC D5 14             LDY     PARM1+1         ;NEW
000C85  1  8D E6 14             STA     USRPC           ;AND
000C88  1  8C E7 14             STY     USRPC+1         ;SET
000C8B  1               NOPC3
000C8B  1  2C F9 14             BIT     BRKOK           ;IF BRK NOT OK
000C8E  1  30 2C                BMI     DOGO            ;JUST EXECUTE
000C90  1  20 85 11             JSR     PR2PTR          ;ELSE SET POINTER
000C93  1  20 61 12             JSR     LDEABS          ;LOAD MODE
000C96  1  20 DB 14             JSR     MOVPNT          ;GET OPCODE
000C99  1  F0 0B                BEQ     TRYBK2          ;IF ZERO SEE IF SECOND
000C9B  1  8D F1 14             STA     OPCDE1          ;ELSE SAVE
000C9E  1  20 3D 12             JSR     SETBPT          ;GET BREAK
000CA1  1  A2 00                LDX     #0              ;SET
000CA3  1  20 45 12             JSR     PNTBPT          ;POINTER
000CA6  1               TRYBK2
000CA6  1  20 61 12             JSR     LDEABS          ;LOAD MODE
000CA9  1  20 92 11             JSR     PR3PTR          ;SET POINTER
000CAC  1  20 DB 14             JSR     MOVPNT          ;GET OPCODE
000CAF  1  F0 0B                BEQ     DOGO            ;IF BREAK GO
000CB1  1  8D F2 14             STA     OPCDE2          ;ELSE SAVE
000CB4  1  20 3D 12             JSR     SETBPT          ;SET BREAK
000CB7  1  A2 02                LDX     #2              ;THEN SET
000CB9  1  20 45 12             JSR     PNTBPT          ;LOCATION
000CBC  1               DOGO
000CBC  1  AC EA 14             LDY     USRY            ;SET Y
000CBF  1  AE EB 14             LDX     USRS            ;GET STACK
000CC2  1  9A                   TXS                     ;AND SET
000CC3  1  AD E7 14             LDA     USRPC+1         ;GET HIGH PC
000CC6  1  48                   PHA                     ;PUSH
000CC7  1  AD E6 14             LDA     USRPC           ;THEN GET LOW
000CCA  1  48                   PHA                     ;PUSH
000CCB  1  AD EC 14             LDA     USRP            ;GET FLAGS
000CCE  1  48                   PHA                     ;PUSH
000CCF  1  AE E9 14             LDX     USRX            ;GET X
000CD2  1  AD E8 14             LDA     USRA            ;AND A
000CD5  1  40                   RTI                     ;AND GO
000CD6  1               NTGO
000CD6  1  4C 27 0A             JMP     GETCOM          ;LOOP
000CD9  1               ;----------------------------------------
000CD9  1               ;INPUT FILE DESIGNATOR
000CD9  1               ;----------------------------------------
000CD9  1               XQINPT
000CD9  1  A2 0B                LDX     #11             ;FILL
000CDB  1  A9 20                LDA     #' '            ;NAME
000CDD  1               MRESPC
000CDD  1  9D 07 01             STA     DFLFCB,X        ;AND
000CE0  1  CA                   DEX                     ;TYPE
000CE1  1  D0 FA                BNE     MRESPC          ;WITH SPACES
000CE3  1  E8                   INX                     ;SET INDEX TO ONE
000CE4  1  A0 00                LDY     #0              ;SKIP I
000CE6  1  20 83 10             JSR     SKPSPC          ;IN COMMAND
000CE9  1  C8                   INY                     ;GET NEXT
000CEA  1  20 83 10             JSR     SKPSPC          ;NON BLANK CHAR
000CED  1  F0 54                BEQ     INPERR          ;ERROR IF NONE
000CEF  1  29 07                AND     #%00000111      ;CONVERT TO NUMBER
000CF1  1  8D 07 01             STA     DFLFCB          ;SET AUTOMATIC
000CF4  1  C8                   INY                     ;POINT TO NEXT
000CF5  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
000CF8  1  C9 3A                CMP     #':'            ;IF : THEN
000CFA  1  F0 07                BEQ     GETNME          ;THEN CONTINUE
000CFC  1  88                   DEY                     ;ELSE BACKUP
000CFD  1  88                   DEY                     ;TWO PLACES
000CFE  1  A9 00                LDA     #0              ;THEN CLEAR
000D00  1  8D 07 01             STA     DFLFCB          ;AUTOMATIC
000D03  1               GETNME
000D03  1  C8                   INY                     ;GO TO NEXT
000D04  1               GTMRNM
000D04  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
000D07  1  F0 36                BEQ     ENDALL          ;OVER IF NONE
000D09  1  C9 2E                CMP     #'.'            ;IF SEPARATOR
000D0B  1  F0 0E                BEQ     ENDNME          ;THEN HAVE NAME
000D0D  1  20 90 10             JSR     TSTLGL          ;MAKE SURE ITS LEGAL
000D10  1  F0 31                BEQ     INPERR          ;IF NOT ERROR
000D12  1  9D 07 01             STA     DFLFCB,X        ;ELSE PUT IN FCB
000D15  1  C8                   INY                     ;POINT TO
000D16  1  E8                   INX                     ;NEXT POSITIONS
000D17  1  E0 09                CPX     #9              ;IF NOT TO BIG
000D19  1  D0 E9                BNE     GTMRNM          ;GET MORE
000D1B  1               ENDNME
000D1B  1  A2 09                LDX     #9              ;START OF TYPE
000D1D  1  B9 B4 14             LDA     CNSTXT,Y        ;GET INPUT
000D20  1  F0 1D                BEQ     ENDALL          ;IF ZERO DONE
000D22  1  C9 2E                CMP     #'.'            ;IF NOT DELIMITER
000D24  1  D0 1D                BNE     INPERR          ;THEN ERROR
000D26  1  C8                   INY                     ;POINT TO NEXT
000D27  1               NXTTYP
000D27  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
000D2A  1  F0 13                BEQ     ENDALL          ;DONE IF NONE
000D2C  1  20 90 10             JSR     TSTLGL          ;BUT IF ILLEGAL
000D2F  1  F0 12                BEQ     INPERR          ;IS AN ERROR
000D31  1  9D 07 01             STA     DFLFCB,X        ;SAVE CHAR
000D34  1  C8                   INY                     ;POINT TO
000D35  1  E8                   INX                     ;NEXT POSITIONS
000D36  1  E0 0C                CPX     #12             ;IF NOT AT END
000D38  1  D0 ED                BNE     NXTTYP          ;TRY ANOTHER
000D3A  1  20 83 10             JSR     SKPSPC          ;IF MORE CHAR
000D3D  1  D0 04                BNE     INPERR          ;IS WRONG
000D3F  1               ENDALL
000D3F  1  CA                   DEX                     ;AND IF NO
000D40  1  F0 01                BEQ     INPERR          ;INPUT IS ERROR
000D42  1  60                   RTS                     ;ELSE RETURN
000D43  1               INPERR
000D43  1  4C D7 11             JMP     ERROR           ;ERROR EXIT
000D46  1               ;----------------------------------------
000D46  1               ;READ FILE -- COM OR KIM
000D46  1               ;----------------------------------------
000D46  1               XQREAD
000D46  1  A9 00                LDA     #0              ;CLEAR
000D48  1  A2 20                LDX     #32             ;FCB
000D4A  1               ZERFCB
000D4A  1  9D 07 01             STA     DFLFCB,X        ;EXCEPT
000D4D  1  CA                   DEX                     ;FOR NAME
000D4E  1  E0 0B                CPX     #11             ;AND TYPE
000D50  1  D0 F8                BNE     ZERFCB          ;AND DRIVE
000D52  1  20 1B 12             JSR     OPNDFL          ;TRY TO OPEN
000D55  1  C9 FF                CMP     #255            ;IF OK CONTINUE
000D57  1  D0 03                BNE     *+5             ;SINCE GOT IT
000D59  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000D5C  1  A2 02                LDX     #2              ;IF TYPE
000D5E  1               TSTTYP
000D5E  1  BD 7C 14             LDA     COMTYP,X        ;IS NOT COM
000D61  1  DD 10 01             CMP     DFLFCB+9,X      ;THEN
000D64  1  D0 7F                BNE     KIMTYP          ;DO KIM READ
000D66  1  CA                   DEX                     ;ELSE COUNT DOWN
000D67  1  10 F5                BPL     TSTTYP          ;AND LOOP UNTIL DONE
000D69  1               ;COM READ
000D69  1  A9 00                LDA     #<TEA           ;GET TEA
000D6B  1  A0 08                LDY     #>TEA           ;START
000D6D  1  18                   CLC                     ;ADD OFFSET
000D6E  1  6D D8 14             ADC     PARM3           ;LOW
000D71  1  8D DC 14             STA     POINTR          ;AND SET
000D74  1  98                   TYA                     ;POINTER
000D75  1  6D D9 14             ADC     PARM3+1         ;TO NEW
000D78  1  8D DD 14             STA     POINTR+1        ;VALUE
000D7B  1  A8                   TAY                     ;GET HIGH BACK
000D7C  1  AD DC 14             LDA     POINTR          ;AND LOW
000D7F  1  48                   PHA                     ;SAVE LOW
000D80  1  C9 00                CMP     #<MINMEM        ;TEST AGAINST LOW
000D82  1  98                   TYA                     ;GET HIGH
000D83  1  E9 08                SBC     #>MINMEM        ;SUBTRACT LOW LIMIT
000D85  1  68                   PLA                     ;GET LOW BACK
000D86  1  B0 03                BCS     CMRDLP          ;IF OK CONTINUE
000D88  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000D8B  1               CMRDLP
000D8B  1  20 17 12             JSR     SETDMA          ;SET BUFFER ADDRESS
000D8E  1  AD DC 14             LDA     POINTR          ;GET LOW
000D91  1  AC DD 14             LDY     POINTR+1        ;AND HIGH POINTER
000D94  1  18                   CLC                     ;ADD
000D95  1  69 80                ADC     #128            ;128
000D97  1  8D DC 14             STA     POINTR          ;AND SAVE
000D9A  1  90 04                BCC     NOADCY          ;SKIP INC W/O CARRY
000D9C  1  C8                   INY                     ;ELSE BUMP HIGH
000D9D  1  8C DD 14             STY     POINTR+1        ;AND SAVE
000DA0  1               NOADCY
000DA0  1  CD 7F 13             CMP     STRVEC          ;TEST AGAINST DEBUG
000DA3  1  98                   TYA                     ;LOWER
000DA4  1  ED 80 13             SBC     STRVEC+1        ;LIMIT
000DA7  1  90 03                BCC     LASTOK          ;CONTINUE IF OK
000DA9  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000DAC  1               LASTOK
000DAC  1  20 1F 12             JSR     RDEDFL          ;READ SECTOR
000DAF  1  C9 00                CMP     #0              ;IF NOT OK
000DB1  1  D0 09                BNE     ENDCOM          ;THEN DONE
000DB3  1  AD DC 14             LDA     POINTR          ;ELSE GET POINTER
000DB6  1  AC DD 14             LDY     POINTR+1        ;LOW AND HIGH
000DB9  1  4C 8B 0D             JMP     CMRDLP          ;AND LOOP
000DBC  1               ENDCOM
000DBC  1  C9 01                CMP     #1              ;IF ONE
000DBE  1  F0 03                BEQ     COMEOF          ;THEN EOF
000DC0  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000DC3  1               COMEOF
000DC3  1  20 1D 0F             JSR     NXTPCM          ;SEND MESSAGE
000DC6  1  AD DC 14             LDA     POINTR          ;GET
000DC9  1  AC DD 14             LDY     POINTR+1        ;POINTER
000DCC  1  38                   SEC                     ;SUBTRACT
000DCD  1  E9 80                SBC     #128            ;128 FROM
000DCF  1  8D DC 14             STA     POINTR          ;POINTER
000DD2  1  B0 04                BCS     NOADBR          ;AND SAVE
000DD4  1  88                   DEY                     ;HIGH
000DD5  1  8C DD 14             STY     POINTR+1        ;AND LOW
000DD8  1               NOADBR
000DD8  1  48                   PHA                     ;SAVE LOW
000DD9  1  98                   TYA                     ;GET HIGH
000DDA  1  20 60 11             JSR     OUTBYT          ;SEND IT
000DDD  1  68                   PLA                     ;GET LOW
000DDE  1  20 60 11             JSR     OUTBYT          ;SEND IT
000DE1  1  20 13 12             JSR     SETBUF          ;SET DEFAULT
000DE4  1  60                   RTS
000DE5  1               ;KIM READ
000DE5  1               KIMTYP
000DE5  1  A9 80                LDA     #128            ;SET POINTER
000DE7  1  8D E1 14             STA     KIMPNT          ;TO ILLEGAL
000DEA  1  0A                   ASL     A               ;CLEAR A
000DEB  1  8D E2 14             STA     SAVPNT          ;AND SAVE POINTER
000DEE  1  20 67 12             JSR     STRABS          ;STORE ABSOLUTE
000DF1  1               KIMLOP
000DF1  1  20 EB 10             JSR     GETCHR          ;GET CHAR
000DF4  1  C9 24                CMP     #'$'            ;IF $
000DF6  1  F0 62                BEQ     ENDKIM          ;THEN DONE
000DF8  1  C9 1A                CMP     #EOF            ;IF EOF
000DFA  1  F0 5E                BEQ     ENDKIM          ;THEN DONE
000DFC  1  C9 3B                CMP     #SEMICO         ;IF NOT FILE MARK
000DFE  1  D0 F1                BNE     KIMLOP          ;TRY AGAIN
000E00  1  20 10 11             JSR     GETTWO          ;GET COUNT
000E03  1  F0 55                BEQ     ENDKIM          ;DONE IF ZERO
000E05  1  8D E3 14             STA     COUNT           ;SET COUNT
000E08  1  20 10 11             JSR     GETTWO          ;GET HIGH ADDR
000E0B  1  8D DD 14             STA     POINTR+1        ;AND SAVE
000E0E  1  20 10 11             JSR     GETTWO          ;GET LOW ADDR
000E11  1  18                   CLC                     ;ADD
000E12  1  6D D8 14             ADC     PARM3           ;OFFSET
000E15  1  8D DC 14             STA     POINTR          ;AND SAVE
000E18  1  48                   PHA                     ;LOCALLY
000E19  1  AD DD 14             LDA     POINTR+1        ;GET HIGH
000E1C  1  6D D9 14             ADC     PARM3+1         ;ADD OFFSET
000E1F  1  8D DD 14             STA     POINTR+1        ;AND SAVE
000E22  1  A8                   TAY                     ;SET HIGH
000E23  1  68                   PLA                     ;AND LOW
000E24  1  48                   PHA                     ;SAVE LOW AGAIN
000E25  1  C9 00                CMP     #<MINMEM        ;SEE IF
000E27  1  98                   TYA                     ;TOO SMALL
000E28  1  E9 08                SBC     #>MINMEM        ;LESS THAN TEA
000E2A  1  68                   PLA                     ;GET LOW BACK
000E2B  1  B0 03                BCS     CHKHIG          ;IF OK CONTINUE
000E2D  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000E30  1               CHKHIG
000E30  1  18                   CLC                     ;ADD
000E31  1  6D E3 14             ADC     COUNT           ;COUNT
000E34  1  90 01                BCC     NOYINC          ;TO START
000E36  1  C8                   INY                     ;AND SAVE
000E37  1               NOYINC
000E37  1  CD 7F 13             CMP     STRVEC          ;SEE IF
000E3A  1  98                   TYA                     ;TOO
000E3B  1  ED 80 13             SBC     STRVEC+1        ;BIG
000E3E  1  90 03                BCC     KMHIOK          ;IF OK CONTINUE
000E40  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000E43  1               KMHIOK
000E43  1  20 10 11             JSR     GETTWO          ;GET BYTE
000E46  1  20 DB 14             JSR     MOVPNT          ;STORE
000E49  1  20 B9 11             JSR     INCPNT          ;BUMP POINTER
000E4C  1  CE E3 14             DEC     COUNT           ;COUNT DOWN
000E4F  1  D0 F2                BNE     KMHIOK          ;LOOP IF MORE
000E51  1  20 10 11             JSR     GETTWO          ;IGNORE
000E54  1  20 10 11             JSR     GETTWO          ;CHECKSUM
000E57  1  4C F1 0D             JMP     KIMLOP          ;AND LOOP
000E5A  1               ENDKIM
000E5A  1  20 1D 0F             JSR     NXTPCM          ;SEND MESSAGE
000E5D  1  AD DD 14             LDA     POINTR+1        ;SEND HIGH
000E60  1  20 60 11             JSR     OUTBYT          ;POINTER
000E63  1  AD DC 14             LDA     POINTR          ;THEN LOW
000E66  1  4C 60 11             JMP     OUTBYT          ;POINTER
000E69  1               ;----------------------------------------
000E69  1               ;DISPLAY MEMORY
000E69  1               ;----------------------------------------
000E69  1               XQDISP
000E69  1  20 AC 11             JSR     LSTCHK          ;CHECK START>=END
000E6C  1  90 5B                BCC     ENDDSP          ;EXIT IF NOT
000E6E  1  20 61 12             JSR     LDEABS          ;LOAD ABSOLUTE
000E71  1               LNLOOP
000E71  1  AD DC 14             LDA     POINTR          ;GET
000E74  1  AC DD 14             LDY     POINTR+1        ;POINTER
000E77  1  8D D8 14             STA     PARM3           ;SAVE IN
000E7A  1  8C D9 14             STY     PARM3+1         ;PARM3
000E7D  1  20 F6 11             JSR     CRLF            ;SEND A CR AND LF
000E80  1  20 6C 11             JSR     OUTPNT          ;SEND POINTER
000E83  1  20 FF 11             JSR     OUTSPC          ;THAN A SPACE
000E86  1               HXLOOP
000E86  1  20 DB 14             JSR     MOVPNT          ;GET BYTE
000E89  1  20 5B 12             JSR     BYTSPC          ;SEND IT AND SPACE
000E8C  1  20 B9 11             JSR     INCPNT          ;BUMP POINTER
000E8F  1  20 EF 11             JSR     TSTPR0          ;TEST FOR ZERO POINTER
000E92  1  F0 0D                BEQ     HEXEND          ;EXIT IF IT IS
000E94  1  20 AC 11             JSR     LSTCHK          ;TEST FOR END
000E97  1  90 08                BCC     HEXEND          ;DONE IF IS
000E99  1  AD DC 14             LDA     POINTR          ;ELSE GET POINTER
000E9C  1  2D FF 14             AND     LINMSK          ;IF NOT START
000E9F  1  D0 E5                BNE     HXLOOP          ;THEN LOOP
000EA1  1               HEXEND
000EA1  1  20 92 11             JSR     PR3PTR          ;RESET POINTER
000EA4  1               ASLOOP
000EA4  1  20 DB 14             JSR     MOVPNT          ;GET CHAR
000EA7  1  29 7F                AND     #%01111111      ;MASK PARITY
000EA9  1  C9 21                CMP     #' '+1          ;IF OVER SPACE
000EAB  1  B0 02                BCS     *+4             ;USE
000EAD  1  A9 2E                LDA     #'.'            ;ELSE USE PERIOD
000EAF  1  20 01 12             JSR     CHROUT          ;SEND AS ASCII
000EB2  1  20 B9 11             JSR     INCPNT          ;BUMP POINTER
000EB5  1  20 EF 11             JSR     TSTPR0          ;TEST FOR ZERO POINTER
000EB8  1  F0 0F                BEQ     ENDDSP          ;EXIT IF IT IS
000EBA  1  20 AC 11             JSR     LSTCHK          ;IF MORE
000EBD  1  90 0A                BCC     ENDDSP          ;THEN LAST THEN DONE
000EBF  1  AD DC 14             LDA     POINTR          ;GET POINTER
000EC2  1  2D FF 14             AND     LINMSK          ;IF MORE IN LINE
000EC5  1  D0 DD                BNE     ASLOOP          ;DO IT
000EC7  1  F0 A8                BEQ     LNLOOP          ;ELSE NEW LINE
000EC9  1               ENDDSP
000EC9  1  60                   RTS                     ;DONE
000ECA  1               ;----------------------------------------
000ECA  1               ;SUBSTITUTE
000ECA  1               ;----------------------------------------
000ECA  1               XQSUBS
000ECA  1  20 F6 11             JSR     CRLF            ;SEND A CR AND LF
000ECD  1  20 6C 11             JSR     OUTPNT          ;SEND POINTER
000ED0  1  20 FF 11             JSR     OUTSPC          ;THEN A SPACE
000ED3  1  A9 00                LDA     #0              ;CLEAR
000ED5  1  8D E4 14             STA     NUMBER          ;CONVERT
000ED8  1  8D E5 14             STA     NUMBER+1        ;BUFFER
000EDB  1  A9 02                LDA     #2              ;SET FOR
000EDD  1  8D E3 14             STA     COUNT           ;TWO CHARACTERS
000EE0  1  20 61 12             JSR     LDEABS          ;LOAD ABSOLUTE
000EE3  1  20 DB 14             JSR     MOVPNT          ;GET BYTE
000EE6  1  20 5B 12             JSR     BYTSPC          ;SEND IT AND SPACE
000EE9  1               NXSBIN
000EE9  1  20 28 12             JSR     CHRINP          ;GET CHAR
000EEC  1  C9 0D                CMP     #CR             ;IF A CR
000EEE  1  F0 2A                BEQ     EXTSUB          ;THEN DONE
000EF0  1  C9 2E                CMP     #'.'            ;IF A PERIOD
000EF2  1  F0 20                BEQ     NXTSUB          ;GO TO NEXT
000EF4  1  C9 41                CMP     #'A'            ;IF LESS THAN "A"
000EF6  1  90 06                BCC     NTLWCS          ;SKIP CONVERSION
000EF8  1  C9 5B                CMP     #'Z'+1          ;IF OVER "Z"
000EFA  1  B0 02                BCS     NTLWCS          ;SKIP CONVERSION
000EFC  1  29 5F                AND     #%01011111      ;ELSE CONVERT
000EFE  1               NTLWCS
000EFE  1  20 2A 11             JSR     PACK            ;PACK
000F01  1  90 03                BCC     *+5             ;IF OK CONTINUE
000F03  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
000F06  1  CE E3 14             DEC     COUNT           ;COUNT DOWN
000F09  1  D0 DE                BNE     NXSBIN          ;IF MORE LOOP
000F0B  1  20 67 12             JSR     STRABS          ;STORE ABSOLUTE
000F0E  1  AD E4 14             LDA     NUMBER          ;GET BYTE
000F11  1  20 DB 14             JSR     MOVPNT          ;AND SET
000F14  1               NXTSUB
000F14  1  20 B9 11             JSR     INCPNT          ;GO TO NEXT
000F17  1  4C CA 0E             JMP     XQSUBS          ;LOOP
000F1A  1               EXTSUB
000F1A  1  4C B9 11             JMP     INCPNT          ;END WITH BUMP
000F1D  1               ;NEXT ADDRESS MESSAGE
000F1D  1               NXTPCM
000F1D  1  A2 00                LDX     #0              ;CLEAR INDEX
000F1F  1               PCMLPE
000F1F  1  BD 7F 14             LDA     NXTMSG,X        ;GET CHAR
000F22  1  F0 06                BEQ     EXTPMS          ;IF NULL DONE
000F24  1  20 01 12             JSR     CHROUT          ;ELSE SEND
000F27  1  E8                   INX                     ;BUMP INDEX
000F28  1  D0 F5                BNE     PCMLPE          ;AND LOOP
000F2A  1               EXTPMS
000F2A  1  60                   RTS
000F2B  1               ;DISASSEMBLE AN INSTRUCTION
000F2B  1               DSMBL
000F2B  1  20 38 0F             JSR     INSDSP
000F2E  1  20 27 10             JSR     PNTAJ
000F31  1  8D DC 14             STA     POINTR
000F34  1  8C DD 14             STY     POINTR+1
000F37  1  60                   RTS
000F38  1               INSDSP
000F38  1  20 13 10             JSR     PRPC
000F3B  1  20 61 12             JSR     LDEABS          ;LOAD ABSOLUTE
000F3E  1  20 DB 14             JSR     MOVPNT          ;GET BYTE
000F41  1  A8                   TAY
000F42  1  4A                   LSR     A
000F43  1  90 0B                BCC     IEVEN
000F45  1  4A                   LSR     A
000F46  1  B0 17                BCS     ERR
000F48  1  C9 22                CMP     #$22
000F4A  1  F0 13                BEQ     ERR
000F4C  1  29 07                AND     #7
000F4E  1  09 80                ORA     #$80
000F50  1               IEVEN
000F50  1  4A                   LSR     A
000F51  1  AA                   TAX
000F52  1  BD 9E 13             LDA     MODE,X
000F55  1  B0 04                BCS     RTMODE
000F57  1  4A                   LSR     A
000F58  1  4A                   LSR     A
000F59  1  4A                   LSR     A
000F5A  1  4A                   LSR     A
000F5B  1               RTMODE
000F5B  1  29 0F                AND     #$F
000F5D  1  D0 04                BNE     GETFMT
000F5F  1               ERR
000F5F  1  A0 80                LDY     #$80
000F61  1  A9 00                LDA     #0
000F63  1               GETFMT
000F63  1  AA                   TAX
000F64  1  BD E2 13             LDA     MODE2,X
000F67  1  8D FC 14             STA     FORMAT
000F6A  1  29 03                AND     #3
000F6C  1  8D FB 14             STA     LENGT
000F6F  1  98                   TYA
000F70  1  29 8F                AND     #$8F
000F72  1  AA                   TAX
000F73  1  98                   TYA
000F74  1  A0 03                LDY     #3
000F76  1  E0 8A                CPX     #$8A
000F78  1  F0 0B                BEQ     MNNDX3
000F7A  1               MNNDX1
000F7A  1  4A                   LSR     A
000F7B  1  90 08                BCC     MNNDX3
000F7D  1  4A                   LSR     A
000F7E  1               MNNDX2
000F7E  1  4A                   LSR     A
000F7F  1  09 20                ORA     #$20
000F81  1  88                   DEY
000F82  1  D0 FA                BNE     MNNDX2
000F84  1  C8                   INY
000F85  1               MNNDX3
000F85  1  88                   DEY
000F86  1  D0 F2                BNE     MNNDX1
000F88  1  48                   PHA
000F89  1               PROP
000F89  1  A9 B9                LDA     #$B9            ;LOAD ABS,Y
000F8B  1  8D DB 14             STA     MOVPNT          ;MODE
000F8E  1  20 DB 14             JSR     MOVPNT          ;GET BYTE
000F91  1  20 60 11             JSR     OUTBYT
000F94  1  A2 01                LDX     #1
000F96  1               PROPBL
000F96  1  20 20 10             JSR     PRBL2
000F99  1  CC FB 14             CPY     LENGT
000F9C  1  C8                   INY
000F9D  1  90 EA                BCC     PROP
000F9F  1  A2 03                LDX     #3
000FA1  1  C0 04                CPY     #4
000FA3  1  90 F1                BCC     PROPBL
000FA5  1  68                   PLA
000FA6  1  A8                   TAY
000FA7  1  B9 FC 13             LDA     MNEML,Y
000FAA  1  8D FD 14             STA     LMNEM
000FAD  1  B9 3C 14             LDA     MNEMR,Y
000FB0  1  8D FE 14             STA     RMNEM
000FB3  1               PRMN1
000FB3  1  A9 00                LDA     #0
000FB5  1  A0 05                LDY     #5
000FB7  1               PRMN2
000FB7  1  0E FE 14             ASL     RMNEM
000FBA  1  2E FD 14             ROL     LMNEM
000FBD  1  2A                   ROL     A
000FBE  1  88                   DEY
000FBF  1  D0 F6                BNE     PRMN2
000FC1  1  69 BF                ADC     #$BF
000FC3  1  20 01 12             JSR     CHROUT          ;SEND TO CONSOLE
000FC6  1  CA                   DEX
000FC7  1  D0 EA                BNE     PRMN1
000FC9  1  20 1E 10             JSR     PRBL
000FCC  1  A2 06                LDX     #6
000FCE  1               PRADR1
000FCE  1  E0 03                CPX     #3
000FD0  1  D0 1A                BNE     PRADR3
000FD2  1  AC FB 14             LDY     LENGT
000FD5  1  F0 15                BEQ     PRADR3
000FD7  1               PRADR2
000FD7  1  AD FC 14             LDA     FORMAT
000FDA  1  C9 E8                CMP     #$E8
000FDC  1  A9 B9                LDA     #$B9            ;LOAD ABS,Y
000FDE  1  8D DB 14             STA     MOVPNT          ;MODE
000FE1  1  20 DB 14             JSR     MOVPNT          ;GET BYTE
000FE4  1  B0 1D                BCS     RELADR
000FE6  1  20 60 11             JSR     OUTBYT
000FE9  1  88                   DEY
000FEA  1  D0 EB                BNE     PRADR2
000FEC  1               PRADR3
000FEC  1  0E FC 14             ASL     FORMAT
000FEF  1  90 0E                BCC     PRADR4
000FF1  1  BD EF 13             LDA     CHAR1-1,X
000FF4  1  20 01 12             JSR     CHROUT
000FF7  1  BD F5 13             LDA     CHAR2-1,X
000FFA  1  F0 03                BEQ     PRADR4
000FFC  1  20 01 12             JSR     CHROUT
000FFF  1               PRADR4
000FFF  1  CA                   DEX
001000  1  D0 CC                BNE     PRADR1
001002  1  60                   RTS
001003  1               RELADR
001003  1  20 2B 10             JSR     PNTAJ3
001006  1  AA                   TAX
001007  1  E8                   INX
001008  1  D0 01                BNE     OUTYX
00100A  1  C8                   INY
00100B  1               OUTYX
00100B  1  98                   TYA
00100C  1               OUTAX
00100C  1  20 60 11             JSR     OUTBYT
00100F  1               OUTX
00100F  1  8A                   TXA
001010  1  4C 60 11             JMP     OUTBYT
001013  1               PRPC
001013  1  20 F6 11             JSR     CRLF
001016  1  20 6C 11             JSR     OUTPNT
001019  1  A9 2D                LDA     #'-'
00101B  1  20 01 12             JSR     CHROUT
00101E  1               PRBL
00101E  1  A2 03                LDX     #3
001020  1               PRBL2
001020  1  20 FF 11             JSR     OUTSPC
001023  1  CA                   DEX
001024  1  D0 FA                BNE     PRBL2
001026  1  60                   RTS
001027  1               PNTAJ
001027  1  AD FB 14             LDA     LENGT
00102A  1               PNTAJ2
00102A  1  38                   SEC
00102B  1               PNTAJ3
00102B  1  AC DD 14             LDY     POINTR+1
00102E  1  AA                   TAX
00102F  1  10 01                BPL     PNTAJ4
001031  1  88                   DEY
001032  1               PNTAJ4
001032  1  6D DC 14             ADC     POINTR
001035  1  90 01                BCC     RTS1
001037  1  C8                   INY
001038  1               RTS1
001038  1  60                   RTS
001039  1               ;GATHER PARAMETERS
001039  1               GETPRM
001039  1  A9 00                LDA     #0              ;CLEAR
00103B  1  8D F5 14             STA     NUMPRM          ;COUNT
00103E  1               PRMLPE
00103E  1  20 C1 10             JSR     PSHOVE          ;PUSH PARMS
001041  1  C8                   INY                     ;FIND NEXT
001042  1  20 83 10             JSR     SKPSPC          ;NON-BLANK
001045  1  F0 2F                BEQ     ENDPRM          ;DONE IF NONE
001047  1  8D F8 14             STA     LSTCHR          ;SAVE LAST CHAR
00104A  1  EE F5 14             INC     NUMPRM          ;ELSE BUMP COUNT
00104D  1  C9 2C                CMP     #','            ;IF SEPARATOR
00104F  1  F0 ED                BEQ     PRMLPE          ;TRY FOR ANOTHER
001051  1               PACKIT
001051  1  20 2A 11             JSR     PACK            ;CONVERT AND	PACK
001054  1  B0 1D                BCS     PRMERR          ;IF ERROR EXIT
001056  1  C8                   INY                     ;POINT TO NEXT
001057  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
00105A  1  F0 1A                BEQ     ENDPRM          ;EXIT IF NONE
00105C  1  8D F8 14             STA     LSTCHR          ;SAVE LAST CHAR
00105F  1  C9 2C                CMP     #','            ;IF SEPARATOR
001061  1  F0 DB                BEQ     PRMLPE          ;LOOP FOR MORE
001063  1  C9 20                CMP     #' '            ;IF NOT SPACE
001065  1  D0 EA                BNE     PACKIT          ;TRY TO CONVERT
001067  1  20 83 10             JSR     SKPSPC          ;ELSE GET NEXT
00106A  1  F0 0A                BEQ     ENDPRM          ;DONE IF NONE
00106C  1  8D F8 14             STA     LSTCHR          ;SAVE LAST CHAR
00106F  1  C9 2C                CMP     #','            ;IF SEPSRATOR
001071  1  F0 CB                BEQ     PRMLPE          ;LOOP FOR MORE
001073  1               PRMERR
001073  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
001076  1               ENDPRM
001076  1  AD F8 14             LDA     LSTCHR          ;GET LAST
001079  1  C9 2C                CMP     #','            ;IF NOT COMMA
00107B  1  D0 03                BNE     NOMRPR          ;THEN DONE
00107D  1  EE F5 14             INC     NUMPRM          ;ELSE BUMP COUNT
001080  1               NOMRPR
001080  1  4C C1 10             JMP     PSHOVE          ;PUSH LAST
001083  1               ;SKIP BLANKS
001083  1               SKPSPC
001083  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
001086  1  F0 07                BEQ     EXTSKP          ;DONE IF NONE
001088  1  C9 20                CMP     #' '            ;IF NOT SPACE
00108A  1  D0 03                BNE     EXTSKP          ;THEN DONE
00108C  1  C8                   INY                     ;ELSE LOOP
00108D  1  D0 F4                BNE     SKPSPC          ;AND TRY AGAIN
00108F  1               EXTSKP
00108F  1  60                   RTS
001090  1               ;TEST FOR ILLEGAL
001090  1               TSTLGL
001090  1  B9 B4 14             LDA     CNSTXT,Y        ;GET CHAR
001093  1  F0 28                BEQ     EXTLGL          ;DONE IF NULL
001095  1  C9 20                CMP     #' '            ;IF LESS THAN SPACE
001097  1  90 25                BCC     BADINP          ;IS AN ERROR
001099  1  F0 22                BEQ     EXTLGL
00109B  1  C9 3F                CMP     #'?'
00109D  1  F0 1E                BEQ     EXTLGL
00109F  1  C9 2A                CMP     #'*'
0010A1  1  F0 1A                BEQ     EXTLGL
0010A3  1  C9 3D                CMP     #'='
0010A5  1  F0 16                BEQ     EXTLGL
0010A7  1  C9 5F                CMP     #'_'
0010A9  1  F0 12                BEQ     EXTLGL
0010AB  1  C9 2E                CMP     #'.'
0010AD  1  F0 0E                BEQ     EXTLGL
0010AF  1  C9 3A                CMP     #':'
0010B1  1  F0 0A                BEQ     EXTLGL
0010B3  1  C9 3B                CMP     #SEMICO
0010B5  1  F0 06                BEQ     EXTLGL
0010B7  1  C9 3C                CMP     #'<'
0010B9  1  F0 02                BEQ     EXTLGL
0010BB  1  C9 3E                CMP     #'>'
0010BD  1               EXTLGL
0010BD  1  60                   RTS
0010BE  1               BADINP
0010BE  1  4C D7 11             JMP     ERROR
0010C1  1               ;PUSH PARMS DOWN
0010C1  1               PSHOVE
0010C1  1  A2 10                LDX     #16             ;SHIFT 16 BITS
0010C3  1               SHVLPE
0010C3  1  0E D8 14             ASL     PARM3           ;FROM
0010C6  1  2E D9 14             ROL     PARM3+1         ;PARM3
0010C9  1  2E D6 14             ROL     PARM2           ;TO PARM2
0010CC  1  2E D7 14             ROL     PARM2+1         ;AND FROM
0010CF  1  2E D4 14             ROL     PARM1           ;PARM2 TO
0010D2  1  2E D5 14             ROL     PARM1+1         ;PARM1
0010D5  1  CA                   DEX                     ;LOOP UNTIL
0010D6  1  D0 EB                BNE     SHVLPE          ;ALL DONE
0010D8  1  AD E4 14             LDA     NUMBER          ;GET NUMBER
0010DB  1  8D D8 14             STA     PARM3           ;AND SET PARM3
0010DE  1  AD E5 14             LDA     NUMBER+1        ;LOW AND
0010E1  1  8D D9 14             STA     PARM3+1         ;HIGH
0010E4  1  8E E4 14             STX     NUMBER          ;CLEAR
0010E7  1  8E E5 14             STX     NUMBER+1        ;NUMBER
0010EA  1  60                   RTS
0010EB  1               ;GET CHARACTER
0010EB  1               GETCHR
0010EB  1  AE E1 14             LDX     KIMPNT          ;GET POINTER
0010EE  1  10 17                BPL     NOREAD          ;IF OK USE
0010F0  1  20 1F 12             JSR     RDEDFL          ;ELSE READ
0010F3  1  F0 0E                BEQ     GETOK           ;IF OK CONTINUE
0010F5  1  C9 01                CMP     #1              ;IF EOF
0010F7  1  F0 03                BEQ     *+5             ;IS OK
0010F9  1  4C D7 11             JMP     ERROR           ;ELSE ERROR
0010FC  1  A9 1A                LDA     #EOF            ;GET AN EOF
0010FE  1  8D 28 01             STA     DFLBUF          ;PUT IN BUFFER
001101  1  A9 00                LDA     #0              ;CLEAR A TO
001103  1               GETOK
001103  1  AA                   TAX                     ;CLEAR INDEX
001104  1  8E E1 14             STX     KIMPNT          ;AND POINTER
001107  1               NOREAD
001107  1  EE E1 14             INC     KIMPNT          ;BUMP POINTER
00110A  1  BD 28 01             LDA     DFLBUF,X        ;GET CHAR
00110D  1  29 7F                AND     #%01111111      ;MASK OUT PARITY
00110F  1  60                   RTS
001110  1               ;GET BYTE
001110  1               GETTWO
001110  1  A9 00                LDA     #0              ;CLEAR
001112  1  8D E4 14             STA     NUMBER          ;BUFFER
001115  1  8D E5 14             STA     NUMBER+1        ;SO NO ERROR
001118  1  20 1B 11             JSR     GETONE          ;GET NIBBLE
00111B  1               GETONE
00111B  1  20 EB 10             JSR     GETCHR          ;GET CHAR
00111E  1  20 2A 11             JSR     PACK            ;PACK AND CONVERT
001121  1  B0 04                BCS     GETERR          ;ERROR IF CARRY
001123  1  AD E4 14             LDA     NUMBER          ;ELSE GET RESULT
001126  1  60                   RTS
001127  1               GETERR
001127  1  4C D7 11             JMP     ERROR           ;ERROR EXIT
00112A  1               ;PACK ASCII
00112A  1               PACK
00112A  1  C9 30                CMP     #'0'            ;IF TOO SMALL
00112C  1  30 22                BMI     PACKER          ;THEN ERROR
00112E  1  C9 3A                CMP     #'9'+1          ;IF "0" TO "9"
001130  1  30 0B                BMI     DECNUM          ;IS DECIMAL
001132  1  C9 41                CMP     #'A'            ;IF LESS THAN "A"
001134  1  30 1A                BMI     PACKER          ;THEN ERROR
001136  1  C9 47                CMP     #'F'+1          ;IF MORE THAN "F"
001138  1  10 16                BPL     PACKER          ;THEN ERROR
00113A  1  18                   CLC                     ;ELSE ADD
00113B  1  69 09                ADC     #9              ;NINE
00113D  1               DECNUM
00113D  1  2A                   ROL     A               ;MOVE
00113E  1  2A                   ROL     A               ;TO
00113F  1  2A                   ROL     A               ;HIGH
001140  1  2A                   ROL     A               ;NIBBLE
001141  1  A2 04                LDX     #4              ;SHIFT
001143  1               PACKLP
001143  1  2A                   ROL     A               ;INPUT
001144  1  2E E4 14             ROL     NUMBER          ;AND
001147  1  2E E5 14             ROL     NUMBER+1        ;BUFFER
00114A  1  B0 04                BCS     PACKER          ;ERROR IF CARRY
00114C  1  CA                   DEX                     ;COUNT DOWN
00114D  1  D0 F4                BNE     PACKLP          ;AND LOOP
00114F  1  60                   RTS
001150  1               PACKER
001150  1  38                   SEC                     ;ERROR
001151  1  60                   RTS                     ;RETURN
001152  1               ;OUTPUT NIBBLE
001152  1               OUTNIB
001152  1  29 0F                AND     #%00001111      ;LOW NIBBLE
001154  1  09 30                ORA     #'0'            ;MAKE ASCII
001156  1  C9 3A                CMP     #'9'+1          ;IF "0" TO "9"
001158  1  30 03                BMI     NOTALP          ;SEND IT
00115A  1  18                   CLC                     ;ELSE
00115B  1  69 07                ADC     #7              ;ADD SEVEN
00115D  1               NOTALP
00115D  1  4C 01 12             JMP     CHROUT          ;WRITE IT
001160  1               ;OUTPUT BYTE
001160  1               OUTBYT
001160  1  48                   PHA                     ;SAVE
001161  1  4A                   LSR     A               ;MOVE
001162  1  4A                   LSR     A               ;HIGH
001163  1  4A                   LSR     A               ;TO
001164  1  4A                   LSR     A               ;LOW
001165  1  20 52 11             JSR     OUTNIB          ;SEND
001168  1  68                   PLA                     ;THEN SEND
001169  1  4C 52 11             JMP     OUTNIB          ;HIGH
00116C  1               ;OUTPUT POINTER
00116C  1               OUTPNT
00116C  1  AD DD 14             LDA     POINTR+1        ;GET HIGH
00116F  1  20 60 11             JSR     OUTBYT          ;SEND
001172  1  AD DC 14             LDA     POINTR          ;THEN LOW
001175  1  4C 60 11             JMP     OUTBYT          ;SEND IT
001178  1               ;PARAMETER 1 TO POINTER
001178  1               PR1PTR
001178  1  AD D4 14             LDA     PARM1           ;GET LOW
00117B  1  AC D5 14             LDY     PARM1+1         ;AND HIGH
00117E  1  8D DC 14             STA     POINTR          ;SET
001181  1  8C DD 14             STY     POINTR+1        ;POINTER
001184  1  60                   RTS
001185  1               ;PARAMETER 2 TO POINTER
001185  1               PR2PTR
001185  1  AD D6 14             LDA     PARM2           ;GET LOW
001188  1  AC D7 14             LDY     PARM2+1         ;AND HIGH
00118B  1  8D DC 14             STA     POINTR          ;SET
00118E  1  8C DD 14             STY     POINTR+1        ;POINTER
001191  1  60                   RTS
001192  1               ;PARAMETER 3 TO POINTER
001192  1               PR3PTR
001192  1  AD D8 14             LDA     PARM3           ;GET LOW
001195  1  AC D9 14             LDY     PARM3+1         ;AND HIGH
001198  1  8D DC 14             STA     POINTR          ;SET
00119B  1  8C DD 14             STY     POINTR+1        ;POINTER
00119E  1  60                   RTS
00119F  1               ;PARAMETER 3 TO PARAMETER 2
00119F  1               PR3PR2
00119F  1  AD D8 14             LDA     PARM3           ;GET LOW
0011A2  1  AC D9 14             LDY     PARM3+1         ;AND HIGH
0011A5  1  8D D6 14             STA     PARM2           ;SET
0011A8  1  8C D7 14             STY     PARM2+1         ;PARM 2
0011AB  1  60                   RTS
0011AC  1               ;LAST ADDRESS CHECK
0011AC  1               LSTCHK
0011AC  1  AD D6 14             LDA     PARM2           ;SUBTRACT
0011AF  1  CD DC 14             CMP     POINTR          ;POINTER
0011B2  1  AD D7 14             LDA     PARM2+1         ;FROM
0011B5  1  ED DD 14             SBC     POINTR+1        ;PARM2
0011B8  1  60                   RTS
0011B9  1               ;INCREMENT POINTER
0011B9  1               INCPNT
0011B9  1  EE DC 14             INC     POINTR          ;BUMP LOW
0011BC  1  D0 03                BNE     *+5             ;DONE IF NOT ZERO
0011BE  1  EE DD 14             INC     POINTR+1        ;ELSE BUMP HIGH
0011C1  1  60                   RTS
0011C2  1               ;DECREMENT POINTER
0011C2  1               DECPNT
0011C2  1  AD DC 14             LDA     POINTR          ;GET LOW
0011C5  1  D0 03                BNE     *+5             ;JUMP IF NOT ZERO
0011C7  1  CE DD 14             DEC     POINTR+1        ;ELSE DROP HIGH
0011CA  1  CE DC 14             DEC     POINTR          ;ALWAYS DROP LOW
0011CD  1  60                   RTS
0011CE  1               ;INCREMENT PARAMETER 2
0011CE  1               INCPR2
0011CE  1  EE D6 14             INC     PARM2           ;BUMP LOW
0011D1  1  D0 03                BNE     *+5             ;DONE IF NOT ZERO
0011D3  1  EE D7 14             INC     PARM2+1         ;ELSE BUMP HIGH
0011D6  1  60                   RTS
0011D7  1               ;ERROR HANDLER
0011D7  1               ERROR
0011D7  1  20 F6 11             JSR     CRLF            ;SEND CR LF
0011DA  1  A9 3F                LDA     #'?'            ;THEN A
0011DC  1  20 01 12             JSR     CHROUT          ;QUESTION
0011DF  1  4C 27 0A             JMP     GETCOM          ;RESTART
0011E2  1               ;PARM3 TO USER PC
0011E2  1               PRMUPC
0011E2  1  AD D8 14             LDA     PARM3           ;GET LOW
0011E5  1  AC D9 14             LDY     PARM3+1         ;AND HIGH
0011E8  1  8D E6 14             STA     USRPC           ;SET PC
0011EB  1  8C E7 14             STY     USRPC+1         ;IN RAM
0011EE  1  60                   RTS
0011EF  1               ;TEST FOR POINTER=0
0011EF  1               TSTPR0
0011EF  1  AD DC 14             LDA     POINTR          ;GET LOW
0011F2  1  0D DD 14             ORA     POINTR+1        ;OR WITH HIGH
0011F5  1  60                   RTS
0011F6  1               ;CR AND LF
0011F6  1               CRLF
0011F6  1  A9 0D                LDA     #CR             ;DO
0011F8  1  20 01 12             JSR     CHROUT          ;A CR
0011FB  1  A9 0A                LDA     #LF             ;AND
0011FD  1  D0 02                BNE     CHROUT          ;A LF
0011FF  1               ;OUTPUT SPACE
0011FF  1               OUTSPC
0011FF  1  A9 20                LDA     #' '            ;GET SPACE
001201  1               ;OUTPUT WITH SAVE
001201  1               CHROUT
001201  1  48                   PHA                     ;SAVE CHAR
001202  1  8E F6 14             STX     SAVEX           ;SAVE X
001205  1  8C F7 14             STY     SAVEY           ;AND Y
001208  1  20 2C 12             JSR     OUTCHR          ;SEND
00120B  1  AC F7 14             LDY     SAVEY           ;RESTORE
00120E  1  AE F6 14             LDX     SAVEX           ;X AND Y
001211  1  68                   PLA                     ;THEN CHAR
001212  1  60                   RTS
001213  1               ;DEFAULT FILE REFERENCES
001213  1               SETBUF
001213  1  A9 28                LDA     #<DFLBUF        ;POINT TO
001215  1  A0 01                LDY     #>DFLBUF        ;DEFAULT BUFFER
001217  1               SETDMA
001217  1  A2 1A                LDX     #26             ;SET DMA
001219  1  D0 1F                BNE     PEMGO
00121B  1               OPNDFL
00121B  1  A2 0F                LDX     #15             ;OPEN FILE
00121D  1  D0 02                BNE     SETDFL
00121F  1               RDEDFL
00121F  1  A2 14                LDX     #20             ;READ RECORD
001221  1               SETDFL
001221  1  A9 07                LDA     #<DFLFCB        ;POINT TO
001223  1  A0 01                LDY     #>DFLFCB        ;DEFAULT FCB
001225  1  4C 3A 12             JMP     PEMGO           ;GO
001228  1               ;GENERAL PEM REFERENCES
001228  1               CHRINP
001228  1  A2 01                LDX     #1              ;CHARACTER INPUT
00122A  1  D0 0E                BNE     PEMGO
00122C  1               OUTCHR
00122C  1  29 7F                AND     #$7F            ;CLEAR MSB
00122E  1  A2 02                LDX     #2              ;DO CHAR OUTPUT
001230  1  D0 08                BNE     PEMGO
001232  1               RDEBUF
001232  1  AD 82 13             LDA     BUFVEC          ;READ BUFFER
001235  1  AC 83 13             LDY     BUFVEC+1
001238  1  A2 0A                LDX     #10
00123A  1               PEMGO
00123A  1  6C B0 14             JMP     (VECTOR)
00123D  1               ;SET BRK OPCODE
00123D  1               SETBPT
00123D  1  20 67 12             JSR     STRABS          ;STORE ABSOLUTE
001240  1  A9 00                LDA     #0              ;BRK CODE
001242  1  4C DB 14             JMP     MOVPNT          ;SET
001245  1               ;MOVE POINTER TO BREAKPOINT POINTER (X=0 OR 2)
001245  1               PNTBPT
001245  1  AD DC 14             LDA     POINTR          ;GET LOW
001248  1  9D ED 14             STA     BRKPT1,X        ;SET LOW
00124B  1  AD DD 14             LDA     POINTR+1        ;GET HIGH
00124E  1  9D EE 14             STA     BRKPT1+1,X      ;THEN SET
001251  1  CA                   DEX                     ;DROP X
001252  1  10 01                BPL     *+3             ;IF 1 OK
001254  1  E8                   INX                     ;ELSE MAKE 0
001255  1  A9 FF                LDA     #$FF            ;GET FLAG
001257  1  9D F3 14             STA     BRFLG1,X        ;AND SET
00125A  1  60                   RTS
00125B  1               ;SEND BYTE THEN ASCII SPACE
00125B  1               BYTSPC
00125B  1  20 60 11             JSR     OUTBYT          ;SEND BYTE
00125E  1  4C FF 11             JMP     OUTSPC          ;THEN SPACE
001261  1               ;LOAD ABSOLUTE MODE
001261  1               LDEABS
001261  1  A9 AD                LDA     #$AD            ;LOAD ABSOLUTE CODE
001263  1  8D DB 14             STA     MOVPNT          ;SET
001266  1  60                   RTS
001267  1               ;STORE ABSOLUTE MODE
001267  1               STRABS
001267  1  A9 8D                LDA     #$8D            ;STORE ABSOLUTE CODE
001269  1  8D DB 14             STA     MOVPNT          ;SET
00126C  1  60                   RTS
00126D  1               ;CLEAR BREAKPOINTS
00126D  1               CLRBPS
00126D  1  20 67 12             JSR     STRABS          ;SET STORE ABSOLUTE
001270  1  A2 00                LDX     #0              ;FIRST POINTER
001272  1  A0 00                LDY     #0              ;FIRST FLAG AND OPCODE
001274  1  20 7A 12             JSR     CLR1            ;CLEAR FIRST
001277  1  C8                   INY                     ;SECOND FLAG AND OPCODE
001278  1  A2 02                LDX     #2              ;SECOND POINTER
00127A  1               ;CLEAR ONE BREAKPOINT
00127A  1               CLR1
00127A  1  B9 F3 14             LDA     BRFLG1,Y        ;GET FLAG
00127D  1  F0 17                BEQ     CLR1EX          ;DO NOTHING IN CLEAR
00127F  1  BD ED 14             LDA     BRKPT1,X        ;ELSE GET
001282  1  8D DC 14             STA     POINTR          ;ADDRESS
001285  1  BD EE 14             LDA     BRKPT1+1,X      ;AND SET
001288  1  8D DD 14             STA     POINTR+1        ;POINTER
00128B  1  B9 F1 14             LDA     OPCDE1,Y        ;THEN GET OPCODE
00128E  1  20 DB 14             JSR     MOVPNT          ;AND RESTORE
001291  1  A9 00                LDA     #0              ;CLEAR
001293  1  99 F3 14             STA     BRFLG1,Y        ;FLAG
001296  1               CLR1EX
001296  1  60                   RTS
001297  1               ;IRQ AND BRK HANDLER
001297  1               IRQBRK
001297  1  08                   PHP                     ;SAVE P
001298  1  48                   PHA                     ;A
001299  1  8A                   TXA                     ;AND
00129A  1  48                   PHA                     ;X
00129B  1  BA                   TSX                     ;GET STATUS
00129C  1  BD 04 01             LDA     $104,X          ;FROM STACK
00129F  1  29 10                AND     #%00010000      ;LOOK AT BRK BIT
0012A1  1  D0 07                BNE     ISABRK          ;BRK IF NOT ZERO
0012A3  1  68                   PLA                     ;ELSE RESTORE
0012A4  1  AA                   TAX                     ;X
0012A5  1  68                   PLA                     ;A
0012A6  1               USRBRK
0012A6  1  28                   PLP                     ;AND P
0012A7  1  6C AE 14             JMP     (IRQVEC)        ;AND DO IRQ
0012AA  1               ISABRK
0012AA  1  68                   PLA                     ;RESTORE
0012AB  1  AA                   TAX                     ;X
0012AC  1  68                   PLA                     ;A
0012AD  1  28                   PLP                     ;AND P
0012AE  1  8D E8 14             STA     USRA            ;NOW SAVE
0012B1  1  8E E9 14             STX     USRX            ;EVERYTHING
0012B4  1  8C EA 14             STY     USRY            ;IN
0012B7  1  68                   PLA                     ;USER
0012B8  1  8D EC 14             STA     USRP            ;SAVE
0012BB  1  68                   PLA                     ;LOCATIONS
0012BC  1  8D E6 14             STA     USRPC           ;INCLUDING
0012BF  1  68                   PLA                     ;PC
0012C0  1  8D E7 14             STA     USRPC+1         ;AND
0012C3  1  BA                   TSX                     ;STACK
0012C4  1  8E EB 14             STX     USRS            ;BEFORE BRK
0012C7  1  D8                   CLD                     ;BINARY MODE
0012C8  1  38                   SEC                     ;ADJUST
0012C9  1  AD E6 14             LDA     USRPC           ;PC
0012CC  1  E9 02                SBC     #2              ;TO
0012CE  1  8D E6 14             STA     USRPC           ;CORRECTLY
0012D1  1  B0 03                BCS     *+5             ;POINT TO
0012D3  1  CE E7 14             DEC     USRPC+1         ;BRK
0012D6  1  AD F3 14             LDA     BRFLG1          ;IF FLAG ZERO
0012D9  1  F0 10                BEQ     TRYBP2          ;IS NOT SET
0012DB  1  AD E6 14             LDA     USRPC           ;ELSE GET LOW
0012DE  1  AC E7 14             LDY     USRPC+1         ;AND HIGH PC
0012E1  1  CD ED 14             CMP     BRKPT1          ;IF LOW NOT
0012E4  1  D0 05                BNE     TRYBP2          ;EQUAL TRY 2
0012E6  1  CC EE 14             CPY     BRKPT1+1        ;IF HIGH
0012E9  1  F0 15                BEQ     RSTOPC          ;EQUAL IS OK
0012EB  1               TRYBP2
0012EB  1  AD F4 14             LDA     BRFLG2          ;IF NOT SET
0012EE  1  F0 25                BEQ     NOTSET          ;MUST BE USER
0012F0  1  AD E6 14             LDA     USRPC           ;ELSE GET
0012F3  1  AC E7 14             LDY     USRPC+1         ;USER PC
0012F6  1  CD EF 14             CMP     BRKPT2          ;IF LOW NOT SAME
0012F9  1  D0 1A                BNE     NOTSET          ;IS USER
0012FB  1  CC F0 14             CPY     BRKPT2+1        ;IF HIGH NOT SAME
0012FE  1  D0 15                BNE     NOTSET          ;IS USER
001300  1               RSTOPC
001300  1  20 6D 12             JSR     CLRBPS          ;CLEAR BREAKPOINTS
001303  1  AD E6 14             LDA     USRPC           ;SET
001306  1  AC E7 14             LDY     USRPC+1         ;POINTER
001309  1  8D DC 14             STA     POINTR          ;TO PC
00130C  1  8C DD 14             STY     POINTR+1        ;FOR OPCODE RESTORE
00130F  1  20 38 0F             JSR     INSDSP          ;SHOW INSTRUCTION
001312  1  4C F2 0A             JMP     NOSTCH          ;SHOW STATUS
001315  1               ;USER BRK
001315  1               NOTSET
001315  1  18                   CLC                     ;ADJUST
001316  1  AD E6 14             LDA     USRPC           ;USER
001319  1  69 02                ADC     #2              ;PC
00131B  1  8D E6 14             STA     USRPC           ;TO ORIGINAL
00131E  1  90 03                BCC     *+5             ;FOR
001320  1  EE E7 14             INC     USRPC+1         ;BRK
001323  1  AD E7 14             LDA     USRPC+1         ;GET HIGH
001326  1  48                   PHA                     ;PUSH
001327  1  AD E6 14             LDA     USRPC           ;GET LOW
00132A  1  48                   PHA                     ;PUSH
00132B  1  AD EC 14             LDA     USRP            ;GET FLAGS
00132E  1  48                   PHA                     ;PUSH
00132F  1  AE E9 14             LDX     USRX            ;GET X
001332  1  AC EA 14             LDY     USRY            ;AND Y
001335  1  AD E8 14             LDA     USRA            ;AND A
001338  1  4C A6 12             JMP     USRBRK
00133B  1               ;GET CHAR PER LINE
00133B  1               GTCHLN
00133B  1  AD 3D FF             LDA     $FF00+61        ;DUMMY WITH OFFSET
00133E  1  60                   RTS
00133F  1               ;GET LINES PER SCREEN - 1
00133F  1               GTLNSC
00133F  1  AD 3C FF             LDA     $FF00+60        ;DUMMY WITH OFFSET
001342  1  38                   SEC
001343  1  E9 01                SBC     #1
001345  1  60                   RTS
001346  1               ;CALCULATE BYTES PER LINE
001346  1               CLBYLN
001346  1  20 3B 13             JSR     GTCHLN          ;GET CHAR PER LINE
001349  1  C9 21                CMP     #33
00134B  1  B0 06                BCS     GT32            ;IF >32 THEN
00134D  1  A9 02                LDA     #2
00134F  1  A2 03                LDX     #%11
001351  1  D0 0E                BNE     GOTMOD
001353  1               GT32
001353  1  C9 41                CMP     #65
001355  1  B0 06                BCS     GT64            ;IF >64 THEN
001357  1  A9 03                LDA     #3
001359  1  A2 07                LDX     #%111
00135B  1  D0 04                BNE     GOTMOD
00135D  1               GT64
00135D  1  A9 04                LDA     #4
00135F  1  A2 0F                LDX     #%1111
001361  1               GOTMOD
001361  1  8D 00 15             STA     BYTPLN          ;SAVE BOTH PARAMS
001364  1  8E FF 14             STX     LINMSK
001367  1  60                   RTS
001368  1               ;CALCULATE TOTAL BYTES-1
001368  1               CLTLBY
001368  1  20 46 13             JSR     CLBYLN          ;BYTES PER LINE
00136B  1  AA                   TAX                     ;SAVE LOG OF BYTES PER LINE
00136C  1  20 3F 13             JSR     GTLNSC
00136F  1  38                   SEC
001370  1  E9 01                SBC     #1              ;DROP ANOTHER FOR SECURITY
001372  1               CLTLLP
001372  1  0A                   ASL     A
001373  1  90 02                BCC     *+4             ;OK IF NO CARRY
001375  1  A9 00                LDA     #0              ;ELSE IS "256"
001377  1  CA                   DEX
001378  1  D0 F8                BNE     CLTLLP          ;LOOP IF MORE
00137A  1  38                   SEC
00137B  1  E9 01                SBC     #1              ;DROP BY ONE
00137D  1  60                   RTS
00137E  1               ;RELOCATABLE VECTORS
00137E  1  20                   .BYTE   $20
00137F  1               STRVEC
00137F  1  00 0A                .WORD   PEMVEC          ;START OF DEBUG
001381  1  20                   .BYTE   $20
001382  1               BUFVEC
001382  1  B2 14                .WORD   CNSBUF          ;CONSOLE BUFFER
001384  1  20                   .BYTE   $20
001385  1               IBKVEC
001385  1  97 12                .WORD   IRQBRK          ;IRQ/BRK VECTOR
001387  1  FF                   .BYTE   $FF             ;STOPPER FOR RELOCATE
001388  1               ;REGISTER TABLE
001388  1               REGTBL
001388  1  41 00                .BYTE   "A",0
00138A  1  58 00                .BYTE   "X",0
00138C  1  59 00                .BYTE   "Y",0
00138E  1  53 00                .BYTE   "S",0
001390  1  4E 80                .BYTE   "N",128
001392  1  56 40                .BYTE   "V",64
001394  1  42 10                .BYTE   "B",16
001396  1  44 08                .BYTE   "D",8
001398  1  49 04                .BYTE   "I",4
00139A  1  5A 02                .BYTE   "Z",2
00139C  1  43 01                .BYTE   "C",1
00139E  1               ;DISASSEMBLER TABLES
00139E  1               MODE
00139E  1  40 02 45 03          .BYTE   $40,$2,$45,$3,$D0,$8,$40,$9
0013A2  1  D0 08 40 09  
0013A6  1  30 22 45 33          .BYTE   $30,$22,$45,$33,$D0,$8,$40,$9
0013AA  1  D0 08 40 09  
0013AE  1  40 02 45 33          .BYTE   $40,$2,$45,$33,$D0,$8,$40,$9
0013B2  1  D0 08 40 09  
0013B6  1  40 02 45 B3          .BYTE   $40,$2,$45,$B3,$D0,$8,$40,$9
0013BA  1  D0 08 40 09  
0013BE  1  00 22 44 33          .BYTE   $0,$22,$44,$33,$D0,$8C,$44,$0
0013C2  1  D0 8C 44 00  
0013C6  1  11 22 44 33          .BYTE   $11,$22,$44,$33,$D0,$8C,$44,$9A
0013CA  1  D0 8C 44 9A  
0013CE  1  10 22 44 33          .BYTE   $10,$22,$44,$33,$D0,$8,$40,$9
0013D2  1  D0 08 40 09  
0013D6  1  10 22 44 33          .BYTE   $10,$22,$44,$33,$D0,$8,$40,$9
0013DA  1  D0 08 40 09  
0013DE  1  62 13 78 A9          .BYTE   $62,$13,$78,$A9
0013E2  1               MODE2
0013E2  1  00 21 81 82          .BYTE   $0,$21,$81,$82,$0,$0,$59,$4D
0013E6  1  00 00 59 4D  
0013EA  1  91 92 86 4A          .BYTE   $91,$92,$86,$4A,$85,$9D
0013EE  1  85 9D        
0013F0  1               CHAR1
0013F0  1  AC A9 AC A3          .BYTE   $AC,$A9,$AC,$A3,$A8,$A4
0013F4  1  A8 A4        
0013F6  1               CHAR2
0013F6  1  D9 00 D8 A4          .BYTE   $D9,$0,$D8,$A4,$A4,$0
0013FA  1  A4 00        
0013FC  1               MNEML
0013FC  1  1C 8A 1C 23          .BYTE   $1C,$8A,$1C,$23,$5D,$8B,$1B,$A1
001400  1  5D 8B 1B A1  
001404  1  9D 8A 1D 23          .BYTE   $9D,$8A,$1D,$23,$9D,$8B,$1D,$A1
001408  1  9D 8B 1D A1  
00140C  1  00 29 19 AE          .BYTE   $0,$29,$19,$AE,$69,$A8,$19,$23
001410  1  69 A8 19 23  
001414  1  24 53 1B 23          .BYTE   $24,$53,$1B,$23,$24,$53,$19,$A1
001418  1  24 53 19 A1  
00141C  1  00 1A 5B 5B          .BYTE   $0,$1A,$5B,$5B,$A5,$69,$24,$24
001420  1  A5 69 24 24  
001424  1  AE AE A8 AD          .BYTE   $AE,$AE,$A8,$AD,$29,$0,$7C,$0
001428  1  29 00 7C 00  
00142C  1  15 9C 6D 9C          .BYTE   $15,$9C,$6D,$9C,$A5,$69,$29,$53
001430  1  A5 69 29 53  
001434  1  84 13 34 11          .BYTE   $84,$13,$34,$11,$A5,$69,$23,$A0
001438  1  A5 69 23 A0  
00143C  1               MNEMR
00143C  1  D8 62 5A 48          .BYTE   $D8,$62,$5A,$48,$26,$62,$94,$88
001440  1  26 62 94 88  
001444  1  54 44 C8 54          .BYTE   $54,$44,$C8,$54,$68,$44,$E8,$94
001448  1  68 44 E8 94  
00144C  1  00 B4 08 84          .BYTE   $0,$B4,$8,$84,$74,$B4,$28,$6E
001450  1  74 B4 28 6E  
001454  1  74 F4 CC 4A          .BYTE   $74,$F4,$CC,$4A,$72,$F2,$A4,$8A
001458  1  72 F2 A4 8A  
00145C  1  00 AA A2 A2          .BYTE   $0,$AA,$A2,$A2,$74,$74,$74,$72
001460  1  74 74 74 72  
001464  1  44 68 B2 32          .BYTE   $44,$68,$B2,$32,$B2,$0,$22,$0
001468  1  B2 00 22 00  
00146C  1  1A 1A 26 26          .BYTE   $1A,$1A,$26,$26,$72,$72,$88,$C8
001470  1  72 72 88 C8  
001474  1  C4 CA 26 48          .BYTE   $C4,$CA,$26,$48,$44,$44,$A2,$C8
001478  1  44 44 A2 C8  
00147C  1               ;MESSAGES
00147C  1               COMTYP
00147C  1  43 4F 4D             .BYTE   "COM"
00147F  1               NXTMSG
00147F  1  0D 0A 4E 45          .BYTE   CR,LF,"NEXT ADDRESS=",0
001483  1  58 54 20 41  
001487  1  44 44 52 45  
00148F  1               STEMSG
00148F  1  0D 0A 2A 20          .BYTE   CR,LF,"*    A  X  Y  S  NV?BDIZC",CR,LF,0
001493  1  20 20 20 41  
001497  1  20 20 58 20  
0014AD  1               ;VARIABLE STORAGE
0014AD  1  xx                   .ALIGN  2               ;ALIGN ON WORD BOUNDARY
0014AE  1               IRQVEC
0014AE  1  00 00                .WORD   0               ;IRQ VECTOR
0014B0  1               VECTOR
0014B0  1  00 00                .WORD   0               ;PEM VECTOR
0014B2  1               CNSBUF
0014B2  1               CNSMAX
0014B2  1  20                   .BYTE   32              ;INPUT
0014B3  1               CNSLNG
0014B3  1  00                   .BYTE   0               ;BUFFER
0014B4  1               CNSTXT
0014B4  1  xx xx xx xx          .RES    32
0014B8  1  xx xx xx xx  
0014BC  1  xx xx xx xx  
0014D4  1               PARM1
0014D4  1  00 00                .WORD   0               ;PARAMETERS
0014D6  1               PARM2
0014D6  1  00 00                .WORD   0               ;FOR
0014D8  1               PARM3
0014D8  1  00 00                .WORD   0               ;COMMANDS
0014DA  1               COMMND
0014DA  1  00                   .BYTE   0               ;COMMAND LETTER
0014DB  1               MOVPNT
0014DB  1  8D                   .BYTE   $8D             ;OPCODE
0014DC  1               POINTR
0014DC  1  00 08                .WORD   TEA             ;POINTER
0014DE  1  60                   .BYTE   $60             ;RETURN
0014DF  1               BUFADD
0014DF  1  00 08                .WORD   TEA             ;COM READ ADDRESS
0014E1  1               KIMPNT
0014E1  1  00                   .BYTE   0               ;KIM CHAR POINTER
0014E2  1               SAVPNT
0014E2  1  00                   .BYTE   0               ;SAVE POINTER
0014E3  1               COUNT
0014E3  1  00                   .BYTE   0               ;COUNTER
0014E4  1               NUMBER
0014E4  1  00 00                .WORD   0               ;PACK BUFFER
0014E6  1               USRPC
0014E6  1  00 08                .WORD   TEA             ;USER REGISTERS
0014E8  1               USRA
0014E8  1  00                   .BYTE   0
0014E9  1               USRX
0014E9  1  00                   .BYTE   0
0014EA  1               USRY
0014EA  1  00                   .BYTE   0
0014EB  1               USRS
0014EB  1  FF                   .BYTE   $FF
0014EC  1               USRP
0014EC  1  04                   .BYTE   %00000100
0014ED  1               BRKPT1
0014ED  1  00 00                .WORD   0               ;BREAKPOINT 1
0014EF  1               BRKPT2
0014EF  1  00 00                .WORD   0               ;BREAKPOINT 2
0014F1  1               OPCDE1
0014F1  1  00                   .BYTE   0               ;OPCODE 1
0014F2  1               OPCDE2
0014F2  1  00                   .BYTE   0               ;OPCODE 2
0014F3  1               BRFLG1
0014F3  1  00                   .BYTE   0               ;BREAK SET
0014F4  1               BRFLG2
0014F4  1  00                   .BYTE   0               ;FLAGS
0014F5  1               NUMPRM
0014F5  1  00                   .BYTE   0               ;NUMBER PARMS
0014F6  1               SAVEX
0014F6  1  00                   .BYTE   0               ;SAVE
0014F7  1               SAVEY
0014F7  1  00                   .BYTE   0               ;REGISTERS
0014F8  1               LSTCHR
0014F8  1  00                   .BYTE   0               ;LAST PARM CHAR
0014F9  1               BRKOK
0014F9  1  00                   .BYTE   0               ;0 IF BRK ALLOWED
0014FA  1               XRGCMD
0014FA  1  00                   .BYTE   0               ;STATE COMMAND
0014FB  1               LENGT
0014FB  1  00                   .BYTE   0               ;INSTRUCTION LENGTH
0014FC  1               FORMAT
0014FC  1  00                   .BYTE   0               ;FORMAT CODE
0014FD  1               LMNEM
0014FD  1  00                   .BYTE   0               ;LEFT NAME
0014FE  1               RMNEM
0014FE  1  00                   .BYTE   0               ;RIGHT NAME
0014FF  1               LINMSK
0014FF  1  00                   .BYTE   0               ;LINE END MASK FOR DISPLAY
001500  1               BYTPLN
001500  1  00                   .BYTE   0               ;BYTES PER LINE FOR DISPLAY
001501  1               ;ALIGN END ON PAGE BOUNDARY-1
001501  1               LAST            = */256*256+256-1
001501  1                       .END
