ca65 V2.18 - Ubuntu 2.19-1
Main file   : dbasic.asm
Current file: dbasic.asm

000000r 1                       .IFDEF  DUODYNE
000000r 1               .P816
000000r 1               
000000r 1                       .MACRO  INDEX16         ; Set 16bit Index Registers
000000r 1                       REP     #$10            ; 16 bit Index registers
000000r 1                       .I16
000000r 1                       .ENDMACRO
000000r 1                       .MACRO  INDEX8          ; Set 8bit Index Registers
000000r 1                       SEP     #$10            ; 8 bit Index registers
000000r 1                       .I8
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ACCUMULATOR16   ; Set 16bit Index Registers
000000r 1                       REP     #$20            ; 16 bit Index registers
000000r 1                       .A16
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ACCUMULATOR8    ; Set 8bit Index Registers
000000r 1                       SEP     #$20            ; 8 bit Index registers
000000r 1                       .A8
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ACCUMULATORINDEX16; Set 16bit Index Registers
000000r 1                       REP     #$30            ; 16 bit Index registers
000000r 1                       .A16
000000r 1                       .I16
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ACCUMULATORINDEX8; Set 8bit Index Registers
000000r 1                       SEP     #$30            ; 8 bit Index registers
000000r 1                       .A8
000000r 1                       .I8
000000r 1                       .ENDMACRO
000000r 1               
000000r 1               
000000r 1                       .MACRO  LDAINDIRECTY PARM1
000000r 1                       PHB
000000r 1                       PHX
000000r 1                       LDX     #$01
000000r 1                       LDA     <PARM1,X
000000r 1                       CMP     #$00
000000r 1                       BNE     *+6
000000r 1                       LDX     #00
000000r 1                       PHX
000000r 1                       PLB
000000r 1                       PLX
000000r 1                       LDA     (<PARM1),Y      ;
000000r 1                       STA     <TMPFLG
000000r 1                       PLB
000000r 1                       LDA     <TMPFLG
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  STAINDIRECTY PARM1
000000r 1                       PHB
000000r 1                       PHX
000000r 1                       PHA
000000r 1                       LDX     #$01
000000r 1                       LDA     <PARM1,X
000000r 1                       CMP     #$00
000000r 1                       BNE     *+6
000000r 1                       LDX     #00
000000r 1                       PHX
000000r 1                       PLB
000000r 1                       PLA
000000r 1                       PLX
000000r 1                       STA     (<PARM1),Y      ;
000000r 1                       PLB
000000r 1                       STA     <TMPFLG
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  FETCHINDIRECTY PARM1
000000r 1                       PHB
000000r 1                       PHA
000000r 1                       PHX
000000r 1                       LDX     #$01
000000r 1                       LDA     <PARM1,X
000000r 1                       CMP     #$00
000000r 1                       BNE     *+6
000000r 1                       LDX     #00
000000r 1                       PHX
000000r 1                       PLB
000000r 1                       PLX
000000r 1                       LDA     (<PARM1),Y      ;
000000r 1                       STA     <TMPFLG
000000r 1                       PLA
000000r 1                       PLB
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  CMPINDIRECTY  PARM1
000000r 1                       PHB
000000r 1                       PHA
000000r 1                       PHX
000000r 1                       LDX     #$01
000000r 1                       LDA     <PARM1,X
000000r 1                       CMP     #$00
000000r 1                       BNE     *+6
000000r 1                       LDX     #00
000000r 1                       PHX
000000r 1                       PLB
000000r 1                       PLX
000000r 1                       LDA     (<PARM1),Y      ;
000000r 1                       STA     <TMPFLG
000000r 1                       PLA
000000r 1                       PLB
000000r 1                       CMP     <TMPFLG         ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ADCINDIRECTY  PARM1
000000r 1                       PHB
000000r 1                       PHA
000000r 1                       PHX
000000r 1                       LDX     #$01
000000r 1                       LDA     <PARM1,X
000000r 1                       CMP     #$00
000000r 1                       BNE     *+6
000000r 1                       LDX     #00
000000r 1                       PHX
000000r 1                       PLB
000000r 1                       PLX
000000r 1                       LDA     (<PARM1),Y      ;
000000r 1                       STA     <TMPFLG
000000r 1                       PLA
000000r 1                       PLB
000000r 1                       CLC
000000r 1                       ADC     <TMPFLG         ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBEQ  PARM1
000000r 1                       BNE     *+5
000000r 1                       JMP     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBNE PARM1
000000r 1                       BEQ     *+5
000000r 1                       JMP     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBCC  PARM1
000000r 1                       BCC     *+4
000000r 1                       BRA     *+5
000000r 1                       JMP     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBCS PARM1
000000r 1                       BCS     *+4
000000r 1                       BRA     *+5
000000r 1                       JMP     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .ELSE
000000r 1               
000000r 1                       .MACRO  LDAINDIRECTY PARM1
000000r 1                       LDA     (PARM1),Y       ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  STAINDIRECTY PARM1
000000r 1                       STA     (PARM1),Y       ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  FETCHINDIRECTY PARM1
000000r 1                       LDA     (PARM1),Y       ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  CMPINDIRECTY  PARM1
000000r 1                       CMP     (<PARM1),Y      ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  ADCINDIRECTY  PARM1
000000r 1                       ADC     (PARM1),Y       ;
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBEQ  PARM1
000000r 1                       BEQ     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBNE  PARM1
000000r 1                       BNE     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBCC  PARM1
000000r 1                       BCC     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO  LBCS PARM1
000000r 1                       BCS     PARM1
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .ENDIF
000000r 1               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.23
000000r 1               ; THIS WORK IS DERIVED FROM ehBASIC BY LEE DAVIDSON
000000r 1               ;
000000r 1               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 1               
000000r 1               ; 2.00	new revision numbers start here
000000r 1               ; 2.01	fixed LCASE$() and UCASE$()
000000r 1               ; 2.02	new get value routine done
000000r 1               ; 2.03	changed RND() to galoise method
000000r 1               ; 2.04	fixed SPC()
000000r 1               ; 2.05	new get value routine fixedf
000000r 1               ; 2.06	changed USR() code
000000r 1               ; 2.07	fixed STR$()
000000r 1               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 1               ; 2.09	fixed RND()
000000r 1               ; 2.10	integrated missed changes from an earlier version
000000r 1               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 1               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 1               ; 2.22	fixed RND() breaking the get byte routine
000000r 1               ; 2.23  ADDED "KILL" COMMAND TO RETURN TO DOS/65
000000r 1               
000000r 1               ; zero page use ..
000000r 1               
000000r 1               LAB_WARM        = $00           ; BASIC warm start entry point
000000r 1               Wrmjpl          = LAB_WARM+1    ; BASIC warm start vector jump low byte
000000r 1               Wrmjph          = LAB_WARM+2    ; BASIC warm start vector jump high byte
000000r 1               TMPFLG          = $04
000000r 1               Usrjmp          = $0A           ; USR function JMP address
000000r 1               Usrjpl          = Usrjmp+1      ; USR function JMP vector low byte
000000r 1               Usrjph          = Usrjmp+2      ; USR function JMP vector high byte
000000r 1               Nullct          = $0D           ; nulls output after each line
000000r 1               TPos            = $0E           ; BASIC terminal position byte
000000r 1               TWidth          = $0F           ; BASIC terminal width byte
000000r 1               Iclim           = $10           ; input column limit
000000r 1               Itempl          = $11           ; temporary integer low byte
000000r 1               Itemph          = Itempl+1      ; temporary integer high byte
000000r 1               
000000r 1               nums_1          = Itempl        ; number to bin/hex string convert MSB
000000r 1               nums_2          = nums_1+1      ; number to bin/hex string convert
000000r 1               nums_3          = nums_1+2      ; number to bin/hex string convert LSB
000000r 1               
000000r 1               Srchc           = $5B           ; search character
000000r 1               Temp3           = Srchc         ; temp byte used in number routines
000000r 1               Scnquo          = $5C           ; scan-between-quotes flag
000000r 1               Asrch           = Scnquo        ; alt search character
000000r 1               
000000r 1               XOAw_l          = Srchc         ; eXclusive OR, OR and AND word low byte
000000r 1               XOAw_h          = Scnquo        ; eXclusive OR, OR and AND word high byte
000000r 1               
000000r 1               Ibptr           = $5D           ; input buffer pointer
000000r 1               Dimcnt          = Ibptr         ; # of dimensions
000000r 1               Tindx           = Ibptr         ; token index
000000r 1               
000000r 1               Defdim          = $5E           ; default DIM flag
000000r 1               Dtypef          = $5F           ; data type flag, $FF=string, $00=numeric
000000r 1               Oquote          = $60           ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 1               Gclctd          = $60           ; garbage collected flag
000000r 1               Sufnxf          = $61           ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 1               Imode           = $62           ; input mode flag, $00=INPUT, $80=READ
000000r 1               
000000r 1               Cflag           = $63           ; comparison evaluation flag
000000r 1               
000000r 1               TabSiz          = $64           ; TAB step size (was input flag)
000000r 1               
000000r 1               next_s          = $65           ; next descriptor stack address
000000r 1               
000000r 1               ; these two bytes form a word pointer to the item
000000r 1               ; currently on top of the descriptor stack
000000r 1               last_sl         = $66           ; last descriptor stack address low byte
000000r 1               last_sh         = $67           ; last descriptor stack address high byte (always $00)
000000r 1               
000000r 1               des_sk          = $68           ; descriptor stack start address (temp strings)
000000r 1               
000000r 1               ;			= $70		; End of descriptor stack
000000r 1               
000000r 1               ut1_pl          = $71           ; utility pointer 1 low byte
000000r 1               ut1_ph          = ut1_pl+1      ; utility pointer 1 high byte
000000r 1               ut2_pl          = $73           ; utility pointer 2 low byte
000000r 1               ut2_ph          = ut2_pl+1      ; utility pointer 2 high byte
000000r 1               
000000r 1               Temp_2          = ut1_pl        ; temp byte for block move
000000r 1               
000000r 1               FACt_1          = $75           ; FAC temp mantissa1
000000r 1               FACt_2          = FACt_1+1      ; FAC temp mantissa2
000000r 1               FACt_3          = FACt_2+1      ; FAC temp mantissa3
000000r 1               
000000r 1               dims_l          = FACt_2        ; array dimension size low byte
000000r 1               dims_h          = FACt_3        ; array dimension size high byte
000000r 1               
000000r 1               TempB           = $78           ; temp page 0 byte
000000r 1               
000000r 1               Smeml           = $79           ; start of mem low byte		(Start-of-Basic)
000000r 1               Smemh           = Smeml+1       ; start of mem high byte	(Start-of-Basic)
000000r 1               Svarl           = $7B           ; start of vars low byte	(Start-of-Variables)
000000r 1               Svarh           = Svarl+1       ; start of vars high byte	(Start-of-Variables)
000000r 1               Sarryl          = $7D           ; var mem end low byte		(Start-of-Arrays)
000000r 1               Sarryh          = Sarryl+1      ; var mem end high byte		(Start-of-Arrays)
000000r 1               Earryl          = $7F           ; array mem end low byte	(End-of-Arrays)
000000r 1               Earryh          = Earryl+1      ; array mem end high byte	(End-of-Arrays)
000000r 1               Sstorl          = $81           ; string storage low byte	(String storage (moving down))
000000r 1               Sstorh          = Sstorl+1      ; string storage high byte	(String storage (moving down))
000000r 1               Sutill          = $83           ; string utility ptr low byte
000000r 1               Sutilh          = Sutill+1      ; string utility ptr high byte
000000r 1               Ememl           = $85           ; end of mem low byte		(Limit-of-memory)
000000r 1               Ememh           = Ememl+1       ; end of mem high byte		(Limit-of-memory)
000000r 1               Clinel          = $87           ; current line low byte		(Basic line number)
000000r 1               Clineh          = Clinel+1      ; current line high byte	(Basic line number)
000000r 1               Blinel          = $89           ; break line low byte		(Previous Basic line number)
000000r 1               Blineh          = Blinel+1      ; break line high byte		(Previous Basic line number)
000000r 1               
000000r 1               Cpntrl          = $8B           ; continue pointer low byte
000000r 1               Cpntrh          = Cpntrl+1      ; continue pointer high byte
000000r 1               
000000r 1               Dlinel          = $8D           ; current DATA line low byte
000000r 1               Dlineh          = Dlinel+1      ; current DATA line high byte
000000r 1               
000000r 1               Dptrl           = $8F           ; DATA pointer low byte
000000r 1               Dptrh           = Dptrl+1       ; DATA pointer high byte
000000r 1               
000000r 1               Rdptrl          = $91           ; read pointer low byte
000000r 1               Rdptrh          = Rdptrl+1      ; read pointer high byte
000000r 1               
000000r 1               Varnm1          = $93           ; current var name 1st byte
000000r 1               Varnm2          = Varnm1+1      ; current var name 2nd byte
000000r 1               
000000r 1               Cvaral          = $95           ; current var address low byte
000000r 1               Cvarah          = Cvaral+1      ; current var address high byte
000000r 1               
000000r 1               Frnxtl          = $97           ; var pointer for FOR/NEXT low byte
000000r 1               Frnxth          = Frnxtl+1      ; var pointer for FOR/NEXT high byte
000000r 1               
000000r 1               Tidx1           = Frnxtl        ; temp line index
000000r 1               
000000r 1               Lvarpl          = Frnxtl        ; let var pointer low byte
000000r 1               Lvarph          = Frnxth        ; let var pointer high byte
000000r 1               
000000r 1               prstk           = $99           ; precedence stacked flag
000000r 1               
000000r 1               comp_f          = $9B           ; compare function flag, bits 0,1 and 2 used
000000r 1               ; bit 2 set if >
000000r 1               ; bit 1 set if =
000000r 1               ; bit 0 set if <
000000r 1               
000000r 1               func_l          = $9C           ; function pointer low byte
000000r 1               func_h          = func_l+1      ; function pointer high byte
000000r 1               
000000r 1               garb_l          = func_l        ; garbage collection working pointer low byte
000000r 1               garb_h          = func_h        ; garbage collection working pointer high byte
000000r 1               
000000r 1               des_2l          = $9E           ; string descriptor_2 pointer low byte
000000r 1               des_2h          = des_2l+1      ; string descriptor_2 pointer high byte
000000r 1               
000000r 1               g_step          = $A0           ; garbage collect step size
000000r 1               
000000r 1               Fnxjmp          = $A1           ; jump vector for functions
000000r 1               Fnxjpl          = Fnxjmp+1      ; functions jump vector low byte
000000r 1               Fnxjph          = Fnxjmp+2      ; functions jump vector high byte
000000r 1               
000000r 1               g_indx          = Fnxjpl        ; garbage collect temp index
000000r 1               
000000r 1               FAC2_r          = $A3           ; FAC2 rounding byte
000000r 1               
000000r 1               Adatal          = $A4           ; array data pointer low byte
000000r 1               Adatah          = Adatal+1      ; array data pointer high  byte
000000r 1               
000000r 1               Nbendl          = Adatal        ; new block end pointer low byte
000000r 1               Nbendh          = Adatah        ; new block end pointer high  byte
000000r 1               
000000r 1               Obendl          = $A6           ; old block end pointer low byte
000000r 1               Obendh          = Obendl+1      ; old block end pointer high  byte
000000r 1               
000000r 1               numexp          = $A8           ; string to float number exponent count
000000r 1               expcnt          = $A9           ; string to float exponent count
000000r 1               
000000r 1               numbit          = numexp        ; bit count for array element calculations
000000r 1               
000000r 1               numdpf          = $AA           ; string to float decimal point flag
000000r 1               expneg          = $AB           ; string to float eval exponent -ve flag
000000r 1               
000000r 1               Astrtl          = numdpf        ; array start pointer low byte
000000r 1               Astrth          = expneg        ; array start pointer high  byte
000000r 1               
000000r 1               Histrl          = numdpf        ; highest string low byte
000000r 1               Histrh          = expneg        ; highest string high  byte
000000r 1               
000000r 1               Baslnl          = numdpf        ; BASIC search line pointer low byte
000000r 1               Baslnh          = expneg        ; BASIC search line pointer high  byte
000000r 1               
000000r 1               Fvar_l          = numdpf        ; find/found variable pointer low byte
000000r 1               Fvar_h          = expneg        ; find/found variable pointer high  byte
000000r 1               
000000r 1               Ostrtl          = numdpf        ; old block start pointer low byte
000000r 1               Ostrth          = expneg        ; old block start pointer high  byte
000000r 1               
000000r 1               Vrschl          = numdpf        ; variable search pointer low byte
000000r 1               Vrschh          = expneg        ; variable search pointer high  byte
000000r 1               
000000r 1               FAC1_e          = $AC           ; FAC1 exponent
000000r 1               FAC1_1          = FAC1_e+1      ; FAC1 mantissa1
000000r 1               FAC1_2          = FAC1_e+2      ; FAC1 mantissa2
000000r 1               FAC1_3          = FAC1_e+3      ; FAC1 mantissa3
000000r 1               FAC1_s          = FAC1_e+4      ; FAC1 sign (b7)
000000r 1               
000000r 1               str_ln          = FAC1_e        ; string length
000000r 1               str_pl          = FAC1_1        ; string pointer low byte
000000r 1               str_ph          = FAC1_2        ; string pointer high byte
000000r 1               
000000r 1               des_pl          = FAC1_2        ; string descriptor pointer low byte
000000r 1               des_ph          = FAC1_3        ; string descriptor pointer high byte
000000r 1               
000000r 1               mids_l          = FAC1_3        ; MID$ string temp length byte
000000r 1               
000000r 1               negnum          = $B1           ; string to float eval -ve flag
000000r 1               numcon          = $B1           ; series evaluation constant count
000000r 1               
000000r 1               FAC1_o          = $B2           ; FAC1 overflow byte
000000r 1               
000000r 1               FAC2_e          = $B3           ; FAC2 exponent
000000r 1               FAC2_1          = FAC2_e+1      ; FAC2 mantissa1
000000r 1               FAC2_2          = FAC2_e+2      ; FAC2 mantissa2
000000r 1               FAC2_3          = FAC2_e+3      ; FAC2 mantissa3
000000r 1               FAC2_s          = FAC2_e+4      ; FAC2 sign (b7)
000000r 1               
000000r 1               FAC_sc          = $B8           ; FAC sign comparison, Acc#1 vs #2
000000r 1               FAC1_r          = $B9           ; FAC1 rounding byte
000000r 1               
000000r 1               ssptr_l         = FAC_sc        ; string start pointer low byte
000000r 1               ssptr_h         = FAC1_r        ; string start pointer high byte
000000r 1               
000000r 1               sdescr          = FAC_sc        ; string descriptor pointer
000000r 1               
000000r 1               csidx           = $BA           ; line crunch save index
000000r 1               Asptl           = csidx         ; array size/pointer low byte
000000r 1               Aspth           = $BB           ; array size/pointer high byte
000000r 1               
000000r 1               Btmpl           = Asptl         ; BASIC pointer temp low byte
000000r 1               Btmph           = Aspth         ; BASIC pointer temp low byte
000000r 1               
000000r 1               Cptrl           = Asptl         ; BASIC pointer temp low byte
000000r 1               Cptrh           = Aspth         ; BASIC pointer temp low byte
000000r 1               
000000r 1               Sendl           = Asptl         ; BASIC pointer temp low byte
000000r 1               Sendh           = Aspth         ; BASIC pointer temp low byte
000000r 1               
000000r 1               LAB_IGBY        = $BC           ; get next BASIC byte subroutine
000000r 1               
000000r 1               LAB_GBYT        = $C2           ; get current BASIC byte subroutine
000000r 1               Bpntrl          = $C3           ; BASIC execute (get byte) pointer low byte
000000r 1               Bpntrh          = Bpntrl+1      ; BASIC execute (get byte) pointer high byte
000000r 1               Bpntrp          = Bpntrl+2      ; BASIC execute (get byte) pointer PAGE byte
000000r 1               ;			= $E0		; end of get BASIC char subroutine
000000r 1               Rbyte4          = $E1           ; extra PRNG byte
000000r 1               Rbyte1          = Rbyte4+1      ; most significant PRNG byte
000000r 1               Rbyte2          = Rbyte4+2      ; middle PRNG byte
000000r 1               Rbyte3          = <Rbyte4+3     ; least significant PRNG byte
000000r 1               NmiBase         = $E5           ; NMI handler enabled/setup/triggered flags
000000r 1               ; bit	function
000000r 1               ; ===	========
000000r 1               ; 7	interrupt enabled
000000r 1               ; 6	interrupt setup
000000r 1               ; 5	interrupt happened
000000r 1               ;			= $E6		; NMI handler addr low byte
000000r 1               ;			= $E7		; NMI handler addr high byte
000000r 1               IrqBase         = $E8           ; IRQ handler enabled/setup/triggered flags
000000r 1               ;			= $E9		; IRQ handler addr low byte
000000r 1               ;			= $EA		; IRQ handler addr high byte
000000r 1               FCBPTR          = $EB           ; POINTER TO FCB FOR FILE OPS
000000r 1               Decss           = $EF           ; number to decimal string start
000000r 1               Decssp1         = Decss+1       ; number to decimal string start
000000r 1               TEMPW           = $FD
000000r 1               ;			= $FF		; decimal string end
000000r 1               
000000r 1                       .IFDEF  DUODYNE
000000r 1               STACK_BOTTOM    = $4000         ; stack bottom, no offset
000000r 1               STACK           = $5FFF         ; stack top, no offset
000000r 1                       .ENDIF
000000r 1               
000000r 1               ; token values needed for BASIC
000000r 1               
000000r 1               ; primary command tokens (can start a statement)
000000r 1               
000000r 1               TK_END          = $80           ; END token
000000r 1               TK_FOR          = TK_END+1      ; FOR token
000000r 1               TK_NEXT         = TK_FOR+1      ; NEXT token
000000r 1               TK_DATA         = TK_NEXT+1     ; DATA token
000000r 1               TK_INPUT        = TK_DATA+1     ; INPUT token
000000r 1               TK_DIM          = TK_INPUT+1    ; DIM token
000000r 1               TK_READ         = TK_DIM+1      ; READ token
000000r 1               TK_LET          = TK_READ+1     ; LET token
000000r 1               TK_DEC          = TK_LET+1      ; DEC token
000000r 1               TK_GOTO         = TK_DEC+1      ; GOTO token
000000r 1               TK_RUN          = TK_GOTO+1     ; RUN token
000000r 1               TK_IF           = TK_RUN+1      ; IF token
000000r 1               TK_RESTORE      = TK_IF+1       ; RESTORE token
000000r 1               TK_GOSUB        = TK_RESTORE+1  ; GOSUB token
000000r 1               TK_RETIRQ       = TK_GOSUB+1    ; RETIRQ token
000000r 1               TK_RETNMI       = TK_RETIRQ+1   ; RETNMI token
000000r 1               TK_RETURN       = TK_RETNMI+1   ; RETURN token
000000r 1               TK_REM          = TK_RETURN+1   ; REM token
000000r 1               TK_STOP         = TK_REM+1      ; STOP token
000000r 1               TK_ON           = TK_STOP+1     ; ON token
000000r 1               TK_NULL         = TK_ON+1       ; NULL token
000000r 1               TK_INC          = TK_NULL+1     ; INC token
000000r 1               TK_WAIT         = TK_INC+1      ; WAIT token
000000r 1               TK_LOAD         = TK_WAIT+1     ; LOAD token
000000r 1               TK_SAVE         = TK_LOAD+1     ; SAVE token
000000r 1               TK_DEF          = TK_SAVE+1     ; DEF token
000000r 1               TK_POKE         = TK_DEF+1      ; POKE token
000000r 1               TK_DOKE         = TK_POKE+1     ; DOKE token
000000r 1               TK_CALL         = TK_DOKE+1     ; CALL token
000000r 1               TK_DO           = TK_CALL+1     ; DO token
000000r 1               TK_LOOP         = TK_DO+1       ; LOOP token
000000r 1               TK_PRINT        = TK_LOOP+1     ; PRINT token
000000r 1               TK_CONT         = TK_PRINT+1    ; CONT token
000000r 1               TK_LIST         = TK_CONT+1     ; LIST token
000000r 1               TK_CLEAR        = TK_LIST+1     ; CLEAR token
000000r 1               TK_NEW          = TK_CLEAR+1    ; NEW token
000000r 1               TK_WIDTH        = TK_NEW+1      ; WIDTH token
000000r 1               TK_GET          = TK_WIDTH+1    ; GET token
000000r 1               TK_SWAP         = TK_GET+1      ; SWAP token
000000r 1               TK_BITSET       = TK_SWAP+1     ; BITSET token
000000r 1               TK_BITCLR       = TK_BITSET+1   ; BITCLR token
000000r 1               TK_IRQ          = TK_BITCLR+1   ; IRQ token
000000r 1               TK_NMI          = TK_IRQ+1      ; NMI token
000000r 1               TK_KILL         = TK_NMI+1      ; NMI token
000000r 1               
000000r 1               ; secondary command tokens, can't start a statement
000000r 1               
000000r 1               TK_TAB          = TK_KILL+1     ; TAB token
000000r 1               TK_ELSE         = TK_TAB+1      ; ELSE token
000000r 1               TK_TO           = TK_ELSE+1     ; TO token
000000r 1               TK_FN           = TK_TO+1       ; FN token
000000r 1               TK_SPC          = TK_FN+1       ; SPC token
000000r 1               TK_THEN         = TK_SPC+1      ; THEN token
000000r 1               TK_NOT          = TK_THEN+1     ; NOT token
000000r 1               TK_STEP         = TK_NOT+1      ; STEP token
000000r 1               TK_UNTIL        = TK_STEP+1     ; UNTIL token
000000r 1               TK_WHILE        = TK_UNTIL+1    ; WHILE token
000000r 1               TK_OFF          = TK_WHILE+1    ; OFF token
000000r 1               
000000r 1               ; opperator tokens
000000r 1               
000000r 1               TK_PLUS         = TK_OFF+1      ; + token
000000r 1               TK_MINUS        = TK_PLUS+1     ; - token
000000r 1               TK_MUL          = TK_MINUS+1    ; * token
000000r 1               TK_DIV          = TK_MUL+1      ; / token
000000r 1               TK_POWER        = TK_DIV+1      ; ^ token
000000r 1               TK_AND          = TK_POWER+1    ; AND token
000000r 1               TK_EOR          = TK_AND+1      ; EOR token
000000r 1               TK_OR           = TK_EOR+1      ; OR token
000000r 1               TK_RSHIFT       = TK_OR+1       ; RSHIFT token
000000r 1               TK_LSHIFT       = TK_RSHIFT+1   ; LSHIFT token
000000r 1               TK_GT           = TK_LSHIFT+1   ; > token
000000r 1               TK_EQUAL        = TK_GT+1       ; = token
000000r 1               TK_LT           = TK_EQUAL+1    ; < token
000000r 1               
000000r 1               ; functions tokens
000000r 1               
000000r 1               TK_SGN          = TK_LT+1       ; SGN token
000000r 1               TK_INT          = TK_SGN+1      ; INT token
000000r 1               TK_ABS          = TK_INT+1      ; ABS token
000000r 1               TK_USR          = TK_ABS+1      ; USR token
000000r 1               TK_FRE          = TK_USR+1      ; FRE token
000000r 1               TK_POS          = TK_FRE+1      ; POS token
000000r 1               TK_SQR          = TK_POS+1      ; SQR token
000000r 1               TK_RND          = TK_SQR+1      ; RND token
000000r 1               TK_LOG          = TK_RND+1      ; LOG token
000000r 1               TK_EXP          = TK_LOG+1      ; EXP token
000000r 1               TK_COS          = TK_EXP+1      ; COS token
000000r 1               TK_SIN          = TK_COS+1      ; SIN token
000000r 1               TK_TAN          = TK_SIN+1      ; TAN token
000000r 1               TK_ATN          = TK_TAN+1      ; ATN token
000000r 1               TK_PEEK         = TK_ATN+1      ; PEEK token
000000r 1               TK_DEEK         = TK_PEEK+1     ; DEEK token
000000r 1               TK_SADD         = TK_DEEK+1     ; SADD token
000000r 1               TK_LEN          = TK_SADD+1     ; LEN token
000000r 1               TK_STRS         = TK_LEN+1      ; STR$ token
000000r 1               TK_VAL          = TK_STRS+1     ; VAL token
000000r 1               TK_ASC          = TK_VAL+1      ; ASC token
000000r 1               TK_UCASES       = TK_ASC+1      ; UCASE$ token
000000r 1               TK_LCASES       = TK_UCASES+1   ; LCASE$ token
000000r 1               TK_CHRS         = TK_LCASES+1   ; CHR$ token
000000r 1               TK_HEXS         = TK_CHRS+1     ; HEX$ token
000000r 1               TK_BINS         = TK_HEXS+1     ; BIN$ token
000000r 1               TK_BITTST       = TK_BINS+1     ; BITTST token
000000r 1               TK_MAX          = TK_BITTST+1   ; MAX token
000000r 1               TK_MIN          = TK_MAX+1      ; MIN token
000000r 1               TK_PI           = TK_MIN+1      ; PI token
000000r 1               TK_TWOPI        = TK_PI+1       ; TWOPI token
000000r 1               TK_VPTR         = TK_TWOPI+1    ; VARPTR token
000000r 1               TK_LEFTS        = TK_VPTR+1     ; LEFT$ token
000000r 1               TK_RIGHTS       = TK_LEFTS+1    ; RIGHT$ token
000000r 1               TK_MIDS         = TK_RIGHTS+1   ; MID$ token
000000r 1               
000000r 1               ; offsets from a base of X or Y
000000r 1               
000000r 1               PLUS_0          = $00           ; X or Y plus 0
000000r 1               PLUS_1          = $01           ; X or Y plus 1
000000r 1               PLUS_2          = $02           ; X or Y plus 2
000000r 1               PLUS_3          = $03           ; X or Y plus 3
000000r 1               
000000r 1               LAB_STAK        = $0100         ; stack bottom, no offset
000000r 1               
000000r 1               LAB_SKFE        = LAB_STAK+$FE
000000r 1               ; flushed stack address
000000r 1               LAB_SKFF        = LAB_STAK+$FF
000000r 1               ; flushed stack address
000000r 1               
000000r 1               ccflag          = $0600         ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 1               ccbyte          = ccflag+1      ; BASIC CTRL-C byte
000000r 1               ccnull          = ccbyte+1      ; BASIC CTRL-C byte timeout
000000r 1               
000000r 1               VEC_CC          = ccnull+1      ; ctrl c check vector
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; This start can be changed to suit your system (TEA START)
000000r 1               
000000r 1                       .FEATURE labels_without_colons
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1               
000800  1               BASICBEGIN:
000800  1  AD 04 01             LDA     $0104
000803  1  8D 94 3D             STA     PEMVEC
000806  1  AD 05 01             LDA     $0105
000809  1  8D 95 3D             STA     PEMVEC+1
00080C  1               
00080C  1               
00080C  1               LAB_COLD:
00080C  1  A0 04                LDY     #PG2_TABE-PG2_TABS-1
00080E  1               ; byte count-1
00080E  1               LAB_2D13:
00080E  1  B9 1B 36             LDA     PG2_TABS,Y      ; get byte
000811  1  99 00 06             STA     ccflag,Y        ; store in page 2
000814  1  88                   DEY                     ; decrement count
000815  1  10 F7                BPL     LAB_2D13        ; loop if not done
000817  1               
000817  1  A2 FF                LDX     #$FF            ; set byte
000819  1  86 88                STX     Clineh          ; set current line high byte (set immediate mode)
00081B  1               
00081B  1  A9 4C                LDA     #$4C            ; code for JMP
00081D  1  85 A1                STA     Fnxjmp          ; save for jump vector for functions
00081F  1               
00081F  1               ; copy block from LAB_2CEE to $00BC - $00D3
00081F  1               
00081F  1  A0 1D                LDY     #StrTab-LAB_2CEE; set byte count
000821  1               LAB_2D4E:
000821  1  BE 1F 36             LDX     LAB_2CEE-1,Y    ; get byte from table
000824  1  96 BB                STX     LAB_IGBY-1,Y    ; save byte in page zero
000826  1  88                   DEY                     ; decrement count
000827  1  D0 F8                BNE     LAB_2D4E        ; loop if not all done
000829  1               
000829  1               ; copy block from StrTab to $0000 - $0012
000829  1               
000829  1               LAB_GMEM:
000829  1  A0 12                LDY     #EndTab-StrTab-1; set byte count-1
00082B  1               TabLoop:
00082B  1  BE 3D 36             LDX     StrTab,Y        ; get byte from table
00082E  1  96 00                STX     PLUS_0,Y        ; save byte in page zero
000830  1  88                   DEY                     ; decrement count
000831  1  10 F8                BPL     TabLoop         ; loop if not all done
000833  1               
000833  1               
000833  1                       .IFDEF  DUODYNE
000833  1  8B                   PHB
000834  1  68                   PLA
000835  1  85 C5                STA     Bpntrp          ; SET LAB_GBYT PAGE POINTER TO DATA BANK
000837  1                       .ELSE
000837  1                       TXS                     ; reset stack pointer
000837  1                       .ENDIF
000837  1               
000837  1               
000837  1               ; set-up start values
000837  1               
000837  1  A9 00                LDA     #$00            ; clear A
000839  1  85 E5                STA     NmiBase         ; clear NMI handler enabled flag
00083B  1  85 E8                STA     IrqBase         ; clear IRQ handler enabled flag
00083D  1  85 B2                STA     FAC1_o          ; clear FAC1 overflow byte
00083F  1  85 67                STA     last_sh         ; clear descriptor stack top item pointer high byte
000841  1               
000841  1  A9 0E                LDA     #$0E            ; set default tab size
000843  1  85 64                STA     TabSiz          ; save it
000845  1  A9 03                LDA     #$03            ; set garbage collect step size for descriptor stack
000847  1  85 A0                STA     g_step          ; save it
000849  1  A2 68                LDX     #des_sk         ; descriptor stack start
00084B  1  86 65                STX     next_s          ; set descriptor stack pointer
00084D  1  20 EC 14             JSR     LAB_CRLF        ; print CR/LF
000850  1               ;	LDA	#<LAB_MSZM		; point to memory size message (low addr)
000850  1               ;	LDY	#>LAB_MSZM		; point to memory size message (high addr)
000850  1               ;	JSR	LAB_18C3		; print null terminated string from memory
000850  1               ;	JSR	LAB_INLN		; print "? " and get BASIC input
000850  1               ;	STX	Bpntrl		; set BASIC execute pointer low byte
000850  1               ;	STY	Bpntrh		; set BASIC execute pointer high byte
000850  1               ;	JSR	LAB_GBYT		; get last byte back
000850  1               
000850  1               ;	BNE	LAB_2DAA		; branch if not null (user typed something)
000850  1               
000850  1  A0 00                LDY     #$00            ; else clear Y
000852  1               ; character was null so get memory size the hard way
000852  1               ; we get here with Y=0 and Itempl/h = Ram_base
000852  1               LAB_2D93:
000852  1  E6 11                INC     Itempl          ; increment temporary integer low byte
000854  1  D0 08                BNE     LAB_2D99        ; branch if no overflow
000856  1               
000856  1  E6 12                INC     Itemph          ; increment temporary integer high byte
000858  1  A5 12                LDA     Itemph          ; get high byte
00085A  1  C9 B8                CMP     #>Ram_top       ; compare with top of RAM+1
00085C  1  F0 63                BEQ     LAB_2DB6        ; branch if match (end of user RAM)
00085E  1               
00085E  1               LAB_2D99:
00085E  1  A9 55                LDA     #$55            ; set test byte
000860  1  8B DA 48 A2          STAINDIRECTY Itempl     ; save via temporary integer
000864  1  01 B5 11 C9  
000868  1  00 D0 04 A2  
000876  1  8B 48 DA A2          CMPINDIRECTY Itempl     ; compare via temporary integer
00087A  1  01 B5 11 C9  
00087E  1  00 D0 04 A2  
00088E  1  D0 31                BNE     LAB_2DB6        ; branch if fail
000890  1               
000890  1  0A                   ASL     A               ; shift test byte left (now $AA)
000891  1  8B DA 48 A2          STAINDIRECTY Itempl     ; save via temporary integer
000895  1  01 B5 11 C9  
000899  1  00 D0 04 A2  
0008A7  1  8B 48 DA A2          CMPINDIRECTY Itempl     ; compare via temporary integer
0008AB  1  01 B5 11 C9  
0008AF  1  00 D0 04 A2  
0008BF  1  F0 91                BEQ     LAB_2D93        ; if ok go do next byte
0008C1  1               
0008C1  1               ;	BNE	LAB_2DB6		; branch if fail
0008C1  1               
0008C1  1               ;LAB_2DAA
0008C1  1               ;	JSR	LAB_2887		; get FAC1 from string
0008C1  1               ;	LDA	FAC1_e		; get FAC1 exponent
0008C1  1               ;	CMP	#$98			; compare with exponent = 2^24
0008C1  1               ;	BCS	LAB_GMEM		; if too large go try again
0008C1  1               ;
0008C1  1               ;	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
0008C1  1               ;					; (no range check)
0008C1  1               
0008C1  1               LAB_2DB6:
0008C1  1  A5 11                LDA     Itempl          ; get temporary integer low byte
0008C3  1  A4 12                LDY     Itemph          ; get temporary integer high byte
0008C5  1  C0 01                CPY     #<Ram_base+1    ; compare with start of RAM+$100 high byte
0008C7  1  90 02 80 03          LBCC    LAB_GMEM        ; if too small go try again
0008CB  1  4C 29 08     
0008CE  1               
0008CE  1               
0008CE  1               ; uncomment these lines if you want to check on the high limit of memory. Note if
0008CE  1               ; Ram_top is set too low then this will fail. default is ignore it and assume the
0008CE  1               ; users know what they're doing!
0008CE  1               
0008CE  1               ;	CPY	#>Ram_top		; compare with top of RAM high byte
0008CE  1               ;	BCC	MEM_OK		; branch if < RAM top
0008CE  1               
0008CE  1               ;	BNE	LAB_GMEM		; if too large go try again
0008CE  1               ; else was = so compare low bytes
0008CE  1               ;	CMP	#<Ram_top		; compare with top of RAM low byte
0008CE  1               ;	BEQ	MEM_OK		; branch if = RAM top
0008CE  1               
0008CE  1               ;	BCS	LAB_GMEM		; if too large go try again
0008CE  1               
0008CE  1               ;MEM_OK
0008CE  1  85 85                STA     Ememl           ; set end of mem low byte
0008D0  1  84 86                STY     Ememh           ; set end of mem high byte
0008D2  1  85 81                STA     Sstorl          ; set bottom of string space low byte
0008D4  1  84 82                STY     Sstorh          ; set bottom of string space high byte
0008D6  1               
0008D6  1  A0 00                LDY     #<Ram_base      ; set start addr low byte
0008D8  1  A2 42                LDX     #>Ram_base      ; set start addr high byte
0008DA  1  84 79                STY     Smeml           ; save start of mem low byte
0008DC  1  86 7A                STX     Smemh           ; save start of mem high byte
0008DE  1               
0008DE  1               ; this line is only needed if Ram_base is not $xx00
0008DE  1               
0008DE  1               ;	LDY	#$00			; clear Y
0008DE  1  98                   TYA                     ; clear A
0008DF  1  8B DA 48 A2          STAINDIRECTY Smeml      ; clear first byte
0008E3  1  01 B5 79 C9  
0008E7  1  00 D0 04 A2  
0008F5  1  E6 79                INC     Smeml           ; increment start of mem low byte
0008F7  1               
0008F7  1               ; these two lines are only needed if Ram_base is $xxFF
0008F7  1               
0008F7  1               ;	BNE	LAB_2E05		; branch if no rollover
0008F7  1               
0008F7  1               ;	INC	Smemh			; increment start of mem high byte
0008F7  1               LAB_2E05:
0008F7  1  20 EC 14             JSR     LAB_CRLF        ; print CR/LF
0008FA  1  20 96 0D             JSR     LAB_1463        ; do "NEW" and "CLEAR"
0008FD  1  A5 85                LDA     Ememl           ; get end of mem low byte
0008FF  1  38                   SEC                     ; set carry for subtract
000900  1  E5 79                SBC     Smeml           ; subtract start of mem low byte
000902  1  AA                   TAX                     ; copy to X
000903  1  A5 86                LDA     Ememh           ; get end of mem high byte
000905  1  E5 7A                SBC     Smemh           ; subtract start of mem high byte
000907  1  20 36 2F             JSR     LAB_295E        ; print XA as unsigned integer (bytes free)
00090A  1  A9 5F                LDA     #<LAB_SMSG      ; point to sign-on message (low addr)
00090C  1  A0 36                LDY     #>LAB_SMSG      ; point to sign-on message (high addr)
00090E  1  20 34 15             JSR     LAB_18C3        ; print null terminated string from memory
000911  1  A9 15                LDA     #<LAB_1274      ; warm start vector low byte
000913  1  A0 0A                LDY     #>LAB_1274      ; warm start vector high byte
000915  1  85 01                STA     Wrmjpl          ; save warm start vector low byte
000917  1  84 02                STY     Wrmjph          ; save warm start vector high byte
000919  1  6C 01 00             JMP     (Wrmjpl)        ; go do warm start
00091C  1               
00091C  1               ; open up space in memory
00091C  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00091C  1               
00091C  1               ; Nbendl,Nbendh - new block end address (A/Y)
00091C  1               ; Obendl,Obendh - old block end address
00091C  1               ; Ostrtl,Ostrth - old block start address
00091C  1               
00091C  1               ; returns with ..
00091C  1               
00091C  1               ; Nbendl,Nbendh - new block start address (high byte - $100)
00091C  1               ; Obendl,Obendh - old block start address (high byte - $100)
00091C  1               ; Ostrtl,Ostrth - old block start address (unchanged)
00091C  1               
00091C  1               LAB_11CF:
00091C  1  20 C6 09             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
00091F  1               ; addr to check is in AY (low/high)
00091F  1  85 7F                STA     Earryl          ; save new array mem end low byte
000921  1  84 80                STY     Earryh          ; save new array mem end high byte
000923  1               
000923  1               ; open up space in memory
000923  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
000923  1               ; don't set array end
000923  1               
000923  1               LAB_11D6:
000923  1  38                   SEC                     ; set carry for subtract
000924  1  A5 A6                LDA     Obendl          ; get block end low byte
000926  1  E5 AA                SBC     Ostrtl          ; subtract block start low byte
000928  1  A8                   TAY                     ; copy MOD(block length/$100) byte to Y
000929  1  A5 A7                LDA     Obendh          ; get block end high byte
00092B  1  E5 AB                SBC     Ostrth          ; subtract block start high byte
00092D  1  AA                   TAX                     ; copy block length high byte to X
00092E  1  E8                   INX                     ; +1 to allow for count=0 exit
00092F  1  98                   TYA                     ; copy block length low byte to A
000930  1  F0 74                BEQ     LAB_120A        ; branch if length low byte=0
000932  1               
000932  1               ; block is (X-1)*256+Y bytes, do the Y bytes first
000932  1               
000932  1  38                   SEC                     ; set carry for add + 1, two's complement
000933  1  49 FF                EOR     #$FF            ; invert low byte for subtract
000935  1  65 A6                ADC     Obendl          ; add block end low byte
000937  1               
000937  1  85 A6                STA     Obendl          ; save corrected old block end low byte
000939  1  B0 03                BCS     LAB_11F3        ; branch if no underflow
00093B  1               
00093B  1  C6 A7                DEC     Obendh          ; else decrement block end high byte
00093D  1  38                   SEC                     ; set carry for add + 1, two's complement
00093E  1               LAB_11F3:
00093E  1  98                   TYA                     ; get MOD(block length/$100) byte
00093F  1  49 FF                EOR     #$FF            ; invert low byte for subtract
000941  1  65 A4                ADC     Nbendl          ; add destination end low byte
000943  1  85 A4                STA     Nbendl          ; save modified new block end low byte
000945  1  B0 30                BCS     LAB_1203        ; branch if no underflow
000947  1               
000947  1  C6 A5                DEC     Nbendh          ; else decrement block end high byte
000949  1  90 2C                BCC     LAB_1203        ; branch always
00094B  1               
00094B  1               LAB_11FF:
00094B  1  8B DA A2 01          LDAINDIRECTY Obendl     ; get byte from source
00094F  1  B5 A6 C9 00  
000953  1  D0 04 A2 00  
000961  1  8B DA 48 A2          STAINDIRECTY Nbendl     ; copy byte to destination
000965  1  01 B5 A4 C9  
000969  1  00 D0 04 A2  
000977  1               LAB_1203:
000977  1  88                   DEY                     ; decrement index
000978  1  D0 D1                BNE     LAB_11FF        ; loop until Y=0
00097A  1               
00097A  1               ; now do Y=0 indexed byte
00097A  1  8B DA A2 01          LDAINDIRECTY Obendl     ; get byte from source
00097E  1  B5 A6 C9 00  
000982  1  D0 04 A2 00  
000990  1  8B DA 48 A2          STAINDIRECTY Nbendl     ; save byte to destination
000994  1  01 B5 A4 C9  
000998  1  00 D0 04 A2  
0009A6  1               LAB_120A:
0009A6  1  C6 A7                DEC     Obendh          ; decrement source pointer high byte
0009A8  1  C6 A5                DEC     Nbendh          ; decrement destination pointer high byte
0009AA  1  CA                   DEX                     ; decrement block count
0009AB  1  D0 CA                BNE     LAB_1203        ; loop until count = $0
0009AD  1               
0009AD  1  60                   RTS
0009AE  1               
0009AE  1               ; check room on stack for A bytes
0009AE  1               ; stack too deep? do OM error
0009AE  1               
0009AE  1               LAB_1212:
0009AE  1                       .IFDEF  DUODYNE
0009AE  1  C2 20                ACCUMULATOR16
0009B0  1  29 FF 00             AND     #$00FF
0009B3  1  18                   CLC
0009B4  1  69 00 40             ADC     #STACK_BOTTOM
0009B7  1  85 FD                STA     <TEMPW
0009B9  1  3B                   TSC
0009BA  1  C5 FD                CMP     <TEMPW
0009BC  1  90 03                BCC     LAB_1213        ; if stack < limit do "Out of memory" error then warm start
0009BE  1  E2 20                ACCUMULATOR8
0009C0  1  60                   RTS
0009C1  1               LAB_1213:
0009C1  1  E2 20                ACCUMULATOR8
0009C3  1  4C F5 09             JMP     LAB_OMER
0009C6  1                       .ELSE
0009C6  1                       STA     TempB           ; save result in temp byte
0009C6  1                       TSX                     ; copy stack
0009C6  1                       CPX     TempB           ; compare new "limit" with stack
0009C6  1                       BCC     LAB_OMER        ; if stack < limit do "Out of memory" error then warm start
0009C6  1                       RTS
0009C6  1                       .ENDIF
0009C6  1               
0009C6  1               
0009C6  1               ; check available memory, "Out of memory" error if no room
0009C6  1               ; addr to check is in AY (low/high)
0009C6  1               
0009C6  1               LAB_121F:
0009C6  1  C4 82                CPY     Sstorh          ; compare bottom of string mem high byte
0009C8  1  90 2A                BCC     LAB_124B        ; if less then exit (is ok)
0009CA  1               
0009CA  1  D0 04                BNE     LAB_1229        ; skip next test if greater (tested <)
0009CC  1               
0009CC  1               ; high byte was =, now do low byte
0009CC  1  C5 81                CMP     Sstorl          ; compare with bottom of string mem low byte
0009CE  1  90 24                BCC     LAB_124B        ; if less then exit (is ok)
0009D0  1               
0009D0  1               ; addr is > string storage ptr (oops!)
0009D0  1               LAB_1229:
0009D0  1  48                   PHA                     ; push addr low byte
0009D1  1  A2 08                LDX     #$08            ; set index to save Adatal to expneg inclusive
0009D3  1  98                   TYA                     ; copy addr high byte (to push on stack)
0009D4  1               
0009D4  1               ; save misc numeric work area
0009D4  1               LAB_122D:
0009D4  1  48                   PHA                     ; push byte
0009D5  1  B5 A3                LDA     Adatal-1,X      ; get byte from Adatal to expneg ( ,$00 not pushed)
0009D7  1  CA                   DEX                     ; decrement index
0009D8  1  10 FA                BPL     LAB_122D        ; loop until all done
0009DA  1               
0009DA  1  20 C2 21             JSR     LAB_GARB        ; garbage collection routine
0009DD  1               
0009DD  1               ; restore misc numeric work area
0009DD  1  A2 00                LDX     #$00            ; clear the index to restore bytes
0009DF  1               LAB_1238:
0009DF  1  68                   PLA                     ; pop byte
0009E0  1  95 A4                STA     Adatal,X        ; save byte to Adatal to expneg
0009E2  1  E8                   INX                     ; increment index
0009E3  1  E0 08                CPX     #$08            ; compare with end + 1
0009E5  1  30 F8                BMI     LAB_1238        ; loop if more to do
0009E7  1               
0009E7  1  68                   PLA                     ; pop addr high byte
0009E8  1  A8                   TAY                     ; copy back to Y
0009E9  1  68                   PLA                     ; pop addr low byte
0009EA  1  C4 82                CPY     Sstorh          ; compare bottom of string mem high byte
0009EC  1  90 06                BCC     LAB_124B        ; if less then exit (is ok)
0009EE  1               
0009EE  1  D0 05                BNE     LAB_OMER        ; if greater do "Out of memory" error then warm start
0009F0  1               
0009F0  1               ; high byte was =, now do low byte
0009F0  1  C5 81                CMP     Sstorl          ; compare with bottom of string mem low byte
0009F2  1  B0 01                BCS     LAB_OMER        ; if >= do "Out of memory" error then warm start
0009F4  1               
0009F4  1               ; ok exit, carry clear
0009F4  1               LAB_124B:
0009F4  1  60                   RTS
0009F5  1               
0009F5  1               ; do "Out of memory" error then warm start
0009F5  1               
0009F5  1               LAB_OMER:
0009F5  1  A2 0C                LDX     #$0C            ; error code $0C ("Out of memory" error)
0009F7  1               
0009F7  1               ; do error #X, then warm start
0009F7  1               
0009F7  1               LAB_XERR:
0009F7  1  20 EC 14             JSR     LAB_CRLF        ; print CR/LF
0009FA  1               
0009FA  1  BD DC 3B             LDA     LAB_BAER,X      ; get error message pointer low byte
0009FD  1  BC DD 3B             LDY     LAB_BAER+1,X    ; get error message pointer high byte
000A00  1  20 34 15             JSR     LAB_18C3        ; print null terminated string from memory
000A03  1               
000A03  1  20 F7 0D             JSR     LAB_1491        ; flush stack and clear continue flag
000A06  1  A9 19                LDA     #<LAB_EMSG      ; point to " Error" low addr
000A08  1  A0 3D                LDY     #>LAB_EMSG      ; point to " Error" high addr
000A0A  1               LAB_1269:
000A0A  1  20 34 15             JSR     LAB_18C3        ; print null terminated string from memory
000A0D  1  A4 88                LDY     Clineh          ; get current line high byte
000A0F  1  C8                   INY                     ; increment it
000A10  1  F0 03                BEQ     LAB_1274        ; go do warm start (was immediate mode)
000A12  1               
000A12  1               ; else print line number
000A12  1  20 2B 2F             JSR     LAB_2953        ; print " in line [LINE #]"
000A15  1               
000A15  1               ; BASIC warm start entry point
000A15  1               ; wait for Basic command
000A15  1               
000A15  1               LAB_1274:
000A15  1               ; clear ON IRQ/NMI bytes
000A15  1  A9 00                LDA     #$00            ; clear A
000A17  1  85 E8                STA     IrqBase         ; clear enabled byte
000A19  1  85 E5                STA     NmiBase         ; clear enabled byte
000A1B  1  A9 2A                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
000A1D  1  A0 3D                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
000A1F  1               
000A1F  1  20 34 15             JSR     LAB_18C3        ; go do print string
000A22  1               
000A22  1               ; wait for Basic command (no "Ready")
000A22  1               
000A22  1               LAB_127D:
000A22  1  20 D4 0B             JSR     LAB_1357        ; call for BASIC input
000A25  1               LAB_1280:
000A25  1  86 C3                STX     Bpntrl          ; set BASIC execute pointer low byte
000A27  1  84 C4                STY     Bpntrh          ; set BASIC execute pointer high byte
000A29  1                       .IFDEF  DUODYNE
000A29  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
000A2D  1                       .ELSE
000A2D  1                       JSR     LAB_GBYT        ; scan memory
000A2D  1                       .ENDIF
000A2D  1  F0 F3                BEQ     LAB_127D        ; loop while null
000A2F  1               
000A2F  1               ; got to interpret input line now ..
000A2F  1               
000A2F  1  A2 FF                LDX     #$FF            ; current line to null value
000A31  1  86 88                STX     Clineh          ; set current line high byte
000A33  1  90 06                BCC     LAB_1295        ; branch if numeric character (handle new BASIC line)
000A35  1               
000A35  1               ; no line number .. immediate mode
000A35  1  20 03 0C             JSR     LAB_13A6        ; crunch keywords into Basic tokens
000A38  1  4C 50 10             JMP     LAB_15F6        ; go scan and interpret code
000A3B  1               
000A3B  1               ; handle new BASIC line
000A3B  1               
000A3B  1               LAB_1295:
000A3B  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
000A3E  1  20 03 0C             JSR     LAB_13A6        ; crunch keywords into Basic tokens
000A41  1  84 5D                STY     Ibptr           ; save index pointer to end of crunched line
000A43  1  20 01 0D             JSR     LAB_SSLN        ; search BASIC for temp integer line number
000A46  1  90 6C                BCC     LAB_12E6        ; branch if not found
000A48  1               
000A48  1               ; aroooogah! line # already exists! delete it
000A48  1  A0 01                LDY     #$01            ; set index to next line pointer high byte
000A4A  1  B1 AA                LDA     (Baslnl),Y      ; get next line pointer high byte
000A4C  1  85 72                STA     ut1_ph          ; save it
000A4E  1  A5 7B                LDA     Svarl           ; get start of vars low byte
000A50  1  85 71                STA     ut1_pl          ; save it
000A52  1  A5 AB                LDA     Baslnh          ; get found line pointer high byte
000A54  1  85 74                STA     ut2_ph          ; save it
000A56  1  A5 AA                LDA     Baslnl          ; get found line pointer low byte
000A58  1  88                   DEY                     ; decrement index
000A59  1  F1 AA                SBC     (Baslnl),Y      ; subtract next line pointer low byte
000A5B  1  18                   CLC                     ; clear carry for add
000A5C  1  65 7B                ADC     Svarl           ; add start of vars low byte
000A5E  1  85 7B                STA     Svarl           ; save new start of vars low byte
000A60  1  85 73                STA     ut2_pl          ; save destination pointer low byte
000A62  1  A5 7C                LDA     Svarh           ; get start of vars high byte
000A64  1  69 FF                ADC     #$FF            ; -1 + carry
000A66  1  85 7C                STA     Svarh           ; save start of vars high byte
000A68  1  E5 AB                SBC     Baslnh          ; subtract found line pointer high byte
000A6A  1  AA                   TAX                     ; copy to block count
000A6B  1  38                   SEC                     ; set carry for subtract
000A6C  1  A5 AA                LDA     Baslnl          ; get found line pointer low byte
000A6E  1  E5 7B                SBC     Svarl           ; subtract start of vars low byte
000A70  1  A8                   TAY                     ; copy to bytes in first block count
000A71  1  B0 03                BCS     LAB_12D0        ; branch if overflow
000A73  1               
000A73  1  E8                   INX                     ; increment block count (correct for =0 loop exit)
000A74  1  C6 74                DEC     ut2_ph          ; decrement destination high byte
000A76  1               LAB_12D0:
000A76  1  18                   CLC                     ; clear carry for add
000A77  1  65 71                ADC     ut1_pl          ; add source pointer low byte
000A79  1  90 03                BCC     LAB_12D8        ; branch if no overflow
000A7B  1               
000A7B  1  C6 72                DEC     ut1_ph          ; else decrement source pointer high byte
000A7D  1  18                   CLC                     ; clear carry
000A7E  1               
000A7E  1               ; close up memory to delete old line
000A7E  1               LAB_12D8:
000A7E  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte from source
000A82  1  B5 71 C9 00  
000A86  1  D0 04 A2 00  
000A94  1  8B DA 48 A2          STAINDIRECTY ut2_pl     ; copy to destination
000A98  1  01 B5 73 C9  
000A9C  1  00 D0 04 A2  
000AAA  1  C8                   INY                     ; increment index
000AAB  1  D0 D1                BNE     LAB_12D8        ; while <> 0 do this block
000AAD  1               
000AAD  1  E6 72                INC     ut1_ph          ; increment source pointer high byte
000AAF  1  E6 74                INC     ut2_ph          ; increment destination pointer high byte
000AB1  1  CA                   DEX                     ; decrement block count
000AB2  1  D0 CA                BNE     LAB_12D8        ; loop until all done
000AB4  1               
000AB4  1               ; got new line in buffer and no existing same #
000AB4  1               LAB_12E6:
000AB4  1  AD 81 41             LDA     Ibuffs          ; get byte from start of input buffer
000AB7  1  D0 03 4C 4B          LBEQ    LAB_1319        ; if null line just go flush stack/vars and exit
000ABB  1  0B           
000ABC  1               
000ABC  1               ; got new line and it isn't empty line
000ABC  1  A5 85                LDA     Ememl           ; get end of mem low byte
000ABE  1  A4 86                LDY     Ememh           ; get end of mem high byte
000AC0  1  85 81                STA     Sstorl          ; set bottom of string space low byte
000AC2  1  84 82                STY     Sstorh          ; set bottom of string space high byte
000AC4  1  A5 7B                LDA     Svarl           ; get start of vars low byte	(end of BASIC)
000AC6  1  85 A6                STA     Obendl          ; save old block end low byte
000AC8  1  A4 7C                LDY     Svarh           ; get start of vars high byte	(end of BASIC)
000ACA  1  84 A7                STY     Obendh          ; save old block end high byte
000ACC  1  65 5D                ADC     Ibptr           ; add input buffer pointer	(also buffer length)
000ACE  1  90 01                BCC     LAB_1301        ; branch if no overflow from add
000AD0  1               
000AD0  1  C8                   INY                     ; else increment high byte
000AD1  1               LAB_1301:
000AD1  1  85 A4                STA     Nbendl          ; save new block end low byte	(move to, low byte)
000AD3  1  84 A5                STY     Nbendh          ; save new block end high byte
000AD5  1  20 1C 09             JSR     LAB_11CF        ; open up space in memory
000AD8  1               ; old start pointer Ostrtl,Ostrth set by the find line call
000AD8  1  A5 7F                LDA     Earryl          ; get array mem end low byte
000ADA  1  A4 80                LDY     Earryh          ; get array mem end high byte
000ADC  1  85 7B                STA     Svarl           ; save start of vars low byte
000ADE  1  84 7C                STY     Svarh           ; save start of vars high byte
000AE0  1  A4 5D                LDY     Ibptr           ; get input buffer pointer	(also buffer length)
000AE2  1  88                   DEY                     ; adjust for loop type
000AE3  1               LAB_1311:
000AE3  1  B9 7D 41             LDA     Ibuffs-4,Y      ; get byte from crunched line
000AE6  1  8B DA 48 A2          STAINDIRECTY Baslnl     ; save it to program memory
000AEA  1  01 B5 AA C9  
000AEE  1  00 D0 04 A2  
000AFC  1  88                   DEY                     ; decrement count
000AFD  1  C0 03                CPY     #$03            ; compare with first byte-1
000AFF  1  D0 E2                BNE     LAB_1311        ; continue while count <> 3
000B01  1               
000B01  1  A5 12                LDA     Itemph          ; get line # high byte
000B03  1  8B DA 48 A2          STAINDIRECTY Baslnl     ; save it to program memory
000B07  1  01 B5 AA C9  
000B0B  1  00 D0 04 A2  
000B19  1  88                   DEY                     ; decrement count
000B1A  1  A5 11                LDA     Itempl          ; get line # low byte
000B1C  1  8B DA 48 A2          STAINDIRECTY Baslnl     ; save it to program memory
000B20  1  01 B5 AA C9  
000B24  1  00 D0 04 A2  
000B32  1  88                   DEY                     ; decrement count
000B33  1  A9 FF                LDA     #$FF            ; set byte to allow chain rebuild. if you didn't set this
000B35  1               ; byte then a zero already here would stop the chain rebuild
000B35  1               ; as it would think it was the [EOT] marker.
000B35  1  8B DA 48 A2          STAINDIRECTY Baslnl     ; save it to program memory
000B39  1  01 B5 AA C9  
000B3D  1  00 D0 04 A2  
000B4B  1               
000B4B  1               LAB_1319:
000B4B  1  20 D3 0D             JSR     LAB_1477        ; reset execution to start, clear vars and flush stack
000B4E  1  A6 79                LDX     Smeml           ; get start of mem low byte
000B50  1  A5 7A                LDA     Smemh           ; get start of mem high byte
000B52  1  A0 01                LDY     #$01            ; index to high byte of next line pointer
000B54  1               LAB_1325:
000B54  1  86 71                STX     ut1_pl          ; set line start pointer low byte
000B56  1  85 72                STA     ut1_ph          ; set line start pointer high byte
000B58  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get it
000B5C  1  B5 71 C9 00  
000B60  1  D0 04 A2 00  
000B6E  1  F0 54                BEQ     LAB_133E        ; exit if end of program
000B70  1               
000B70  1               ; rebuild chaining of Basic lines
000B70  1               
000B70  1  A0 04                LDY     #$04            ; point to first code byte of line
000B72  1               ; there is always 1 byte + [EOL] as null entries are deleted
000B72  1               LAB_1330:
000B72  1  C8                   INY                     ; next code byte
000B73  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte
000B77  1  B5 71 C9 00  
000B7B  1  D0 04 A2 00  
000B89  1  D0 E7                BNE     LAB_1330        ; loop if not [EOL]
000B8B  1               
000B8B  1  38                   SEC                     ; set carry for add + 1
000B8C  1  98                   TYA                     ; copy end index
000B8D  1  65 71                ADC     ut1_pl          ; add to line start pointer low byte
000B8F  1  AA                   TAX                     ; copy to X
000B90  1  A0 00                LDY     #$00            ; clear index, point to this line's next line pointer
000B92  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; set next line pointer low byte
000B96  1  01 B5 71 C9  
000B9A  1  00 D0 04 A2  
000BA8  1  98                   TYA                     ; clear A
000BA9  1  65 72                ADC     ut1_ph          ; add line start pointer high byte + carry
000BAB  1  C8                   INY                     ; increment index to high byte
000BAC  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; save next line pointer low byte
000BB0  1  01 B5 71 C9  
000BB4  1  00 D0 04 A2  
000BC2  1  90 90                BCC     LAB_1325        ; go do next line, branch always, carry clear
000BC4  1               
000BC4  1               
000BC4  1               LAB_133E:
000BC4  1  4C 22 0A             JMP     LAB_127D        ; else we just wait for Basic command, no "Ready"
000BC7  1               
000BC7  1               ; print "? " and get BASIC input
000BC7  1               
000BC7  1               LAB_INLN:
000BC7  1  20 60 15             JSR     LAB_18E3        ; print "?" character
000BCA  1  20 5D 15             JSR     LAB_18E0        ; print " "
000BCD  1  D0 05                BNE     LAB_1357        ; call for BASIC input and return
000BCF  1               
000BCF  1               ; receive line from keyboard
000BCF  1               
000BCF  1               ; $08 as delete key (BACKSPACE on standard keyboard)
000BCF  1               LAB_134B:
000BCF  1  20 62 15             JSR     LAB_PRNA        ; go print the character
000BD2  1  CA                   DEX                     ; decrement the buffer counter (delete)
000BD3  1  2C                   .BYTE   $2C             ; make LDX into BIT abs
000BD4  1               
000BD4  1               ; call for BASIC input (main entry point)
000BD4  1               
000BD4  1               LAB_1357:
000BD4  1  A2 00                LDX     #$00            ; clear BASIC line buffer pointer
000BD6  1               LAB_1359:
000BD6  1  20 58 3D             JSR     V_INPT          ; call scan input device
000BD9  1  90 FB                BCC     LAB_1359        ; loop if no byte
000BDB  1               
000BDB  1               ;BEQ	LAB_1359		; loop until valid input (ignore NULLs)
000BDB  1               
000BDB  1  C9 07                CMP     #$07            ; compare with [BELL]
000BDD  1  F0 10                BEQ     LAB_1378        ; branch if [BELL]
000BDF  1               
000BDF  1  C9 0D                CMP     #$0D            ; compare with [CR]
000BE1  1  F0 19                BEQ     LAB_1384        ; do CR/LF exit if [CR]
000BE3  1               
000BE3  1  E0 00                CPX     #$00            ; compare pointer with $00
000BE5  1  D0 04                BNE     LAB_1374        ; branch if not empty
000BE7  1               
000BE7  1               ; next two lines ignore any non print character and [SPACE] if input buffer empty
000BE7  1               
000BE7  1  C9 21                CMP     #$21            ; compare with [SP]+1
000BE9  1  90 EB                BCC     LAB_1359        ; if < ignore character
000BEB  1               
000BEB  1               LAB_1374:
000BEB  1  C9 08                CMP     #$08            ; compare with [BACKSPACE] (delete last character)
000BED  1  F0 E0                BEQ     LAB_134B        ; go delete last character
000BEF  1               
000BEF  1               LAB_1378:
000BEF  1  E0 47                CPX     #Ibuffe-Ibuffs  ; compare character count with max
000BF1  1  B0 0C                BCS     LAB_138E        ; skip store and do [BELL] if buffer full
000BF3  1               
000BF3  1  9D 81 41             STA     Ibuffs,X        ; else store in buffer
000BF6  1  E8                   INX                     ; increment pointer
000BF7  1               LAB_137F:
000BF7  1  20 62 15             JSR     LAB_PRNA        ; go print the character
000BFA  1  D0 DA                BNE     LAB_1359        ; always loop for next character
000BFC  1               
000BFC  1               LAB_1384:
000BFC  1  4C E3 14             JMP     LAB_1866        ; do CR/LF exit to BASIC
000BFF  1               
000BFF  1               ; announce buffer full
000BFF  1               
000BFF  1               LAB_138E:
000BFF  1  A9 07                LDA     #$07            ; [BELL] character into A
000C01  1  D0 F4                BNE     LAB_137F        ; go print the [BELL] but ignore input character
000C03  1               ; branch always
000C03  1               
000C03  1               ; crunch keywords into Basic tokens
000C03  1               ; position independent buffer version ..
000C03  1               ; faster, dictionary search version ....
000C03  1               
000C03  1               LAB_13A6:
000C03  1  A0 FF                LDY     #$FF            ; set save index (makes for easy math later)
000C05  1               
000C05  1  38                   SEC                     ; set carry for subtract
000C06  1  A5 C3                LDA     Bpntrl          ; get basic execute pointer low byte
000C08  1  E9 81                SBC     #<Ibuffs        ; subtract input buffer start pointer
000C0A  1  AA                   TAX                     ; copy result to X (index past line # if any)
000C0B  1               
000C0B  1  86 60                STX     Oquote          ; clear open quote/DATA flag
000C0D  1               LAB_13AC:
000C0D  1  BD 81 41             LDA     Ibuffs,X        ; get byte from input buffer
000C10  1  F0 7E                BEQ     LAB_13EC        ; if null save byte then exit
000C12  1               
000C12  1  C9 5F                CMP     #'_'            ; compare with "_"
000C14  1  B0 7A                BCS     LAB_13EC        ; if >= go save byte then continue crunching
000C16  1               
000C16  1  C9 3C                CMP     #'<'            ; compare with "<"
000C18  1  B0 11                BCS     LAB_13CC        ; if >= go crunch now
000C1A  1               
000C1A  1  C9 30                CMP     #'0'            ; compare with "0"
000C1C  1  B0 72                BCS     LAB_13EC        ; if >= go save byte then continue crunching
000C1E  1               
000C1E  1  85 5C                STA     Scnquo          ; save buffer byte as search character
000C20  1  C9 22                CMP     #$22            ; is it quote character?
000C22  1  D0 03 4C B5          LBEQ    LAB_1410        ; branch if so (copy quoted string)
000C26  1  0C           
000C27  1               
000C27  1  C9 2A                CMP     #'*'            ; compare with "*"
000C29  1  90 65                BCC     LAB_13EC        ; if < go save byte then continue crunching
000C2B  1               
000C2B  1               ; else crunch now
000C2B  1               LAB_13CC:
000C2B  1  24 60                BIT     Oquote          ; get open quote/DATA token flag
000C2D  1  70 61                BVS     LAB_13EC        ; branch if b6 of Oquote set (was DATA)
000C2F  1               ; go save byte then continue crunching
000C2F  1               
000C2F  1  86 78                STX     TempB           ; save buffer read index
000C31  1  84 BA                STY     csidx           ; copy buffer save index
000C33  1  A0 38                LDY     #<TAB_1STC      ; get keyword first character table low address
000C35  1  84 73                STY     ut2_pl          ; save pointer low byte
000C37  1  A0 38                LDY     #>TAB_1STC      ; get keyword first character table high address
000C39  1  84 74                STY     ut2_ph          ; save pointer high byte
000C3B  1  A0 00                LDY     #$00            ; clear table pointer
000C3D  1               
000C3D  1               LAB_13D0:
000C3D  1  8B 48 DA A2          CMPINDIRECTY ut2_pl     ; compare with keyword first character table byte
000C41  1  01 B5 73 C9  
000C45  1  00 D0 04 A2  
000C55  1  F0 05                BEQ     LAB_13D1        ; go do word_table_chr if match
000C57  1               
000C57  1  90 35                BCC     LAB_13EA        ; if < keyword first character table byte go restore
000C59  1               ; Y and save to crunched
000C59  1               
000C59  1  C8                   INY                     ; else increment pointer
000C5A  1  D0 E1                BNE     LAB_13D0        ; and loop (branch always)
000C5C  1               
000C5C  1               ; have matched first character of some keyword
000C5C  1               
000C5C  1               LAB_13D1:
000C5C  1  98                   TYA                     ; copy matching index
000C5D  1  0A                   ASL     A               ; *2 (bytes per pointer)
000C5E  1  AA                   TAX                     ; copy to new index
000C5F  1  BD 57 38             LDA     TAB_CHRT,X      ; get keyword table pointer low byte
000C62  1  85 73                STA     ut2_pl          ; save pointer low byte
000C64  1  BD 58 38             LDA     TAB_CHRT+1,X    ; get keyword table pointer high byte
000C67  1  85 74                STA     ut2_ph          ; save pointer high byte
000C69  1               
000C69  1  A0 FF                LDY     #$FF            ; clear table pointer (make -1 for start)
000C6B  1               
000C6B  1  A6 78                LDX     TempB           ; restore buffer read index
000C6D  1               
000C6D  1               LAB_13D6:
000C6D  1  C8                   INY                     ; next table byte
000C6E  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get byte from table
000C72  1  B5 73 C9 00  
000C76  1  D0 04 A2 00  
000C84  1               LAB_13D8:
000C84  1  30 08                BMI     LAB_13EA        ; all bytes matched so go save token
000C86  1               
000C86  1  E8                   INX                     ; next buffer byte
000C87  1  DD 81 41             CMP     Ibuffs,X        ; compare with byte from input buffer
000C8A  1  F0 E1                BEQ     LAB_13D6        ; go compare next if match
000C8C  1               
000C8C  1  D0 2E                BNE     LAB_1417        ; branch if >< (not found keyword)
000C8E  1               
000C8E  1               LAB_13EA:
000C8E  1  A4 BA                LDY     csidx           ; restore save index
000C90  1               
000C90  1               ; save crunched to output
000C90  1               LAB_13EC:
000C90  1  E8                   INX                     ; increment buffer index (to next input byte)
000C91  1  C8                   INY                     ; increment save index (to next output byte)
000C92  1  99 81 41             STA     Ibuffs,Y        ; save byte to output
000C95  1  C9 00                CMP     #$00            ; set the flags, set carry
000C97  1  F0 5D                BEQ     LAB_142A        ; do exit if was null [EOL]
000C99  1               
000C99  1               ; A holds token or byte here
000C99  1  E9 3A                SBC     #':'            ; subtract ":" (carry set by CMP #00)
000C9B  1  F0 04                BEQ     LAB_13FF        ; branch if it was ":" (is now $00)
000C9D  1               
000C9D  1               ; A now holds token-$3A
000C9D  1  C9 49                CMP     #TK_DATA-$3A    ; compare with DATA token - $3A
000C9F  1  D0 02                BNE     LAB_1401        ; branch if not DATA
000CA1  1               
000CA1  1               ; token was : or DATA
000CA1  1               LAB_13FF:
000CA1  1  85 60                STA     Oquote          ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
000CA3  1               LAB_1401:
000CA3  1  49 57                EOR     #TK_REM-$3A     ; effectively subtract REM token offset
000CA5  1  F0 03 4C 0D          LBNE    LAB_13AC        ; If wasn't REM then go crunch rest of line
000CA9  1  0C           
000CAA  1               
000CAA  1  85 5C                STA     Asrch           ; else was REM so set search for [EOL]
000CAC  1               
000CAC  1               ; loop for REM, "..." etc.
000CAC  1               LAB_1408:
000CAC  1  BD 81 41             LDA     Ibuffs,X        ; get byte from input buffer
000CAF  1  F0 DF                BEQ     LAB_13EC        ; branch if null [EOL]
000CB1  1               
000CB1  1  C5 5C                CMP     Asrch           ; compare with stored character
000CB3  1  F0 DB                BEQ     LAB_13EC        ; branch if match (end quote)
000CB5  1               
000CB5  1               ; entry for copy string in quotes, don't crunch
000CB5  1               LAB_1410:
000CB5  1  C8                   INY                     ; increment buffer save index
000CB6  1  99 81 41             STA     Ibuffs,Y        ; save byte to output
000CB9  1  E8                   INX                     ; increment buffer read index
000CBA  1  D0 F0                BNE     LAB_1408        ; loop while <> 0 (should never be 0!)
000CBC  1               
000CBC  1               ; not found keyword this go
000CBC  1               LAB_1417:
000CBC  1  A6 78                LDX     TempB           ; compare has failed, restore buffer index (start byte!)
000CBE  1               
000CBE  1               ; now find the end of this word in the table
000CBE  1               LAB_141B:
000CBE  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get table byte
000CC2  1  B5 73 C9 00  
000CC6  1  D0 04 A2 00  
000CD4  1  08                   PHP                     ; save status
000CD5  1  C8                   INY                     ; increment table index
000CD6  1  28                   PLP                     ; restore byte status
000CD7  1  10 E5                BPL     LAB_141B        ; if not end of keyword go do next
000CD9  1               
000CD9  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get byte from keyword table
000CDD  1  B5 73 C9 00  
000CE1  1  D0 04 A2 00  
000CEF  1  D0 93                BNE     LAB_13D8        ; go test next word if not zero byte (end of table)
000CF1  1               
000CF1  1               ; reached end of table with no match
000CF1  1  BD 81 41             LDA     Ibuffs,X        ; restore byte from input buffer
000CF4  1  10 98                BPL     LAB_13EA        ; branch always (all bytes in buffer are $00-$7F)
000CF6  1               ; go save byte in output and continue crunching
000CF6  1               
000CF6  1               ; reached [EOL]
000CF6  1               LAB_142A:
000CF6  1  C8                   INY                     ; increment pointer
000CF7  1  C8                   INY                     ; increment pointer (makes it next line pointer high byte)
000CF8  1  99 81 41             STA     Ibuffs,Y        ; save [EOL] (marks [EOT] in immediate mode)
000CFB  1  C8                   INY                     ; adjust for line copy
000CFC  1  C8                   INY                     ; adjust for line copy
000CFD  1  C8                   INY                     ; adjust for line copy
000CFE  1  C6 C3                DEC     Bpntrl          ; allow for increment (change if buffer starts at $xxFF)
000D00  1  60                   RTS
000D01  1               
000D01  1               ; search Basic for temp integer line number from start of mem
000D01  1               
000D01  1               LAB_SSLN:
000D01  1  A5 79                LDA     Smeml           ; get start of mem low byte
000D03  1  A6 7A                LDX     Smemh           ; get start of mem high byte
000D05  1               
000D05  1               ; search Basic for temp integer line number from AX
000D05  1               ; returns carry set if found
000D05  1               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
000D05  1               
000D05  1               ; old 541 new 507
000D05  1               
000D05  1               LAB_SHLN:
000D05  1  A0 01                LDY     #$01            ; set index
000D07  1  85 AA                STA     Baslnl          ; save low byte as current
000D09  1  86 AB                STX     Baslnh          ; save high byte as current
000D0B  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get pointer high byte from addr
000D0F  1  B5 AA C9 00  
000D13  1  D0 04 A2 00  
000D21  1  F0 6F                BEQ     LAB_145F        ; pointer was zero so we're done, do 'not found' exit
000D23  1               
000D23  1  A0 03                LDY     #$03            ; set index to line # high byte
000D25  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get line # high byte
000D29  1  B5 AA C9 00  
000D2D  1  D0 04 A2 00  
000D3B  1  88                   DEY                     ; decrement index (point to low byte)
000D3C  1  C5 12                CMP     Itemph          ; compare with temporary integer high byte
000D3E  1  D0 18                BNE     LAB_1455        ; if <> skip low byte check
000D40  1               
000D40  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get line # low byte
000D44  1  B5 AA C9 00  
000D48  1  D0 04 A2 00  
000D56  1  C5 11                CMP     Itempl          ; compare with temporary integer low byte
000D58  1               LAB_1455:
000D58  1  B0 36                BCS     LAB_145E        ; else if temp < this line, exit (passed line#)
000D5A  1               
000D5A  1               LAB_1456:
000D5A  1  88                   DEY                     ; decrement index to next line ptr high byte
000D5B  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next line pointer high byte
000D5F  1  B5 AA C9 00  
000D63  1  D0 04 A2 00  
000D71  1  AA                   TAX                     ; copy to X
000D72  1  88                   DEY                     ; decrement index to next line ptr low byte
000D73  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next line pointer low byte
000D77  1  B5 AA C9 00  
000D7B  1  D0 04 A2 00  
000D89  1  90 02 80 03          LBCC    LAB_SHLN        ; go search for line # in temp (Itempl/Itemph) from AX
000D8D  1  4C 05 0D     
000D90  1               ; (carry always clear)
000D90  1               
000D90  1               LAB_145E:
000D90  1  F0 01                BEQ     LAB_1460        ; exit if temp = found line #, carry is set
000D92  1               
000D92  1               LAB_145F:
000D92  1  18                   CLC                     ; clear found flag
000D93  1               LAB_1460:
000D93  1  60                   RTS
000D94  1               
000D94  1               ; perform NEW
000D94  1               
000D94  1               LAB_NEW:
000D94  1  D0 FD                BNE     LAB_1460        ; exit if not end of statement (to do syntax error)
000D96  1               
000D96  1               LAB_1463:
000D96  1  A9 00                LDA     #$00            ; clear A
000D98  1  A8                   TAY                     ; clear Y
000D99  1  8B DA 48 A2          STAINDIRECTY Smeml      ; clear first line, next line pointer, low byte
000D9D  1  01 B5 79 C9  
000DA1  1  00 D0 04 A2  
000DAF  1  C8                   INY                     ; increment index
000DB0  1  8B DA 48 A2          STAINDIRECTY Smeml      ; clear first line, next line pointer, high byte
000DB4  1  01 B5 79 C9  
000DB8  1  00 D0 04 A2  
000DC6  1  18                   CLC                     ; clear carry
000DC7  1  A5 79                LDA     Smeml           ; get start of mem low byte
000DC9  1  69 02                ADC     #$02            ; calculate end of BASIC low byte
000DCB  1  85 7B                STA     Svarl           ; save start of vars low byte
000DCD  1  A5 7A                LDA     Smemh           ; get start of mem high byte
000DCF  1  69 00                ADC     #$00            ; add any carry
000DD1  1  85 7C                STA     Svarh           ; save start of vars high byte
000DD3  1               
000DD3  1               ; reset execution to start, clear vars and flush stack
000DD3  1               
000DD3  1               LAB_1477:
000DD3  1  18                   CLC                     ; clear carry
000DD4  1  A5 79                LDA     Smeml           ; get start of mem low byte
000DD6  1  69 FF                ADC     #$FF            ; -1
000DD8  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
000DDA  1  A5 7A                LDA     Smemh           ; get start of mem high byte
000DDC  1  69 FF                ADC     #$FF            ; -1+carry
000DDE  1  85 C4                STA     Bpntrh          ; save BASIC execute pointer high byte
000DE0  1               
000DE0  1               ; "CLEAR" command gets here
000DE0  1               
000DE0  1               LAB_147A:
000DE0  1  A5 85                LDA     Ememl           ; get end of mem low byte
000DE2  1  A4 86                LDY     Ememh           ; get end of mem high byte
000DE4  1  85 81                STA     Sstorl          ; set bottom of string space low byte
000DE6  1  84 82                STY     Sstorh          ; set bottom of string space high byte
000DE8  1  A5 7B                LDA     Svarl           ; get start of vars low byte
000DEA  1  A4 7C                LDY     Svarh           ; get start of vars high byte
000DEC  1  85 7D                STA     Sarryl          ; save var mem end low byte
000DEE  1  84 7E                STY     Sarryh          ; save var mem end high byte
000DF0  1  85 7F                STA     Earryl          ; save array mem end low byte
000DF2  1  84 80                STY     Earryh          ; save array mem end high byte
000DF4  1  20 A9 10             JSR     LAB_161A        ; perform RESTORE command
000DF7  1               
000DF7  1               ; flush stack and clear continue flag
000DF7  1               
000DF7  1               LAB_1491:
000DF7  1                       .IFDEF  DUODYNE
000DF7  1  C2 30                ACCUMULATORINDEX16
000DF9  1  FA                   PLX                     ; pull return address low byte
000DFA  1  A9 FF 5F             LDA     #STACK          ; get the stack address
000DFD  1  1B                   TCS                     ; and set the stack to it
000DFE  1  DA                   PHX
000DFF  1  E2 30                ACCUMULATORINDEX8
000E01  1                       .ELSE
000E01  1                       LDX     #des_sk         ; set descriptor stack pointer
000E01  1                       STX     next_s          ; save descriptor stack pointer
000E01  1                       PLA                     ; pull return address low byte
000E01  1                       TAX                     ; copy return address low byte
000E01  1                       PLA                     ; pull return address high byte
000E01  1                       STX     LAB_SKFE        ; save to cleared stack
000E01  1                       STA     LAB_SKFF        ; save to cleared stack
000E01  1                       LDX     #$FD            ; new stack pointer
000E01  1                       TXS                     ; reset stack
000E01  1                       .ENDIF
000E01  1  A9 00                LDA     #$00            ; clear byte
000E03  1  85 8C                STA     Cpntrh          ; clear continue pointer high byte
000E05  1  85 61                STA     Sufnxf          ; clear subscript/FNX flag
000E07  1               LAB_14A6:
000E07  1  60                   RTS
000E08  1               
000E08  1               ; perform CLEAR
000E08  1               
000E08  1               LAB_CLEAR:
000E08  1  F0 D6                BEQ     LAB_147A        ; if no following token go do "CLEAR"
000E0A  1               
000E0A  1               ; else there was a following token (go do syntax error)
000E0A  1  60                   RTS
000E0B  1               
000E0B  1               ; perform LIST [n][-m]
000E0B  1               ; bigger, faster version (a _lot_ faster)
000E0B  1               
000E0B  1               LAB_LIST:
000E0B  1  90 06                BCC     LAB_14BD        ; branch if next character numeric (LIST n..)
000E0D  1               
000E0D  1  F0 04                BEQ     LAB_14BD        ; branch if next character [NULL] (LIST)
000E0F  1               
000E0F  1  C9 B8                CMP     #TK_MINUS       ; compare with token for -
000E11  1  D0 F4                BNE     LAB_14A6        ; exit if not - (LIST -m)
000E13  1               
000E13  1               ; LIST [[n][-m]]
000E13  1               ; this bit sets the n , if present, as the start and end
000E13  1               LAB_14BD:
000E13  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
000E16  1  20 01 0D             JSR     LAB_SSLN        ; search BASIC for temp integer line number
000E19  1               ; (pointer in Baslnl/Baslnh)
000E19  1                       .IFDEF  DUODYNE
000E19  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
000E1D  1                       .ELSE
000E1D  1                       JSR     LAB_GBYT        ; scan memory
000E1D  1                       .ENDIF
000E1D  1               
000E1D  1  F0 13                BEQ     LAB_14D4        ; branch if no more characters
000E1F  1               
000E1F  1               ; this bit checks the - is present
000E1F  1  C9 B8                CMP     #TK_MINUS       ; compare with token for -
000E21  1  F0 03 4C 93          LBNE    LAB_1460        ; return if not "-" (will be Syntax error)
000E25  1  0D           
000E26  1               
000E26  1               ; LIST [n]-m
000E26  1               ; the - was there so set m as the end value
000E26  1                       .IFDEF  DUODYNE
000E26  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
000E2A  1                       .ELSE
000E2A  1                       JSR     LAB_IGBY        ; increment and scan memory
000E2A  1                       .ENDIF
000E2A  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
000E2D  1  F0 03 4C 93          LBNE    LAB_1460        ; exit if not ok
000E31  1  0D           
000E32  1               
000E32  1               LAB_14D4:
000E32  1  A5 11                LDA     Itempl          ; get temporary integer low byte
000E34  1  05 12                ORA     Itemph          ; OR temporary integer high byte
000E36  1  D0 06                BNE     LAB_14E2        ; branch if start set
000E38  1               
000E38  1  A9 FF                LDA     #$FF            ; set for -1
000E3A  1  85 11                STA     Itempl          ; set temporary integer low byte
000E3C  1  85 12                STA     Itemph          ; set temporary integer high byte
000E3E  1               LAB_14E2:
000E3E  1  A0 01                LDY     #$01            ; set index for line
000E40  1  84 60                STY     Oquote          ; clear open quote flag
000E42  1  20 EC 14             JSR     LAB_CRLF        ; print CR/LF
000E45  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next line pointer high byte
000E49  1  B5 AA C9 00  
000E4D  1  D0 04 A2 00  
000E5B  1               ; pointer initially set by search at LAB_14BD
000E5B  1  D0 03 4C 05          LBEQ    LAB_152B        ; if null all done so exit
000E5F  1  0F           
000E60  1  20 74 10             JSR     LAB_1629        ; do CRTL-C check vector
000E63  1               
000E63  1  C8                   INY                     ; increment index for line
000E64  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get line # low byte
000E68  1  B5 AA C9 00  
000E6C  1  D0 04 A2 00  
000E7A  1  AA                   TAX                     ; copy to X
000E7B  1  C8                   INY                     ; increment index
000E7C  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get line # high byte
000E80  1  B5 AA C9 00  
000E84  1  D0 04 A2 00  
000E92  1  C5 12                CMP     Itemph          ; compare with temporary integer high byte
000E94  1  D0 04                BNE     LAB_14FF        ; branch if no high byte match
000E96  1               
000E96  1  E4 11                CPX     Itempl          ; compare with temporary integer low byte
000E98  1  F0 02                BEQ     LAB_1501        ; branch if = last line to do (< will pass next branch)
000E9A  1               
000E9A  1               LAB_14FF:                       ; else ..
000E9A  1  B0 69                BCS     LAB_152B        ; if greater all done so exit
000E9C  1               
000E9C  1               LAB_1501:
000E9C  1  84 97                STY     Tidx1           ; save index for line
000E9E  1  20 36 2F             JSR     LAB_295E        ; print XA as unsigned integer
000EA1  1  A9 20                LDA     #$20            ; space is the next character
000EA3  1               LAB_1508:
000EA3  1  A4 97                LDY     Tidx1           ; get index for line
000EA5  1  29 7F                AND     #$7F            ; mask top out bit of character
000EA7  1               LAB_150C:
000EA7  1  20 62 15             JSR     LAB_PRNA        ; go print the character
000EAA  1  C9 22                CMP     #$22            ; was it " character
000EAC  1  D0 06                BNE     LAB_1519        ; branch if not
000EAE  1               
000EAE  1               ; we are either entering or leaving a pair of quotes
000EAE  1  A5 60                LDA     Oquote          ; get open quote flag
000EB0  1  49 FF                EOR     #$FF            ; toggle it
000EB2  1  85 60                STA     Oquote          ; save it back
000EB4  1               LAB_1519:
000EB4  1  C8                   INY                     ; increment index
000EB5  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next byte
000EB9  1  B5 AA C9 00  
000EBD  1  D0 04 A2 00  
000ECB  1  D0 39                BNE     LAB_152E        ; branch if not [EOL] (go print character)
000ECD  1  A8                   TAY                     ; else clear index
000ECE  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next line pointer low byte
000ED2  1  B5 AA C9 00  
000ED6  1  D0 04 A2 00  
000EE4  1  AA                   TAX                     ; copy to X
000EE5  1  C8                   INY                     ; increment index
000EE6  1  8B DA A2 01          LDAINDIRECTY Baslnl     ; get next line pointer high byte
000EEA  1  B5 AA C9 00  
000EEE  1  D0 04 A2 00  
000EFC  1  86 AA                STX     Baslnl          ; set pointer to line low byte
000EFE  1  85 AB                STA     Baslnh          ; set pointer to line high byte
000F00  1  F0 03 4C 3E          LBNE    LAB_14E2        ; go do next line if not [EOT]
000F04  1  0E           
000F05  1               ; else ..
000F05  1               LAB_152B:
000F05  1  60                   RTS
000F06  1               
000F06  1               LAB_152E:
000F06  1  10 9F                BPL     LAB_150C        ; just go print it if not token byte
000F08  1               
000F08  1               ; else was token byte so uncrunch it (maybe)
000F08  1  24 60                BIT     Oquote          ; test the open quote flag
000F0A  1  30 9B                BMI     LAB_150C        ; just go print character if open quote set
000F0C  1               
000F0C  1  A2 3A                LDX     #>LAB_KEYT      ; get table address high byte
000F0E  1  0A                   ASL     A               ; *2
000F0F  1  0A                   ASL     A               ; *4
000F10  1  90 02                BCC     LAB_152F        ; branch if no carry
000F12  1               
000F12  1  E8                   INX                     ; else increment high byte
000F13  1  18                   CLC                     ; clear carry for add
000F14  1               LAB_152F:
000F14  1  69 40                ADC     #<LAB_KEYT      ; add low byte
000F16  1  90 01                BCC     LAB_1530        ; branch if no carry
000F18  1               
000F18  1  E8                   INX                     ; else increment high byte
000F19  1               LAB_1530:
000F19  1  85 73                STA     ut2_pl          ; save table pointer low byte
000F1B  1  86 74                STX     ut2_ph          ; save table pointer high byte
000F1D  1  84 97                STY     Tidx1           ; save index for line
000F1F  1  A0 00                LDY     #$00            ; clear index
000F21  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get length
000F25  1  B5 73 C9 00  
000F29  1  D0 04 A2 00  
000F37  1  AA                   TAX                     ; copy length
000F38  1  C8                   INY                     ; increment index
000F39  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get 1st character
000F3D  1  B5 73 C9 00  
000F41  1  D0 04 A2 00  
000F4F  1  CA                   DEX                     ; decrement length
000F50  1  D0 03 4C A3          LBEQ    LAB_1508        ; if no more characters exit and print
000F54  1  0E           
000F55  1               
000F55  1  20 62 15             JSR     LAB_PRNA        ; go print the character
000F58  1  C8                   INY                     ; increment index
000F59  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get keyword address low byte
000F5D  1  B5 73 C9 00  
000F61  1  D0 04 A2 00  
000F6F  1  48                   PHA                     ; save it for now
000F70  1  C8                   INY                     ; increment index
000F71  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get keyword address high byte
000F75  1  B5 73 C9 00  
000F79  1  D0 04 A2 00  
000F87  1  A0 00                LDY     #$00
000F89  1  85 74                STA     ut2_ph          ; save keyword pointer high byte
000F8B  1  68                   PLA                     ; pull low byte
000F8C  1  85 73                STA     ut2_pl          ; save keyword pointer low byte
000F8E  1               LAB_1540:
000F8E  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get character
000F92  1  B5 73 C9 00  
000F96  1  D0 04 A2 00  
000FA4  1  CA                   DEX                     ; decrement character count
000FA5  1  D0 03 4C A3          LBEQ    LAB_1508        ; if last character exit and print
000FA9  1  0E           
000FAA  1               
000FAA  1  20 62 15             JSR     LAB_PRNA        ; go print the character
000FAD  1  C8                   INY                     ; increment index
000FAE  1  D0 DE                BNE     LAB_1540        ; loop for next character
000FB0  1               
000FB0  1               ; perform FOR
000FB0  1               
000FB0  1               LAB_FOR:
000FB0  1  A9 80                LDA     #$80            ; set FNX
000FB2  1  85 61                STA     Sufnxf          ; set subscript/FNX flag
000FB4  1  20 2F 13             JSR     LAB_LET         ; go do LET
000FB7  1  68                   PLA                     ; pull return address
000FB8  1  68                   PLA                     ; pull return address
000FB9  1  A9 10                LDA     #$10            ; we need 16d bytes !
000FBB  1  20 AE 09             JSR     LAB_1212        ; check room on stack for A bytes
000FBE  1  20 0D 12             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
000FC1  1  18                   CLC                     ; clear carry for add
000FC2  1  98                   TYA                     ; copy index to A
000FC3  1  65 C3                ADC     Bpntrl          ; add BASIC execute pointer low byte
000FC5  1  48                   PHA                     ; push onto stack
000FC6  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
000FC8  1  69 00                ADC     #$00            ; add carry
000FCA  1  48                   PHA                     ; push onto stack
000FCB  1  A5 88                LDA     Clineh          ; get current line high byte
000FCD  1  48                   PHA                     ; push onto stack
000FCE  1  A5 87                LDA     Clinel          ; get current line low byte
000FD0  1  48                   PHA                     ; push onto stack
000FD1  1  A9 AE                LDA     #TK_TO          ; get "TO" token
000FD3  1  20 A4 18             JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
000FD6  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
000FD9  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
000FDC  1               ; else do type mismatch
000FDC  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
000FDE  1  09 7F                ORA     #$7F            ; set all non sign bits
000FE0  1  25 AD                AND     FAC1_1          ; and FAC1 mantissa1
000FE2  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
000FE4  1  A9 EF                LDA     #<LAB_159F      ; set return address low byte
000FE6  1  A0 0F                LDY     #>LAB_159F      ; set return address high byte
000FE8  1  85 71                STA     ut1_pl          ; save return address low byte
000FEA  1  84 72                STY     ut1_ph          ; save return address high byte
000FEC  1  4C 36 18             JMP     LAB_1B66        ; round FAC1 and put on stack (returns to next instruction)
000FEF  1               
000FEF  1               LAB_159F:
000FEF  1  A9 06                LDA     #<LAB_259C      ; set 1 pointer low addr (default step size)
000FF1  1  A0 37                LDY     #>LAB_259C      ; set 1 pointer high addr
000FF3  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
000FF6  1                       .IFDEF  DUODYNE
000FF6  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
000FFA  1                       .ELSE
000FFA  1                       JSR     LAB_GBYT        ; scan memory
000FFA  1                       .ENDIF
000FFA  1               
000FFA  1  C9 B3                CMP     #TK_STEP        ; compare with STEP token
000FFC  1  D0 07                BNE     LAB_15B3        ; jump if not "STEP"
000FFE  1               
000FFE  1               ;.was step so ..
000FFE  1                       .IFDEF  DUODYNE
000FFE  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001002  1                       .ELSE
001002  1                       JSR     LAB_IGBY        ; increment and scan memory
001002  1                       .ENDIF
001002  1               
001002  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
001005  1               ; else do type mismatch
001005  1               LAB_15B3:
001005  1  20 1B 2D             JSR     LAB_27CA        ; return A=FF,C=1/-ve A=01,C=0/+ve
001008  1  85 B0                STA     FAC1_s          ; set FAC1 sign (b7)
00100A  1               ; this is +1 for +ve step and -1 for -ve step, in NEXT we
00100A  1               ; compare the FOR value and the TO value and return +1 if
00100A  1               ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00100A  1               ; here (+/-1) is then compared to that result and if they
00100A  1               ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00100A  1               ; the loop is done
00100A  1  20 2B 18             JSR     LAB_1B5B        ; push sign, round FAC1 and put on stack
00100D  1  A5 98                LDA     Frnxth          ; get var pointer for FOR/NEXT high byte
00100F  1  48                   PHA                     ; push on stack
001010  1  A5 97                LDA     Frnxtl          ; get var pointer for FOR/NEXT low byte
001012  1  48                   PHA                     ; push on stack
001013  1  A9 81                LDA     #TK_FOR         ; get FOR token
001015  1  48                   PHA                     ; push on stack
001016  1               
001016  1               ; interpreter inner loop
001016  1               
001016  1               LAB_15C2:
001016  1  20 74 10             JSR     LAB_1629        ; do CRTL-C check vector
001019  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
00101B  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte
00101D  1               
00101D  1  A6 88                LDX     Clineh          ; continue line is $FFxx for immediate mode
00101F  1               ; ($00xx for RUN from immediate mode)
00101F  1  E8                   INX                     ; increment it (now $00 if immediate mode)
001020  1  F0 04                BEQ     LAB_15D1        ; branch if null (immediate mode)
001022  1               
001022  1  85 8B                STA     Cpntrl          ; save continue pointer low byte
001024  1  84 8C                STY     Cpntrh          ; save continue pointer high byte
001026  1               LAB_15D1:
001026  1  A0 00                LDY     #$00            ; clear index
001028  1  B1 C3                LDA     (Bpntrl),Y      ; get next byte
00102A  1  F0 07                BEQ     LAB_15DC        ; branch if null [EOL]
00102C  1               
00102C  1  C9 3A                CMP     #':'            ; compare with ":"
00102E  1  F0 20                BEQ     LAB_15F6        ; branch if = (statement separator)
001030  1               
001030  1               LAB_15D9:
001030  1  4C B7 18             JMP     LAB_SNER        ; else syntax error then warm start
001033  1               
001033  1               ; have reached [EOL]
001033  1               LAB_15DC:
001033  1  A0 02                LDY     #$02            ; set index
001035  1  B1 C3                LDA     (Bpntrl),Y      ; get next line pointer high byte
001037  1  18                   CLC                     ; clear carry for no "BREAK" message
001038  1  D0 03 4C 9B          LBEQ    LAB_1651        ; if null go to immediate mode (was immediate or [EOT]
00103C  1  10           
00103D  1               ; marker)
00103D  1               
00103D  1  C8                   INY                     ; increment index
00103E  1  B1 C3                LDA     (Bpntrl),Y      ; get line # low byte
001040  1  85 87                STA     Clinel          ; save current line low byte
001042  1  C8                   INY                     ; increment index
001043  1  B1 C3                LDA     (Bpntrl),Y      ; get line # high byte
001045  1  85 88                STA     Clineh          ; save current line high byte
001047  1  98                   TYA                     ; A now = 4
001048  1  65 C3                ADC     Bpntrl          ; add BASIC execute pointer low byte
00104A  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
00104C  1  90 02                BCC     LAB_15F6        ; branch if no overflow
00104E  1               
00104E  1  E6 C4                INC     Bpntrh          ; else increment BASIC execute pointer high byte
001050  1               LAB_15F6:
001050  1                       .IFDEF  DUODYNE
001050  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001054  1                       .ELSE
001054  1                       JSR     LAB_IGBY        ; increment and scan memory
001054  1                       .ENDIF
001054  1               
001054  1               
001054  1               LAB_15F9:
001054  1  20 5A 10             JSR     LAB_15FF        ; go interpret BASIC code from (Bpntrl)
001057  1               
001057  1               LAB_15FC:
001057  1  4C 16 10             JMP     LAB_15C2        ; loop
00105A  1               
00105A  1               ; interpret BASIC code from (Bpntrl)
00105A  1               
00105A  1               LAB_15FF:
00105A  1  F0 5B                BEQ     LAB_1628        ; exit if zero [EOL]
00105C  1               
00105C  1               LAB_1602:
00105C  1  0A                   ASL     A               ; *2 bytes per vector and normalise token
00105D  1  B0 03                BCS     LAB_1609        ; branch if was token
00105F  1               
00105F  1  4C 2F 13             JMP     LAB_LET         ; else go do implied LET
001062  1               
001062  1               LAB_1609:
001062  1               TK_TABUSE       = (TK_TAB-$80)*2
001062  1  C9 58                CMP     #TK_TABUSE      ; compare normalised token * 2 with TAB
001064  1  B0 CA                BCS     LAB_15D9        ; branch if A>=TAB (do syntax error then warm start)
001066  1               ; only tokens before TAB can start a line
001066  1  A8                   TAY                     ; copy to index
001067  1  B9 2E 37             LDA     LAB_CTBL+1,Y    ; get vector high byte
00106A  1  48                   PHA                     ; onto stack
00106B  1  B9 2D 37             LDA     LAB_CTBL,Y      ; get vector low byte
00106E  1  48                   PHA                     ; onto stack
00106F  1                       .IFDEF  DUODYNE
00106F  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001073  1                       .ELSE
001073  1                       JSR     LAB_IGBY        ; increment and scan memory
001073  1                       .ENDIF
001073  1  60                   RTS
001074  1               ; then "return" to vector
001074  1               
001074  1               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
001074  1               ; key press is detected.
001074  1               
001074  1               LAB_1629:
001074  1                       .IFDEF  DUODYNE
001074  1  DA                   PHX
001075  1  A2 00                LDX     #$00
001077  1  FC 03 06             JSR     (VEC_CC,X)      ; ctrl c check vector
00107A  1  FA                   PLX
00107B  1  60                   RTS
00107C  1                       .ELSE
00107C  1                       JMP     (VEC_CC)        ; ctrl c check vector
00107C  1                       .ENDIF
00107C  1               
00107C  1               
00107C  1               ; if there was a key press it gets back here ..
00107C  1               
00107C  1               LAB_1636:
00107C  1  C9 03                CMP     #$03            ; compare with CTRL-C
00107E  1               
00107E  1               ; perform STOP
00107E  1               
00107E  1               LAB_STOP:
00107E  1  B0 01                BCS     LAB_163B        ; branch if token follows STOP
001080  1               ; else just END
001080  1               ; END
001080  1               
001080  1               LAB_END:
001080  1  18                   CLC                     ; clear the carry, indicate a normal program end
001081  1               LAB_163B:
001081  1  D0 67                BNE     LAB_167A        ; if wasn't CTRL-C or there is a following byte return
001083  1               
001083  1  A5 C4                LDA     Bpntrh          ; get the BASIC execute pointer high byte
001085  1  49 41                EOR     #>Ibuffs        ; compare with buffer address high byte (Cb unchanged)
001087  1  F0 10                BEQ     LAB_164F        ; branch if the BASIC pointer is in the input buffer
001089  1               ; (can't continue in immediate mode)
001089  1               
001089  1               ; else ..
001089  1  49 41                EOR     #>Ibuffs        ; correct the bits
00108B  1  A4 C3                LDY     Bpntrl          ; get BASIC execute pointer low byte
00108D  1  84 8B                STY     Cpntrl          ; save continue pointer low byte
00108F  1  85 8C                STA     Cpntrh          ; save continue pointer high byte
001091  1               LAB_1647:
001091  1  A5 87                LDA     Clinel          ; get current line low byte
001093  1  A4 88                LDY     Clineh          ; get current line high byte
001095  1  85 89                STA     Blinel          ; save break line low byte
001097  1  84 8A                STY     Blineh          ; save break line high byte
001099  1               LAB_164F:
001099  1  68                   PLA                     ; pull return address low
00109A  1  68                   PLA                     ; pull return address high
00109B  1               LAB_1651:
00109B  1  90 07                BCC     LAB_165E        ; if was program end just do warm start
00109D  1               
00109D  1               ; else ..
00109D  1  A9 11                LDA     #<LAB_BMSG      ; point to "Break" low byte
00109F  1  A0 3D                LDY     #>LAB_BMSG      ; point to "Break" high byte
0010A1  1  4C 0A 0A             JMP     LAB_1269        ; print "Break" and do warm start
0010A4  1               
0010A4  1               LAB_165E:
0010A4  1  4C 15 0A             JMP     LAB_1274        ; go do warm start
0010A7  1               
0010A7  1               ; perform RESTORE
0010A7  1               
0010A7  1               LAB_RESTORE:
0010A7  1  D0 0F                BNE     LAB_RESTOREn    ; branch if next character not null (RESTORE n)
0010A9  1               
0010A9  1               LAB_161A:
0010A9  1  38                   SEC                     ; set carry for subtract
0010AA  1  A5 79                LDA     Smeml           ; get start of mem low byte
0010AC  1  E9 01                SBC     #$01            ; -1
0010AE  1  A4 7A                LDY     Smemh           ; get start of mem high byte
0010B0  1  B0 01                BCS     LAB_1624        ; branch if no underflow
0010B2  1               
0010B2  1               LAB_uflow:
0010B2  1  88                   DEY                     ; else decrement high byte
0010B3  1               LAB_1624:
0010B3  1  85 8F                STA     Dptrl           ; save DATA pointer low byte
0010B5  1  84 90                STY     Dptrh           ; save DATA pointer high byte
0010B7  1               LAB_1628:
0010B7  1  60                   RTS
0010B8  1               
0010B8  1               ; is RESTORE n
0010B8  1               LAB_RESTOREn:
0010B8  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
0010BB  1  20 10 12             JSR     LAB_SNBL        ; scan for next BASIC line
0010BE  1  A5 88                LDA     Clineh          ; get current line high byte
0010C0  1  C5 12                CMP     Itemph          ; compare with temporary integer high byte
0010C2  1  B0 0B                BCS     LAB_reset_search; branch if >= (start search from beginning)
0010C4  1               
0010C4  1  98                   TYA                     ; else copy line index to A
0010C5  1  38                   SEC                     ; set carry (+1)
0010C6  1  65 C3                ADC     Bpntrl          ; add BASIC execute pointer low byte
0010C8  1  A6 C4                LDX     Bpntrh          ; get BASIC execute pointer high byte
0010CA  1  90 07                BCC     LAB_go_search   ; branch if no overflow to high byte
0010CC  1               
0010CC  1  E8                   INX                     ; increment high byte
0010CD  1  B0 04                BCS     LAB_go_search   ; branch always (can never be carry clear)
0010CF  1               
0010CF  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
0010CF  1               
0010CF  1               LAB_reset_search:
0010CF  1  A5 79                LDA     Smeml           ; get start of mem low byte
0010D1  1  A6 7A                LDX     Smemh           ; get start of mem high byte
0010D3  1               
0010D3  1               ; search for line # in temp (Itempl/Itemph) from (AX)
0010D3  1               
0010D3  1               LAB_go_search:
0010D3  1               
0010D3  1  20 05 0D             JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
0010D6  1  B0 03                BCS     LAB_line_found  ; if carry set go set pointer
0010D8  1               
0010D8  1  4C E2 11             JMP     LAB_16F7        ; else go do "Undefined statement" error
0010DB  1               
0010DB  1               LAB_line_found:
0010DB  1               ; carry already set for subtract
0010DB  1  A5 AA                LDA     Baslnl          ; get pointer low byte
0010DD  1  E9 01                SBC     #$01            ; -1
0010DF  1  A4 AB                LDY     Baslnh          ; get pointer high byte
0010E1  1  B0 D0                BCS     LAB_1624        ; branch if no underflow (save DATA pointer and return)
0010E3  1               
0010E3  1  90 CD                BCC     LAB_uflow       ; else decrement high byte then save DATA pointer and
0010E5  1               ; return (branch always)
0010E5  1               
0010E5  1               ; perform NULL
0010E5  1               
0010E5  1               LAB_NULL:
0010E5  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter
0010E8  1  86 0D                STX     Nullct          ; save new NULL count
0010EA  1               LAB_167A:
0010EA  1  60                   RTS
0010EB  1               
0010EB  1               ; perform CONT
0010EB  1               
0010EB  1               LAB_CONT:
0010EB  1  D0 FD                BNE     LAB_167A        ; if following byte exit to do syntax error
0010ED  1               
0010ED  1  A4 8C                LDY     Cpntrh          ; get continue pointer high byte
0010EF  1  D0 05                BNE     LAB_166C        ; go do continue if we can
0010F1  1               
0010F1  1  A2 1E                LDX     #$1E            ; error code $1E ("Can't continue" error)
0010F3  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
0010F6  1               
0010F6  1               ; we can continue so ..
0010F6  1               LAB_166C:
0010F6  1  A9 93                LDA     #TK_ON          ; set token for ON
0010F8  1  20 3C 34             JSR     LAB_IRQ         ; set IRQ flags
0010FB  1  A9 93                LDA     #TK_ON          ; set token for ON
0010FD  1  20 3F 34             JSR     LAB_NMI         ; set NMI flags
001100  1               
001100  1  84 C4                STY     Bpntrh          ; save BASIC execute pointer high byte
001102  1  A5 8B                LDA     Cpntrl          ; get continue pointer low byte
001104  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
001106  1  A5 89                LDA     Blinel          ; get break line low byte
001108  1  A4 8A                LDY     Blineh          ; get break line high byte
00110A  1  85 87                STA     Clinel          ; set current line low byte
00110C  1  84 88                STY     Clineh          ; set current line high byte
00110E  1  60                   RTS
00110F  1               
00110F  1               ; perform RUN
00110F  1               
00110F  1               LAB_RUN:
00110F  1  D0 03                BNE     LAB_1696        ; branch if RUN n
001111  1  4C D3 0D             JMP     LAB_1477        ; reset execution to start, clear variables, flush stack and
001114  1               ; return
001114  1               
001114  1               ; does RUN n
001114  1               
001114  1               LAB_1696:
001114  1  20 E0 0D             JSR     LAB_147A        ; go do "CLEAR"
001117  1  F0 2F                BEQ     LAB_16B0        ; get n and do GOTO n (branch always as CLEAR sets Z=1)
001119  1               
001119  1               ; perform DO
001119  1               
001119  1               LAB_DO:
001119  1  A9 05                LDA     #$05            ; need 5 bytes for DO
00111B  1  20 AE 09             JSR     LAB_1212        ; check room on stack for A bytes
00111E  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
001120  1  48                   PHA                     ; push on stack
001121  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
001123  1  48                   PHA                     ; push on stack
001124  1  A5 88                LDA     Clineh          ; get current line high byte
001126  1  48                   PHA                     ; push on stack
001127  1  A5 87                LDA     Clinel          ; get current line low byte
001129  1  48                   PHA                     ; push on stack
00112A  1  A9 9D                LDA     #TK_DO          ; token for DO
00112C  1  48                   PHA                     ; push on stack
00112D  1                       .IFDEF  DUODYNE
00112D  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001131  1                       .ELSE
001131  1                       JSR     LAB_GBYT        ; scan memory
001131  1                       .ENDIF
001131  1               
001131  1  4C 16 10             JMP     LAB_15C2        ; go do interpreter inner loop
001134  1               
001134  1               ; perform GOSUB
001134  1               
001134  1               LAB_GOSUB:
001134  1  A9 05                LDA     #$05            ; need 5 bytes for GOSUB
001136  1  20 AE 09             JSR     LAB_1212        ; check room on stack for A bytes
001139  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
00113B  1  48                   PHA                     ; push on stack
00113C  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
00113E  1  48                   PHA                     ; push on stack
00113F  1  A5 88                LDA     Clineh          ; get current line high byte
001141  1  48                   PHA                     ; push on stack
001142  1  A5 87                LDA     Clinel          ; get current line low byte
001144  1  48                   PHA                     ; push on stack
001145  1  A9 8D                LDA     #TK_GOSUB       ; token for GOSUB
001147  1  48                   PHA                     ; push on stack
001148  1               LAB_16B0:
001148  1                       .IFDEF  DUODYNE
001148  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00114C  1                       .ELSE
00114C  1                       JSR     LAB_GBYT        ; scan memory
00114C  1                       .ENDIF
00114C  1               
00114C  1  20 52 11             JSR     LAB_GOTO        ; perform GOTO n
00114F  1  4C 16 10             JMP     LAB_15C2        ; go do interpreter inner loop
001152  1               ; (can't RTS, we used the stack!)
001152  1               
001152  1               ; perform GOTO
001152  1               
001152  1               LAB_GOTO:
001152  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
001155  1  20 10 12             JSR     LAB_SNBL        ; scan for next BASIC line
001158  1  A5 88                LDA     Clineh          ; get current line high byte
00115A  1  C5 12                CMP     Itemph          ; compare with temporary integer high byte
00115C  1  B0 0B                BCS     LAB_16D0        ; branch if >= (start search from beginning)
00115E  1               
00115E  1  98                   TYA                     ; else copy line index to A
00115F  1  38                   SEC                     ; set carry (+1)
001160  1  65 C3                ADC     Bpntrl          ; add BASIC execute pointer low byte
001162  1  A6 C4                LDX     Bpntrh          ; get BASIC execute pointer high byte
001164  1  90 07                BCC     LAB_16D4        ; branch if no overflow to high byte
001166  1               
001166  1  E8                   INX                     ; increment high byte
001167  1  B0 04                BCS     LAB_16D4        ; branch always (can never be carry)
001169  1               
001169  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
001169  1               
001169  1               LAB_16D0:
001169  1  A5 79                LDA     Smeml           ; get start of mem low byte
00116B  1  A6 7A                LDX     Smemh           ; get start of mem high byte
00116D  1               
00116D  1               ; search for line # in temp (Itempl/Itemph) from (AX)
00116D  1               
00116D  1               LAB_16D4:
00116D  1  20 05 0D             JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
001170  1  90 70                BCC     LAB_16F7        ; if carry clear go do "Undefined statement" error
001172  1               ; (unspecified statement)
001172  1               
001172  1               ; carry already set for subtract
001172  1  A5 AA                LDA     Baslnl          ; get pointer low byte
001174  1  E9 01                SBC     #$01            ; -1
001176  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
001178  1  A5 AB                LDA     Baslnh          ; get pointer high byte
00117A  1  E9 00                SBC     #$00            ; subtract carry
00117C  1  85 C4                STA     Bpntrh          ; save BASIC execute pointer high byte
00117E  1               LAB_16E5:
00117E  1  60                   RTS
00117F  1               
00117F  1               LAB_DONOK:
00117F  1  A2 22                LDX     #$22            ; error code $22 ("LOOP without DO" error)
001181  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
001184  1               
001184  1               ; perform LOOP
001184  1               
001184  1               LAB_LOOP:
001184  1  A8                   TAY                     ; save following token
001185  1                       .IFDEF  DUODYNE
001185  1  A3 03                LDA     3,S             ; get token byte from stack
001187  1  C9 9D                CMP     #TK_DO          ; compare with DO token
001189  1  D0 F4                BNE     LAB_DONOK       ; branch if no matching DO
00118B  1               
00118B  1               ; FIXUP STACK
00118B  1  C2 10                INDEX16
00118D  1  BA                   TSX
00118E  1  E8                   INX                     ; dump calling routine return address
00118F  1  E8                   INX                     ; dump calling routine return address
001190  1  9A                   TXS                     ; correct stack
001191  1  E2 10                INDEX8
001193  1                       .ELSE
001193  1                       TSX                     ; copy stack pointer
001193  1                       LDA     LAB_STAK+3,X    ; get token byte from stack
001193  1                       CMP     #TK_DO          ; compare with DO token
001193  1                       BNE     LAB_DONOK       ; branch if no matching DO
001193  1               
001193  1                       INX                     ; dump calling routine return address
001193  1                       INX                     ; dump calling routine return address
001193  1                       TXS                     ; correct stack
001193  1                       .ENDIF
001193  1  98                   TYA                     ; get saved following token back
001194  1  F0 20                BEQ     LoopAlways      ; if no following token loop forever
001196  1               ; (stack pointer in X)
001196  1               
001196  1  C9 3A                CMP     #':'            ; could be ':'
001198  1  F0 1C                BEQ     LoopAlways      ; if :... loop forever
00119A  1               
00119A  1  E9 B4                SBC     #TK_UNTIL       ; subtract token for UNTIL, we know carry is set here
00119C  1  AA                   TAX                     ; copy to X (if it was UNTIL then Y will be correct)
00119D  1  F0 04                BEQ     DoRest          ; branch if was UNTIL
00119F  1               
00119F  1  CA                   DEX                     ; decrement result
0011A0  1  D0 68                BNE     LAB_16FC        ; if not WHILE go do syntax error and warm start
0011A2  1               ; only if the token was WHILE will this fail
0011A2  1               
0011A2  1  CA                   DEX                     ; set invert result byte
0011A3  1               DoRest:
0011A3  1  86 98                STX     Frnxth          ; save invert result byte
0011A5  1                       .IFDEF  DUODYNE
0011A5  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0011A9  1                       .ELSE
0011A9  1                       JSR     LAB_IGBY        ; increment and scan memory
0011A9  1                       .ENDIF
0011A9  1               
0011A9  1  20 91 17             JSR     LAB_EVEX        ; evaluate expression
0011AC  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0011AE  1  F0 02                BEQ     DoCmp           ; if =0 go do straight compare
0011B0  1               
0011B0  1  A9 FF                LDA     #$FF            ; else set all bits
0011B2  1               DoCmp:
0011B2  1                       .IFNDEF DUODYNE
0011B2  1                       TSX                     ; copy stack pointer
0011B2  1                       .ENDIF
0011B2  1  45 98                EOR     Frnxth          ; EOR with invert byte
0011B4  1  D0 1B                BNE     LoopDone        ; if <> 0 clear stack and back to interpreter loop
0011B6  1               
0011B6  1               ; loop condition wasn't met so do it again
0011B6  1               LoopAlways:
0011B6  1  BD 02 01             LDA     LAB_STAK+2,X    ; get current line low byte
0011B9  1  85 87                STA     Clinel          ; save current line low byte
0011BB  1  BD 03 01             LDA     LAB_STAK+3,X    ; get current line high byte
0011BE  1  85 88                STA     Clineh          ; save current line high byte
0011C0  1  BD 04 01             LDA     LAB_STAK+4,X    ; get BASIC execute pointer low byte
0011C3  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
0011C5  1  BD 05 01             LDA     LAB_STAK+5,X    ; get BASIC execute pointer high byte
0011C8  1  85 C4                STA     Bpntrh          ; save BASIC execute pointer high byte
0011CA  1                       .IFDEF  DUODYNE
0011CA  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0011CE  1                       .ELSE
0011CE  1                       JSR     LAB_GBYT        ; scan memory
0011CE  1                       .ENDIF
0011CE  1               
0011CE  1  4C 16 10             JMP     LAB_15C2        ; go do interpreter inner loop
0011D1  1               
0011D1  1               ; clear stack and back to interpreter loop
0011D1  1               LoopDone:
0011D1  1                       .IFDEF  DUODYNE
0011D1  1  C2 10                INDEX16
0011D3  1  BA                   TSX
0011D4  1  E8                   INX                     ; dump DO token
0011D5  1  E8                   INX                     ; dump current line low byte
0011D6  1  E8                   INX                     ; dump current line high byte
0011D7  1  E8                   INX                     ; dump BASIC execute pointer low byte
0011D8  1  E8                   INX                     ; dump BASIC execute pointer high byte
0011D9  1  9A                   TXS                     ; correct stack
0011DA  1  E2 10                INDEX8
0011DC  1                       .ELSE
0011DC  1                       INX                     ; dump DO token
0011DC  1                       INX                     ; dump current line low byte
0011DC  1                       INX                     ; dump current line high byte
0011DC  1                       INX                     ; dump BASIC execute pointer low byte
0011DC  1                       INX                     ; dump BASIC execute pointer high byte
0011DC  1                       TXS                     ; correct stack
0011DC  1                       .ENDIF
0011DC  1  4C FC 11             JMP     LAB_DATA        ; go perform DATA (find : or [EOL])
0011DF  1               
0011DF  1               ; do the return without gosub error
0011DF  1               
0011DF  1               LAB_16F4:
0011DF  1  A2 04                LDX     #$04            ; error code $04 ("RETURN without GOSUB" error)
0011E1  1  2C                   .BYTE   $2C             ; makes next line BIT LAB_0EA2
0011E2  1               
0011E2  1               LAB_16F7
0011E2  1               ; do undefined statement error
0011E2  1  A2 0E                LDX     #$0E            ; error code $0E ("Undefined statement" error)
0011E4  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
0011E7  1               
0011E7  1               ; perform RETURN
0011E7  1               
0011E7  1               LAB_RETURN:
0011E7  1  D0 95                BNE     LAB_16E5        ; exit if following token (to allow syntax error)
0011E9  1               
0011E9  1               LAB_16E8:
0011E9  1  68                   PLA                     ; dump calling routine return address
0011EA  1  68                   PLA                     ; dump calling routine return address
0011EB  1  68                   PLA                     ; pull token
0011EC  1  C9 8D                CMP     #TK_GOSUB       ; compare with GOSUB token
0011EE  1  D0 EF                BNE     LAB_16F4        ; branch if no matching GOSUB
0011F0  1               
0011F0  1               LAB_16FF:
0011F0  1  68                   PLA                     ; pull current line low byte
0011F1  1  85 87                STA     Clinel          ; save current line low byte
0011F3  1  68                   PLA                     ; pull current line high byte
0011F4  1  85 88                STA     Clineh          ; save current line high byte
0011F6  1  68                   PLA                     ; pull BASIC execute pointer low byte
0011F7  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
0011F9  1  68                   PLA                     ; pull BASIC execute pointer high byte
0011FA  1  85 C4                STA     Bpntrh          ; save BASIC execute pointer high byte
0011FC  1               
0011FC  1               ; now do the DATA statement as we could be returning into
0011FC  1               ; the middle of an ON <var> GOSUB n,m,p,q line
0011FC  1               ; (the return address used by the DATA statement is the one
0011FC  1               ; pushed before the GOSUB was executed!)
0011FC  1               
0011FC  1               ; perform DATA
0011FC  1               
0011FC  1               LAB_DATA:
0011FC  1  20 0D 12             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
0011FF  1               
0011FF  1               ; set BASIC execute pointer
0011FF  1               LAB_170F:
0011FF  1  98                   TYA                     ; copy index to A
001200  1  18                   CLC                     ; clear carry for add
001201  1  65 C3                ADC     Bpntrl          ; add BASIC execute pointer low byte
001203  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
001205  1  90 02                BCC     LAB_1719        ; skip next if no carry
001207  1               
001207  1  E6 C4                INC     Bpntrh          ; else increment BASIC execute pointer high byte
001209  1               LAB_1719:
001209  1  60                   RTS
00120A  1               
00120A  1               LAB_16FC:
00120A  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
00120D  1               
00120D  1               ; scan for next BASIC statement ([:] or [EOL])
00120D  1               ; returns Y as index to [:] or [EOL]
00120D  1               
00120D  1               LAB_SNBS:
00120D  1  A2 3A                LDX     #':'            ; set look for character = ":"
00120F  1  2C                   .BYTE   $2C             ; makes next line BIT $00A2
001210  1               
001210  1               ; scan for next BASIC line
001210  1               ; returns Y as index to [EOL]
001210  1               
001210  1               LAB_SNBL:
001210  1  A2 00                LDX     #$00            ; set alt search character = [EOL]
001212  1  A0 00                LDY     #$00            ; set search character = [EOL]
001214  1  84 5C                STY     Asrch           ; store search character
001216  1               LAB_1725:
001216  1  8A                   TXA                     ; get alt search character
001217  1  45 5C                EOR     Asrch           ; toggle search character, effectively swap with $00
001219  1  85 5C                STA     Asrch           ; save swapped search character
00121B  1               LAB_172D:
00121B  1  B1 C3                LDA     (Bpntrl),Y      ; get next byte
00121D  1  F0 EA                BEQ     LAB_1719        ; exit if null [EOL]
00121F  1               
00121F  1  C5 5C                CMP     Asrch           ; compare with search character
001221  1  F0 E6                BEQ     LAB_1719        ; exit if found
001223  1               
001223  1  C8                   INY                     ; increment index
001224  1  C9 22                CMP     #$22            ; compare current character with open quote
001226  1  D0 F3                BNE     LAB_172D        ; if not open quote go get next character
001228  1               
001228  1  F0 EC                BEQ     LAB_1725        ; if found go swap search character for alt search character
00122A  1               
00122A  1               ; perform IF
00122A  1               
00122A  1               LAB_IF:
00122A  1  20 91 17             JSR     LAB_EVEX        ; evaluate the expression
00122D  1                       .IFDEF  DUODYNE
00122D  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001231  1                       .ELSE
001231  1                       JSR     LAB_GBYT        ; scan memory
001231  1                       .ENDIF
001231  1               
001231  1  C9 B1                CMP     #TK_THEN        ; compare with THEN token
001233  1  F0 12                BEQ     LAB_174B        ; if it was THEN go do IF
001235  1               
001235  1               ; wasn't IF .. THEN so must be IF .. GOTO
001235  1  C9 89                CMP     #TK_GOTO        ; compare with GOTO token
001237  1  D0 D1                BNE     LAB_16FC        ; if it wasn't GOTO go do syntax error
001239  1               
001239  1  A6 C3                LDX     Bpntrl          ; save the basic pointer low byte
00123B  1  A4 C4                LDY     Bpntrh          ; save the basic pointer high byte
00123D  1                       .IFDEF  DUODYNE
00123D  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001241  1                       .ELSE
001241  1                       JSR     LAB_IGBY        ; increment and scan memory
001241  1                       .ENDIF
001241  1               
001241  1  B0 C7                BCS     LAB_16FC        ; if not numeric go do syntax error
001243  1               
001243  1  86 C3                STX     Bpntrl          ; restore the basic pointer low byte
001245  1  84 C4                STY     Bpntrh          ; restore the basic pointer high byte
001247  1               LAB_174B:
001247  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
001249  1  F0 1F                BEQ     LAB_174E        ; if the result was zero go look for an ELSE
00124B  1               
00124B  1                       .IFDEF  DUODYNE
00124B  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00124F  1                       .ELSE
00124F  1                       JSR     LAB_IGBY        ; increment and scan memory
00124F  1                       .ENDIF
00124F  1               
00124F  1  B0 03                BCS     LAB_174D        ; if not numeric go do var or keyword
001251  1               
001251  1               LAB_174C:
001251  1  4C 52 11             JMP     LAB_GOTO        ; else was numeric so do GOTO n
001254  1               
001254  1               ; is var or keyword
001254  1               LAB_174D:
001254  1  C9 90                CMP     #TK_RETURN      ; compare the byte with the token for RETURN
001256  1  D0 03                BNE     LAB_174G        ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
001258  1               ; and return to this code to process any following code
001258  1               
001258  1  4C 5C 10             JMP     LAB_1602        ; else it was RETURN so interpret BASIC code from (Bpntrl)
00125B  1               ; but don't return here
00125B  1               
00125B  1               LAB_174G:
00125B  1  20 5A 10             JSR     LAB_15FF        ; interpret BASIC code from (Bpntrl)
00125E  1               
00125E  1               ; the IF was executed and there may be a following ELSE so the code needs to return
00125E  1               ; here to check and ignore the ELSE if present
00125E  1               
00125E  1  A0 00                LDY     #$00            ; clear the index
001260  1  B1 C3                LDA     (Bpntrl),Y      ; get the next BASIC byte
001262  1  C9 AD                CMP     #TK_ELSE        ; compare it with the token for ELSE
001264  1  D0 03 4C FC          LBEQ    LAB_DATA        ; if ELSE ignore the following statement
001268  1  11           
001269  1               
001269  1               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
001269  1               ; following ELSE will, correctly, cause a syntax error
001269  1               
001269  1  60                   RTS                     ; else return to the interpreter inner loop
00126A  1               
00126A  1               ; perform ELSE after IF
00126A  1               
00126A  1               LAB_174E:
00126A  1  A0 00                LDY     #$00            ; clear the BASIC byte index
00126C  1  A2 01                LDX     #$01            ; clear the nesting depth
00126E  1               LAB_1750:
00126E  1  C8                   INY                     ; increment the BASIC byte index
00126F  1  B1 C3                LDA     (Bpntrl),Y      ; get the next BASIC byte
001271  1  F0 0F                BEQ     LAB_1753        ; if EOL go add the pointer and return
001273  1               
001273  1  C9 8B                CMP     #TK_IF          ; compare the byte with the token for IF
001275  1  D0 03                BNE     LAB_1752        ; if not IF token skip the depth increment
001277  1               
001277  1  E8                   INX                     ; else increment the nesting depth ..
001278  1  D0 F4                BNE     LAB_1750        ; .. and continue looking
00127A  1               
00127A  1               LAB_1752:
00127A  1  C9 AD                CMP     #TK_ELSE        ; compare the byte with the token for ELSE
00127C  1  D0 F0                BNE     LAB_1750        ; if not ELSE token continue looking
00127E  1               
00127E  1  CA                   DEX                     ; was ELSE so decrement the nesting depth
00127F  1  D0 ED                BNE     LAB_1750        ; loop if still nested
001281  1               
001281  1  C8                   INY                     ; increment the BASIC byte index past the ELSE
001282  1               
001282  1               ; found the matching ELSE, now do <{n|statement}>
001282  1               
001282  1               LAB_1753:
001282  1  98                   TYA                     ; else copy line index to A
001283  1  18                   CLC                     ; clear carry for add
001284  1  65 C3                ADC     Bpntrl          ; add the BASIC execute pointer low byte
001286  1  85 C3                STA     Bpntrl          ; save the BASIC execute pointer low byte
001288  1  90 02                BCC     LAB_1754        ; branch if no overflow to high byte
00128A  1               
00128A  1  E6 C4                INC     Bpntrh          ; else increment the BASIC execute pointer high byte
00128C  1               LAB_1754:
00128C  1                       .IFDEF  DUODYNE
00128C  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001290  1                       .ELSE
001290  1                       JSR     LAB_GBYT        ; scan memory
001290  1                       .ENDIF
001290  1               
001290  1  90 BF                BCC     LAB_174C        ; if numeric do GOTO n
001292  1               ; the code will return to the interpreter loop at the
001292  1               ; tail end of the GOTO <n>
001292  1               
001292  1  4C 5A 10             JMP     LAB_15FF        ; interpret BASIC code from (Bpntrl)
001295  1               ; the code will return to the interpreter loop at the
001295  1               ; tail end of the <statement>
001295  1               
001295  1               ; perform REM, skip (rest of) line
001295  1               
001295  1               LAB_REM:
001295  1  20 10 12             JSR     LAB_SNBL        ; scan for next BASIC line
001298  1  4C FF 11             JMP     LAB_170F        ; go set BASIC execute pointer and return, branch always
00129B  1               
00129B  1               LAB_16FD:
00129B  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
00129E  1               
00129E  1               ; perform ON
00129E  1               
00129E  1               LAB_ON:
00129E  1  C9 A9                CMP     #TK_IRQ         ; was it IRQ token ?
0012A0  1  D0 03                BNE     LAB_NOIN        ; if not go check NMI
0012A2  1               
0012A2  1  4C 62 34             JMP     LAB_SIRQ        ; else go set-up IRQ
0012A5  1               
0012A5  1               LAB_NOIN:
0012A5  1  C9 AA                CMP     #TK_NMI         ; was it NMI token ?
0012A7  1  D0 03                BNE     LAB_NONM        ; if not go do normal ON command
0012A9  1               
0012A9  1  4C 66 34             JMP     LAB_SNMI        ; else go set-up NMI
0012AC  1               
0012AC  1               LAB_NONM:
0012AC  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter
0012AF  1  48                   PHA                     ; push GOTO/GOSUB token
0012B0  1  C9 8D                CMP     #TK_GOSUB       ; compare with GOSUB token
0012B2  1  F0 04                BEQ     LAB_176B        ; branch if GOSUB
0012B4  1               
0012B4  1  C9 89                CMP     #TK_GOTO        ; compare with GOTO token
0012B6  1               LAB_1767:
0012B6  1  D0 E3                BNE     LAB_16FD        ; if not GOTO do syntax error then warm start
0012B8  1               
0012B8  1               
0012B8  1               ; next character was GOTO or GOSUB
0012B8  1               
0012B8  1               LAB_176B:
0012B8  1  C6 AF                DEC     FAC1_3          ; decrement index (byte value)
0012BA  1  D0 04                BNE     LAB_1773        ; branch if not zero
0012BC  1               
0012BC  1  68                   PLA                     ; pull GOTO/GOSUB token
0012BD  1  4C 5C 10             JMP     LAB_1602        ; go execute it
0012C0  1               
0012C0  1               LAB_1773:
0012C0  1                       .IFDEF  DUODYNE
0012C0  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0012C4  1                       .ELSE
0012C4  1                       JSR     LAB_IGBY        ; increment and scan memory
0012C4  1                       .ENDIF
0012C4  1               
0012C4  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer (skip this n)
0012C7  1               ; (we could LDX #',' and JSR LAB_SNBL+2, then we
0012C7  1               ; just BNE LAB_176B for the loop. should be quicker ..
0012C7  1               ; no we can't, what if we meet a colon or [EOL]?)
0012C7  1  C9 2C                CMP     #$2C            ; compare next character with ","
0012C9  1  F0 ED                BEQ     LAB_176B        ; loop if ","
0012CB  1               
0012CB  1               LAB_177E:
0012CB  1  68                   PLA                     ; else pull keyword token (run out of options)
0012CC  1               ; also dump +/-1 pointer low byte and exit
0012CC  1               LAB_177F:
0012CC  1  60                   RTS
0012CD  1               
0012CD  1               ; takes n * 106 + 11 cycles where n is the number of digits
0012CD  1               
0012CD  1               ; get fixed-point number into temp integer
0012CD  1               
0012CD  1               LAB_GFPN:
0012CD  1  A2 00                LDX     #$00            ; clear reg
0012CF  1  86 11                STX     Itempl          ; clear temporary integer low byte
0012D1  1               LAB_1785:
0012D1  1  86 12                STX     Itemph          ; save temporary integer high byte
0012D3  1  B0 F7                BCS     LAB_177F        ; return if carry set, end of scan, character was
0012D5  1               ; not 0-9
0012D5  1               
0012D5  1  E0 19                CPX     #$19            ; compare high byte with $19
0012D7  1  A8                   TAY                     ; ensure Zb = 0 if the branch is taken
0012D8  1  B0 DC                BCS     LAB_1767        ; branch if >=, makes max line # 63999 because next
0012DA  1               ; bit does *$0A, = 64000, compare at target will fail
0012DA  1               ; and do syntax error
0012DA  1               
0012DA  1  E9 2F                SBC     #'0'-1          ; subtract "0", $2F + carry, from byte
0012DC  1  A8                   TAY                     ; copy binary digit
0012DD  1  A5 11                LDA     Itempl          ; get temporary integer low byte
0012DF  1  0A                   ASL     A               ; *2 low byte
0012E0  1  26 12                ROL     Itemph          ; *2 high byte
0012E2  1  0A                   ASL     A               ; *2 low byte
0012E3  1  26 12                ROL     Itemph          ; *2 high byte, *4
0012E5  1  65 11                ADC     Itempl          ; + low byte, *5
0012E7  1  85 11                STA     Itempl          ; save it
0012E9  1  8A                   TXA                     ; get high byte copy to A
0012EA  1  65 12                ADC     Itemph          ; + high byte, *5
0012EC  1  06 11                ASL     Itempl          ; *2 low byte, *10d
0012EE  1  2A                   ROL     A               ; *2 high byte, *10d
0012EF  1  AA                   TAX                     ; copy high byte back to X
0012F0  1  98                   TYA                     ; get binary digit back
0012F1  1  65 11                ADC     Itempl          ; add number low byte
0012F3  1  85 11                STA     Itempl          ; save number low byte
0012F5  1  90 01                BCC     LAB_17B3        ; if no overflow to high byte get next character
0012F7  1               
0012F7  1  E8                   INX                     ; else increment high byte
0012F8  1               LAB_17B3:
0012F8  1                       .IFDEF  DUODYNE
0012F8  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0012FC  1                       .ELSE
0012FC  1                       JSR     LAB_IGBY        ; increment and scan memory
0012FC  1                       .ENDIF
0012FC  1               
0012FC  1  4C D1 12             JMP     LAB_1785        ; loop for next character
0012FF  1               
0012FF  1               ; perform DEC
0012FF  1               
0012FF  1               LAB_DEC:
0012FF  1  A9 0A                LDA     #<LAB_2AFD      ; set -1 pointer low byte
001301  1  2C                   .BYTE   $2C             ; BIT abs to skip the LDA below
001302  1               
001302  1               ; perform INC
001302  1               
001302  1               LAB_INC:
001302  1  A9 06                LDA     #<LAB_259C      ; set 1 pointer low byte
001304  1               LAB_17B5:
001304  1  48                   PHA                     ; save +/-1 pointer low byte
001305  1               LAB_17B7:
001305  1  20 8E 1A             JSR     LAB_GVAR        ; get var address
001308  1  A6 5F                LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
00130A  1  30 20                BMI     IncrErr         ; exit if string
00130C  1               
00130C  1  85 97                STA     Lvarpl          ; save var address low byte
00130E  1  84 98                STY     Lvarph          ; save var address high byte
001310  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
001313  1  68                   PLA                     ; get +/-1 pointer low byte
001314  1  48                   PHA                     ; save +/-1 pointer low byte
001315  1  A0 37                LDY     #>LAB_259C      ; set +/-1 pointer high byte (both the same)
001317  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1
00131A  1  20 85 2C             JSR     LAB_PFAC        ; pack FAC1 into variable (Lvarpl)
00131D  1               
00131D  1                       .IFDEF  DUODYNE
00131D  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001321  1                       .ELSE
001321  1                       JSR     LAB_GBYT        ; scan memory
001321  1                       .ENDIF
001321  1               
001321  1  C9 2C                CMP     #','            ; compare with ","
001323  1  D0 A6                BNE     LAB_177E        ; exit if not "," (either end or error)
001325  1               
001325  1               ; was "," so another INCR variable to do
001325  1                       .IFDEF  DUODYNE
001325  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001329  1                       .ELSE
001329  1                       JSR     LAB_IGBY        ; increment and scan memory
001329  1                       .ENDIF
001329  1               
001329  1  4C 05 13             JMP     LAB_17B7        ; go do next var
00132C  1               
00132C  1               IncrErr:
00132C  1  4C 8C 17             JMP     LAB_1ABC        ; do "Type mismatch" error then warm start
00132F  1               
00132F  1               ; perform LET
00132F  1               
00132F  1               LAB_LET:
00132F  1  20 8E 1A             JSR     LAB_GVAR        ; get var address
001332  1  85 97                STA     Lvarpl          ; save var address low byte
001334  1  84 98                STY     Lvarph          ; save var address high byte
001336  1  A9 C2                LDA     #TK_EQUAL       ; get = token
001338  1  20 A4 18             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00133B  1  A5 5F                LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00133D  1  48                   PHA                     ; push data type flag
00133E  1  20 91 17             JSR     LAB_EVEX        ; evaluate expression
001341  1  68                   PLA                     ; pop data type flag
001342  1  2A                   ROL     A               ; set carry if type = string
001343  1  20 83 17             JSR     LAB_CKTM        ; type match check, set C for string
001346  1  D0 03                BNE     LAB_17D5        ; branch if string
001348  1               
001348  1  4C 85 2C             JMP     LAB_PFAC        ; pack FAC1 into variable (Lvarpl) and return
00134B  1               
00134B  1               ; string LET
00134B  1               
00134B  1               LAB_17D5:
00134B  1  A0 02                LDY     #$02            ; set index to pointer high byte
00134D  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get string pointer high byte
001351  1  B5 AE C9 00  
001355  1  D0 04 A2 00  
001363  1  C5 82                CMP     Sstorh          ; compare bottom of string space high byte
001365  1  90 2B                BCC     LAB_17F4        ; if less assign value and exit (was in program memory)
001367  1               
001367  1  D0 1B                BNE     LAB_17E6        ; branch if >
001369  1               ; else was equal so compare low bytes
001369  1  88                   DEY                     ; decrement index
00136A  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get pointer low byte
00136E  1  B5 AE C9 00  
001372  1  D0 04 A2 00  
001380  1  C5 81                CMP     Sstorl          ; compare bottom of string space low byte
001382  1  90 0E                BCC     LAB_17F4        ; if less assign value and exit (was in program memory)
001384  1               
001384  1               ; pointer was >= to bottom of string space pointer
001384  1               LAB_17E6:
001384  1  A4 AF                LDY     des_ph          ; get descriptor pointer high byte
001386  1  C4 7C                CPY     Svarh           ; compare start of vars high byte
001388  1  90 08                BCC     LAB_17F4        ; branch if less (descriptor is on stack)
00138A  1               
00138A  1  D0 0D                BNE     LAB_17FB        ; branch if greater (descriptor is not on stack)
00138C  1               
00138C  1               ; else high bytes were equal so ..
00138C  1  A5 AE                LDA     des_pl          ; get descriptor pointer low byte
00138E  1  C5 7B                CMP     Svarl           ; compare start of vars low byte
001390  1  B0 07                BCS     LAB_17FB        ; branch if >= (descriptor is not on stack)
001392  1               
001392  1               LAB_17F4:
001392  1  A5 AE                LDA     des_pl          ; get descriptor pointer low byte
001394  1  A4 AF                LDY     des_ph          ; get descriptor pointer high byte
001396  1  4C C3 13             JMP     LAB_1811        ; clean stack, copy descriptor to variable and return
001399  1               
001399  1               ; make space and copy string
001399  1               LAB_17FB:
001399  1  A0 00                LDY     #$00            ; index to length
00139B  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get string length
00139F  1  B5 AE C9 00  
0013A3  1  D0 04 A2 00  
0013B1  1  20 01 21             JSR     LAB_209C        ; copy string
0013B4  1  A5 9E                LDA     des_2l          ; get descriptor pointer low byte
0013B6  1  A4 9F                LDY     des_2h          ; get descriptor pointer high byte
0013B8  1  85 B8                STA     ssptr_l         ; save descriptor pointer low byte
0013BA  1  84 B9                STY     ssptr_h         ; save descriptor pointer high byte
0013BC  1  20 01 24             JSR     LAB_228A        ; copy string from descriptor (sdescr) to (Sutill)
0013BF  1  A9 AC                LDA     #<FAC1_e        ; set descriptor pointer low byte
0013C1  1  A0 00                LDY     #>FAC1_e        ; get descriptor pointer high byte
0013C3  1               
0013C3  1               ; clean stack and assign value to string variable
0013C3  1               LAB_1811:
0013C3  1  85 9E                STA     des_2l          ; save descriptor_2 pointer low byte
0013C5  1  84 9F                STY     des_2h          ; save descriptor_2 pointer high byte
0013C7  1  20 03 25             JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
0013CA  1  A0 00                LDY     #$00            ; index to length
0013CC  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string length
0013D0  1  B5 9E C9 00  
0013D4  1  D0 04 A2 00  
0013E2  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
0013E6  1  01 B5 97 C9  
0013EA  1  00 D0 04 A2  
0013F8  1  C8                   INY                     ; index to string pointer low byte
0013F9  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string pointer low byte
0013FD  1  B5 9E C9 00  
001401  1  D0 04 A2 00  
00140F  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
001413  1  01 B5 97 C9  
001417  1  00 D0 04 A2  
001425  1  C8                   INY                     ; index to string pointer high byte
001426  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string pointer high byte
00142A  1  B5 9E C9 00  
00142E  1  D0 04 A2 00  
00143C  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
001440  1  01 B5 97 C9  
001444  1  00 D0 04 A2  
001452  1  60                   RTS
001453  1               
001453  1               ; perform GET
001453  1               
001453  1               LAB_GET:
001453  1  20 8E 1A             JSR     LAB_GVAR        ; get var address
001456  1  85 97                STA     Lvarpl          ; save var address low byte
001458  1  84 98                STY     Lvarph          ; save var address high byte
00145A  1  20 28 34             JSR     INGET           ; get input byte
00145D  1  A6 5F                LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
00145F  1  30 07                BMI     LAB_GETS        ; go get string character
001461  1               
001461  1               ; was numeric get
001461  1  A8                   TAY                     ; copy character to Y
001462  1  20 7D 1F             JSR     LAB_1FD0        ; convert Y to byte in FAC1
001465  1  4C 85 2C             JMP     LAB_PFAC        ; pack FAC1 into variable (Lvarpl) and return
001468  1               
001468  1               LAB_GETS:
001468  1  48                   PHA                     ; save character
001469  1  A9 01                LDA     #$01            ; string is single byte
00146B  1  B0 01                BCS     LAB_IsByte      ; branch if byte received
00146D  1               
00146D  1  68                   PLA                     ; string is null
00146E  1               LAB_IsByte:
00146E  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
001471  1               ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
001471  1  F0 19                BEQ     LAB_NoSt        ; skip store if null string
001473  1               
001473  1  68                   PLA                     ; get character back
001474  1  A0 00                LDY     #$00            ; clear index
001476  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save byte in string (byte IS string!)
00147A  1  01 B5 AD C9  
00147E  1  00 D0 04 A2  
00148C  1               LAB_NoSt:
00148C  1  20 68 21             JSR     LAB_RTST        ; check for space on descriptor stack then put address
00148F  1               ; and length on descriptor stack and update stack pointers
00148F  1               
00148F  1  4C 4B 13             JMP     LAB_17D5        ; do string LET and return
001492  1               
001492  1               ; perform PRINT
001492  1               
001492  1               LAB_1829:
001492  1  20 37 15             JSR     LAB_18C6        ; print string from Sutill/Sutilh
001495  1               LAB_182C:
001495  1                       .IFDEF  DUODYNE
001495  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001499  1                       .ELSE
001499  1                       JSR     LAB_GBYT        ; scan memory
001499  1                       .ENDIF
001499  1               
001499  1               
001499  1               ; PRINT
001499  1               
001499  1               LAB_PRINT:
001499  1  F0 51                BEQ     LAB_CRLF        ; if nothing following just print CR/LF
00149B  1               
00149B  1               LAB_1831:
00149B  1  C9 AC                CMP     #TK_TAB         ; compare with TAB( token
00149D  1  F0 6C                BEQ     LAB_18A2        ; go do TAB/SPC
00149F  1               
00149F  1  C9 B0                CMP     #TK_SPC         ; compare with SPC( token
0014A1  1  F0 68                BEQ     LAB_18A2        ; go do TAB/SPC
0014A3  1               
0014A3  1  C9 2C                CMP     #','            ; compare with ","
0014A5  1  F0 4E                BEQ     LAB_188B        ; go do move to next TAB mark
0014A7  1               
0014A7  1  C9 3B                CMP     #$3B            ; compare with ";"
0014A9  1  F0 7F                BEQ     LAB_18BD        ; if ";" continue with PRINT processing
0014AB  1               
0014AB  1  20 91 17             JSR     LAB_EVEX        ; evaluate expression
0014AE  1  24 5F                BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
0014B0  1  30 E0                BMI     LAB_1829        ; branch if string
0014B2  1               
0014B2  1  20 49 2F             JSR     LAB_296E        ; convert FAC1 to string
0014B5  1  20 13 21             JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh
0014B8  1  A0 00                LDY     #$00            ; clear index
0014BA  1               
0014BA  1               ; don't check fit if terminal width byte is zero
0014BA  1               
0014BA  1  A5 0F                LDA     TWidth          ; get terminal width byte
0014BC  1  F0 20                BEQ     LAB_185E        ; skip check if zero
0014BE  1                       .IFDEF  DUODYNE
0014BE  1  8B 48 DA A2          FETCHINDIRECTY des_pl   ; subtract string length
0014C2  1  01 B5 AE C9  
0014C6  1  00 D0 04 A2  
0014D4  1  38                   SEC                     ; set carry for subtract
0014D5  1  E5 0E                SBC     TPos            ; subtract terminal position
0014D7  1  E5 04                SBC     <TMPFLG         ; subtract string length
0014D9  1                       .ELSE
0014D9  1                       SEC                     ; set carry for subtract
0014D9  1                       SBC     TPos            ; subtract terminal position
0014D9  1                       SBC     (des_pl),Y      ; subtract string length
0014D9  1                       .ENDIF
0014D9  1  B0 03                BCS     LAB_185E        ; branch if less than terminal width
0014DB  1  20 EC 14             JSR     LAB_CRLF        ; else print CR/LF
0014DE  1               LAB_185E:
0014DE  1  20 37 15             JSR     LAB_18C6        ; print string from Sutill/Sutilh
0014E1  1  F0 B2                BEQ     LAB_182C        ; always go continue processing line
0014E3  1               
0014E3  1               ; CR/LF return to BASIC from BASIC input handler
0014E3  1               
0014E3  1               LAB_1866:
0014E3  1  A9 00                LDA     #$00            ; clear byte
0014E5  1  9D 81 41             STA     Ibuffs,X        ; null terminate input
0014E8  1  A2 81                LDX     #<Ibuffs        ; set X to buffer start-1 low byte
0014EA  1  A0 41                LDY     #>Ibuffs        ; set Y to buffer start-1 high byte
0014EC  1               
0014EC  1               ; print CR/LF
0014EC  1               
0014EC  1               LAB_CRLF:
0014EC  1  A9 0D                LDA     #$0D            ; load [CR]
0014EE  1  20 62 15             JSR     LAB_PRNA        ; go print the character
0014F1  1  A9 0A                LDA     #$0A            ; load [LF]
0014F3  1  D0 6D                BNE     LAB_PRNA        ; go print the character and return, branch always
0014F5  1               
0014F5  1               LAB_188B:
0014F5  1  A5 0E                LDA     TPos            ; get terminal position
0014F7  1  C5 10                CMP     Iclim           ; compare with input column limit
0014F9  1  90 05                BCC     LAB_1897        ; branch if less
0014FB  1               
0014FB  1  20 EC 14             JSR     LAB_CRLF        ; else print CR/LF (next line)
0014FE  1  D0 2A                BNE     LAB_18BD        ; continue with PRINT processing (branch always)
001500  1               
001500  1               LAB_1897:
001500  1  38                   SEC                     ; set carry for subtract
001501  1               LAB_1898:
001501  1  E5 64                SBC     TabSiz          ; subtract TAB size
001503  1  B0 FC                BCS     LAB_1898        ; loop if result was +ve
001505  1               
001505  1  49 FF                EOR     #$FF            ; complement it
001507  1  69 01                ADC     #$01            ; +1 (twos complement)
001509  1  D0 15                BNE     LAB_18B6        ; always print A spaces (result is never $00)
00150B  1               
00150B  1               ; do TAB/SPC
00150B  1               LAB_18A2:
00150B  1  48                   PHA                     ; save token
00150C  1  20 17 27             JSR     LAB_SGBY        ; scan and get byte parameter
00150F  1  C9 29                CMP     #$29            ; is next character )
001511  1  F0 03 4C A9          LBNE    LAB_1910        ; if not do syntax error then warm start
001515  1  15           
001516  1               
001516  1  68                   PLA                     ; get token back
001517  1  C9 AC                CMP     #TK_TAB         ; was it TAB ?
001519  1  D0 06                BNE     LAB_18B7        ; if not go do SPC
00151B  1               
00151B  1               ; calculate TAB offset
00151B  1  8A                   TXA                     ; copy integer value to A
00151C  1  E5 0E                SBC     TPos            ; subtract terminal position
00151E  1  90 0A                BCC     LAB_18BD        ; branch if result was < 0 (can't TAB backwards)
001520  1               
001520  1               ; print A spaces
001520  1               LAB_18B6:
001520  1  AA                   TAX                     ; copy result to X
001521  1               LAB_18B7:
001521  1  8A                   TXA                     ; set flags on size for SPC
001522  1  F0 06                BEQ     LAB_18BD        ; branch if result was = $0, already here
001524  1               
001524  1               ; print X spaces
001524  1               LAB_18BA:
001524  1  20 5D 15             JSR     LAB_18E0        ; print " "
001527  1  CA                   DEX                     ; decrement count
001528  1  D0 FA                BNE     LAB_18BA        ; loop if not all done
00152A  1               
00152A  1               ; continue with PRINT processing
00152A  1               LAB_18BD:
00152A  1                       .IFDEF  DUODYNE
00152A  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00152E  1                       .ELSE
00152E  1                       JSR     LAB_IGBY        ; increment and scan memory
00152E  1                       .ENDIF
00152E  1               
00152E  1  F0 03 4C 9B          LBNE    LAB_1831        ; if more to print go do it
001532  1  14           
001533  1               
001533  1  60                   RTS
001534  1               
001534  1               ; print null terminated string from memory
001534  1               
001534  1               LAB_18C3:
001534  1  20 13 21             JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh
001537  1               
001537  1               ; print string from Sutill/Sutilh
001537  1               
001537  1               LAB_18C6:
001537  1  20 92 24             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
00153A  1               ; space returns with A = length, X=$71=pointer low byte,
00153A  1               ; Y=$72=pointer high byte
00153A  1  A0 00                LDY     #$00            ; reset index
00153C  1  AA                   TAX                     ; copy length to X
00153D  1  F0 5D                BEQ     LAB_188C        ; exit (RTS) if null string
00153F  1               
00153F  1               LAB_18CD:
00153F  1               
00153F  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get next byte
001543  1  B5 71 C9 00  
001547  1  D0 04 A2 00  
001555  1  20 62 15             JSR     LAB_PRNA        ; go print the character
001558  1  C8                   INY                     ; increment index
001559  1  CA                   DEX                     ; decrement count
00155A  1  D0 E3                BNE     LAB_18CD        ; loop if not done yet
00155C  1               
00155C  1  60                   RTS
00155D  1               
00155D  1               ; Print single format character
00155D  1               ; print " "
00155D  1               
00155D  1               LAB_18E0:
00155D  1  A9 20                LDA     #$20            ; load " "
00155F  1  2C                   .BYTE   $2C             ; change next line to BIT LAB_3FA9
001560  1               
001560  1               ; print "?" character
001560  1               
001560  1               LAB_18E3:
001560  1  A9 3F                LDA     #$3F            ; load "?" character
001562  1               
001562  1               ; print character in A
001562  1               ; now includes the null handler
001562  1               ; also includes infinite line length code
001562  1               ; note! some routines expect this one to exit with Zb=0
001562  1               
001562  1               LAB_PRNA:
001562  1  C9 20                CMP     #' '            ; compare with " "
001564  1  90 19                BCC     LAB_18F9        ; branch if less (non printing)
001566  1               
001566  1               ; else printable character
001566  1  48                   PHA                     ; save the character
001567  1               
001567  1               ; don't check fit if terminal width byte is zero
001567  1               
001567  1  A5 0F                LDA     TWidth          ; get terminal width
001569  1  D0 0A                BNE     LAB_18F0        ; branch if not zero (not infinite length)
00156B  1               
00156B  1               ; is "infinite line" so check TAB position
00156B  1               
00156B  1  A5 0E                LDA     TPos            ; get position
00156D  1  E5 64                SBC     TabSiz          ; subtract TAB size, carry set by CMP #$20 above
00156F  1  D0 0B                BNE     LAB_18F7        ; skip reset if different
001571  1               
001571  1  85 0E                STA     TPos            ; else reset position
001573  1  F0 07                BEQ     LAB_18F7        ; go print character
001575  1               
001575  1               LAB_18F0:
001575  1  C5 0E                CMP     TPos            ; compare with terminal character position
001577  1  D0 03                BNE     LAB_18F7        ; branch if not at end of line
001579  1               
001579  1  20 EC 14             JSR     LAB_CRLF        ; else print CR/LF
00157C  1               LAB_18F7:
00157C  1  E6 0E                INC     TPos            ; increment terminal position
00157E  1  68                   PLA                     ; get character back
00157F  1               LAB_18F9:
00157F  1  20 7C 3D             JSR     V_OUTP          ; output byte via output vector
001582  1  C9 0D                CMP     #$0D            ; compare with [CR]
001584  1  D0 14                BNE     LAB_188A        ; branch if not [CR]
001586  1               
001586  1               ; else print nullct nulls after the [CR]
001586  1  86 78                STX     TempB           ; save buffer index
001588  1  A6 0D                LDX     Nullct          ; get null count
00158A  1  F0 0A                BEQ     LAB_1886        ; branch if no nulls
00158C  1               
00158C  1  A9 00                LDA     #$00            ; load [NULL]
00158E  1               LAB_1880:
00158E  1  20 62 15             JSR     LAB_PRNA        ; go print the character
001591  1  CA                   DEX                     ; decrement count
001592  1  D0 FA                BNE     LAB_1880        ; loop if not all done
001594  1               
001594  1  A9 0D                LDA     #$0D            ; restore the character (and set the flags)
001596  1               LAB_1886:
001596  1  86 0E                STX     TPos            ; clear terminal position (X always = zero when we get here)
001598  1  A6 78                LDX     TempB           ; restore buffer index
00159A  1               LAB_188A:
00159A  1  29 FF                AND     #$FF            ; set the flags
00159C  1               LAB_188C:
00159C  1  60                   RTS
00159D  1               
00159D  1               ; handle bad input data
00159D  1               
00159D  1               LAB_1904:
00159D  1  A5 62                LDA     Imode           ; get input mode flag, $00=INPUT, $00=READ
00159F  1  10 0B                BPL     LAB_1913        ; branch if INPUT (go do redo)
0015A1  1               
0015A1  1  A5 8D                LDA     Dlinel          ; get current DATA line low byte
0015A3  1  A4 8E                LDY     Dlineh          ; get current DATA line high byte
0015A5  1  85 87                STA     Clinel          ; save current line low byte
0015A7  1  84 88                STY     Clineh          ; save current line high byte
0015A9  1               LAB_1910:
0015A9  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
0015AC  1               
0015AC  1               ; mode was INPUT
0015AC  1               LAB_1913:
0015AC  1  A9 45                LDA     #<LAB_REDO      ; point to redo message (low addr)
0015AE  1  A0 3D                LDY     #>LAB_REDO      ; point to redo message (high addr)
0015B0  1  20 34 15             JSR     LAB_18C3        ; print null terminated string from memory
0015B3  1  A5 8B                LDA     Cpntrl          ; get continue pointer low byte
0015B5  1  A4 8C                LDY     Cpntrh          ; get continue pointer high byte
0015B7  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
0015B9  1  84 C4                STY     Bpntrh          ; save BASIC execute pointer high byte
0015BB  1  60                   RTS
0015BC  1               
0015BC  1               ; perform INPUT
0015BC  1               
0015BC  1               LAB_INPUT:
0015BC  1  C9 22                CMP     #$22            ; compare next byte with open quote
0015BE  1  D0 0B                BNE     LAB_1934        ; branch if no prompt string
0015C0  1               
0015C0  1  20 70 18             JSR     LAB_1BC1        ; print "..." string
0015C3  1  A9 3B                LDA     #$3B            ; load A with ";"
0015C5  1  20 A4 18             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
0015C8  1  20 37 15             JSR     LAB_18C6        ; print string from Sutill/Sutilh
0015CB  1               
0015CB  1               ; done with prompt, now get data
0015CB  1               LAB_1934:
0015CB  1  20 81 1F             JSR     LAB_CKRN        ; check not Direct, back here if ok
0015CE  1  20 C7 0B             JSR     LAB_INLN        ; print "? " and get BASIC input
0015D1  1  A9 00                LDA     #$00            ; set mode = INPUT
0015D3  1  CD 81 41             CMP     Ibuffs          ; test first byte in buffer
0015D6  1  D0 0A                BNE     LAB_1953        ; branch if not null input
0015D8  1               
0015D8  1  18                   CLC                     ; was null input so clear carry to exit program
0015D9  1  4C 91 10             JMP     LAB_1647        ; go do BREAK exit
0015DC  1               
0015DC  1               ; perform READ
0015DC  1               
0015DC  1               LAB_READ:
0015DC  1  A6 8F                LDX     Dptrl           ; get DATA pointer low byte
0015DE  1  A4 90                LDY     Dptrh           ; get DATA pointer high byte
0015E0  1  A9 80                LDA     #$80            ; set mode = READ
0015E2  1               
0015E2  1               LAB_1953:
0015E2  1  85 62                STA     Imode           ; set input mode flag, $00=INPUT, $80=READ
0015E4  1  86 91                STX     Rdptrl          ; save READ pointer low byte
0015E6  1  84 92                STY     Rdptrh          ; save READ pointer high byte
0015E8  1               
0015E8  1               ; READ or INPUT next variable from list
0015E8  1               LAB_195B:
0015E8  1  20 8E 1A             JSR     LAB_GVAR        ; get (var) address
0015EB  1  85 97                STA     Lvarpl          ; save address low byte
0015ED  1  84 98                STY     Lvarph          ; save address high byte
0015EF  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
0015F1  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte
0015F3  1  85 11                STA     Itempl          ; save as temporary integer low byte
0015F5  1  84 12                STY     Itemph          ; save as temporary integer high byte
0015F7  1  A6 91                LDX     Rdptrl          ; get READ pointer low byte
0015F9  1  A4 92                LDY     Rdptrh          ; get READ pointer high byte
0015FB  1  86 C3                STX     Bpntrl          ; set BASIC execute pointer low byte
0015FD  1  84 C4                STY     Bpntrh          ; set BASIC execute pointer high byte
0015FF  1                       .IFDEF  DUODYNE
0015FF  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001603  1                       .ELSE
001603  1                       JSR     LAB_GBYT        ; scan memory
001603  1                       .ENDIF
001603  1               
001603  1  D0 12                BNE     LAB_1988        ; branch if not null
001605  1               
001605  1               ; pointer was to null entry
001605  1  24 62                BIT     Imode           ; test input mode flag, $00=INPUT, $80=READ
001607  1  30 6C                BMI     LAB_19DD        ; branch if READ
001609  1               
001609  1               ; mode was INPUT
001609  1  20 60 15             JSR     LAB_18E3        ; print "?" character (double ? for extended input)
00160C  1  20 C7 0B             JSR     LAB_INLN        ; print "? " and get BASIC input
00160F  1  86 C3                STX     Bpntrl          ; set BASIC execute pointer low byte
001611  1  84 C4                STY     Bpntrh          ; set BASIC execute pointer high byte
001613  1               LAB_1985:
001613  1                       .IFDEF  DUODYNE
001613  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001617  1                       .ELSE
001617  1                       JSR     LAB_GBYT        ; scan memory
001617  1                       .ENDIF
001617  1               
001617  1               LAB_1988:
001617  1  24 5F                BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
001619  1  10 24                BPL     LAB_19B0        ; branch if numeric
00161B  1               
00161B  1               ; else get string
00161B  1  85 5B                STA     Srchc           ; save search character
00161D  1  C9 22                CMP     #$22            ; was it " ?
00161F  1  F0 07                BEQ     LAB_1999        ; branch if so
001621  1               
001621  1  A9 3A                LDA     #':'            ; else search character is ":"
001623  1  85 5B                STA     Srchc           ; set new search character
001625  1  A9 2C                LDA     #','            ; other search character is ","
001627  1  18                   CLC                     ; clear carry for add
001628  1               LAB_1999:
001628  1  85 5C                STA     Asrch           ; set second search character
00162A  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
00162C  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte
00162E  1               
00162E  1  69 00                ADC     #$00            ; c is =1 if we came via the BEQ LAB_1999, else =0
001630  1  90 01                BCC     LAB_19A4        ; branch if no execute pointer low byte rollover
001632  1               
001632  1  C8                   INY                     ; else increment high byte
001633  1               LAB_19A4:
001633  1  20 19 21             JSR     LAB_20B4        ; print Srchc or Asrch terminated string to Sutill/Sutilh
001636  1  20 9D 27             JSR     LAB_23F3        ; restore BASIC execute pointer from temp (Btmpl/Btmph)
001639  1  20 4B 13             JSR     LAB_17D5        ; go do string LET
00163C  1  4C 45 16             JMP     LAB_19B6        ; go check string terminator
00163F  1               
00163F  1               ; get numeric INPUT
00163F  1               LAB_19B0:
00163F  1  20 3C 2E             JSR     LAB_2887        ; get FAC1 from string
001642  1  20 85 2C             JSR     LAB_PFAC        ; pack FAC1 into (Lvarpl)
001645  1               LAB_19B6:
001645  1                       .IFDEF  DUODYNE
001645  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001649  1                       .ELSE
001649  1                       JSR     LAB_GBYT        ; scan memory
001649  1                       .ENDIF
001649  1               
001649  1  F0 0B                BEQ     LAB_19C5        ; branch if null (last entry)
00164B  1               
00164B  1  C9 2C                CMP     #','            ; else compare with ","
00164D  1  F0 03                BEQ     LAB_19C2        ; branch if ","
00164F  1               
00164F  1  4C 9D 15             JMP     LAB_1904        ; else go handle bad input data
001652  1               
001652  1               ; got good input data
001652  1               LAB_19C2:
001652  1                       .IFDEF  DUODYNE
001652  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001656  1                       .ELSE
001656  1                       JSR     LAB_IGBY        ; increment and scan memory
001656  1                       .ENDIF
001656  1               
001656  1               LAB_19C5:
001656  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
001658  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00165A  1  85 91                STA     Rdptrl          ; save for now
00165C  1  84 92                STY     Rdptrh          ; save for now
00165E  1  A5 11                LDA     Itempl          ; get temporary integer low byte (temp BASIC execute ptr)
001660  1  A4 12                LDY     Itemph          ; get temporary integer high byte (temp BASIC execute ptr)
001662  1  85 C3                STA     Bpntrl          ; set BASIC execute pointer low byte
001664  1  84 C4                STY     Bpntrh          ; set BASIC execute pointer high byte
001666  1                       .IFDEF  DUODYNE
001666  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00166A  1                       .ELSE
00166A  1                       JSR     LAB_GBYT        ; scan memory
00166A  1                       .ENDIF
00166A  1               
00166A  1  D0 03 4C A1          LBEQ    LAB_1A03        ; if null go do extra ignored message
00166E  1  16           
00166F  1               
00166F  1  20 B3 18             JSR     LAB_1C01        ; else scan for "," , else do syntax error then warm start
001672  1  4C E8 15             JMP     LAB_195B        ; go INPUT next variable from list
001675  1               
001675  1               ; find next DATA statement or do "Out of DATA" error
001675  1               LAB_19DD:
001675  1  20 0D 12             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
001678  1  C8                   INY                     ; increment index
001679  1  AA                   TAX                     ; copy character ([:] or [EOL])
00167A  1  D0 15                BNE     LAB_19F6        ; branch if [:]
00167C  1               
00167C  1  A2 06                LDX     #$06            ; set for "Out of DATA" error
00167E  1  C8                   INY                     ; increment index, now points to next line pointer high byte
00167F  1  B1 C3                LDA     (Bpntrl),Y      ; get next line pointer high byte
001681  1  D0 03 4C 0F          LBEQ    LAB_1A54        ; branch if end (eventually does error X)
001685  1  17           
001686  1               
001686  1  C8                   INY                     ; increment index
001687  1  B1 C3                LDA     (Bpntrl),Y      ; get next line # low byte
001689  1  85 8D                STA     Dlinel          ; save current DATA line low byte
00168B  1  C8                   INY                     ; increment index
00168C  1  B1 C3                LDA     (Bpntrl),Y      ; get next line # high byte
00168E  1  C8                   INY                     ; increment index
00168F  1  85 8E                STA     Dlineh          ; save current DATA line high byte
001691  1               LAB_19F6:
001691  1  B1 C3                LDA     (Bpntrl),Y      ; get byte
001693  1  C8                   INY                     ; increment index
001694  1  AA                   TAX                     ; copy to X
001695  1  20 FF 11             JSR     LAB_170F        ; set BASIC execute pointer
001698  1  E0 83                CPX     #TK_DATA        ; compare with "DATA" token
00169A  1  D0 03 4C 13          LBEQ    LAB_1985        ; was "DATA" so go do next READ
00169E  1  16           
00169F  1               
00169F  1  D0 D4                BNE     LAB_19DD        ; go find next statement if not "DATA"
0016A1  1               
0016A1  1               ; end of INPUT/READ routine
0016A1  1               
0016A1  1               LAB_1A03:
0016A1  1  A5 91                LDA     Rdptrl          ; get temp READ pointer low byte
0016A3  1  A4 92                LDY     Rdptrh          ; get temp READ pointer high byte
0016A5  1  A6 62                LDX     Imode           ; get input mode flag, $00=INPUT, $80=READ
0016A7  1  10 03                BPL     LAB_1A0E        ; branch if INPUT
0016A9  1               
0016A9  1  4C B3 10             JMP     LAB_1624        ; save AY as DATA pointer and return
0016AC  1               
0016AC  1               ; we were getting INPUT
0016AC  1               LAB_1A0E:
0016AC  1  A0 00                LDY     #$00            ; clear index
0016AE  1  8B DA A2 01          LDAINDIRECTY Rdptrl     ; get next byte
0016B2  1  B5 91 C9 00  
0016B6  1  D0 04 A2 00  
0016C4  1  D0 01                BNE     LAB_1A1B        ; error if not end of INPUT
0016C6  1               
0016C6  1  60                   RTS
0016C7  1               
0016C7  1               ; user typed too much
0016C7  1               LAB_1A1B:
0016C7  1  A9 34                LDA     #<LAB_IMSG      ; point to extra ignored message (low addr)
0016C9  1  A0 3D                LDY     #>LAB_IMSG      ; point to extra ignored message (high addr)
0016CB  1  4C 34 15             JMP     LAB_18C3        ; print null terminated string from memory and return
0016CE  1               
0016CE  1               ; search the stack for FOR activity
0016CE  1               ; exit with z=1 if FOR else exit with z=0
0016CE  1               
0016CE  1               LAB_11A1:
0016CE  1                       .IFDEF  DUODYNE
0016CE  1  C2 10                INDEX16
0016D0  1                       .ENDIF
0016D0  1  BA                   TSX                     ; copy stack pointer
0016D1  1  E8                   INX                     ; +1 pass return address
0016D2  1  E8                   INX                     ; +2 pass return address
0016D3  1  E8                   INX                     ; +3 pass calling routine return address
0016D4  1  E8                   INX                     ; +4 pass calling routine return address
0016D5  1               LAB_11A6:
0016D5  1                       .IFDEF  DUODYNE
0016D5  1  B5 01                LDA     1,X             ; get token byte from stack
0016D7  1                       .ELSE
0016D7  1                       LDA     LAB_STAK+1,X    ; get token byte from stack
0016D7  1                       .ENDIF
0016D7  1  C9 81                CMP     #TK_FOR         ; is it FOR token
0016D9  1  D0 1F                BNE     LAB_11CE        ; exit if not FOR token
0016DB  1               
0016DB  1               ; was FOR token
0016DB  1  A5 98                LDA     Frnxth          ; get var pointer for FOR/NEXT high byte
0016DD  1  D0 08                BNE     LAB_11BB        ; branch if not null
0016DF  1                       .IFDEF  DUODYNE
0016DF  1  B5 02                LDA     2,X             ; get FOR variable pointer low byte
0016E1  1                       .ELSE
0016E1  1                       LDA     LAB_STAK+2,X    ; get FOR variable pointer low byte
0016E1  1                       .ENDIF
0016E1  1  85 97                STA     Frnxtl          ; save var pointer for FOR/NEXT low byte
0016E3  1                       .IFDEF  DUODYNE
0016E3  1  B5 03                LDA     3,X             ; get FOR variable pointer high byte
0016E5  1                       .ELSE
0016E5  1                       LDA     LAB_STAK+3,X    ; get FOR variable pointer high byte
0016E5  1                       .ENDIF
0016E5  1  85 98                STA     Frnxth          ; save var pointer for FOR/NEXT high byte
0016E7  1               LAB_11BB:
0016E7  1                       .IFDEF  DUODYNE
0016E7  1  D5 03                CMP     3,X             ; compare var pointer with stacked var pointer (high byte)
0016E9  1                       .ELSE
0016E9  1                       CMP     LAB_STAK+3,X    ; compare var pointer with stacked var pointer (high byte)
0016E9  1                       .ENDIF
0016E9  1  D0 06                BNE     LAB_11C7        ; branch if no match
0016EB  1               
0016EB  1  A5 97                LDA     Frnxtl          ; get var pointer for FOR/NEXT low byte
0016ED  1                       .IFDEF  DUODYNE
0016ED  1  D5 02                CMP     2,X             ; compare var pointer with stacked var pointer (low byte)
0016EF  1                       .ELSE
0016EF  1                       CMP     LAB_STAK+2,X    ; compare var pointer with stacked var pointer (low byte)
0016EF  1                       .ENDIF
0016EF  1  F0 09                BEQ     LAB_11CE        ; exit if match found
0016F1  1               
0016F1  1               LAB_11C7:
0016F1  1                       .IFDEF  DUODYNE
0016F1  1  E2 10                INDEX8
0016F3  1                       .ENDIF
0016F3  1  8A                   TXA                     ; copy index
0016F4  1  18                   CLC                     ; clear carry for add
0016F5  1  69 10                ADC     #$10            ; add FOR stack use size
0016F7  1  AA                   TAX                     ; copy back to index
0016F8  1  D0 DB                BNE     LAB_11A6        ; loop if not at start of stack
0016FA  1               
0016FA  1               LAB_11CE:
0016FA  1  60                   RTS
0016FB  1               
0016FB  1               ; perform NEXT
0016FB  1               
0016FB  1               LAB_NEXT:
0016FB  1  D0 04                BNE     LAB_1A46        ; branch if NEXT var
0016FD  1               
0016FD  1  A0 00                LDY     #$00            ; else clear Y
0016FF  1  F0 03                BEQ     LAB_1A49        ; branch always (no variable to search for)
001701  1               
001701  1               ; NEXT var
001701  1               
001701  1               LAB_1A46:
001701  1  20 8E 1A             JSR     LAB_GVAR        ; get variable address
001704  1               LAB_1A49:
001704  1  85 97                STA     Frnxtl          ; store variable pointer low byte
001706  1  84 98                STY     Frnxth          ; store variable pointer high byte
001708  1               ; (both cleared if no variable defined)
001708  1  20 CE 16             JSR     LAB_11A1        ; search the stack for FOR activity
00170B  1  F0 04                BEQ     LAB_1A56        ; branch if found
00170D  1               
00170D  1  A2 00                LDX     #$00            ; else set error $00 ("NEXT without FOR" error)
00170F  1               LAB_1A54:
00170F  1  F0 7D                BEQ     LAB_1ABE        ; do error #X, then warm start
001711  1               
001711  1               LAB_1A56:
001711  1                       .IFDEF  DUODYNE
001711  1  C2 30                ACCUMULATORINDEX16
001713  1  A6 FD                LDX     <TEMPW
001715  1  9A                   TXS                     ; set stack pointer, X set by search, dumps return addresses
001716  1  8A                   TXA                     ; copy stack pointer
001717  1  18                   CLC                     ; CLEAR carry
001718  1  69 09 00             ADC     #$0009          ; point to TO var
00171B  1  85 73                STA     <ut2_pl         ; save pointer to TO var for compare
00171D  1  38                   SEC
00171E  1  E9 05 00             SBC     #$0005          ; point to STEP var
001721  1  85 FD                STA     <TEMPW
001723  1               
001723  1  E2 30                ACCUMULATORINDEX8
001725  1  A4 FE                LDY     <TEMPW+1        ; point to stack page high byte
001727  1               
001727  1  8B                   PHB                     ; ensure UNPACK works in stack bank not data bank
001728  1  DA                   PHX
001729  1  A2 00                LDX     #$00
00172B  1  DA                   PHX
00172C  1  AB                   PLB
00172D  1  FA                   PLX
00172E  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (STEP value) into FAC1
001731  1  AB                   PLB
001732  1               
001732  1  A3 08                LDA     8,S             ; get step sign
001734  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
001736  1  A5 97                LDA     <Frnxtl         ; get FOR variable pointer low byte
001738  1  A4 98                LDY     <Frnxth         ; get FOR variable pointer high byte
00173A  1  20 FA 28             JSR     LAB_246C        ; add (FOR variable) to FAC1
00173D  1  20 85 2C             JSR     LAB_PFAC        ; pack FAC1 into (FOR variable)
001740  1  A4 FE                LDY     <TEMPW+1        ; point to stack page high byte
001742  1               
001742  1  8B                   PHB                     ; ensure compare works in stack bank not data bank
001743  1  DA                   PHX
001744  1  A2 00                LDX     #$00
001746  1  DA                   PHX
001747  1  AB                   PLB
001748  1  FA                   PLX
001749  1               
001749  1  20 4B 2D             JSR     LAB_27FA        ; compare FAC1 with (Y,<ut2_pl) (TO value)
00174C  1  AB                   PLB
00174D  1                       .ELSE
00174D  1                       TXS                     ; set stack pointer, X set by search, dumps return addresses
00174D  1               
00174D  1                       TXA                     ; copy stack pointer
00174D  1                       SEC                     ; set carry for subtract
00174D  1                       SBC     #$F7            ; point to TO var
00174D  1                       STA     ut2_pl          ; save pointer to TO var for compare
00174D  1                       ADC     #$FB            ; point to STEP var
00174D  1               
00174D  1                       LDY     #>LAB_STAK      ; point to stack page high byte
00174D  1                       JSR     LAB_UFAC        ; unpack memory (STEP value) into FAC1
00174D  1                       TSX                     ; get stack pointer back
00174D  1                       LDA     LAB_STAK+8,X    ; get step sign
00174D  1                       STA     FAC1_s          ; save FAC1 sign (b7)
00174D  1                       LDA     Frnxtl          ; get FOR variable pointer low byte
00174D  1                       LDY     Frnxth          ; get FOR variable pointer high byte
00174D  1                       JSR     LAB_246C        ; add (FOR variable) to FAC1
00174D  1                       JSR     LAB_PFAC        ; pack FAC1 into (FOR variable)
00174D  1                       LDY     #>LAB_STAK      ; point to stack page high byte
00174D  1                       JSR     LAB_27FA        ; compare FAC1 with (Y,ut2_pl) (TO value)
00174D  1                       TSX                     ; get stack pointer back
00174D  1                       .ENDIF
00174D  1  DD 08 01             CMP     LAB_STAK+8,X    ; compare step sign
001750  1  F0 17                BEQ     LAB_1A9B        ; branch if = (loop complete)
001752  1               
001752  1               ; loop back and do it all again
001752  1  BD 0D 01             LDA     LAB_STAK+$0D,X  ; get FOR line low byte
001755  1  85 87                STA     Clinel          ; save current line low byte
001757  1  BD 0E 01             LDA     LAB_STAK+$0E,X  ; get FOR line high byte
00175A  1  85 88                STA     Clineh          ; save current line high byte
00175C  1  BD 10 01             LDA     LAB_STAK+$10,X  ; get BASIC execute pointer low byte
00175F  1  85 C3                STA     Bpntrl          ; save BASIC execute pointer low byte
001761  1  BD 0F 01             LDA     LAB_STAK+$0F,X  ; get BASIC execute pointer high byte
001764  1  85 C4                STA     Bpntrh          ; save BASIC execute pointer high byte
001766  1               LAB_1A98:
001766  1  4C 16 10             JMP     LAB_15C2        ; go do interpreter inner loop
001769  1               
001769  1               ; loop complete so carry on
001769  1               LAB_1A9B:
001769  1  8A                   TXA                     ; stack copy to A
00176A  1  69 0F                ADC     #$0F            ; add $10 ($0F+carry) to dump FOR structure
00176C  1  AA                   TAX                     ; copy back to index
00176D  1  9A                   TXS                     ; copy to stack pointer
00176E  1                       .IFDEF  DUODYNE
00176E  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001772  1                       .ELSE
001772  1                       JSR     LAB_GBYT        ; scan memory
001772  1                       .ENDIF
001772  1               
001772  1  C9 2C                CMP     #','            ; compare with ","
001774  1  D0 F0                BNE     LAB_1A98        ; branch if not "," (go do interpreter inner loop)
001776  1               
001776  1               ; was "," so another NEXT variable to do
001776  1                       .IFDEF  DUODYNE
001776  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00177A  1                       .ELSE
00177A  1                       JSR     LAB_IGBY        ; increment and scan memory
00177A  1                       .ENDIF
00177A  1               
00177A  1  20 01 17             JSR     LAB_1A46        ; do NEXT (var)
00177D  1               
00177D  1               ; evaluate expression and check is numeric, else do type mismatch
00177D  1               
00177D  1               LAB_EVNM:
00177D  1  20 91 17             JSR     LAB_EVEX        ; evaluate expression
001780  1               
001780  1               ; check if source is numeric, else do type mismatch
001780  1               
001780  1               LAB_CTNM:
001780  1  18                   CLC                     ; destination is numeric
001781  1  24                   .BYTE   $24             ; makes next line BIT $38
001782  1               
001782  1               ; check if source is string, else do type mismatch
001782  1               
001782  1               LAB_CTST:
001782  1  38                   SEC                     ; required type is string
001783  1               
001783  1               ; type match check, set C for string, clear C for numeric
001783  1               
001783  1               LAB_CKTM:
001783  1  24 5F                BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
001785  1  30 03                BMI     LAB_1ABA        ; branch if data type is string
001787  1               
001787  1               ; else data type was numeric
001787  1  B0 03                BCS     LAB_1ABC        ; if required type is string do type mismatch error
001789  1               LAB_1AB9:
001789  1  60                   RTS
00178A  1               
00178A  1               ; data type was string, now check required type
00178A  1               LAB_1ABA:
00178A  1  B0 FD                BCS     LAB_1AB9        ; exit if required type is string
00178C  1               
00178C  1               ; else do type mismatch error
00178C  1               LAB_1ABC:
00178C  1  A2 18                LDX     #$18            ; error code $18 ("Type mismatch" error)
00178E  1               LAB_1ABE:
00178E  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
001791  1               
001791  1               ; evaluate expression
001791  1               
001791  1               LAB_EVEX:
001791  1  A6 C3                LDX     Bpntrl          ; get BASIC execute pointer low byte
001793  1  D0 02                BNE     LAB_1AC7        ; skip next if not zero
001795  1               
001795  1  C6 C4                DEC     Bpntrh          ; else decrement BASIC execute pointer high byte
001797  1               LAB_1AC7:
001797  1  C6 C3                DEC     Bpntrl          ; decrement BASIC execute pointer low byte
001799  1               
001799  1               LAB_EVEZ:
001799  1  A9 00                LDA     #$00            ; set null precedence (flag done)
00179B  1               LAB_1ACC:
00179B  1  48                   PHA                     ; push precedence byte
00179C  1  A9 02                LDA     #$02            ; 2 bytes
00179E  1  20 AE 09             JSR     LAB_1212        ; check room on stack for A bytes
0017A1  1  20 7F 18             JSR     LAB_GVAL        ; get value from line
0017A4  1  A9 00                LDA     #$00            ; clear A
0017A6  1  85 9B                STA     comp_f          ; clear compare function flag
0017A8  1               LAB_1ADB:
0017A8  1                       .IFDEF  DUODYNE
0017A8  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0017AC  1                       .ELSE
0017AC  1                       JSR     LAB_GBYT        ; scan memory
0017AC  1                       .ENDIF
0017AC  1               
0017AC  1               LAB_1ADE:
0017AC  1  38                   SEC                     ; set carry for subtract
0017AD  1  E9 C1                SBC     #TK_GT          ; subtract token for > (lowest comparison function)
0017AF  1  90 18                BCC     LAB_1AFA        ; branch if < TK_GT
0017B1  1               
0017B1  1  C9 03                CMP     #$03            ; compare with ">" to "<" tokens
0017B3  1  B0 14                BCS     LAB_1AFA        ; branch if >= TK_SGN (highest evaluation function +1)
0017B5  1               
0017B5  1               ; was token for > = or < (A = 0, 1 or 2)
0017B5  1  C9 01                CMP     #$01            ; compare with token for =
0017B7  1  2A                   ROL     A               ; *2, b0 = carry (=1 if token was = or <)
0017B8  1               ; (A = 0, 3 or 5)
0017B8  1  49 01                EOR     #$01            ; toggle b0
0017BA  1               ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
0017BA  1  45 9B                EOR     comp_f          ; EOR with compare function flag bits
0017BC  1  C5 9B                CMP     comp_f          ; compare with compare function flag
0017BE  1  90 68                BCC     LAB_1B53        ; if <(comp_f) do syntax error then warm start
0017C0  1               ; was more than one <, = or >)
0017C0  1               
0017C0  1  85 9B                STA     comp_f          ; save new compare function flag
0017C2  1                       .IFDEF  DUODYNE
0017C2  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0017C6  1                       .ELSE
0017C6  1                       JSR     LAB_IGBY        ; increment and scan memory
0017C6  1                       .ENDIF
0017C6  1               
0017C6  1  4C AC 17             JMP     LAB_1ADE        ; go do next character
0017C9  1               
0017C9  1               ; token is < ">" or > "<" tokens
0017C9  1               LAB_1AFA:
0017C9  1  A6 9B                LDX     comp_f          ; get compare function flag
0017CB  1  D0 2C                BNE     LAB_1B2A        ; branch if compare function
0017CD  1               
0017CD  1  B0 79                BCS     LAB_1B78        ; go do functions
0017CF  1               
0017CF  1               ; else was <  TK_GT so is operator or lower
0017CF  1  69 0A                ADC     #TK_GT-TK_PLUS  ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
0017D1  1  90 75                BCC     LAB_1B78        ; branch if < + operator
0017D3  1               
0017D3  1               ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
0017D3  1  D0 07                BNE     LAB_1B0B        ; branch if not + token
0017D5  1               
0017D5  1  24 5F                BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
0017D7  1  10 03                BPL     LAB_1B0B        ; branch if not string
0017D9  1               
0017D9  1               ; will only be $00 if type is string and token was +
0017D9  1  4C 99 23             JMP     LAB_224D        ; add strings, string 1 is in descriptor des_pl, string 2
0017DC  1               ; is in line, and return
0017DC  1               
0017DC  1               LAB_1B0B:
0017DC  1  85 71                STA     ut1_pl          ; save it
0017DE  1  0A                   ASL     A               ; *2
0017DF  1  65 71                ADC     ut1_pl          ; *3
0017E1  1  A8                   TAY                     ; copy to index
0017E2  1               LAB_1B13:
0017E2  1  68                   PLA                     ; pull previous precedence
0017E3  1  D9 11 38             CMP     LAB_OPPT,Y      ; compare with precedence byte
0017E6  1  B0 65                BCS     LAB_1B7D        ; branch if A >=
0017E8  1               
0017E8  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
0017EB  1               LAB_1B1C:
0017EB  1  48                   PHA                     ; save precedence
0017EC  1               LAB_1B1D:
0017EC  1  20 14 18             JSR     LAB_1B43        ; get vector, execute function then continue evaluation
0017EF  1  68                   PLA                     ; restore precedence
0017F0  1  A4 99                LDY     prstk           ; get precedence stacked flag
0017F2  1  10 19                BPL     LAB_1B3C        ; branch if stacked values
0017F4  1               
0017F4  1  AA                   TAX                     ; copy precedence (set flags)
0017F5  1  F0 76                BEQ     LAB_1B9D        ; exit if done
0017F7  1               
0017F7  1  D0 5D                BNE     LAB_1B86        ; else pop FAC2 and return, branch always
0017F9  1               
0017F9  1               LAB_1B2A:
0017F9  1  26 5F                ROL     Dtypef          ; shift data type flag into Cb
0017FB  1  8A                   TXA                     ; copy compare function flag
0017FC  1  85 5F                STA     Dtypef          ; clear data type flag, X is 0xxx xxxx
0017FE  1  2A                   ROL     A               ; shift data type into compare function byte b0
0017FF  1  A6 C3                LDX     Bpntrl          ; get BASIC execute pointer low byte
001801  1  D0 02                BNE     LAB_1B34        ; branch if no underflow
001803  1               
001803  1  C6 C4                DEC     Bpntrh          ; else decrement BASIC execute pointer high byte
001805  1               LAB_1B34:
001805  1  C6 C3                DEC     Bpntrl          ; decrement BASIC execute pointer low byte
001807  1               TK_LT_PLUS      = TK_LT-TK_PLUS
001807  1  A0 24                LDY     #TK_LT_PLUS*3   ; set offset to last operator entry
001809  1  85 9B                STA     comp_f          ; save new compare function flag
00180B  1  D0 D5                BNE     LAB_1B13        ; branch always
00180D  1               
00180D  1               LAB_1B3C:
00180D  1  D9 11 38             CMP     LAB_OPPT,Y      ;.compare with stacked function precedence
001810  1  B0 44                BCS     LAB_1B86        ; branch if A >=, pop FAC2 and return
001812  1               
001812  1  90 D7                BCC     LAB_1B1C        ; branch always
001814  1               
001814  1               ;.get vector, execute function then continue evaluation
001814  1               
001814  1               LAB_1B43:
001814  1  B9 13 38             LDA     LAB_OPPT+2,Y    ; get function vector high byte
001817  1  48                   PHA                     ; onto stack
001818  1  B9 12 38             LDA     LAB_OPPT+1,Y    ; get function vector low byte
00181B  1  48                   PHA                     ; onto stack
00181C  1               ; now push sign, round FAC1 and put on stack
00181C  1  20 2B 18             JSR     LAB_1B5B        ; function will return here, then the next RTS will call
00181F  1               ; the function
00181F  1  A5 9B                LDA     comp_f          ; get compare function flag
001821  1  48                   PHA                     ; push compare evaluation byte
001822  1  B9 11 38             LDA     LAB_OPPT,Y      ; get precedence byte
001825  1  4C 9B 17             JMP     LAB_1ACC        ; continue evaluating expression
001828  1               
001828  1               LAB_1B53:
001828  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
00182B  1               
00182B  1               ; push sign, round FAC1 and put on stack
00182B  1               
00182B  1               LAB_1B5B:
00182B  1  68                   PLA                     ; get return addr low byte
00182C  1  85 71                STA     ut1_pl          ; save it
00182E  1  E6 71                INC     ut1_pl          ; increment it (was ret-1 pushed? yes!)
001830  1               ; note! no check is made on the high byte! if the calling
001830  1               ; routine assembles to a page edge then this all goes
001830  1               ; horribly wrong !!!
001830  1  68                   PLA                     ; get return addr high byte
001831  1  85 72                STA     ut1_ph          ; save it
001833  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
001835  1  48                   PHA                     ; push sign
001836  1               
001836  1               ; round FAC1 and put on stack
001836  1               
001836  1               LAB_1B66:
001836  1  20 0B 2D             JSR     LAB_27BA        ; round FAC1
001839  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
00183B  1  48                   PHA                     ; push on stack
00183C  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
00183E  1  48                   PHA                     ; push on stack
00183F  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
001841  1  48                   PHA                     ; push on stack
001842  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
001844  1  48                   PHA                     ; push on stack
001845  1  6C 71 00             JMP     (ut1_pl)        ; return, sort of
001848  1               
001848  1               
001848  1               ; do functions
001848  1               
001848  1               LAB_1B78:
001848  1  A0 FF                LDY     #$FF            ; flag function
00184A  1  68                   PLA                     ; pull precedence byte
00184B  1               LAB_1B7B:
00184B  1  F0 20                BEQ     LAB_1B9D        ; exit if done
00184D  1               
00184D  1               LAB_1B7D:
00184D  1  C9 64                CMP     #$64            ; compare previous precedence with $64
00184F  1  F0 03                BEQ     LAB_1B84        ; branch if was $64 (< function)
001851  1               
001851  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
001854  1               LAB_1B84:
001854  1  84 99                STY     prstk           ; save precedence stacked flag
001856  1               
001856  1               ; pop FAC2 and return
001856  1               LAB_1B86:
001856  1  68                   PLA                     ; pop byte
001857  1  4A                   LSR     A               ; shift out comparison evaluation lowest bit
001858  1  85 63                STA     Cflag           ; save comparison evaluation flag
00185A  1  68                   PLA                     ; pop exponent
00185B  1  85 B3                STA     FAC2_e          ; save FAC2 exponent
00185D  1  68                   PLA                     ; pop mantissa1
00185E  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
001860  1  68                   PLA                     ; pop mantissa2
001861  1  85 B5                STA     FAC2_2          ; save FAC2 mantissa2
001863  1  68                   PLA                     ; pop mantissa3
001864  1  85 B6                STA     FAC2_3          ; save FAC2 mantissa3
001866  1  68                   PLA                     ; pop sign
001867  1  85 B7                STA     FAC2_s          ; save FAC2 sign (b7)
001869  1  45 B0                EOR     FAC1_s          ; EOR FAC1 sign (b7)
00186B  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00186D  1               LAB_1B9D:
00186D  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
00186F  1  60                   RTS
001870  1               
001870  1               ; print "..." string to string util area
001870  1               
001870  1               LAB_1BC1:
001870  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
001872  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte
001874  1  69 00                ADC     #$00            ; add carry to low byte
001876  1  90 01                BCC     LAB_1BCA        ; branch if no overflow
001878  1               
001878  1  C8                   INY                     ; increment high byte
001879  1               LAB_1BCA:
001879  1  20 13 21             JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh
00187C  1  4C 9D 27             JMP     LAB_23F3        ; restore BASIC execute pointer from temp and return
00187F  1               
00187F  1               ; get value from line
00187F  1               
00187F  1               LAB_GVAL:
00187F  1                       .IFDEF  DUODYNE
00187F  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001883  1                       .ELSE
001883  1                       JSR     LAB_IGBY        ; increment and scan memory
001883  1                       .ENDIF
001883  1               
001883  1  B0 03                BCS     LAB_1BAC        ; branch if not numeric character
001885  1               
001885  1               ; else numeric string found (e.g. 123)
001885  1               LAB_1BA9:
001885  1  4C 3C 2E             JMP     LAB_2887        ; get FAC1 from string and return
001888  1               
001888  1               ; get value from line .. continued
001888  1               
001888  1               ; wasn't a number so ..
001888  1               LAB_1BAC:
001888  1  AA                   TAX                     ; set the flags
001889  1  30 31                BMI     LAB_1BD0        ; if -ve go test token values
00188B  1               
00188B  1               ; else it is either a string, number, variable or (<expr>)
00188B  1  C9 24                CMP     #'$'            ; compare with "$"
00188D  1  F0 F6                BEQ     LAB_1BA9        ; branch if "$", hex number
00188F  1               
00188F  1  C9 25                CMP     #'%'            ; else compare with "%"
001891  1  F0 F2                BEQ     LAB_1BA9        ; branch if "%", binary number
001893  1               
001893  1  C9 2E                CMP     #'.'            ; compare with "."
001895  1  F0 EE                BEQ     LAB_1BA9        ; if so get FAC1 from string and return (e.g. was .123)
001897  1               
001897  1               ; it wasn't any sort of number so ..
001897  1  C9 22                CMP     #$22            ; compare with "
001899  1  F0 D5                BEQ     LAB_1BC1        ; branch if open quote
00189B  1               
00189B  1               ; wasn't any sort of number so ..
00189B  1               
00189B  1               ; evaluate expression within parentheses
00189B  1               
00189B  1  C9 28                CMP     #'('            ; compare with "("
00189D  1  D0 51                BNE     LAB_1C18        ; if not "(" get (var), return value in FAC1 and $ flag
00189F  1               
00189F  1               LAB_1BF7:
00189F  1  20 99 17             JSR     LAB_EVEZ        ; evaluate expression, no decrement
0018A2  1               
0018A2  1               ; all the 'scan for' routines return the character after the sought character
0018A2  1               
0018A2  1               ; scan for ")" , else do syntax error then warm start
0018A2  1               
0018A2  1               LAB_1BFB:
0018A2  1  A9 29                LDA     #$29            ; load A with ")"
0018A4  1               
0018A4  1               ; scan for CHR$(A) , else do syntax error then warm start
0018A4  1               
0018A4  1               LAB_SCCA:
0018A4  1  A0 00                LDY     #$00            ; clear index
0018A6  1  D1 C3                CMP     (Bpntrl),Y      ; check next byte is = A
0018A8  1  D0 0D                BNE     LAB_SNER        ; if not do syntax error then warm start
0018AA  1                       .IFDEF  DUODYNE
0018AA  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0018AE  1                       .ELSE
0018AE  1                       JSR     LAB_IGBY        ; increment and scan memory
0018AE  1                       .ENDIF
0018AE  1  60                   RTS
0018AF  1               ; scan for "(" , else do syntax error then warm start
0018AF  1               
0018AF  1               LAB_1BFE:
0018AF  1  A9 28                LDA     #$28            ; load A with "("
0018B1  1  D0 F1                BNE     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
0018B3  1               ; (branch always)
0018B3  1               
0018B3  1               ; scan for "," , else do syntax error then warm start
0018B3  1               
0018B3  1               LAB_1C01:
0018B3  1  A9 2C                LDA     #$2C            ; load A with ","
0018B5  1  D0 ED                BNE     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
0018B7  1               ; (branch always)
0018B7  1               
0018B7  1               ; syntax error then warm start
0018B7  1               
0018B7  1               LAB_SNER:
0018B7  1  A2 02                LDX     #$02            ; error code $02 ("Syntax" error)
0018B9  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
0018BC  1               
0018BC  1               ; get value from line .. continued
0018BC  1               ; do tokens
0018BC  1               
0018BC  1               LAB_1BD0:
0018BC  1  C9 B8                CMP     #TK_MINUS       ; compare with token for -
0018BE  1  F0 29                BEQ     LAB_1C11        ; branch if - token (do set-up for functions)
0018C0  1               
0018C0  1               ; wasn't -n so ..
0018C0  1  C9 B7                CMP     #TK_PLUS        ; compare with token for +
0018C2  1  F0 BB                BEQ     LAB_GVAL        ; branch if + token (+n = n so ignore leading +)
0018C4  1               
0018C4  1  C9 B2                CMP     #TK_NOT         ; compare with token for NOT
0018C6  1  D0 13                BNE     LAB_1BE7        ; branch if not token for NOT
0018C8  1               
0018C8  1               ; was NOT token
0018C8  1               TK_EQUAL_PLUS   = TK_EQUAL-TK_PLUS
0018C8  1  A0 21                LDY     #TK_EQUAL_PLUS*3; offset to NOT function
0018CA  1  D0 1F                BNE     LAB_1C13        ; do set-up for function then execute (branch always)
0018CC  1               
0018CC  1               ; do = compare
0018CC  1               
0018CC  1               LAB_EQUAL:
0018CC  1  20 36 1C             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
0018CF  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
0018D1  1  49 FF                EOR     #$FF            ; invert it
0018D3  1  A8                   TAY                     ; copy it
0018D4  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0018D6  1  49 FF                EOR     #$FF            ; invert it
0018D8  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
0018DB  1               
0018DB  1               ; get value from line .. continued
0018DB  1               
0018DB  1               ; wasn't +, -, or NOT so ..
0018DB  1               LAB_1BE7:
0018DB  1  C9 AF                CMP     #TK_FN          ; compare with token for FN
0018DD  1  D0 03                BNE     LAB_1BEE        ; branch if not token for FN
0018DF  1               
0018DF  1  4C CE 1F             JMP     LAB_201E        ; go evaluate FNx
0018E2  1               
0018E2  1               ; get value from line .. continued
0018E2  1               
0018E2  1               ; wasn't +, -, NOT or FN so ..
0018E2  1               LAB_1BEE:
0018E2  1  E9 C4                SBC     #TK_SGN         ; subtract with token for SGN
0018E4  1  B0 19                BCS     LAB_1C27        ; if a function token go do it
0018E6  1               
0018E6  1  4C B7 18             JMP     LAB_SNER        ; else do syntax error
0018E9  1               
0018E9  1               ; set-up for functions
0018E9  1               
0018E9  1               LAB_1C11:
0018E9  1               TK_GT_PLUS      = TK_GT-TK_PLUS
0018E9  1  A0 1E                LDY     #TK_GT_PLUS*3   ; set offset from base to > operator
0018EB  1               LAB_1C13:
0018EB  1  68                   PLA                     ; dump return address low byte
0018EC  1  68                   PLA                     ; dump return address high byte
0018ED  1  4C EC 17             JMP     LAB_1B1D        ; execute function then continue evaluation
0018F0  1               
0018F0  1               ; variable name set-up
0018F0  1               ; get (var), return value in FAC_1 and $ flag
0018F0  1               
0018F0  1               LAB_1C18:
0018F0  1  20 8E 1A             JSR     LAB_GVAR        ; get (var) address
0018F3  1  85 AE                STA     FAC1_2          ; save address low byte in FAC1 mantissa2
0018F5  1  84 AF                STY     FAC1_3          ; save address high byte in FAC1 mantissa3
0018F7  1  A6 5F                LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
0018F9  1  30 03                BMI     LAB_1C25        ; if string then return (does RTS)
0018FB  1               
0018FB  1               LAB_1C24:
0018FB  1  4C 0F 2C             JMP     LAB_UFAC        ; unpack memory (AY) into FAC1
0018FE  1               
0018FE  1               LAB_1C25:
0018FE  1  60                   RTS
0018FF  1               
0018FF  1               ; get value from line .. continued
0018FF  1               ; only functions left so ..
0018FF  1               
0018FF  1               ; set up function references
0018FF  1               
0018FF  1               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
0018FF  1               ; to process function calls. now the function vector is computed and pushed on the stack
0018FF  1               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
0018FF  1               ; is calculated and the routine called, if not this routine just does RTS. whichever
0018FF  1               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
0018FF  1               ; the function code
0018FF  1               
0018FF  1               ; this also removes some less than elegant code that was used to bypass type checking
0018FF  1               ; for functions that returned strings
0018FF  1               
0018FF  1               LAB_1C27:
0018FF  1  0A                   ASL     A               ; *2 (2 bytes per function address)
001900  1  A8                   TAY                     ; copy to index
001901  1               
001901  1  B9 CC 37             LDA     LAB_FTBM,Y      ; get function jump vector high byte
001904  1  48                   PHA                     ; push functions jump vector high byte
001905  1  B9 CB 37             LDA     LAB_FTBL,Y      ; get function jump vector low byte
001908  1  48                   PHA                     ; push functions jump vector low byte
001909  1               
001909  1  B9 86 37             LDA     LAB_FTPM,Y      ; get function pre process vector high byte
00190C  1  F0 05                BEQ     LAB_1C56        ; skip pre process if null vector
00190E  1               
00190E  1  48                   PHA                     ; push functions pre process vector high byte
00190F  1  B9 85 37             LDA     LAB_FTPL,Y      ; get function pre process vector low byte
001912  1  48                   PHA                     ; push functions pre process vector low byte
001913  1               
001913  1               LAB_1C56:
001913  1  60                   RTS                     ; do function, or pre process, call
001914  1               
001914  1               ; process string expression in parenthesis
001914  1               
001914  1               LAB_PPFS:
001914  1  20 9F 18             JSR     LAB_1BF7        ; process expression in parenthesis
001917  1  4C 82 17             JMP     LAB_CTST        ; check if source is string then do function,
00191A  1               ; else do type mismatch
00191A  1               
00191A  1               ; process numeric expression in parenthesis
00191A  1               
00191A  1               LAB_PPFN:
00191A  1  20 9F 18             JSR     LAB_1BF7        ; process expression in parenthesis
00191D  1  4C 80 17             JMP     LAB_CTNM        ; check if source is numeric then do function,
001920  1               ; else do type mismatch
001920  1               
001920  1               ; set numeric data type and increment BASIC execute pointer
001920  1               
001920  1               LAB_PPBI:
001920  1  46 5F                LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
001922  1                       .IFDEF  DUODYNE
001922  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001926  1                       .ELSE
001926  1                       JSR     LAB_IGBY        ; increment and scan memory
001926  1                       .ENDIF
001926  1  60                   RTS
001927  1               
001927  1               ; process string for LEFT$, RIGHT$ or MID$
001927  1               
001927  1               LAB_LRMS:
001927  1  20 99 17             JSR     LAB_EVEZ        ; evaluate (should be string) expression
00192A  1  20 B3 18             JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start
00192D  1  20 82 17             JSR     LAB_CTST        ; check if source is string, else do type mismatch
001930  1               
001930  1  68                   PLA                     ; get function jump vector low byte
001931  1  AA                   TAX                     ; save functions jump vector low byte
001932  1  68                   PLA                     ; get function jump vector high byte
001933  1  A8                   TAY                     ; save functions jump vector high byte
001934  1  A5 AF                LDA     des_ph          ; get descriptor pointer high byte
001936  1  48                   PHA                     ; push string pointer high byte
001937  1  A5 AE                LDA     des_pl          ; get descriptor pointer low byte
001939  1  48                   PHA                     ; push string pointer low byte
00193A  1  98                   TYA                     ; get function jump vector high byte back
00193B  1  48                   PHA                     ; save functions jump vector high byte
00193C  1  8A                   TXA                     ; get function jump vector low byte back
00193D  1  48                   PHA                     ; save functions jump vector low byte
00193E  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter
001941  1  8A                   TXA                     ; copy byte parameter to A
001942  1  60                   RTS                     ; go do function
001943  1               
001943  1               ; process numeric expression(s) for BIN$ or HEX$
001943  1               
001943  1               LAB_BHSS:
001943  1  20 99 17             JSR     LAB_EVEZ        ; process expression
001946  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
001949  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
00194B  1  C9 98                CMP     #$98            ; compare with exponent = 2^24
00194D  1  B0 22                BCS     LAB_BHER        ; branch if n>=2^24 (is too big)
00194F  1               
00194F  1  20 E6 2D             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
001952  1  A2 02                LDX     #$02            ; 3 bytes to do
001954  1               LAB_CFAC:
001954  1  B5 AD                LDA     FAC1_1,X        ; get byte from FAC1
001956  1  95 11                STA     nums_1,X        ; save byte to temp
001958  1  CA                   DEX                     ; decrement index
001959  1  10 F9                BPL     LAB_CFAC        ; copy FAC1 mantissa to temp
00195B  1               
00195B  1                       .IFDEF  DUODYNE
00195B  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00195F  1                       .ELSE
00195F  1                       JSR     LAB_GBYT        ; scan memory
00195F  1                       .ENDIF
00195F  1               
00195F  1  A2 00                LDX     #$00            ; set default to no leading "0"s
001961  1  C9 29                CMP     #')'            ; compare with close bracket
001963  1  F0 0B                BEQ     LAB_1C54        ; if ")" go do rest of function
001965  1               
001965  1  20 AC 27             JSR     LAB_SCGB        ; scan for "," and get byte
001968  1                       .IFDEF  DUODYNE
001968  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00196C  1                       .ELSE
00196C  1                       JSR     LAB_GBYT        ; scan memory
00196C  1                       .ENDIF
00196C  1               
00196C  1  C9 29                CMP     #')'            ; is next character )
00196E  1  D0 01                BNE     LAB_BHER        ; if not ")" go do error
001970  1               
001970  1               LAB_1C54:
001970  1  60                   RTS                     ; else do function
001971  1               
001971  1               LAB_BHER:
001971  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start
001974  1               
001974  1               ; perform EOR
001974  1               
001974  1               ; added operator format is the same as AND or OR, precedence is the same as OR
001974  1               
001974  1               ; this bit worked first time but it took a while to sort out the operator table
001974  1               ; pointers and offsets afterwards!
001974  1               
001974  1               LAB_EOR:
001974  1  20 9B 19             JSR     GetFirst        ; get first integer expression (no sign check)
001977  1  45 5B                EOR     XOAw_l          ; EOR with expression 1 low byte
001979  1  A8                   TAY                     ; save in Y
00197A  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
00197C  1  45 5C                EOR     XOAw_h          ; EOR with expression 1 high byte
00197E  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
001981  1               
001981  1               ; perform OR
001981  1               
001981  1               LAB_OR:
001981  1  20 9B 19             JSR     GetFirst        ; get first integer expression (no sign check)
001984  1  05 5B                ORA     XOAw_l          ; OR with expression 1 low byte
001986  1  A8                   TAY                     ; save in Y
001987  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
001989  1  05 5C                ORA     XOAw_h          ; OR with expression 1 high byte
00198B  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00198E  1               
00198E  1               ; perform AND
00198E  1               
00198E  1               LAB_AND:
00198E  1  20 9B 19             JSR     GetFirst        ; get first integer expression (no sign check)
001991  1  25 5B                AND     XOAw_l          ; AND with expression 1 low byte
001993  1  A8                   TAY                     ; save in Y
001994  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
001996  1  25 5C                AND     XOAw_h          ; AND with expression 1 high byte
001998  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00199B  1               
00199B  1               ; get first value for OR, AND or EOR
00199B  1               
00199B  1               GetFirst:
00199B  1  20 36 1C             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00199E  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0019A0  1  85 5C                STA     XOAw_h          ; save it
0019A2  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
0019A4  1  85 5B                STA     XOAw_l          ; save it
0019A6  1  20 FF 28             JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
0019A9  1  20 36 1C             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
0019AC  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
0019AE  1               LAB_1C95:
0019AE  1  60                   RTS
0019AF  1               
0019AF  1               ; perform comparisons
0019AF  1               
0019AF  1               ; do < compare
0019AF  1               
0019AF  1               LAB_LTHAN:
0019AF  1  20 83 17             JSR     LAB_CKTM        ; type match check, set C for string
0019B2  1  B0 13                BCS     LAB_1CAE        ; branch if string
0019B4  1               
0019B4  1               ; do numeric < compare
0019B4  1  A5 B7                LDA     FAC2_s          ; get FAC2 sign (b7)
0019B6  1  09 7F                ORA     #$7F            ; set all non sign bits
0019B8  1  25 B4                AND     FAC2_1          ; and FAC2 mantissa1 (AND in sign bit)
0019BA  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
0019BC  1  A9 B3                LDA     #<FAC2_e        ; set pointer low byte to FAC2
0019BE  1  A0 00                LDY     #>FAC2_e        ; set pointer high byte to FAC2
0019C0  1  20 49 2D             JSR     LAB_27F8        ; compare FAC1 with FAC2 (AY)
0019C3  1  AA                   TAX                     ; copy result
0019C4  1  4C F8 19             JMP     LAB_1CE1        ; go evaluate result
0019C7  1               
0019C7  1               ; do string < compare
0019C7  1               LAB_1CAE:
0019C7  1  46 5F                LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
0019C9  1  C6 9B                DEC     comp_f          ; clear < bit in compare function flag
0019CB  1  20 92 24             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
0019CE  1               ; space returns with A = length, X=pointer low byte,
0019CE  1               ; Y=pointer high byte
0019CE  1  85 AC                STA     str_ln          ; save length
0019D0  1  86 AD                STX     str_pl          ; save string pointer low byte
0019D2  1  84 AE                STY     str_ph          ; save string pointer high byte
0019D4  1  A5 B5                LDA     FAC2_2          ; get descriptor pointer low byte
0019D6  1  A4 B6                LDY     FAC2_3          ; get descriptor pointer high byte
0019D8  1  20 96 24             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
0019DB  1               ; returns with A = length, X=pointer low byte,
0019DB  1               ; Y=pointer high byte
0019DB  1  86 B5                STX     FAC2_2          ; save string pointer low byte
0019DD  1  84 B6                STY     FAC2_3          ; save string pointer high byte
0019DF  1  AA                   TAX                     ; copy length
0019E0  1  38                   SEC                     ; set carry for subtract
0019E1  1  E5 AC                SBC     str_ln          ; subtract string 1 length
0019E3  1  F0 08                BEQ     LAB_1CD6        ; branch if str 1 length = string 2 length
0019E5  1               
0019E5  1  A9 01                LDA     #$01            ; set str 1 length > string 2 length
0019E7  1  90 04                BCC     LAB_1CD6        ; branch if so
0019E9  1               
0019E9  1  A6 AC                LDX     str_ln          ; get string 1 length
0019EB  1  A9 FF                LDA     #$FF            ; set str 1 length < string 2 length
0019ED  1               LAB_1CD6:
0019ED  1  85 B0                STA     FAC1_s          ; save length compare
0019EF  1  A0 FF                LDY     #$FF            ; set index
0019F1  1  E8                   INX                     ; adjust for loop
0019F2  1               LAB_1CDB:
0019F2  1  C8                   INY                     ; increment index
0019F3  1  CA                   DEX                     ; decrement count
0019F4  1  D0 07                BNE     LAB_1CE6        ; branch if still bytes to do
0019F6  1               
0019F6  1  A6 B0                LDX     FAC1_s          ; get length compare back
0019F8  1               LAB_1CE1:
0019F8  1  30 39                BMI     LAB_1CF2        ; branch if str 1 < str 2
0019FA  1               
0019FA  1  18                   CLC                     ; flag str 1 <= str 2
0019FB  1  90 36                BCC     LAB_1CF2        ; go evaluate result
0019FD  1               
0019FD  1               LAB_1CE6:
0019FD  1  8B DA A2 01          LDAINDIRECTY FAC2_2     ; get string 2 byte
001A01  1  B5 B5 C9 00  
001A05  1  D0 04 A2 00  
001A13  1  8B 48 DA A2          CMPINDIRECTY FAC1_1     ; compare with string 1 byte
001A17  1  01 B5 AD C9  
001A1B  1  00 D0 04 A2  
001A2B  1  F0 C5                BEQ     LAB_1CDB        ; loop if bytes =
001A2D  1               
001A2D  1  A2 FF                LDX     #$FF            ; set str 1 < string 2
001A2F  1  B0 02                BCS     LAB_1CF2        ; branch if so
001A31  1               
001A31  1  A2 01                LDX     #$01            ;  set str 1 > string 2
001A33  1               LAB_1CF2:
001A33  1  E8                   INX                     ; x = 0, 1 or 2
001A34  1  8A                   TXA                     ; copy to A
001A35  1  2A                   ROL     A               ; *2 (1, 2 or 4)
001A36  1  25 63                AND     Cflag           ; AND with comparison evaluation flag
001A38  1  F0 02                BEQ     LAB_1CFB        ; branch if 0 (compare is false)
001A3A  1               
001A3A  1  A9 FF                LDA     #$FF            ; else set result true
001A3C  1               LAB_1CFB:
001A3C  1  4C 2C 2D             JMP     LAB_27DB        ; save A as integer byte and return
001A3F  1               
001A3F  1               LAB_1CFE:
001A3F  1  20 B3 18             JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start
001A42  1               
001A42  1               ; perform DIM
001A42  1               
001A42  1               LAB_DIM:
001A42  1  AA                   TAX                     ; copy "DIM" flag to X
001A43  1  20 94 1A             JSR     LAB_1D10        ; search for variable
001A46  1                       .IFDEF  DUODYNE
001A46  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001A4A  1                       .ELSE
001A4A  1                       JSR     LAB_GBYT        ; scan memory
001A4A  1                       .ENDIF
001A4A  1               
001A4A  1  D0 F3                BNE     LAB_1CFE        ; scan for "," and loop if not null
001A4C  1               
001A4C  1  60                   RTS
001A4D  1               
001A4D  1               ; perform << (left shift)
001A4D  1               
001A4D  1               LAB_LSHIFT:
001A4D  1  20 83 1A             JSR     GetPair         ; get integer expression and byte (no sign check)
001A50  1  A5 AE                LDA     FAC1_2          ; get expression high byte
001A52  1  A6 78                LDX     TempB           ; get shift count
001A54  1  F0 22                BEQ     NoShift         ; branch if zero
001A56  1               
001A56  1  E0 10                CPX     #$10            ; compare bit count with 16d
001A58  1  B0 23                BCS     TooBig          ; branch if >=
001A5A  1               
001A5A  1               Ls_loop:
001A5A  1  06 AF                ASL     FAC1_3          ; shift low byte
001A5C  1  2A                   ROL     A               ; shift high byte
001A5D  1  CA                   DEX                     ; decrement bit count
001A5E  1  D0 FA                BNE     Ls_loop         ; loop if shift not complete
001A60  1               
001A60  1  A4 AF                LDY     FAC1_3          ; get expression low byte
001A62  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
001A65  1               
001A65  1               ; perform >> (right shift)
001A65  1               
001A65  1               LAB_RSHIFT:
001A65  1  20 83 1A             JSR     GetPair         ; get integer expression and byte (no sign check)
001A68  1  A5 AE                LDA     FAC1_2          ; get expression high byte
001A6A  1  A6 78                LDX     TempB           ; get shift count
001A6C  1  F0 0A                BEQ     NoShift         ; branch if zero
001A6E  1               
001A6E  1  E0 10                CPX     #$10            ; compare bit count with 16d
001A70  1  B0 0B                BCS     TooBig          ; branch if >=
001A72  1               
001A72  1               Rs_loop:
001A72  1  4A                   LSR     A               ; shift high byte
001A73  1  66 AF                ROR     FAC1_3          ; shift low byte
001A75  1  CA                   DEX                     ; decrement bit count
001A76  1  D0 FA                BNE     Rs_loop         ; loop if shift not complete
001A78  1               
001A78  1               NoShift:
001A78  1  A4 AF                LDY     FAC1_3          ; get expression low byte
001A7A  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
001A7D  1               
001A7D  1               TooBig:
001A7D  1  A9 00                LDA     #$00            ; clear high byte
001A7F  1  A8                   TAY                     ; copy to low byte
001A80  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
001A83  1               
001A83  1               GetPair:
001A83  1  20 1E 27             JSR     LAB_EVBY        ; evaluate byte expression, result in X
001A86  1  86 78                STX     TempB           ; save it
001A88  1  20 FF 28             JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
001A8B  1  4C 36 1C             JMP     LAB_EVIR        ; evaluate integer expression (no sign check)
001A8E  1               
001A8E  1               ; search for variable
001A8E  1               
001A8E  1               ; return pointer to variable in Cvaral/Cvarah
001A8E  1               
001A8E  1               LAB_GVAR:
001A8E  1  A2 00                LDX     #$00            ; set DIM flag = $00
001A90  1                       .IFDEF  DUODYNE
001A90  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001A94  1                       .ELSE
001A94  1                       JSR     LAB_GBYT        ; scan memory
001A94  1                       .ENDIF
001A94  1               
001A94  1               LAB_1D10:
001A94  1  86 5E                STX     Defdim          ; save DIM flag
001A96  1               LAB_1D12:
001A96  1  85 93                STA     Varnm1          ; save 1st character
001A98  1  29 7F                AND     #$7F            ; clear FN flag bit
001A9A  1  20 35 1B             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
001A9D  1  B0 03                BCS     LAB_1D1F        ; branch if ok
001A9F  1               
001A9F  1  4C B7 18             JMP     LAB_SNER        ; else syntax error then warm start
001AA2  1               
001AA2  1               ; was variable name so ..
001AA2  1               LAB_1D1F:
001AA2  1  A2 00                LDX     #$00            ; clear 2nd character temp
001AA4  1  86 5F                STX     Dtypef          ; clear data type flag, $FF=string, $00=numeric
001AA6  1                       .IFDEF  DUODYNE
001AA6  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001AAA  1                       .ELSE
001AAA  1                       JSR     LAB_IGBY        ; increment and scan memory
001AAA  1                       .ENDIF
001AAA  1               
001AAA  1  90 05                BCC     LAB_1D2D        ; branch if character = "0"-"9" (ok)
001AAC  1               
001AAC  1               ; 2nd character wasn't "0" to "9" so ..
001AAC  1  20 35 1B             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
001AAF  1  90 0C                BCC     LAB_1D38        ; branch if <"A" or >"Z" (go check if string)
001AB1  1               
001AB1  1               LAB_1D2D:
001AB1  1  AA                   TAX                     ; copy 2nd character
001AB2  1               
001AB2  1               ; ignore further (valid) characters in the variable name
001AB2  1               LAB_1D2E:
001AB2  1                       .IFDEF  DUODYNE
001AB2  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001AB6  1                       .ELSE
001AB6  1                       JSR     LAB_IGBY        ; increment and scan memory
001AB6  1                       .ENDIF
001AB6  1               
001AB6  1  90 FA                BCC     LAB_1D2E        ; loop if character = "0"-"9" (ignore)
001AB8  1               
001AB8  1  20 35 1B             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
001ABB  1  B0 F5                BCS     LAB_1D2E        ; loop if character = "A"-"Z" (ignore)
001ABD  1               
001ABD  1               ; check if string variable
001ABD  1               LAB_1D38:
001ABD  1  C9 24                CMP     #'$'            ; compare with "$"
001ABF  1  D0 0C                BNE     LAB_1D47        ; branch if not string
001AC1  1               
001AC1  1               ; to introduce a new variable type (% suffix for integers say) then this branch
001AC1  1               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
001AC1  1               
001AC1  1               ; type is string
001AC1  1  A9 FF                LDA     #$FF            ; set data type = string
001AC3  1  85 5F                STA     Dtypef          ; set data type flag, $FF=string, $00=numeric
001AC5  1  8A                   TXA                     ; get 2nd character back
001AC6  1  09 80                ORA     #$80            ; set top bit (indicate string var)
001AC8  1  AA                   TAX                     ; copy back to 2nd character temp
001AC9  1                       .IFDEF  DUODYNE
001AC9  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001ACD  1                       .ELSE
001ACD  1                       JSR     LAB_IGBY        ; increment and scan memory
001ACD  1                       .ENDIF
001ACD  1               
001ACD  1               
001ACD  1               ; after we have determined the variable type we need to come back here to determine
001ACD  1               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
001ACD  1               
001ACD  1               
001ACD  1               LAB_1D47:                       ; gets here with character after var name in A
001ACD  1  86 94                STX     Varnm2          ; save 2nd character
001ACF  1  05 61                ORA     Sufnxf          ; or with subscript/FNX flag (or FN name)
001AD1  1  C9 28                CMP     #'('            ; compare with "("
001AD3  1  D0 03                BNE     LAB_1D53        ; branch if not "("
001AD5  1               
001AD5  1  4C 4B 1C             JMP     LAB_1E17        ; go find, or make, array
001AD8  1               
001AD8  1               ; either find or create var
001AD8  1               ; var name (1st two characters only!) is in Varnm1,Varnm2
001AD8  1               
001AD8  1               ; variable name wasn't var(... so look for plain var
001AD8  1               LAB_1D53:
001AD8  1  A9 00                LDA     #$00            ; clear A
001ADA  1  85 61                STA     Sufnxf          ; clear subscript/FNX flag
001ADC  1  A5 7B                LDA     Svarl           ; get start of vars low byte
001ADE  1  A6 7C                LDX     Svarh           ; get start of vars high byte
001AE0  1  A0 00                LDY     #$00            ; clear index
001AE2  1               LAB_1D5D:
001AE2  1  86 AB                STX     Vrschh          ; save search address high byte
001AE4  1               LAB_1D5F:
001AE4  1  85 AA                STA     Vrschl          ; save search address low byte
001AE6  1  E4 7E                CPX     Sarryh          ; compare high address with var space end
001AE8  1  D0 04                BNE     LAB_1D69        ; skip next compare if <>
001AEA  1               
001AEA  1               ; high addresses were = so compare low addresses
001AEA  1  C5 7D                CMP     Sarryl          ; compare low address with var space end
001AEC  1  F0 5B                BEQ     LAB_1D8B        ; if not found go make new var
001AEE  1               
001AEE  1               LAB_1D69:
001AEE  1  A5 93                LDA     Varnm1          ; get 1st character of var to find
001AF0  1  8B 48 DA A2          CMPINDIRECTY Vrschl     ; compare with variable name 1st character
001AF4  1  01 B5 AA C9  
001AF8  1  00 D0 04 A2  
001B08  1  D0 21                BNE     LAB_1D77        ; branch if no match
001B0A  1               
001B0A  1               ; 1st characters match so compare 2nd characters
001B0A  1  A5 94                LDA     Varnm2          ; get 2nd character of var to find
001B0C  1  C8                   INY                     ; index to point to variable name 2nd character
001B0D  1  8B 48 DA A2          CMPINDIRECTY Vrschl     ; compare with variable name 2nd character
001B11  1  01 B5 AA C9  
001B15  1  00 D0 04 A2  
001B25  1  D0 03 4C 0B          LBEQ    LAB_1DD7        ; branch if match (found var)
001B29  1  1C           
001B2A  1               
001B2A  1  88                   DEY                     ; else decrement index (now = $00)
001B2B  1               LAB_1D77:
001B2B  1  18                   CLC                     ; clear carry for add
001B2C  1  A5 AA                LDA     Vrschl          ; get search address low byte
001B2E  1  69 06                ADC     #$06            ; +6 (offset to next var name)
001B30  1  90 B2                BCC     LAB_1D5F        ; loop if no overflow to high byte
001B32  1               
001B32  1  E8                   INX                     ; else increment high byte
001B33  1  D0 AD                BNE     LAB_1D5D        ; loop always (RAM doesn't extend to $FFFF !)
001B35  1               
001B35  1               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
001B35  1               
001B35  1               LAB_CASC:
001B35  1  C9 61                CMP     #'a'            ; compare with "a"
001B37  1  B0 0A                BCS     LAB_1D83        ; go check <"z"+1
001B39  1               
001B39  1               ; check byte, return C=0 if<"A" or >"Z"
001B39  1               
001B39  1               LAB_1D82:
001B39  1  C9 41                CMP     #'A'            ; compare with "A"
001B3B  1  90 05                BCC     LAB_1D8A        ; exit if less
001B3D  1               
001B3D  1               ; carry is set
001B3D  1  E9 5B                SBC     #$5B            ; subtract "Z"+1
001B3F  1  38                   SEC                     ; set carry
001B40  1  E9 A5                SBC     #$A5            ; subtract $A5 (restore byte)
001B42  1               ; carry clear if byte>$5A
001B42  1               LAB_1D8A:
001B42  1  60                   RTS
001B43  1               
001B43  1               LAB_1D83:
001B43  1  E9 7B                SBC     #$7B            ; subtract "z"+1
001B45  1  38                   SEC                     ; set carry
001B46  1  E9 85                SBC     #$85            ; subtract $85 (restore byte)
001B48  1               ; carry clear if byte>$7A
001B48  1  60                   RTS
001B49  1               
001B49  1               ; reached end of variable mem without match
001B49  1               ; .. so create new variable
001B49  1               LAB_1D8B:
001B49  1  68                   PLA                     ; pop return address low byte
001B4A  1  48                   PHA                     ; push return address low byte
001B4B  1               LAB_1C18p2      = LAB_1C18+2
001B4B  1  C9 F2                CMP     #<LAB_1C18p2    ; compare with expected calling routine return low byte
001B4D  1  D0 05                BNE     LAB_1D98        ; if not get (var) go create new var
001B4F  1               
001B4F  1               ; This will only drop through if the call was from LAB_1C18 and is only called
001B4F  1               ; from there if it is searching for a variable from the RHS of a LET a=b statement
001B4F  1               ; it prevents the creation of variables not assigned a value.
001B4F  1               
001B4F  1               ; value returned by this is either numeric zero (exponent byte is $00) or null string
001B4F  1               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
001B4F  1               
001B4F  1               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
001B4F  1               
001B4F  1               ; this is where you would put the undefined variable error call e.g.
001B4F  1               
001B4F  1               ;					; variable doesn't exist so flag error
001B4F  1               ;	LDX	#$24			; error code $24 ("undefined variable" error)
001B4F  1               ;	JMP	LAB_XERR		; do error #X then warm start
001B4F  1               
001B4F  1               ; the above code has been tested and works a treat! (it replaces the three code lines
001B4F  1               ; below)
001B4F  1               
001B4F  1               ; else return dummy null value
001B4F  1  A9 07                LDA     #<LAB_1D96      ; low byte point to $00,$00
001B51  1               ; (uses part of misc constants table)
001B51  1  A0 37                LDY     #>LAB_1D96      ; high byte point to $00,$00
001B53  1  60                   RTS
001B54  1               
001B54  1               ; create new numeric variable
001B54  1               LAB_1D98:
001B54  1  A5 7D                LDA     Sarryl          ; get var mem end low byte
001B56  1  A4 7E                LDY     Sarryh          ; get var mem end high byte
001B58  1  85 AA                STA     Ostrtl          ; save old block start low byte
001B5A  1  84 AB                STY     Ostrth          ; save old block start high byte
001B5C  1  A5 7F                LDA     Earryl          ; get array mem end low byte
001B5E  1  A4 80                LDY     Earryh          ; get array mem end high byte
001B60  1  85 A6                STA     Obendl          ; save old block end low byte
001B62  1  84 A7                STY     Obendh          ; save old block end high byte
001B64  1  18                   CLC                     ; clear carry for add
001B65  1  69 06                ADC     #$06            ; +6 (space for one var)
001B67  1  90 01                BCC     LAB_1DAE        ; branch if no overflow to high byte
001B69  1               
001B69  1  C8                   INY                     ; else increment high byte
001B6A  1               LAB_1DAE:
001B6A  1  85 A4                STA     Nbendl          ; set new block end low byte
001B6C  1  84 A5                STY     Nbendh          ; set new block end high byte
001B6E  1  20 1C 09             JSR     LAB_11CF        ; open up space in memory
001B71  1  A5 A4                LDA     Nbendl          ; get new start low byte
001B73  1  A4 A5                LDY     Nbendh          ; get new start high byte (-$100)
001B75  1  C8                   INY                     ; correct high byte
001B76  1  85 7D                STA     Sarryl          ; save new var mem end low byte
001B78  1  84 7E                STY     Sarryh          ; save new var mem end high byte
001B7A  1  A0 00                LDY     #$00            ; clear index
001B7C  1  A5 93                LDA     Varnm1          ; get var name 1st character
001B7E  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; save var name 1st character
001B82  1  01 B5 AA C9  
001B86  1  00 D0 04 A2  
001B94  1  C8                   INY                     ; increment index
001B95  1  A5 94                LDA     Varnm2          ; get var name 2nd character
001B97  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; save var name 2nd character
001B9B  1  01 B5 AA C9  
001B9F  1  00 D0 04 A2  
001BAD  1  A9 00                LDA     #$00            ; clear A
001BAF  1  C8                   INY                     ; increment index
001BB0  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; initialise var byte
001BB4  1  01 B5 AA C9  
001BB8  1  00 D0 04 A2  
001BC6  1  C8                   INY                     ; increment index
001BC7  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; initialise var byte
001BCB  1  01 B5 AA C9  
001BCF  1  00 D0 04 A2  
001BDD  1  C8                   INY                     ; increment index
001BDE  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; initialise var byte
001BE2  1  01 B5 AA C9  
001BE6  1  00 D0 04 A2  
001BF4  1  C8                   INY                     ; increment index
001BF5  1  8B DA 48 A2          STAINDIRECTY Vrschl     ; initialise var byte
001BF9  1  01 B5 AA C9  
001BFD  1  00 D0 04 A2  
001C0B  1               
001C0B  1               ; found a match for var ((Vrschl) = ptr)
001C0B  1               LAB_1DD7
001C0B  1  A5 AA                LDA     Vrschl          ; get var address low byte
001C0D  1  18                   CLC                     ; clear carry for add
001C0E  1  69 02                ADC     #$02            ; +2 (offset past var name bytes)
001C10  1  A4 AB                LDY     Vrschh          ; get var address high byte
001C12  1  90 01                BCC     LAB_1DE1        ; branch if no overflow from add
001C14  1               
001C14  1  C8                   INY                     ; else increment high byte
001C15  1               LAB_1DE1
001C15  1  85 95                STA     Cvaral          ; save current var address low byte
001C17  1  84 96                STY     Cvarah          ; save current var address high byte
001C19  1  60                   RTS
001C1A  1               
001C1A  1               ; set-up array pointer (Adatal/h) to first element in array
001C1A  1               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
001C1A  1               
001C1A  1               LAB_1DE6
001C1A  1  A5 5D                LDA     Dimcnt          ; get # of dimensions (1, 2 or 3)
001C1C  1  0A                   ASL     A               ; *2 (also clears the carry !)
001C1D  1  69 05                ADC     #$05            ; +5 (result is 7, 9 or 11 here)
001C1F  1  65 AA                ADC     Astrtl          ; add array start pointer low byte
001C21  1  A4 AB                LDY     Astrth          ; get array pointer high byte
001C23  1  90 01                BCC     LAB_1DF2        ; branch if no overflow
001C25  1               
001C25  1  C8                   INY                     ; else increment high byte
001C26  1               LAB_1DF2
001C26  1  85 A4                STA     Adatal          ; save array data pointer low byte
001C28  1  84 A5                STY     Adatah          ; save array data pointer high byte
001C2A  1  60                   RTS
001C2B  1               
001C2B  1               ; evaluate integer expression
001C2B  1               
001C2B  1               LAB_EVIN
001C2B  1                       .IFDEF  DUODYNE
001C2B  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
001C2F  1                       .ELSE
001C2F  1                       JSR     LAB_IGBY        ; increment and scan memory
001C2F  1                       .ENDIF
001C2F  1               
001C2F  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
001C32  1               ; else do type mismatch
001C32  1               
001C32  1               ; evaluate integer expression (no check)
001C32  1               
001C32  1               LAB_EVPI
001C32  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
001C34  1  30 0D                BMI     LAB_1E12        ; do function call error if -ve
001C36  1               
001C36  1               ; evaluate integer expression (no sign check)
001C36  1               
001C36  1               LAB_EVIR
001C36  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
001C38  1  C9 90                CMP     #$90            ; compare with exponent = 2^16 (n>2^15)
001C3A  1  90 0C                BCC     LAB_1E14        ; branch if n<2^16 (is ok)
001C3C  1               
001C3C  1  A9 0E                LDA     #<LAB_1DF7      ; set pointer low byte to -32768
001C3E  1  A0 37                LDY     #>LAB_1DF7      ; set pointer high byte to -32768
001C40  1  20 49 2D             JSR     LAB_27F8        ; compare FAC1 with (AY)
001C43  1               LAB_1E12
001C43  1  F0 03 4C 12          LBNE    LAB_FCER        ; if <> do function call error then warm start
001C47  1  1D           
001C48  1               
001C48  1               LAB_1E14
001C48  1  4C E6 2D             JMP     LAB_2831        ; convert FAC1 floating-to-fixed and return
001C4B  1               
001C4B  1               ; find or make array
001C4B  1               
001C4B  1               LAB_1E17
001C4B  1  A5 5E                LDA     Defdim          ; get DIM flag
001C4D  1  48                   PHA                     ; push it
001C4E  1  A5 5F                LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
001C50  1  48                   PHA                     ; push it
001C51  1  A0 00                LDY     #$00            ; clear dimensions count
001C53  1               
001C53  1               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
001C53  1               
001C53  1               LAB_1E1F
001C53  1  98                   TYA                     ; copy dimensions count
001C54  1  48                   PHA                     ; save it
001C55  1  A5 94                LDA     Varnm2          ; get array name 2nd byte
001C57  1  48                   PHA                     ; save it
001C58  1  A5 93                LDA     Varnm1          ; get array name 1st byte
001C5A  1  48                   PHA                     ; save it
001C5B  1  20 2B 1C             JSR     LAB_EVIN        ; evaluate integer expression
001C5E  1  68                   PLA                     ; pull array name 1st byte
001C5F  1  85 93                STA     Varnm1          ; restore array name 1st byte
001C61  1  68                   PLA                     ; pull array name 2nd byte
001C62  1  85 94                STA     Varnm2          ; restore array name 2nd byte
001C64  1  68                   PLA                     ; pull dimensions count
001C65  1  A8                   TAY                     ; restore it
001C66  1  BA                   TSX                     ; copy stack pointer
001C67  1  BD 02 01             LDA     LAB_STAK+2,X    ; get DIM flag
001C6A  1  48                   PHA                     ; push it
001C6B  1  BD 01 01             LDA     LAB_STAK+1,X    ; get data type flag
001C6E  1  48                   PHA                     ; push it
001C6F  1  A5 AE                LDA     FAC1_2          ; get this dimension size high byte
001C71  1  9D 02 01             STA     LAB_STAK+2,X    ; stack before flag bytes
001C74  1  A5 AF                LDA     FAC1_3          ; get this dimension size low byte
001C76  1  9D 01 01             STA     LAB_STAK+1,X    ; stack before flag bytes
001C79  1  C8                   INY                     ; increment dimensions count
001C7A  1                       .IFDEF  DUODYNE
001C7A  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
001C7E  1                       .ELSE
001C7E  1                       JSR     LAB_GBYT        ; scan memory
001C7E  1                       .ENDIF
001C7E  1               
001C7E  1  C9 2C                CMP     #','            ; compare with ","
001C80  1  F0 D1                BEQ     LAB_1E1F        ; if found go do next dimension
001C82  1               
001C82  1  84 5D                STY     Dimcnt          ; store dimensions count
001C84  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
001C87  1  68                   PLA                     ; pull data type flag
001C88  1  85 5F                STA     Dtypef          ; restore data type flag, $FF=string, $00=numeric
001C8A  1  68                   PLA                     ; pull DIM flag
001C8B  1  85 5E                STA     Defdim          ; restore DIM flag
001C8D  1  A6 7D                LDX     Sarryl          ; get array mem start low byte
001C8F  1  A5 7E                LDA     Sarryh          ; get array mem start high byte
001C91  1               
001C91  1               ; now check to see if we are at the end of array memory (we would be if there were
001C91  1               ; no arrays).
001C91  1               
001C91  1               LAB_1E5C
001C91  1  86 AA                STX     Astrtl          ; save as array start pointer low byte
001C93  1  85 AB                STA     Astrth          ; save as array start pointer high byte
001C95  1  C5 80                CMP     Earryh          ; compare with array mem end high byte
001C97  1  D0 07                BNE     LAB_1E68        ; branch if not reached array mem end
001C99  1               
001C99  1  E4 7F                CPX     Earryl          ; else compare with array mem end low byte
001C9B  1  D0 03 4C 41          LBEQ    LAB_1EA1        ; go build array if not found
001C9F  1  1D           
001CA0  1               
001CA0  1               ; search for array
001CA0  1               LAB_1E68
001CA0  1  A0 00                LDY     #$00            ; clear index
001CA2  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get array name first byte
001CA6  1  B5 AA C9 00  
001CAA  1  D0 04 A2 00  
001CB8  1  C8                   INY                     ; increment index to second name byte
001CB9  1  C5 93                CMP     Varnm1          ; compare with this array name first byte
001CBB  1  D0 1C                BNE     LAB_1E77        ; branch if no match
001CBD  1               
001CBD  1  A5 94                LDA     Varnm2          ; else get this array name second byte
001CBF  1  8B 48 DA A2          CMPINDIRECTY Astrtl     ; compare with array name second byte
001CC3  1  01 B5 AA C9  
001CC7  1  00 D0 04 A2  
001CD7  1  F0 3E                BEQ     LAB_1E8D        ; array found so branch
001CD9  1               
001CD9  1               ; no match
001CD9  1               LAB_1E77
001CD9  1  C8                   INY                     ; increment index
001CDA  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get array size low byte
001CDE  1  B5 AA C9 00  
001CE2  1  D0 04 A2 00  
001CF0  1  18                   CLC                     ; clear carry for add
001CF1  1  65 AA                ADC     Astrtl          ; add array start pointer low byte
001CF3  1  AA                   TAX                     ; copy low byte to X
001CF4  1  C8                   INY                     ; increment index
001CF5  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get array size high byte
001CF9  1  B5 AA C9 00  
001CFD  1  D0 04 A2 00  
001D0B  1  65 AB                ADC     Astrth          ; add array mem pointer high byte
001D0D  1  90 82                BCC     LAB_1E5C        ; if no overflow go check next array
001D0F  1               
001D0F  1               ; do array bounds error
001D0F  1               
001D0F  1               LAB_1E85
001D0F  1  A2 10                LDX     #$10            ; error code $10 ("Array bounds" error)
001D11  1  2C                   .BYTE   $2C             ; makes next bit BIT LAB_08A2
001D12  1               
001D12  1               ; do function call error
001D12  1               
001D12  1               LAB_FCER
001D12  1  A2 08                LDX     #$08            ; error code $08 ("Function call" error)
001D14  1               LAB_1E8A
001D14  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
001D17  1               
001D17  1               ; found array, are we trying to dimension it?
001D17  1               LAB_1E8D
001D17  1  A2 12                LDX     #$12            ; set error $12 ("Double dimension" error)
001D19  1  A5 5E                LDA     Defdim          ; get DIM flag
001D1B  1  D0 F7                BNE     LAB_1E8A        ; if we are trying to dimension it do error #X, then warm
001D1D  1               ; start
001D1D  1               
001D1D  1               ; found the array and we're not dimensioning it so we must find an element in it
001D1D  1               
001D1D  1  20 1A 1C             JSR     LAB_1DE6        ; set-up array pointer (Adatal/h) to first element in array
001D20  1               ; (Astrtl,Astrth points to start of array)
001D20  1  A5 5D                LDA     Dimcnt          ; get dimensions count
001D22  1  A0 04                LDY     #$04            ; set index to array's # of dimensions
001D24  1  8B 48 DA A2          CMPINDIRECTY Astrtl     ; compare with no of dimensions
001D28  1  01 B5 AA C9  
001D2C  1  00 D0 04 A2  
001D3C  1  D0 D1                BNE     LAB_1E85        ; if wrong do array bounds error, could do "Wrong
001D3E  1               ; dimensions" error here .. if we want a different
001D3E  1               ; error message
001D3E  1               
001D3E  1  4C 83 1E             JMP     LAB_1F28        ; found array so go get element
001D41  1               ; (could jump to LAB_1F28 as all LAB_1F24 does is take
001D41  1               ; Dimcnt and save it at (Astrtl),Y which is already the
001D41  1               ; same or we would have taken the BNE)
001D41  1               
001D41  1               ; array not found, so build it
001D41  1               LAB_1EA1
001D41  1  20 1A 1C             JSR     LAB_1DE6        ; set-up array pointer (Adatal/h) to first element in array
001D44  1               ; (Astrtl,Astrth points to start of array)
001D44  1  20 C6 09             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
001D47  1               ; addr to check is in AY (low/high)
001D47  1  A0 00                LDY     #$00            ; clear Y (don't need to clear A)
001D49  1  84 BB                STY     Aspth           ; clear array data size high byte
001D4B  1  A5 93                LDA     Varnm1          ; get variable name 1st byte
001D4D  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save array name 1st byte
001D51  1  01 B5 AA C9  
001D55  1  00 D0 04 A2  
001D63  1  C8                   INY                     ; increment index
001D64  1  A5 94                LDA     Varnm2          ; get variable name 2nd byte
001D66  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save array name 2nd byte
001D6A  1  01 B5 AA C9  
001D6E  1  00 D0 04 A2  
001D7C  1  A5 5D                LDA     Dimcnt          ; get dimensions count
001D7E  1  A0 04                LDY     #$04            ; index to dimension count
001D80  1  84 BA                STY     Asptl           ; set array data size low byte (four bytes per element)
001D82  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; set array's dimensions count
001D86  1  01 B5 AA C9  
001D8A  1  00 D0 04 A2  
001D98  1               
001D98  1               ; now calculate the size of the data space for the array
001D98  1  18                   CLC                     ; clear carry for add (clear on subsequent loops)
001D99  1               LAB_1EC0
001D99  1  A2 0B                LDX     #$0B            ; set default dimension value low byte
001D9B  1  A9 00                LDA     #$00            ; set default dimension value high byte
001D9D  1  24 5E                BIT     Defdim          ; test default DIM flag
001D9F  1  50 07                BVC     LAB_1ED0        ; branch if b6 of Defdim is clear
001DA1  1               
001DA1  1  68                   PLA                     ; else pull dimension value low byte
001DA2  1  69 01                ADC     #$01            ; +1 (allow for zeroeth element)
001DA4  1  AA                   TAX                     ; copy low byte to X
001DA5  1  68                   PLA                     ; pull dimension value high byte
001DA6  1  69 00                ADC     #$00            ; add carry from low byte
001DA8  1               
001DA8  1               LAB_1ED0
001DA8  1  C8                   INY                     ; index to dimension value high byte
001DA9  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save dimension value high byte
001DAD  1  01 B5 AA C9  
001DB1  1  00 D0 04 A2  
001DBF  1  C8                   INY                     ; index to dimension value high byte
001DC0  1  8A                   TXA                     ; get dimension value low byte
001DC1  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save dimension value low byte
001DC5  1  01 B5 AA C9  
001DC9  1  00 D0 04 A2  
001DD7  1  20 FE 1E             JSR     LAB_1F7C        ; does XY = (Astrtl),Y * (Asptl)
001DDA  1  86 BA                STX     Asptl           ; save array data size low byte
001DDC  1  85 BB                STA     Aspth           ; save array data size high byte
001DDE  1  A4 71                LDY     ut1_pl          ; restore index (saved by subroutine)
001DE0  1  C6 5D                DEC     Dimcnt          ; decrement dimensions count
001DE2  1  D0 B5                BNE     LAB_1EC0        ; loop while not = 0
001DE4  1               
001DE4  1  65 A5                ADC     Adatah          ; add size high byte to first element high byte
001DE6  1               ; (carry is always clear here)
001DE6  1  B0 02 80 03          LBCS    LAB_1F45        ; if overflow go do "Out of memory" error
001DEA  1  4C CC 1E     
001DED  1               
001DED  1  85 A5                STA     Adatah          ; save end of array high byte
001DEF  1  A8                   TAY                     ; copy end high byte to Y
001DF0  1  8A                   TXA                     ; get array size low byte
001DF1  1  65 A4                ADC     Adatal          ; add array start low byte
001DF3  1  90 06                BCC     LAB_1EF3        ; branch if no carry
001DF5  1               
001DF5  1  C8                   INY                     ; else increment end of array high byte
001DF6  1  D0 03 4C CC          LBEQ    LAB_1F45        ; if overflow go do "Out of memory" error
001DFA  1  1E           
001DFB  1               
001DFB  1               ; set-up mostly complete, now zero the array
001DFB  1               LAB_1EF3
001DFB  1  20 C6 09             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
001DFE  1               ; addr to check is in AY (low/high)
001DFE  1  85 7F                STA     Earryl          ; save array mem end low byte
001E00  1  84 80                STY     Earryh          ; save array mem end high byte
001E02  1  A9 00                LDA     #$00            ; clear byte for array clear
001E04  1  E6 BB                INC     Aspth           ; increment array size high byte (now block count)
001E06  1  A4 BA                LDY     Asptl           ; get array size low byte (now index to block)
001E08  1  F0 19                BEQ     LAB_1F07        ; branch if low byte = $00
001E0A  1               
001E0A  1               LAB_1F02
001E0A  1  88                   DEY                     ; decrement index (do 0 to n-1)
001E0B  1  8B DA 48 A2          STAINDIRECTY Adatal     ; zero byte
001E0F  1  01 B5 A4 C9  
001E13  1  00 D0 04 A2  
001E21  1  D0 E7                BNE     LAB_1F02        ; loop until this block done
001E23  1               
001E23  1               LAB_1F07
001E23  1  C6 A5                DEC     Adatah          ; decrement array pointer high byte
001E25  1  C6 BB                DEC     Aspth           ; decrement block count high byte
001E27  1  D0 E1                BNE     LAB_1F02        ; loop until all blocks done
001E29  1               
001E29  1  E6 A5                INC     Adatah          ; correct for last loop
001E2B  1  38                   SEC                     ; set carry for subtract
001E2C  1  A0 02                LDY     #$02            ; index to array size low byte
001E2E  1  A5 7F                LDA     Earryl          ; get array mem end low byte
001E30  1  E5 AA                SBC     Astrtl          ; subtract array start low byte
001E32  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save array size low byte
001E36  1  01 B5 AA C9  
001E3A  1  00 D0 04 A2  
001E48  1  C8                   INY                     ; index to array size high byte
001E49  1  A5 80                LDA     Earryh          ; get array mem end high byte
001E4B  1  E5 AB                SBC     Astrth          ; subtract array start high byte
001E4D  1  8B DA 48 A2          STAINDIRECTY Astrtl     ; save array size high byte
001E51  1  01 B5 AA C9  
001E55  1  00 D0 04 A2  
001E63  1  A5 5E                LDA     Defdim          ; get default DIM flag
001E65  1  F0 03 4C FD          LBNE    LAB_1F7B        ; exit (RET) if this was a DIM command
001E69  1  1E           
001E6A  1               
001E6A  1               ; else, find element
001E6A  1  C8                   INY                     ; index to # of dimensions
001E6B  1               
001E6B  1               LAB_1F24
001E6B  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get array's dimension count
001E6F  1  B5 AA C9 00  
001E73  1  D0 04 A2 00  
001E81  1  85 5D                STA     Dimcnt          ; save it
001E83  1               
001E83  1               ; we have found, or built, the array. now we need to find the element
001E83  1               
001E83  1               LAB_1F28
001E83  1  A9 00                LDA     #$00            ; clear byte
001E85  1  85 BA                STA     Asptl           ; clear array data pointer low byte
001E87  1               LAB_1F2C
001E87  1  85 BB                STA     Aspth           ; save array data pointer high byte
001E89  1  C8                   INY                     ; increment index (point to array bound high byte)
001E8A  1  68                   PLA                     ; pull array index low byte
001E8B  1  AA                   TAX                     ; copy to X
001E8C  1  85 AE                STA     FAC1_2          ; save index low byte to FAC1 mantissa2
001E8E  1  68                   PLA                     ; pull array index high byte
001E8F  1  85 AF                STA     FAC1_3          ; save index high byte to FAC1 mantissa3
001E91  1  8B 48 DA A2          CMPINDIRECTY Astrtl     ; compare with array bound high byte
001E95  1  01 B5 AA C9  
001E99  1  00 D0 04 A2  
001EA9  1  90 24                BCC     LAB_1F48        ; branch if within bounds
001EAB  1               
001EAB  1  D0 1C                BNE     LAB_1F42        ; if outside bounds do array bounds error
001EAD  1               
001EAD  1               ; else high byte was = so test low bytes
001EAD  1  C8                   INY                     ; index to array bound low byte
001EAE  1  8A                   TXA                     ; get array index low byte
001EAF  1  8B 48 DA A2          CMPINDIRECTY Astrtl     ; compare with array bound low byte
001EB3  1  01 B5 AA C9  
001EB7  1  00 D0 04 A2  
001EC7  1  90 07                BCC     LAB_1F49        ; branch if within bounds
001EC9  1               
001EC9  1               LAB_1F42
001EC9  1  4C 0F 1D             JMP     LAB_1E85        ; else do array bounds error
001ECC  1               
001ECC  1               LAB_1F45
001ECC  1  4C F5 09             JMP     LAB_OMER        ; do "Out of memory" error then warm start
001ECF  1               
001ECF  1               LAB_1F48
001ECF  1  C8                   INY                     ; index to array bound low byte
001ED0  1               LAB_1F49
001ED0  1  A5 BB                LDA     Aspth           ; get array data pointer high byte
001ED2  1  05 BA                ORA     Asptl           ; OR with array data pointer low byte
001ED4  1  F0 0A                BEQ     LAB_1F5A        ; branch if array data pointer = null (skip multiply)
001ED6  1               
001ED6  1  20 FE 1E             JSR     LAB_1F7C        ; does XY = (Astrtl),Y * (Asptl)
001ED9  1  8A                   TXA                     ; get result low byte
001EDA  1  65 AE                ADC     FAC1_2          ; add index low byte from FAC1 mantissa2
001EDC  1  AA                   TAX                     ; save result low byte
001EDD  1  98                   TYA                     ; get result high byte
001EDE  1  A4 71                LDY     ut1_pl          ; restore index
001EE0  1               LAB_1F5A
001EE0  1  65 AF                ADC     FAC1_3          ; add index high byte from FAC1 mantissa3
001EE2  1  86 BA                STX     Asptl           ; save array data pointer low byte
001EE4  1  C6 5D                DEC     Dimcnt          ; decrement dimensions count
001EE6  1  D0 9F                BNE     LAB_1F2C        ; loop if dimensions still to do
001EE8  1               
001EE8  1  06 BA                ASL     Asptl           ; array data pointer low byte * 2
001EEA  1  2A                   ROL     A               ; array data pointer high byte * 2
001EEB  1  06 BA                ASL     Asptl           ; array data pointer low byte * 4
001EED  1  2A                   ROL     A               ; array data pointer high byte * 4
001EEE  1  A8                   TAY                     ; copy high byte
001EEF  1  A5 BA                LDA     Asptl           ; get low byte
001EF1  1  65 A4                ADC     Adatal          ; add array data start pointer low byte
001EF3  1  85 95                STA     Cvaral          ; save as current var address low byte
001EF5  1  98                   TYA                     ; get high byte back
001EF6  1  65 A5                ADC     Adatah          ; add array data start pointer high byte
001EF8  1  85 96                STA     Cvarah          ; save as current var address high byte
001EFA  1  A8                   TAY                     ; copy high byte to Y
001EFB  1  A5 95                LDA     Cvaral          ; get current var address low byte
001EFD  1               LAB_1F7B
001EFD  1  60                   RTS
001EFE  1               
001EFE  1               ; does XY = (Astrtl),Y * (Asptl)
001EFE  1               
001EFE  1               LAB_1F7C
001EFE  1  84 71                STY     ut1_pl          ; save index
001F00  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get dimension size low byte
001F04  1  B5 AA C9 00  
001F08  1  D0 04 A2 00  
001F16  1  85 76                STA     dims_l          ; save dimension size low byte
001F18  1  88                   DEY                     ; decrement index
001F19  1  8B DA A2 01          LDAINDIRECTY Astrtl     ; get dimension size high byte
001F1D  1  B5 AA C9 00  
001F21  1  D0 04 A2 00  
001F2F  1  85 77                STA     dims_h          ; save dimension size high byte
001F31  1               
001F31  1  A9 10                LDA     #$10            ; count = $10 (16 bit multiply)
001F33  1  85 A8                STA     numbit          ; save bit count
001F35  1  A2 00                LDX     #$00            ; clear result low byte
001F37  1  A0 00                LDY     #$00            ; clear result high byte
001F39  1               LAB_1F8F
001F39  1  8A                   TXA                     ; get result low byte
001F3A  1  0A                   ASL     A               ; *2
001F3B  1  AA                   TAX                     ; save result low byte
001F3C  1  98                   TYA                     ; get result high byte
001F3D  1  2A                   ROL     A               ; *2
001F3E  1  A8                   TAY                     ; save result high byte
001F3F  1  B0 8B                BCS     LAB_1F45        ; if overflow go do "Out of memory" error
001F41  1               
001F41  1  06 BA                ASL     Asptl           ; shift multiplier low byte
001F43  1  26 BB                ROL     Aspth           ; shift multiplier high byte
001F45  1  90 10                BCC     LAB_1FA8        ; skip add if no carry
001F47  1               
001F47  1  18                   CLC                     ; else clear carry for add
001F48  1  8A                   TXA                     ; get result low byte
001F49  1  65 76                ADC     dims_l          ; add dimension size low byte
001F4B  1  AA                   TAX                     ; save result low byte
001F4C  1  98                   TYA                     ; get result high byte
001F4D  1  65 77                ADC     dims_h          ; add dimension size high byte
001F4F  1  A8                   TAY                     ; save result high byte
001F50  1  B0 02 80 03          LBCS    LAB_1F45        ; if overflow go do "Out of memory" error
001F54  1  4C CC 1E     
001F57  1               
001F57  1               LAB_1FA8
001F57  1  C6 A8                DEC     numbit          ; decrement bit count
001F59  1  D0 DE                BNE     LAB_1F8F        ; loop until all done
001F5B  1               
001F5B  1  60                   RTS
001F5C  1               
001F5C  1               ; perform FRE()
001F5C  1               
001F5C  1               LAB_FRE
001F5C  1  A5 5F                LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
001F5E  1  10 03                BPL     LAB_1FB4        ; branch if numeric
001F60  1               
001F60  1  20 92 24             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
001F63  1               ; space returns with A = length, X=$71=pointer low byte,
001F63  1               ; Y=$72=pointer high byte
001F63  1               
001F63  1               ; FRE(n) was numeric so do this
001F63  1               LAB_1FB4
001F63  1  20 C2 21             JSR     LAB_GARB        ; go do garbage collection
001F66  1  38                   SEC                     ; set carry for subtract
001F67  1  A5 81                LDA     Sstorl          ; get bottom of string space low byte
001F69  1  E5 7F                SBC     Earryl          ; subtract array mem end low byte
001F6B  1  A8                   TAY                     ; copy result to Y
001F6C  1  A5 82                LDA     Sstorh          ; get bottom of string space high byte
001F6E  1  E5 80                SBC     Earryh          ; subtract array mem end high byte
001F70  1               
001F70  1               ; save and convert integer AY to FAC1
001F70  1               
001F70  1               LAB_AYFC
001F70  1  46 5F                LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
001F72  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
001F74  1  84 AE                STY     FAC1_2          ; save FAC1 mantissa2
001F76  1  A2 90                LDX     #$90            ; set exponent=2^16 (integer)
001F78  1  4C 34 2D             JMP     LAB_27E3        ; set exp=X, clear FAC1_3, normalise and return
001F7B  1               
001F7B  1               ; perform POS()
001F7B  1               
001F7B  1               LAB_POS
001F7B  1  A4 0E                LDY     TPos            ; get terminal position
001F7D  1               
001F7D  1               ; convert Y to byte in FAC1
001F7D  1               
001F7D  1               LAB_1FD0
001F7D  1  A9 00                LDA     #$00            ; clear high byte
001F7F  1  F0 EF                BEQ     LAB_AYFC        ; always save and convert integer AY to FAC1 and return
001F81  1               
001F81  1               ; check not Direct (used by DEF and INPUT)
001F81  1               
001F81  1               LAB_CKRN
001F81  1  A6 88                LDX     Clineh          ; get current line high byte
001F83  1  E8                   INX                     ; increment it
001F84  1  F0 03 4C FD          LBNE    LAB_1F7B        ; return if can continue not direct mode
001F88  1  1E           
001F89  1               
001F89  1               ; else do illegal direct error
001F89  1               LAB_1FD9
001F89  1  A2 16                LDX     #$16            ; error code $16 ("Illegal direct" error)
001F8B  1               LAB_1FDB
001F8B  1  4C F7 09             JMP     LAB_XERR        ; go do error #X, then warm start
001F8E  1               
001F8E  1               ; perform DEF
001F8E  1               
001F8E  1               LAB_DEF
001F8E  1  20 BF 1F             JSR     LAB_200B        ; check FNx syntax
001F91  1  85 9C                STA     func_l          ; save function pointer low byte
001F93  1  84 9D                STY     func_h          ; save function pointer high byte
001F95  1  20 81 1F             JSR     LAB_CKRN        ; check not Direct (back here if ok)
001F98  1  20 AF 18             JSR     LAB_1BFE        ; scan for "(" , else do syntax error then warm start
001F9B  1  A9 80                LDA     #$80            ; set flag for FNx
001F9D  1  85 61                STA     Sufnxf          ; save subscript/FNx flag
001F9F  1  20 8E 1A             JSR     LAB_GVAR        ; get (var) address
001FA2  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
001FA5  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
001FA8  1  A9 C2                LDA     #TK_EQUAL       ; get = token
001FAA  1  20 A4 18             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
001FAD  1  A5 96                LDA     Cvarah          ; get current var address high byte
001FAF  1  48                   PHA                     ; push it
001FB0  1  A5 95                LDA     Cvaral          ; get current var address low byte
001FB2  1  48                   PHA                     ; push it
001FB3  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
001FB5  1  48                   PHA                     ; push it
001FB6  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
001FB8  1  48                   PHA                     ; push it
001FB9  1  20 FC 11             JSR     LAB_DATA        ; go perform DATA
001FBC  1  4C 93 20             JMP     LAB_207A        ; put execute pointer and variable pointer into function
001FBF  1               ; and return
001FBF  1               
001FBF  1               ; check FNx syntax
001FBF  1               
001FBF  1               LAB_200B
001FBF  1  A9 AF                LDA     #TK_FN          ; get FN" token
001FC1  1  20 A4 18             JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
001FC4  1               ; return character after A
001FC4  1  09 80                ORA     #$80            ; set FN flag bit
001FC6  1  85 61                STA     Sufnxf          ; save FN flag so array variable test fails
001FC8  1  20 96 1A             JSR     LAB_1D12        ; search for FN variable
001FCB  1  4C 80 17             JMP     LAB_CTNM        ; check if source is numeric and return, else do type
001FCE  1               ; mismatch
001FCE  1               
001FCE  1               ; Evaluate FNx
001FCE  1               LAB_201E
001FCE  1  20 BF 1F             JSR     LAB_200B        ; check FNx syntax
001FD1  1  48                   PHA                     ; push function pointer low byte
001FD2  1  98                   TYA                     ; copy function pointer high byte
001FD3  1  48                   PHA                     ; push function pointer high byte
001FD4  1  20 AF 18             JSR     LAB_1BFE        ; scan for "(", else do syntax error then warm start
001FD7  1  20 91 17             JSR     LAB_EVEX        ; evaluate expression
001FDA  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
001FDD  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
001FE0  1  68                   PLA                     ; pop function pointer high byte
001FE1  1  85 9D                STA     func_h          ; restore it
001FE3  1  68                   PLA                     ; pop function pointer low byte
001FE4  1  85 9C                STA     func_l          ; restore it
001FE6  1  A2 20                LDX     #$20            ; error code $20 ("Undefined function" error)
001FE8  1  A0 03                LDY     #$03            ; index to variable pointer high byte
001FEA  1  8B DA A2 01          LDAINDIRECTY func_l     ; get variable pointer high byte
001FEE  1  B5 9C C9 00  
001FF2  1  D0 04 A2 00  
002000  1  F0 89                BEQ     LAB_1FDB        ; if zero go do undefined function error
002002  1               
002002  1  85 96                STA     Cvarah          ; save variable address high byte
002004  1  88                   DEY                     ; index to variable address low byte
002005  1  8B DA A2 01          LDAINDIRECTY func_l     ; get variable address low byte
002009  1  B5 9C C9 00  
00200D  1  D0 04 A2 00  
00201B  1  85 95                STA     Cvaral          ; save variable address low byte
00201D  1  AA                   TAX                     ; copy address low byte
00201E  1               
00201E  1               ; now stack the function variable value before use
00201E  1  C8                   INY                     ; index to mantissa_3
00201F  1               LAB_2043
00201F  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get byte from variable
002023  1  B5 95 C9 00  
002027  1  D0 04 A2 00  
002035  1  48                   PHA                     ; stack it
002036  1  88                   DEY                     ; decrement index
002037  1  10 E6                BPL     LAB_2043        ; loop until variable stacked
002039  1               
002039  1  A4 96                LDY     Cvarah          ; get variable address high byte
00203B  1  20 89 2C             JSR     LAB_2778        ; pack FAC1 (function expression value) into (XY)
00203E  1               ; (function variable), return Y=0, always
00203E  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
002040  1  48                   PHA                     ; push it
002041  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
002043  1  48                   PHA                     ; push it
002044  1  8B DA A2 01          LDAINDIRECTY func_l     ; get function execute pointer low byte
002048  1  B5 9C C9 00  
00204C  1  D0 04 A2 00  
00205A  1  85 C3                STA     Bpntrl          ; save as BASIC execute pointer low byte
00205C  1  C8                   INY                     ; index to high byte
00205D  1  8B DA A2 01          LDAINDIRECTY func_l     ; get function execute pointer high byte
002061  1  B5 9C C9 00  
002065  1  D0 04 A2 00  
002073  1  85 C4                STA     Bpntrh          ; save as BASIC execute pointer high byte
002075  1  A5 96                LDA     Cvarah          ; get variable address high byte
002077  1  48                   PHA                     ; push it
002078  1  A5 95                LDA     Cvaral          ; get variable address low byte
00207A  1  48                   PHA                     ; push it
00207B  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00207E  1               ; else do type mismatch
00207E  1  68                   PLA                     ; pull variable address low byte
00207F  1  85 9C                STA     func_l          ; save variable address low byte
002081  1  68                   PLA                     ; pull variable address high byte
002082  1  85 9D                STA     func_h          ; save variable address high byte
002084  1                       .IFDEF  DUODYNE
002084  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002088  1                       .ELSE
002088  1                       JSR     LAB_GBYT        ; scan memory
002088  1                       .ENDIF
002088  1               
002088  1  F0 03                BEQ     LAB_2074        ; branch if null (should be [EOL] marker)
00208A  1               
00208A  1  4C B7 18             JMP     LAB_SNER        ; else syntax error then warm start
00208D  1               
00208D  1               ; restore Bpntrl,Bpntrh and function variable from stack
00208D  1               
00208D  1               LAB_2074
00208D  1  68                   PLA                     ; pull BASIC execute pointer low byte
00208E  1  85 C3                STA     Bpntrl          ; restore BASIC execute pointer low byte
002090  1  68                   PLA                     ; pull BASIC execute pointer high byte
002091  1  85 C4                STA     Bpntrh          ; restore BASIC execute pointer high byte
002093  1               
002093  1               ; put execute pointer and variable pointer into function
002093  1               
002093  1               LAB_207A
002093  1  A0 00                LDY     #$00            ; clear index
002095  1  68                   PLA                     ; pull BASIC execute pointer low byte
002096  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
00209A  1  01 B5 9C C9  
00209E  1  00 D0 04 A2  
0020AC  1  C8                   INY                     ; increment index
0020AD  1  68                   PLA                     ; pull BASIC execute pointer high byte
0020AE  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
0020B2  1  01 B5 9C C9  
0020B6  1  00 D0 04 A2  
0020C4  1  C8                   INY                     ; increment index
0020C5  1  68                   PLA                     ; pull current var address low byte
0020C6  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
0020CA  1  01 B5 9C C9  
0020CE  1  00 D0 04 A2  
0020DC  1  C8                   INY                     ; increment index
0020DD  1  68                   PLA                     ; pull current var address high byte
0020DE  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
0020E2  1  01 B5 9C C9  
0020E6  1  00 D0 04 A2  
0020F4  1  60                   RTS
0020F5  1               
0020F5  1               ; perform STR$()
0020F5  1               
0020F5  1               LAB_STRS
0020F5  1  20 80 17             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
0020F8  1  20 49 2F             JSR     LAB_296E        ; convert FAC1 to string
0020FB  1  A9 F0                LDA     #<Decssp1       ; set result string low pointer
0020FD  1  A0 00                LDY     #>Decssp1       ; set result string high pointer
0020FF  1  F0 12                BEQ     LAB_20AE        ; print null terminated string to Sutill/Sutilh
002101  1               
002101  1               ; Do string vector
002101  1               ; copy des_pl/h to des_2l/h and make string space A bytes long
002101  1               
002101  1               LAB_209C
002101  1  A6 AE                LDX     des_pl          ; get descriptor pointer low byte
002103  1  A4 AF                LDY     des_ph          ; get descriptor pointer high byte
002105  1  86 9E                STX     des_2l          ; save descriptor pointer low byte
002107  1  84 9F                STY     des_2h          ; save descriptor pointer high byte
002109  1               
002109  1               ; make string space A bytes long
002109  1               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
002109  1               
002109  1               LAB_MSSP
002109  1  20 90 21             JSR     LAB_2115        ; make space in string memory for string A long
00210C  1               ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00210C  1  86 AD                STX     str_pl          ; save string pointer low byte
00210E  1  84 AE                STY     str_ph          ; save string pointer high byte
002110  1  85 AC                STA     str_ln          ; save length
002112  1  60                   RTS
002113  1               
002113  1               ; Scan, set up string
002113  1               ; print " terminated string to Sutill/Sutilh
002113  1               
002113  1               LAB_20AE
002113  1  A2 22                LDX     #$22            ; set terminator to "
002115  1  86 5B                STX     Srchc           ; set search character (terminator 1)
002117  1  86 5C                STX     Asrch           ; set terminator 2
002119  1               
002119  1               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
002119  1               ; source is AY
002119  1               
002119  1               LAB_20B4
002119  1  85 B8                STA     ssptr_l         ; store string start low byte
00211B  1  84 B9                STY     ssptr_h         ; store string start high byte
00211D  1  85 AD                STA     str_pl          ; save string pointer low byte
00211F  1  84 AE                STY     str_ph          ; save string pointer high byte
002121  1  A0 FF                LDY     #$FF            ; set length to -1
002123  1               LAB_20BE
002123  1  C8                   INY                     ; increment length
002124  1  8B DA A2 01          LDAINDIRECTY ssptr_l    ; get byte from string
002128  1  B5 B8 C9 00  
00212C  1  D0 04 A2 00  
00213A  1  F0 0C                BEQ     LAB_20CF        ; exit loop if null byte [EOS]
00213C  1               
00213C  1  C5 5B                CMP     Srchc           ; compare with search character (terminator 1)
00213E  1  F0 04                BEQ     LAB_20CB        ; branch if terminator
002140  1               
002140  1  C5 5C                CMP     Asrch           ; compare with terminator 2
002142  1  D0 DF                BNE     LAB_20BE        ; loop if not terminator 2
002144  1               
002144  1               LAB_20CB
002144  1  C9 22                CMP     #$22            ; compare with "
002146  1  F0 01                BEQ     LAB_20D0        ; branch if " (carry set if = !)
002148  1               
002148  1               LAB_20CF
002148  1  18                   CLC                     ; clear carry for add (only if [EOL] terminated string)
002149  1               LAB_20D0
002149  1  84 AC                STY     str_ln          ; save length in FAC1 exponent
00214B  1  98                   TYA                     ; copy length to A
00214C  1  65 B8                ADC     ssptr_l         ; add string start low byte
00214E  1  85 BA                STA     Sendl           ; save string end low byte
002150  1  A6 B9                LDX     ssptr_h         ; get string start high byte
002152  1  90 01                BCC     LAB_20DC        ; branch if no low byte overflow
002154  1               
002154  1  E8                   INX                     ; else increment high byte
002155  1               LAB_20DC
002155  1  86 BB                STX     Sendh           ; save string end high byte
002157  1  A5 B9                LDA     ssptr_h         ; get string start high byte
002159  1  C9 08                CMP     #>BASICBEGIN    ; compare with BASICBEGIN, FORMERLY (Ram_base) start of program memory
00215B  1  B0 0B                BCS     LAB_RTST        ; branch if not in utility area
00215D  1               
00215D  1               ; string in utility area, move to string memory
00215D  1  98                   TYA                     ; copy length to A
00215E  1  20 01 21             JSR     LAB_209C        ; copy des_pl/h to des_2l/h and make string space A bytes
002161  1               ; long
002161  1  A6 B8                LDX     ssptr_l         ; get string start low byte
002163  1  A4 B9                LDY     ssptr_h         ; get string start high byte
002165  1  20 4B 24             JSR     LAB_2298        ; store string A bytes long from XY to (Sutill)
002168  1               
002168  1               ; check for space on descriptor stack then ..
002168  1               ; put string address and length on descriptor stack and update stack pointers
002168  1               
002168  1               LAB_RTST
002168  1  A6 65                LDX     next_s          ; get string stack pointer
00216A  1  E0 71                CPX     #des_sk+$09     ; compare with max+1
00216C  1  D0 05                BNE     LAB_20F8        ; branch if space on string stack
00216E  1               
00216E  1               ; else do string too complex error
00216E  1  A2 1C                LDX     #$1C            ; error code $1C ("String too complex" error)
002170  1               LAB_20F5
002170  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
002173  1               
002173  1               ; put string address and length on descriptor stack and update stack pointers
002173  1               
002173  1               LAB_20F8
002173  1  A5 AC                LDA     str_ln          ; get string length
002175  1  95 00                STA     PLUS_0,X        ; put on string stack
002177  1  A5 AD                LDA     str_pl          ; get string pointer low byte
002179  1  95 01                STA     PLUS_1,X        ; put on string stack
00217B  1  A5 AE                LDA     str_ph          ; get string pointer high byte
00217D  1  95 02                STA     PLUS_2,X        ; put on string stack
00217F  1  A0 00                LDY     #$00            ; clear Y
002181  1  86 AE                STX     des_pl          ; save string descriptor pointer low byte
002183  1  84 AF                STY     des_ph          ; save string descriptor pointer high byte (always $00)
002185  1  88                   DEY                     ; Y = $FF
002186  1  84 5F                STY     Dtypef          ; save data type flag, $FF=string
002188  1  86 66                STX     last_sl         ; save old stack pointer (current top item)
00218A  1  E8                   INX                     ; update stack pointer
00218B  1  E8                   INX                     ; update stack pointer
00218C  1  E8                   INX                     ; update stack pointer
00218D  1  86 65                STX     next_s          ; save new top item value
00218F  1  60                   RTS
002190  1               
002190  1               ; Build descriptor
002190  1               ; make space in string memory for string A long
002190  1               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
002190  1               
002190  1               LAB_2115
002190  1  46 60                LSR     Gclctd          ; clear garbage collected flag (b7)
002192  1               
002192  1               ; make space for string A long
002192  1               LAB_2117
002192  1  48                   PHA                     ; save string length
002193  1  49 FF                EOR     #$FF            ; complement it
002195  1  38                   SEC                     ; set carry for subtract (twos comp add)
002196  1  65 81                ADC     Sstorl          ; add bottom of string space low byte (subtract length)
002198  1  A4 82                LDY     Sstorh          ; get bottom of string space high byte
00219A  1  B0 01                BCS     LAB_2122        ; skip decrement if no underflow
00219C  1               
00219C  1  88                   DEY                     ; decrement bottom of string space high byte
00219D  1               LAB_2122
00219D  1  C4 80                CPY     Earryh          ; compare with array mem end high byte
00219F  1  90 11                BCC     LAB_2137        ; do out of memory error if less
0021A1  1               
0021A1  1  D0 04                BNE     LAB_212C        ; if not = skip next test
0021A3  1               
0021A3  1  C5 7F                CMP     Earryl          ; compare with array mem end low byte
0021A5  1  90 0B                BCC     LAB_2137        ; do out of memory error if less
0021A7  1               
0021A7  1               LAB_212C
0021A7  1  85 81                STA     Sstorl          ; save bottom of string space low byte
0021A9  1  84 82                STY     Sstorh          ; save bottom of string space high byte
0021AB  1  85 83                STA     Sutill          ; save string utility ptr low byte
0021AD  1  84 84                STY     Sutilh          ; save string utility ptr high byte
0021AF  1  AA                   TAX                     ; copy low byte to X
0021B0  1  68                   PLA                     ; get string length back
0021B1  1  60                   RTS
0021B2  1               
0021B2  1               LAB_2137
0021B2  1  A2 0C                LDX     #$0C            ; error code $0C ("Out of memory" error)
0021B4  1  A5 60                LDA     Gclctd          ; get garbage collected flag
0021B6  1  30 B8                BMI     LAB_20F5        ; if set then do error code X
0021B8  1               
0021B8  1  20 C2 21             JSR     LAB_GARB        ; else go do garbage collection
0021BB  1  A9 80                LDA     #$80            ; flag for garbage collected
0021BD  1  85 60                STA     Gclctd          ; set garbage collected flag
0021BF  1  68                   PLA                     ; pull length
0021C0  1  D0 D0                BNE     LAB_2117        ; go try again (loop always, length should never be = $00)
0021C2  1               
0021C2  1               ; garbage collection routine
0021C2  1               
0021C2  1               LAB_GARB
0021C2  1  A6 85                LDX     Ememl           ; get end of mem low byte
0021C4  1  A5 86                LDA     Ememh           ; get end of mem high byte
0021C6  1               
0021C6  1               ; re-run routine from last ending
0021C6  1               
0021C6  1               LAB_214B
0021C6  1  86 81                STX     Sstorl          ; set string storage low byte
0021C8  1  85 82                STA     Sstorh          ; set string storage high byte
0021CA  1  A0 00                LDY     #$00            ; clear index
0021CC  1  84 9D                STY     garb_h          ; clear working pointer high byte (flag no strings to move)
0021CE  1  A5 7F                LDA     Earryl          ; get array mem end low byte
0021D0  1  A6 80                LDX     Earryh          ; get array mem end high byte
0021D2  1  85 AA                STA     Histrl          ; save as highest string low byte
0021D4  1  86 AB                STX     Histrh          ; save as highest string high byte
0021D6  1  A9 68                LDA     #des_sk         ; set descriptor stack pointer
0021D8  1  85 71                STA     ut1_pl          ; save descriptor stack pointer low byte
0021DA  1  84 72                STY     ut1_ph          ; save descriptor stack pointer high byte ($00)
0021DC  1               LAB_2161
0021DC  1  C5 65                CMP     next_s          ; compare with descriptor stack pointer
0021DE  1  F0 05                BEQ     LAB_216A        ; branch if =
0021E0  1               
0021E0  1  20 B0 22             JSR     LAB_21D7        ; go garbage collect descriptor stack
0021E3  1  F0 F7                BEQ     LAB_2161        ; loop always
0021E5  1               
0021E5  1               ; done stacked strings, now do string vars
0021E5  1               LAB_216A
0021E5  1  06 A0                ASL     g_step          ; set step size = $06
0021E7  1  A5 7B                LDA     Svarl           ; get start of vars low byte
0021E9  1  A6 7C                LDX     Svarh           ; get start of vars high byte
0021EB  1  85 71                STA     ut1_pl          ; save as pointer low byte
0021ED  1  86 72                STX     ut1_ph          ; save as pointer high byte
0021EF  1               LAB_2176
0021EF  1  E4 7E                CPX     Sarryh          ; compare start of arrays high byte
0021F1  1  D0 04                BNE     LAB_217E        ; branch if no high byte match
0021F3  1               
0021F3  1  C5 7D                CMP     Sarryl          ; else compare start of arrays low byte
0021F5  1  F0 05                BEQ     LAB_2183        ; branch if = var mem end
0021F7  1               
0021F7  1               LAB_217E
0021F7  1  20 96 22             JSR     LAB_21D1        ; go garbage collect strings
0021FA  1  F0 F3                BEQ     LAB_2176        ; loop always
0021FC  1               
0021FC  1               ; done string vars, now do string arrays
0021FC  1               LAB_2183
0021FC  1  85 A4                STA     Nbendl          ; save start of arrays low byte as working pointer
0021FE  1  86 A5                STX     Nbendh          ; save start of arrays high byte as working pointer
002200  1  A9 04                LDA     #$04            ; set step size
002202  1  85 A0                STA     g_step          ; save step size
002204  1               LAB_218B
002204  1  A5 A4                LDA     Nbendl          ; get pointer low byte
002206  1  A6 A5                LDX     Nbendh          ; get pointer high byte
002208  1               LAB_218F
002208  1  E4 80                CPX     Earryh          ; compare with array mem end high byte
00220A  1  D0 07                BNE     LAB_219A        ; branch if not at end
00220C  1               
00220C  1  C5 7F                CMP     Earryl          ; else compare with array mem end low byte
00220E  1  D0 03 4C 2B          LBEQ    LAB_2216        ; tidy up and exit if at end
002212  1  23           
002213  1               
002213  1               LAB_219A
002213  1  85 71                STA     ut1_pl          ; save pointer low byte
002215  1  86 72                STX     ut1_ph          ; save pointer high byte
002217  1  A0 02                LDY     #$02            ; set index
002219  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get array size low byte
00221D  1  B5 71 C9 00  
002221  1  D0 04 A2 00  
00222F  1  65 A4                ADC     Nbendl          ; add start of this array low byte
002231  1  85 A4                STA     Nbendl          ; save start of next array low byte
002233  1  C8                   INY                     ; increment index
002234  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get array size high byte
002238  1  B5 71 C9 00  
00223C  1  D0 04 A2 00  
00224A  1  65 A5                ADC     Nbendh          ; add start of this array high byte
00224C  1  85 A5                STA     Nbendh          ; save start of next array high byte
00224E  1  A0 01                LDY     #$01            ; set index
002250  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get name second byte
002254  1  B5 71 C9 00  
002258  1  D0 04 A2 00  
002266  1  10 9C                BPL     LAB_218B        ; skip if not string array
002268  1               
002268  1               ; was string array so ..
002268  1               
002268  1  A0 04                LDY     #$04            ; set index
00226A  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get # of dimensions
00226E  1  B5 71 C9 00  
002272  1  D0 04 A2 00  
002280  1  0A                   ASL     A               ; *2
002281  1  69 05                ADC     #$05            ; +5 (array header size)
002283  1  20 1E 23             JSR     LAB_2208        ; go set up for first element
002286  1               LAB_21C4
002286  1  E4 A5                CPX     Nbendh          ; compare with start of next array high byte
002288  1  D0 07                BNE     LAB_21CC        ; branch if <> (go do this array)
00228A  1               
00228A  1  C5 A4                CMP     Nbendl          ; else compare element pointer low byte with next array
00228C  1               ; low byte
00228C  1  D0 03 4C 08          LBEQ    LAB_218F        ; if equal then go do next array
002290  1  22           
002291  1               
002291  1               LAB_21CC
002291  1  20 B0 22             JSR     LAB_21D7        ; go defrag array strings
002294  1  F0 F0                BEQ     LAB_21C4        ; go do next array string (loop always)
002296  1               
002296  1               ; defrag string variables
002296  1               ; enter with XA = variable pointer
002296  1               ; return with XA = next variable pointer
002296  1               
002296  1               LAB_21D1
002296  1  C8                   INY                     ; increment index (Y was $00)
002297  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get var name byte 2
00229B  1  B5 71 C9 00  
00229F  1  D0 04 A2 00  
0022AD  1  10 6C                BPL     LAB_2206        ; if not string, step pointer to next var and return
0022AF  1               
0022AF  1  C8                   INY                     ; else increment index
0022B0  1               LAB_21D7
0022B0  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string length
0022B4  1  B5 71 C9 00  
0022B8  1  D0 04 A2 00  
0022C6  1  F0 53                BEQ     LAB_2206        ; if null, step pointer to next string and return
0022C8  1               
0022C8  1  C8                   INY                     ; else increment index
0022C9  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer low byte
0022CD  1  B5 71 C9 00  
0022D1  1  D0 04 A2 00  
0022DF  1  AA                   TAX                     ; copy to X
0022E0  1  C8                   INY                     ; increment index
0022E1  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer high byte
0022E5  1  B5 71 C9 00  
0022E9  1  D0 04 A2 00  
0022F7  1  C5 82                CMP     Sstorh          ; compare bottom of string space high byte
0022F9  1  90 06                BCC     LAB_21EC        ; branch if less
0022FB  1               
0022FB  1  D0 1E                BNE     LAB_2206        ; if greater, step pointer to next string and return
0022FD  1               
0022FD  1               ; high bytes were = so compare low bytes
0022FD  1  E4 81                CPX     Sstorl          ; compare bottom of string space low byte
0022FF  1  B0 1A                BCS     LAB_2206        ; if >=, step pointer to next string and return
002301  1               
002301  1               ; string pointer is < string storage pointer (pos in mem)
002301  1               LAB_21EC
002301  1  C5 AB                CMP     Histrh          ; compare to highest string high byte
002303  1  90 17                BCC     LAB_2207        ; if <, step pointer to next string and return
002305  1               
002305  1  D0 04                BNE     LAB_21F6        ; if > update pointers, step to next and return
002307  1               
002307  1               ; high bytes were = so compare low bytes
002307  1  E4 AA                CPX     Histrl          ; compare to highest string low byte
002309  1  90 11                BCC     LAB_2207        ; if <, step pointer to next string and return
00230B  1               
00230B  1               ; string is in string memory space
00230B  1               LAB_21F6
00230B  1  86 AA                STX     Histrl          ; save as new highest string low byte
00230D  1  85 AB                STA     Histrh          ; save as new highest string high byte
00230F  1  A5 71                LDA     ut1_pl          ; get start of vars(descriptors) low byte
002311  1  A6 72                LDX     ut1_ph          ; get start of vars(descriptors) high byte
002313  1  85 9C                STA     garb_l          ; save as working pointer low byte
002315  1  86 9D                STX     garb_h          ; save as working pointer high byte
002317  1  88                   DEY                     ; decrement index DIFFERS
002318  1  88                   DEY                     ; decrement index (should point to descriptor start)
002319  1  84 A2                STY     g_indx          ; save index pointer
00231B  1               
00231B  1               ; step pointer to next string
00231B  1               LAB_2206
00231B  1  18                   CLC                     ; clear carry for add
00231C  1               LAB_2207
00231C  1  A5 A0                LDA     g_step          ; get step size
00231E  1               LAB_2208
00231E  1  65 71                ADC     ut1_pl          ; add pointer low byte
002320  1  85 71                STA     ut1_pl          ; save pointer low byte
002322  1  90 02                BCC     LAB_2211        ; branch if no overflow
002324  1               
002324  1  E6 72                INC     ut1_ph          ; else increment high byte
002326  1               LAB_2211
002326  1  A6 72                LDX     ut1_ph          ; get pointer high byte
002328  1  A0 00                LDY     #$00            ; clear Y
00232A  1  60                   RTS
00232B  1               
00232B  1               ; search complete, now either exit or set-up and move string
00232B  1               
00232B  1               LAB_2216
00232B  1  C6 A0                DEC     g_step          ; decrement step size (now $03 for descriptor stack)
00232D  1  A6 9D                LDX     garb_h          ; get string to move high byte
00232F  1  F0 F5                BEQ     LAB_2211        ; exit if nothing to move
002331  1               
002331  1  A4 A2                LDY     g_indx          ; get index byte back (points to descriptor)
002333  1  18                   CLC                     ; clear carry for add
002334  1  8B DA A2 01          LDAINDIRECTY garb_l     ; get string length
002338  1  B5 9C C9 00  
00233C  1  D0 04 A2 00  
00234A  1  65 AA                ADC     Histrl          ; add highest string low byte
00234C  1  85 A6                STA     Obendl          ; save old block end low pointer
00234E  1  A5 AB                LDA     Histrh          ; get highest string high byte
002350  1  69 00                ADC     #$00            ; add any carry
002352  1  85 A7                STA     Obendh          ; save old block end high byte
002354  1  A5 81                LDA     Sstorl          ; get bottom of string space low byte
002356  1  A6 82                LDX     Sstorh          ; get bottom of string space high byte
002358  1  85 A4                STA     Nbendl          ; save new block end low byte
00235A  1  86 A5                STX     Nbendh          ; save new block end high byte
00235C  1  20 23 09             JSR     LAB_11D6        ; open up space in memory, don't set array end
00235F  1  A4 A2                LDY     g_indx          ; get index byte
002361  1  C8                   INY                     ; point to descriptor low byte
002362  1  A5 A4                LDA     Nbendl          ; get string pointer low byte
002364  1  8B DA 48 A2          STAINDIRECTY garb_l     ; save new string pointer low byte
002368  1  01 B5 9C C9  
00236C  1  00 D0 04 A2  
00237A  1  AA                   TAX                     ; copy string pointer low byte
00237B  1  E6 A5                INC     Nbendh          ; correct high byte (move sets high byte -1)
00237D  1  A5 A5                LDA     Nbendh          ; get new string pointer high byte
00237F  1  C8                   INY                     ; point to descriptor high byte
002380  1  8B DA 48 A2          STAINDIRECTY garb_l     ; save new string pointer high byte
002384  1  01 B5 9C C9  
002388  1  00 D0 04 A2  
002396  1  4C C6 21             JMP     LAB_214B        ; re-run routine from last ending
002399  1               ; (but don't collect this string)
002399  1               
002399  1               ; concatenate
002399  1               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
002399  1               
002399  1               LAB_224D
002399  1  A5 AF                LDA     des_ph          ; get descriptor pointer high byte
00239B  1  48                   PHA                     ; put on stack
00239C  1  A5 AE                LDA     des_pl          ; get descriptor pointer low byte
00239E  1  48                   PHA                     ; put on stack
00239F  1  20 7F 18             JSR     LAB_GVAL        ; get value from line
0023A2  1  20 82 17             JSR     LAB_CTST        ; check if source is string, else do type mismatch
0023A5  1  68                   PLA                     ; get descriptor pointer low byte back
0023A6  1  85 B8                STA     ssptr_l         ; set pointer low byte
0023A8  1  68                   PLA                     ; get descriptor pointer high byte back
0023A9  1  85 B9                STA     ssptr_h         ; set pointer high byte
0023AB  1  A0 00                LDY     #$00            ; clear index
0023AD  1  8B DA A2 01          LDAINDIRECTY ssptr_l    ; get length_1 from descriptor
0023B1  1  B5 B8 C9 00  
0023B5  1  D0 04 A2 00  
0023C3  1  18                   CLC                     ; clear carry for add
0023C4  1  8B 48 DA A2          ADCINDIRECTY des_pl     ; add length_2
0023C8  1  01 B5 AE C9  
0023CC  1  00 D0 04 A2  
0023DD  1  90 05                BCC     LAB_226D        ; branch if no overflow
0023DF  1               
0023DF  1  A2 1A                LDX     #$1A            ; else set error code $1A ("String too long" error)
0023E1  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
0023E4  1               
0023E4  1               LAB_226D
0023E4  1  20 01 21             JSR     LAB_209C        ; copy des_pl/h to des_2l/h and make string space A bytes
0023E7  1               ; long
0023E7  1  20 01 24             JSR     LAB_228A        ; copy string from descriptor (sdescr) to (Sutill)
0023EA  1  A5 9E                LDA     des_2l          ; get descriptor pointer low byte
0023EC  1  A4 9F                LDY     des_2h          ; get descriptor pointer high byte
0023EE  1  20 96 24             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
0023F1  1               ; returns with A = length, ut1_pl = pointer low byte,
0023F1  1               ; ut1_ph = pointer high byte
0023F1  1  20 4F 24             JSR     LAB_229C        ; store string A bytes long from (ut1_pl) to (Sutill)
0023F4  1  A5 B8                LDA     ssptr_l         ;.set descriptor pointer low byte
0023F6  1  A4 B9                LDY     ssptr_h         ;.set descriptor pointer high byte
0023F8  1  20 96 24             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
0023FB  1               ; returns with A = length, X=ut1_pl=pointer low byte,
0023FB  1               ; Y=ut1_ph=pointer high byte
0023FB  1  20 68 21             JSR     LAB_RTST        ; check for space on descriptor stack then put string
0023FE  1               ; address and length on descriptor stack and update stack
0023FE  1               ; pointers
0023FE  1  4C A8 17             JMP     LAB_1ADB        ;.continue evaluation
002401  1               
002401  1               ; copy string from descriptor (sdescr) to (Sutill)
002401  1               
002401  1               LAB_228A
002401  1  A0 00                LDY     #$00            ; clear index
002403  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get string length
002407  1  B5 B8 C9 00  
00240B  1  D0 04 A2 00  
002419  1  48                   PHA                     ; save on stack
00241A  1  C8                   INY                     ; increment index
00241B  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get source string pointer low byte
00241F  1  B5 B8 C9 00  
002423  1  D0 04 A2 00  
002431  1  AA                   TAX                     ; copy to X
002432  1  C8                   INY                     ; increment index
002433  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get source string pointer high byte
002437  1  B5 B8 C9 00  
00243B  1  D0 04 A2 00  
002449  1  A8                   TAY                     ; copy to Y
00244A  1  68                   PLA                     ; get length back
00244B  1               
00244B  1               ; store string A bytes long from YX to (Sutill)
00244B  1               
00244B  1               LAB_2298
00244B  1  86 71                STX     ut1_pl          ; save source string pointer low byte
00244D  1  84 72                STY     ut1_ph          ; save source string pointer high byte
00244F  1               
00244F  1               ; store string A bytes long from (ut1_pl) to (Sutill)
00244F  1               
00244F  1               LAB_229C
00244F  1  AA                   TAX                     ; copy length to index (don't count with Y)
002450  1  F0 3C                BEQ     LAB_22B2        ; branch if = $0 (null string) no need to add zero length
002452  1               
002452  1  A0 00                LDY     #$00            ; zero pointer (copy forward)
002454  1               LAB_22A0
002454  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get source byte
002458  1  B5 71 C9 00  
00245C  1  D0 04 A2 00  
00246A  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save destination byte
00246E  1  01 B5 83 C9  
002472  1  00 D0 04 A2  
002480  1               
002480  1  C8                   INY                     ; increment index
002481  1  CA                   DEX                     ; decrement counter
002482  1  D0 D0                BNE     LAB_22A0        ; loop while <> 0
002484  1               
002484  1  98                   TYA                     ; restore length from Y
002485  1               LAB_22A9
002485  1  18                   CLC                     ; clear carry for add
002486  1  65 83                ADC     Sutill          ; add string utility ptr low byte
002488  1  85 83                STA     Sutill          ; save string utility ptr low byte
00248A  1  90 02                BCC     LAB_22B2        ; branch if no carry
00248C  1               
00248C  1  E6 84                INC     Sutilh          ; else increment string utility ptr high byte
00248E  1               LAB_22B2
00248E  1  60                   RTS
00248F  1               
00248F  1               ; evaluate string
00248F  1               
00248F  1               LAB_EVST
00248F  1  20 82 17             JSR     LAB_CTST        ; check if source is string, else do type mismatch
002492  1               
002492  1               ; pop string off descriptor stack, or from top of string space
002492  1               ; returns with A = length, X=pointer low byte, Y=pointer high byte
002492  1               
002492  1               LAB_22B6
002492  1  A5 AE                LDA     des_pl          ; get descriptor pointer low byte
002494  1  A4 AF                LDY     des_ph          ; get descriptor pointer high byte
002496  1               
002496  1               ; pop (YA) descriptor off stack or from top of string space
002496  1               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
002496  1               
002496  1               LAB_22BA
002496  1  85 71                STA     ut1_pl          ; save descriptor pointer low byte
002498  1  84 72                STY     ut1_ph          ; save descriptor pointer high byte
00249A  1  20 03 25             JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
00249D  1  08                   PHP                     ; save status flags
00249E  1  A0 00                LDY     #$00            ; clear index
0024A0  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get length from string descriptor
0024A4  1  B5 71 C9 00  
0024A8  1  D0 04 A2 00  
0024B6  1  48                   PHA                     ; put on stack
0024B7  1  C8                   INY                     ; increment index
0024B8  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer low byte from descriptor
0024BC  1  B5 71 C9 00  
0024C0  1  D0 04 A2 00  
0024CE  1  AA                   TAX                     ; copy to X
0024CF  1  C8                   INY                     ; increment index
0024D0  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer high byte from descriptor
0024D4  1  B5 71 C9 00  
0024D8  1  D0 04 A2 00  
0024E6  1  A8                   TAY                     ; copy to Y
0024E7  1  68                   PLA                     ; get string length back
0024E8  1  28                   PLP                     ; restore status
0024E9  1  D0 13                BNE     LAB_22E6        ; branch if pointer <> last_sl,last_sh
0024EB  1               
0024EB  1  C4 82                CPY     Sstorh          ; compare bottom of string space high byte
0024ED  1  D0 0F                BNE     LAB_22E6        ; branch if <>
0024EF  1               
0024EF  1  E4 81                CPX     Sstorl          ; else compare bottom of string space low byte
0024F1  1  D0 0B                BNE     LAB_22E6        ; branch if <>
0024F3  1               
0024F3  1  48                   PHA                     ; save string length
0024F4  1  18                   CLC                     ; clear carry for add
0024F5  1  65 81                ADC     Sstorl          ; add bottom of string space low byte
0024F7  1  85 81                STA     Sstorl          ; save bottom of string space low byte
0024F9  1  90 02                BCC     LAB_22E5        ; skip increment if no overflow
0024FB  1               
0024FB  1  E6 82                INC     Sstorh          ; increment bottom of string space high byte
0024FD  1               LAB_22E5
0024FD  1  68                   PLA                     ; restore string length
0024FE  1               LAB_22E6
0024FE  1  86 71                STX     ut1_pl          ; save string pointer low byte
002500  1  84 72                STY     ut1_ph          ; save string pointer high byte
002502  1  60                   RTS
002503  1               
002503  1               ; clean descriptor stack, YA = pointer
002503  1               ; checks if AY is on the descriptor stack, if so does a stack discard
002503  1               
002503  1               LAB_22EB
002503  1  C4 67                CPY     last_sh         ; compare pointer high byte
002505  1  D0 0C                BNE     LAB_22FB        ; exit if <>
002507  1               
002507  1  C5 66                CMP     last_sl         ; compare pointer low byte
002509  1  D0 08                BNE     LAB_22FB        ; exit if <>
00250B  1               
00250B  1  85 65                STA     next_s          ; save descriptor stack pointer
00250D  1  E9 03                SBC     #$03            ; -3
00250F  1  85 66                STA     last_sl         ; save low byte -3
002511  1  A0 00                LDY     #$00            ; clear high byte
002513  1               LAB_22FB
002513  1  60                   RTS
002514  1               
002514  1               ; perform CHR$()
002514  1               
002514  1               LAB_CHRS
002514  1  20 1E 27             JSR     LAB_EVBY        ; evaluate byte expression, result in X
002517  1  8A                   TXA                     ; copy to A
002518  1  48                   PHA                     ; save character
002519  1  A9 01                LDA     #$01            ; string is single byte
00251B  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
00251E  1               ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00251E  1  68                   PLA                     ; get character back
00251F  1  A0 00                LDY     #$00            ; clear index
002521  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save byte in string (byte IS string!)
002525  1  01 B5 AD C9  
002529  1  00 D0 04 A2  
002537  1  4C 68 21             JMP     LAB_RTST        ; check for space on descriptor stack then put string
00253A  1               ; address and length on descriptor stack and update stack
00253A  1               ; pointers
00253A  1               
00253A  1               ; perform LEFT$()
00253A  1               
00253A  1               LAB_LEFT
00253A  1  48                   PHA                     ; push byte parameter
00253B  1  20 F2 25             JSR     LAB_236F        ; pull string data and byte parameter from stack
00253E  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
00253E  1  8B 48 DA A2          CMPINDIRECTY des_2l     ; compare byte parameter with string length
002542  1  01 B5 9E C9  
002546  1  00 D0 04 A2  
002556  1  98                   TYA                     ; clear A
002557  1  F0 1F                BEQ     LAB_2316        ; go do string copy (branch always)
002559  1               
002559  1               ; perform RIGHT$()
002559  1               
002559  1               LAB_RIGHT
002559  1  48                   PHA                     ; push byte parameter
00255A  1  20 F2 25             JSR     LAB_236F        ; pull string data and byte parameter from stack
00255D  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
00255D  1                       .IFDEF  DUODYNE
00255D  1  8B 48 DA A2          FETCHINDIRECTY des_2l   ; subtract string length
002561  1  01 B5 9E C9  
002565  1  00 D0 04 A2  
002573  1  18                   CLC                     ; clear carry for add-1
002574  1  E5 04                SBC     <TMPFLG         ; REDO SBC WITH CARRY CLEARED (ARTIFACT FROM 816 CONVERSION)
002576  1                       .ELSE
002576  1                       CLC                     ; clear carry for add-1
002576  1                       SBC     (des_2l),Y      ; subtract string length
002576  1                       .ENDIF
002576  1  49 FF                EOR     #$FF            ; invert it (A=LEN(expression$)-l)
002578  1               
002578  1               LAB_2316
002578  1  90 18                BCC     LAB_231C        ; branch if string length > byte parameter
00257A  1               
00257A  1  8B DA A2 01          LDAINDIRECTY des_2l     ; else make parameter = length
00257E  1  B5 9E C9 00  
002582  1  D0 04 A2 00  
002590  1  AA                   TAX                     ; copy to byte parameter copy
002591  1  98                   TYA                     ; clear string start offset
002592  1               LAB_231C
002592  1  48                   PHA                     ; save string start offset
002593  1               LAB_231D
002593  1  8A                   TXA                     ; copy byte parameter (or string length if <)
002594  1               LAB_231E
002594  1  48                   PHA                     ; save string length
002595  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
002598  1               ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
002598  1  A5 9E                LDA     des_2l          ; get descriptor pointer low byte
00259A  1  A4 9F                LDY     des_2h          ; get descriptor pointer high byte
00259C  1  20 96 24             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
00259F  1               ; returns with A = length, X=ut1_pl=pointer low byte,
00259F  1               ; Y=ut1_ph=pointer high byte
00259F  1  68                   PLA                     ; get string length back
0025A0  1  A8                   TAY                     ; copy length to Y
0025A1  1  68                   PLA                     ; get string start offset back
0025A2  1  18                   CLC                     ; clear carry for add
0025A3  1  65 71                ADC     ut1_pl          ; add start offset to string start pointer low byte
0025A5  1  85 71                STA     ut1_pl          ; save string start pointer low byte
0025A7  1  90 02                BCC     LAB_2335        ; branch if no overflow
0025A9  1               
0025A9  1  E6 72                INC     ut1_ph          ; else increment string start pointer high byte
0025AB  1               LAB_2335
0025AB  1  98                   TYA                     ; copy length to A
0025AC  1  20 4F 24             JSR     LAB_229C        ; store string A bytes long from (ut1_pl) to (Sutill)
0025AF  1  4C 68 21             JMP     LAB_RTST        ; check for space on descriptor stack then put string
0025B2  1               ; address and length on descriptor stack and update stack
0025B2  1               ; pointers
0025B2  1               
0025B2  1               ; perform MID$()
0025B2  1               
0025B2  1               LAB_MIDS
0025B2  1  48                   PHA                     ; push byte parameter
0025B3  1  A9 FF                LDA     #$FF            ; set default length = 255
0025B5  1  85 AF                STA     mids_l          ; save default length
0025B7  1                       .IFDEF  DUODYNE
0025B7  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0025BB  1                       .ELSE
0025BB  1                       JSR     LAB_GBYT        ; scan memory
0025BB  1                       .ENDIF
0025BB  1               
0025BB  1  C9 29                CMP     #')'            ; compare with ")"
0025BD  1  F0 06                BEQ     LAB_2358        ; branch if = ")" (skip second byte get)
0025BF  1               
0025BF  1  20 B3 18             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
0025C2  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter (use copy in mids_l)
0025C5  1               LAB_2358
0025C5  1  20 F2 25             JSR     LAB_236F        ; pull string data and byte parameter from stack
0025C8  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
0025C8  1  CA                   DEX                     ; decrement start index
0025C9  1  8A                   TXA                     ; copy to A
0025CA  1  48                   PHA                     ; save string start offset
0025CB  1                       .IFDEF  DUODYNE
0025CB  1  8B 48 DA A2          FETCHINDIRECTY des_2l
0025CF  1  01 B5 9E C9  
0025D3  1  00 D0 04 A2  
0025E1  1  18                   CLC                     ; clear carry for sub-1
0025E2  1  A2 00                LDX     #$00            ; clear output string length
0025E4  1  E5 04                SBC     <TMPFLG         ; subtract string length
0025E6  1                       .ELSE
0025E6  1                       CLC                     ; clear carry for sub-1
0025E6  1                       LDX     #$00            ; clear output string length
0025E6  1                       SBC     (des_2l),Y      ; subtract string length
0025E6  1                       .ENDIF
0025E6  1  B0 AB                BCS     LAB_231D        ; if start>string length go do null string
0025E8  1               
0025E8  1  49 FF                EOR     #$FF            ; complement -length
0025EA  1  C5 AF                CMP     mids_l          ; compare byte parameter
0025EC  1  90 A6                BCC     LAB_231E        ; if length>remaining string go do RIGHT$
0025EE  1               
0025EE  1  A5 AF                LDA     mids_l          ; get length byte
0025F0  1  B0 A2                BCS     LAB_231E        ; go do string copy (branch always)
0025F2  1               
0025F2  1               ; pull string data and byte parameter from stack
0025F2  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
0025F2  1               
0025F2  1               LAB_236F
0025F2  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
0025F5  1  68                   PLA                     ; pull return address low byte (return address)
0025F6  1  85 A2                STA     Fnxjpl          ; save functions jump vector low byte
0025F8  1  68                   PLA                     ; pull return address high byte (return address)
0025F9  1  85 A3                STA     Fnxjph          ; save functions jump vector high byte
0025FB  1  68                   PLA                     ; pull byte parameter
0025FC  1  AA                   TAX                     ; copy byte parameter to X
0025FD  1  68                   PLA                     ; pull string pointer low byte
0025FE  1  85 9E                STA     des_2l          ; save it
002600  1  68                   PLA                     ; pull string pointer high byte
002601  1  85 9F                STA     des_2h          ; save it
002603  1  A0 00                LDY     #$00            ; clear index
002605  1  8A                   TXA                     ; copy byte parameter
002606  1  D0 03 4C 14          LBEQ    LAB_23A8        ; if null do function call error then warm start
00260A  1  27           
00260B  1               
00260B  1  E6 A2                INC     Fnxjpl          ; increment function jump vector low byte
00260D  1               ; (JSR pushes return addr-1. this is all very nice
00260D  1               ; but will go tits up if either call is on a page
00260D  1               ; boundary!)
00260D  1  6C A2 00             JMP     (Fnxjpl)        ; in effect, RTS
002610  1               
002610  1               
002610  1               ; perform LCASE$()
002610  1               
002610  1               LAB_LCASE
002610  1  20 8F 24             JSR     LAB_EVST        ; evaluate string
002613  1  85 AC                STA     str_ln          ; set string length
002615  1  A8                   TAY                     ; copy length to Y
002616  1  D0 03 4C A3          LBEQ    NoString        ; branch if null string
00261A  1  26           
00261B  1               
00261B  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long A=length,
00261E  1               ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00261E  1  86 AD                STX     str_pl          ; save string pointer low byte
002620  1  84 AE                STY     str_ph          ; save string pointer high byte
002622  1  A8                   TAY                     ; get string length back
002623  1               
002623  1               LC_loop
002623  1  88                   DEY                     ; decrement index
002624  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte from string
002628  1  B5 71 C9 00  
00262C  1  D0 04 A2 00  
00263A  1  20 39 1B             JSR     LAB_1D82        ; is character "A" to "Z"
00263D  1  90 02                BCC     NoUcase         ; branch if not upper case alpha
00263F  1               
00263F  1  09 20                ORA     #$20            ; convert upper to lower case
002641  1               NoUcase
002641  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save byte back to string
002645  1  01 B5 83 C9  
002649  1  00 D0 04 A2  
002657  1  98                   TYA                     ; test index
002658  1  D0 C9                BNE     LC_loop         ; loop if not all done
00265A  1               
00265A  1  F0 47                BEQ     NoString        ; tidy up and exit, branch always
00265C  1               
00265C  1               ; perform UCASE$()
00265C  1               
00265C  1               LAB_UCASE
00265C  1  20 8F 24             JSR     LAB_EVST        ; evaluate string
00265F  1  85 AC                STA     str_ln          ; set string length
002661  1  A8                   TAY                     ; copy length to Y
002662  1  F0 3F                BEQ     NoString        ; branch if null string
002664  1               
002664  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long A=length,
002667  1               ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
002667  1  86 AD                STX     str_pl          ; save string pointer low byte
002669  1  84 AE                STY     str_ph          ; save string pointer high byte
00266B  1  A8                   TAY                     ; get string length back
00266C  1               
00266C  1               UC_loop
00266C  1  88                   DEY                     ; decrement index
00266D  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte from string
002671  1  B5 71 C9 00  
002675  1  D0 04 A2 00  
002683  1  20 35 1B             JSR     LAB_CASC        ; is character "a" to "z" (or "A" to "Z")
002686  1  90 02                BCC     NoLcase         ; branch if not alpha
002688  1               
002688  1  29 DF                AND     #$DF            ; convert lower to upper case
00268A  1               NoLcase
00268A  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save byte back to string
00268E  1  01 B5 83 C9  
002692  1  00 D0 04 A2  
0026A0  1  98                   TYA                     ; test index
0026A1  1  D0 C9                BNE     UC_loop         ; loop if not all done
0026A3  1               
0026A3  1               NoString
0026A3  1  4C 68 21             JMP     LAB_RTST        ; check for space on descriptor stack then put string
0026A6  1               ; address and length on descriptor stack and update stack
0026A6  1               ; pointers
0026A6  1               
0026A6  1               ; perform SADD()
0026A6  1               
0026A6  1               LAB_SADD
0026A6  1                       .IFDEF  DUODYNE
0026A6  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0026AA  1                       .ELSE
0026AA  1                       JSR     LAB_IGBY        ; increment and scan memory
0026AA  1                       .ENDIF
0026AA  1               
0026AA  1  20 8E 1A             JSR     LAB_GVAR        ; get var address
0026AD  1               
0026AD  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
0026B0  1  20 82 17             JSR     LAB_CTST        ; check if source is string, else do type mismatch
0026B3  1               
0026B3  1  A0 02                LDY     #$02            ; index to string pointer high byte
0026B5  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get string pointer high byte
0026B9  1  B5 95 C9 00  
0026BD  1  D0 04 A2 00  
0026CB  1  AA                   TAX                     ; copy string pointer high byte to X
0026CC  1  88                   DEY                     ; index to string pointer low byte
0026CD  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get string pointer low byte
0026D1  1  B5 95 C9 00  
0026D5  1  D0 04 A2 00  
0026E3  1  A8                   TAY                     ; copy string pointer low byte to Y
0026E4  1  8A                   TXA                     ; copy string pointer high byte to A
0026E5  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
0026E8  1               
0026E8  1               ; perform LEN()
0026E8  1               
0026E8  1               LAB_LENS
0026E8  1  20 EE 26             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
0026EB  1  4C 7D 1F             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
0026EE  1               
0026EE  1               ; evaluate string, get length in Y
0026EE  1               
0026EE  1               LAB_ESGL
0026EE  1  20 8F 24             JSR     LAB_EVST        ; evaluate string
0026F1  1  A8                   TAY                     ; copy length to Y
0026F2  1  60                   RTS
0026F3  1               
0026F3  1               ; perform ASC()
0026F3  1               
0026F3  1               LAB_ASC
0026F3  1  20 EE 26             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
0026F6  1  F0 1C                BEQ     LAB_23A8        ; if null do function call error then warm start
0026F8  1               
0026F8  1  A0 00                LDY     #$00            ; set index to first character
0026FA  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte
0026FE  1  B5 71 C9 00  
002702  1  D0 04 A2 00  
002710  1  A8                   TAY                     ; copy to Y
002711  1  4C 7D 1F             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
002714  1               
002714  1               ; do function call error then warm start
002714  1               
002714  1               LAB_23A8
002714  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start
002717  1               
002717  1               ; scan and get byte parameter
002717  1               
002717  1               LAB_SGBY
002717  1                       .IFDEF  DUODYNE
002717  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00271B  1                       .ELSE
00271B  1                       JSR     LAB_IGBY        ; increment and scan memory
00271B  1                       .ENDIF
00271B  1               
00271B  1               
00271B  1               ; get byte parameter
00271B  1               
00271B  1               LAB_GTBY
00271B  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00271E  1               ; else do type mismatch
00271E  1               
00271E  1               ; evaluate byte expression, result in X
00271E  1               
00271E  1               LAB_EVBY
00271E  1  20 32 1C             JSR     LAB_EVPI        ; evaluate integer expression (no check)
002721  1               
002721  1  A4 AE                LDY     FAC1_2          ; get FAC1 mantissa2
002723  1  D0 EF                BNE     LAB_23A8        ; if top byte <> 0 do function call error then warm start
002725  1               
002725  1  A6 AF                LDX     FAC1_3          ; get FAC1 mantissa3
002727  1                       .IFDEF  DUODYNE
002727  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00272B  1                       .ELSE
00272B  1                       JSR     LAB_GBYT        ; scan memory
00272B  1                       .ENDIF
00272B  1  60                   RTS
00272C  1               
00272C  1               ; perform VAL()
00272C  1               
00272C  1               LAB_VAL
00272C  1  20 EE 26             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
00272F  1  D0 03                BNE     LAB_23C5        ; branch if not null string
002731  1               
002731  1               ; string was null so set result = $00
002731  1  4C 92 29             JMP     LAB_24F1        ; clear FAC1 exponent and sign and return
002734  1               
002734  1               LAB_23C5
002734  1  A6 C3                LDX     Bpntrl          ; get BASIC execute pointer low byte
002736  1  A4 C4                LDY     Bpntrh          ; get BASIC execute pointer high byte
002738  1  86 BA                STX     Btmpl           ; save BASIC execute pointer low byte
00273A  1  84 BB                STY     Btmph           ; save BASIC execute pointer high byte
00273C  1  A6 71                LDX     ut1_pl          ; get string pointer low byte
00273E  1  86 C3                STX     Bpntrl          ; save as BASIC execute pointer low byte
002740  1  18                   CLC                     ; clear carry
002741  1  65 71                ADC     ut1_pl          ; add string length
002743  1  85 73                STA     ut2_pl          ; save string end low byte
002745  1  A5 72                LDA     ut1_ph          ; get string pointer high byte
002747  1  85 C4                STA     Bpntrh          ; save as BASIC execute pointer high byte
002749  1  69 00                ADC     #$00            ; add carry to high byte
00274B  1  85 74                STA     ut2_ph          ; save string end high byte
00274D  1  A0 00                LDY     #$00            ; set index to $00
00274F  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get string end +1 byte
002753  1  B5 73 C9 00  
002757  1  D0 04 A2 00  
002765  1  48                   PHA                     ; push it
002766  1  98                   TYA                     ; clear A
002767  1  8B DA 48 A2          STAINDIRECTY ut2_pl     ; terminate string with $00
00276B  1  01 B5 73 C9  
00276F  1  00 D0 04 A2  
00277D  1                       .IFDEF  DUODYNE
00277D  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002781  1                       .ELSE
002781  1                       JSR     LAB_GBYT        ; scan memory
002781  1                       .ENDIF
002781  1               
002781  1  20 3C 2E             JSR     LAB_2887        ; get FAC1 from string
002784  1  68                   PLA                     ; restore string end +1 byte
002785  1  A0 00                LDY     #$00            ; set index to zero
002787  1  8B DA 48 A2          STAINDIRECTY ut2_pl     ; put string end byte back
00278B  1  01 B5 73 C9  
00278F  1  00 D0 04 A2  
00279D  1               
00279D  1               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00279D  1               
00279D  1               LAB_23F3
00279D  1  A6 BA                LDX     Btmpl           ; get BASIC execute pointer low byte back
00279F  1  A4 BB                LDY     Btmph           ; get BASIC execute pointer high byte back
0027A1  1  86 C3                STX     Bpntrl          ; save BASIC execute pointer low byte
0027A3  1  84 C4                STY     Bpntrh          ; save BASIC execute pointer high byte
0027A5  1  60                   RTS
0027A6  1               
0027A6  1               ; get two parameters for POKE or WAIT
0027A6  1               
0027A6  1               LAB_GADB
0027A6  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
0027A9  1               ; else do type mismatch
0027A9  1  20 BF 27             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0027AC  1               
0027AC  1               ; scan for "," and get byte, else do Syntax error then warm start
0027AC  1               
0027AC  1               LAB_SCGB
0027AC  1  20 B3 18             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
0027AF  1  A5 12                LDA     Itemph          ; save temporary integer high byte
0027B1  1  48                   PHA                     ; on stack
0027B2  1  A5 11                LDA     Itempl          ; save temporary integer low byte
0027B4  1  48                   PHA                     ; on stack
0027B5  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter
0027B8  1  68                   PLA                     ; pull low byte
0027B9  1  85 11                STA     Itempl          ; restore temporary integer low byte
0027BB  1  68                   PLA                     ; pull high byte
0027BC  1  85 12                STA     Itemph          ; restore temporary integer high byte
0027BE  1  60                   RTS
0027BF  1               
0027BF  1               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
0027BF  1               ; -ve and converts it into a right truncated integer in Itempl and Itemph
0027BF  1               
0027BF  1               ; save unsigned 16 bit integer part of FAC1 in temporary integer
0027BF  1               
0027BF  1               LAB_F2FX
0027BF  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0027C1  1  C9 98                CMP     #$98            ; compare with exponent = 2^24
0027C3  1  B0 02 80 03          LBCS    LAB_23A8        ; if >= do function call error then warm start
0027C7  1  4C 14 27     
0027CA  1               
0027CA  1               LAB_F2FU
0027CA  1  20 E6 2D             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
0027CD  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0027CF  1  A4 AF                LDY     FAC1_3          ; get FAC1 mantissa3
0027D1  1  84 11                STY     Itempl          ; save temporary integer low byte
0027D3  1  85 12                STA     Itemph          ; save temporary integer high byte
0027D5  1  60                   RTS
0027D6  1               
0027D6  1               ; perform PEEK()
0027D6  1               
0027D6  1               LAB_PEEK
0027D6  1  20 BF 27             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0027D9  1  A2 00                LDX     #$00            ; clear index
0027DB  1  A1 11                LDA     (Itempl,X)      ; get byte via temporary integer (addr)
0027DD  1  A8                   TAY                     ; copy byte to Y
0027DE  1  4C 7D 1F             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
0027E1  1               
0027E1  1               ; perform POKE
0027E1  1               
0027E1  1               LAB_POKE
0027E1  1  20 A6 27             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
0027E4  1  8A                   TXA                     ; copy byte argument to A
0027E5  1  A2 00                LDX     #$00            ; clear index
0027E7  1  81 11                STA     (Itempl,X)      ; save byte via temporary integer (addr)
0027E9  1  60                   RTS
0027EA  1               
0027EA  1               ; perform DEEK()
0027EA  1               
0027EA  1               LAB_DEEK
0027EA  1  20 BF 27             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0027ED  1  A2 00                LDX     #$00            ; clear index
0027EF  1  A1 11                LDA     (Itempl,X)      ; PEEK low byte
0027F1  1  A8                   TAY                     ; copy to Y
0027F2  1  E6 11                INC     Itempl          ; increment pointer low byte
0027F4  1  D0 02                BNE     Deekh           ; skip high increment if no rollover
0027F6  1               
0027F6  1  E6 12                INC     Itemph          ; increment pointer high byte
0027F8  1               Deekh
0027F8  1  A1 11                LDA     (Itempl,X)      ; PEEK high byte
0027FA  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
0027FD  1               
0027FD  1               ; perform DOKE
0027FD  1               
0027FD  1               LAB_DOKE
0027FD  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
002800  1               ; else do type mismatch
002800  1  20 BF 27             JSR     LAB_F2FX        ; convert floating-to-fixed
002803  1               
002803  1  84 97                STY     Frnxtl          ; save pointer low byte (float to fixed returns word in AY)
002805  1  85 98                STA     Frnxth          ; save pointer high byte
002807  1               
002807  1  20 B3 18             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
00280A  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00280D  1               ; else do type mismatch
00280D  1  20 BF 27             JSR     LAB_F2FX        ; convert floating-to-fixed
002810  1               
002810  1  98                   TYA                     ; copy value low byte (float to fixed returns word in AY)
002811  1  A2 00                LDX     #$00            ; clear index
002813  1  81 97                STA     (Frnxtl,X)      ; POKE low byte
002815  1  E6 97                INC     Frnxtl          ; increment pointer low byte
002817  1  D0 02                BNE     Dokeh           ; skip high increment if no rollover
002819  1               
002819  1  E6 98                INC     Frnxth          ; increment pointer high byte
00281B  1               Dokeh
00281B  1  A5 12                LDA     Itemph          ; get value high byte
00281D  1  81 97                STA     (Frnxtl,X)      ; POKE high byte
00281F  1                       .IFDEF  DUODYNE
00281F  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002823  1                       .ELSE
002823  1                       JSR     LAB_GBYT        ; scan memory
002823  1                       .ENDIF
002823  1  60                   RTS
002824  1               
002824  1               ; perform SWAP
002824  1               
002824  1               LAB_SWAP
002824  1  20 8E 1A             JSR     LAB_GVAR        ; get var1 address
002827  1  85 97                STA     Lvarpl          ; save var1 address low byte
002829  1  84 98                STY     Lvarph          ; save var1 address high byte
00282B  1  A5 5F                LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00282D  1  48                   PHA                     ; save data type flag
00282E  1               
00282E  1  20 B3 18             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
002831  1  20 8E 1A             JSR     LAB_GVAR        ; get var2 address (pointer in Cvaral/h)
002834  1  68                   PLA                     ; pull var1 data type flag
002835  1  45 5F                EOR     Dtypef          ; compare with var2 data type
002837  1  10 60                BPL     SwapErr         ; exit if not both the same type
002839  1               
002839  1  A0 03                LDY     #$03            ; four bytes to swap (either value or descriptor+1)
00283B  1               SwapLp
00283B  1  8B DA A2 01          LDAINDIRECTY Lvarpl     ; get byte from var1
00283F  1  B5 97 C9 00  
002843  1  D0 04 A2 00  
002851  1  AA                   TAX                     ; save var1 byte
002852  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get byte from var2
002856  1  B5 95 C9 00  
00285A  1  D0 04 A2 00  
002868  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; save byte to var1
00286C  1  01 B5 97 C9  
002870  1  00 D0 04 A2  
00287E  1  8A                   TXA                     ; restore var1 byte
00287F  1  8B DA 48 A2          STAINDIRECTY Cvaral     ; save byte to var2
002883  1  01 B5 95 C9  
002887  1  00 D0 04 A2  
002895  1  88                   DEY                     ; decrement index
002896  1  10 A3                BPL     SwapLp          ; loop until done
002898  1               
002898  1  60                   RTS
002899  1               
002899  1               SwapErr
002899  1  4C 8C 17             JMP     LAB_1ABC        ; do "Type mismatch" error then warm start
00289C  1               
00289C  1               ; perform CALL
00289C  1               
00289C  1               LAB_CALL
00289C  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00289F  1               ; else do type mismatch
00289F  1  20 BF 27             JSR     LAB_F2FX        ; convert floating-to-fixed
0028A2  1  A9 28                LDA     #>CallExit      ; set return address high byte
0028A4  1  48                   PHA                     ; put on stack
0028A5  1  A9 AA                LDA     #<CallExit-1    ; set return address low byte
0028A7  1  48                   PHA                     ; put on stack
0028A8  1  6C 11 00             JMP     (Itempl)        ; do indirect jump to user routine
0028AB  1               
0028AB  1               
0028AB  1               ; if the called routine exits correctly then it will return to here. this will then get
0028AB  1               ; the next byte for the interpreter and return
0028AB  1               
0028AB  1               CallExit
0028AB  1                       .IFDEF  DUODYNE
0028AB  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0028AF  1                       .ELSE
0028AF  1                       JSR     LAB_GBYT        ; scan memory
0028AF  1                       .ENDIF
0028AF  1  60                   RTS
0028B0  1               
0028B0  1               ; perform WAIT
0028B0  1               
0028B0  1               LAB_WAIT
0028B0  1  20 A6 27             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
0028B3  1  86 97                STX     Frnxtl          ; save byte
0028B5  1  A2 00                LDX     #$00            ; clear mask
0028B7  1                       .IFDEF  DUODYNE
0028B7  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0028BB  1                       .ELSE
0028BB  1                       JSR     LAB_GBYT        ; scan memory
0028BB  1                       .ENDIF
0028BB  1               
0028BB  1  F0 03                BEQ     LAB_2441        ; skip if no third argument
0028BD  1               
0028BD  1  20 AC 27             JSR     LAB_SCGB        ; scan for "," and get byte, else SN error then warm start
0028C0  1               LAB_2441
0028C0  1  86 98                STX     Frnxth          ; save EOR argument
0028C2  1               LAB_2445
0028C2  1  8B DA A2 01          LDAINDIRECTY Itempl     ; get byte via temporary integer (addr)
0028C6  1  B5 11 C9 00  
0028CA  1  D0 04 A2 00  
0028D8  1  45 98                EOR     Frnxth          ; EOR with second argument (mask)
0028DA  1  25 97                AND     Frnxtl          ; AND with first argument (byte)
0028DC  1  F0 E4                BEQ     LAB_2445        ; loop if result is zero
0028DE  1               
0028DE  1               LAB_244D
0028DE  1  60                   RTS
0028DF  1               
0028DF  1               ; perform subtraction, FAC1 from (AY)
0028DF  1               
0028DF  1               LAB_2455
0028DF  1  20 CD 2A             JSR     LAB_264D        ; unpack memory (AY) into FAC2
0028E2  1               
0028E2  1               ; perform subtraction, FAC1 from FAC2
0028E2  1               
0028E2  1               LAB_SUBTRACT
0028E2  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
0028E4  1  49 FF                EOR     #$FF            ; complement it
0028E6  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
0028E8  1  45 B7                EOR     FAC2_s          ; EOR with FAC2 sign (b7)
0028EA  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
0028EC  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0028EE  1  4C FD 28             JMP     LAB_ADD         ; go add FAC2 to FAC1
0028F1  1               
0028F1  1               ; perform addition
0028F1  1               
0028F1  1               LAB_2467
0028F1  1  20 1C 2A             JSR     LAB_257B        ; shift FACX A times right (>8 shifts)
0028F4  1  90 4D                BCC     LAB_24A8        ;.go subtract mantissas
0028F6  1               
0028F6  1               ; add 0.5 to FAC1
0028F6  1               
0028F6  1               LAB_244E
0028F6  1  A9 0F                LDA     #<LAB_2A96      ; set 0.5 pointer low byte
0028F8  1  A0 37                LDY     #>LAB_2A96      ; set 0.5 pointer high byte
0028FA  1               
0028FA  1               ; add (AY) to FAC1
0028FA  1               
0028FA  1               LAB_246C
0028FA  1  20 CD 2A             JSR     LAB_264D        ; unpack memory (AY) into FAC2
0028FD  1               
0028FD  1               ; add FAC2 to FAC1
0028FD  1               
0028FD  1               LAB_ADD
0028FD  1  D0 10                BNE     LAB_2474        ; branch if FAC1 was not zero
0028FF  1               
0028FF  1               ; copy FAC2 to FAC1
0028FF  1               
0028FF  1               LAB_279B
0028FF  1  A5 B7                LDA     FAC2_s          ; get FAC2 sign (b7)
002901  1               
002901  1               ; save FAC1 sign and copy ABS(FAC2) to FAC1
002901  1               
002901  1               LAB_279D
002901  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
002903  1  A2 04                LDX     #$04            ; 4 bytes to copy
002905  1               LAB_27A1
002905  1  B5 B2                LDA     FAC1_o,X        ; get byte from FAC2,X
002907  1  95 AB                STA     FAC1_e-1,X      ; save byte at FAC1,X
002909  1  CA                   DEX                     ; decrement count
00290A  1  D0 F9                BNE     LAB_27A1        ; loop if not all done
00290C  1               
00290C  1  86 B9                STX     FAC1_r          ; clear FAC1 rounding byte
00290E  1  60                   RTS
00290F  1               
00290F  1               ; FAC1 is non zero
00290F  1               LAB_2474
00290F  1  A6 B9                LDX     FAC1_r          ; get FAC1 rounding byte
002911  1  86 A3                STX     FAC2_r          ; save as FAC2 rounding byte
002913  1  A2 B3                LDX     #FAC2_e         ; set index to FAC2 exponent addr
002915  1  A5 B3                LDA     FAC2_e          ; get FAC2 exponent
002917  1               LAB_247C
002917  1  A8                   TAY                     ; copy exponent
002918  1  F0 C4                BEQ     LAB_244D        ; exit if zero
00291A  1               
00291A  1  38                   SEC                     ; set carry for subtract
00291B  1  E5 AC                SBC     FAC1_e          ; subtract FAC1 exponent
00291D  1  F0 24                BEQ     LAB_24A8        ; branch if = (go add mantissa)
00291F  1               
00291F  1  90 12                BCC     LAB_2498        ; branch if <
002921  1               
002921  1               ; FAC2>FAC1
002921  1  84 AC                STY     FAC1_e          ; save FAC1 exponent
002923  1  A4 B7                LDY     FAC2_s          ; get FAC2 sign (b7)
002925  1  84 B0                STY     FAC1_s          ; save FAC1 sign (b7)
002927  1  49 FF                EOR     #$FF            ; complement A
002929  1  69 00                ADC     #$00            ; +1 (twos complement, carry is set)
00292B  1  A0 00                LDY     #$00            ; clear Y
00292D  1  84 A3                STY     FAC2_r          ; clear FAC2 rounding byte
00292F  1  A2 AC                LDX     #FAC1_e         ; set index to FAC1 exponent addr
002931  1  D0 04                BNE     LAB_249C        ; branch always
002933  1               
002933  1               LAB_2498
002933  1  A0 00                LDY     #$00            ; clear Y
002935  1  84 B9                STY     FAC1_r          ; clear FAC1 rounding byte
002937  1               LAB_249C
002937  1  C9 F9                CMP     #$F9            ; compare exponent diff with $F9
002939  1  30 B6                BMI     LAB_2467        ; branch if range $79-$F8
00293B  1               
00293B  1  A8                   TAY                     ; copy exponent difference to Y
00293C  1  A5 B9                LDA     FAC1_r          ; get FAC1 rounding byte
00293E  1  56 01                LSR     PLUS_1,X        ; shift FAC? mantissa1
002940  1  20 33 2A             JSR     LAB_2592        ; shift FACX Y times right
002943  1               
002943  1               ; exponents are equal now do mantissa subtract
002943  1               LAB_24A8
002943  1  24 B8                BIT     FAC_sc          ; test sign compare (FAC1 EOR FAC2)
002945  1  10 52                BPL     LAB_24F8        ; if = add FAC2 mantissa to FAC1 mantissa and return
002947  1               
002947  1  A0 AC                LDY     #FAC1_e         ; set index to FAC1 exponent addr
002949  1  E0 B3                CPX     #FAC2_e         ; compare X to FAC2 exponent addr
00294B  1  F0 02                BEQ     LAB_24B4        ; branch if =
00294D  1               
00294D  1  A0 B3                LDY     #FAC2_e         ; else set index to FAC2 exponent addr
00294F  1               
00294F  1               ; subtract smaller from bigger (take sign of bigger)
00294F  1               LAB_24B4
00294F  1  38                   SEC                     ; set carry for subtract
002950  1  49 FF                EOR     #$FF            ; ones complement A
002952  1  65 A3                ADC     FAC2_r          ; add FAC2 rounding byte
002954  1  85 B9                STA     FAC1_r          ; save FAC1 rounding byte
002956  1                       .IFDEF  DUODYNE
002956  1  DA                   PHX
002957  1  BB                   TYX
002958  1  B5 03                LDA     PLUS_3,X        ; get FACY mantissa3
00295A  1  FA                   PLX
00295B  1                       .ELSE
00295B  1                       LDA     PLUS_3,Y        ; get FACY mantissa3
00295B  1                       .ENDIF
00295B  1  F5 03                SBC     PLUS_3,X        ; subtract FACX mantissa3
00295D  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
00295F  1                       .IFDEF  DUODYNE
00295F  1  DA                   PHX
002960  1  BB                   TYX
002961  1  B5 02                LDA     PLUS_2,X        ; get FACY mantissa2
002963  1  FA                   PLX
002964  1                       .ELSE
002964  1                       LDA     PLUS_2,Y        ; get FACY mantissa2
002964  1                       .ENDIF
002964  1  F5 02                SBC     PLUS_2,X        ; subtract FACX mantissa2
002966  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
002968  1               
002968  1                       .IFDEF  DUODYNE
002968  1  DA                   PHX
002969  1  BB                   TYX
00296A  1  B5 01                LDA     PLUS_1,X        ; get FACY mantissa1
00296C  1  FA                   PLX
00296D  1                       .ELSE
00296D  1                       LDA     PLUS_1,Y        ; get FACY mantissa1
00296D  1                       .ENDIF
00296D  1  F5 01                SBC     PLUS_1,X        ; subtract FACX mantissa1
00296F  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002971  1               
002971  1               ; do ABS and normalise FAC1
002971  1               
002971  1               LAB_24D0
002971  1  B0 03                BCS     LAB_24D5        ; branch if number is +ve
002973  1               
002973  1  20 D8 29             JSR     LAB_2537        ; negate FAC1
002976  1               
002976  1               ; normalise FAC1
002976  1               
002976  1               LAB_24D5
002976  1  A0 00                LDY     #$00            ; clear Y
002978  1  98                   TYA                     ; clear A
002979  1  18                   CLC                     ; clear carry for add
00297A  1               LAB_24D9
00297A  1  A6 AD                LDX     FAC1_1          ; get FAC1 mantissa1
00297C  1  D0 3E                BNE     LAB_251B        ; if not zero normalise FAC1
00297E  1               
00297E  1  A6 AE                LDX     FAC1_2          ; get FAC1 mantissa2
002980  1  86 AD                STX     FAC1_1          ; save FAC1 mantissa1
002982  1  A6 AF                LDX     FAC1_3          ; get FAC1 mantissa3
002984  1  86 AE                STX     FAC1_2          ; save FAC1 mantissa2
002986  1  A6 B9                LDX     FAC1_r          ; get FAC1 rounding byte
002988  1  86 AF                STX     FAC1_3          ; save FAC1 mantissa3
00298A  1  84 B9                STY     FAC1_r          ; clear FAC1 rounding byte
00298C  1  69 08                ADC     #$08            ; add x to exponent offset
00298E  1  C9 18                CMP     #$18            ; compare with $18 (max offset, all bits would be =0)
002990  1  D0 E8                BNE     LAB_24D9        ; loop if not max
002992  1               
002992  1               ; clear FAC1 exponent and sign
002992  1               
002992  1               LAB_24F1
002992  1  A9 00                LDA     #$00            ; clear A
002994  1               LAB_24F3
002994  1  85 AC                STA     FAC1_e          ; set FAC1 exponent
002996  1               
002996  1               ; save FAC1 sign
002996  1               
002996  1               LAB_24F5
002996  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
002998  1  60                   RTS
002999  1               
002999  1               ; add FAC2 mantissa to FAC1 mantissa
002999  1               
002999  1               LAB_24F8
002999  1  65 A3                ADC     FAC2_r          ; add FAC2 rounding byte
00299B  1  85 B9                STA     FAC1_r          ; save FAC1 rounding byte
00299D  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
00299F  1  65 B6                ADC     FAC2_3          ; add FAC2 mantissa3
0029A1  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
0029A3  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0029A5  1  65 B5                ADC     FAC2_2          ; add FAC2 mantissa2
0029A7  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
0029A9  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
0029AB  1  65 B4                ADC     FAC2_1          ; add FAC2 mantissa1
0029AD  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
0029AF  1  B0 1A                BCS     LAB_252A        ; if carry then normalise FAC1 for C=1
0029B1  1               
0029B1  1  60                   RTS                     ; else just exit
0029B2  1               
0029B2  1               LAB_2511
0029B2  1  69 01                ADC     #$01            ; add 1 to exponent offset
0029B4  1  06 B9                ASL     FAC1_r          ; shift FAC1 rounding byte
0029B6  1  26 AF                ROL     FAC1_3          ; shift FAC1 mantissa3
0029B8  1  26 AE                ROL     FAC1_2          ; shift FAC1 mantissa2
0029BA  1  26 AD                ROL     FAC1_1          ; shift FAC1 mantissa1
0029BC  1               
0029BC  1               ; normalise FAC1
0029BC  1               
0029BC  1               LAB_251B
0029BC  1  10 F4                BPL     LAB_2511        ; loop if not normalised
0029BE  1               
0029BE  1  38                   SEC                     ; set carry for subtract
0029BF  1  E5 AC                SBC     FAC1_e          ; subtract FAC1 exponent
0029C1  1  B0 CF                BCS     LAB_24F1        ; branch if underflow (set result = $0)
0029C3  1               
0029C3  1  49 FF                EOR     #$FF            ; complement exponent
0029C5  1  69 01                ADC     #$01            ; +1 (twos complement)
0029C7  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
0029C9  1               
0029C9  1               ; test and normalise FAC1 for C=0/1
0029C9  1               
0029C9  1               LAB_2528
0029C9  1  90 0C                BCC     LAB_2536        ; exit if no overflow
0029CB  1               
0029CB  1               ; normalise FAC1 for C=1
0029CB  1               
0029CB  1               LAB_252A
0029CB  1  E6 AC                INC     FAC1_e          ; increment FAC1 exponent
0029CD  1  F0 36                BEQ     LAB_2564        ; if zero do overflow error and warm start
0029CF  1               
0029CF  1  66 AD                ROR     FAC1_1          ; shift FAC1 mantissa1
0029D1  1  66 AE                ROR     FAC1_2          ; shift FAC1 mantissa2
0029D3  1  66 AF                ROR     FAC1_3          ; shift FAC1 mantissa3
0029D5  1  66 B9                ROR     FAC1_r          ; shift FAC1 rounding byte
0029D7  1               LAB_2536
0029D7  1  60                   RTS
0029D8  1               
0029D8  1               ; negate FAC1
0029D8  1               
0029D8  1               LAB_2537
0029D8  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
0029DA  1  49 FF                EOR     #$FF            ; complement it
0029DC  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
0029DE  1               
0029DE  1               ; twos complement FAC1 mantissa
0029DE  1               
0029DE  1               LAB_253D
0029DE  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
0029E0  1  49 FF                EOR     #$FF            ; complement it
0029E2  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
0029E4  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0029E6  1  49 FF                EOR     #$FF            ; complement it
0029E8  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
0029EA  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
0029EC  1  49 FF                EOR     #$FF            ; complement it
0029EE  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
0029F0  1  A5 B9                LDA     FAC1_r          ; get FAC1 rounding byte
0029F2  1  49 FF                EOR     #$FF            ; complement it
0029F4  1  85 B9                STA     FAC1_r          ; save FAC1 rounding byte
0029F6  1  E6 B9                INC     FAC1_r          ; increment FAC1 rounding byte
0029F8  1  D0 0A                BNE     LAB_2563        ; exit if no overflow
0029FA  1               
0029FA  1               ; increment FAC1 mantissa
0029FA  1               
0029FA  1               LAB_2559
0029FA  1  E6 AF                INC     FAC1_3          ; increment FAC1 mantissa3
0029FC  1  D0 06                BNE     LAB_2563        ; finished if no rollover
0029FE  1               
0029FE  1  E6 AE                INC     FAC1_2          ; increment FAC1 mantissa2
002A00  1  D0 02                BNE     LAB_2563        ; finished if no rollover
002A02  1               
002A02  1  E6 AD                INC     FAC1_1          ; increment FAC1 mantissa1
002A04  1               LAB_2563
002A04  1  60                   RTS
002A05  1               
002A05  1               ; do overflow error (overflow exit)
002A05  1               
002A05  1               LAB_2564
002A05  1  A2 0A                LDX     #$0A            ; error code $0A ("Overflow" error)
002A07  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
002A0A  1               
002A0A  1               ; shift FCAtemp << A+8 times
002A0A  1               
002A0A  1               LAB_2569
002A0A  1  A2 74                LDX     #FACt_1-1       ; set offset to FACtemp
002A0C  1               LAB_256B
002A0C  1  B4 03                LDY     PLUS_3,X        ; get FACX mantissa3
002A0E  1  84 B9                STY     FAC1_r          ; save as FAC1 rounding byte
002A10  1  B4 02                LDY     PLUS_2,X        ; get FACX mantissa2
002A12  1  94 03                STY     PLUS_3,X        ; save FACX mantissa3
002A14  1  B4 01                LDY     PLUS_1,X        ; get FACX mantissa1
002A16  1  94 02                STY     PLUS_2,X        ; save FACX mantissa2
002A18  1  A4 B2                LDY     FAC1_o          ; get FAC1 overflow byte
002A1A  1  94 01                STY     PLUS_1,X        ; save FACX mantissa1
002A1C  1               
002A1C  1               ; shift FACX -A times right (> 8 shifts)
002A1C  1               
002A1C  1               LAB_257B
002A1C  1  69 08                ADC     #$08            ; add 8 to shift count
002A1E  1  30 EC                BMI     LAB_256B        ; go do 8 shift if still -ve
002A20  1               
002A20  1  F0 EA                BEQ     LAB_256B        ; go do 8 shift if zero
002A22  1               
002A22  1  E9 08                SBC     #$08            ; else subtract 8 again
002A24  1  A8                   TAY                     ; save count to Y
002A25  1  A5 B9                LDA     FAC1_r          ; get FAC1 rounding byte
002A27  1  B0 12                BCS     LAB_259A        ;.
002A29  1               
002A29  1               LAB_2588
002A29  1  16 01                ASL     PLUS_1,X        ; shift FACX mantissa1
002A2B  1  90 02                BCC     LAB_258E        ; branch if +ve
002A2D  1               
002A2D  1  F6 01                INC     PLUS_1,X        ; this sets b7 eventually
002A2F  1               LAB_258E
002A2F  1  76 01                ROR     PLUS_1,X        ; shift FACX mantissa1 (correct for ASL)
002A31  1  76 01                ROR     PLUS_1,X        ; shift FACX mantissa1 (put carry in b7)
002A33  1               
002A33  1               ; shift FACX Y times right
002A33  1               
002A33  1               LAB_2592
002A33  1  76 02                ROR     PLUS_2,X        ; shift FACX mantissa2
002A35  1  76 03                ROR     PLUS_3,X        ; shift FACX mantissa3
002A37  1  6A                   ROR     A               ; shift FACX rounding byte
002A38  1  C8                   INY                     ; increment exponent diff
002A39  1  D0 EE                BNE     LAB_2588        ; branch if range adjust not complete
002A3B  1               
002A3B  1               LAB_259A
002A3B  1  18                   CLC                     ; just clear it
002A3C  1  60                   RTS
002A3D  1               
002A3D  1               ; perform LOG()
002A3D  1               
002A3D  1               LAB_LOG
002A3D  1  20 1B 2D             JSR     LAB_27CA        ; test sign and zero
002A40  1  F0 02                BEQ     LAB_25C4        ; if zero do function call error then warm start
002A42  1               
002A42  1  10 03                BPL     LAB_25C7        ; skip error if +ve
002A44  1               
002A44  1               LAB_25C4
002A44  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start (-ve)
002A47  1               
002A47  1               LAB_25C7
002A47  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002A49  1  E9 7F                SBC     #$7F            ; normalise it
002A4B  1  48                   PHA                     ; save it
002A4C  1  A9 80                LDA     #$80            ; set exponent to zero
002A4E  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
002A50  1  A9 8F                LDA     #<LAB_25AD      ; set 1/root2 pointer low byte
002A52  1  A0 36                LDY     #>LAB_25AD      ; set 1/root2 pointer high byte
002A54  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1 (1/root2)
002A57  1  A9 93                LDA     #<LAB_25B1      ; set root2 pointer low byte
002A59  1  A0 36                LDY     #>LAB_25B1      ; set root2 pointer high byte
002A5B  1  20 93 2B             JSR     LAB_26CA        ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
002A5E  1  A9 06                LDA     #<LAB_259C      ; set 1 pointer low byte
002A60  1  A0 37                LDY     #>LAB_259C      ; set 1 pointer high byte
002A62  1  20 DF 28             JSR     LAB_2455        ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
002A65  1  A9 82                LDA     #<LAB_25A0      ; set pointer low byte to counter
002A67  1  A0 36                LDY     #>LAB_25A0      ; set pointer high byte to counter
002A69  1  20 1F 31             JSR     LAB_2B6E        ; ^2 then series evaluation
002A6C  1  A9 97                LDA     #<LAB_25B5      ; set -0.5 pointer low byte
002A6E  1  A0 36                LDY     #>LAB_25B5      ; set -0.5 pointer high byte
002A70  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1
002A73  1  68                   PLA                     ; restore FAC1 exponent
002A74  1  20 E2 2E             JSR     LAB_2912        ; evaluate new ASCII digit
002A77  1  A9 9B                LDA     #<LAB_25B9      ; set LOG(2) pointer low byte
002A79  1  A0 36                LDY     #>LAB_25B9      ; set LOG(2) pointer high byte
002A7B  1               
002A7B  1               ; do convert AY, FCA1*(AY)
002A7B  1               
002A7B  1               LAB_25FB
002A7B  1  20 CD 2A             JSR     LAB_264D        ; unpack memory (AY) into FAC2
002A7E  1               LAB_MULTIPLY
002A7E  1  F0 4C                BEQ     LAB_264C        ; exit if zero
002A80  1               
002A80  1  20 43 2B             JSR     LAB_2673        ; test and adjust accumulators
002A83  1  A9 00                LDA     #$00            ; clear A
002A85  1  85 75                STA     FACt_1          ; clear temp mantissa1
002A87  1  85 76                STA     FACt_2          ; clear temp mantissa2
002A89  1  85 77                STA     FACt_3          ; clear temp mantissa3
002A8B  1  A5 B9                LDA     FAC1_r          ; get FAC1 rounding byte
002A8D  1  20 A2 2A             JSR     LAB_2622        ; go do shift/add FAC2
002A90  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
002A92  1  20 A2 2A             JSR     LAB_2622        ; go do shift/add FAC2
002A95  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
002A97  1  20 A2 2A             JSR     LAB_2622        ; go do shift/add FAC2
002A9A  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
002A9C  1  20 A7 2A             JSR     LAB_2627        ; go do shift/add FAC2
002A9F  1  4C 00 2C             JMP     LAB_273C        ; copy temp to FAC1, normalise and return
002AA2  1               
002AA2  1               LAB_2622
002AA2  1  D0 03                BNE     LAB_2627        ; branch if byte <> zero
002AA4  1               
002AA4  1  4C 0A 2A             JMP     LAB_2569        ; shift FCAtemp << A+8 times
002AA7  1               
002AA7  1               ; else do shift and add
002AA7  1               LAB_2627
002AA7  1  4A                   LSR     A               ; shift byte
002AA8  1  09 80                ORA     #$80            ; set top bit (mark for 8 times)
002AAA  1               LAB_262A
002AAA  1  A8                   TAY                     ; copy result
002AAB  1  90 13                BCC     LAB_2640        ; skip next if bit was zero
002AAD  1               
002AAD  1  18                   CLC                     ; clear carry for add
002AAE  1  A5 77                LDA     FACt_3          ; get temp mantissa3
002AB0  1  65 B6                ADC     FAC2_3          ; add FAC2 mantissa3
002AB2  1  85 77                STA     FACt_3          ; save temp mantissa3
002AB4  1  A5 76                LDA     FACt_2          ; get temp mantissa2
002AB6  1  65 B5                ADC     FAC2_2          ; add FAC2 mantissa2
002AB8  1  85 76                STA     FACt_2          ; save temp mantissa2
002ABA  1  A5 75                LDA     FACt_1          ; get temp mantissa1
002ABC  1  65 B4                ADC     FAC2_1          ; add FAC2 mantissa1
002ABE  1  85 75                STA     FACt_1          ; save temp mantissa1
002AC0  1               LAB_2640
002AC0  1  66 75                ROR     FACt_1          ; shift temp mantissa1
002AC2  1  66 76                ROR     FACt_2          ; shift temp mantissa2
002AC4  1  66 77                ROR     FACt_3          ; shift temp mantissa3
002AC6  1  66 B9                ROR     FAC1_r          ; shift temp rounding byte
002AC8  1  98                   TYA                     ; get byte back
002AC9  1  4A                   LSR     A               ; shift byte
002ACA  1  D0 DE                BNE     LAB_262A        ; loop if all bits not done
002ACC  1               
002ACC  1               LAB_264C
002ACC  1  60                   RTS
002ACD  1               
002ACD  1               ; unpack memory (AY) into FAC2
002ACD  1               
002ACD  1               LAB_264D
002ACD  1  85 71                STA     ut1_pl          ; save pointer low byte
002ACF  1  84 72                STY     ut1_ph          ; save pointer high byte
002AD1  1  A0 03                LDY     #$03            ; 4 bytes to get (0-3)
002AD3  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa3
002AD7  1  B5 71 C9 00  
002ADB  1  D0 04 A2 00  
002AE9  1  85 B6                STA     FAC2_3          ; save FAC2 mantissa3
002AEB  1  88                   DEY                     ; decrement index
002AEC  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa2
002AF0  1  B5 71 C9 00  
002AF4  1  D0 04 A2 00  
002B02  1  85 B5                STA     FAC2_2          ; save FAC2 mantissa2
002B04  1  88                   DEY                     ; decrement index
002B05  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa1+sign
002B09  1  B5 71 C9 00  
002B0D  1  D0 04 A2 00  
002B1B  1  85 B7                STA     FAC2_s          ; save FAC2 sign (b7)
002B1D  1  45 B0                EOR     FAC1_s          ; EOR with FAC1 sign (b7)
002B1F  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
002B21  1  A5 B7                LDA     FAC2_s          ; recover FAC2 sign (b7)
002B23  1  09 80                ORA     #$80            ; set 1xxx xxx (set normal bit)
002B25  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
002B27  1  88                   DEY                     ; decrement index
002B28  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get exponent byte
002B2C  1  B5 71 C9 00  
002B30  1  D0 04 A2 00  
002B3E  1  85 B3                STA     FAC2_e          ; save FAC2 exponent
002B40  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002B42  1  60                   RTS
002B43  1               
002B43  1               ; test and adjust accumulators
002B43  1               
002B43  1               LAB_2673
002B43  1  A5 B3                LDA     FAC2_e          ; get FAC2 exponent
002B45  1               LAB_2675
002B45  1  F0 1D                BEQ     LAB_2696        ; branch if FAC2 = $00 (handle underflow)
002B47  1               
002B47  1  18                   CLC                     ; clear carry for add
002B48  1  65 AC                ADC     FAC1_e          ; add FAC1 exponent
002B4A  1  90 04                BCC     LAB_2680        ; branch if sum of exponents <$0100
002B4C  1               
002B4C  1  30 31                BMI     LAB_269B        ; do overflow error
002B4E  1               
002B4E  1  18                   CLC                     ; clear carry for the add
002B4F  1  2C                   .BYTE   $2C             ; makes next line BIT $1410
002B50  1               LAB_2680
002B50  1  10 12                BPL     LAB_2696        ; if +ve go handle underflow
002B52  1               
002B52  1  69 80                ADC     #$80            ; adjust exponent
002B54  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
002B56  1  D0 03                BNE     LAB_268B        ; branch if not zero
002B58  1               
002B58  1  4C 96 29             JMP     LAB_24F5        ; save FAC1 sign and return
002B5B  1               
002B5B  1               LAB_268B
002B5B  1  A5 B8                LDA     FAC_sc          ; get sign compare (FAC1 EOR FAC2)
002B5D  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
002B5F  1               LAB_268F
002B5F  1  60                   RTS
002B60  1               
002B60  1               ; handle overflow and underflow
002B60  1               
002B60  1               LAB_2690
002B60  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
002B62  1  10 1B                BPL     LAB_269B        ; do overflow error
002B64  1               
002B64  1               ; handle underflow
002B64  1               LAB_2696
002B64  1  68                   PLA                     ; pop return address low byte
002B65  1  68                   PLA                     ; pop return address high byte
002B66  1  4C 92 29             JMP     LAB_24F1        ; clear FAC1 exponent and sign and return
002B69  1               
002B69  1               ; multiply by 10
002B69  1               
002B69  1               LAB_269E
002B69  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
002B6C  1  AA                   TAX                     ; copy exponent (set the flags)
002B6D  1  F0 F0                BEQ     LAB_268F        ; exit if zero
002B6F  1               
002B6F  1  18                   CLC                     ; clear carry for add
002B70  1  69 02                ADC     #$02            ; add two to exponent (*4)
002B72  1  B0 0B                BCS     LAB_269B        ; do overflow error if > $FF
002B74  1               
002B74  1  A2 00                LDX     #$00            ; clear byte
002B76  1  86 B8                STX     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
002B78  1  20 17 29             JSR     LAB_247C        ; add FAC2 to FAC1 (*5)
002B7B  1  E6 AC                INC     FAC1_e          ; increment FAC1 exponent (*10)
002B7D  1  D0 E0                BNE     LAB_268F        ; if non zero just do RTS
002B7F  1               
002B7F  1               LAB_269B
002B7F  1  4C 05 2A             JMP     LAB_2564        ; do overflow error and warm start
002B82  1               
002B82  1               ; divide by 10
002B82  1               
002B82  1               LAB_26B9
002B82  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
002B85  1  A9 17                LDA     #<LAB_26B5      ; set pointer to 10d low addr
002B87  1  A0 37                LDY     #>LAB_26B5      ; set pointer to 10d high addr
002B89  1  A2 00                LDX     #$00            ; clear sign
002B8B  1               
002B8B  1               ; divide by (AY) (X=sign)
002B8B  1               
002B8B  1               LAB_26C2
002B8B  1  86 B8                STX     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
002B8D  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
002B90  1  4C 96 2B             JMP     LAB_DIVIDE      ; do FAC2/FAC1
002B93  1               
002B93  1               ; Perform divide-by
002B93  1               ; convert AY and do (AY)/FAC1
002B93  1               
002B93  1               LAB_26CA
002B93  1  20 CD 2A             JSR     LAB_264D        ; unpack memory (AY) into FAC2
002B96  1               
002B96  1               ; Perform divide-into
002B96  1               LAB_DIVIDE
002B96  1  F0 63                BEQ     LAB_2737        ; if zero go do /0 error
002B98  1               
002B98  1  20 0B 2D             JSR     LAB_27BA        ; round FAC1
002B9B  1  A9 00                LDA     #$00            ; clear A
002B9D  1  38                   SEC                     ; set carry for subtract
002B9E  1  E5 AC                SBC     FAC1_e          ; subtract FAC1 exponent (2s complement)
002BA0  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
002BA2  1  20 43 2B             JSR     LAB_2673        ; test and adjust accumulators
002BA5  1  E6 AC                INC     FAC1_e          ; increment FAC1 exponent
002BA7  1  F0 D6                BEQ     LAB_269B        ; if zero do overflow error
002BA9  1               
002BA9  1  A2 FF                LDX     #$FF            ; set index for pre increment
002BAB  1  A9 01                LDA     #$01            ; set bit to flag byte save
002BAD  1               LAB_26E4
002BAD  1  A4 B4                LDY     FAC2_1          ; get FAC2 mantissa1
002BAF  1  C4 AD                CPY     FAC1_1          ; compare FAC1 mantissa1
002BB1  1  D0 0A                BNE     LAB_26F4        ; branch if <>
002BB3  1               
002BB3  1  A4 B5                LDY     FAC2_2          ; get FAC2 mantissa2
002BB5  1  C4 AE                CPY     FAC1_2          ; compare FAC1 mantissa2
002BB7  1  D0 04                BNE     LAB_26F4        ; branch if <>
002BB9  1               
002BB9  1  A4 B6                LDY     FAC2_3          ; get FAC2 mantissa3
002BBB  1  C4 AF                CPY     FAC1_3          ; compare FAC1 mantissa3
002BBD  1               LAB_26F4
002BBD  1  08                   PHP                     ; save FAC2-FAC1 compare status
002BBE  1  2A                   ROL     A               ; shift the result byte
002BBF  1  90 0E                BCC     LAB_2702        ; if no carry skip the byte save
002BC1  1               
002BC1  1  A0 01                LDY     #$01            ; set bit to flag byte save
002BC3  1  E8                   INX                     ; else increment the index to FACt
002BC4  1  E0 02                CPX     #$02            ; compare with the index to FACt_3
002BC6  1  30 04                BMI     LAB_2701        ; if not last byte just go save it
002BC8  1               
002BC8  1  D0 28                BNE     LAB_272B        ; if all done go save FAC1 rounding byte, normalise and
002BCA  1               ; return
002BCA  1               
002BCA  1  A0 40                LDY     #$40            ; set bit to flag byte save for the rounding byte
002BCC  1               LAB_2701
002BCC  1  95 75                STA     FACt_1,X        ; write result byte to FACt_1 + index
002BCE  1  98                   TYA                     ; copy the next save byte flag
002BCF  1               LAB_2702
002BCF  1  28                   PLP                     ; restore FAC2-FAC1 compare status
002BD0  1  90 14                BCC     LAB_2704        ; if FAC2 < FAC1 then skip the subtract
002BD2  1               
002BD2  1  A8                   TAY                     ; save FAC2-FAC1 compare status
002BD3  1  A5 B6                LDA     FAC2_3          ; get FAC2 mantissa3
002BD5  1  E5 AF                SBC     FAC1_3          ; subtract FAC1 mantissa3
002BD7  1  85 B6                STA     FAC2_3          ; save FAC2 mantissa3
002BD9  1  A5 B5                LDA     FAC2_2          ; get FAC2 mantissa2
002BDB  1  E5 AE                SBC     FAC1_2          ; subtract FAC1 mantissa2
002BDD  1  85 B5                STA     FAC2_2          ; save FAC2 mantissa2
002BDF  1  A5 B4                LDA     FAC2_1          ; get FAC2 mantissa1
002BE1  1  E5 AD                SBC     FAC1_1          ; subtract FAC1 mantissa1
002BE3  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
002BE5  1  98                   TYA                     ; restore FAC2-FAC1 compare status
002BE6  1               
002BE6  1               ; FAC2 = FAC2*2
002BE6  1               LAB_2704
002BE6  1  06 B6                ASL     FAC2_3          ; shift FAC2 mantissa3
002BE8  1  26 B5                ROL     FAC2_2          ; shift FAC2 mantissa2
002BEA  1  26 B4                ROL     FAC2_1          ; shift FAC2 mantissa1
002BEC  1  B0 CF                BCS     LAB_26F4        ; loop with no compare
002BEE  1               
002BEE  1  30 BD                BMI     LAB_26E4        ; loop with compare
002BF0  1               
002BF0  1  10 CB                BPL     LAB_26F4        ; loop always with no compare
002BF2  1               
002BF2  1               ; do A<<6, save as FAC1 rounding byte, normalise and return
002BF2  1               
002BF2  1               LAB_272B
002BF2  1  4A                   LSR     A               ; shift b1 - b0 ..
002BF3  1  6A                   ROR     A               ; ..
002BF4  1  6A                   ROR     A               ; .. to b7 - b6
002BF5  1  85 B9                STA     FAC1_r          ; save FAC1 rounding byte
002BF7  1  28                   PLP                     ; dump FAC2-FAC1 compare status
002BF8  1  4C 00 2C             JMP     LAB_273C        ; copy temp to FAC1, normalise and return
002BFB  1               
002BFB  1               ; do "Divide by zero" error
002BFB  1               
002BFB  1               LAB_2737
002BFB  1  A2 14                LDX     #$14            ; error code $14 ("Divide by zero" error)
002BFD  1  4C F7 09             JMP     LAB_XERR        ; do error #X, then warm start
002C00  1               
002C00  1               ; copy temp to FAC1 and normalise
002C00  1               
002C00  1               LAB_273C
002C00  1  A5 75                LDA     FACt_1          ; get temp mantissa1
002C02  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002C04  1  A5 76                LDA     FACt_2          ; get temp mantissa2
002C06  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
002C08  1  A5 77                LDA     FACt_3          ; get temp mantissa3
002C0A  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
002C0C  1  4C 76 29             JMP     LAB_24D5        ; normalise FAC1 and return
002C0F  1               
002C0F  1               ; unpack memory (AY) into FAC1
002C0F  1               
002C0F  1               LAB_UFAC
002C0F  1  85 71                STA     ut1_pl          ; save pointer low byte
002C11  1  84 72                STY     ut1_ph          ; save pointer high byte
002C13  1  A0 03                LDY     #$03            ; 4 bytes to do
002C15  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get last byte
002C19  1  B5 71 C9 00  
002C1D  1  D0 04 A2 00  
002C2B  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
002C2D  1  88                   DEY                     ; decrement index
002C2E  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get last-1 byte
002C32  1  B5 71 C9 00  
002C36  1  D0 04 A2 00  
002C44  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
002C46  1  88                   DEY                     ; decrement index
002C47  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get second byte
002C4B  1  B5 71 C9 00  
002C4F  1  D0 04 A2 00  
002C5D  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
002C5F  1  09 80                ORA     #$80            ; set 1xxx xxxx (add normal bit)
002C61  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002C63  1  88                   DEY                     ; decrement index
002C64  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get first byte (exponent)
002C68  1  B5 71 C9 00  
002C6C  1  D0 04 A2 00  
002C7A  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
002C7C  1  84 B9                STY     FAC1_r          ; clear FAC1 rounding byte
002C7E  1  60                   RTS
002C7F  1               
002C7F  1               ; pack FAC1 into Adatal
002C7F  1               
002C7F  1               LAB_276E
002C7F  1  A2 A4                LDX     #<Adatal        ; set pointer low byte
002C81  1               LAB_2770
002C81  1  A0 00                LDY     #>Adatal        ; set pointer high byte
002C83  1  F0 04                BEQ     LAB_2778        ; pack FAC1 into (XY) and return
002C85  1               
002C85  1               ; pack FAC1 into (Lvarpl)
002C85  1               
002C85  1               LAB_PFAC
002C85  1  A6 97                LDX     Lvarpl          ; get destination pointer low byte
002C87  1  A4 98                LDY     Lvarph          ; get destination pointer high byte
002C89  1               
002C89  1               ; pack FAC1 into (XY)
002C89  1               
002C89  1               LAB_2778
002C89  1  20 0B 2D             JSR     LAB_27BA        ; round FAC1
002C8C  1  86 71                STX     ut1_pl          ; save pointer low byte
002C8E  1  84 72                STY     ut1_ph          ; save pointer high byte
002C90  1  A0 03                LDY     #$03            ; set index
002C92  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
002C94  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
002C98  1  01 B5 71 C9  
002C9C  1  00 D0 04 A2  
002CAA  1  88                   DEY                     ; decrement index
002CAB  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
002CAD  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
002CB1  1  01 B5 71 C9  
002CB5  1  00 D0 04 A2  
002CC3  1  88                   DEY                     ; decrement index
002CC4  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
002CC6  1  09 7F                ORA     #$7F            ; set bits x111 1111
002CC8  1  25 AD                AND     FAC1_1          ; AND in FAC1 mantissa1
002CCA  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
002CCE  1  01 B5 71 C9  
002CD2  1  00 D0 04 A2  
002CE0  1  88                   DEY                     ; decrement index
002CE1  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002CE3  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
002CE7  1  01 B5 71 C9  
002CEB  1  00 D0 04 A2  
002CF9  1  84 B9                STY     FAC1_r          ; clear FAC1 rounding byte
002CFB  1  60                   RTS
002CFC  1               
002CFC  1               ; round and copy FAC1 to FAC2
002CFC  1               
002CFC  1               LAB_27AB
002CFC  1  20 0B 2D             JSR     LAB_27BA        ; round FAC1
002CFF  1               
002CFF  1               ; copy FAC1 to FAC2
002CFF  1               
002CFF  1               LAB_27AE
002CFF  1  A2 05                LDX     #$05            ; 5 bytes to copy
002D01  1               LAB_27B0
002D01  1  B5 AB                LDA     FAC1_e-1,X      ; get byte from FAC1,X
002D03  1  95 B2                STA     FAC1_o,X        ; save byte at FAC2,X
002D05  1  CA                   DEX                     ; decrement count
002D06  1  D0 F9                BNE     LAB_27B0        ; loop if not all done
002D08  1               
002D08  1  86 B9                STX     FAC1_r          ; clear FAC1 rounding byte
002D0A  1               LAB_27B9
002D0A  1  60                   RTS
002D0B  1               
002D0B  1               ; round FAC1
002D0B  1               
002D0B  1               LAB_27BA
002D0B  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002D0D  1  F0 FB                BEQ     LAB_27B9        ; exit if zero
002D0F  1               
002D0F  1  06 B9                ASL     FAC1_r          ; shift FAC1 rounding byte
002D11  1  90 F7                BCC     LAB_27B9        ; exit if no overflow
002D13  1               
002D13  1               ; round FAC1 (no check)
002D13  1               
002D13  1               LAB_27C2
002D13  1  20 FA 29             JSR     LAB_2559        ; increment FAC1 mantissa
002D16  1  D0 F2                BNE     LAB_27B9        ; branch if no overflow
002D18  1               
002D18  1  4C CB 29             JMP     LAB_252A        ; normalise FAC1 for C=1 and return
002D1B  1               
002D1B  1               ; get FAC1 sign
002D1B  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
002D1B  1               
002D1B  1               LAB_27CA
002D1B  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002D1D  1  F0 09                BEQ     LAB_27D7        ; exit if zero (already correct SGN(0)=0)
002D1F  1               
002D1F  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
002D1F  1               ; no = 0 check
002D1F  1               
002D1F  1               LAB_27CE
002D1F  1  A5 B0                LDA     FAC1_s          ; else get FAC1 sign (b7)
002D21  1               
002D21  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
002D21  1               ; no = 0 check, sign in A
002D21  1               
002D21  1               LAB_27D0
002D21  1  2A                   ROL     A               ; move sign bit to carry
002D22  1  A9 FF                LDA     #$FF            ; set byte for -ve result
002D24  1  B0 02                BCS     LAB_27D7        ; return if sign was set (-ve)
002D26  1               
002D26  1  A9 01                LDA     #$01            ; else set byte for +ve result
002D28  1               LAB_27D7
002D28  1  60                   RTS
002D29  1               
002D29  1               ; perform SGN()
002D29  1               
002D29  1               LAB_SGN
002D29  1  20 1B 2D             JSR     LAB_27CA        ; get FAC1 sign
002D2C  1               ; return A=$FF/-ve A=$01/+ve
002D2C  1               ; save A as integer byte
002D2C  1               
002D2C  1               LAB_27DB
002D2C  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002D2E  1  A9 00                LDA     #$00            ; clear A
002D30  1  85 AE                STA     FAC1_2          ; clear FAC1 mantissa2
002D32  1  A2 88                LDX     #$88            ; set exponent
002D34  1               
002D34  1               ; set exp=X, clearFAC1 mantissa3 and normalise
002D34  1               
002D34  1               LAB_27E3
002D34  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
002D36  1  49 FF                EOR     #$FF            ; complement it
002D38  1  2A                   ROL     A               ; sign bit into carry
002D39  1               
002D39  1               ; set exp=X, clearFAC1 mantissa3 and normalise
002D39  1               
002D39  1               LAB_STFA
002D39  1  A9 00                LDA     #$00            ; clear A
002D3B  1  85 AF                STA     FAC1_3          ; clear FAC1 mantissa3
002D3D  1  86 AC                STX     FAC1_e          ; set FAC1 exponent
002D3F  1  85 B9                STA     FAC1_r          ; clear FAC1 rounding byte
002D41  1  85 B0                STA     FAC1_s          ; clear FAC1 sign (b7)
002D43  1  4C 71 29             JMP     LAB_24D0        ; do ABS and normalise FAC1
002D46  1               
002D46  1               ; perform ABS()
002D46  1               
002D46  1               LAB_ABS
002D46  1  46 B0                LSR     FAC1_s          ; clear FAC1 sign (put zero in b7)
002D48  1  60                   RTS
002D49  1               
002D49  1               ; compare FAC1 with (AY)
002D49  1               ; returns A=$00 if FAC1 = (AY)
002D49  1               ; returns A=$01 if FAC1 > (AY)
002D49  1               ; returns A=$FF if FAC1 < (AY)
002D49  1               
002D49  1               LAB_27F8
002D49  1  85 73                STA     ut2_pl          ; save pointer low byte
002D4B  1               LAB_27FA
002D4B  1  84 74                STY     ut2_ph          ; save pointer high byte
002D4D  1  A0 00                LDY     #$00            ; clear index
002D4F  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get exponent
002D53  1  B5 73 C9 00  
002D57  1  D0 04 A2 00  
002D65  1  C8                   INY                     ; increment index
002D66  1  AA                   TAX                     ; copy (AY) exponent to X
002D67  1  F0 B2                BEQ     LAB_27CA        ; branch if (AY) exponent=0 and get FAC1 sign
002D69  1               ; A=FF,C=1/-ve A=01,C=0/+ve
002D69  1               
002D69  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get (AY) mantissa1 (with sign)
002D6D  1  B5 73 C9 00  
002D71  1  D0 04 A2 00  
002D7F  1  45 B0                EOR     FAC1_s          ; EOR FAC1 sign (b7)
002D81  1  30 9C                BMI     LAB_27CE        ; if signs <> do return A=FF,C=1/-ve
002D83  1               ; A=01,C=0/+ve and return
002D83  1               
002D83  1  E4 AC                CPX     FAC1_e          ; compare (AY) exponent with FAC1 exponent
002D85  1  D0 56                BNE     LAB_2828        ; branch if different
002D87  1               
002D87  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get (AY) mantissa1 (with sign)
002D8B  1  B5 73 C9 00  
002D8F  1  D0 04 A2 00  
002D9D  1  09 80                ORA     #$80            ; normalise top bit
002D9F  1  C5 AD                CMP     FAC1_1          ; compare with FAC1 mantissa1
002DA1  1  D0 3A                BNE     LAB_2828        ; branch if different
002DA3  1               
002DA3  1  C8                   INY                     ; increment index
002DA4  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get mantissa2
002DA8  1  B5 73 C9 00  
002DAC  1  D0 04 A2 00  
002DBA  1  C5 AE                CMP     FAC1_2          ; compare with FAC1 mantissa2
002DBC  1  D0 1F                BNE     LAB_2828        ; branch if different
002DBE  1               
002DBE  1  C8                   INY                     ; increment index
002DBF  1  A9 7F                LDA     #$7F            ; set for 1/2 value rounding byte
002DC1  1  C5 B9                CMP     FAC1_r          ; compare with FAC1 rounding byte (set carry)
002DC3  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get mantissa3
002DC7  1  B5 73 C9 00  
002DCB  1  D0 04 A2 00  
002DD9  1  E5 AF                SBC     FAC1_3          ; subtract FAC1 mantissa3
002DDB  1  F0 28                BEQ     LAB_2850        ; exit if mantissa3 equal
002DDD  1               
002DDD  1               ; gets here if number <> FAC1
002DDD  1               
002DDD  1               LAB_2828
002DDD  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
002DDF  1  90 02                BCC     LAB_282E        ; branch if FAC1 > (AY)
002DE1  1               
002DE1  1  49 FF                EOR     #$FF            ; else toggle FAC1 sign
002DE3  1               LAB_282E
002DE3  1  4C 21 2D             JMP     LAB_27D0        ; return A=FF,C=1/-ve A=01,C=0/+ve
002DE6  1               
002DE6  1               ; convert FAC1 floating-to-fixed
002DE6  1               
002DE6  1               LAB_2831
002DE6  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002DE8  1  F0 4A                BEQ     LAB_287F        ; if zero go clear FAC1 and return
002DEA  1               
002DEA  1  38                   SEC                     ; set carry for subtract
002DEB  1  E9 98                SBC     #$98            ; subtract maximum integer range exponent
002DED  1  24 B0                BIT     FAC1_s          ; test FAC1 sign (b7)
002DEF  1  10 09                BPL     LAB_2845        ; branch if FAC1 +ve
002DF1  1               
002DF1  1               ; FAC1 was -ve
002DF1  1  AA                   TAX                     ; copy subtracted exponent
002DF2  1  A9 FF                LDA     #$FF            ; overflow for -ve number
002DF4  1  85 B2                STA     FAC1_o          ; set FAC1 overflow byte
002DF6  1  20 DE 29             JSR     LAB_253D        ; twos complement FAC1 mantissa
002DF9  1  8A                   TXA                     ; restore subtracted exponent
002DFA  1               LAB_2845
002DFA  1  A2 AC                LDX     #FAC1_e         ; set index to FAC1
002DFC  1  C9 F9                CMP     #$F9            ; compare exponent result
002DFE  1  10 06                BPL     LAB_2851        ; if < 8 shifts shift FAC1 A times right and return
002E00  1               
002E00  1  20 1C 2A             JSR     LAB_257B        ; shift FAC1 A times right (> 8 shifts)
002E03  1  84 B2                STY     FAC1_o          ; clear FAC1 overflow byte
002E05  1               LAB_2850
002E05  1  60                   RTS
002E06  1               
002E06  1               ; shift FAC1 A times right
002E06  1               
002E06  1               LAB_2851
002E06  1  A8                   TAY                     ; copy shift count
002E07  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
002E09  1  29 80                AND     #$80            ; mask sign bit only (x000 0000)
002E0B  1  46 AD                LSR     FAC1_1          ; shift FAC1 mantissa1
002E0D  1  05 AD                ORA     FAC1_1          ; OR sign in b7 FAC1 mantissa1
002E0F  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002E11  1  20 33 2A             JSR     LAB_2592        ; shift FAC1 Y times right
002E14  1  84 B2                STY     FAC1_o          ; clear FAC1 overflow byte
002E16  1  60                   RTS
002E17  1               
002E17  1               ; perform INT()
002E17  1               
002E17  1               LAB_INT
002E17  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
002E19  1  C9 98                CMP     #$98            ; compare with max int
002E1B  1  B0 1E                BCS     LAB_2886        ; exit if >= (already int, too big for fractional part!)
002E1D  1               
002E1D  1  20 E6 2D             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
002E20  1  84 B9                STY     FAC1_r          ; save FAC1 rounding byte
002E22  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
002E24  1  84 B0                STY     FAC1_s          ; save FAC1 sign (b7)
002E26  1  49 80                EOR     #$80            ; toggle FAC1 sign
002E28  1  2A                   ROL     A               ; shift into carry
002E29  1  A9 98                LDA     #$98            ; set new exponent
002E2B  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
002E2D  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
002E2F  1  85 5B                STA     Temp3           ; save for EXP() function
002E31  1  4C 71 29             JMP     LAB_24D0        ; do ABS and normalise FAC1
002E34  1               
002E34  1               ; clear FAC1 and return
002E34  1               
002E34  1               LAB_287F
002E34  1  85 AD                STA     FAC1_1          ; clear FAC1 mantissa1
002E36  1  85 AE                STA     FAC1_2          ; clear FAC1 mantissa2
002E38  1  85 AF                STA     FAC1_3          ; clear FAC1 mantissa3
002E3A  1  A8                   TAY                     ; clear Y
002E3B  1               LAB_2886
002E3B  1  60                   RTS
002E3C  1               
002E3C  1               ; get FAC1 from string
002E3C  1               ; this routine now handles hex and binary values from strings
002E3C  1               ; starting with "$" and "%" respectively
002E3C  1               
002E3C  1               LAB_2887
002E3C  1  A0 00                LDY     #$00            ; clear Y
002E3E  1  84 5F                STY     Dtypef          ; clear data type flag, $FF=string, $00=numeric
002E40  1  A2 09                LDX     #$09            ; set index
002E42  1               LAB_288B
002E42  1  94 A8                STY     numexp,X        ; clear byte
002E44  1  CA                   DEX                     ; decrement index
002E45  1  10 FB                BPL     LAB_288B        ; loop until numexp to negnum (and FAC1) = $00
002E47  1               
002E47  1  B0 03                BCS     LAB_s28FE       ; branch if 1st NOT character numeric
002E49  1  4C CF 2E             JMP     LAB_28FE        ; branch if 1st character numeric
002E4C  1               LAB_s28FE:
002E4C  1               
002E4C  1               ; get FAC1 from string .. first character wasn't numeric
002E4C  1               
002E4C  1  C9 2D                CMP     #'-'            ; else compare with "-"
002E4E  1  D0 04                BNE     LAB_289A        ; branch if not "-"
002E50  1               
002E50  1  86 B1                STX     negnum          ; set flag for -ve number (X = $FF)
002E52  1  F0 04                BEQ     LAB_289C        ; branch always (go scan and check for hex/bin)
002E54  1               
002E54  1               ; get FAC1 from string .. first character wasn't numeric or -
002E54  1               
002E54  1               LAB_289A
002E54  1  C9 2B                CMP     #'+'            ; else compare with "+"
002E56  1  D0 06                BNE     LAB_289D        ; branch if not "+" (go check for hex/bin)
002E58  1               
002E58  1               ; was "+" or "-" to start, so get next character
002E58  1               
002E58  1               LAB_289C
002E58  1                       .IFDEF  DUODYNE
002E58  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E5C  1                       .ELSE
002E5C  1                       JSR     LAB_IGBY        ; increment and scan memory
002E5C  1                       .ENDIF
002E5C  1               
002E5C  1  90 71                BCC     LAB_28FE        ; branch if numeric character
002E5E  1               
002E5E  1               ; code here for hex and binary numbers
002E5E  1               
002E5E  1               LAB_289D
002E5E  1  C9 24                CMP     #'$'            ; else compare with "$"
002E60  1  D0 03                BNE     LAB_NHEX        ; branch if not "$"
002E62  1               
002E62  1  4C 90 33             JMP     LAB_CHEX        ; branch if "$"
002E65  1               
002E65  1               LAB_NHEX
002E65  1  C9 25                CMP     #'%'            ; else compare with "%"
002E67  1  D0 09                BNE     LAB_28A3        ; branch if not "%" (continue original code)
002E69  1               
002E69  1  4C BF 33             JMP     LAB_CBIN        ; branch if "%"
002E6C  1               
002E6C  1               LAB_289E
002E6C  1                       .IFDEF  DUODYNE
002E6C  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E70  1                       .ELSE
002E70  1                       JSR     LAB_IGBY        ; increment and scan memory
002E70  1                       .ENDIF
002E70  1               
002E70  1               LAB_28A1
002E70  1  90 5D                BCC     LAB_28FE        ; branch if numeric character
002E72  1               
002E72  1               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
002E72  1               
002E72  1               LAB_28A3
002E72  1  C9 2E                CMP     #'.'            ; else compare with "."
002E74  1  F0 30                BEQ     LAB_28D5        ; branch if "."
002E76  1               
002E76  1               ; get FAC1 from string .. character wasn't numeric, -, + or .
002E76  1               
002E76  1  C9 45                CMP     #'E'            ; else compare with "E"
002E78  1  D0 32                BNE     LAB_28DB        ; branch if not "E"
002E7A  1               
002E7A  1               ; was "E" so evaluate exponential part
002E7A  1                       .IFDEF  DUODYNE
002E7A  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E7E  1                       .ELSE
002E7E  1                       JSR     LAB_IGBY        ; increment and scan memory
002E7E  1                       .ENDIF
002E7E  1               
002E7E  1  90 18                BCC     LAB_28C7        ; branch if numeric character
002E80  1               
002E80  1  C9 B8                CMP     #TK_MINUS       ; else compare with token for -
002E82  1  F0 0E                BEQ     LAB_28C2        ; branch if token for -
002E84  1               
002E84  1  C9 2D                CMP     #'-'            ; else compare with "-"
002E86  1  F0 0A                BEQ     LAB_28C2        ; branch if "-"
002E88  1               
002E88  1  C9 B7                CMP     #TK_PLUS        ; else compare with token for +
002E8A  1  F0 08                BEQ     LAB_28C4        ; branch if token for +
002E8C  1               
002E8C  1  C9 2B                CMP     #'+'            ; else compare with "+"
002E8E  1  F0 04                BEQ     LAB_28C4        ; branch if "+"
002E90  1               
002E90  1  D0 08                BNE     LAB_28C9        ; branch always
002E92  1               
002E92  1               LAB_28C2
002E92  1  66 AB                ROR     expneg          ; set exponent -ve flag (C, which=1, into b7)
002E94  1               LAB_28C4
002E94  1                       .IFDEF  DUODYNE
002E94  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E98  1                       .ELSE
002E98  1                       JSR     LAB_IGBY        ; increment and scan memory
002E98  1                       .ENDIF
002E98  1               
002E98  1               LAB_28C7
002E98  1  90 5B                BCC     LAB_2925        ; branch if numeric character
002E9A  1               
002E9A  1               LAB_28C9
002E9A  1  24 AB                BIT     expneg          ; test exponent -ve flag
002E9C  1  10 0E                BPL     LAB_28DB        ; if +ve go evaluate exponent
002E9E  1               
002E9E  1               ; else do exponent = -exponent
002E9E  1  A9 00                LDA     #$00            ; clear result
002EA0  1  38                   SEC                     ; set carry for subtract
002EA1  1  E5 A9                SBC     expcnt          ; subtract exponent byte
002EA3  1  4C AE 2E             JMP     LAB_28DD        ; go evaluate exponent
002EA6  1               
002EA6  1               LAB_28D5
002EA6  1  66 AA                ROR     numdpf          ; set decimal point flag
002EA8  1  24 AA                BIT     numdpf          ; test decimal point flag
002EAA  1  50 C0                BVC     LAB_289E        ; branch if only one decimal point so far
002EAC  1               
002EAC  1               ; evaluate exponent
002EAC  1               LAB_28DB
002EAC  1  A5 A9                LDA     expcnt          ; get exponent count byte
002EAE  1               LAB_28DD
002EAE  1  38                   SEC                     ; set carry for subtract
002EAF  1  E5 A8                SBC     numexp          ; subtract numerator exponent
002EB1  1  85 A9                STA     expcnt          ; save exponent count byte
002EB3  1  F0 12                BEQ     LAB_28F6        ; branch if no adjustment
002EB5  1               
002EB5  1  10 09                BPL     LAB_28EF        ; else if +ve go do FAC1*10^expcnt
002EB7  1               
002EB7  1               ; else go do FAC1/10^(0-expcnt)
002EB7  1               LAB_28E6
002EB7  1  20 82 2B             JSR     LAB_26B9        ; divide by 10
002EBA  1  E6 A9                INC     expcnt          ; increment exponent count byte
002EBC  1  D0 F9                BNE     LAB_28E6        ; loop until all done
002EBE  1               
002EBE  1  F0 07                BEQ     LAB_28F6        ; branch always
002EC0  1               
002EC0  1               LAB_28EF
002EC0  1  20 69 2B             JSR     LAB_269E        ; multiply by 10
002EC3  1  C6 A9                DEC     expcnt          ; decrement exponent count byte
002EC5  1  D0 F9                BNE     LAB_28EF        ; loop until all done
002EC7  1               
002EC7  1               LAB_28F6
002EC7  1  A5 B1                LDA     negnum          ; get -ve flag
002EC9  1  30 01                BMI     LAB_28FB        ; if -ve do - FAC1 and return
002ECB  1               
002ECB  1  60                   RTS
002ECC  1               
002ECC  1               ; do - FAC1 and return
002ECC  1               
002ECC  1               LAB_28FB
002ECC  1  4C C2 30             JMP     LAB_GTHAN       ; do - FAC1 and return
002ECF  1               
002ECF  1               ; do unsigned FAC1*10+number
002ECF  1               
002ECF  1               LAB_28FE
002ECF  1  48                   PHA                     ; save character
002ED0  1  24 AA                BIT     numdpf          ; test decimal point flag
002ED2  1  10 02                BPL     LAB_2905        ; skip exponent increment if not set
002ED4  1               
002ED4  1  E6 A8                INC     numexp          ; else increment number exponent
002ED6  1               LAB_2905
002ED6  1  20 69 2B             JSR     LAB_269E        ; multiply FAC1 by 10
002ED9  1  68                   PLA                     ; restore character
002EDA  1  29 0F                AND     #$0F            ; convert to binary
002EDC  1  20 E2 2E             JSR     LAB_2912        ; evaluate new ASCII digit
002EDF  1  4C 6C 2E             JMP     LAB_289E        ; go do next character
002EE2  1               
002EE2  1               ; evaluate new ASCII digit
002EE2  1               
002EE2  1               LAB_2912
002EE2  1  48                   PHA                     ; save digit
002EE3  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
002EE6  1  68                   PLA                     ; restore digit
002EE7  1  20 2C 2D             JSR     LAB_27DB        ; save A as integer byte
002EEA  1  A5 B7                LDA     FAC2_s          ; get FAC2 sign (b7)
002EEC  1  45 B0                EOR     FAC1_s          ; toggle with FAC1 sign (b7)
002EEE  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
002EF0  1  A6 AC                LDX     FAC1_e          ; get FAC1 exponent
002EF2  1  4C FD 28             JMP     LAB_ADD         ; add FAC2 to FAC1 and return
002EF5  1               
002EF5  1               ; evaluate next character of exponential part of number
002EF5  1               
002EF5  1               LAB_2925
002EF5  1  A5 A9                LDA     expcnt          ; get exponent count byte
002EF7  1  C9 0A                CMP     #$0A            ; compare with 10 decimal
002EF9  1  90 09                BCC     LAB_2934        ; branch if less
002EFB  1               
002EFB  1  A9 64                LDA     #$64            ; make all -ve exponents = -100 decimal (causes underflow)
002EFD  1  24 AB                BIT     expneg          ; test exponent -ve flag
002EFF  1  30 25                BMI     LAB_2942        ; branch if -ve
002F01  1               
002F01  1  4C 05 2A             JMP     LAB_2564        ; else do overflow error
002F04  1               
002F04  1               LAB_2934
002F04  1  0A                   ASL     A               ; * 2
002F05  1  0A                   ASL     A               ; * 4
002F06  1  65 A9                ADC     expcnt          ; * 5
002F08  1  0A                   ASL     A               ; * 10
002F09  1  A0 00                LDY     #$00            ; set index
002F0B  1  8B 48 DA A2          ADCINDIRECTY Bpntrl     ; add character (will be $30 too much!)
002F0F  1  01 B5 C3 C9  
002F13  1  00 D0 04 A2  
002F24  1  E9 2F                SBC     #'0'-1          ; convert character to binary
002F26  1               LAB_2942
002F26  1  85 A9                STA     expcnt          ; save exponent count byte
002F28  1  4C 94 2E             JMP     LAB_28C4        ; go get next character
002F2B  1               
002F2B  1               ; print " in line [LINE #]"
002F2B  1               
002F2B  1               LAB_2953
002F2B  1  A9 20                LDA     #<LAB_LMSG      ; point to " in line " message low byte
002F2D  1  A0 3D                LDY     #>LAB_LMSG      ; point to " in line " message high byte
002F2F  1  20 34 15             JSR     LAB_18C3        ; print null terminated string from memory
002F32  1               
002F32  1               ; print Basic line #
002F32  1  A5 88                LDA     Clineh          ; get current line high byte
002F34  1  A6 87                LDX     Clinel          ; get current line low byte
002F36  1               
002F36  1               ; print XA as unsigned integer
002F36  1               
002F36  1               LAB_295E
002F36  1  85 AD                STA     FAC1_1          ; save low byte as FAC1 mantissa1
002F38  1  86 AE                STX     FAC1_2          ; save high byte as FAC1 mantissa2
002F3A  1  A2 90                LDX     #$90            ; set exponent to 16d bits
002F3C  1  38                   SEC                     ; set integer is +ve flag
002F3D  1  20 39 2D             JSR     LAB_STFA        ; set exp=X, clearFAC1 mantissa3 and normalise
002F40  1  A0 00                LDY     #$00            ; clear index
002F42  1  98                   TYA                     ; clear A
002F43  1  20 58 2F             JSR     LAB_297B        ; convert FAC1 to string, skip sign character save
002F46  1  4C 34 15             JMP     LAB_18C3        ; print null terminated string from memory and return
002F49  1               
002F49  1               ; convert FAC1 to ASCII string result in (AY)
002F49  1               ; not any more, moved scratchpad to page 0
002F49  1               
002F49  1               LAB_296E
002F49  1  A0 01                LDY     #$01            ; set index = 1
002F4B  1  A9 20                LDA     #$20            ; character = " " (assume +ve)
002F4D  1  24 B0                BIT     FAC1_s          ; test FAC1 sign (b7)
002F4F  1  10 02                BPL     LAB_2978        ; branch if +ve
002F51  1               
002F51  1  A9 2D                LDA     #$2D            ; else character = "-"
002F53  1               LAB_2978
002F53  1                       .IFDEF  DUODYNE
002F53  1  DA                   PHX
002F54  1  BB                   TYX
002F55  1  95 EF                STA     Decss,X         ; save leading character (" " or "-")
002F57  1  FA                   PLX
002F58  1                       .ELSE
002F58  1                       STA     Decss,Y         ; save leading character (" " or "-")
002F58  1                       .ENDIF
002F58  1               LAB_297B
002F58  1  85 B0                STA     FAC1_s          ; clear FAC1 sign (b7)
002F5A  1  84 BA                STY     Sendl           ; save index
002F5C  1  C8                   INY                     ; increment index
002F5D  1  A6 AC                LDX     FAC1_e          ; get FAC1 exponent
002F5F  1  D0 05                BNE     LAB_2989        ; branch if FAC1<>0
002F61  1               
002F61  1               ; exponent was $00 so FAC1 is 0
002F61  1  A9 30                LDA     #'0'            ; set character = "0"
002F63  1  4C 78 30             JMP     LAB_2A89        ; save last character, [EOT] and exit
002F66  1               
002F66  1               ; FAC1 is some non zero value
002F66  1               LAB_2989
002F66  1  A9 00                LDA     #$00            ; clear (number exponent count)
002F68  1  E0 81                CPX     #$81            ; compare FAC1 exponent with $81 (>1.00000)
002F6A  1               
002F6A  1  B0 09                BCS     LAB_299A        ; branch if FAC1=>1
002F6C  1               
002F6C  1               ; FAC1<1
002F6C  1  A9 A7                LDA     #<LAB_294F      ; set pointer low byte to 1,000,000
002F6E  1  A0 36                LDY     #>LAB_294F      ; set pointer high byte to 1,000,000
002F70  1  20 7B 2A             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
002F73  1  A9 FA                LDA     #$FA            ; set number exponent count (-6)
002F75  1               LAB_299A
002F75  1  85 A8                STA     numexp          ; save number exponent count
002F77  1               LAB_299C
002F77  1  A9 A3                LDA     #<LAB_294B      ; set pointer low byte to 999999.4375 (max before sci note)
002F79  1  A0 36                LDY     #>LAB_294B      ; set pointer high byte to 999999.4375
002F7B  1  20 49 2D             JSR     LAB_27F8        ; compare FAC1 with (AY)
002F7E  1  F0 1E                BEQ     LAB_29C3        ; exit if FAC1 = (AY)
002F80  1               
002F80  1  10 12                BPL     LAB_29B9        ; go do /10 if FAC1 > (AY)
002F82  1               
002F82  1               ; FAC1 < (AY)
002F82  1               LAB_29A7
002F82  1  A9 9F                LDA     #<LAB_2947      ; set pointer low byte to 99999.9375
002F84  1  A0 36                LDY     #>LAB_2947      ; set pointer high byte to 99999.9375
002F86  1  20 49 2D             JSR     LAB_27F8        ; compare FAC1 with (AY)
002F89  1  F0 02                BEQ     LAB_29B2        ; branch if FAC1 = (AY) (allow decimal places)
002F8B  1               
002F8B  1  10 0E                BPL     LAB_29C0        ; branch if FAC1 > (AY) (no decimal places)
002F8D  1               
002F8D  1               ; FAC1 <= (AY)
002F8D  1               LAB_29B2
002F8D  1  20 69 2B             JSR     LAB_269E        ; multiply by 10
002F90  1  C6 A8                DEC     numexp          ; decrement number exponent count
002F92  1  D0 EE                BNE     LAB_29A7        ; go test again (branch always)
002F94  1               
002F94  1               LAB_29B9
002F94  1  20 82 2B             JSR     LAB_26B9        ; divide by 10
002F97  1  E6 A8                INC     numexp          ; increment number exponent count
002F99  1  D0 DC                BNE     LAB_299C        ; go test again (branch always)
002F9B  1               
002F9B  1               ; now we have just the digits to do
002F9B  1               
002F9B  1               LAB_29C0
002F9B  1  20 F6 28             JSR     LAB_244E        ; add 0.5 to FAC1 (round FAC1)
002F9E  1               LAB_29C3
002F9E  1  20 E6 2D             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
002FA1  1  A2 01                LDX     #$01            ; set default digits before dp = 1
002FA3  1  A5 A8                LDA     numexp          ; get number exponent count
002FA5  1  18                   CLC                     ; clear carry for add
002FA6  1  69 07                ADC     #$07            ; up to 6 digits before point
002FA8  1  30 09                BMI     LAB_29D8        ; if -ve then 1 digit before dp
002FAA  1               
002FAA  1  C9 08                CMP     #$08            ; A>=8 if n>=1E6
002FAC  1  B0 06                BCS     LAB_29D9        ; branch if >= $08
002FAE  1               
002FAE  1               ; carry is clear
002FAE  1  69 FF                ADC     #$FF            ; take 1 from digit count
002FB0  1  AA                   TAX                     ; copy to A
002FB1  1  A9 02                LDA     #$02            ;.set exponent adjust
002FB3  1               LAB_29D8
002FB3  1  38                   SEC                     ; set carry for subtract
002FB4  1               LAB_29D9
002FB4  1  E9 02                SBC     #$02            ; -2
002FB6  1  85 A9                STA     expcnt          ;.save exponent adjust
002FB8  1  86 A8                STX     numexp          ; save digits before dp count
002FBA  1  8A                   TXA                     ; copy to A
002FBB  1  F0 02                BEQ     LAB_29E4        ; branch if no digits before dp
002FBD  1               
002FBD  1  10 17                BPL     LAB_29F7        ; branch if digits before dp
002FBF  1               
002FBF  1               LAB_29E4
002FBF  1  A4 BA                LDY     Sendl           ; get output string index
002FC1  1  A9 2E                LDA     #$2E            ; character "."
002FC3  1  C8                   INY                     ; increment index
002FC4  1                       .IFDEF  DUODYNE
002FC4  1  DA                   PHX
002FC5  1  BB                   TYX
002FC6  1  95 EF                STA     Decss,X         ; save to output string
002FC8  1  FA                   PLX
002FC9  1                       .ELSE
002FC9  1                       STA     Decss,Y         ; save to output string
002FC9  1                       .ENDIF
002FC9  1  8A                   TXA                     ;.
002FCA  1  F0 08                BEQ     LAB_29F5        ;.
002FCC  1               
002FCC  1  A9 30                LDA     #'0'            ; character "0"
002FCE  1  C8                   INY                     ; increment index
002FCF  1                       .IFDEF  DUODYNE
002FCF  1  DA                   PHX
002FD0  1  BB                   TYX
002FD1  1  95 EF                STA     Decss,X         ; save to output string
002FD3  1  FA                   PLX
002FD4  1                       .ELSE
002FD4  1                       STA     Decss,Y         ; save to output string
002FD4  1                       .ENDIF
002FD4  1               
002FD4  1               LAB_29F5
002FD4  1  84 BA                STY     Sendl           ; save output string index
002FD6  1               LAB_29F7
002FD6  1  A0 00                LDY     #$00            ; clear index (point to 100,000)
002FD8  1  A2 80                LDX     #$80            ;
002FDA  1               LAB_29FB
002FDA  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
002FDC  1  18                   CLC                     ; clear carry for add
002FDD  1  79 1D 37             ADC     LAB_2A9C,Y      ; add -ve LSB
002FE0  1  85 AF                STA     FAC1_3          ; save FAC1 mantissa3
002FE2  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
002FE4  1  79 1C 37             ADC     LAB_2A9B,Y      ; add -ve NMSB
002FE7  1  85 AE                STA     FAC1_2          ; save FAC1 mantissa2
002FE9  1  A5 AD                LDA     FAC1_1          ; get FAC1 mantissa1
002FEB  1  79 1B 37             ADC     LAB_2A9A,Y      ; add -ve MSB
002FEE  1  85 AD                STA     FAC1_1          ; save FAC1 mantissa1
002FF0  1  E8                   INX                     ;
002FF1  1  B0 04                BCS     LAB_2A18        ;
002FF3  1               
002FF3  1  10 E5                BPL     LAB_29FB        ; not -ve so try again
002FF5  1               
002FF5  1  30 02                BMI     LAB_2A1A        ;
002FF7  1               
002FF7  1               LAB_2A18
002FF7  1  30 E1                BMI     LAB_29FB        ;
002FF9  1               
002FF9  1               LAB_2A1A
002FF9  1  8A                   TXA                     ;
002FFA  1  90 04                BCC     LAB_2A21        ;
002FFC  1               
002FFC  1  49 FF                EOR     #$FF            ;
002FFE  1  69 0A                ADC     #$0A            ;
003000  1               LAB_2A21
003000  1  69 2F                ADC     #'0'-1          ; add "0"-1 to result
003002  1  C8                   INY                     ; increment index ..
003003  1  C8                   INY                     ; .. to next less ..
003004  1  C8                   INY                     ; .. power of ten
003005  1  84 95                STY     Cvaral          ; save as current var address low byte
003007  1  A4 BA                LDY     Sendl           ; get output string index
003009  1  C8                   INY                     ; increment output string index
00300A  1  AA                   TAX                     ; copy character to X
00300B  1  29 7F                AND     #$7F            ; mask out top bit
00300D  1                       .IFDEF  DUODYNE
00300D  1  DA                   PHX
00300E  1  BB                   TYX
00300F  1  95 EF                STA     Decss,X         ; save to output string
003011  1  FA                   PLX
003012  1                       .ELSE
003012  1                       STA     Decss,Y         ; save to output string
003012  1                       .ENDIF
003012  1  C6 A8                DEC     numexp          ; decrement # of characters before the dp
003014  1  D0 08                BNE     LAB_2A3B        ; branch if still characters to do
003016  1               
003016  1               ; else output the point
003016  1  A9 2E                LDA     #$2E            ; character "."
003018  1  C8                   INY                     ; increment output string index
003019  1                       .IFDEF  DUODYNE
003019  1  DA                   PHX
00301A  1  BB                   TYX
00301B  1  95 EF                STA     Decss,X         ; save to output string
00301D  1  FA                   PLX
00301E  1                       .ELSE
00301E  1                       STA     Decss,Y         ; save to output string
00301E  1                       .ENDIF
00301E  1               LAB_2A3B
00301E  1  84 BA                STY     Sendl           ; save output string index
003020  1  A4 95                LDY     Cvaral          ; get current var address low byte
003022  1  8A                   TXA                     ; get character back
003023  1  49 FF                EOR     #$FF            ;
003025  1  29 80                AND     #$80            ;
003027  1  AA                   TAX                     ;
003028  1  C0 12                CPY     #$12            ; compare index with max
00302A  1  D0 AE                BNE     LAB_29FB        ; loop if not max
00302C  1               
00302C  1               ; now remove trailing zeroes
00302C  1  A4 BA                LDY     Sendl           ; get output string index
00302E  1               LAB_2A4B
00302E  1                       .IFDEF DUODYNE
00302E  1  DA                   PHX
00302F  1  BB                   TYX
003030  1  B5 EF                LDA     Decss,X         ; save to output string
003032  1  FA                   PLX
003033  1                       .ELSE
003033  1                       LDA     Decss,Y         ; GET FROM output string
003033  1                       .ENDIF
003033  1  88                   DEY                     ; decrement output string index
003034  1  C9 30                CMP     #'0'            ; compare with "0"
003036  1  F0 F6                BEQ     LAB_2A4B        ; loop until non "0" character found
003038  1               
003038  1  C9 2E                CMP     #'.'            ; compare with "."
00303A  1  F0 01                BEQ     LAB_2A58        ; branch if was dp
00303C  1               
00303C  1               ; restore last character
00303C  1  C8                   INY                     ; increment output string index
00303D  1               LAB_2A58
00303D  1  A9 2B                LDA     #$2B            ; character "+"
00303F  1  A6 A9                LDX     expcnt          ; get exponent count
003041  1  F0 3A                BEQ     LAB_2A8C        ; if zero go set null terminator and exit
003043  1               
003043  1               ; exponent isn't zero so write exponent
003043  1  10 08                BPL     LAB_2A68        ; branch if exponent count +ve
003045  1               
003045  1  A9 00                LDA     #$00            ; clear A
003047  1  38                   SEC                     ; set carry for subtract
003048  1  E5 A9                SBC     expcnt          ; subtract exponent count adjust (convert -ve to +ve)
00304A  1  AA                   TAX                     ; copy exponent count to X
00304B  1  A9 2D                LDA     #'-'            ; character "-"
00304D  1               LAB_2A68
00304D  1               
00304D  1                       .IFDEF DUODYNE
00304D  1  DA                   PHX
00304E  1  BB                   TYX
00304F  1  95 F1                STA     Decss+2,X       ; save to output string
003051  1  FA                   PLX
003052  1                       .ELSE
003052  1                       STA     Decss+2,Y       ; save to output string
003052  1                       .ENDIF
003052  1  A9 45                LDA     #$45            ; character "E"
003054  1                       .IFDEF  DUODYNE
003054  1  DA                   PHX
003055  1  BB                   TYX
003056  1  95 F0                STA     Decss+1,X       ; save EXPONENT SIGN to output string
003058  1  FA                   PLX
003059  1                       .ELSE
003059  1                       STA     Decss+1,Y       ; save EXPONENT SIGN to output string
003059  1                       .ENDIF
003059  1  8A                   TXA                     ; get exponent count back
00305A  1  A2 2F                LDX     #'0'-1          ; one less than "0" character
00305C  1  38                   SEC                     ; set carry for subtract
00305D  1               LAB_2A74
00305D  1  E8                   INX                     ; increment 10's character
00305E  1  E9 0A                SBC     #$0A            ;.subtract 10 from exponent count
003060  1  B0 FB                BCS     LAB_2A74        ; loop while still >= 0
003062  1               
003062  1  69 3A                ADC     #':'            ; add character ":" ($30+$0A, result is 10 less that value)
003064  1                       .IFDEF  DUODYNE
003064  1  DA                   PHX
003065  1  BB                   TYX
003066  1  95 F3                STA     Decss+4,X       ; save to output string
003068  1  FA                   PLX
003069  1                       .ELSE
003069  1                       STA     Decss+4,Y       ; save to output string
003069  1                       .ENDIF
003069  1  8A                   TXA                     ; copy 10's character
00306A  1                       .IFDEF  DUODYNE
00306A  1  DA                   PHX
00306B  1  BB                   TYX
00306C  1  95 F2                STA     Decss+3,X       ; save to output string
00306E  1  FA                   PLX
00306F  1                       .ELSE
00306F  1                       STA     Decss+3,Y       ; save to output string
00306F  1                       .ENDIF
00306F  1  A9 00                LDA     #$00            ; set null terminator
003071  1                       .IFDEF  DUODYNE
003071  1  DA                   PHX
003072  1  BB                   TYX
003073  1  95 F4                STA     Decss+5,X       ; save to output string
003075  1  FA                   PLX
003076  1                       .ELSE
003076  1                       STA     Decss+5,Y       ; save to output string
003076  1                       .ENDIF
003076  1  F0 0C                BEQ     LAB_2A91        ; go set string pointer (AY) and exit (branch always)
003078  1               
003078  1               ; save last character, [EOT] and exit
003078  1               LAB_2A89
003078  1                       .IFDEF  DUODYNE
003078  1  DA                   PHX
003079  1  BB                   TYX
00307A  1  95 EF                STA     Decss,X         ; save to output string
00307C  1  FA                   PLX
00307D  1                       .ELSE
00307D  1                       STA     Decss,Y         ; save to output string
00307D  1                       .ENDIF
00307D  1               
00307D  1               ; set null terminator and exit
00307D  1               LAB_2A8C
00307D  1  A9 00                LDA     #$00            ; set null terminator
00307F  1                       .IFDEF  DUODYNE
00307F  1  DA                   PHX
003080  1  BB                   TYX
003081  1  95 F0                STA     Decss+1,X       ; save to output string
003083  1  FA                   PLX
003084  1                       .ELSE
003084  1                       STA     Decss+1,Y       ; save to output string
003084  1                       .ENDIF
003084  1               
003084  1               ; set string pointer (AY) and exit
003084  1               LAB_2A91
003084  1  A9 F0                LDA     #<Decssp1       ; set result string low pointer
003086  1  A0 00                LDY     #>Decssp1       ; set result string high pointer
003088  1  60                   RTS
003089  1               
003089  1               ; perform power function
003089  1               
003089  1               LAB_POWER
003089  1  F0 42                BEQ     LAB_EXP         ; go do  EXP()
00308B  1               
00308B  1  A5 B3                LDA     FAC2_e          ; get FAC2 exponent
00308D  1  D0 03                BNE     LAB_2ABF        ; branch if FAC2<>0
00308F  1               
00308F  1  4C 94 29             JMP     LAB_24F3        ; clear FAC1 exponent and sign and return
003092  1               
003092  1               LAB_2ABF
003092  1  A2 9C                LDX     #<func_l        ; set destination pointer low byte
003094  1  A0 00                LDY     #>func_l        ; set destination pointer high byte
003096  1  20 89 2C             JSR     LAB_2778        ; pack FAC1 into (XY)
003099  1  A5 B7                LDA     FAC2_s          ; get FAC2 sign (b7)
00309B  1  10 0F                BPL     LAB_2AD9        ; branch if FAC2>0
00309D  1               
00309D  1               ; else FAC2 is -ve and can only be raised to an
00309D  1               ; integer power which gives an x +j0 result
00309D  1  20 17 2E             JSR     LAB_INT         ; perform INT
0030A0  1  A9 9C                LDA     #<func_l        ; set source pointer low byte
0030A2  1  A0 00                LDY     #>func_l        ; set source pointer high byte
0030A4  1  20 49 2D             JSR     LAB_27F8        ; compare FAC1 with (AY)
0030A7  1  D0 03                BNE     LAB_2AD9        ; branch if FAC1 <> (AY) to allow Function Call error
0030A9  1               ; this will leave FAC1 -ve and cause a Function Call
0030A9  1               ; error when LOG() is called
0030A9  1               
0030A9  1  98                   TYA                     ; clear sign b7
0030AA  1  A4 5B                LDY     Temp3           ; save mantissa 3 from INT() function as sign in Y
0030AC  1               ; for possible later negation, b0
0030AC  1               LAB_2AD9
0030AC  1  20 01 29             JSR     LAB_279D        ; save FAC1 sign and copy ABS(FAC2) to FAC1
0030AF  1  98                   TYA                     ; copy sign back ..
0030B0  1  48                   PHA                     ; .. and save it
0030B1  1  20 3D 2A             JSR     LAB_LOG         ; do LOG(n)
0030B4  1  A9 9C                LDA     #<garb_l        ; set pointer low byte
0030B6  1  A0 00                LDY     #>garb_l        ; set pointer high byte
0030B8  1  20 7B 2A             JSR     LAB_25FB        ; do convert AY, FCA1*(AY) (square the value)
0030BB  1  20 CD 30             JSR     LAB_EXP         ; go do EXP(n)
0030BE  1  68                   PLA                     ; pull sign from stack
0030BF  1  4A                   LSR     A               ; b0 is to be tested, shift to Cb
0030C0  1  90 0A                BCC     LAB_2AF9        ; if no bit then exit
0030C2  1               
0030C2  1               ; Perform negation
0030C2  1               ; do - FAC1
0030C2  1               
0030C2  1               LAB_GTHAN
0030C2  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0030C4  1  F0 06                BEQ     LAB_2AF9        ; exit if FAC1_e = $00
0030C6  1               
0030C6  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
0030C8  1  49 FF                EOR     #$FF            ; complement it
0030CA  1  85 B0                STA     FAC1_s          ; save FAC1 sign (b7)
0030CC  1               LAB_2AF9
0030CC  1  60                   RTS
0030CD  1               
0030CD  1               ; perform EXP()	(x^e)
0030CD  1               
0030CD  1               LAB_EXP
0030CD  1  A9 AB                LDA     #<LAB_2AFA      ; set 1.443 pointer low byte
0030CF  1  A0 36                LDY     #>LAB_2AFA      ; set 1.443 pointer high byte
0030D1  1  20 7B 2A             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
0030D4  1  A5 B9                LDA     FAC1_r          ; get FAC1 rounding byte
0030D6  1  69 50                ADC     #$50            ; +$50/$100
0030D8  1  90 03                BCC     LAB_2B2B        ; skip rounding if no carry
0030DA  1               
0030DA  1  20 13 2D             JSR     LAB_27C2        ; round FAC1 (no check)
0030DD  1               LAB_2B2B
0030DD  1  85 A3                STA     FAC2_r          ; save FAC2 rounding byte
0030DF  1  20 FF 2C             JSR     LAB_27AE        ; copy FAC1 to FAC2
0030E2  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0030E4  1  C9 88                CMP     #$88            ; compare with EXP limit (256d)
0030E6  1  90 03                BCC     LAB_2B39        ; branch if less
0030E8  1               
0030E8  1               LAB_2B36
0030E8  1  20 60 2B             JSR     LAB_2690        ; handle overflow and underflow
0030EB  1               LAB_2B39
0030EB  1  20 17 2E             JSR     LAB_INT         ; perform INT
0030EE  1  A5 5B                LDA     Temp3           ; get mantissa 3 from INT() function
0030F0  1  18                   CLC                     ; clear carry for add
0030F1  1  69 81                ADC     #$81            ; normalise +1
0030F3  1  F0 F3                BEQ     LAB_2B36        ; if $00 go handle overflow
0030F5  1               
0030F5  1  38                   SEC                     ; set carry for subtract
0030F6  1  E9 01                SBC     #$01            ; now correct for exponent
0030F8  1  48                   PHA                     ; save FAC2 exponent
0030F9  1               
0030F9  1               ; swap FAC1 and FAC2
0030F9  1  A2 04                LDX     #$04            ; 4 bytes to do
0030FB  1               LAB_2B49
0030FB  1  B5 B3                LDA     FAC2_e,X        ; get FAC2,X
0030FD  1  B4 AC                LDY     FAC1_e,X        ; get FAC1,X
0030FF  1  95 AC                STA     FAC1_e,X        ; save FAC1,X
003101  1  94 B3                STY     FAC2_e,X        ; save FAC2,X
003103  1  CA                   DEX                     ; decrement count/index
003104  1  10 F5                BPL     LAB_2B49        ; loop if not all done
003106  1               
003106  1  A5 A3                LDA     FAC2_r          ; get FAC2 rounding byte
003108  1  85 B9                STA     FAC1_r          ; save as FAC1 rounding byte
00310A  1  20 E2 28             JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
00310D  1  20 C2 30             JSR     LAB_GTHAN       ; do - FAC1
003110  1  A9 AF                LDA     #<LAB_2AFE      ; set counter pointer low byte
003112  1  A0 36                LDY     #>LAB_2AFE      ; set counter pointer high byte
003114  1  20 35 31             JSR     LAB_2B84        ; go do series evaluation
003117  1  A9 00                LDA     #$00            ; clear A
003119  1  85 B8                STA     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
00311B  1  68                   PLA                     ;.get saved FAC2 exponent
00311C  1  4C 45 2B             JMP     LAB_2675        ; test and adjust accumulators and return
00311F  1               
00311F  1               ; ^2 then series evaluation
00311F  1               
00311F  1               LAB_2B6E
00311F  1  85 BA                STA     Cptrl           ; save count pointer low byte
003121  1  84 BB                STY     Cptrh           ; save count pointer high byte
003123  1  20 7F 2C             JSR     LAB_276E        ; pack FAC1 into Adatal
003126  1  A9 A4                LDA     #<Adatal        ; set pointer low byte (Y already $00)
003128  1  20 7B 2A             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00312B  1  20 39 31             JSR     LAB_2B88        ; go do series evaluation
00312E  1  A9 A4                LDA     #<Adatal        ; pointer to original # low byte
003130  1  A0 00                LDY     #>Adatal        ; pointer to original # high byte
003132  1  4C 7B 2A             JMP     LAB_25FB        ; do convert AY, FCA1*(AY) and return
003135  1               
003135  1               ; series evaluation
003135  1               
003135  1               LAB_2B84
003135  1  85 BA                STA     Cptrl           ; save count pointer low byte
003137  1  84 BB                STY     Cptrh           ; save count pointer high byte
003139  1               LAB_2B88
003139  1  A2 A8                LDX     #<numexp        ; set pointer low byte
00313B  1  20 81 2C             JSR     LAB_2770        ; set pointer high byte and pack FAC1 into numexp
00313E  1  8B DA A2 01          LDAINDIRECTY Cptrl      ; get constants count
003142  1  B5 BA C9 00  
003146  1  D0 04 A2 00  
003154  1  85 B1                STA     numcon          ; save constants count
003156  1  A4 BA                LDY     Cptrl           ; get count pointer low byte
003158  1  C8                   INY                     ; increment it (now constants pointer)
003159  1  98                   TYA                     ; copy it
00315A  1  D0 02                BNE     LAB_2B97        ; skip next if no overflow
00315C  1               
00315C  1  E6 BB                INC     Cptrh           ; else increment high byte
00315E  1               LAB_2B97
00315E  1  85 BA                STA     Cptrl           ; save low byte
003160  1  A4 BB                LDY     Cptrh           ; get high byte
003162  1               LAB_2B9B
003162  1  20 7B 2A             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
003165  1  A5 BA                LDA     Cptrl           ; get constants pointer low byte
003167  1  A4 BB                LDY     Cptrh           ; get constants pointer high byte
003169  1  18                   CLC                     ; clear carry for add
00316A  1  69 04                ADC     #$04            ; +4 to  low pointer (4 bytes per constant)
00316C  1  90 01                BCC     LAB_2BA8        ; skip next if no overflow
00316E  1               
00316E  1  C8                   INY                     ; increment high byte
00316F  1               LAB_2BA8
00316F  1  85 BA                STA     Cptrl           ; save pointer low byte
003171  1  84 BB                STY     Cptrh           ; save pointer high byte
003173  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1
003176  1  A9 A8                LDA     #<numexp        ; set pointer low byte to partial @ numexp
003178  1  A0 00                LDY     #>numexp        ; set pointer high byte to partial @ numexp
00317A  1  C6 B1                DEC     numcon          ; decrement constants count
00317C  1  D0 E4                BNE     LAB_2B9B        ; loop until all done
00317E  1               
00317E  1  60                   RTS
00317F  1               
00317F  1               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00317F  1               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00317F  1               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00317F  1               
00317F  1               ; Entropy = 7.997442 bits per byte
00317F  1               ; Optimum compression would reduce these 65536 bytes by 0 percent
00317F  1               
00317F  1               ; Chi square distribution for 65536 samples is 232.01, and
00317F  1               ; randomly would exceed this value 75.00 percent of the time
00317F  1               
00317F  1               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00317F  1               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00317F  1               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00317F  1               
00317F  1               LAB_RND:
00317F  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
003181  1  F0 07                BEQ     NextPRN         ; do next random # if zero
003183  1               
003183  1               ; else get seed into random number store
003183  1  A2 E1                LDX     #Rbyte4         ; set PRNG pointer low byte
003185  1  A0 00                LDY     #$00            ; set PRNG pointer high byte
003187  1  20 89 2C             JSR     LAB_2778        ; pack FAC1 into (XY)
00318A  1               NextPRN:
00318A  1  A2 AF                LDX     #$AF            ; set EOR byte
00318C  1  A0 13                LDY     #$13            ; do this nineteen times
00318E  1               LoopPRN:
00318E  1  06 E2                ASL     Rbyte1          ; shift PRNG most significant byte
003190  1  26 E3                ROL     Rbyte2          ; shift PRNG middle byte
003192  1  26 E4                ROL     Rbyte3          ; shift PRNG least significant byte
003194  1  26 E1                ROL     Rbyte4          ; shift PRNG extra byte
003196  1  90 05                BCC     Ninc1           ; branch if bit 32 clear
003198  1               
003198  1  8A                   TXA                     ; set EOR byte
003199  1  45 E2                EOR     Rbyte1          ; EOR PRNG extra byte
00319B  1  85 E2                STA     Rbyte1          ; save new PRNG extra byte
00319D  1               Ninc1:
00319D  1  88                   DEY                     ; decrement loop count
00319E  1  D0 EE                BNE     LoopPRN         ; loop if not all done
0031A0  1               
0031A0  1  A2 02                LDX     #$02            ; three bytes to copy
0031A2  1               CopyPRNG:
0031A2  1  B5 E2                LDA     Rbyte1,X        ; get PRNG byte
0031A4  1  95 AD                STA     FAC1_1,X        ; save FAC1 byte
0031A6  1  CA                   DEX
0031A7  1  10 F9                BPL     CopyPRNG        ; loop if not complete
0031A9  1               
0031A9  1  A9 80                LDA     #$80            ; set the exponent
0031AB  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
0031AD  1               
0031AD  1  0A                   ASL     A               ; clear A
0031AE  1  85 B0                STA     FAC1_s          ; save FAC1 sign
0031B0  1               
0031B0  1  4C 76 29             JMP     LAB_24D5        ; normalise FAC1 and return
0031B3  1               
0031B3  1               ; perform COS()
0031B3  1               
0031B3  1               LAB_COS:
0031B3  1  A9 CC                LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
0031B5  1  A0 36                LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
0031B7  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1
0031BA  1               
0031BA  1               ; perform SIN()
0031BA  1               
0031BA  1               LAB_SIN:
0031BA  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
0031BD  1  A9 E1                LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
0031BF  1  A0 36                LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
0031C1  1  A6 B7                LDX     FAC2_s          ; get FAC2 sign (b7)
0031C3  1  20 8B 2B             JSR     LAB_26C2        ; divide by (AY) (X=sign)
0031C6  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
0031C9  1  20 17 2E             JSR     LAB_INT         ; perform INT
0031CC  1  A9 00                LDA     #$00            ; clear byte
0031CE  1  85 B8                STA     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
0031D0  1  20 E2 28             JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
0031D3  1  A9 13                LDA     #<LAB_2C80      ; set 0.25 pointer low byte
0031D5  1  A0 37                LDY     #>LAB_2C80      ; set 0.25 pointer high byte
0031D7  1  20 DF 28             JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
0031DA  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
0031DC  1  48                   PHA                     ; save FAC1 sign
0031DD  1  10 0D                BPL     LAB_2C35        ; branch if +ve
0031DF  1               
0031DF  1               ; FAC1 sign was -ve
0031DF  1  20 F6 28             JSR     LAB_244E        ; add 0.5 to FAC1
0031E2  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
0031E4  1  30 09                BMI     LAB_2C38        ; branch if -ve
0031E6  1               
0031E6  1  A5 63                LDA     Cflag           ; get comparison evaluation flag
0031E8  1  49 FF                EOR     #$FF            ; toggle flag
0031EA  1  85 63                STA     Cflag           ; save comparison evaluation flag
0031EC  1               LAB_2C35
0031EC  1  20 C2 30             JSR     LAB_GTHAN       ; do - FAC1
0031EF  1               LAB_2C38:
0031EF  1  A9 13                LDA     #<LAB_2C80      ; set 0.25 pointer low byte
0031F1  1  A0 37                LDY     #>LAB_2C80      ; set 0.25 pointer high byte
0031F3  1  20 FA 28             JSR     LAB_246C        ; add (AY) to FAC1
0031F6  1  68                   PLA                     ; restore FAC1 sign
0031F7  1  10 03                BPL     LAB_2C45        ; branch if was +ve
0031F9  1               
0031F9  1               ; else correct FAC1
0031F9  1  20 C2 30             JSR     LAB_GTHAN       ; do - FAC1
0031FC  1               LAB_2C45:
0031FC  1  A9 D0                LDA     #<LAB_2C84      ; set pointer low byte to counter
0031FE  1  A0 36                LDY     #>LAB_2C84      ; set pointer high byte to counter
003200  1  4C 1F 31             JMP     LAB_2B6E        ; ^2 then series evaluation and return
003203  1               
003203  1               ; perform TAN()
003203  1               
003203  1               LAB_TAN:
003203  1  20 7F 2C             JSR     LAB_276E        ; pack FAC1 into Adatal
003206  1  A9 00                LDA     #$00            ; clear byte
003208  1  85 63                STA     Cflag           ; clear comparison evaluation flag
00320A  1  20 BA 31             JSR     LAB_SIN         ; go do SIN(n)
00320D  1  A2 9C                LDX     #<func_l        ; set sin(n) pointer low byte
00320F  1  A0 00                LDY     #>func_l        ; set sin(n) pointer high byte
003211  1  20 89 2C             JSR     LAB_2778        ; pack FAC1 into (XY)
003214  1  A9 A4                LDA     #<Adatal        ; set n pointer low addr
003216  1  A0 00                LDY     #>Adatal        ; set n pointer high addr
003218  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00321B  1  A9 00                LDA     #$00            ; clear byte
00321D  1  85 B0                STA     FAC1_s          ; clear FAC1 sign (b7)
00321F  1  A5 63                LDA     Cflag           ; get comparison evaluation flag
003221  1  20 2B 32             JSR     LAB_2C74        ; save flag and go do series evaluation
003224  1               
003224  1  A9 9C                LDA     #<func_l        ; set sin(n) pointer low byte
003226  1  A0 00                LDY     #>func_l        ; set sin(n) pointer high byte
003228  1  4C 93 2B             JMP     LAB_26CA        ; convert AY and do (AY)/FAC1
00322B  1               
00322B  1               LAB_2C74:
00322B  1  48                   PHA                     ; save comparison evaluation flag
00322C  1  4C EC 31             JMP     LAB_2C35        ; go do series evaluation
00322F  1               
00322F  1               ; perform USR()
00322F  1               
00322F  1               LAB_USR:
00322F  1  20 0A 00             JSR     Usrjmp          ; call user code
003232  1  4C A2 18             JMP     LAB_1BFB        ; scan for ")", else do syntax error then warm start
003235  1               
003235  1               ; perform ATN()
003235  1               
003235  1               LAB_ATN:
003235  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign (b7)
003237  1  48                   PHA                     ; save sign
003238  1  10 03                BPL     LAB_2CA1        ; branch if +ve
00323A  1               
00323A  1  20 C2 30             JSR     LAB_GTHAN       ; else do - FAC1
00323D  1               LAB_2CA1:
00323D  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
00323F  1  48                   PHA                     ; push exponent
003240  1  C9 81                CMP     #$81            ; compare with 1
003242  1  90 07                BCC     LAB_2CAF        ; branch if FAC1<1
003244  1               
003244  1  A9 06                LDA     #<LAB_259C      ; set 1 pointer low byte
003246  1  A0 37                LDY     #>LAB_259C      ; set 1 pointer high byte
003248  1  20 93 2B             JSR     LAB_26CA        ; convert AY and do (AY)/FAC1
00324B  1               LAB_2CAF:
00324B  1  A9 E5                LDA     #<LAB_2CC9      ; set pointer low byte to counter
00324D  1  A0 36                LDY     #>LAB_2CC9      ; set pointer high byte to counter
00324F  1  20 1F 31             JSR     LAB_2B6E        ; ^2 then series evaluation
003252  1  68                   PLA                     ; restore old FAC1 exponent
003253  1  C9 81                CMP     #$81            ; compare with 1
003255  1  90 07                BCC     LAB_2CC2        ; branch if FAC1<1
003257  1               
003257  1  A9 CC                LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
003259  1  A0 36                LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
00325B  1  20 DF 28             JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
00325E  1               LAB_2CC2:
00325E  1  68                   PLA                     ; restore FAC1 sign
00325F  1  10 16                BPL     LAB_2D04        ; exit if was +ve
003261  1               
003261  1  4C C2 30             JMP     LAB_GTHAN       ; else do - FAC1 and return
003264  1               
003264  1               ; perform BITSET
003264  1               
003264  1               LAB_BITSET:
003264  1  20 A6 27             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
003267  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
003269  1  B0 20                BCS     FCError         ; branch if > 7
00326B  1               
00326B  1  A9 00                LDA     #$00            ; clear A
00326D  1  38                   SEC                     ; set the carry
00326E  1               S_Bits:
00326E  1  2A                   ROL     A               ; shift bit
00326F  1  CA                   DEX                     ; decrement bit number
003270  1  10 FC                BPL     S_Bits          ; loop if still +ve
003272  1               
003272  1  E8                   INX                     ; make X = $00
003273  1  01 11                ORA     (Itempl,X)      ; or with byte via temporary integer (addr)
003275  1  81 11                STA     (Itempl,X)      ; save byte via temporary integer (addr)
003277  1               LAB_2D04:
003277  1  60                   RTS
003278  1               
003278  1               ; perform BITCLR
003278  1               
003278  1               LAB_BITCLR:
003278  1  20 A6 27             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
00327B  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
00327D  1  B0 0C                BCS     FCError         ; branch if > 7
00327F  1               
00327F  1  A9 FF                LDA     #$FF            ; set A
003281  1               S_Bitc:
003281  1  2A                   ROL     A               ; shift bit
003282  1  CA                   DEX                     ; decrement bit number
003283  1  10 FC                BPL     S_Bitc          ; loop if still +ve
003285  1               
003285  1  E8                   INX                     ; make X = $00
003286  1  21 11                AND     (Itempl,X)      ; and with byte via temporary integer (addr)
003288  1  81 11                STA     (Itempl,X)      ; save byte via temporary integer (addr)
00328A  1  60                   RTS
00328B  1               
00328B  1               FCError:
00328B  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start
00328E  1               
00328E  1               ; perform BITTST()
00328E  1               
00328E  1               LAB_BTST:
00328E  1                       .IFDEF  DUODYNE
00328E  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003292  1                       .ELSE
003292  1                       JSR     LAB_IGBY        ; increment and scan memory
003292  1                       .ENDIF
003292  1               
003292  1  20 A6 27             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
003295  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
003297  1  B0 F2                BCS     FCError         ; branch if > 7
003299  1               
003299  1                       .IFDEF  DUODYNE
003299  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00329D  1                       .ELSE
00329D  1                       JSR     LAB_GBYT        ; scan memory
00329D  1                       .ENDIF
00329D  1               
00329D  1  C9 29                CMP     #')'            ; is next character ")"
00329F  1  F0 03                BEQ     TST_OK          ; if ")" go do rest of function
0032A1  1               
0032A1  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
0032A4  1               
0032A4  1               TST_OK:
0032A4  1                       .IFDEF  DUODYNE
0032A4  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0032A8  1                       .ELSE
0032A8  1                       JSR     LAB_IGBY        ; increment and scan memory
0032A8  1                       .ENDIF
0032A8  1               
0032A8  1  A9 00                LDA     #$00            ; clear A
0032AA  1  38                   SEC                     ; set the carry
0032AB  1               T_Bits:
0032AB  1  2A                   ROL     A               ; shift bit
0032AC  1  CA                   DEX                     ; decrement bit number
0032AD  1  10 FC                BPL     T_Bits          ; loop if still +ve
0032AF  1               
0032AF  1  E8                   INX                     ; make X = $00
0032B0  1  21 11                AND     (Itempl,X)      ; AND with byte via temporary integer (addr)
0032B2  1  F0 02                BEQ     LAB_NOTT        ; branch if zero (already correct)
0032B4  1               
0032B4  1  A9 FF                LDA     #$FF            ; set for -1 result
0032B6  1               LAB_NOTT:
0032B6  1  4C 2C 2D             JMP     LAB_27DB        ; go do SGN tail
0032B9  1               
0032B9  1               ; perform BIN$()
0032B9  1               
0032B9  1               LAB_BINS:
0032B9  1  E0 19                CPX     #$19            ; max + 1
0032BB  1  B0 71                BCS     BinFErr         ; exit if too big ( > or = )
0032BD  1               
0032BD  1  86 78                STX     TempB           ; save # of characters ($00 = leading zero remove)
0032BF  1  A9 18                LDA     #$18            ; need A byte long space
0032C1  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long
0032C4  1  A0 17                LDY     #$17            ; set index
0032C6  1  A2 18                LDX     #$18            ; character count
0032C8  1               NextB1:
0032C8  1  46 11                LSR     nums_1          ; shift highest byte
0032CA  1  66 12                ROR     nums_2          ; shift middle byte
0032CC  1  66 13                ROR     nums_3          ; shift lowest byte bit 0 to carry
0032CE  1  8A                   TXA                     ; load with "0"/2
0032CF  1  2A                   ROL     A               ; shift in carry
0032D0  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save to temp string + index
0032D4  1  01 B5 AD C9  
0032D8  1  00 D0 04 A2  
0032E6  1  88                   DEY                     ; decrement index
0032E7  1  10 DF                BPL     NextB1          ; loop if not done
0032E9  1               
0032E9  1  A5 78                LDA     TempB           ; get # of characters
0032EB  1  F0 0A                BEQ     EndBHS          ; branch if truncate
0032ED  1               
0032ED  1  AA                   TAX                     ; copy length to X
0032EE  1  38                   SEC                     ; set carry for add !
0032EF  1  49 FF                EOR     #$FF            ; 1's complement
0032F1  1  69 18                ADC     #$18            ; add 24d
0032F3  1  F0 30                BEQ     GoPr2           ; if zero print whole string
0032F5  1               
0032F5  1  D0 23                BNE     GoPr1           ; else go make output string
0032F7  1               
0032F7  1               ; this is the exit code and is also used by HEX$()
0032F7  1               ; truncate string to remove leading "0"s
0032F7  1               
0032F7  1               EndBHS:
0032F7  1  A8                   TAY                     ; clear index (A=0, X=length here)
0032F8  1               NextB2:
0032F8  1  8B DA A2 01          LDAINDIRECTY str_pl     ; get character from string
0032FC  1  B5 AD C9 00  
003300  1  D0 04 A2 00  
00330E  1  C9 30                CMP     #'0'            ; compare with "0"
003310  1  D0 07                BNE     GoPr            ; if not "0" then go print string from here
003312  1               
003312  1  CA                   DEX                     ; decrement character count
003313  1  F0 03                BEQ     GoPr3           ; if zero then end of string so go print it
003315  1               
003315  1  C8                   INY                     ; else increment index
003316  1  10 E0                BPL     NextB2          ; loop always
003318  1               
003318  1               ; make fixed length output string - ignore overflows!
003318  1               
003318  1               GoPr3:
003318  1  E8                   INX                     ; need at least 1 character
003319  1               GoPr:
003319  1  98                   TYA                     ; copy result
00331A  1               GoPr1:
00331A  1  18                   CLC                     ; clear carry for add
00331B  1  65 AD                ADC     str_pl          ; add low address
00331D  1  85 AD                STA     str_pl          ; save low address
00331F  1  A9 00                LDA     #$00            ; do high byte
003321  1  65 AE                ADC     str_ph          ; add high address
003323  1  85 AE                STA     str_ph          ; save high address
003325  1               GoPr2:
003325  1  86 AC                STX     str_ln          ; X holds string length
003327  1                       .IFDEF  DUODYNE
003327  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00332B  1                       .ELSE
00332B  1                       JSR     LAB_IGBY        ; increment and scan memory
00332B  1                       .ENDIF
00332B  1               
00332B  1  4C 68 21             JMP     LAB_RTST        ; check for space on descriptor stack then put address
00332E  1               ; and length on descriptor stack and update stack pointers
00332E  1               
00332E  1               BinFErr:
00332E  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start
003331  1               
003331  1               ; perform HEX$()
003331  1               
003331  1               LAB_HEXS:
003331  1  E0 07                CPX     #$07            ; max + 1
003333  1  B0 F9                BCS     BinFErr         ; exit if too big ( > or = )
003335  1               
003335  1  86 78                STX     TempB           ; save # of characters
003337  1               
003337  1  A9 06                LDA     #$06            ; need 6 bytes for string
003339  1  20 09 21             JSR     LAB_MSSP        ; make string space A bytes long
00333C  1  A0 05                LDY     #$05            ; set string index
00333E  1               
00333E  1  F8                   SED                     ; need decimal mode for nibble convert
00333F  1  A5 13                LDA     nums_3          ; get lowest byte
003341  1  20 5F 33             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
003344  1  A5 12                LDA     nums_2          ; get middle byte
003346  1  20 5F 33             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
003349  1  A5 11                LDA     nums_1          ; get highest byte
00334B  1  20 5F 33             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
00334E  1  D8                   CLD                     ; back to binary
00334F  1               
00334F  1  A2 06                LDX     #$06            ; character count
003351  1  A5 78                LDA     TempB           ; get # of characters
003353  1  F0 A2                BEQ     EndBHS          ; branch if truncate
003355  1               
003355  1  AA                   TAX                     ; copy length to X
003356  1  38                   SEC                     ; set carry for add !
003357  1  49 FF                EOR     #$FF            ; 1's complement
003359  1  69 06                ADC     #$06            ; add 6d
00335B  1  F0 C8                BEQ     GoPr2           ; if zero print whole string
00335D  1               
00335D  1  D0 BB                BNE     GoPr1           ; else go make output string (branch always)
00335F  1               
00335F  1               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00335F  1               
00335F  1               LAB_A2HX:
00335F  1  AA                   TAX                     ; save byte
003360  1  29 0F                AND     #$0F            ; mask off top bits
003362  1  20 6A 33             JSR     LAB_AL2X        ; convert low nibble to ASCII and output
003365  1  8A                   TXA                     ; get byte back
003366  1  4A                   LSR     A               ; /2	shift high nibble to low nibble
003367  1  4A                   LSR     A               ; /4
003368  1  4A                   LSR     A               ; /8
003369  1  4A                   LSR     A               ; /16
00336A  1               LAB_AL2X:
00336A  1  C9 0A                CMP     #$0A            ; set carry for +1 if >9
00336C  1  69 30                ADC     #'0'            ; add ASCII "0"
00336E  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save to temp string
003372  1  01 B5 AD C9  
003376  1  00 D0 04 A2  
003384  1  88                   DEY                     ; decrement counter
003385  1  60                   RTS
003386  1               
003386  1               LAB_NLTO:
003386  1  85 AC                STA     FAC1_e          ; save FAC1 exponent
003388  1  A9 00                LDA     #$00            ; clear sign compare
00338A  1               LAB_MLTE:
00338A  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00338C  1  8A                   TXA                     ; restore character
00338D  1  20 E2 2E             JSR     LAB_2912        ; evaluate new ASCII digit
003390  1               
003390  1               ; gets here if the first character was "$" for hex
003390  1               ; get hex number
003390  1               
003390  1               LAB_CHEX:
003390  1                       .IFDEF  DUODYNE
003390  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003394  1                       .ELSE
003394  1                       JSR     LAB_IGBY        ; increment and scan memory
003394  1                       .ENDIF
003394  1               
003394  1  90 0A                BCC     LAB_ISHN        ; branch if numeric character
003396  1               
003396  1  09 20                ORA     #$20            ; case convert, allow "A" to "F" and "a" to "f"
003398  1  E9 61                SBC     #'a'            ; subtract "a" (carry set here)
00339A  1  C9 06                CMP     #$06            ; compare normalised with $06 (max+1)
00339C  1  B0 2B                BCS     LAB_EXCH        ; exit if >"f" or <"0"
00339E  1               
00339E  1  69 0A                ADC     #$0A            ; convert to nibble
0033A0  1               LAB_ISHN:
0033A0  1  29 0F                AND     #$0F            ; convert to binary
0033A2  1  AA                   TAX                     ; save nibble
0033A3  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0033A5  1  F0 E3                BEQ     LAB_MLTE        ; skip multiply if zero
0033A7  1               
0033A7  1  69 04                ADC     #$04            ; add four to exponent (*16 - carry clear here)
0033A9  1  90 DB                BCC     LAB_NLTO        ; if no overflow do evaluate digit
0033AB  1               
0033AB  1               LAB_MLTO:
0033AB  1  4C 05 2A             JMP     LAB_2564        ; do overflow error and warm start
0033AE  1               
0033AE  1               LAB_NXCH:
0033AE  1  AA                   TAX                     ; save bit
0033AF  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0033B1  1  F0 06                BEQ     LAB_MLBT        ; skip multiply if zero
0033B3  1               
0033B3  1  E6 AC                INC     FAC1_e          ; increment FAC1 exponent (*2)
0033B5  1  F0 F4                BEQ     LAB_MLTO        ; do overflow error if = $00
0033B7  1               
0033B7  1  A9 00                LDA     #$00            ; clear sign compare
0033B9  1               LAB_MLBT:
0033B9  1  85 B8                STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
0033BB  1  8A                   TXA                     ; restore bit
0033BC  1  20 E2 2E             JSR     LAB_2912        ; evaluate new ASCII digit
0033BF  1               
0033BF  1               ; gets here if the first character was  "%" for binary
0033BF  1               ; get binary number
0033BF  1               
0033BF  1               LAB_CBIN:
0033BF  1                       .IFDEF  DUODYNE
0033BF  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0033C3  1                       .ELSE
0033C3  1                       JSR     LAB_IGBY        ; increment and scan memory
0033C3  1                       .ENDIF
0033C3  1               
0033C3  1  49 30                EOR     #'0'            ; convert "0" to 0 etc.
0033C5  1  C9 02                CMP     #$02            ; compare with max+1
0033C7  1  90 E5                BCC     LAB_NXCH        ; branch exit if < 2
0033C9  1               
0033C9  1               LAB_EXCH:
0033C9  1  4C C7 2E             JMP     LAB_28F6        ; evaluate -ve flag and return
0033CC  1               
0033CC  1               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
0033CC  1               ; now also the code that checks to see if an interrupt has occurred
0033CC  1               
0033CC  1               CTRLC:
0033CC  1  AD 00 06             LDA     ccflag          ; get [CTRL-C] check flag
0033CF  1  D0 18                BNE     LAB_FBA2        ; exit if inhibited
0033D1  1               
0033D1  1  20 58 3D             JSR     V_INPT          ; scan input device
0033D4  1  90 0B                BCC     LAB_FBA0        ; exit if buffer empty
0033D6  1               
0033D6  1  8D 01 06             STA     ccbyte          ; save received byte
0033D9  1  A2 20                LDX     #$20            ; "life" timer for bytes
0033DB  1  8E 02 06             STX     ccnull          ; set countdown
0033DE  1  4C 7C 10             JMP     LAB_1636        ; return to BASIC
0033E1  1               
0033E1  1               LAB_FBA0:
0033E1  1  AE 02 06             LDX     ccnull          ; get countdown byte
0033E4  1  F0 03                BEQ     LAB_FBA2        ; exit if finished
0033E6  1               
0033E6  1  CE 02 06             DEC     ccnull          ; else decrement countdown
0033E9  1               LAB_FBA2:
0033E9  1  A2 E5                LDX     #NmiBase        ; set pointer to NMI values
0033EB  1  20 F4 33             JSR     LAB_CKIN        ; go check interrupt
0033EE  1  A2 E8                LDX     #IrqBase        ; set pointer to IRQ values
0033F0  1  20 F4 33             JSR     LAB_CKIN        ; go check interrupt
0033F3  1               LAB_CRTS:
0033F3  1  60                   RTS
0033F4  1               
0033F4  1               ; check whichever interrupt is indexed by X
0033F4  1               
0033F4  1               LAB_CKIN:
0033F4  1  B5 00                LDA     PLUS_0,X        ; get interrupt flag byte
0033F6  1  10 FB                BPL     LAB_CRTS        ; branch if interrupt not enabled
0033F8  1               
0033F8  1               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
0033F8  1               ; automatically enable the interrupt when we exit
0033F8  1               
0033F8  1  0A                   ASL     A               ; move happened bit to setup bit
0033F9  1  29 40                AND     #$40            ; mask happened bits
0033FB  1  F0 F6                BEQ     LAB_CRTS        ; if no interrupt then exit
0033FD  1               
0033FD  1  95 00                STA     PLUS_0,X        ; save interrupt flag byte
0033FF  1               
0033FF  1  8A                   TXA                     ; copy index ..
003400  1  A8                   TAY                     ; .. to Y
003401  1               
003401  1  68                   PLA                     ; dump return address low byte, call from CTRL-C
003402  1  68                   PLA                     ; dump return address high byte
003403  1               
003403  1  A9 05                LDA     #$05            ; need 5 bytes for GOSUB
003405  1  20 AE 09             JSR     LAB_1212        ; check room on stack for A bytes
003408  1  A5 C4                LDA     Bpntrh          ; get BASIC execute pointer high byte
00340A  1  48                   PHA                     ; push on stack
00340B  1  A5 C3                LDA     Bpntrl          ; get BASIC execute pointer low byte
00340D  1  48                   PHA                     ; push on stack
00340E  1  A5 88                LDA     Clineh          ; get current line high byte
003410  1  48                   PHA                     ; push on stack
003411  1  A5 87                LDA     Clinel          ; get current line low byte
003413  1  48                   PHA                     ; push on stack
003414  1  A9 8D                LDA     #TK_GOSUB       ; token for GOSUB
003416  1  48                   PHA                     ; push on stack
003417  1                       .IFDEF  DUODYNE
003417  1  DA                   PHX
003418  1  BB                   TYX
003419  1  B5 01                LDA     PLUS_1,X        ; get interrupt code pointer low byte
00341B  1  FA                   PLX
00341C  1                       .ELSE
00341C  1                       LDA     PLUS_1,Y        ; get interrupt code pointer low byte
00341C  1                       .ENDIF
00341C  1  85 C3                STA     Bpntrl          ; save as BASIC execute pointer low byte
00341E  1                       .IFDEF  DUODYNE
00341E  1  DA                   PHX
00341F  1  BB                   TYX
003420  1  B5 02                LDA     PLUS_2,X        ; get interrupt code pointer low byte
003422  1  FA                   PLX
003423  1                       .ELSE
003423  1                       LDA     PLUS_2,Y        ; get interrupt code pointer low byte
003423  1                       .ENDIF
003423  1  85 C4                STA     Bpntrh          ; save as BASIC execute pointer high byte
003425  1               
003425  1  4C 16 10             JMP     LAB_15C2        ; go do interpreter inner loop
003428  1               ; can't RTS, we used the stack! the RTS from the ctrl-c
003428  1               ; check will be taken when the RETIRQ/RETNMI/RETURN is
003428  1               ; executed at the end of the subroutine
003428  1               
003428  1               ; get byte from input device, no waiting
003428  1               ; returns with carry set if byte in A
003428  1               
003428  1               INGET:
003428  1  20 58 3D             JSR     V_INPT          ; call scan input device
00342B  1  B0 09                BCS     LAB_FB95        ; if byte go reset timer
00342D  1               
00342D  1  AD 02 06             LDA     ccnull          ; get countdown
003430  1  F0 09                BEQ     LAB_FB96        ; exit if empty
003432  1               
003432  1  AD 01 06             LDA     ccbyte          ; get last received byte
003435  1  38                   SEC                     ; flag we got a byte
003436  1               LAB_FB95:
003436  1  A2 00                LDX     #$00            ; clear X
003438  1  8E 02 06             STX     ccnull          ; clear timer because we got a byte
00343B  1               LAB_FB96:
00343B  1  60                   RTS
00343C  1               
00343C  1               ; these routines only enable the interrupts if the set-up flag is set
00343C  1               ; if not they have no effect
00343C  1               
00343C  1               ; perform IRQ {ON|OFF|CLEAR}
00343C  1               
00343C  1               LAB_IRQ:
00343C  1  A2 E8                LDX     #IrqBase        ; set pointer to IRQ values
00343E  1  2C                   .BYTE   $2C             ; make next line BIT abs.
00343F  1               
00343F  1               ; perform NMI {ON|OFF|CLEAR}
00343F  1               
00343F  1               LAB_NMI:
00343F  1  A2 E5                LDX     #NmiBase        ; set pointer to NMI values
003441  1  C9 93                CMP     #TK_ON          ; compare with token for ON
003443  1  F0 11                BEQ     LAB_INON        ; go turn on interrupt
003445  1               
003445  1  C9 B6                CMP     #TK_OFF         ; compare with token for OFF
003447  1  F0 07                BEQ     LAB_IOFF        ; go turn off interrupt
003449  1               
003449  1  49 A2                EOR     #TK_CLEAR       ; compare with token for CLEAR, A = $00 if = TK_CLEAR
00344B  1  F0 0E                BEQ     LAB_INEX        ; go clear interrupt flags and return
00344D  1               
00344D  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
003450  1               
003450  1               LAB_IOFF:
003450  1  A9 7F                LDA     #$7F            ; clear A
003452  1  35 00                AND     PLUS_0,X        ; AND with interrupt setup flag
003454  1  10 05                BPL     LAB_INEX        ; go clear interrupt enabled flag and return
003456  1               
003456  1               LAB_INON:
003456  1  B5 00                LDA     PLUS_0,X        ; get interrupt setup flag
003458  1  0A                   ASL     A               ; Shift bit to enabled flag
003459  1  15 00                ORA     PLUS_0,X        ; OR with flag byte
00345B  1               LAB_INEX:
00345B  1  95 00                STA     PLUS_0,X        ; save interrupt flag byte
00345D  1                       .IFDEF  DUODYNE
00345D  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003461  1                       .ELSE
003461  1                       JSR     LAB_IGBY        ; increment and scan memory
003461  1                       .ENDIF
003461  1  60                   RTS
003462  1               
003462  1               ; these routines set up the pointers and flags for the interrupt routines
003462  1               ; note that the interrupts are also enabled by these commands
003462  1               
003462  1               ; perform ON IRQ
003462  1               
003462  1               LAB_SIRQ:
003462  1  58                   CLI                     ; enable interrupts
003463  1  A2 E8                LDX     #IrqBase        ; set pointer to IRQ values
003465  1  2C                   .BYTE   $2C             ; make next line BIT abs.
003466  1               
003466  1               ; perform ON NMI
003466  1               
003466  1               LAB_SNMI:
003466  1  A2 E5                LDX     #NmiBase        ; set pointer to NMI values
003468  1               
003468  1  86 78                STX     TempB           ; save interrupt pointer
00346A  1                       .IFDEF  DUODYNE
00346A  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00346E  1                       .ELSE
00346E  1                       JSR     LAB_IGBY        ; increment and scan memory
00346E  1                       .ENDIF
00346E  1               
00346E  1  20 CD 12             JSR     LAB_GFPN        ; get fixed-point number into temp integer
003471  1  A5 79                LDA     Smeml           ; get start of mem low byte
003473  1  A6 7A                LDX     Smemh           ; get start of mem high byte
003475  1  20 05 0D             JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
003478  1  B0 03                BCS     LAB_LFND        ; if carry set go set-up interrupt
00347A  1               
00347A  1  4C E2 11             JMP     LAB_16F7        ; else go do "Undefined statement" error and warm start
00347D  1               
00347D  1               LAB_LFND:
00347D  1  A6 78                LDX     TempB           ; get interrupt pointer
00347F  1  A5 AA                LDA     Baslnl          ; get pointer low byte
003481  1  E9 01                SBC     #$01            ; -1 (carry already set for subtract)
003483  1  95 01                STA     PLUS_1,X        ; save as interrupt pointer low byte
003485  1  A5 AB                LDA     Baslnh          ; get pointer high byte
003487  1  E9 00                SBC     #$00            ; subtract carry
003489  1  95 02                STA     PLUS_2,X        ; save as interrupt pointer high byte
00348B  1               
00348B  1  A9 C0                LDA     #$C0            ; set interrupt enabled/setup bits
00348D  1  95 00                STA     PLUS_0,X        ; set interrupt flags
00348F  1               LAB_IRTS:
00348F  1  60                   RTS
003490  1               
003490  1               ; return from IRQ service, restores the enabled flag.
003490  1               
003490  1               ; perform RETIRQ
003490  1               
003490  1               LAB_RETIRQ:
003490  1  D0 FD                BNE     LAB_IRTS        ; exit if following token (to allow syntax error)
003492  1               
003492  1  A5 E8                LDA     IrqBase         ; get interrupt flags
003494  1  0A                   ASL     A               ; copy setup to enabled (b7)
003495  1  05 E8                ORA     IrqBase         ; OR in setup flag
003497  1  85 E8                STA     IrqBase         ; save enabled flag
003499  1  4C E9 11             JMP     LAB_16E8        ; go do rest of RETURN
00349C  1               
00349C  1               ; return from NMI service, restores the enabled flag.
00349C  1               
00349C  1               ; perform RETNMI
00349C  1               
00349C  1               LAB_RETNMI:
00349C  1  D0 F1                BNE     LAB_IRTS        ; exit if following token (to allow syntax error)
00349E  1               
00349E  1  A5 E5                LDA     NmiBase         ; get set-up flag
0034A0  1  0A                   ASL     A               ; copy setup to enabled (b7)
0034A1  1  05 E5                ORA     NmiBase         ; OR in setup flag
0034A3  1  85 E5                STA     NmiBase         ; save enabled flag
0034A5  1  4C E9 11             JMP     LAB_16E8        ; go do rest of RETURN
0034A8  1               
0034A8  1               ; MAX() MIN() pre process
0034A8  1               
0034A8  1               LAB_MMPP:
0034A8  1  20 99 17             JSR     LAB_EVEZ        ; process expression
0034AB  1  4C 80 17             JMP     LAB_CTNM        ; check if source is numeric, else do type mismatch
0034AE  1               
0034AE  1               ; perform MAX()
0034AE  1               
0034AE  1               LAB_MAX:
0034AE  1  20 DE 34             JSR     LAB_PHFA        ; push FAC1, evaluate expression,
0034B1  1               ; pull FAC2 and compare with FAC1
0034B1  1  10 FB                BPL     LAB_MAX         ; branch if no swap to do
0034B3  1               
0034B3  1  A5 B4                LDA     FAC2_1          ; get FAC2 mantissa1
0034B5  1  09 80                ORA     #$80            ; set top bit (clear sign from compare)
0034B7  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
0034B9  1  20 FF 28             JSR     LAB_279B        ; copy FAC2 to FAC1
0034BC  1  F0 F0                BEQ     LAB_MAX         ; go do next (branch always)
0034BE  1               
0034BE  1               ; perform MIN()
0034BE  1               
0034BE  1               LAB_MIN:
0034BE  1  20 DE 34             JSR     LAB_PHFA        ; push FAC1, evaluate expression,
0034C1  1               ; pull FAC2 and compare with FAC1
0034C1  1  30 FB                BMI     LAB_MIN         ; branch if no swap to do
0034C3  1               
0034C3  1  F0 F9                BEQ     LAB_MIN         ; branch if no swap to do
0034C5  1               
0034C5  1  A5 B4                LDA     FAC2_1          ; get FAC2 mantissa1
0034C7  1  09 80                ORA     #$80            ; set top bit (clear sign from compare)
0034C9  1  85 B4                STA     FAC2_1          ; save FAC2 mantissa1
0034CB  1  20 FF 28             JSR     LAB_279B        ; copy FAC2 to FAC1
0034CE  1  F0 EE                BEQ     LAB_MIN         ; go do next (branch always)
0034D0  1               
0034D0  1               ; exit routine. don't bother returning to the loop code
0034D0  1               ; check for correct exit, else so syntax error
0034D0  1               
0034D0  1               LAB_MMEC:
0034D0  1  C9 29                CMP     #')'            ; is it end of function?
0034D2  1  D0 07                BNE     LAB_MMSE        ; if not do MAX MIN syntax error
0034D4  1               
0034D4  1  68                   PLA                     ; dump return address low byte
0034D5  1  68                   PLA                     ; dump return address high byte
0034D6  1                       .IFDEF  DUODYNE
0034D6  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0034DA  1                       .ELSE
0034DA  1                       JSR     LAB_IGBY        ; increment and scan memory
0034DA  1                       .ENDIF
0034DA  1               
0034DA  1  60                   RTS                     ; update BASIC execute pointer (to chr past ")")
0034DB  1               
0034DB  1               LAB_MMSE:
0034DB  1  4C B7 18             JMP     LAB_SNER        ; do syntax error then warm start
0034DE  1               
0034DE  1               ; check for next, evaluate and return or exit
0034DE  1               ; this is the routine that does most of the work
0034DE  1               
0034DE  1               LAB_PHFA:
0034DE  1                       .IFDEF  DUODYNE
0034DE  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0034E2  1                       .ELSE
0034E2  1                       JSR     LAB_GBYT        ; scan memory
0034E2  1                       .ENDIF
0034E2  1               
0034E2  1  C9 2C                CMP     #','            ; is there more ?
0034E4  1  D0 EA                BNE     LAB_MMEC        ; if not go do end check
0034E6  1               
0034E6  1               ; push FAC1
0034E6  1  20 0B 2D             JSR     LAB_27BA        ; round FAC1
0034E9  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign
0034EB  1  09 7F                ORA     #$7F            ; set all non sign bits
0034ED  1  25 AD                AND     FAC1_1          ; AND FAC1 mantissa1 (AND in sign bit)
0034EF  1  48                   PHA                     ; push on stack
0034F0  1  A5 AE                LDA     FAC1_2          ; get FAC1 mantissa2
0034F2  1  48                   PHA                     ; push on stack
0034F3  1  A5 AF                LDA     FAC1_3          ; get FAC1 mantissa3
0034F5  1  48                   PHA                     ; push on stack
0034F6  1  A5 AC                LDA     FAC1_e          ; get FAC1 exponent
0034F8  1  48                   PHA                     ; push on stack
0034F9  1               
0034F9  1                       .IFDEF  DUODYNE
0034F9  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0034FD  1                       .ELSE
0034FD  1                       JSR     LAB_IGBY        ; increment and scan memory
0034FD  1                       .ENDIF
0034FD  1               
0034FD  1  20 7D 17             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
003500  1               ; else do type mismatch
003500  1               
003500  1               ; pop FAC2 (MAX/MIN expression so far)
003500  1  68                   PLA                     ; pop exponent
003501  1  85 B3                STA     FAC2_e          ; save FAC2 exponent
003503  1  68                   PLA                     ; pop mantissa3
003504  1  85 B6                STA     FAC2_3          ; save FAC2 mantissa3
003506  1  68                   PLA                     ; pop mantissa1
003507  1  85 B5                STA     FAC2_2          ; save FAC2 mantissa2
003509  1  68                   PLA                     ; pop sign/mantissa1
00350A  1  85 B4                STA     FAC2_1          ; save FAC2 sign/mantissa1
00350C  1  85 B7                STA     FAC2_s          ; save FAC2 sign
00350E  1               
00350E  1               ; compare FAC1 with (packed) FAC2
00350E  1  A9 B3                LDA     #<FAC2_e        ; set pointer low byte to FAC2
003510  1  A0 00                LDY     #>FAC2_e        ; set pointer high byte to FAC2
003512  1  4C 49 2D             JMP     LAB_27F8        ; compare FAC1 with FAC2 (AY) and return
003515  1               ; returns A=$00 if FAC1 = (AY)
003515  1               ; returns A=$01 if FAC1 > (AY)
003515  1               ; returns A=$FF if FAC1 < (AY)
003515  1               
003515  1               ; perform WIDTH
003515  1               
003515  1               LAB_WDTH:
003515  1  C9 2C                CMP     #','            ; is next byte ","
003517  1  F0 1C                BEQ     LAB_TBSZ        ; if so do tab size
003519  1               
003519  1  20 1B 27             JSR     LAB_GTBY        ; get byte parameter
00351C  1  8A                   TXA                     ; copy width to A
00351D  1  F0 0A                BEQ     LAB_NSTT        ; branch if set for infinite line
00351F  1               
00351F  1  E0 10                CPX     #$10            ; else make min width = 16d
003521  1  90 46                BCC     TabErr          ; if less do function call error and exit
003523  1               
003523  1               ; this next compare ensures that we can't exit WIDTH via an error leaving the
003523  1               ; tab size greater than the line length.
003523  1               
003523  1  E4 64                CPX     TabSiz          ; compare with tab size
003525  1  B0 02                BCS     LAB_NSTT        ; branch if >= tab size
003527  1               
003527  1  86 64                STX     TabSiz          ; else make tab size = terminal width
003529  1               LAB_NSTT:
003529  1  86 0F                STX     TWidth          ; set the terminal width
00352B  1                       .IFDEF  DUODYNE
00352B  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00352F  1                       .ELSE
00352F  1                       JSR     LAB_GBYT        ; scan memory
00352F  1                       .ENDIF
00352F  1               
00352F  1  F0 1A                BEQ     WExit           ; exit if no following
003531  1               
003531  1  C9 2C                CMP     #','            ; else is it ","
003533  1  D0 A6                BNE     LAB_MMSE        ; if not do syntax error
003535  1               
003535  1               LAB_TBSZ:
003535  1  20 17 27             JSR     LAB_SGBY        ; scan and get byte parameter
003538  1  8A                   TXA                     ; copy TAB size
003539  1  30 2E                BMI     TabErr          ; if >127 do function call error and exit
00353B  1               
00353B  1  E0 01                CPX     #$01            ; compare with min-1
00353D  1  90 2A                BCC     TabErr          ; if <=1 do function call error and exit
00353F  1               
00353F  1  A5 0F                LDA     TWidth          ; set flags for width
003541  1  F0 06                BEQ     LAB_SVTB        ; skip check if infinite line
003543  1               
003543  1  E4 0F                CPX     TWidth          ; compare TAB with width
003545  1  F0 02                BEQ     LAB_SVTB        ; ok if =
003547  1               
003547  1  B0 20                BCS     TabErr          ; branch if too big
003549  1               
003549  1               LAB_SVTB:
003549  1  86 64                STX     TabSiz          ; save TAB size
00354B  1               
00354B  1               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00354B  1               ; position on a line that still has at least one whole tab width between it
00354B  1               ; and the end of the line.
00354B  1               
00354B  1               WExit:
00354B  1  A5 0F                LDA     TWidth          ; get width
00354D  1  F0 06                BEQ     LAB_SULP        ; branch if infinite line
00354F  1               
00354F  1  C5 64                CMP     TabSiz          ; compare with tab size
003551  1  B0 03                BCS     LAB_WDLP        ; branch if >= tab size
003553  1               
003553  1  85 64                STA     TabSiz          ; else make tab size = terminal width
003555  1               LAB_SULP:
003555  1  38                   SEC                     ; set carry for subtract
003556  1               LAB_WDLP:
003556  1  E5 64                SBC     TabSiz          ; subtract tab size
003558  1  B0 FC                BCS     LAB_WDLP        ; loop while no borrow
00355A  1               
00355A  1  65 64                ADC     TabSiz          ; add tab size back
00355C  1  18                   CLC                     ; clear carry for add
00355D  1  65 64                ADC     TabSiz          ; add tab size back again
00355F  1  85 10                STA     Iclim           ; save for now
003561  1  A5 0F                LDA     TWidth          ; get width back
003563  1  38                   SEC                     ; set carry for subtract
003564  1  E5 10                SBC     Iclim           ; subtract remainder
003566  1  85 10                STA     Iclim           ; save tab column limit
003568  1               LAB_NOSQ:
003568  1  60                   RTS
003569  1               
003569  1               TabErr:
003569  1  4C 12 1D             JMP     LAB_FCER        ; do function call error then warm start
00356C  1               
00356C  1               ; perform SQR()
00356C  1               
00356C  1               LAB_SQR:
00356C  1  A5 B0                LDA     FAC1_s          ; get FAC1 sign
00356E  1  30 F9                BMI     TabErr          ; if -ve do function call error
003570  1               
003570  1  A5 AC                LDA     FAC1_e          ; get exponent
003572  1  F0 F4                BEQ     LAB_NOSQ        ; if zero just return
003574  1               
003574  1               ; else do root
003574  1  20 FC 2C             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
003577  1  A9 00                LDA     #$00            ; clear A
003579  1               
003579  1  85 77                STA     FACt_3          ; clear remainder
00357B  1  85 76                STA     FACt_2          ; ..
00357D  1  85 75                STA     FACt_1          ; ..
00357F  1  85 78                STA     TempB           ; ..
003581  1               
003581  1  85 AF                STA     FAC1_3          ; clear root
003583  1  85 AE                STA     FAC1_2          ; ..
003585  1  85 AD                STA     FAC1_1          ; ..
003587  1               
003587  1  A2 18                LDX     #$18            ; 24 pairs of bits to do
003589  1  A5 B3                LDA     FAC2_e          ; get exponent
00358B  1  4A                   LSR     A               ; check odd/even
00358C  1  B0 0E                BCS     LAB_SQE2        ; if odd only 1 shift first time
00358E  1               
00358E  1               LAB_SQE1:
00358E  1  06 B6                ASL     FAC2_3          ; shift highest bit of number ..
003590  1  26 B5                ROL     FAC2_2          ; ..
003592  1  26 B4                ROL     FAC2_1          ; ..
003594  1  26 77                ROL     FACt_3          ; .. into remainder
003596  1  26 76                ROL     FACt_2          ; ..
003598  1  26 75                ROL     FACt_1          ; ..
00359A  1  26 78                ROL     TempB           ; .. never overflows
00359C  1               LAB_SQE2:
00359C  1  06 B6                ASL     FAC2_3          ; shift highest bit of number ..
00359E  1  26 B5                ROL     FAC2_2          ; ..
0035A0  1  26 B4                ROL     FAC2_1          ; ..
0035A2  1  26 77                ROL     FACt_3          ; .. into remainder
0035A4  1  26 76                ROL     FACt_2          ; ..
0035A6  1  26 75                ROL     FACt_1          ; ..
0035A8  1  26 78                ROL     TempB           ; .. never overflows
0035AA  1               
0035AA  1  06 AF                ASL     FAC1_3          ; root = root * 2
0035AC  1  26 AE                ROL     FAC1_2          ; ..
0035AE  1  26 AD                ROL     FAC1_1          ; .. never overflows
0035B0  1               
0035B0  1  A5 AF                LDA     FAC1_3          ; get root low byte
0035B2  1  2A                   ROL     A               ; *2
0035B3  1  85 5B                STA     Temp3           ; save partial low byte
0035B5  1  A5 AE                LDA     FAC1_2          ; get root low mid byte
0035B7  1  2A                   ROL     A               ; *2
0035B8  1  85 5C                STA     Temp3+1         ; save partial low mid byte
0035BA  1  A5 AD                LDA     FAC1_1          ; get root high mid byte
0035BC  1  2A                   ROL     A               ; *2
0035BD  1  85 5D                STA     Temp3+2         ; save partial high mid byte
0035BF  1  A9 00                LDA     #$00            ; get root high byte (always $00)
0035C1  1  2A                   ROL     A               ; *2
0035C2  1  85 5E                STA     Temp3+3         ; save partial high byte
0035C4  1               
0035C4  1               ; carry clear for subtract +1
0035C4  1  A5 77                LDA     FACt_3          ; get remainder low byte
0035C6  1  E5 5B                SBC     Temp3           ; subtract partial low byte
0035C8  1  85 5B                STA     Temp3           ; save partial low byte
0035CA  1               
0035CA  1  A5 76                LDA     FACt_2          ; get remainder low mid byte
0035CC  1  E5 5C                SBC     Temp3+1         ; subtract partial low mid byte
0035CE  1  85 5C                STA     Temp3+1         ; save partial low mid byte
0035D0  1               
0035D0  1  A5 75                LDA     FACt_1          ; get remainder high mid byte
0035D2  1  E5 5D                SBC     Temp3+2         ; subtract partial high mid byte
0035D4  1  A8                   TAY                     ; copy partial high mid byte
0035D5  1               
0035D5  1  A5 78                LDA     TempB           ; get remainder high byte
0035D7  1  E5 5E                SBC     Temp3+3         ; subtract partial high byte
0035D9  1  90 0E                BCC     LAB_SQNS        ; skip sub if remainder smaller
0035DB  1               
0035DB  1  85 78                STA     TempB           ; save remainder high byte
0035DD  1               
0035DD  1  84 75                STY     FACt_1          ; save remainder high mid byte
0035DF  1               
0035DF  1  A5 5C                LDA     Temp3+1         ; get remainder low mid byte
0035E1  1  85 76                STA     FACt_2          ; save remainder low mid byte
0035E3  1               
0035E3  1  A5 5B                LDA     Temp3           ; get partial low byte
0035E5  1  85 77                STA     FACt_3          ; save remainder low byte
0035E7  1               
0035E7  1  E6 AF                INC     FAC1_3          ; increment root low byte (never any rollover)
0035E9  1               LAB_SQNS:
0035E9  1  CA                   DEX                     ; decrement bit pair count
0035EA  1  D0 A2                BNE     LAB_SQE1        ; loop if not all done
0035EC  1               
0035EC  1  38                   SEC                     ; set carry for subtract
0035ED  1  A5 B3                LDA     FAC2_e          ; get exponent
0035EF  1  E9 80                SBC     #$80            ; normalise
0035F1  1  6A                   ROR     A               ; /2 and re-bias to $80
0035F2  1  69 00                ADC     #$00            ; add bit zero back in (allow for half shift)
0035F4  1  85 AC                STA     FAC1_e          ; save it
0035F6  1  4C 76 29             JMP     LAB_24D5        ; normalise FAC1 and return
0035F9  1               
0035F9  1               ; perform VARPTR()
0035F9  1               
0035F9  1               LAB_VARPTR:
0035F9  1                       .IFDEF  DUODYNE
0035F9  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0035FD  1                       .ELSE
0035FD  1                       JSR     LAB_IGBY        ; increment and scan memory
0035FD  1                       .ENDIF
0035FD  1               
0035FD  1  20 8E 1A             JSR     LAB_GVAR        ; get var address
003600  1  20 A2 18             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
003603  1  A4 95                LDY     Cvaral          ; get var address low byte
003605  1  A5 96                LDA     Cvarah          ; get var address high byte
003607  1  4C 70 1F             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00360A  1               
00360A  1               ; perform PI
00360A  1               
00360A  1               LAB_PI:
00360A  1  A9 E1                LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
00360C  1  A0 36                LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
00360E  1  20 0F 2C             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
003611  1  C6 AC                DEC     FAC1_e          ; make result = PI
003613  1  60                   RTS
003614  1               
003614  1               ; perform TWOPI
003614  1               
003614  1               LAB_TWOPI:
003614  1  A9 E1                LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
003616  1  A0 36                LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
003618  1  4C 0F 2C             JMP     LAB_UFAC        ; unpack memory (AY) into FAC1 and return
00361B  1               
00361B  1               
00361B  1               ; The rest are tables messages and code for RAM
00361B  1               
00361B  1               ; the rest of the code is tables and BASIC start-up code
00361B  1               
00361B  1               PG2_TABS:
00361B  1  00                   .BYTE   $00             ; ctrl-c flag		-	$00 = enabled
00361C  1  00                   .BYTE   $00             ; ctrl-c byte		-	GET needs this
00361D  1  00                   .BYTE   $00             ; ctrl-c byte timeout	-	GET needs this
00361E  1  CC 33                .WORD   CTRLC           ; ctrl c check vector
003620  1               ;	.word	xxxx			; non halting key input	-	monitor to set this
003620  1               ;	.word	xxxx			; output vector		-	monitor to set this
003620  1               ;	.word	xxxx			; load vector		-	monitor to set this
003620  1               ;	.word	xxxx			; save vector		-	monitor to set this
003620  1               PG2_TABE:
003620  1               
003620  1               ; character get subroutine for zero page
003620  1               
003620  1               ; For a 1.8432MHz 6502 including the JSR and RTS
003620  1               ; fastest (>=":")	=  29 cycles =  15.7uS
003620  1               ; slowest (<":")	=  40 cycles =  21.7uS
003620  1               ; space skip	= +21 cycles = +11.4uS
003620  1               ; inc across page	=  +4 cycles =  +2.2uS
003620  1               
003620  1               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
003620  1               ; block is copied to it's destination, any non zero page address will do at assembly
003620  1               ; time, to assemble a three byte instruction.
003620  1               
003620  1               ; page 0 initialisation table from $BC
003620  1               ; increment and scan memory
003620  1               
003620  1               LAB_2CEE:
003620  1  E6 C3                INC     Bpntrl          ; increment BASIC execute pointer low byte
003622  1  D0 02                BNE     LAB_2CF4        ; branch if no carry
003624  1               ; else
003624  1  E6 C4                INC     Bpntrh          ; increment BASIC execute pointer high byte
003626  1               
003626  1               ; page 0 initialisation table from $C2
003626  1               ; scan memory
003626  1                       .IFDEF  DUODYNE
003626  1               LAB_2CF4:
003626  1  AF FF FF FF          LDA     $FFFFFF         ; get byte to scan (addr set by call routine)
00362A  1  C9 AD                CMP     #TK_ELSE        ; compare with the token for ELSE
00362C  1  F0 0E                BEQ     LAB_2D05        ; exit if ELSE, not numeric, carry set
00362E  1               
00362E  1  C9 3A                CMP     #':'            ; compare with ":"
003630  1  B0 0A                BCS     LAB_2D05        ; exit if >= ":", not numeric, carry set
003632  1               
003632  1  C9 20                CMP     #' '            ; compare with " "
003634  1  F0 EA                BEQ     LAB_2CEE        ; if " " go do next
003636  1               
003636  1  38                   SEC                     ; set carry for SBC
003637  1  E9 30                SBC     #'0'            ; subtract "0"
003639  1  38                   SEC                     ; set carry for SBC
00363A  1  E9 D0                SBC     #$D0            ; subtract -"0"
00363C  1               ; clear carry if byte = "0"-"9"
00363C  1               LAB_2D05:
00363C  1  6B                   RTL
00363D  1                       .ELSE
00363D  1               LAB_2CF4:
00363D  1                       LDA     $FFFF           ; get byte to scan (addr set by call routine)
00363D  1                       CMP     #TK_ELSE        ; compare with the token for ELSE
00363D  1                       BEQ     LAB_2D05        ; exit if ELSE, not numeric, carry set
00363D  1               
00363D  1                       CMP     #':'            ; compare with ":"
00363D  1                       BCS     LAB_2D05        ; exit if >= ":", not numeric, carry set
00363D  1               
00363D  1                       CMP     #' '            ; compare with " "
00363D  1                       BEQ     LAB_2CEE        ; if " " go do next
00363D  1               
00363D  1                       SEC                     ; set carry for SBC
00363D  1                       SBC     #'0'            ; subtract "0"
00363D  1                       SEC                     ; set carry for SBC
00363D  1                       SBC     #$D0            ; subtract -"0"
00363D  1               ; clear carry if byte = "0"-"9"
00363D  1               LAB_2D05:
00363D  1                       RTS
00363D  1                       .ENDIF
00363D  1               
00363D  1               ; page zero initialisation table $00-$12 inclusive
00363D  1               
00363D  1               StrTab:
00363D  1  4C                   .BYTE   $4C             ; JMP opcode
00363E  1  0C 08                .WORD   LAB_COLD        ; initial warm start vector (cold start)
003640  1               
003640  1  00                   .BYTE   $00             ; these bytes are not used by BASIC
003641  1  00 00                .WORD   $0000           ;
003643  1  00 00                .WORD   $0000           ;
003645  1  00 00                .WORD   $0000           ;
003647  1               
003647  1  4C                   .BYTE   $4C             ; JMP opcode
003648  1  12 1D                .WORD   LAB_FCER        ; initial user function vector ("Function call" error)
00364A  1  00                   .BYTE   $00             ; default NULL count
00364B  1  00                   .BYTE   $00             ; clear terminal position
00364C  1  00                   .BYTE   $00             ; default terminal width byte
00364D  1  F2                   .BYTE   $F2             ; default limit for TAB = 14
00364E  1  00 42                .WORD   Ram_base        ; start of user RAM
003650  1               EndTab:
003650  1               
003650  1               LAB_MSZM:
003650  1  0D 0A 4D 65          .BYTE   $0D,$0A,"Memory size ",$00
003654  1  6D 6F 72 79  
003658  1  20 73 69 7A  
00365F  1               
00365F  1               LAB_SMSG:
00365F  1  20 42 79 74          .BYTE   " Bytes free",$0D,$0A,$0A
003663  1  65 73 20 66  
003667  1  72 65 65 0D  
00366D  1  45 6E 68 61          .BYTE   "Enhanced BASIC 2.22",$0A,$00
003671  1  6E 63 65 64  
003675  1  20 42 41 53  
003682  1               
003682  1               ; numeric constants and series
003682  1               
003682  1               ; constants and series for LOG(n)
003682  1               LAB_25A0:
003682  1  02                   .BYTE   $02             ; counter
003683  1  80 19 56 62          .BYTE   $80,$19,$56,$62 ; 0.59898
003687  1  80 76 22 F3          .BYTE   $80,$76,$22,$F3 ; 0.96147
00368B  1               ;##	.byte	$80,$76,$22,$F1	; 0.96147
00368B  1  82 38 AA 40          .BYTE   $82,$38,$AA,$40 ; 2.88539
00368F  1               ;##	.byte	$82,$38,$AA,$45	; 2.88539
00368F  1               
00368F  1               LAB_25AD:
00368F  1  80 35 04 F3          .BYTE   $80,$35,$04,$F3 ; 0.70711	1/root 2
003693  1               LAB_25B1:
003693  1  81 35 04 F3          .BYTE   $81,$35,$04,$F3 ; 1.41421	root 2
003697  1               LAB_25B5:
003697  1  80 80 00 00          .BYTE   $80,$80,$00,$00 ; -0.5
00369B  1               LAB_25B9:
00369B  1  80 31 72 18          .BYTE   $80,$31,$72,$18 ; 0.69315	LOG(2)
00369F  1               
00369F  1               ; numeric PRINT constants
00369F  1               LAB_2947:
00369F  1  91 43 4F F8          .BYTE   $91,$43,$4F,$F8 ; 99999.9375 (max value with at least one decimal)
0036A3  1               LAB_294B:
0036A3  1  94 74 23 F7          .BYTE   $94,$74,$23,$F7 ; 999999.4375 (max value before scientific notation)
0036A7  1               LAB_294F:
0036A7  1  94 74 24 00          .BYTE   $94,$74,$24,$00 ; 1000000
0036AB  1               
0036AB  1               ; EXP(n) constants and series
0036AB  1               LAB_2AFA:
0036AB  1  81 38 AA 3B          .BYTE   $81,$38,$AA,$3B ; 1.4427	(1/LOG base 2 e)
0036AF  1               LAB_2AFE:
0036AF  1  06                   .BYTE   $06             ; counter
0036B0  1  74 63 90 8C          .BYTE   $74,$63,$90,$8C ; 2.17023e-4
0036B4  1  77 23 0C AB          .BYTE   $77,$23,$0C,$AB ; 0.00124
0036B8  1  7A 1E 94 00          .BYTE   $7A,$1E,$94,$00 ; 0.00968
0036BC  1  7C 63 42 80          .BYTE   $7C,$63,$42,$80 ; 0.05548
0036C0  1  7E 75 FE D0          .BYTE   $7E,$75,$FE,$D0 ; 0.24023
0036C4  1  80 31 72 15          .BYTE   $80,$31,$72,$15 ; 0.69315
0036C8  1  81 00 00 00          .BYTE   $81,$00,$00,$00 ; 1.00000
0036CC  1               
0036CC  1               ;##	.byte	$07			; counter
0036CC  1               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
0036CC  1               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
0036CC  1               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
0036CC  1               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
0036CC  1               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
0036CC  1               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
0036CC  1               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
0036CC  1               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
0036CC  1               
0036CC  1               ; trigonometric constants and series
0036CC  1               LAB_2C78:
0036CC  1  81 49 0F DB          .BYTE   $81,$49,$0F,$DB ; 1.570796371 (pi/2) as floating #
0036D0  1               LAB_2C84:
0036D0  1  04                   .BYTE   $04             ; counter
0036D1  1  86 1E D7 FB          .BYTE   $86,$1E,$D7,$FB ; 39.7109
0036D5  1               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
0036D5  1  87 99 26 65          .BYTE   $87,$99,$26,$65 ;-76.575
0036D9  1               ;##	.byte	$87,$99,$26,$64	;-76.575
0036D9  1  87 23 34 58          .BYTE   $87,$23,$34,$58 ; 81.6022
0036DD  1  86 A5 5D E1          .BYTE   $86,$A5,$5D,$E1 ;-41.3417
0036E1  1               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
0036E1  1               LAB_2C7C:
0036E1  1  83 49 0F DB          .BYTE   $83,$49,$0F,$DB ; 6.28319 (2*pi) as floating #
0036E5  1               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
0036E5  1               
0036E5  1               LAB_2CC9:
0036E5  1  08                   .BYTE   $08             ; counter
0036E6  1  78 3A C5 37          .BYTE   $78,$3A,$C5,$37 ; 0.00285
0036EA  1  7B 83 A2 5C          .BYTE   $7B,$83,$A2,$5C ;-0.0160686
0036EE  1  7C 2E DD 4D          .BYTE   $7C,$2E,$DD,$4D ; 0.0426915
0036F2  1  7D 99 B0 1E          .BYTE   $7D,$99,$B0,$1E ;-0.0750429
0036F6  1  7D 59 ED 24          .BYTE   $7D,$59,$ED,$24 ; 0.106409
0036FA  1  7E 91 72 00          .BYTE   $7E,$91,$72,$00 ;-0.142036
0036FE  1  7E 4C B9 73          .BYTE   $7E,$4C,$B9,$73 ; 0.199926
003702  1  7F AA AA 53          .BYTE   $7F,$AA,$AA,$53 ;-0.333331
003706  1               
003706  1               ;##	.byte	$08			; counter
003706  1               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
003706  1               ;##	.byte	$7B,$84,$6E,$02	;-1/15
003706  1               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
003706  1               ;##	.byte	$7D,$9A,$31,$74	;-1/11
003706  1               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
003706  1               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
003706  1               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
003706  1               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
003706  1               
003706  1               LAB_1D96        = *+1           ; $00,$00 used for undefined variables
003706  1               LAB_259C:
003706  1  81 00 00 00          .BYTE   $81,$00,$00,$00 ; 1.000000, used for INC
00370A  1               LAB_2AFD:
00370A  1  81 80 00 00          .BYTE   $81,$80,$00,$00 ; -1.00000, used for DEC. must be on the same page as +1.00
00370E  1               
00370E  1               ; misc constants
00370E  1               LAB_1DF7:
00370E  1  90                   .BYTE   $90             ;-32768 (uses first three bytes from 0.5)
00370F  1               LAB_2A96:
00370F  1  80 00 00 00          .BYTE   $80,$00,$00,$00 ; 0.5
003713  1               LAB_2C80:
003713  1  7F 00 00 00          .BYTE   $7F,$00,$00,$00 ; 0.25
003717  1               LAB_26B5:
003717  1  84 20 00 00          .BYTE   $84,$20,$00,$00 ; 10.0000 divide by 10 constant
00371B  1               
00371B  1               ; This table is used in converting numbers to ASCII.
00371B  1               
00371B  1               LAB_2A9A:
00371B  1               LAB_2A9B        = LAB_2A9A+1
00371B  1               LAB_2A9C        = LAB_2A9B+1
00371B  1  FE 79 60             .BYTE   $FE,$79,$60     ; -100000
00371E  1  00 27 10             .BYTE   $00,$27,$10     ; 10000
003721  1  FF FC 18             .BYTE   $FF,$FC,$18     ; -1000
003724  1  00 00 64             .BYTE   $00,$00,$64     ; 100
003727  1  FF FF F6             .BYTE   $FF,$FF,$F6     ; -10
00372A  1  00 00 01             .BYTE   $00,$00,$01     ; 1
00372D  1               
00372D  1               LAB_CTBL:
00372D  1  7F 10                .WORD   LAB_END-1       ; END
00372F  1  AF 0F                .WORD   LAB_FOR-1       ; FOR
003731  1  FA 16                .WORD   LAB_NEXT-1      ; NEXT
003733  1  FB 11                .WORD   LAB_DATA-1      ; DATA
003735  1  BB 15                .WORD   LAB_INPUT-1     ; INPUT
003737  1  41 1A                .WORD   LAB_DIM-1       ; DIM
003739  1  DB 15                .WORD   LAB_READ-1      ; READ
00373B  1  2E 13                .WORD   LAB_LET-1       ; LET
00373D  1  FE 12                .WORD   LAB_DEC-1       ; DEC			new command
00373F  1  51 11                .WORD   LAB_GOTO-1      ; GOTO
003741  1  0E 11                .WORD   LAB_RUN-1       ; RUN
003743  1  29 12                .WORD   LAB_IF-1        ; IF
003745  1  A6 10                .WORD   LAB_RESTORE-1   ; RESTORE		modified command
003747  1  33 11                .WORD   LAB_GOSUB-1     ; GOSUB
003749  1  8F 34                .WORD   LAB_RETIRQ-1    ; RETIRQ		new command
00374B  1  9B 34                .WORD   LAB_RETNMI-1    ; RETNMI		new command
00374D  1  E6 11                .WORD   LAB_RETURN-1    ; RETURN
00374F  1  94 12                .WORD   LAB_REM-1       ; REM
003751  1  7D 10                .WORD   LAB_STOP-1      ; STOP
003753  1  9D 12                .WORD   LAB_ON-1        ; ON			modified command
003755  1  E4 10                .WORD   LAB_NULL-1      ; NULL		modified command
003757  1  01 13                .WORD   LAB_INC-1       ; INC			new command
003759  1  AF 28                .WORD   LAB_WAIT-1      ; WAIT
00375B  1  BA 3E                .WORD   V_LOAD-1        ; LOAD
00375D  1  9E 3D                .WORD   V_SAVE-1        ; SAVE
00375F  1  8D 1F                .WORD   LAB_DEF-1       ; DEF
003761  1  E0 27                .WORD   LAB_POKE-1      ; POKE
003763  1  FC 27                .WORD   LAB_DOKE-1      ; DOKE		new command
003765  1  9B 28                .WORD   LAB_CALL-1      ; CALL		new command
003767  1  18 11                .WORD   LAB_DO-1        ; DO			new command
003769  1  83 11                .WORD   LAB_LOOP-1      ; LOOP		new command
00376B  1  98 14                .WORD   LAB_PRINT-1     ; PRINT
00376D  1  EA 10                .WORD   LAB_CONT-1      ; CONT
00376F  1  0A 0E                .WORD   LAB_LIST-1      ; LIST
003771  1  07 0E                .WORD   LAB_CLEAR-1     ; CLEAR
003773  1  93 0D                .WORD   LAB_NEW-1       ; NEW
003775  1  14 35                .WORD   LAB_WDTH-1      ; WIDTH		new command
003777  1  52 14                .WORD   LAB_GET-1       ; GET			new command
003779  1  23 28                .WORD   LAB_SWAP-1      ; SWAP		new command
00377B  1  63 32                .WORD   LAB_BITSET-1    ; BITSET		new command
00377D  1  77 32                .WORD   LAB_BITCLR-1    ; BITCLR		new command
00377F  1  3B 34                .WORD   LAB_IRQ-1       ; IRQ			new command
003781  1  3E 34                .WORD   LAB_NMI-1       ; NMI			new command
003783  1  9B 3D                .WORD   LAB_KILL-1      ; KILL			new command
003785  1               
003785  1               ; function pre process routine table
003785  1               
003785  1               LAB_FTPL:
003785  1               LAB_FTPM        = LAB_FTPL+$01
003785  1  19 19                .WORD   LAB_PPFN-1      ; SGN(n)	process numeric expression in ()
003787  1  19 19                .WORD   LAB_PPFN-1      ; INT(n)		"
003789  1  19 19                .WORD   LAB_PPFN-1      ; ABS(n)		"
00378B  1  98 17                .WORD   LAB_EVEZ-1      ; USR(x)	process any expression
00378D  1  9E 18                .WORD   LAB_1BF7-1      ; FRE(x)		"
00378F  1  9E 18                .WORD   LAB_1BF7-1      ; POS(x)		"
003791  1  19 19                .WORD   LAB_PPFN-1      ; SQR(n)	process numeric expression in ()
003793  1  19 19                .WORD   LAB_PPFN-1      ; RND(n)		"
003795  1  19 19                .WORD   LAB_PPFN-1      ; LOG(n)		"
003797  1  19 19                .WORD   LAB_PPFN-1      ; EXP(n)		"
003799  1  19 19                .WORD   LAB_PPFN-1      ; COS(n)		"
00379B  1  19 19                .WORD   LAB_PPFN-1      ; SIN(n)		"
00379D  1  19 19                .WORD   LAB_PPFN-1      ; TAN(n)		"
00379F  1  19 19                .WORD   LAB_PPFN-1      ; ATN(n)		"
0037A1  1  19 19                .WORD   LAB_PPFN-1      ; PEEK(n)		"
0037A3  1  19 19                .WORD   LAB_PPFN-1      ; DEEK(n)		"
0037A5  1  00 00                .WORD   $0000           ; SADD()	none
0037A7  1  13 19                .WORD   LAB_PPFS-1      ; LEN($)	process string expression in ()
0037A9  1  19 19                .WORD   LAB_PPFN-1      ; STR$(n)	process numeric expression in ()
0037AB  1  13 19                .WORD   LAB_PPFS-1      ; VAL($)	process string expression in ()
0037AD  1  13 19                .WORD   LAB_PPFS-1      ; ASC($)		"
0037AF  1  13 19                .WORD   LAB_PPFS-1      ; UCASE$($)		"
0037B1  1  13 19                .WORD   LAB_PPFS-1      ; LCASE$($)		"
0037B3  1  19 19                .WORD   LAB_PPFN-1      ; CHR$(n)	process numeric expression in ()
0037B5  1  42 19                .WORD   LAB_BHSS-1      ; HEX$(n)		"
0037B7  1  42 19                .WORD   LAB_BHSS-1      ; BIN$(n)		"
0037B9  1  00 00                .WORD   $0000           ; BITTST()	none
0037BB  1  A7 34                .WORD   LAB_MMPP-1      ; MAX()	process numeric expression
0037BD  1  A7 34                .WORD   LAB_MMPP-1      ; MIN()		"
0037BF  1  1F 19                .WORD   LAB_PPBI-1      ; PI		advance pointer
0037C1  1  1F 19                .WORD   LAB_PPBI-1      ; TWOPI		"
0037C3  1  00 00                .WORD   $0000           ; VARPTR()	none
0037C5  1  26 19                .WORD   LAB_LRMS-1      ; LEFT$()	process string expression
0037C7  1  26 19                .WORD   LAB_LRMS-1      ; RIGHT$()		"
0037C9  1  26 19                .WORD   LAB_LRMS-1      ; MID$()		"
0037CB  1               
0037CB  1               ; action addresses for functions
0037CB  1               
0037CB  1               LAB_FTBL:
0037CB  1               LAB_FTBM        = LAB_FTBL+$01
0037CB  1  28 2D                .WORD   LAB_SGN-1       ; SGN()
0037CD  1  16 2E                .WORD   LAB_INT-1       ; INT()
0037CF  1  45 2D                .WORD   LAB_ABS-1       ; ABS()
0037D1  1  2E 32                .WORD   LAB_USR-1       ; USR()
0037D3  1  5B 1F                .WORD   LAB_FRE-1       ; FRE()
0037D5  1  7A 1F                .WORD   LAB_POS-1       ; POS()
0037D7  1  6B 35                .WORD   LAB_SQR-1       ; SQR()
0037D9  1  7E 31                .WORD   LAB_RND-1       ; RND()		modified function
0037DB  1  3C 2A                .WORD   LAB_LOG-1       ; LOG()
0037DD  1  CC 30                .WORD   LAB_EXP-1       ; EXP()
0037DF  1  B2 31                .WORD   LAB_COS-1       ; COS()
0037E1  1  B9 31                .WORD   LAB_SIN-1       ; SIN()
0037E3  1  02 32                .WORD   LAB_TAN-1       ; TAN()
0037E5  1  34 32                .WORD   LAB_ATN-1       ; ATN()
0037E7  1  D5 27                .WORD   LAB_PEEK-1      ; PEEK()
0037E9  1  E9 27                .WORD   LAB_DEEK-1      ; DEEK()		new function
0037EB  1  A5 26                .WORD   LAB_SADD-1      ; SADD()		new function
0037ED  1  E7 26                .WORD   LAB_LENS-1      ; LEN()
0037EF  1  F4 20                .WORD   LAB_STRS-1      ; STR$()
0037F1  1  2B 27                .WORD   LAB_VAL-1       ; VAL()
0037F3  1  F2 26                .WORD   LAB_ASC-1       ; ASC()
0037F5  1  5B 26                .WORD   LAB_UCASE-1     ; UCASE$()		new function
0037F7  1  0F 26                .WORD   LAB_LCASE-1     ; LCASE$()		new function
0037F9  1  13 25                .WORD   LAB_CHRS-1      ; CHR$()
0037FB  1  30 33                .WORD   LAB_HEXS-1      ; HEX$()		new function
0037FD  1  B8 32                .WORD   LAB_BINS-1      ; BIN$()		new function
0037FF  1  8D 32                .WORD   LAB_BTST-1      ; BITTST()		new function
003801  1  AD 34                .WORD   LAB_MAX-1       ; MAX()		new function
003803  1  BD 34                .WORD   LAB_MIN-1       ; MIN()		new function
003805  1  09 36                .WORD   LAB_PI-1        ; PI			new function
003807  1  13 36                .WORD   LAB_TWOPI-1     ; TWOPI		new function
003809  1  F8 35                .WORD   LAB_VARPTR-1    ; VARPTR()		new function
00380B  1  39 25                .WORD   LAB_LEFT-1      ; LEFT$()
00380D  1  58 25                .WORD   LAB_RIGHT-1     ; RIGHT$()
00380F  1  B1 25                .WORD   LAB_MIDS-1      ; MID$()
003811  1               
003811  1               ; hierarchy and action addresses for operator
003811  1               
003811  1               LAB_OPPT:
003811  1  79                   .BYTE   $79             ; +
003812  1  FC 28                .WORD   LAB_ADD-1
003814  1  79                   .BYTE   $79             ; -
003815  1  E1 28                .WORD   LAB_SUBTRACT-1
003817  1  7B                   .BYTE   $7B             ; *
003818  1  7D 2A                .WORD   LAB_MULTIPLY-1
00381A  1  7B                   .BYTE   $7B             ; /
00381B  1  95 2B                .WORD   LAB_DIVIDE-1
00381D  1  7F                   .BYTE   $7F             ; ^
00381E  1  88 30                .WORD   LAB_POWER-1
003820  1  50                   .BYTE   $50             ; AND
003821  1  8D 19                .WORD   LAB_AND-1
003823  1  46                   .BYTE   $46             ; EOR			new operator
003824  1  73 19                .WORD   LAB_EOR-1
003826  1  46                   .BYTE   $46             ; OR
003827  1  80 19                .WORD   LAB_OR-1
003829  1  56                   .BYTE   $56             ; >>			new operator
00382A  1  64 1A                .WORD   LAB_RSHIFT-1
00382C  1  56                   .BYTE   $56             ; <<			new operator
00382D  1  4C 1A                .WORD   LAB_LSHIFT-1
00382F  1  7D                   .BYTE   $7D             ; >
003830  1  C1 30                .WORD   LAB_GTHAN-1
003832  1  5A                   .BYTE   $5A             ; =
003833  1  CB 18                .WORD   LAB_EQUAL-1
003835  1  64                   .BYTE   $64             ; <
003836  1  AE 19                .WORD   LAB_LTHAN-1
003838  1               
003838  1               ; keywords start with ..
003838  1               ; this is the first character table and must be in alphabetic order
003838  1               
003838  1               TAB_1STC:
003838  1  2A                   .BYTE   "*"
003839  1  2B                   .BYTE   "+"
00383A  1  2D                   .BYTE   "-"
00383B  1  2F                   .BYTE   "/"
00383C  1  3C                   .BYTE   "<"
00383D  1  3D                   .BYTE   "="
00383E  1  3E                   .BYTE   ">"
00383F  1  3F                   .BYTE   "?"
003840  1  41                   .BYTE   "A"
003841  1  42                   .BYTE   "B"
003842  1  43                   .BYTE   "C"
003843  1  44                   .BYTE   "D"
003844  1  45                   .BYTE   "E"
003845  1  46                   .BYTE   "F"
003846  1  47                   .BYTE   "G"
003847  1  48                   .BYTE   "H"
003848  1  49                   .BYTE   "I"
003849  1  4B                   .BYTE   "K"
00384A  1  4C                   .BYTE   "L"
00384B  1  4D                   .BYTE   "M"
00384C  1  4E                   .BYTE   "N"
00384D  1  4F                   .BYTE   "O"
00384E  1  50                   .BYTE   "P"
00384F  1  52                   .BYTE   "R"
003850  1  53                   .BYTE   "S"
003851  1  54                   .BYTE   "T"
003852  1  55                   .BYTE   "U"
003853  1  56                   .BYTE   "V"
003854  1  57                   .BYTE   "W"
003855  1  5E                   .BYTE   "^"
003856  1  00                   .BYTE   $00             ; table terminator
003857  1               
003857  1               ; pointers to keyword tables
003857  1               
003857  1               TAB_CHRT:
003857  1  93 38                .WORD   TAB_STAR        ; table for "*"
003859  1  95 38                .WORD   TAB_PLUS        ; table for "+"
00385B  1  97 38                .WORD   TAB_MNUS        ; table for "-"
00385D  1  99 38                .WORD   TAB_SLAS        ; table for "/"
00385F  1  9B 38                .WORD   TAB_LESS        ; table for "<"
003861  1  9F 38                .WORD   TAB_EQUL        ; table for "="
003863  1  A1 38                .WORD   TAB_MORE        ; table for ">"
003865  1  A5 38                .WORD   TAB_QEST        ; table for "?"
003867  1  A7 38                .WORD   TAB_ASCA        ; table for "A"
003869  1  B7 38                .WORD   TAB_ASCB        ; table for "B"
00386B  1  D0 38                .WORD   TAB_ASCC        ; table for "C"
00386D  1  E7 38                .WORD   TAB_ASCD        ; table for "D"
00386F  1  00 39                .WORD   TAB_ASCE        ; table for "E"
003871  1  0F 39                .WORD   TAB_ASCF        ; table for "F"
003873  1  19 39                .WORD   TAB_ASCG        ; table for "G"
003875  1  26 39                .WORD   TAB_ASCH        ; table for "H"
003877  1  2C 39                .WORD   TAB_ASCI        ; table for "I"
003879  1  3E 39                .WORD   TAB_ASCK        ; table for "K"
00387B  1  42 39                .WORD   TAB_ASCL        ; table for "L"
00387D  1  67 39                .WORD   TAB_ASCM        ; table for "M"
00387F  1  75 39                .WORD   TAB_ASCN        ; table for "N"
003881  1  87 39                .WORD   TAB_ASCO        ; table for "O"
003883  1  8F 39                .WORD   TAB_ASCP        ; table for "P"
003885  1  A4 39                .WORD   TAB_ASCR        ; table for "R"
003887  1  D3 39                .WORD   TAB_ASCS        ; table for "S"
003889  1  FE 39                .WORD   TAB_ASCT        ; table for "T"
00388B  1  12 3A                .WORD   TAB_ASCU        ; table for "U"
00388D  1  23 3A                .WORD   TAB_ASCV        ; table for "V"
00388F  1  2F 3A                .WORD   TAB_ASCW        ; table for "W"
003891  1  3E 3A                .WORD   TAB_POWR        ; table for "^"
003893  1               
003893  1               ; tables for each start character, note if a longer keyword with the same start
003893  1               ; letters as a shorter one exists then it must come first, else the list is in
003893  1               ; alphabetical order as follows ..
003893  1               
003893  1               ; [keyword,token
003893  1               ; [keyword,token]]
003893  1               ; end marker (#$00)
003893  1               
003893  1               TAB_STAR:
003893  1  B9 00                .BYTE   TK_MUL,$00      ; *
003895  1               TAB_PLUS:
003895  1  B7 00                .BYTE   TK_PLUS,$00     ; +
003897  1               TAB_MNUS:
003897  1  B8 00                .BYTE   TK_MINUS,$00    ; -
003899  1               TAB_SLAS:
003899  1  BA 00                .BYTE   TK_DIV,$00      ; /
00389B  1               TAB_LESS:
00389B  1               LBB_LSHIFT:
00389B  1  3C C0                .BYTE   "<",TK_LSHIFT   ; <<	note - "<<" must come before "<"
00389D  1  C3                   .BYTE   TK_LT           ; <
00389E  1  00                   .BYTE   $00
00389F  1               TAB_EQUL:
00389F  1  C2 00                .BYTE   TK_EQUAL,$00    ; =
0038A1  1               TAB_MORE:
0038A1  1               LBB_RSHIFT:
0038A1  1  3E BF                .BYTE   ">",TK_RSHIFT   ; >>	note - ">>" must come before ">"
0038A3  1  C1                   .BYTE   TK_GT           ; >
0038A4  1  00                   .BYTE   $00
0038A5  1               TAB_QEST:
0038A5  1  9F 00                .BYTE   TK_PRINT,$00    ; ?
0038A7  1               TAB_ASCA:
0038A7  1               LBB_ABS:
0038A7  1  42 53 28 C6          .BYTE   "BS(",TK_ABS    ; ABS(
0038AB  1               LBB_AND:
0038AB  1  4E 44 BC             .BYTE   "ND",TK_AND     ; AND
0038AE  1               LBB_ASC:
0038AE  1  53 43 28 D8          .BYTE   "SC(",TK_ASC    ; ASC(
0038B2  1               LBB_ATN:
0038B2  1  54 4E 28 D1          .BYTE   "TN(",TK_ATN    ; ATN(
0038B6  1  00                   .BYTE   $00
0038B7  1               TAB_ASCB:
0038B7  1               LBB_BINS:
0038B7  1  49 4E 24 28          .BYTE   "IN$(",TK_BINS  ; BIN$(
0038BB  1  DD           
0038BC  1               LBB_BITCLR:
0038BC  1  49 54 43 4C          .BYTE   "ITCLR",TK_BITCLR; BITCLR
0038C0  1  52 A8        
0038C2  1               LBB_BITSET:
0038C2  1  49 54 53 45          .BYTE   "ITSET",TK_BITSET; BITSET
0038C6  1  54 A7        
0038C8  1               LBB_BITTST:
0038C8  1  49 54 54 53          .BYTE   "ITTST(",TK_BITTST
0038CC  1  54 28 DE     
0038CF  1               ; BITTST(
0038CF  1  00                   .BYTE   $00
0038D0  1               TAB_ASCC:
0038D0  1               LBB_CALL:
0038D0  1  41 4C 4C 9C          .BYTE   "ALL",TK_CALL   ; CALL
0038D4  1               LBB_CHRS:
0038D4  1  48 52 24 28          .BYTE   "HR$(",TK_CHRS  ; CHR$(
0038D8  1  DB           
0038D9  1               LBB_CLEAR:
0038D9  1  4C 45 41 52          .BYTE   "LEAR",TK_CLEAR ; CLEAR
0038DD  1  A2           
0038DE  1               LBB_CONT:
0038DE  1  4F 4E 54 A0          .BYTE   "ONT",TK_CONT   ; CONT
0038E2  1               LBB_COS:
0038E2  1  4F 53 28 CE          .BYTE   "OS(",TK_COS    ; COS(
0038E6  1  00                   .BYTE   $00
0038E7  1               TAB_ASCD:
0038E7  1               LBB_DATA:
0038E7  1  41 54 41 83          .BYTE   "ATA",TK_DATA   ; DATA
0038EB  1               LBB_DEC:
0038EB  1  45 43 88             .BYTE   "EC",TK_DEC     ; DEC
0038EE  1               LBB_DEEK:
0038EE  1  45 45 4B 28          .BYTE   "EEK(",TK_DEEK  ; DEEK(
0038F2  1  D3           
0038F3  1               LBB_DEF:
0038F3  1  45 46 99             .BYTE   "EF",TK_DEF     ; DEF
0038F6  1               LBB_DIM:
0038F6  1  49 4D 85             .BYTE   "IM",TK_DIM     ; DIM
0038F9  1               LBB_DOKE:
0038F9  1  4F 4B 45 9B          .BYTE   "OKE",TK_DOKE   ; DOKE note - "DOKE" must come before "DO"
0038FD  1               LBB_DO:
0038FD  1  4F 9D                .BYTE   "O",TK_DO       ; DO
0038FF  1  00                   .BYTE   $00
003900  1               TAB_ASCE:
003900  1               LBB_ELSE:
003900  1  4C 53 45 AD          .BYTE   "LSE",TK_ELSE   ; ELSE
003904  1               LBB_END:
003904  1  4E 44 80             .BYTE   "ND",TK_END     ; END
003907  1               LBB_EOR:
003907  1  4F 52 BD             .BYTE   "OR",TK_EOR     ; EOR
00390A  1               LBB_EXP:
00390A  1  58 50 28 CD          .BYTE   "XP(",TK_EXP    ; EXP(
00390E  1  00                   .BYTE   $00
00390F  1               TAB_ASCF:
00390F  1               LBB_FN:
00390F  1  4E AF                .BYTE   "N",TK_FN       ; FN
003911  1               LBB_FOR:
003911  1  4F 52 81             .BYTE   "OR",TK_FOR     ; FOR
003914  1               LBB_FRE:
003914  1  52 45 28 C8          .BYTE   "RE(",TK_FRE    ; FRE(
003918  1  00                   .BYTE   $00
003919  1               TAB_ASCG:
003919  1               LBB_GET:
003919  1  45 54 A5             .BYTE   "ET",TK_GET     ; GET
00391C  1               LBB_GOSUB:
00391C  1  4F 53 55 42          .BYTE   "OSUB",TK_GOSUB ; GOSUB
003920  1  8D           
003921  1               LBB_GOTO:
003921  1  4F 54 4F 89          .BYTE   "OTO",TK_GOTO   ; GOTO
003925  1  00                   .BYTE   $00
003926  1               TAB_ASCH:
003926  1               LBB_HEXS:
003926  1  45 58 24 28          .BYTE   "EX$(",TK_HEXS  ; HEX$(
00392A  1  DC           
00392B  1  00                   .BYTE   $00
00392C  1               TAB_ASCI:
00392C  1               LBB_IF:
00392C  1  46 8B                .BYTE   "F",TK_IF       ; IF
00392E  1               LBB_INC:
00392E  1  4E 43 95             .BYTE   "NC",TK_INC     ; INC
003931  1               LBB_INPUT:
003931  1  4E 50 55 54          .BYTE   "NPUT",TK_INPUT ; INPUT
003935  1  84           
003936  1               LBB_INT:
003936  1  4E 54 28 C5          .BYTE   "NT(",TK_INT    ; INT(
00393A  1               LBB_IRQ:
00393A  1  52 51 A9             .BYTE   "RQ",TK_IRQ     ; IRQ
00393D  1  00                   .BYTE   $00
00393E  1               TAB_ASCK:
00393E  1               LBB_KILL:
00393E  1  49 4C 4C AB          .BYTE   "ILL",TK_KILL   ; KILL
003942  1               TAB_ASCL:
003942  1               LBB_LCASES:
003942  1  43 41 53 45          .BYTE   "CASE$(",TK_LCASES
003946  1  24 28 DA     
003949  1               ; LCASE$(
003949  1               LBB_LEFTS:
003949  1  45 46 54 24          .BYTE   "EFT$(",TK_LEFTS; LEFT$(
00394D  1  28 E4        
00394F  1               LBB_LEN:
00394F  1  45 4E 28 D5          .BYTE   "EN(",TK_LEN    ; LEN(
003953  1               LBB_LET:
003953  1  45 54 87             .BYTE   "ET",TK_LET     ; LET
003956  1               LBB_LIST:
003956  1  49 53 54 A1          .BYTE   "IST",TK_LIST   ; LIST
00395A  1               LBB_LOAD:
00395A  1  4F 41 44 97          .BYTE   "OAD",TK_LOAD   ; LOAD
00395E  1               LBB_LOG:
00395E  1  4F 47 28 CC          .BYTE   "OG(",TK_LOG    ; LOG(
003962  1               LBB_LOOP:
003962  1  4F 4F 50 9E          .BYTE   "OOP",TK_LOOP   ; LOOP
003966  1  00                   .BYTE   $00
003967  1               TAB_ASCM:
003967  1               LBB_MAX:
003967  1  41 58 28 DF          .BYTE   "AX(",TK_MAX    ; MAX(
00396B  1               LBB_MIDS:
00396B  1  49 44 24 28          .BYTE   "ID$(",TK_MIDS  ; MID$(
00396F  1  E6           
003970  1               LBB_MIN:
003970  1  49 4E 28 E0          .BYTE   "IN(",TK_MIN    ; MIN(
003974  1  00                   .BYTE   $00
003975  1               TAB_ASCN:
003975  1               LBB_NEW:
003975  1  45 57 A3             .BYTE   "EW",TK_NEW     ; NEW
003978  1               LBB_NEXT:
003978  1  45 58 54 82          .BYTE   "EXT",TK_NEXT   ; NEXT
00397C  1               LBB_NMI:
00397C  1  4D 49 AA             .BYTE   "MI",TK_NMI     ; NMI
00397F  1               LBB_NOT:
00397F  1  4F 54 B2             .BYTE   "OT",TK_NOT     ; NOT
003982  1               LBB_NULL:
003982  1  55 4C 4C 94          .BYTE   "ULL",TK_NULL   ; NULL
003986  1  00                   .BYTE   $00
003987  1               TAB_ASCO:
003987  1               LBB_OFF:
003987  1  46 46 B6             .BYTE   "FF",TK_OFF     ; OFF
00398A  1               LBB_ON:
00398A  1  4E 93                .BYTE   "N",TK_ON       ; ON
00398C  1               LBB_OR:
00398C  1  52 BE                .BYTE   "R",TK_OR       ; OR
00398E  1  00                   .BYTE   $00
00398F  1               TAB_ASCP:
00398F  1               LBB_PEEK:
00398F  1  45 45 4B 28          .BYTE   "EEK(",TK_PEEK  ; PEEK(
003993  1  D2           
003994  1               LBB_PI:
003994  1  49 E1                .BYTE   "I",TK_PI       ; PI
003996  1               LBB_POKE:
003996  1  4F 4B 45 9A          .BYTE   "OKE",TK_POKE   ; POKE
00399A  1               LBB_POS:
00399A  1  4F 53 28 C9          .BYTE   "OS(",TK_POS    ; POS(
00399E  1               LBB_PRINT:
00399E  1  52 49 4E 54          .BYTE   "RINT",TK_PRINT ; PRINT
0039A2  1  9F           
0039A3  1  00                   .BYTE   $00
0039A4  1               TAB_ASCR:
0039A4  1               LBB_READ:
0039A4  1  45 41 44 86          .BYTE   "EAD",TK_READ   ; READ
0039A8  1               LBB_REM:
0039A8  1  45 4D 91             .BYTE   "EM",TK_REM     ; REM
0039AB  1               LBB_RESTORE:
0039AB  1  45 53 54 4F          .BYTE   "ESTORE",TK_RESTORE
0039AF  1  52 45 8C     
0039B2  1               ; RESTORE
0039B2  1               LBB_RETIRQ:
0039B2  1  45 54 49 52          .BYTE   "ETIRQ",TK_RETIRQ; RETIRQ
0039B6  1  51 8E        
0039B8  1               LBB_RETNMI:
0039B8  1  45 54 4E 4D          .BYTE   "ETNMI",TK_RETNMI; RETNMI
0039BC  1  49 8F        
0039BE  1               LBB_RETURN:
0039BE  1  45 54 55 52          .BYTE   "ETURN",TK_RETURN; RETURN
0039C2  1  4E 90        
0039C4  1               LBB_RIGHTS:
0039C4  1  49 47 48 54          .BYTE   "IGHT$(",TK_RIGHTS
0039C8  1  24 28 E5     
0039CB  1               ; RIGHT$(
0039CB  1               LBB_RND:
0039CB  1  4E 44 28 CB          .BYTE   "ND(",TK_RND    ; RND(
0039CF  1               LBB_RUN:
0039CF  1  55 4E 8A             .BYTE   "UN",TK_RUN     ; RUN
0039D2  1  00                   .BYTE   $00
0039D3  1               TAB_ASCS:
0039D3  1               LBB_SADD:
0039D3  1  41 44 44 28          .BYTE   "ADD(",TK_SADD  ; SADD(
0039D7  1  D4           
0039D8  1               LBB_SAVE:
0039D8  1  41 56 45 98          .BYTE   "AVE",TK_SAVE   ; SAVE
0039DC  1               LBB_SGN:
0039DC  1  47 4E 28 C4          .BYTE   "GN(",TK_SGN    ; SGN(
0039E0  1               LBB_SIN:
0039E0  1  49 4E 28 CF          .BYTE   "IN(",TK_SIN    ; SIN(
0039E4  1               LBB_SPC:
0039E4  1  50 43 28 B0          .BYTE   "PC(",TK_SPC    ; SPC(
0039E8  1               LBB_SQR:
0039E8  1  51 52 28 CA          .BYTE   "QR(",TK_SQR    ; SQR(
0039EC  1               LBB_STEP:
0039EC  1  54 45 50 B3          .BYTE   "TEP",TK_STEP   ; STEP
0039F0  1               LBB_STOP:
0039F0  1  54 4F 50 92          .BYTE   "TOP",TK_STOP   ; STOP
0039F4  1               LBB_STRS:
0039F4  1  54 52 24 28          .BYTE   "TR$(",TK_STRS  ; STR$(
0039F8  1  D6           
0039F9  1               LBB_SWAP:
0039F9  1  57 41 50 A6          .BYTE   "WAP",TK_SWAP   ; SWAP
0039FD  1  00                   .BYTE   $00
0039FE  1               TAB_ASCT:
0039FE  1               LBB_TAB:
0039FE  1  41 42 28 AC          .BYTE   "AB(",TK_TAB    ; TAB(
003A02  1               LBB_TAN:
003A02  1  41 4E 28 D0          .BYTE   "AN(",TK_TAN    ; TAN(
003A06  1               LBB_THEN:
003A06  1  48 45 4E B1          .BYTE   "HEN",TK_THEN   ; THEN
003A0A  1               LBB_TO:
003A0A  1  4F AE                .BYTE   "O",TK_TO       ; TO
003A0C  1               LBB_TWOPI:
003A0C  1  57 4F 50 49          .BYTE   "WOPI",TK_TWOPI ; TWOPI
003A10  1  E2           
003A11  1  00                   .BYTE   $00
003A12  1               TAB_ASCU:
003A12  1               LBB_UCASES:
003A12  1  43 41 53 45          .BYTE   "CASE$(",TK_UCASES
003A16  1  24 28 D9     
003A19  1               ; UCASE$(
003A19  1               LBB_UNTIL:
003A19  1  4E 54 49 4C          .BYTE   "NTIL",TK_UNTIL ; UNTIL
003A1D  1  B4           
003A1E  1               LBB_USR:
003A1E  1  53 52 28 C7          .BYTE   "SR(",TK_USR    ; USR(
003A22  1  00                   .BYTE   $00
003A23  1               TAB_ASCV:
003A23  1               LBB_VAL:
003A23  1  41 4C 28 D7          .BYTE   "AL(",TK_VAL    ; VAL(
003A27  1               LBB_VPTR:
003A27  1  41 52 50 54          .BYTE   "ARPTR(",TK_VPTR; VARPTR(
003A2B  1  52 28 E3     
003A2E  1  00                   .BYTE   $00
003A2F  1               TAB_ASCW:
003A2F  1               LBB_WAIT:
003A2F  1  41 49 54 96          .BYTE   "AIT",TK_WAIT   ; WAIT
003A33  1               LBB_WHILE:
003A33  1  48 49 4C 45          .BYTE   "HILE",TK_WHILE ; WHILE
003A37  1  B5           
003A38  1               LBB_WIDTH:
003A38  1  49 44 54 48          .BYTE   "IDTH",TK_WIDTH ; WIDTH
003A3C  1  A4           
003A3D  1  00                   .BYTE   $00
003A3E  1               TAB_POWR:
003A3E  1  BB 00                .BYTE   TK_POWER,$00    ; ^
003A40  1               
003A40  1               ; new decode table for LIST
003A40  1               ; Table is ..
003A40  1               ; byte - keyword length, keyword first character
003A40  1               ; word - pointer to rest of keyword from dictionary
003A40  1               
003A40  1               ; note if length is 1 then the pointer is ignored
003A40  1               
003A40  1               LAB_KEYT:
003A40  1  03 45                .BYTE   3,'E'
003A42  1  04 39                .WORD   LBB_END         ; END
003A44  1  03 46                .BYTE   3,'F'
003A46  1  11 39                .WORD   LBB_FOR         ; FOR
003A48  1  04 4E                .BYTE   4,'N'
003A4A  1  78 39                .WORD   LBB_NEXT        ; NEXT
003A4C  1  04 44                .BYTE   4,'D'
003A4E  1  E7 38                .WORD   LBB_DATA        ; DATA
003A50  1  05 49                .BYTE   5,'I'
003A52  1  31 39                .WORD   LBB_INPUT       ; INPUT
003A54  1  03 44                .BYTE   3,'D'
003A56  1  F6 38                .WORD   LBB_DIM         ; DIM
003A58  1  04 52                .BYTE   4,'R'
003A5A  1  A4 39                .WORD   LBB_READ        ; READ
003A5C  1  03 4C                .BYTE   3,'L'
003A5E  1  53 39                .WORD   LBB_LET         ; LET
003A60  1  03 44                .BYTE   3,'D'
003A62  1  EB 38                .WORD   LBB_DEC         ; DEC
003A64  1  04 47                .BYTE   4,'G'
003A66  1  21 39                .WORD   LBB_GOTO        ; GOTO
003A68  1  03 52                .BYTE   3,'R'
003A6A  1  CF 39                .WORD   LBB_RUN         ; RUN
003A6C  1  02 49                .BYTE   2,'I'
003A6E  1  2C 39                .WORD   LBB_IF          ; IF
003A70  1  07 52                .BYTE   7,'R'
003A72  1  AB 39                .WORD   LBB_RESTORE     ; RESTORE
003A74  1  05 47                .BYTE   5,'G'
003A76  1  1C 39                .WORD   LBB_GOSUB       ; GOSUB
003A78  1  06 52                .BYTE   6,'R'
003A7A  1  B2 39                .WORD   LBB_RETIRQ      ; RETIRQ
003A7C  1  06 52                .BYTE   6,'R'
003A7E  1  B8 39                .WORD   LBB_RETNMI      ; RETNMI
003A80  1  06 52                .BYTE   6,'R'
003A82  1  BE 39                .WORD   LBB_RETURN      ; RETURN
003A84  1  03 52                .BYTE   3,'R'
003A86  1  A8 39                .WORD   LBB_REM         ; REM
003A88  1  04 53                .BYTE   4,'S'
003A8A  1  F0 39                .WORD   LBB_STOP        ; STOP
003A8C  1  02 4F                .BYTE   2,'O'
003A8E  1  8A 39                .WORD   LBB_ON          ; ON
003A90  1  04 4E                .BYTE   4,'N'
003A92  1  82 39                .WORD   LBB_NULL        ; NULL
003A94  1  03 49                .BYTE   3,'I'
003A96  1  2E 39                .WORD   LBB_INC         ; INC
003A98  1  04 57                .BYTE   4,'W'
003A9A  1  2F 3A                .WORD   LBB_WAIT        ; WAIT
003A9C  1  04 4C                .BYTE   4,'L'
003A9E  1  5A 39                .WORD   LBB_LOAD        ; LOAD
003AA0  1  04 53                .BYTE   4,'S'
003AA2  1  D8 39                .WORD   LBB_SAVE        ; SAVE
003AA4  1  03 44                .BYTE   3,'D'
003AA6  1  F3 38                .WORD   LBB_DEF         ; DEF
003AA8  1  04 50                .BYTE   4,'P'
003AAA  1  96 39                .WORD   LBB_POKE        ; POKE
003AAC  1  04 44                .BYTE   4,'D'
003AAE  1  F9 38                .WORD   LBB_DOKE        ; DOKE
003AB0  1  04 43                .BYTE   4,'C'
003AB2  1  D0 38                .WORD   LBB_CALL        ; CALL
003AB4  1  02 44                .BYTE   2,'D'
003AB6  1  FD 38                .WORD   LBB_DO          ; DO
003AB8  1  04 4C                .BYTE   4,'L'
003ABA  1  62 39                .WORD   LBB_LOOP        ; LOOP
003ABC  1  05 50                .BYTE   5,'P'
003ABE  1  9E 39                .WORD   LBB_PRINT       ; PRINT
003AC0  1  04 43                .BYTE   4,'C'
003AC2  1  DE 38                .WORD   LBB_CONT        ; CONT
003AC4  1  04 4C                .BYTE   4,'L'
003AC6  1  56 39                .WORD   LBB_LIST        ; LIST
003AC8  1  05 43                .BYTE   5,'C'
003ACA  1  D9 38                .WORD   LBB_CLEAR       ; CLEAR
003ACC  1  03 4E                .BYTE   3,'N'
003ACE  1  75 39                .WORD   LBB_NEW         ; NEW
003AD0  1  05 57                .BYTE   5,'W'
003AD2  1  38 3A                .WORD   LBB_WIDTH       ; WIDTH
003AD4  1  03 47                .BYTE   3,'G'
003AD6  1  19 39                .WORD   LBB_GET         ; GET
003AD8  1  04 53                .BYTE   4,'S'
003ADA  1  F9 39                .WORD   LBB_SWAP        ; SWAP
003ADC  1  06 42                .BYTE   6,'B'
003ADE  1  C2 38                .WORD   LBB_BITSET      ; BITSET
003AE0  1  06 42                .BYTE   6,'B'
003AE2  1  BC 38                .WORD   LBB_BITCLR      ; BITCLR
003AE4  1  03 49                .BYTE   3,'I'
003AE6  1  3A 39                .WORD   LBB_IRQ         ; IRQ
003AE8  1  03 4E                .BYTE   3,'N'
003AEA  1  7C 39                .WORD   LBB_NMI         ; NMI
003AEC  1  04 4B                .BYTE   4,'K'
003AEE  1  3E 39                .WORD   LBB_KILL        ; KILL
003AF0  1               
003AF0  1               
003AF0  1               ; secondary commands (can't start a statement)
003AF0  1               
003AF0  1  04 54                .BYTE   4,'T'
003AF2  1  FE 39                .WORD   LBB_TAB         ; TAB
003AF4  1  04 45                .BYTE   4,'E'
003AF6  1  00 39                .WORD   LBB_ELSE        ; ELSE
003AF8  1  02 54                .BYTE   2,'T'
003AFA  1  0A 3A                .WORD   LBB_TO          ; TO
003AFC  1  02 46                .BYTE   2,'F'
003AFE  1  0F 39                .WORD   LBB_FN          ; FN
003B00  1  04 53                .BYTE   4,'S'
003B02  1  E4 39                .WORD   LBB_SPC         ; SPC
003B04  1  04 54                .BYTE   4,'T'
003B06  1  06 3A                .WORD   LBB_THEN        ; THEN
003B08  1  03 4E                .BYTE   3,'N'
003B0A  1  7F 39                .WORD   LBB_NOT         ; NOT
003B0C  1  04 53                .BYTE   4,'S'
003B0E  1  EC 39                .WORD   LBB_STEP        ; STEP
003B10  1  05 55                .BYTE   5,'U'
003B12  1  19 3A                .WORD   LBB_UNTIL       ; UNTIL
003B14  1  05 57                .BYTE   5,'W'
003B16  1  33 3A                .WORD   LBB_WHILE       ; WHILE
003B18  1  03 4F                .BYTE   3,'O'
003B1A  1  87 39                .WORD   LBB_OFF         ; OFF
003B1C  1               
003B1C  1               ; opperators
003B1C  1               
003B1C  1  01 2B                .BYTE   1,'+'
003B1E  1  00 00                .WORD   $0000           ; +
003B20  1  01 2D                .BYTE   1,'-'
003B22  1  00 00                .WORD   $0000           ; -
003B24  1  01 2A                .BYTE   1,'*'
003B26  1  00 00                .WORD   $0000           ; *
003B28  1  01 2F                .BYTE   1,'/'
003B2A  1  00 00                .WORD   $0000           ; /
003B2C  1  01 5E                .BYTE   1,'^'
003B2E  1  00 00                .WORD   $0000           ; ^
003B30  1  03 41                .BYTE   3,'A'
003B32  1  AB 38                .WORD   LBB_AND         ; AND
003B34  1  03 45                .BYTE   3,'E'
003B36  1  07 39                .WORD   LBB_EOR         ; EOR
003B38  1  02 4F                .BYTE   2,'O'
003B3A  1  8C 39                .WORD   LBB_OR          ; OR
003B3C  1  02 3E                .BYTE   2,'>'
003B3E  1  A1 38                .WORD   LBB_RSHIFT      ; >>
003B40  1  02 3C                .BYTE   2,'<'
003B42  1  9B 38                .WORD   LBB_LSHIFT      ; <<
003B44  1  01 3E                .BYTE   1,'>'
003B46  1  00 00                .WORD   $0000           ; >
003B48  1  01 3D                .BYTE   1,'='
003B4A  1  00 00                .WORD   $0000           ; =
003B4C  1  01 3C                .BYTE   1,'<'
003B4E  1  00 00                .WORD   $0000           ; <
003B50  1               
003B50  1               ; functions
003B50  1               
003B50  1  04 53                .BYTE   4,'S'           ;
003B52  1  DC 39                .WORD   LBB_SGN         ; SGN
003B54  1  04 49                .BYTE   4,'I'           ;
003B56  1  36 39                .WORD   LBB_INT         ; INT
003B58  1  04 41                .BYTE   4,'A'           ;
003B5A  1  A7 38                .WORD   LBB_ABS         ; ABS
003B5C  1  04 55                .BYTE   4,'U'           ;
003B5E  1  1E 3A                .WORD   LBB_USR         ; USR
003B60  1  04 46                .BYTE   4,'F'           ;
003B62  1  14 39                .WORD   LBB_FRE         ; FRE
003B64  1  04 50                .BYTE   4,'P'           ;
003B66  1  9A 39                .WORD   LBB_POS         ; POS
003B68  1  04 53                .BYTE   4,'S'           ;
003B6A  1  E8 39                .WORD   LBB_SQR         ; SQR
003B6C  1  04 52                .BYTE   4,'R'           ;
003B6E  1  CB 39                .WORD   LBB_RND         ; RND
003B70  1  04 4C                .BYTE   4,'L'           ;
003B72  1  5E 39                .WORD   LBB_LOG         ; LOG
003B74  1  04 45                .BYTE   4,'E'           ;
003B76  1  0A 39                .WORD   LBB_EXP         ; EXP
003B78  1  04 43                .BYTE   4,'C'           ;
003B7A  1  E2 38                .WORD   LBB_COS         ; COS
003B7C  1  04 53                .BYTE   4,'S'           ;
003B7E  1  E0 39                .WORD   LBB_SIN         ; SIN
003B80  1  04 54                .BYTE   4,'T'           ;
003B82  1  02 3A                .WORD   LBB_TAN         ; TAN
003B84  1  04 41                .BYTE   4,'A'           ;
003B86  1  B2 38                .WORD   LBB_ATN         ; ATN
003B88  1  05 50                .BYTE   5,'P'           ;
003B8A  1  8F 39                .WORD   LBB_PEEK        ; PEEK
003B8C  1  05 44                .BYTE   5,'D'           ;
003B8E  1  EE 38                .WORD   LBB_DEEK        ; DEEK
003B90  1  05 53                .BYTE   5,'S'           ;
003B92  1  D3 39                .WORD   LBB_SADD        ; SADD
003B94  1  04 4C                .BYTE   4,'L'           ;
003B96  1  4F 39                .WORD   LBB_LEN         ; LEN
003B98  1  05 53                .BYTE   5,'S'           ;
003B9A  1  F4 39                .WORD   LBB_STRS        ; STR$
003B9C  1  04 56                .BYTE   4,'V'           ;
003B9E  1  23 3A                .WORD   LBB_VAL         ; VAL
003BA0  1  04 41                .BYTE   4,'A'           ;
003BA2  1  AE 38                .WORD   LBB_ASC         ; ASC
003BA4  1  07 55                .BYTE   7,'U'           ;
003BA6  1  12 3A                .WORD   LBB_UCASES      ; UCASE$
003BA8  1  07 4C                .BYTE   7,'L'           ;
003BAA  1  42 39                .WORD   LBB_LCASES      ; LCASE$
003BAC  1  05 43                .BYTE   5,'C'           ;
003BAE  1  D4 38                .WORD   LBB_CHRS        ; CHR$
003BB0  1  05 48                .BYTE   5,'H'           ;
003BB2  1  26 39                .WORD   LBB_HEXS        ; HEX$
003BB4  1  05 42                .BYTE   5,'B'           ;
003BB6  1  B7 38                .WORD   LBB_BINS        ; BIN$
003BB8  1  07 42                .BYTE   7,'B'           ;
003BBA  1  C8 38                .WORD   LBB_BITTST      ; BITTST
003BBC  1  04 4D                .BYTE   4,'M'           ;
003BBE  1  67 39                .WORD   LBB_MAX         ; MAX
003BC0  1  04 4D                .BYTE   4,'M'           ;
003BC2  1  70 39                .WORD   LBB_MIN         ; MIN
003BC4  1  02 50                .BYTE   2,'P'           ;
003BC6  1  94 39                .WORD   LBB_PI          ; PI
003BC8  1  05 54                .BYTE   5,'T'           ;
003BCA  1  0C 3A                .WORD   LBB_TWOPI       ; TWOPI
003BCC  1  07 56                .BYTE   7,'V'           ;
003BCE  1  27 3A                .WORD   LBB_VPTR        ; VARPTR
003BD0  1  06 4C                .BYTE   6,'L'           ;
003BD2  1  49 39                .WORD   LBB_LEFTS       ; LEFT$
003BD4  1  07 52                .BYTE   7,'R'           ;
003BD6  1  C4 39                .WORD   LBB_RIGHTS      ; RIGHT$
003BD8  1  05 4D                .BYTE   5,'M'           ;
003BDA  1  6B 39                .WORD   LBB_MIDS        ; MID$
003BDC  1               
003BDC  1               ; BASIC messages, mostly error messages
003BDC  1               
003BDC  1               LAB_BAER:
003BDC  1  00 3C                .WORD   ERR_NF          ;$00 NEXT without FOR
003BDE  1  11 3C                .WORD   ERR_SN          ;$02 syntax
003BE0  1  18 3C                .WORD   ERR_RG          ;$04 RETURN without GOSUB
003BE2  1  2D 3C                .WORD   ERR_OD          ;$06 out of data
003BE4  1  39 3C                .WORD   ERR_FC          ;$08 function call
003BE6  1  47 3C                .WORD   ERR_OV          ;$0A overflow
003BE8  1  50 3C                .WORD   ERR_OM          ;$0C out of memory
003BEA  1  5E 3C                .WORD   ERR_US          ;$0E undefined statement
003BEC  1  72 3C                .WORD   ERR_BS          ;$10 array bounds
003BEE  1  7F 3C                .WORD   ERR_DD          ;$12 double dimension array
003BF0  1  90 3C                .WORD   ERR_D0          ;$14 divide by 0
003BF2  1  9F 3C                .WORD   ERR_ID          ;$16 illegal direct
003BF4  1  AE 3C                .WORD   ERR_TM          ;$18 type mismatch
003BF6  1  BC 3C                .WORD   ERR_LS          ;$1A long string
003BF8  1  CC 3C                .WORD   ERR_ST          ;$1C string too complex
003BFA  1  DF 3C                .WORD   ERR_CN          ;$1E continue error
003BFC  1  EE 3C                .WORD   ERR_UF          ;$20 undefined function
003BFE  1  01 3D                .WORD   ERR_LD          ;$22 LOOP without DO
003C00  1               
003C00  1               ; I may implement these two errors to force definition of variables and
003C00  1               ; dimensioning of arrays before use.
003C00  1               
003C00  1               ;	.word ERR_UV		;$24 undefined variable
003C00  1               
003C00  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
003C00  1               
003C00  1               ;	.word ERR_UA		;$26 undimensioned array
003C00  1               
003C00  1               ERR_NF:
003C00  1  4E 45 58 54          .BYTE   "NEXT without FOR",$00
003C04  1  20 77 69 74  
003C08  1  68 6F 75 74  
003C11  1               ERR_SN:
003C11  1  53 79 6E 74          .BYTE   "Syntax",$00
003C15  1  61 78 00     
003C18  1               ERR_RG:
003C18  1  52 45 54 55          .BYTE   "RETURN without GOSUB",$00
003C1C  1  52 4E 20 77  
003C20  1  69 74 68 6F  
003C2D  1               ERR_OD:
003C2D  1  4F 75 74 20          .BYTE   "Out of DATA",$00
003C31  1  6F 66 20 44  
003C35  1  41 54 41 00  
003C39  1               ERR_FC:
003C39  1  46 75 6E 63          .BYTE   "Function call",$00
003C3D  1  74 69 6F 6E  
003C41  1  20 63 61 6C  
003C47  1               ERR_OV:
003C47  1  4F 76 65 72          .BYTE   "Overflow",$00
003C4B  1  66 6C 6F 77  
003C4F  1  00           
003C50  1               ERR_OM:
003C50  1  4F 75 74 20          .BYTE   "Out of memory",$00
003C54  1  6F 66 20 6D  
003C58  1  65 6D 6F 72  
003C5E  1               ERR_US:
003C5E  1  55 6E 64 65          .BYTE   "Undefined statement",$00
003C62  1  66 69 6E 65  
003C66  1  64 20 73 74  
003C72  1               ERR_BS:
003C72  1  41 72 72 61          .BYTE   "Array bounds",$00
003C76  1  79 20 62 6F  
003C7A  1  75 6E 64 73  
003C7F  1               ERR_DD:
003C7F  1  44 6F 75 62          .BYTE   "Double dimension",$00
003C83  1  6C 65 20 64  
003C87  1  69 6D 65 6E  
003C90  1               ERR_D0:
003C90  1  44 69 76 69          .BYTE   "Divide by zero",$00
003C94  1  64 65 20 62  
003C98  1  79 20 7A 65  
003C9F  1               ERR_ID:
003C9F  1  49 6C 6C 65          .BYTE   "Illegal direct",$00
003CA3  1  67 61 6C 20  
003CA7  1  64 69 72 65  
003CAE  1               ERR_TM:
003CAE  1  54 79 70 65          .BYTE   "Type mismatch",$00
003CB2  1  20 6D 69 73  
003CB6  1  6D 61 74 63  
003CBC  1               ERR_LS:
003CBC  1  53 74 72 69          .BYTE   "String too long",$00
003CC0  1  6E 67 20 74  
003CC4  1  6F 6F 20 6C  
003CCC  1               ERR_ST:
003CCC  1  53 74 72 69          .BYTE   "String too complex",$00
003CD0  1  6E 67 20 74  
003CD4  1  6F 6F 20 63  
003CDF  1               ERR_CN:
003CDF  1  43 61 6E 27          .BYTE   "Can't continue",$00
003CE3  1  74 20 63 6F  
003CE7  1  6E 74 69 6E  
003CEE  1               ERR_UF:
003CEE  1  55 6E 64 65          .BYTE   "Undefined function",$00
003CF2  1  66 69 6E 65  
003CF6  1  64 20 66 75  
003D01  1               ERR_LD:
003D01  1  4C 4F 4F 50          .BYTE   "LOOP without DO",$00
003D05  1  20 77 69 74  
003D09  1  68 6F 75 74  
003D11  1               
003D11  1               ;ERR_UV	.byte	"Undefined variable",$00
003D11  1               
003D11  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
003D11  1               
003D11  1               ;ERR_UA	.byte	"Undimensioned array",$00
003D11  1               
003D11  1               LAB_BMSG:
003D11  1  0D 0A 42 72          .BYTE   $0D,$0A,"Break",$00
003D15  1  65 61 6B 00  
003D19  1               LAB_EMSG:
003D19  1  20 45 72 72          .BYTE   " Error",$00
003D1D  1  6F 72 00     
003D20  1               LAB_LMSG:
003D20  1  20 69 6E 20          .BYTE   " in line ",$00
003D24  1  6C 69 6E 65  
003D28  1  20 00        
003D2A  1               LAB_RMSG:
003D2A  1  0D 0A 52 65          .BYTE   $0D,$0A,"Ready",$0D,$0A,$00
003D2E  1  61 64 79 0D  
003D32  1  0A 00        
003D34  1               
003D34  1               LAB_IMSG:
003D34  1  20 45 78 74          .BYTE   " Extra ignored",$0D,$0A,$00
003D38  1  72 61 20 69  
003D3C  1  67 6E 6F 72  
003D45  1               LAB_REDO:
003D45  1  20 52 65 64          .BYTE   " Redo from start",$0D,$0A,$00
003D49  1  6F 20 66 72  
003D4D  1  6F 6D 20 73  
003D58  1               
003D58  1               AA_end_basic:
003D58  1               
003D58  1               
003D58  1               
003D58  1               ; system dependant i/o vectors
003D58  1               ; these are in RAM and are set by the monitor at start-up
003D58  1               
003D58  1               V_INPT: ; non halting scan input device
003D58  1               BYTEIN:
003D58  1  8C 97 3D             STY     DBGY            ;
003D5B  1  8E 96 3D             STX     DBGX            ;
003D5E  1  A2 0B                LDX     #11             ;
003D60  1  20 99 3D             JSR     PEM             ;
003D63  1  C9 00                CMP     #$00            ;
003D65  1  F0 0D                BEQ     LAB_nobyw       ; branch if no byte waiting
003D67  1  A2 06                LDX     #6              ;
003D69  1  20 99 3D             JSR     PEM             ;
003D6C  1  AC 97 3D             LDY     DBGY
003D6F  1  AE 96 3D             LDX     DBGX
003D72  1  38                   SEC                     ; flag byte received
003D73  1  60                   RTS
003D74  1               LAB_nobyw:
003D74  1  AC 97 3D             LDY     DBGY
003D77  1  AE 96 3D             LDX     DBGX
003D7A  1  18                   CLC                     ; flag no byte received
003D7B  1  60                   RTS                     ;
003D7C  1               
003D7C  1               V_OUTP: ; send byte to output device
003D7C  1               BYTEOUT:
003D7C  1  8D 98 3D             STA     DBGA
003D7F  1  8C 97 3D             STY     DBGY
003D82  1  8E 96 3D             STX     DBGX
003D85  1  A2 02                LDX     #2              ;
003D87  1  20 99 3D             JSR     PEM             ;
003D8A  1  AD 98 3D             LDA     DBGA
003D8D  1  AC 97 3D             LDY     DBGY
003D90  1  AE 96 3D             LDX     DBGX
003D93  1  60                   RTS
003D94  1               
003D94  1               
003D94  1               PEMVEC:
003D94  1  00 00                .WORD   $0000
003D96  1               
003D96  1               DBGX:
003D96  1  00                   .BYTE   0
003D97  1               DBGY:
003D97  1  00                   .BYTE   0
003D98  1               DBGA:
003D98  1  00                   .BYTE   0
003D99  1               
003D99  1               
003D99  1               
003D99  1               PEM:
003D99  1                       .IFDEF  DUODYNE
003D99  1  4C 03 01             JMP     $0103
003D9C  1                       .ELSE
003D9C  1                       JMP     (PEMVEC)
003D9C  1                       .ENDIF
003D9C  1               
003D9C  1               LAB_KILL:
003D9C  1               RETURN_TO_OS:
003D9C  1  4C 00 01             JMP     $0100
003D9F  1               
003D9F  1               
003D9F  1               
003D9F  1               V_SAVE: ; save BASIC program
003D9F  1               DOS65SAVE:
003D9F  1  20 A8 3F             JSR     DOS65FCBPREP    ; parse parameters into FCB
003DA2  1  B0 29                BCS     DOS65SAVE_ERR1  ; Error?, if so abort
003DA4  1  A2 0D                LDX     #13             ;
003DA6  1  20 99 3D             JSR     PEM             ;
003DA9  1  A9 93                LDA     #<FCB           ; CREATE File
003DAB  1  A0 40                LDY     #>FCB           ;
003DAD  1  A2 16                LDX     #22             ;
003DAF  1  20 99 3D             JSR     PEM             ;
003DB2  1  A9 00                LDA     #0              ; clear
003DB4  1  8D B3 40             STA     FCB+32          ; record number
003DB7  1  A9 93                LDA     #<FCB           ; Open File
003DB9  1  A0 40                LDY     #>FCB           ;
003DBB  1  A2 0F                LDX     #15             ;
003DBD  1  20 99 3D             JSR     PEM             ;
003DC0  1  C9 FF                CMP     #$FF            ; error?, if NOT, continue
003DC2  1  D0 0C                BNE     DOS65SAVE_1     ;
003DC4  1               DOS65SAVE_ERR:
003DC4  1  A9 6E                LDA     #<FILEERROR2    ; NO, ERROR OUT
003DC6  1  A0 40                LDY     #>FILEERROR2
003DC8  1  A2 09                LDX     #9              ; Print error message
003DCA  1  20 99 3D             JSR     PEM             ;
003DCD  1               DOS65SAVE_ERR1:
003DCD  1  4C 95 12             JMP     LAB_REM         ; comment out the remainder of the line (if any)
003DD0  1               DOS65SAVE_1:
003DD0  1  A9 B4                LDA     #<FCBBUFFER     ; SETUP BUFFER
003DD2  1  85 EB                STA     FCBPTR          ; STORE DEST BUFFER IN FCBPTR
003DD4  1  A0 40                LDY     #>FCBBUFFER     ;
003DD6  1  84 EC                STY     FCBPTR+1        ;
003DD8  1  A2 1A                LDX     #26             ; Setup Buffer
003DDA  1  20 99 3D             JSR     PEM             ;
003DDD  1  20 73 3E             JSR     DOS65SAVE_CONTROL;
003DE0  1               DOS65SAVE_2:
003DE0  1  A5 79                LDA     <Smeml          ; All is well, file opened and continue
003DE2  1  85 ED                STA     FCBPTR+2        ; point to base of RAM
003DE4  1  A5 7A                LDA     <Smemh          ;
003DE6  1  85 EE                STA     FCBPTR+3        ;
003DE8  1  A2 00                LDX     #$00            ; x=0 (null counter)
003DEA  1               DOS65SAVE_2A:
003DEA  1  A0 00                LDY     #$00            ; y=0 (Loop Index)
003DEC  1               DOS65SAVE_3:
003DEC  1  8B DA A2 01          LDAINDIRECTY FCBPTR+2   ; load from RAM
003DF0  1  B5 ED C9 00  
003DF4  1  D0 04 A2 00  
003E02  1  8B DA 48 A2          STAINDIRECTY FCBPTR     ; save to Buffer
003E06  1  01 B5 EB C9  
003E0A  1  00 D0 04 A2  
003E18  1  C9 00                CMP     #$00            ; is Zero?
003E1A  1  D0 10                BNE     DOS65SAVE_3A    ; No, continue
003E1C  1  E8                   INX                     ; yes, bump Null Counter
003E1D  1  E0 03                CPX     #$03            ; Three nulls in a row?
003E1F  1  D0 0D                BNE     DOS65SAVE_3B    ; no, continue
003E21  1  A9 90                LDA     #$90            ; yes, signal end
003E23  1  85 ED                STA     FCBPTR+2        ;
003E25  1  A9 B7                LDA     #>Ram_top-1     ; yes, signal end
003E27  1  85 EE                STA     FCBPTR+3        ;
003E29  1  4C 33 3E             JMP     DOS65SAVE_3C
003E2C  1               DOS65SAVE_3A:                   ;
003E2C  1  A2 00                LDX     #$00            ; prior char not null, reset null counter
003E2E  1               DOS65SAVE_3B:                   ;
003E2E  1  C8                   INY                     ; bump index
003E2F  1  C0 80                CPY     #$80            ; end of buffer?
003E31  1  D0 B9                BNE     DOS65SAVE_3     ; no, loop
003E33  1               DOS65SAVE_3C:
003E33  1  A9 93                LDA     #<FCB           ; Write record in buffer to disk file
003E35  1  A0 40                LDY     #>FCB           ;
003E37  1  A2 15                LDX     #21             ;
003E39  1  20 99 3D             JSR     PEM             ;
003E3C  1  29 FE                AND     #$FE            ; strip out extension
003E3E  1  C9 00                CMP     #$00            ; is error
003E40  1  D0 82                BNE     DOS65SAVE_ERR   ; ERROR, do error handling
003E42  1  18                   CLC                     ;
003E43  1  A5 ED                LDA     FCBPTR+2        ; add $80 to base counter
003E45  1  69 80                ADC     #$80            ;
003E47  1  85 ED                STA     FCBPTR+2        ;
003E49  1  90 9F                BCC     DOS65SAVE_2A    ; is carry?, no loop
003E4B  1  18                   CLC                     ; yes, carry, inc high byte
003E4C  1  A5 EE                LDA     FCBPTR+3        ;
003E4E  1  69 01                ADC     #$01            ;
003E50  1  85 EE                STA     FCBPTR+3        ;
003E52  1  C9 B8                CMP     #>Ram_top       ; are we at the end of RAM?
003E54  1  F0 03                BEQ     DOS65SAVE_4
003E56  1  4C EA 3D             JMP     DOS65SAVE_2A
003E59  1               DOS65SAVE_4:
003E59  1  A9 93                LDA     #<FCB           ;
003E5B  1  A0 40                LDY     #>FCB           ;
003E5D  1  A2 10                LDX     #16             ;
003E5F  1  20 99 3D             JSR     PEM             ;
003E62  1  C9 FF                CMP     #$FF            ;
003E64  1  D0 03                BNE     DOS65SAVE_5     ;
003E66  1  4C C4 3D             JMP     DOS65SAVE_ERR   ; ERROR, DISPLAY IT
003E69  1               DOS65SAVE_5
003E69  1  A9 2A                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
003E6B  1  A0 3D                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
003E6D  1  20 34 15             JSR     LAB_18C3
003E70  1  4C 4B 0B             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
003E73  1               
003E73  1               
003E73  1               
003E73  1               DOS65SAVE_CONTROL:
003E73  1  A9 60                LDA     #$60            ; SAVE 80H OF CONTROL DATA
003E75  1  85 ED                STA     FCBPTR+2        ;
003E77  1  A9 00                LDA     #$00            ;
003E79  1  85 EE                STA     FCBPTR+3        ;
003E7B  1  A0 00                LDY     #$00            ; y=0 (Loop Index)
003E7D  1  A2 00                LDX     #$00            ; x=0 (null counter)
003E7F  1               DOS65SAVE_CONTROL1:
003E7F  1  8B DA A2 01          LDAINDIRECTY FCBPTR+2   ; load from RAM
003E83  1  B5 ED C9 00  
003E87  1  D0 04 A2 00  
003E95  1  8B DA 48 A2          STAINDIRECTY FCBPTR     ; save to Buffer
003E99  1  01 B5 EB C9  
003E9D  1  00 D0 04 A2  
003EAB  1  C8                   INY
003EAC  1  98                   TYA
003EAD  1  C9 80                CMP     #$80            ; is END?
003EAF  1  D0 CE                BNE     DOS65SAVE_CONTROL1; No, continue
003EB1  1  A9 93                LDA     #<FCB           ; Write record in buffer to disk file
003EB3  1  A0 40                LDY     #>FCB           ;
003EB5  1  A2 15                LDX     #21             ;
003EB7  1  20 99 3D             JSR     PEM             ;
003EBA  1  60                   RTS
003EBB  1               
003EBB  1               
003EBB  1               V_LOAD: ; load BASIC program
003EBB  1               DOS65LOAD:
003EBB  1  20 A8 3F             JSR     DOS65FCBPREP    ; parse parameters into FCB
003EBE  1  B0 20                BCS     DOS65LOAD_ERR1  ; Error?, if so abort
003EC0  1  A2 0D                LDX     #13             ;
003EC2  1  20 99 3D             JSR     PEM             ;
003EC5  1  A9 00                LDA     #0              ; clear
003EC7  1  8D B3 40             STA     FCB+32          ; record number
003ECA  1  A9 93                LDA     #<FCB           ; Open File
003ECC  1  A0 40                LDY     #>FCB           ;
003ECE  1  A2 0F                LDX     #15             ;
003ED0  1  20 99 3D             JSR     PEM             ;
003ED3  1  C9 FF                CMP     #$FF            ; error?, if NOT, continue
003ED5  1  D0 0C                BNE     DOS65LOAD_1     ;
003ED7  1               DOS65LOAD_ERR:
003ED7  1  A9 6E                LDA     #<FILEERROR2    ; NO, ERROR OUT
003ED9  1  A0 40                LDY     #>FILEERROR2
003EDB  1  A2 09                LDX     #9              ; Print error message
003EDD  1  20 99 3D             JSR     PEM             ;
003EE0  1               DOS65LOAD_ERR1:
003EE0  1  4C 95 12             JMP     LAB_REM         ; comment out the remainder of the line (if any)
003EE3  1               DOS65LOAD_1:
003EE3  1  A9 B4                LDA     #<FCBBUFFER     ; SETUP BUFFER
003EE5  1  85 EB                STA     FCBPTR          ; STORE DEST BUFFER IN FCBPTR
003EE7  1  A0 40                LDY     #>FCBBUFFER     ;
003EE9  1  A2 1A                LDX     #26             ; Setup Buffer
003EEB  1  20 99 3D             JSR     PEM             ;
003EEE  1  20 65 3F             JSR     DOS65LOAD_CONTROL;
003EF1  1               DOS65LOAD_2:
003EF1  1  A5 79                LDA     <Smeml          ; All is well, file opened and continue
003EF3  1  85 ED                STA     FCBPTR+2        ; point to base of RAM
003EF5  1  A5 7A                LDA     <Smemh          ;
003EF7  1  85 EE                STA     FCBPTR+3        ;
003EF9  1  4C 41 3F             JMP     DOS65LOAD_3C
003EFC  1               DOS65LOAD_3:
003EFC  1  8B DA A2 01          LDAINDIRECTY FCBPTR     ; load from BUFFER
003F00  1  B5 EB C9 00  
003F04  1  D0 04 A2 00  
003F12  1  8B DA 48 A2          STAINDIRECTY FCBPTR+2   ; save to RAM
003F16  1  01 B5 ED C9  
003F1A  1  00 D0 04 A2  
003F28  1  C8                   INY                     ; bump index
003F29  1  C0 80                CPY     #$80            ; end of buffer?
003F2B  1  D0 CF                BNE     DOS65LOAD_3     ; no, loop
003F2D  1               
003F2D  1  18                   CLC                     ;
003F2E  1  A5 ED                LDA     FCBPTR+2        ; add $80 to base counter
003F30  1  69 80                ADC     #$80            ;
003F32  1  85 ED                STA     FCBPTR+2        ;
003F34  1  90 0B                BCC     DOS65LOAD_3C    ; is carry?, no SKIP
003F36  1  18                   CLC                     ; yes, carry, inc high byte
003F37  1  A5 EE                LDA     FCBPTR+3        ;
003F39  1  69 01                ADC     #$01            ;
003F3B  1  85 EE                STA     FCBPTR+3        ;
003F3D  1  C9 B8                CMP     #>Ram_top       ; are we at the end of RAM?
003F3F  1  F0 11                BEQ     DOS65LOAD_4
003F41  1               
003F41  1               DOS65LOAD_3C:
003F41  1  A9 93                LDA     #<FCB           ; READ record buffer from disk file
003F43  1  A0 40                LDY     #>FCB           ;
003F45  1  20 26 40             JSR     RDERCR          ;
003F48  1  A0 00                LDY     #$00            ; RESET INDEX
003F4A  1  C9 00                CMP     #$00            ; is error or EOF
003F4C  1  F0 AE                BEQ     DOS65LOAD_3     ;
003F4E  1  C9 01                CMP     #$01            ; EOF?
003F50  1  D0 85                BNE     DOS65LOAD_ERR   ; ERROR, do error handling
003F52  1               DOS65LOAD_4:
003F52  1  A9 93                LDA     #<FCB           ;
003F54  1  A0 40                LDY     #>FCB           ;
003F56  1  A2 10                LDX     #16             ;
003F58  1  20 99 3D             JSR     PEM             ;
003F5B  1  A9 2A                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
003F5D  1  A0 3D                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
003F5F  1  20 34 15             JSR     LAB_18C3
003F62  1  4C 4B 0B             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
003F65  1               
003F65  1               DOS65LOAD_CONTROL:
003F65  1  A9 60                LDA     #$60            ; RESTORE CONTORL DATA
003F67  1  85 ED                STA     FCBPTR+2        ; point to base of RAM
003F69  1  A9 00                LDA     #$00            ;
003F6B  1  85 EE                STA     FCBPTR+3        ;
003F6D  1               
003F6D  1  A9 93                LDA     #<FCB           ; READ record buffer from disk file
003F6F  1  A0 40                LDY     #>FCB           ;
003F71  1  A2 14                LDX     #20             ;
003F73  1  20 99 3D             JSR     PEM             ;
003F76  1               
003F76  1               DOS65LOAD_CONTROL1:
003F76  1  8B DA A2 01          LDAINDIRECTY FCBPTR     ; load from BUFFER
003F7A  1  B5 EB C9 00  
003F7E  1  D0 04 A2 00  
003F8C  1  8B DA 48 A2          STAINDIRECTY FCBPTR+2   ; save to RAM
003F90  1  01 B5 ED C9  
003F94  1  00 D0 04 A2  
003FA2  1  C8                   INY                     ; bump index
003FA3  1  C0 80                CPY     #$80            ; end of buffer?
003FA5  1  D0 CF                BNE     DOS65LOAD_CONTROL1; no, loop
003FA7  1  60                   RTS
003FA8  1               
003FA8  1               DOS65FCBPREP:
003FA8  1                       .IFDEF  DUODYNE
003FA8  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
003FAC  1                       .ELSE
003FAC  1                       JSR     LAB_GBYT        ; scan memory
003FAC  1                       .ENDIF
003FAC  1               
003FAC  1  38                   SEC                     ;
003FAD  1  E9 40                SBC     #64             ; PARSE DRIVE NUMBER
003FAF  1  8D 93 40             STA     DOSDRIVE        ; STORE IT IN FCB
003FB2  1                       .IFDEF  DUODYNE
003FB2  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003FB6  1                       .ELSE
003FB6  1                       JSR     LAB_IGBY        ; increment and scan memory
003FB6  1                       .ENDIF
003FB6  1               
003FB6  1  C9 3A                CMP     #':'            ;
003FB8  1  F0 0E                BEQ     DOS65FCBPREP_1  ; YES, IT WAS A DRIVE, CONTINUE
003FBA  1  A9 43                LDA     #<FILEERROR1    ; NO, ERROR OUT
003FBC  1  A0 40                LDY     #>FILEERROR1
003FBE  1  A2 09                LDX     #9
003FC0  1  20 99 3D             JSR     PEM
003FC3  1  20 95 12             JSR     LAB_REM
003FC6  1  38                   SEC
003FC7  1  60                   RTS
003FC8  1               DOS65FCBPREP_1:
003FC8  1  A9 93                LDA     #<FCB           ; SETUP FCBPTR
003FCA  1  85 EB                STA     FCBPTR          ;
003FCC  1  A9 40                LDA     #>FCB           ;
003FCE  1  85 EC                STA     FCBPTR+1        ;
003FD0  1  A0 01                LDY     #$01            ; POINT Y TO FCB FILE NAME
003FD2  1  A9 20                LDA     #$20            ; LOAD SPACE CHAR INTO A
003FD4  1               DOS65FCBPREP_1A:                ; BLANK OUT FCB
003FD4  1  8B DA 48 A2          STAINDIRECTY FCBPTR     ;
003FD8  1  01 B5 EB C9  
003FDC  1  00 D0 04 A2  
003FEA  1  C8                   INY                     ;
003FEB  1  C0 09                CPY     #$09            ; IS DONE
003FED  1  D0 E5                BNE     DOS65FCBPREP_1A ; NO, LOOP
003FEF  1  A0 01                LDY     #$01            ; POINT Y TO FCB FILE NAME
003FF1  1               DOS65FCBPREP_2:                 ; COPY FILE NAME PARAMETER INTO FCB
003FF1  1                       .IFDEF  DUODYNE
003FF1  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003FF5  1                       .ELSE
003FF5  1                       JSR     LAB_IGBY        ; increment and scan memory
003FF5  1                       .ENDIF
003FF5  1               
003FF5  1  F0 1E                BEQ     DOS65FCBPREP_3  ;
003FF7  1  8B DA 48 A2          STAINDIRECTY FCBPTR     ;
003FFB  1  01 B5 EB C9  
003FFF  1  00 D0 04 A2  
00400D  1  C8                   INY                     ;
00400E  1  C0 09                CPY     #$09            ;
004010  1  F0 03                BEQ     DOS65FCBPREP_3  ;
004012  1  4C F1 3F             JMP     DOS65FCBPREP_2  ;
004015  1               DOS65FCBPREP_3:                 ;
004015  1  18                   CLC
004016  1  60                   RTS                     ;
004017  1               
004017  1               ;SUBROUTINES
004017  1               ;OPEN FILE
004017  1               OPNFIL:
004017  1  A2 0F                LDX     #15
004019  1  4C 99 3D             JMP     PEM
00401C  1               ;CLOSE FILE
00401C  1               CLSFIL:
00401C  1  A2 10                LDX     #16
00401E  1  4C 99 3D             JMP     PEM
004021  1               ;DELETE FILE
004021  1               DLTFIL:
004021  1  A2 13                LDX     #19
004023  1  4C 99 3D             JMP     PEM
004026  1               ;READ RECORD
004026  1               RDERCR:
004026  1  A2 14                LDX     #20
004028  1  4C 99 3D             JMP     PEM
00402B  1               ;WRITE RECORD
00402B  1               WRTRCR:
00402B  1  A2 15                LDX     #21
00402D  1  4C 99 3D             JMP     PEM
004030  1               ;CREATE FILE
004030  1               CRTFIL:
004030  1  A2 16                LDX     #22
004032  1  4C 99 3D             JMP     PEM
004035  1               ;RENAME FILE
004035  1               RNMFIL:
004035  1  A2 17                LDX     #23
004037  1  4C 99 3D             JMP     PEM
00403A  1               ;SET BUFFER
00403A  1               SETBUF:
00403A  1  A2 1A                LDX     #26
00403C  1  4C 99 3D             JMP     PEM
00403F  1               
00403F  1               
00403F  1               VDOS65SAVE:
00403F  1  9F 3D                .WORD   DOS65SAVE
004041  1               VDOS65LOAD:
004041  1  BB 3E                .WORD   DOS65LOAD
004043  1               FILEERROR1:
004043  1  2A 2A 20 4E          .BYTE   "** NO DRIVE SPECIFIED, OPERATION ABORTED"
004047  1  4F 20 44 52  
00404B  1  49 56 45 20  
00406B  1  0D 0A 24             .BYTE   $0D,$0A,'$'
00406E  1               FILEERROR2:
00406E  1  2A 2A 20 44          .BYTE   "** DOS/65 ERROR, OPERATION ABORTED"
004072  1  4F 53 2F 36  
004076  1  35 20 45 52  
004090  1  0D 0A 24             .BYTE   $0D,$0A,'$'
004093  1               FCB:
004093  1               DOSDRIVE:
004093  1  00                   .BYTE   0               ; DRIVE NUMBER
004094  1               DOSFN:
004094  1  20 20 20 20          .BYTE   "        "      ; FILE NAME
004098  1  20 20 20 20  
00409C  1               DOSEX:
00409C  1  42 41 53             .BYTE   "BAS"           ; EXTENSION
00409F  1               DOSET:
00409F  1  00 00 00             .BYTE   0,0,0           ; EXTENT
0040A2  1               DOSNR:
0040A2  1  00                   .BYTE   0               ; NUMBER OF RECORDS IN FILE
0040A3  1               DOSBL:
0040A3  1  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0 ; BLOCKS IN FILE
0040A7  1  00 00 00 00  
0040AB  1  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0 ;
0040AF  1  00 00 00 00  
0040B3  1               DOSNX:
0040B3  1  00                   .BYTE   0               ; NEXT RECORD
0040B4  1               FCBBUFFER:
0040B4  1               ENDOFBASIC:
0040B4  1  44 45 52 49          .BYTE   "DERIVED FROM ehBASIC"
0040B8  1  56 45 44 20  
0040BC  1  46 52 4F 4D  
0040C8  1               
0040C8  1               
0040C8  1               ; Ibuffs can now be anywhere in RAM AS LONG AS IT IS BEFORE RAM_BASE AND IS NOT PAGE ALIGNED!, ensure that the max length is < $80
0040C8  1               
0040C8  1               Ibuffs          = (ENDOFBASIC & $FF00)+$181
0040C8  1               Ibuffe          = Ibuffs+$47    ; end of input buffer
0040C8  1               
0040C8  1               Ram_base        = (Ibuffe & $FF00)+$100; start of user RAM (set as needed, should be page aligned)
0040C8  1               Ram_top         = $B800         ; end of user RAM+1 (set as needed, should be page aligned)
0040C8  1               
0040C8  1               
0040C8  1                       .END
